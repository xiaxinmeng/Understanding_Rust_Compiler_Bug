{"sha": "8a2e2dd665f09d93bc80022c221e8f8000575107", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMmUyZGQ2NjVmMDlkOTNiYzgwMDIyYzIyMWU4ZjgwMDA1NzUxMDc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-16T08:36:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-16T08:36:09Z"}, "message": "Merge pull request #56 from oli-obk/rustc_run_pass\n\nvarious things that allow miri to crash less and execute more code", "tree": {"sha": "5e159ddc2bd7b38d1787adcb1fb52cd9c1d3ac03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e159ddc2bd7b38d1787adcb1fb52cd9c1d3ac03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a2e2dd665f09d93bc80022c221e8f8000575107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a2e2dd665f09d93bc80022c221e8f8000575107", "html_url": "https://github.com/rust-lang/rust/commit/8a2e2dd665f09d93bc80022c221e8f8000575107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a2e2dd665f09d93bc80022c221e8f8000575107/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f731766805a32eb2cb23766057271c842fdf1724", "url": "https://api.github.com/repos/rust-lang/rust/commits/f731766805a32eb2cb23766057271c842fdf1724", "html_url": "https://github.com/rust-lang/rust/commit/f731766805a32eb2cb23766057271c842fdf1724"}, {"sha": "31bbeb9eff7b11554a87f0647fa9e542cd77597a", "url": "https://api.github.com/repos/rust-lang/rust/commits/31bbeb9eff7b11554a87f0647fa9e542cd77597a", "html_url": "https://github.com/rust-lang/rust/commit/31bbeb9eff7b11554a87f0647fa9e542cd77597a"}], "stats": {"total": 140, "additions": 99, "deletions": 41}, "files": [{"sha": "7bc70b08cc76eff5378f1ae0ab39e8fbbe7daaaf", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a2e2dd665f09d93bc80022c221e8f8000575107/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a2e2dd665f09d93bc80022c221e8f8000575107/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=8a2e2dd665f09d93bc80022c221e8f8000575107", "patch": "@@ -1093,12 +1093,20 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n         use rustc::util::ppaux;\n         use std::fmt;\n         struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n+        impl<'tcx> ::std::panic::UnwindSafe for Instance<'tcx> {}\n+        impl<'tcx> ::std::panic::RefUnwindSafe for Instance<'tcx> {}\n         impl<'tcx> fmt::Display for Instance<'tcx> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[])\n             }\n         }\n-        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+        let inst = Instance(def_id, substs);\n+        match ::std::panic::catch_unwind(|| {\n+            format!(\"inside call to {}\", inst)\n+        }) {\n+            Ok(msg) => err.span_note(span, &msg),\n+            Err(_) => err.span_note(span, &format!(\"ppaux::parameterized failed: {:?}, {:?}\", def_id, substs)),\n+        };\n     }\n     err.emit();\n }"}, {"sha": "d8edad79f1ebfc8acd6a9aef7c71bece8297b394", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8a2e2dd665f09d93bc80022c221e8f8000575107/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a2e2dd665f09d93bc80022c221e8f8000575107/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=8a2e2dd665f09d93bc80022c221e8f8000575107", "patch": "@@ -182,29 +182,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // Only trait methods can have a Self parameter.\n                 let (resolved_def_id, resolved_substs) =\n                     if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n-                        self.trait_method(trait_id, def_id, substs, arg_srcs.get_mut(0))?\n+                        self.trait_method(trait_id, def_id, substs, &mut arg_srcs)?\n                     } else {\n                         (def_id, substs)\n                     };\n \n-                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n-                    arg_srcs.pop();\n-                    let last_arg = args.last().unwrap();\n-                    let last = self.eval_operand(last_arg)?;\n-                    let last_ty = self.operand_ty(last_arg);\n-                    let last_layout = self.type_layout(last_ty);\n-                    match (&last_ty.sty, last_layout) {\n-                        (&ty::TyTuple(fields),\n-                         &Layout::Univariant { ref variant, .. }) => {\n-                            let offsets = iter::once(0)\n-                                .chain(variant.offset_after_field.iter()\n-                                    .map(|s| s.bytes()));\n-                            for (offset, ty) in offsets.zip(fields) {\n-                                let src = last.offset(offset as isize);\n-                                arg_srcs.push((src, ty));\n+                if fn_ty.abi == Abi::RustCall {\n+                    if let Some((last, last_ty)) = arg_srcs.pop() {\n+                        let last_layout = self.type_layout(last_ty);\n+                        match (&last_ty.sty, last_layout) {\n+                            (&ty::TyTuple(fields),\n+                             &Layout::Univariant { ref variant, .. }) => {\n+                                let offsets = iter::once(0)\n+                                    .chain(variant.offset_after_field.iter()\n+                                        .map(|s| s.bytes()));\n+                                for (offset, ty) in offsets.zip(fields) {\n+                                    let src = last.offset(offset as isize);\n+                                    arg_srcs.push((src, ty));\n+                                }\n                             }\n+                            ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n                         }\n-                        ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n                     }\n                 }\n \n@@ -300,6 +298,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n \n+            \"ctpop\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n+                self.memory.write_uint(dest, num.into(), elem_size)?;\n+            }\n+\n+            \"ctlz\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n+                self.memory.write_uint(dest, num.into(), elem_size)?;\n+            }\n+\n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n@@ -495,7 +507,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         trait_id: DefId,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n-        first_arg: Option<&mut (Pointer, Ty<'tcx>)>,\n+        args: &mut Vec<(Pointer, Ty<'tcx>)>,\n     ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n@@ -514,23 +526,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             traits::VtableClosure(vtable_closure) =>\n                 Ok((vtable_closure.closure_def_id, vtable_closure.substs.func_substs)),\n \n-            traits::VtableFnPointer(_fn_ty) => {\n-                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                unimplemented!()\n-                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n-\n-                // let method_ty = def_ty(tcx, def_id, substs);\n-                // let fn_ptr_ty = match method_ty.sty {\n-                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                //     _ => unreachable!(\"expected fn item type, found {}\",\n-                //                       method_ty)\n-                // };\n-                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            traits::VtableFnPointer(vtable_fn_ptr) => {\n+                if let ty::TyFnDef(did, ref substs, _) = vtable_fn_ptr.fn_ty.sty {\n+                    args.remove(0);\n+                    Ok((did, substs))\n+                } else {\n+                    bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n+                }\n             }\n \n             traits::VtableObject(ref data) => {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n-                if let Some(&mut(first_arg, ref mut first_ty)) = first_arg {\n+                if let Some(&mut(first_arg, ref mut first_ty)) = args.get_mut(0) {\n                     let (_, vtable) = self.get_fat_ptr(first_arg);\n                     let vtable = self.memory.read_ptr(vtable)?;\n                     let idx = idx + 3;"}, {"sha": "bc112f40685463c11e98a9c9285023970cf4a85b", "filename": "tests/compiletest.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8a2e2dd665f09d93bc80022c221e8f8000575107/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a2e2dd665f09d93bc80022c221e8f8000575107/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=8a2e2dd665f09d93bc80022c221e8f8000575107", "patch": "@@ -22,6 +22,8 @@ fn run_pass() {\n     let mut config = compiletest::default_config();\n     config.mode = \"run-pass\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(\"tests/run-pass\".to_string());\n+    config.target_rustcflags = Some(\"-Dwarnings\".to_string());\n+    config.host_rustcflags = Some(\"-Dwarnings\".to_string());\n     compiletest::run_tests(&config);\n }\n \n@@ -55,7 +57,17 @@ fn compile_test() {\n     compile_fail(&sysroot);\n     run_pass();\n     for_all_targets(&sysroot, |target| {\n-        for file in std::fs::read_dir(\"tests/run-pass\").unwrap() {\n+        let files = std::fs::read_dir(\"tests/run-pass\").unwrap();\n+        let files: Box<Iterator<Item=_>> = if let Ok(path) = std::env::var(\"MIRI_RUSTC_TEST\") {\n+            Box::new(files.chain(std::fs::read_dir(path).unwrap()))\n+        } else {\n+            Box::new(files)\n+        };\n+        let mut mir_not_found = 0;\n+        let mut crate_not_found = 0;\n+        let mut success = 0;\n+        let mut failed = 0;\n+        for file in files {\n             let file = file.unwrap();\n             let path = file.path();\n \n@@ -67,28 +79,41 @@ fn compile_test() {\n             write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n             let mut cmd = std::process::Command::new(\"target/debug/miri\");\n             cmd.arg(path);\n-            cmd.arg(\"-Dwarnings\");\n             cmd.arg(format!(\"--target={}\", target));\n             let libs = Path::new(&sysroot).join(\"lib\");\n             let sysroot = libs.join(\"rustlib\").join(&target).join(\"lib\");\n             let paths = std::env::join_paths(&[libs, sysroot]).unwrap();\n             cmd.env(compiletest::procsrv::dylib_env_var(), paths);\n \n             match cmd.output() {\n-                Ok(ref output) if output.status.success() => writeln!(stderr.lock(), \"ok\").unwrap(),\n+                Ok(ref output) if output.status.success() => {\n+                    success += 1;\n+                    writeln!(stderr.lock(), \"ok\").unwrap()\n+                },\n                 Ok(output) => {\n-                    writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n-                    writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n-                    writeln!(stderr.lock(), \"stderr: \\n {}\", std::str::from_utf8(&output.stderr).unwrap()).unwrap();\n-                    panic!(\"some tests failed\");\n+                    let output_err = std::str::from_utf8(&output.stderr).unwrap();\n+                    if let Some(text) = output_err.splitn(2, \"thread 'main' panicked at 'no mir for `\").nth(1) {\n+                        mir_not_found += 1;\n+                        let end = text.find('`').unwrap();\n+                        writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n+                    } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n+                        crate_not_found += 1;\n+                        let end = text.find('`').unwrap();\n+                        writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n+                    } else {\n+                        failed += 1;\n+                        writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n+                        writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n+                        writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n+                    }\n                 }\n                 Err(e) => {\n                     writeln!(stderr.lock(), \"FAILED: {}\", e).unwrap();\n-                    panic!(\"some tests failed\");\n+                    panic!(\"failed to execute miri\");\n                 },\n             }\n         }\n         let stderr = std::io::stderr();\n-        writeln!(stderr.lock(), \"\").unwrap();\n+        writeln!(stderr.lock(), \"{} success, {} mir not found, {} crate not found, {} failed\", success, mir_not_found, crate_not_found, failed).unwrap();\n     });\n }"}, {"sha": "e7368004069f655721ed1aef9bbf1fc98f647326", "filename": "tests/run-pass/function_pointers.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a2e2dd665f09d93bc80022c221e8f8000575107/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a2e2dd665f09d93bc80022c221e8f8000575107/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=8a2e2dd665f09d93bc80022c221e8f8000575107", "patch": "@@ -2,6 +2,10 @@ fn f() -> i32 {\n     42\n }\n \n+fn g(i: i32) -> i32 {\n+    i*42\n+}\n+\n fn return_fn_ptr() -> fn() -> i32 {\n     f\n }\n@@ -10,8 +14,22 @@ fn call_fn_ptr() -> i32 {\n     return_fn_ptr()()\n }\n \n+fn indirect<F: Fn() -> i32>(f: F) -> i32 { f() }\n+fn indirect_mut<F: FnMut() -> i32>(mut f: F) -> i32 { f() }\n+fn indirect_once<F: FnOnce() -> i32>(f: F) -> i32 { f() }\n+\n+fn indirect2<F: Fn(i32) -> i32>(f: F) -> i32 { f(10) }\n+fn indirect_mut2<F: FnMut(i32) -> i32>(mut f: F) -> i32 { f(10) }\n+fn indirect_once2<F: FnOnce(i32) -> i32>(f: F) -> i32 { f(10) }\n+\n fn main() {\n     assert_eq!(call_fn_ptr(), 42);\n+    assert_eq!(indirect(f), 42);\n+    assert_eq!(indirect_mut(f), 42);\n+    assert_eq!(indirect_once(f), 42);\n+    assert_eq!(indirect2(g), 420);\n+    assert_eq!(indirect_mut2(g), 420);\n+    assert_eq!(indirect_once2(g), 420);\n     assert!(return_fn_ptr() == f);\n     assert!(return_fn_ptr() as unsafe fn() -> i32 == f as fn() -> i32 as unsafe fn() -> i32);\n }"}]}