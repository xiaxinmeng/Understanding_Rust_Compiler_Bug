{"sha": "1da50543dd6d1778856e24433d186fd39327def1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYTUwNTQzZGQ2ZDE3Nzg4NTZlMjQ0MzNkMTg2ZmQzOTMyN2RlZjE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-08-07T12:11:54Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-08-10T11:19:22Z"}, "message": "Use the object crate for archive reading during archive building", "tree": {"sha": "6f3c769f4f3313dffff16481769f7f61eee3d8f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f3c769f4f3313dffff16481769f7f61eee3d8f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1da50543dd6d1778856e24433d186fd39327def1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1da50543dd6d1778856e24433d186fd39327def1", "html_url": "https://github.com/rust-lang/rust/commit/1da50543dd6d1778856e24433d186fd39327def1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1da50543dd6d1778856e24433d186fd39327def1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c11d8f5be17c9a2a7514bc8b65247a724c2fc217", "url": "https://api.github.com/repos/rust-lang/rust/commits/c11d8f5be17c9a2a7514bc8b65247a724c2fc217", "html_url": "https://github.com/rust-lang/rust/commit/c11d8f5be17c9a2a7514bc8b65247a724c2fc217"}], "stats": {"total": 61, "additions": 32, "deletions": 29}, "files": [{"sha": "6c0e30664cd20b39b2adf14dcb711796539fd728", "filename": "src/archive.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1da50543dd6d1778856e24433d186fd39327def1/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da50543dd6d1778856e24433d186fd39327def1/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=1da50543dd6d1778856e24433d186fd39327def1", "patch": "@@ -1,18 +1,21 @@\n //! Creation of ar archives like for the lib and staticlib crate type\n \n use std::collections::BTreeMap;\n+use std::convert::TryFrom;\n use std::fs::File;\n+use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n use rustc_codegen_ssa::METADATA_FILENAME;\n use rustc_session::Session;\n \n-use object::{Object, ObjectSymbol, SymbolKind};\n+use object::read::archive::ArchiveFile;\n+use object::{Object, ObjectSymbol, ReadCache, SymbolKind};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive { archive_index: usize, entry_index: usize },\n+    FromArchive { archive_index: usize, file_range: (u64, u64) },\n     File(PathBuf),\n }\n \n@@ -23,7 +26,7 @@ pub(crate) struct ArArchiveBuilder<'a> {\n     use_gnu_style_archive: bool,\n     no_builtin_ranlib: bool,\n \n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    src_archives: Vec<File>,\n     // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n     // the end of an archive for linkers to not get confused.\n     entries: Vec<(String, ArchiveEntry)>,\n@@ -34,20 +37,19 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         use rustc_codegen_ssa::back::link::archive_search_paths;\n \n         let (src_archives, entries) = if let Some(input) = input {\n-            let mut archive = ar::Archive::new(File::open(input).unwrap());\n+            let read_cache = ReadCache::new(File::open(input).unwrap());\n+            let archive = ArchiveFile::parse(&read_cache).unwrap();\n             let mut entries = Vec::new();\n \n-            let mut i = 0;\n-            while let Some(entry) = archive.next_entry() {\n+            for entry in archive.members() {\n                 let entry = entry.unwrap();\n                 entries.push((\n-                    String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n+                    String::from_utf8(entry.name().to_vec()).unwrap(),\n+                    ArchiveEntry::FromArchive { archive_index: 0, file_range: entry.file_range() },\n                 ));\n-                i += 1;\n             }\n \n-            (vec![(input.to_owned(), archive)], entries)\n+            (vec![read_cache.into_inner()], entries)\n         } else {\n             (vec![], Vec::new())\n         };\n@@ -98,7 +100,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         name: &str,\n         lto: bool,\n         skip_objects: bool,\n-    ) -> std::io::Result<()> {\n+    ) -> io::Result<()> {\n         let obj_start = name.to_owned();\n \n         self.add_archive(rlib.to_owned(), move |fname: &str| {\n@@ -141,14 +143,14 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n-                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n+                ArchiveEntry::FromArchive { archive_index, file_range } => {\n                     // FIXME read symbols from symtab\n-                    use std::io::Read;\n-                    let (ref _src_archive_path, ref mut src_archive) =\n-                        self.src_archives[archive_index];\n-                    let mut entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let mut data = Vec::new();\n-                    entry.read_to_end(&mut data).unwrap();\n+                    let src_read_cache = &mut self.src_archives[archive_index];\n+\n+                    src_read_cache.seek(io::SeekFrom::Start(file_range.0)).unwrap();\n+                    let mut data = std::vec::from_elem(0, usize::try_from(file_range.1).unwrap());\n+                    src_read_cache.read_exact(&mut data).unwrap();\n+\n                     data\n                 }\n                 ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n@@ -266,26 +268,27 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArArchiveBuilder<'a> {\n-    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n+    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> io::Result<()>\n     where\n         F: FnMut(&str) -> bool + 'static,\n     {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n+        let archive = ArchiveFile::parse(&read_cache).unwrap();\n         let archive_index = self.src_archives.len();\n \n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+        for entry in archive.members() {\n+            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+            let file_name = String::from_utf8(entry.name().to_vec())\n+                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n+                self.entries.push((\n+                    file_name,\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n+                ));\n             }\n-            i += 1;\n         }\n \n-        self.src_archives.push((archive_path, archive));\n+        self.src_archives.push(read_cache.into_inner());\n         Ok(())\n     }\n }"}]}