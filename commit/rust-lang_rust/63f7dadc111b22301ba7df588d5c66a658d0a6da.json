{"sha": "63f7dadc111b22301ba7df588d5c66a658d0a6da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZjdkYWRjMTExYjIyMzAxYmE3ZGY1ODhkNWM2NmE2NThkMGE2ZGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-18T13:56:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:37:25Z"}, "message": "rename LoweredImport -> ImportId", "tree": {"sha": "01def0f3d562a2b3a112c6c5f9ea2a26d935abae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01def0f3d562a2b3a112c6c5f9ea2a26d935abae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63f7dadc111b22301ba7df588d5c66a658d0a6da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63f7dadc111b22301ba7df588d5c66a658d0a6da", "html_url": "https://github.com/rust-lang/rust/commit/63f7dadc111b22301ba7df588d5c66a658d0a6da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63f7dadc111b22301ba7df588d5c66a658d0a6da/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0aeb5204c010a11db2015113a7858b517415de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0aeb5204c010a11db2015113a7858b517415de1", "html_url": "https://github.com/rust-lang/rust/commit/c0aeb5204c010a11db2015113a7858b517415de1"}], "stats": {"total": 210, "additions": 25, "deletions": 185}, "files": [{"sha": "860fd75395b1cf3b9c416dae7203c99f8d6df5e7", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{ast, TreeArc, SyntaxNode};\n use crate::{\n     Name, DefId, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n     type_ref::TypeRef,\n-    nameres::{ModuleScope, lower::LoweredImport},\n+    nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n     expr::BodySyntaxMapping,\n     ty::InferenceResult,\n@@ -100,7 +100,7 @@ impl Module {\n     pub fn import_source(\n         &self,\n         db: &impl HirDatabase,\n-        import: LoweredImport,\n+        import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n         self.import_source_impl(db, import)\n     }"}, {"sha": "e5394d440e1a7087dc1bbaa157706c911131cb73", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -5,7 +5,7 @@ use crate::{\n     Module, ModuleSource, Problem,\n     Crate, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def,\n     module_tree::ModuleId,\n-    nameres::{ModuleScope, lower::LoweredImport},\n+    nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n };\n \n@@ -69,7 +69,7 @@ impl Module {\n     pub(crate) fn import_source_impl(\n         &self,\n         db: &impl HirDatabase,\n-        import: LoweredImport,\n+        import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n         let loc = self.def_id.loc(db);\n         let source_map = db.lower_module_source_map(loc.source_root_id, loc.module_id);"}, {"sha": "60065cf6a55a83888af6c65b2ab5ca737eff9652", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module_tree::{ModuleId, ModuleTree},\n-    nameres::{ItemMap, lower::{InputModuleItems, LoweredModule, ImportSourceMap}},\n+    nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n@@ -58,13 +58,6 @@ pub trait HirDatabase:\n     #[salsa::invoke(crate::module_tree::Submodule::submodules_query)]\n     fn submodules(&self, source: SourceItemId) -> Arc<Vec<crate::module_tree::Submodule>>;\n \n-    #[salsa::invoke(crate::nameres::lower::InputModuleItems::input_module_items_query)]\n-    fn input_module_items(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<InputModuleItems>;\n-\n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_query)]\n     fn lower_module(\n         &self,"}, {"sha": "75b9c6b4300d8e9b40b49e7ebe4430d65097eb7f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -31,7 +31,7 @@ mod code_model_impl;\n use crate::{\n     db::HirDatabase,\n     name::{AsName, KnownName},\n-    ids::{DefKind, SourceItemId, SourceFileItemId, SourceFileItems},\n+    ids::{DefKind, SourceItemId, SourceFileItems},\n };\n \n pub use self::{"}, {"sha": "4efafd4092791a780ae3f990115567dd8fb09503", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -60,7 +60,7 @@ pub struct Resolution {\n     /// None for unresolved\n     pub def_id: PerNs<DefId>,\n     /// ident by whitch this is imported into local scope.\n-    pub import: Option<LoweredImport>,\n+    pub import: Option<ImportId>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -154,7 +154,7 @@ pub(crate) struct Resolver<'a, DB> {\n     input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n     source_root: SourceRootId,\n     module_tree: Arc<ModuleTree>,\n-    processed_imports: FxHashSet<(ModuleId, LoweredImport)>,\n+    processed_imports: FxHashSet<(ModuleId, ImportId)>,\n     result: ItemMap,\n }\n \n@@ -296,7 +296,7 @@ where\n     fn resolve_import(\n         &mut self,\n         module_id: ModuleId,\n-        import_id: LoweredImport,\n+        import_id: ImportId,\n         import: &ImportData,\n     ) -> bool {\n         log::debug!(\"resolving import: {:?}\", import);"}, {"sha": "52448644cdce54f1eb8377c94ffa8310f54a9848", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 15, "deletions": 167, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -1,157 +1,17 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    TextRange, SyntaxKind, AstNode, SourceFile, TreeArc,\n+    SyntaxKind, AstNode, SourceFile, TreeArc,\n     ast::{self, ModuleItemOwner},\n };\n use ra_db::{SourceRootId, LocalSyntaxPtr};\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n \n use crate::{\n-    SourceItemId, SourceFileItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n+    SourceItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n     HirFileId, MacroCallLoc, AsName,\n     module_tree::ModuleId\n };\n-/// A set of items and imports declared inside a module, without relation to\n-/// other modules.\n-///\n-/// This sits in-between raw syntax and name resolution and allows us to avoid\n-/// recomputing name res: if two instance of `InputModuleItems` are the same, we\n-/// can avoid redoing name resolution.\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct InputModuleItems {\n-    pub(crate) items: Vec<ModuleItem>,\n-    pub(super) imports: Vec<Import>,\n-}\n-\n-impl InputModuleItems {\n-    pub(crate) fn input_module_items_query(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<InputModuleItems> {\n-        let module_tree = db.module_tree(source_root_id);\n-        let source = module_id.source(&module_tree);\n-        let file_id = source.file_id;\n-        let source = ModuleSource::from_source_item_id(db, source);\n-        let mut res = InputModuleItems::default();\n-        match source {\n-            ModuleSource::SourceFile(it) => res.fill(\n-                db,\n-                source_root_id,\n-                module_id,\n-                file_id,\n-                &mut it.items_with_macros(),\n-            ),\n-            ModuleSource::Module(it) => {\n-                if let Some(item_list) = it.item_list() {\n-                    res.fill(\n-                        db,\n-                        source_root_id,\n-                        module_id,\n-                        file_id,\n-                        &mut item_list.items_with_macros(),\n-                    )\n-                }\n-            }\n-        };\n-        Arc::new(res)\n-    }\n-\n-    fn fill(\n-        &mut self,\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-        file_id: HirFileId,\n-        items: &mut Iterator<Item = ast::ItemOrMacro>,\n-    ) {\n-        let file_items = db.file_items(file_id);\n-\n-        for item in items {\n-            match item {\n-                ast::ItemOrMacro::Item(it) => {\n-                    self.add_item(file_id, &file_items, it);\n-                }\n-                ast::ItemOrMacro::Macro(macro_call) => {\n-                    let item_id = file_items.id_of_unchecked(macro_call.syntax());\n-                    let loc = MacroCallLoc {\n-                        source_root_id,\n-                        module_id,\n-                        source_item_id: SourceItemId {\n-                            file_id,\n-                            item_id: Some(item_id),\n-                        },\n-                    };\n-                    let id = loc.id(db);\n-                    let file_id = HirFileId::from(id);\n-                    let file_items = db.file_items(file_id);\n-                    //FIXME: expand recursively\n-                    for item in db.hir_source_file(file_id).items() {\n-                        self.add_item(file_id, &file_items, item);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_item(\n-        &mut self,\n-        file_id: HirFileId,\n-        file_items: &SourceFileItems,\n-        item: &ast::ModuleItem,\n-    ) -> Option<()> {\n-        match item.kind() {\n-            ast::ModuleItemKind::StructDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::EnumDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::FnDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::TraitDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::TypeDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::ImplBlock(_) => {\n-                // impls don't define items\n-            }\n-            ast::ModuleItemKind::UseItem(it) => self.add_use_item(file_items, it),\n-            ast::ModuleItemKind::ExternCrateItem(_) => {\n-                // TODO\n-            }\n-            ast::ModuleItemKind::ConstDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::StaticDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::Module(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-        }\n-        Some(())\n-    }\n-\n-    fn add_use_item(&mut self, file_items: &SourceFileItems, item: &ast::UseItem) {\n-        let file_item_id = file_items.id_of_unchecked(item.syntax());\n-        let start_offset = item.syntax().range().start();\n-        Path::expand_use_item(item, |path, segment| {\n-            let kind = match segment {\n-                None => ImportKind::Glob,\n-                Some(segment) => ImportKind::Named(NamedImport {\n-                    file_item_id,\n-                    relative_range: segment.syntax().range() - start_offset,\n-                }),\n-            };\n-            self.imports.push(Import { kind, path })\n-        })\n-    }\n-}\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) enum Vis {\n@@ -188,52 +48,40 @@ impl ModuleItem {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub(super) struct Import {\n-    pub(super) path: Path,\n-    pub(super) kind: ImportKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub struct NamedImport {\n-    pub file_item_id: SourceFileItemId,\n-    pub relative_range: TextRange,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub(super) enum ImportKind {\n-    Glob,\n-    Named(NamedImport),\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LoweredImport(RawId);\n-impl_arena_id!(LoweredImport);\n+pub struct ImportId(RawId);\n+impl_arena_id!(ImportId);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct ImportData {\n     pub(super) path: Path,\n     pub(super) is_glob: bool,\n }\n \n+/// A set of items and imports declared inside a module, without relation to\n+/// other modules.\n+///\n+/// This sits in-between raw syntax and name resolution and allows us to avoid\n+/// recomputing name res: if two instance of `InputModuleItems` are the same, we\n+/// can avoid redoing name resolution.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct LoweredModule {\n-    pub(super) items: Vec<ModuleItem>,\n-    pub(super) imports: Arena<LoweredImport, ImportData>,\n+    pub(crate) items: Vec<ModuleItem>,\n+    pub(super) imports: Arena<ImportId, ImportData>,\n }\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImportSourceMap {\n-    map: ArenaMap<LoweredImport, LocalSyntaxPtr>,\n+    map: ArenaMap<ImportId, LocalSyntaxPtr>,\n }\n \n impl ImportSourceMap {\n-    fn insert(&mut self, import: LoweredImport, segment: &ast::PathSegment) {\n+    fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n         self.map\n             .insert(import, LocalSyntaxPtr::new(segment.syntax()))\n     }\n \n-    pub fn get(&self, source: &ModuleSource, import: LoweredImport) -> TreeArc<ast::PathSegment> {\n+    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n         let file = match source {\n             ModuleSource::SourceFile(file) => &*file,\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),"}, {"sha": "2fe354b0419dd4ff50fea08680befff095d08986", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -142,7 +142,7 @@ pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, Te\n         None => return Vec::new(),\n     };\n     let loc = module.def_id.loc(db);\n-    let items = db.input_module_items(loc.source_root_id, loc.module_id);\n+    let items = db.lower_module_module(loc.source_root_id, loc.module_id);\n     let mut res = Vec::new();\n \n     for macro_call_id in items"}, {"sha": "c2978f909733d1c17db0f0d07f06f2e39a53e7eb", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f7dadc111b22301ba7df588d5c66a658d0a6da/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=63f7dadc111b22301ba7df588d5c66a658d0a6da", "patch": "@@ -113,7 +113,6 @@ salsa::database_storage! {\n             fn fn_scopes() for hir::db::FnScopesQuery;\n             fn file_items() for hir::db::FileItemsQuery;\n             fn file_item() for hir::db::FileItemQuery;\n-            fn input_module_items() for hir::db::InputModuleItemsQuery;\n             fn lower_module() for hir::db::LowerModuleQuery;\n             fn lower_module_module() for hir::db::LowerModuleModuleQuery;\n             fn lower_module_source_map() for hir::db::LowerModuleSourceMapQuery;"}]}