{"sha": "d1e67fcacdcc41ac1666fda816fb874a6d12a370", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZTY3ZmNhY2RjYzQxYWMxNjY2ZmRhODE2ZmI4NzRhNmQxMmEzNzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-26T11:30:22Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-31T00:31:40Z"}, "message": "remove universal-region-relation computation from universal_regions", "tree": {"sha": "f6cc635256f0427c7677a120c5766b5a0cba9768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6cc635256f0427c7677a120c5766b5a0cba9768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1e67fcacdcc41ac1666fda816fb874a6d12a370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1e67fcacdcc41ac1666fda816fb874a6d12a370", "html_url": "https://github.com/rust-lang/rust/commit/d1e67fcacdcc41ac1666fda816fb874a6d12a370", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1e67fcacdcc41ac1666fda816fb874a6d12a370/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "html_url": "https://github.com/rust-lang/rust/commit/3bca170bc7543da8ddb1b550a824ad0f4cbaf395"}], "stats": {"total": 506, "additions": 206, "deletions": 300}, "files": [{"sha": "973568a67f030e8fdf04c89d45a8e59cfc5376c2", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -111,7 +111,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // Run the MIR type-checker.\n     let liveness_map = NllLivenessMap::compute(&mir);\n     let liveness = LivenessResults::compute(mir, &liveness_map);\n-    let constraint_sets = type_check::type_check(\n+    let (constraint_sets, universal_region_relations) = type_check::type_check(\n         infcx,\n         param_env,\n         mir,\n@@ -155,6 +155,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let mut regioncx = RegionInferenceContext::new(\n         var_origins,\n         universal_regions,\n+        universal_region_relations,\n         mir,\n         outlives_constraints,\n         type_tests,"}, {"sha": "d3b4f0a0447a1e952c7266fa4bb483c99dcde02c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     .universal_regions\n                     .region_classification(region)\n                     .unwrap();\n-                let outlived_by = self.universal_regions.regions_outlived_by(region);\n+                let outlived_by = self.universal_region_relations.regions_outlived_by(region);\n                 writeln!(\n                     out,\n                     \"| {r:rw$} | {c:cw$} | {ob}\","}, {"sha": "6281b5dd4b64cd73c8c818807b55377738e62c8d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -15,6 +15,7 @@ use borrow_check::nll::constraints::{\n };\n use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::Locations;\n+use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n@@ -80,8 +81,12 @@ pub struct RegionInferenceContext<'tcx> {\n     type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n-    /// on this function and their (known) relations to one another.\n+    /// on this function.\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n+\n+    /// Information about how the universally quantified regions in\n+    /// scope on this function relate to one another.\n+    universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -207,6 +212,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn new(\n         var_infos: VarInfos,\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n+        universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n@@ -249,6 +255,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             scc_values,\n             type_tests,\n             universal_regions,\n+            universal_region_relations,\n         };\n \n         result.init_free_and_bound_regions();\n@@ -766,7 +773,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Grow further to get smallest universal region known to\n         // creator.\n-        let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n+        let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n \n         debug!(\n             \"non_local_universal_upper_bound: non_local_lub={:?}\",\n@@ -802,7 +809,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut lub = self.universal_regions.fr_fn_body;\n         let r_scc = self.constraint_sccs.scc(r);\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n-            lub = self.universal_regions.postdom_upper_bound(lub, ur);\n+            lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n         }\n \n         debug!(\"universal_upper_bound: r={:?} lub={:?}\", r, lub);\n@@ -870,7 +877,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .all(|r1| {\n                 self.scc_values\n                     .universal_regions_outlived_by(sup_region_scc)\n-                    .any(|r2| self.universal_regions.outlives(r2, r1))\n+                    .any(|r2| self.universal_region_relations.outlives(r2, r1))\n             });\n \n         if !universal_outlives {\n@@ -975,7 +982,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n             // If it is known that `fr: o`, carry on.\n-            if self.universal_regions.outlives(longer_fr, shorter_fr) {\n+            if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n                 continue;\n             }\n \n@@ -989,14 +996,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n                 // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-                if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr) {\n                     debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n                     // Grow `shorter_fr` until we find a non-local\n                     // region. (We always will.)  We'll call that\n                     // `shorter_fr+` -- it's ever so slightly larger than\n                     // `fr`.\n-                    let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                    let shorter_fr_plus = self.universal_region_relations.non_local_upper_bound(shorter_fr);\n                     debug!(\n                         \"check_universal_region: shorter_fr_plus={:?}\",\n                         shorter_fr_plus"}, {"sha": "d2850f8f32443e651a4256efb760f0ed3d356784", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -9,11 +9,13 @@\n // except according to those terms.\n \n use borrow_check::location::LocationTable;\n+use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::type_check::constraint_conversion;\n use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n+use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::InferCtxt;\n use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n@@ -93,6 +95,107 @@ impl UniversalRegionRelations<'tcx> {\n         self.outlives.add(fr_a, fr_b);\n         self.inverse_outlives.add(fr_b, fr_a);\n     }\n+\n+    /// Given two universal regions, returns the postdominating\n+    /// upper-bound (effectively the least upper bound).\n+    ///\n+    /// (See `TransitiveRelation::postdom_upper_bound` for details on\n+    /// the postdominating upper bound in general.)\n+    crate fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n+        assert!(self.universal_regions.is_universal_region(fr1));\n+        assert!(self.universal_regions.is_universal_region(fr2));\n+        *self\n+            .inverse_outlives\n+            .postdom_upper_bound(&fr1, &fr2)\n+            .unwrap_or(&self.universal_regions.fr_static)\n+    }\n+\n+    /// Finds an \"upper bound\" for `fr` that is not local. In other\n+    /// words, returns the smallest (*) known region `fr1` that (a)\n+    /// outlives `fr` and (b) is not local. This cannot fail, because\n+    /// we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.inverse_outlives, fr)\n+            .unwrap_or(self.universal_regions.fr_static)\n+    }\n+\n+    /// Finds a \"lower bound\" for `fr` that is not local. In other\n+    /// words, returns the largest (*) known region `fr1` that (a) is\n+    /// outlived by `fr` and (b) is not local. This cannot fail,\n+    /// because we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.outlives, fr)\n+    }\n+\n+    /// Helper for `non_local_upper_bound` and\n+    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n+    /// until we find something that is not local. Returns None if we\n+    /// never do so.\n+    fn non_local_bound(\n+        &self,\n+        relation: &TransitiveRelation<RegionVid>,\n+        fr0: RegionVid,\n+    ) -> Option<RegionVid> {\n+        // This method assumes that `fr0` is one of the universally\n+        // quantified region variables.\n+        assert!(self.universal_regions.is_universal_region(fr0));\n+\n+        let mut external_parents = vec![];\n+        let mut queue = vec![&fr0];\n+\n+        // Keep expanding `fr` into its parents until we reach\n+        // non-local regions.\n+        while let Some(fr) = queue.pop() {\n+            if !self.universal_regions.is_local_free_region(*fr) {\n+                external_parents.push(fr);\n+                continue;\n+            }\n+\n+            queue.extend(relation.parents(fr));\n+        }\n+\n+        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = relation\n+            .mutual_immediate_postdominator(external_parents)\n+            .cloned();\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom.and_then(|post_dom| {\n+            // If the mutual immediate postdom is not local, then\n+            // there is no non-local result we can return.\n+            if !self.universal_regions.is_local_free_region(post_dom) {\n+                Some(post_dom)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// True if fr1 is known to outlive fr2.\n+    ///\n+    /// This will only ever be true for universally quantified regions.\n+    crate fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        self.outlives.contains(&fr1, &fr2)\n+    }\n+\n+    /// Returns a vector of free regions `x` such that `fr1: x` is\n+    /// known to hold.\n+    crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n+        self.outlives.reachable_from(&fr1)\n+    }\n }\n \n struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n@@ -223,3 +326,16 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n         }\n     }\n }\n+\n+/// This trait is used by the `impl-trait` constraint code to abstract\n+/// over the `FreeRegionMap` from lexical regions and\n+/// `UniversalRegions` (from NLL)`.\n+impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegionRelations<'tcx> {\n+    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+        let shorter = shorter.to_region_vid();\n+        assert!(self.universal_regions.is_universal_region(shorter));\n+        let longer = longer.to_region_vid();\n+        assert!(self.universal_regions.is_universal_region(longer));\n+        self.outlives(longer, shorter)\n+    }\n+}"}, {"sha": "8571ac3235c33da7e5ccb0946d7fb35788f094b3", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -18,6 +18,7 @@\n //! contain revealed `impl Trait` values).\n \n use borrow_check::nll::renumber;\n+use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;\n@@ -37,6 +38,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         universal_regions: &UniversalRegions<'tcx>,\n+        universal_region_relations: &UniversalRegionRelations<'tcx>,\n     ) {\n         let tcx = self.infcx.tcx;\n \n@@ -160,7 +162,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 Locations::All,\n                 CustomTypeOp::new(\n                     |_cx| {\n-                        infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                        infcx.constrain_anon_types(&anon_type_map, universal_region_relations);\n                         Ok(InferOk {\n                             value: (),\n                             obligations: vec![],"}, {"sha": "15deb5fb2f4984ca966a97cc0e6ddcbb8d205a63", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 68, "deletions": 48, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -17,9 +17,10 @@ use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::LocalWithRegion;\n+use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n@@ -36,12 +37,12 @@ use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n+use rustc_errors::Diagnostic;\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n-use rustc_errors::Diagnostic;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -71,7 +72,7 @@ macro_rules! span_mirbug_and_err {\n }\n \n mod constraint_conversion;\n-mod free_region_relations;\n+pub mod free_region_relations;\n mod input_output;\n mod liveness;\n mod relate_tys;\n@@ -120,24 +121,28 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     errors_buffer: &mut Vec<Diagnostic>,\n-) -> MirTypeckRegionConstraints<'tcx> {\n+) -> (\n+    MirTypeckRegionConstraints<'tcx>,\n+    Rc<UniversalRegionRelations<'tcx>>,\n+) {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n         liveness_constraints: LivenessValues::new(elements),\n         outlives_constraints: ConstraintSet::default(),\n         type_tests: Vec::default(),\n     };\n \n-    let _urr = free_region_relations::UniversalRegionRelations::create(\n-        infcx,\n-        mir_def_id,\n-        param_env,\n-        location_table,\n-        Some(implicit_region_bound),\n-        universal_regions,\n-        &mut constraints,\n-        all_facts,\n-    );\n+    let universal_region_relations =\n+        Rc::new(free_region_relations::UniversalRegionRelations::create(\n+            infcx,\n+            mir_def_id,\n+            param_env,\n+            location_table,\n+            Some(implicit_region_bound),\n+            universal_regions,\n+            &mut constraints,\n+            all_facts,\n+        ));\n \n     {\n         let mut borrowck_context = BorrowCheckContext {\n@@ -153,17 +158,23 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             mir_def_id,\n             param_env,\n             mir,\n-            &universal_regions.region_bound_pairs,\n+            &universal_region_relations.region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n             Some(errors_buffer),\n             |cx| {\n                 liveness::generate(cx, mir, liveness, flow_inits, move_data);\n-                cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n+                cx.equate_inputs_and_outputs(\n+                    mir,\n+                    mir_def_id,\n+                    universal_regions,\n+                    &universal_region_relations,\n+                );\n             },\n         );\n     }\n-    constraints\n+\n+    (constraints, universal_region_relations)\n }\n \n fn type_check_internal<'a, 'gcx, 'tcx, F>(\n@@ -176,8 +187,8 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     errors_buffer: Option<&mut Vec<Diagnostic>>,\n     mut extra: F,\n-)\n-    where F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>)\n+) where\n+    F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>),\n {\n     let mut checker = TypeChecker::new(\n         infcx,\n@@ -319,8 +330,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             // don't have a handy function for that, so for\n             // now we just ignore `value.val` regions.\n \n-            let instantiated_predicates =\n-                tcx.predicates_of(def_id).instantiate(tcx, substs);\n+            let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n             type_checker.normalize_and_prove_instantiated_predicates(\n                 instantiated_predicates,\n                 location.boring(),\n@@ -1035,9 +1045,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n                     if let Some(ref mut borrowck_context) = self.borrowck_context {\n-                        let region_vid = borrowck_context.universal_regions.to_region_vid(\n-                            late_bound_region);\n-                        borrowck_context.constraints\n+                        let region_vid = borrowck_context\n+                            .universal_regions\n+                            .to_region_vid(late_bound_region);\n+                        borrowck_context\n+                            .constraints\n                             .liveness_constraints\n                             .add_element(region_vid, term_location);\n                     }\n@@ -1253,12 +1265,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self,\n-                   mir: &Mir<'tcx>,\n-                   local: Local,\n-                   local_decl: &LocalDecl<'tcx>,\n-                   errors_buffer: &mut Option<&mut Vec<Diagnostic>>)\n-    {\n+    fn check_local(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        local: Local,\n+        local_decl: &LocalDecl<'tcx>,\n+        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n+    ) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1286,12 +1299,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if let None = self.reported_errors.replace((ty, span)) {\n-                let mut diag = struct_span_err!(self.tcx().sess,\n-                                                span,\n-                                                E0161,\n-                                                \"cannot move a value of type {0}: the size of {0} \\\n-                                                 cannot be statically determined\",\n-                                                ty);\n+                let mut diag = struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0161,\n+                    \"cannot move a value of type {0}: the size of {0} \\\n+                     cannot be statically determined\",\n+                    ty\n+                );\n                 if let Some(ref mut errors_buffer) = *errors_buffer {\n                     diag.buffer(errors_buffer);\n                 } else {\n@@ -1589,13 +1604,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n                         ty::TyRef(ref_region, _, mutbl) => {\n-                            constraints\n-                                .outlives_constraints\n-                                .push(OutlivesConstraint {\n-                                    sup: ref_region.to_region_vid(),\n-                                    sub: borrow_region.to_region_vid(),\n-                                    locations: location.boring(),\n-                                });\n+                            constraints.outlives_constraints.push(OutlivesConstraint {\n+                                sup: ref_region.to_region_vid(),\n+                                sub: borrow_region.to_region_vid(),\n+                                locations: location.boring(),\n+                            });\n \n                             if let Some(all_facts) = all_facts {\n                                 all_facts.outlives.push((\n@@ -1780,10 +1793,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self,\n-                  mir: &Mir<'tcx>,\n-                  mut errors_buffer: Option<&mut Vec<Diagnostic>>)\n-    {\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>, mut errors_buffer: Option<&mut Vec<Diagnostic>>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n@@ -1853,7 +1863,17 @@ impl MirPass for TypeckMir {\n \n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, None, |_| ());\n+            type_check_internal(\n+                &infcx,\n+                def_id,\n+                param_env,\n+                mir,\n+                &[],\n+                None,\n+                None,\n+                None,\n+                |_| (),\n+            );\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "765c4cf906e68a4c4a89ba524e52317df654d88d", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 241, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e67fcacdcc41ac1666fda816fb874a6d12a370/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=d1e67fcacdcc41ac1666fda816fb874a6d12a370", "patch": "@@ -25,16 +25,12 @@\n use either::Either;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{self, BodyOwnerKind, HirId};\n-use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n-use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::transitive_relation::TransitiveRelation;\n use std::iter;\n use syntax::ast;\n \n@@ -85,21 +81,7 @@ pub struct UniversalRegions<'tcx> {\n     /// as the name suggests. =)\n     pub unnormalized_input_tys: &'tcx [Ty<'tcx>],\n \n-    /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n-    /// be true. These encode relationships like `T: 'a` that are\n-    /// added via implicit bounds.\n-    ///\n-    /// Each region here is guaranteed to be a key in the `indices`\n-    /// map.  We use the \"original\" regions (i.e., the keys from the\n-    /// map, and not the values) because the code in\n-    /// `process_registered_region_obligations` has some special-cased\n-    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n-    /// our special inference variable there, we would mess that up.\n-    pub region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-\n     pub yield_ty: Option<Ty<'tcx>>,\n-\n-    relations: UniversalRegionRelations,\n }\n \n /// The \"defining type\" for this MIR. The key feature of the \"defining\n@@ -171,20 +153,6 @@ struct UniversalRegionIndices<'tcx> {\n     indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n }\n \n-#[derive(Debug)]\n-struct UniversalRegionRelations {\n-    /// Stores the outlives relations that are known to hold from the\n-    /// implied bounds, in-scope where clauses, and that sort of\n-    /// thing.\n-    outlives: TransitiveRelation<RegionVid>,\n-\n-    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n-    /// and we store that here. This is useful when figuring out how\n-    /// to express some local region in terms of external regions our\n-    /// caller will understand.\n-    inverse_outlives: TransitiveRelation<RegionVid>,\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum RegionClassification {\n     /// A **global** region is one that can be named from\n@@ -249,11 +217,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n             mir_node_id,\n             mir_hir_id,\n             param_env,\n-            region_bound_pairs: vec![],\n-            relations: UniversalRegionRelations {\n-                outlives: TransitiveRelation::new(),\n-                inverse_outlives: TransitiveRelation::new(),\n-            },\n         }.build()\n     }\n \n@@ -326,45 +289,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.num_universals\n     }\n \n-    /// Given two universal regions, returns the postdominating\n-    /// upper-bound (effectively the least upper bound).\n-    ///\n-    /// (See `TransitiveRelation::postdom_upper_bound` for details on\n-    /// the postdominating upper bound in general.)\n-    pub fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n-        assert!(self.is_universal_region(fr1));\n-        assert!(self.is_universal_region(fr2));\n-        *self.relations\n-            .inverse_outlives\n-            .postdom_upper_bound(&fr1, &fr2)\n-            .unwrap_or(&self.fr_static)\n-    }\n-\n-    /// Finds an \"upper bound\" for `fr` that is not local. In other\n-    /// words, returns the smallest (*) known region `fr1` that (a)\n-    /// outlives `fr` and (b) is not local. This cannot fail, because\n-    /// we will always find `'static` at worst.\n-    ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    pub fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.relations.inverse_outlives, fr)\n-            .unwrap_or(self.fr_static)\n-    }\n-\n-    /// Finds a \"lower bound\" for `fr` that is not local. In other\n-    /// words, returns the largest (*) known region `fr1` that (a) is\n-    /// outlived by `fr` and (b) is not local. This cannot fail,\n-    /// because we will always find `'static` at worst.\n-    ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    pub fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n-        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.relations.outlives, fr)\n-    }\n-\n     /// Returns the number of global plus external universal regions.\n     /// For closures, these are the regions that appear free in the\n     /// closure type (versus those bound in the closure\n@@ -374,68 +298,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.first_local_index\n     }\n \n-    /// Helper for `non_local_upper_bound` and\n-    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n-    /// until we find something that is not local. Returns None if we\n-    /// never do so.\n-    fn non_local_bound(\n-        &self,\n-        relation: &TransitiveRelation<RegionVid>,\n-        fr0: RegionVid,\n-    ) -> Option<RegionVid> {\n-        // This method assumes that `fr0` is one of the universally\n-        // quantified region variables.\n-        assert!(self.is_universal_region(fr0));\n-\n-        let mut external_parents = vec![];\n-        let mut queue = vec![&fr0];\n-\n-        // Keep expanding `fr` into its parents until we reach\n-        // non-local regions.\n-        while let Some(fr) = queue.pop() {\n-            if !self.is_local_free_region(*fr) {\n-                external_parents.push(fr);\n-                continue;\n-            }\n-\n-            queue.extend(relation.parents(fr));\n-        }\n-\n-        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n-\n-        // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = relation\n-            .mutual_immediate_postdominator(external_parents)\n-            .cloned();\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom.and_then(|post_dom| {\n-            // If the mutual immediate postdom is not local, then\n-            // there is no non-local result we can return.\n-            if !self.is_local_free_region(post_dom) {\n-                Some(post_dom)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    /// True if fr1 is known to outlive fr2.\n-    ///\n-    /// This will only ever be true for universally quantified regions.\n-    pub fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n-        self.relations.outlives.contains(&fr1, &fr2)\n-    }\n-\n-    /// Returns a vector of free regions `x` such that `fr1: x` is\n-    /// known to hold.\n-    pub fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n-        self.relations.outlives.reachable_from(&fr1)\n-    }\n-\n     /// Get an iterator over all the early-bound regions that have names.\n     pub fn named_universal_regions<'s>(\n         &'s self,\n@@ -455,14 +317,12 @@ struct UniversalRegionsBuilder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     mir_hir_id: HirId,\n     mir_node_id: ast::NodeId,\n     param_env: ty::ParamEnv<'tcx>,\n-    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-    relations: UniversalRegionRelations,\n }\n \n const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n \n impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n-    fn build(mut self) -> UniversalRegions<'tcx> {\n+    fn build(self) -> UniversalRegions<'tcx> {\n         debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n \n         let param_env = self.param_env;\n@@ -519,33 +379,6 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n         let num_universals = self.infcx.num_region_vars();\n \n-        // Insert the facts we know from the predicates. Why? Why not.\n-        self.add_outlives_bounds(\n-            &indices,\n-            outlives_bounds::explicit_outlives_bounds(param_env),\n-        );\n-\n-        // Add the implied bounds from inputs and outputs.\n-        for ty in inputs_and_output {\n-            debug!(\"build: input_or_output={:?}\", ty);\n-            self.add_implied_bounds(&indices, ty);\n-        }\n-\n-        // Finally:\n-        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n-        // - `'static: 'r` for every region `'r`\n-        // - `'r: 'fn_body` for every (other) universally quantified\n-        //   region `'r`, all of which are provided by our caller\n-        for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n-            debug!(\n-                \"build: relating free region {:?} to itself and to 'static\",\n-                fr\n-            );\n-            self.relations.relate_universal_regions(fr, fr);\n-            self.relations.relate_universal_regions(fr_static, fr);\n-            self.relations.relate_universal_regions(fr, fr_fn_body);\n-        }\n-\n         let (unnormalized_output_ty, unnormalized_input_tys) =\n             inputs_and_output.split_last().unwrap();\n \n@@ -579,9 +412,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             defining_ty,\n             unnormalized_output_ty,\n             unnormalized_input_tys,\n-            region_bound_pairs: self.region_bound_pairs,\n             yield_ty: yield_ty,\n-            relations: self.relations,\n         }\n     }\n \n@@ -730,64 +561,6 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Update the type of a single local, which should represent\n-    /// either the return type of the MIR or one of its arguments. At\n-    /// the same time, compute and add any implied bounds that come\n-    /// from this local.\n-    ///\n-    /// Assumes that `universal_regions` indices map is fully constructed.\n-    fn add_implied_bounds(&mut self, indices: &UniversalRegionIndices<'tcx>, ty: Ty<'tcx>) {\n-        debug!(\"add_implied_bounds(ty={:?})\", ty);\n-        let span = self.infcx.tcx.def_span(self.mir_def_id);\n-        let bounds = self.infcx\n-            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n-        self.add_outlives_bounds(indices, bounds);\n-    }\n-\n-    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n-    /// the outlives relation as well as the region-bound pairs\n-    /// listing.\n-    fn add_outlives_bounds<I>(&mut self, indices: &UniversalRegionIndices<'tcx>, outlives_bounds: I)\n-    where\n-        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n-    {\n-        for outlives_bound in outlives_bounds {\n-            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n-\n-            match outlives_bound {\n-                OutlivesBound::RegionSubRegion(r1, r2) => {\n-                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n-                    let r1 = indices.to_region_vid(r1);\n-                    let r2 = indices.to_region_vid(r2);\n-                    self.relations.relate_universal_regions(r2, r1);\n-                }\n-\n-                OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs\n-                        .push((r_a, GenericKind::Param(param_b)));\n-                }\n-\n-                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs\n-                        .push((r_a, GenericKind::Projection(projection_b)));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl UniversalRegionRelations {\n-    /// Records in the `outlives_relation` (and\n-    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n-    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n-        debug!(\n-            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n-            fr_a, fr_b\n-        );\n-        self.outlives.add(fr_a, fr_b);\n-        self.inverse_outlives.add(fr_b, fr_a);\n-    }\n }\n \n trait InferCtxtExt<'tcx> {\n@@ -925,19 +698,6 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n }\n \n-/// This trait is used by the `impl-trait` constraint code to abstract\n-/// over the `FreeRegionMap` from lexical regions and\n-/// `UniversalRegions` (from NLL)`.\n-impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegions<'tcx> {\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n-        let shorter = shorter.to_region_vid();\n-        assert!(self.is_universal_region(shorter));\n-        let longer = longer.to_region_vid();\n-        assert!(self.is_universal_region(longer));\n-        self.outlives(longer, shorter)\n-    }\n-}\n-\n /// Iterates over the late-bound regions defined on fn_def_id and\n /// invokes `f` with the liberated form of each one.\n fn for_each_late_bound_region_defined_on<'tcx>("}]}