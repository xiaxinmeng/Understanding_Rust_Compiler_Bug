{"sha": "5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "node_id": "C_kwDOAAsO6NoAKDVmYzI2MWU5YTA5MDJjYzdhYTQxZmQ0MzRiMjNmYTBjMThlZDlkN2Y", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-23T20:38:34Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-12T09:59:36Z"}, "message": "Inherit generics for impl-trait.", "tree": {"sha": "3def85b0d0c1ef638deceff44f691b1231261b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3def85b0d0c1ef638deceff44f691b1231261b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "html_url": "https://github.com/rust-lang/rust/commit/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b95650930bdd4a972aed911380b9706dbaec6409", "url": "https://api.github.com/repos/rust-lang/rust/commits/b95650930bdd4a972aed911380b9706dbaec6409", "html_url": "https://github.com/rust-lang/rust/commit/b95650930bdd4a972aed911380b9706dbaec6409"}], "stats": {"total": 216, "additions": 144, "deletions": 72}, "files": [{"sha": "0f61fc51661835cff3e6fd2b91057192c42fa292", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "patch": "@@ -2767,35 +2767,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n             if let Some(i) = (param.index as usize).checked_sub(generics.parent_count) {\n                 // Our own parameters are the resolved lifetimes.\n-                if let GenericParamDefKind::Lifetime = param.kind {\n-                    if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] {\n-                        self.ast_region_to_region(lifetime, None).into()\n-                    } else {\n-                        bug!()\n-                    }\n-                } else {\n-                    bug!()\n-                }\n+                let GenericParamDefKind::Lifetime { .. } = param.kind else { bug!() };\n+                let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] else { bug!() };\n+                self.ast_region_to_region(lifetime, None).into()\n             } else {\n-                match param.kind {\n-                    // For RPIT (return position impl trait), only lifetimes\n-                    // mentioned in the impl Trait predicate are captured by\n-                    // the opaque type, so the lifetime parameters from the\n-                    // parent item need to be replaced with `'static`.\n-                    //\n-                    // For `impl Trait` in the types of statics, constants,\n-                    // locals and type aliases. These capture all parent\n-                    // lifetimes, so they can use their identity subst.\n-                    GenericParamDefKind::Lifetime\n-                        if matches!(\n-                            origin,\n-                            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..)\n-                        ) =>\n-                    {\n-                        tcx.lifetimes.re_static.into()\n-                    }\n-                    _ => tcx.mk_param_from_def(param),\n-                }\n+                tcx.mk_param_from_def(param)\n             }\n         });\n         debug!(\"impl_trait_ty_to_ty: substs={:?}\", substs);\n@@ -2972,6 +2948,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Some(tcx.liberate_late_bound_regions(fn_hir_id.expect_owner().to_def_id(), ty))\n     }\n \n+    #[instrument(level = \"trace\", skip(self, generate_err))]\n     fn validate_late_bound_regions(\n         &self,\n         constrained_regions: FxHashSet<ty::BoundRegionKind>,"}, {"sha": "eddc7e0e0556c84306addfd1f67d710c43ec99a7", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 79, "deletions": 14, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "patch": "@@ -240,6 +240,7 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     }\n     check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n }\n+\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n #[instrument(level = \"debug\", skip(tcx, span))]\n@@ -251,15 +252,19 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n     let item = tcx.hir().expect_item(def_id);\n     debug!(?item, ?span);\n \n+    #[derive(Debug)]\n     struct FoundParentLifetime;\n-    struct FindParentLifetimeVisitor<'tcx>(&'tcx ty::Generics);\n+    struct FindParentLifetimeVisitor<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        parent_count: u32,\n+    }\n     impl<'tcx> ty::visit::TypeVisitor<'tcx> for FindParentLifetimeVisitor<'tcx> {\n         type BreakTy = FoundParentLifetime;\n \n+        #[instrument(level = \"trace\", skip(self), ret)]\n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"FindParentLifetimeVisitor: r={:?}\", r);\n             if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *r {\n-                if index < self.0.parent_count as u32 {\n+                if index < self.parent_count {\n                     return ControlFlow::Break(FoundParentLifetime);\n                 } else {\n                     return ControlFlow::CONTINUE;\n@@ -269,6 +274,63 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n             r.super_visit_with(self)\n         }\n \n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            // We're only interested in types involving regions\n+            if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n+                return ControlFlow::CONTINUE;\n+            }\n+\n+            match ty.kind() {\n+                ty::Closure(_, ref substs) => {\n+                    // Skip lifetime parameters of the enclosing item(s)\n+\n+                    substs.as_closure().tupled_upvars_ty().visit_with(self)?;\n+                    substs.as_closure().sig_as_fn_ptr_ty().visit_with(self)?;\n+                }\n+\n+                ty::Generator(_, ref substs, _) => {\n+                    // Skip lifetime parameters of the enclosing item(s)\n+                    // Also skip the witness type, because that has no free regions.\n+\n+                    substs.as_generator().tupled_upvars_ty().visit_with(self)?;\n+                    substs.as_generator().return_ty().visit_with(self)?;\n+                    substs.as_generator().yield_ty().visit_with(self)?;\n+                    substs.as_generator().resume_ty().visit_with(self)?;\n+                }\n+\n+                ty::Opaque(def_id, ref substs) => {\n+                    // Skip lifetime paramters that are not captures.\n+                    let variances = self.tcx.variances_of(*def_id);\n+\n+                    for (v, s) in std::iter::zip(variances, substs.iter()) {\n+                        if *v != ty::Variance::Bivariant {\n+                            s.visit_with(self)?;\n+                        }\n+                    }\n+                }\n+\n+                ty::Projection(proj)\n+                    if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+                {\n+                    // Skip lifetime paramters that are not captures.\n+                    let variances = self.tcx.variances_of(proj.item_def_id);\n+\n+                    for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n+                        if *v != ty::Variance::Bivariant {\n+                            s.visit_with(self)?;\n+                        }\n+                    }\n+                }\n+\n+                _ => {\n+                    ty.super_visit_with(self)?;\n+                }\n+            }\n+\n+            ControlFlow::CONTINUE\n+        }\n+\n         fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if let ty::ConstKind::Unevaluated(..) = c.kind() {\n                 // FIXME(#72219) We currently don't detect lifetimes within substs\n@@ -291,12 +353,15 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n         type BreakTy = Ty<'tcx>;\n \n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            debug!(?t, \"root_visit_ty\");\n             if t == self.opaque_identity_ty {\n                 ControlFlow::CONTINUE\n             } else {\n-                t.super_visit_with(&mut FindParentLifetimeVisitor(self.generics))\n-                    .map_break(|FoundParentLifetime| t)\n+                t.visit_with(&mut FindParentLifetimeVisitor {\n+                    tcx: self.tcx,\n+                    parent_count: self.generics.parent_count as u32,\n+                })\n+                .map_break(|FoundParentLifetime| t)\n             }\n         }\n     }\n@@ -329,14 +394,18 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n \n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n         origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n+        in_trait,\n         ..\n     }) = item.kind\n     {\n+        let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        let opaque_identity_ty = if in_trait {\n+            tcx.mk_projection(def_id.to_def_id(), substs)\n+        } else {\n+            tcx.mk_opaque(def_id.to_def_id(), substs)\n+        };\n         let mut visitor = ProhibitOpaqueVisitor {\n-            opaque_identity_ty: tcx.mk_opaque(\n-                def_id.to_def_id(),\n-                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-            ),\n+            opaque_identity_ty,\n             generics: tcx.generics_of(def_id),\n             tcx,\n             selftys: vec![],\n@@ -345,10 +414,6 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n             .explicit_item_bounds(def_id)\n             .iter()\n             .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n-        debug!(\n-            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor.opaque_identity_ty={:?}, visitor.generics={:?}\",\n-            prohibit_opaque, visitor.opaque_identity_ty, visitor.generics\n-        );\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n             visitor.visit_item(&item);"}, {"sha": "d773aa5f1fce1402141df71dd825fe4c61846678", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "patch": "@@ -261,6 +261,7 @@ fn label_msg_span(\n     }\n }\n \n+#[instrument(level = \"trace\", skip(tcx))]\n pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,"}, {"sha": "e480e713f6173c5760e17682b5ed6e2dd5185828", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "patch": "@@ -332,32 +332,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         concrete_ty: Ty<'tcx>,\n         span: Span,\n     ) {\n-        let def_id = opaque_type_key.def_id;\n-\n-        let tcx = self.tcx;\n-\n         let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n-\n         debug!(?concrete_ty);\n \n-        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n-                // We lower\n-                //\n-                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-                //\n-                // into\n-                //\n-                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-                //\n-                // For these types we only iterate over `'l0..lm` below.\n-                tcx.generics_of(def_id).parent_count\n-            }\n-            // These opaque type inherit all lifetime parameters from their\n-            // parent, so we have to check them all.\n-            hir::OpaqueTyOrigin::TyAlias => 0,\n-        };\n+        let variances = self.tcx.variances_of(opaque_type_key.def_id);\n+        debug!(?variances);\n \n         // For a case like `impl Foo<'a, 'b>`, we would generate a constraint\n         // `'r in ['a, 'b, 'static]` for each region `'r` that appears in the\n@@ -370,9 +349,12 @@ impl<'tcx> InferCtxt<'tcx> {\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_key.substs[first_own_region..]\n+            opaque_type_key\n+                .substs\n                 .iter()\n-                .filter_map(|arg| match arg.unpack() {\n+                .enumerate()\n+                .filter(|(i, _)| variances[*i] == ty::Variance::Invariant)\n+                .filter_map(|(_, arg)| match arg.unpack() {\n                     GenericArgKind::Lifetime(r) => Some(r),\n                     GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                 })\n@@ -381,6 +363,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         );\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n             op: |r| self.member_constraint(opaque_type_key, span, concrete_ty, r, &choice_regions),\n         });\n     }\n@@ -440,11 +423,12 @@ impl<'tcx> InferCtxt<'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<OP> {\n+struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n+    tcx: TyCtxt<'tcx>,\n     op: OP,\n }\n \n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n@@ -490,6 +474,31 @@ where\n                 substs.as_generator().yield_ty().visit_with(self);\n                 substs.as_generator().resume_ty().visit_with(self);\n             }\n+\n+            ty::Opaque(def_id, ref substs) => {\n+                // Skip lifetime paramters that are not captures.\n+                let variances = self.tcx.variances_of(*def_id);\n+\n+                for (v, s) in std::iter::zip(variances, substs.iter()) {\n+                    if *v != ty::Variance::Bivariant {\n+                        s.visit_with(self);\n+                    }\n+                }\n+            }\n+\n+            ty::Projection(proj)\n+                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            {\n+                // Skip lifetime paramters that are not captures.\n+                let variances = self.tcx.variances_of(proj.item_def_id);\n+\n+                for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n+                    if *v != ty::Variance::Bivariant {\n+                        s.visit_with(self);\n+                    }\n+                }\n+            }\n+\n             _ => {\n                 ty.super_visit_with(self);\n             }"}, {"sha": "bf000e4fd0e8f0fd4602351e9a3556094a76065a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "patch": "@@ -1338,8 +1338,8 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n             // HACK: The HIR lowering for async fn does not generate\n             // any `+ Captures<'x>` bounds for the `impl Future<...>`, so all async fns with lifetimes\n             // would now fail to compile. We should probably just make hir lowering fill this in properly.\n-            OpaqueTyOrigin::AsyncFn(_) => map.collect(),\n-            OpaqueTyOrigin::FnReturn(_) | OpaqueTyOrigin::TyAlias => {\n+            OpaqueTyOrigin::FnReturn(_) | OpaqueTyOrigin::AsyncFn(_) => map.collect(),\n+            OpaqueTyOrigin::TyAlias => {\n                 // Opaque types may only use regions that are bound. So for\n                 // ```rust\n                 // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;"}, {"sha": "42a1314b14dc25ccc7caa53446959d3bf58198ca", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=5fc261e9a0902cc7aa41fd434b23fa0c18ed9d7f", "patch": "@@ -170,6 +170,26 @@ pub fn relate_substs_with_variances<'tcx, R: TypeRelation<'tcx>>(\n     tcx.mk_substs(params)\n }\n \n+#[instrument(level = \"trace\", skip(relation), ret)]\n+fn relate_opaque_item_substs<'tcx, R: TypeRelation<'tcx>>(\n+    relation: &mut R,\n+    def_id: DefId,\n+    a_subst: SubstsRef<'tcx>,\n+    b_subst: SubstsRef<'tcx>,\n+) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n+    let tcx = relation.tcx();\n+    let variances = tcx.variances_of(def_id);\n+    debug!(?variances);\n+\n+    let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n+        let variance = variances[i];\n+        let variance_info = ty::VarianceDiagInfo::default();\n+        relation.relate_with_variance(variance, variance_info, a, b)\n+    });\n+\n+    tcx.mk_substs(params)\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n@@ -561,7 +581,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let substs = relate_substs(relation, a_substs, b_substs)?;\n+            let substs = relate_opaque_item_substs(relation, a_def_id, a_substs, b_substs)?;\n             Ok(tcx.mk_opaque(a_def_id, substs))\n         }\n "}]}