{"sha": "2989a25273013dd90c2704b4c0a484c6455b78aa", "node_id": "C_kwDOAAsO6NoAKDI5ODlhMjUyNzMwMTNkZDkwYzI3MDRiNGMwYTQ4NGM2NDU1Yjc4YWE", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2021-12-16T04:48:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-16T04:48:10Z"}, "message": "Feature/global rvalue initialization petter tomner (#111)\n\n* Use new initialization functions\r\n\r\n* Fix for new reflection patch\r\n\r\n* Fix for new TLS patch", "tree": {"sha": "d1e21eaa4feb6dfecb52776a7957c70d1209df18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1e21eaa4feb6dfecb52776a7957c70d1209df18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2989a25273013dd90c2704b4c0a484c6455b78aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhusUKCRBK7hj4Ov3rIwAA9HIIAKYt1t6YPhW5Q8W2A34NrjW8\nn35Ix7rndC+Nw/pyCAJ5lYmWjLEtih/k7XfKGOsMZ2dnPrO9LKbSyqCE7YdzYdt/\n+hPRS62dVm8gnN5kJsKlBa9F+VppQGkrE50dw1EHt3OWkskTNrBIOdjd7JhG4igW\npdxZAL+YldGJBAYiVjbgGYGo7jW/YZuKvyjW1Kn0mGgfuAS53DU/G1ptDniL3hgt\nnSpnEyZa18NpqZWa4JS+dVSknGFXSB2xzok+YWsLIIkliFgIvYkwN26vcYFzlv+d\nynSZARuy2RGTbV1DhBAmwVWwIVeEwxBGnDC0GBOBAj6x30q7rVK5QUFj5aRbHrk=\n=Etrl\n-----END PGP SIGNATURE-----\n", "payload": "tree d1e21eaa4feb6dfecb52776a7957c70d1209df18\nparent ddb015a09e9512a035b5c2017feb65d8b9a44bd8\nauthor antoyo <antoyo@users.noreply.github.com> 1639630090 -0500\ncommitter GitHub <noreply@github.com> 1639630090 -0500\n\nFeature/global rvalue initialization petter tomner (#111)\n\n* Use new initialization functions\r\n\r\n* Fix for new reflection patch\r\n\r\n* Fix for new TLS patch"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2989a25273013dd90c2704b4c0a484c6455b78aa", "html_url": "https://github.com/rust-lang/rust/commit/2989a25273013dd90c2704b4c0a484c6455b78aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2989a25273013dd90c2704b4c0a484c6455b78aa/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "html_url": "https://github.com/rust-lang/rust/commit/ddb015a09e9512a035b5c2017feb65d8b9a44bd8"}], "stats": {"total": 95, "additions": 41, "deletions": 54}, "files": [{"sha": "47925f72c2cbdd30b6964213f60da8da3dc26d2f", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2989a25273013dd90c2704b4c0a484c6455b78aa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2989a25273013dd90c2704b4c0a484c6455b78aa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2989a25273013dd90c2704b4c0a484c6455b78aa", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -70,7 +70,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"wasi\",\n ]\n \n@@ -80,7 +80,7 @@ version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]\n@@ -91,7 +91,7 @@ checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n dependencies = [\n  \"fm\",\n  \"getopts\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"num_cpus\",\n  \"termcolor\",\n  \"threadpool\",\n@@ -107,9 +107,9 @@ checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.102\"\n+version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n \n [[package]]\n name = \"memchr\"\n@@ -124,22 +124,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.10\"\n+version = \"0.2.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857\"\n+checksum = \"ed0cfbc8191465bed66e1718596ee0b0b35d5ee1f41c5df2189d0fe8bde535ba\"\n \n [[package]]\n name = \"rand\"\n version = \"0.8.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"rand_chacha\",\n  \"rand_core\",\n  \"rand_hc\",\n@@ -241,7 +241,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n@@ -278,7 +278,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]"}, {"sha": "ccf8123000cf83ec0fff9c58bb09d28fb31f6e71", "filename": "src/builder.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=2989a25273013dd90c2704b4c0a484c6455b78aa", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn check_ptr_call<'b>(&mut self, _typ: &str, func_ptr: RValue<'gcc>, args: &'b [RValue<'gcc>]) -> Cow<'b, [RValue<'gcc>]> {\n         let mut all_args_match = true;\n         let mut param_types = vec![];\n-        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         for (index, arg) in args.iter().enumerate().take(gcc_func.get_param_count()) {\n             let param = gcc_func.get_param_type(index);\n             if param != arg.get_type() {\n@@ -277,7 +277,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let mut return_type = gcc_func.get_return_type();\n         let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n@@ -810,7 +810,10 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let atomic_load = self.context.get_builtin_function(&format!(\"__atomic_load_{}\", size.bytes()));\n         let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n \n-        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let volatile_const_void_ptr_type = self.context.new_type::<()>()\n+            .make_const()\n+            .make_volatile()\n+            .make_pointer();\n         let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n         self.context.new_call(None, atomic_load, &[ptr, ordering])\n     }\n@@ -935,7 +938,9 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo): handle alignment.\n         let atomic_store = self.context.get_builtin_function(&format!(\"__atomic_store_{}\", size.bytes()));\n         let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n-        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let volatile_const_void_ptr_type = self.context.new_type::<()>()\n+            .make_volatile()\n+            .make_pointer();\n         let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n \n         // FIXME(antoyo): fix libgccjit to allow comparing an integer type with an aligned integer type because\n@@ -975,12 +980,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(idx as usize as u64, idx);\n         let value = ptr.dereference(None).to_rvalue();\n \n-        if value_type.is_array().is_some() {\n+        if value_type.dyncast_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n             let element = self.context.new_array_access(None, value, index);\n             element.get_address(None)\n         }\n-        else if let Some(vector_type) = value_type.is_vector() {\n+        else if let Some(vector_type) = value_type.dyncast_vector() {\n             let array_type = vector_type.get_element_type().make_pointer();\n             let array = self.bitcast(ptr, array_type);\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n@@ -1003,7 +1008,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn sext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check that it indeed sign extend the value.\n-        if dest_ty.is_vector().is_some() {\n+        if dest_ty.dyncast_vector().is_some() {\n             // TODO(antoyo): nothing to do as it is only for LLVM?\n             return value;\n         }\n@@ -1075,7 +1080,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let right_type = rhs.get_type();\n         if left_type != right_type {\n             // NOTE: because libgccjit cannot compare function pointers.\n-            if left_type.is_function_ptr_type().is_some() && right_type.is_function_ptr_type().is_some() {\n+            if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n                 lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n                 rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n             }\n@@ -1183,12 +1188,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(idx as usize as u64, idx);\n         let value_type = aggregate_value.get_type();\n \n-        if value_type.is_array().is_some() {\n+        if value_type.dyncast_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n             let element = self.context.new_array_access(None, aggregate_value, index);\n             element.get_address(None)\n         }\n-        else if value_type.is_vector().is_some() {\n+        else if value_type.dyncast_vector().is_some() {\n             panic!();\n         }\n         else if let Some(pointer_type) = value_type.get_pointee() {\n@@ -1215,11 +1220,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let value_type = aggregate_value.get_type();\n \n         let lvalue =\n-            if value_type.is_array().is_some() {\n+            if value_type.dyncast_array().is_some() {\n                 let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n                 self.context.new_array_access(None, aggregate_value, index)\n             }\n-            else if value_type.is_vector().is_some() {\n+            else if value_type.dyncast_vector().is_some() {\n                 panic!();\n             }\n             else if let Some(pointer_type) = value_type.get_pointee() {"}, {"sha": "e972a91acededa7f105f749593177c57257646e5", "filename": "src/common.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=2989a25273013dd90c2704b4c0a484c6455b78aa", "patch": "@@ -1,5 +1,4 @@\n use std::convert::TryFrom;\n-use std::convert::TryInto;\n \n use gccjit::LValue;\n use gccjit::{Block, CType, RValue, Type, ToRValue};\n@@ -44,7 +43,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let string = self.context.new_string_literal(&*string);\n         let sym = self.generate_local_symbol_name(\"str\");\n         let global = self.declare_private_global(&sym, self.val_ty(string));\n-        global.global_set_initializer_value(string);\n+        global.global_set_initializer_rvalue(string);\n         global\n         // TODO(antoyo): set linkage.\n     }\n@@ -79,7 +78,7 @@ pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) ->\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n         .collect();\n-    context.new_rvalue_from_array(None, typ, &elements)\n+    context.new_array_constructor(None, typ, &elements)\n }\n \n pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n@@ -120,13 +119,6 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn const_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n-        let num64: Result<i64, _> = num.try_into();\n-        if let Ok(num) = num64 {\n-            // FIXME(antoyo): workaround for a bug where libgccjit is expecting a constant.\n-            // The operations >> 64 and | low are making the normal case a non-constant.\n-            return self.context.new_rvalue_from_long(typ, num as i64);\n-        }\n-\n         if num >> 64 != 0 {\n             // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n             let low = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n@@ -193,7 +185,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo): cache the type? It's anonymous, so probably not.\n         let typ = self.type_struct(&fields, packed);\n         let struct_type = typ.is_struct().expect(\"struct type\");\n-        self.context.new_rvalue_from_struct(None, struct_type, values)\n+        self.context.new_struct_constructor(None, struct_type.as_type(), None, values)\n     }\n \n     fn const_to_opt_uint(&self, _v: RValue<'gcc>) -> Option<u64> {"}, {"sha": "ba4589bd810255be742e27f90a908bd54d4135f8", "filename": "src/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=2989a25273013dd90c2704b4c0a484c6455b78aa", "patch": "@@ -20,7 +20,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n         if value.get_type() == self.bool_type.make_pointer() {\n             if let Some(pointee) = typ.get_pointee() {\n-                if pointee.is_vector().is_some() {\n+                if pointee.dyncast_vector().is_some() {\n                     panic!()\n                 }\n             }\n@@ -81,7 +81,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             else {\n                 value\n             };\n-        global.global_set_initializer_value(value);\n+        global.global_set_initializer_rvalue(value);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n@@ -180,7 +180,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             };\n         // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n         // globally.\n-        global.global_set_initializer_value(cv);\n+        global.global_set_initializer_rvalue(cv);\n         // TODO(antoyo): set unnamed address.\n         global.get_address(None)\n     }\n@@ -375,7 +375,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         real_name.push_str(&sym);\n         let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_value(global1.get_address(None));\n+        global2.global_set_initializer_rvalue(global1.get_address(None));\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }"}, {"sha": "dfcd1b6231216cb49acc361bdb83e054a43e058d", "filename": "src/context.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=2989a25273013dd90c2704b4c0a484c6455b78aa", "patch": "@@ -1,16 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{\n-    Block,\n-    Context,\n-    CType,\n-    Function,\n-    FunctionType,\n-    LValue,\n-    RValue,\n-    Struct,\n-    Type,\n-};\n+use gccjit::{Block, CType, Context, Function, FunctionType, LValue, RValue, Struct, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,"}, {"sha": "28e2adc492bbeb49f86be0c3037610c3d0fd53a2", "filename": "src/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2989a25273013dd90c2704b4c0a484c6455b78aa/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=2989a25273013dd90c2704b4c0a484c6455b78aa", "patch": "@@ -122,7 +122,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         if typ.is_integral() {\n             TypeKind::Integer\n         }\n-        else if typ.is_vector().is_some() {\n+        else if typ.dyncast_vector().is_some() {\n             TypeKind::Vector\n         }\n         else {\n@@ -141,10 +141,10 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn element_type(&self, ty: Type<'gcc>) -> Type<'gcc> {\n-        if let Some(typ) = ty.is_array() {\n+        if let Some(typ) = ty.dyncast_array() {\n             typ\n         }\n-        else if let Some(vector_type) = ty.is_vector() {\n+        else if let Some(vector_type) = ty.dyncast_vector() {\n             vector_type.get_element_type()\n         }\n         else if let Some(typ) = ty.get_pointee() {"}]}