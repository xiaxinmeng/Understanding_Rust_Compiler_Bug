{"sha": "93613a543f0cae68ea82e6a66b9b9cdfa13b673e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNjEzYTU0M2YwY2FlNjhlYTgyZTZhNjZiOWI5Y2RmYTEzYjY3M2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-28T00:23:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-02T04:41:37Z"}, "message": "std: Stabilize the `process` module\n\nThis commits blanket marks the API of the `std::process` module as `#[stable]`.\nThe module's API is very similar to the old `std::old_io::process` API and has\ngenerally had quite a bit of time to bake both before and after the new module\nlanded.\n\nThe one modification made to the API is that `Stdio::capture` is now named\n`stdio::piped`.\n\n[breaking-change]", "tree": {"sha": "03e86752b8a7a1fd9d2ed44472aa091b50633fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03e86752b8a7a1fd9d2ed44472aa091b50633fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93613a543f0cae68ea82e6a66b9b9cdfa13b673e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93613a543f0cae68ea82e6a66b9b9cdfa13b673e", "html_url": "https://github.com/rust-lang/rust/commit/93613a543f0cae68ea82e6a66b9b9cdfa13b673e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93613a543f0cae68ea82e6a66b9b9cdfa13b673e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "157614249594f187f421cd97f928e64c5ab5c1fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/157614249594f187f421cd97f928e64c5ab5c1fa", "html_url": "https://github.com/rust-lang/rust/commit/157614249594f187f421cd97f928e64c5ab5c1fa"}], "stats": {"total": 72, "additions": 57, "deletions": 15}, "files": [{"sha": "b578b5e3d600a8b28467f05613d048e81b06d00d", "filename": "src/libstd/process.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/93613a543f0cae68ea82e6a66b9b9cdfa13b673e/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93613a543f0cae68ea82e6a66b9b9cdfa13b673e/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=93613a543f0cae68ea82e6a66b9b9cdfa13b673e", "patch": "@@ -10,7 +10,7 @@\n \n //! Working with processes.\n \n-#![unstable(feature = \"process\", reason = \"recently added via RFC 579\")]\n+#![stable(feature = \"process\", since = \"1.0.0\")]\n #![allow(non_upper_case_globals)]\n \n use prelude::v1::*;\n@@ -48,27 +48,33 @@ use thread;\n /// let contents = output.stdout;\n /// assert!(output.status.success());\n /// ```\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n     handle: ProcessImp,\n \n     /// None until wait() or wait_with_output() is called.\n     status: Option<ExitStatusImp>,\n \n     /// The handle for writing to the child's stdin, if it has been captured\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n \n     /// The handle for reading from the child's stdout, if it has been captured\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdout: Option<ChildStdout>,\n \n     /// The handle for reading from the child's stderr, if it has been captured\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stderr: Option<ChildStderr>,\n }\n \n /// A handle to a child procesess's stdin\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe\n }\n \n+#[stable(feature = \"process\", since = \"1.0.0\")]\n impl Write for ChildStdin {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(buf)\n@@ -80,21 +86,25 @@ impl Write for ChildStdin {\n }\n \n /// A handle to a child procesess's stdout\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n     inner: AnonPipe\n }\n \n+#[stable(feature = \"process\", since = \"1.0.0\")]\n impl Read for ChildStdout {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n }\n \n /// A handle to a child procesess's stderr\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n     inner: AnonPipe\n }\n \n+#[stable(feature = \"process\", since = \"1.0.0\")]\n impl Read for ChildStderr {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n@@ -108,15 +118,14 @@ impl Read for ChildStderr {\n /// to be changed (for example, by adding arguments) prior to spawning:\n ///\n /// ```\n-/// # #![feature(process)]\n-///\n /// use std::process::Command;\n ///\n /// let output = Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").output().unwrap_or_else(|e| {\n ///   panic!(\"failed to execute process: {}\", e)\n /// });\n /// let hello = output.stdout;\n /// ```\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Command {\n     inner: CommandImp,\n \n@@ -137,6 +146,7 @@ impl Command {\n     ///\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn new<S: AsOsStr + ?Sized>(program: &S) -> Command {\n         Command {\n             inner: CommandImp::new(program.as_os_str()),\n@@ -147,12 +157,14 @@ impl Command {\n     }\n \n     /// Add an argument to pass to the program.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn arg<S: AsOsStr + ?Sized>(&mut self, arg: &S) -> &mut Command {\n         self.inner.arg(arg.as_os_str());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<S: AsOsStr>(&mut self, args: &[S]) -> &mut Command {\n         self.inner.args(args.iter().map(AsOsStr::as_os_str));\n         self\n@@ -162,47 +174,54 @@ impl Command {\n     ///\n     /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n     /// and case-sensitive on all other platforms.\n-    pub fn env<S: ?Sized, T: ?Sized>(&mut self, key: &S, val: &T) -> &mut Command where\n-        S: AsOsStr, T: AsOsStr\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n+    pub fn env<K: ?Sized, V: ?Sized>(&mut self, key: &K, val: &V) -> &mut Command\n+        where K: AsOsStr, V: AsOsStr\n     {\n         self.inner.env(key.as_os_str(), val.as_os_str());\n         self\n     }\n \n     /// Removes an environment variable mapping.\n-    pub fn env_remove<S: ?Sized + AsOsStr>(&mut self, key: &S) -> &mut Command {\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n+    pub fn env_remove<K: ?Sized + AsOsStr>(&mut self, key: &K) -> &mut Command {\n         self.inner.env_remove(key.as_os_str());\n         self\n     }\n \n     /// Clears the entire environment map for the child process.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_clear(&mut self) -> &mut Command {\n         self.inner.env_clear();\n         self\n     }\n \n     /// Set the working directory for the child process.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsPath + ?Sized>(&mut self, dir: &P) -> &mut Command {\n         self.inner.cwd(dir.as_path().as_os_str());\n         self\n     }\n \n     /// Configuration for the child process's stdin handle (file descriptor 0).\n     /// Defaults to `CreatePipe(true, false)` so the input can be written to.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n         self.stdin = Some(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n     /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n         self.stdout = Some(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n     /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n         self.stderr = Some(cfg.0);\n         self\n@@ -234,6 +253,7 @@ impl Command {\n     /// Executes the command as a child process, returning a handle to it.\n     ///\n     /// By default, stdin, stdout and stderr are inherited by the parent.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n         self.spawn_inner(StdioImp::Inherit)\n     }\n@@ -258,8 +278,9 @@ impl Command {\n     /// println!(\"stdout: {}\", String::from_utf8_lossy(output.stdout.as_slice()));\n     /// println!(\"stderr: {}\", String::from_utf8_lossy(output.stderr.as_slice()));\n     /// ```\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.spawn_inner(StdioImp::Capture).and_then(|p| p.wait_with_output())\n+        self.spawn_inner(StdioImp::Piped).and_then(|p| p.wait_with_output())\n     }\n \n     /// Executes a command as a child process, waiting for it to finish and\n@@ -279,6 +300,7 @@ impl Command {\n     ///\n     /// println!(\"process exited with: {}\", status);\n     /// ```\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn status(&mut self) -> io::Result<ExitStatus> {\n         self.spawn().and_then(|mut p| p.wait())\n     }\n@@ -317,7 +339,7 @@ fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)\n         Inherit => {\n             (Some(AnonPipe::from_fd(fd)), None)\n         }\n-        Capture => {\n+        Piped => {\n             let (reader, writer) = try!(unsafe { pipe2::anon_pipe() });\n             if readable {\n                 (Some(reader), Some(writer))\n@@ -330,45 +352,60 @@ fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)\n \n /// The output of a finished process.\n #[derive(PartialEq, Eq, Clone)]\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Output {\n     /// The status (exit code) of the process.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub status: ExitStatus,\n     /// The data that the process wrote to stdout.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdout: Vec<u8>,\n     /// The data that the process wrote to stderr.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stderr: Vec<u8>,\n }\n \n /// Describes what to do with a standard io stream for a child process.\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Stdio(StdioImp);\n \n // The internal enum for stdio setup; see below for descriptions.\n #[derive(Clone)]\n enum StdioImp {\n-    Capture,\n+    Piped,\n     Inherit,\n     Null,\n }\n \n impl Stdio {\n     /// A new pipe should be arranged to connect the parent and child processes.\n-    pub fn capture() -> Stdio { Stdio(StdioImp::Capture) }\n+    #[unstable(feature = \"process_capture\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `Stdio::piped`\")]\n+    pub fn capture() -> Stdio { Stdio::piped() }\n+\n+    /// A new pipe should be arranged to connect the parent and child processes.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n+    pub fn piped() -> Stdio { Stdio(StdioImp::Piped) }\n \n     /// The child inherits from the corresponding parent descriptor.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn inherit() -> Stdio { Stdio(StdioImp::Inherit) }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn null() -> Stdio { Stdio(StdioImp::Null) }\n }\n \n /// Describes the result of a process after it has terminated.\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+#[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ExitStatus(ExitStatusImp);\n \n impl ExitStatus {\n     /// Was termination successful? Signal termination not considered a success,\n     /// and success is defined as a zero exit status.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn success(&self) -> bool {\n         self.0.success()\n     }\n@@ -378,6 +415,7 @@ impl ExitStatus {\n     /// On Unix, this will return `None` if the process was terminated\n     /// by a signal; `std::os::unix` provides an extension trait for\n     /// extracting the signal and other details from the `ExitStatus`.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn code(&self) -> Option<i32> {\n         self.0.code()\n     }\n@@ -387,6 +425,7 @@ impl AsInner<ExitStatusImp> for ExitStatus {\n     fn as_inner(&self) -> &ExitStatusImp { &self.0 }\n }\n \n+#[stable(feature = \"process\", since = \"1.0.0\")]\n impl fmt::Display for ExitStatus {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.0.fmt(f)\n@@ -396,6 +435,7 @@ impl fmt::Display for ExitStatus {\n impl Child {\n     /// Forces the child to exit. This is equivalent to sending a\n     /// SIGKILL on unix platforms.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n         #[cfg(unix)] fn collect_status(p: &mut Child) {\n             // On Linux (and possibly other unices), a process that has exited will\n@@ -436,6 +476,7 @@ impl Child {\n     /// before waiting. This helps avoid deadlock: it ensures that the\n     /// child does not block waiting for input from the parent, while\n     /// the parent waits for the child to exit.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         drop(self.stdin.take());\n         match self.status {\n@@ -456,6 +497,7 @@ impl Child {\n     /// before waiting. This helps avoid deadlock: it ensures that the\n     /// child does not block waiting for input from the parent, while\n     /// the parent waits for the child to exit.\n+    #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait_with_output(mut self) -> io::Result<Output> {\n         drop(self.stdin.take());\n         fn read<T: Read + Send + 'static>(stream: Option<T>) -> Receiver<io::Result<Vec<u8>>> {\n@@ -557,7 +599,7 @@ mod tests {\n     #[test]\n     fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n-        cmd.arg(\"foobar\").stdout(Stdio::capture());\n+        cmd.arg(\"foobar\").stdout(Stdio::piped());\n         assert_eq!(run_output(cmd), \"foobar\\n\");\n     }\n \n@@ -567,7 +609,7 @@ mod tests {\n         let mut cmd = Command::new(\"/bin/sh\");\n         cmd.arg(\"-c\").arg(\"pwd\")\n            .current_dir(\"/\")\n-           .stdout(Stdio::capture());\n+           .stdout(Stdio::piped());\n         assert_eq!(run_output(cmd), \"/\\n\");\n     }\n \n@@ -576,8 +618,8 @@ mod tests {\n     fn stdin_works() {\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"read line; echo $line\")\n-                            .stdin(Stdio::capture())\n-                            .stdout(Stdio::capture())\n+                            .stdin(Stdio::piped())\n+                            .stdout(Stdio::piped())\n                             .spawn().unwrap();\n         p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n@@ -675,7 +717,7 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     #[test]\n     fn test_wait_with_output_once() {\n-        let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::capture())\n+        let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped())\n             .spawn().unwrap();\n         let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(stdout.as_slice()).unwrap();"}]}