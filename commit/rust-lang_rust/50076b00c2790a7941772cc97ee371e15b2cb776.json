{"sha": "50076b00c2790a7941772cc97ee371e15b2cb776", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMDc2YjAwYzI3OTBhNzk0MTc3MmNjOTdlZTM3MWUxNWIyY2I3NzY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-03T21:41:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-11T05:41:03Z"}, "message": "rustc: intern ConstVal's in TyCtxt.", "tree": {"sha": "100b84d9c40cf34acfdd5ebc64e488123b41d0df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/100b84d9c40cf34acfdd5ebc64e488123b41d0df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50076b00c2790a7941772cc97ee371e15b2cb776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50076b00c2790a7941772cc97ee371e15b2cb776", "html_url": "https://github.com/rust-lang/rust/commit/50076b00c2790a7941772cc97ee371e15b2cb776", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50076b00c2790a7941772cc97ee371e15b2cb776/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6bce95094facf5bf36afa5995f522d374d00149", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6bce95094facf5bf36afa5995f522d374d00149", "html_url": "https://github.com/rust-lang/rust/commit/e6bce95094facf5bf36afa5995f522d374d00149"}], "stats": {"total": 587, "additions": 347, "deletions": 240}, "files": [{"sha": "dd2a3978d884405a18972f8dc6d1e4cc494251cc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -611,7 +611,7 @@ pub enum BindingAnnotation {\n   RefMut,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeEnd {\n     Included,\n     Excluded,"}, {"sha": "0d8aead0b36b8123d2721ff1e86b6379ab6cbd30", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n-use syntax_pos::symbol::InternedString;\n use middle::region;\n use ty;\n \n@@ -272,59 +271,60 @@ for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use middle::const_val::ConstVal;\n+        use middle::const_val::ConstVal::*;\n+        use middle::const_val::ConstAggregate::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            ConstVal::Float(ref value) => {\n+            Float(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Integral(ref value) => {\n+            Integral(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Str(ref value) => {\n+            Str(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::ByteStr(ref value) => {\n+            ByteStr(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Bool(value) => {\n+            Bool(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Char(value) => {\n+            Char(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Variant(def_id) => {\n+            Variant(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Function(def_id, substs) => {\n+            Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Struct(ref name_value_map) => {\n-                let mut values: Vec<(InternedString, &ConstVal)> =\n-                    name_value_map.iter()\n-                                  .map(|(name, val)| (name.as_str(), val))\n-                                  .collect();\n-\n+            Aggregate(Struct(ref name_values)) => {\n+                let mut values = name_values.to_vec();\n                 values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n                 values.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Tuple(ref value) => {\n+            Aggregate(Tuple(ref value)) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Array(ref value) => {\n+            Aggregate(Array(ref value)) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Repeat(ref value, times) => {\n+            Aggregate(Repeat(ref value, times)) => {\n                 value.hash_stable(hcx, hasher);\n                 times.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n+impl_stable_hash_for!(struct ::middle::const_val::ByteArray<'tcx> {\n+    data\n+});\n+\n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });"}, {"sha": "8eac44966bb7ef7de7ede28b6c583daf77ff5635", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use self::ConstVal::*;\n+use self::ConstAggregate::*;\n pub use rustc_const_math::ConstInt;\n \n use hir;\n@@ -22,30 +23,55 @@ use rustc_const_math::*;\n \n use graphviz::IntoCow;\n use errors::DiagnosticBuilder;\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax::symbol::InternedString;\n use syntax::ast;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n-use std::collections::BTreeMap;\n-use std::rc::Rc;\n \n-pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n+pub type EvalResult<'tcx> = Result<&'tcx ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n \n-#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n     Float(ConstFloat),\n     Integral(ConstInt),\n     Str(InternedString),\n-    ByteStr(Rc<Vec<u8>>),\n+    ByteStr(ByteArray<'tcx>),\n     Bool(bool),\n     Char(char),\n     Variant(DefId),\n     Function(DefId, &'tcx Substs<'tcx>),\n-    Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n-    Tuple(Vec<ConstVal<'tcx>>),\n-    Array(Vec<ConstVal<'tcx>>),\n-    Repeat(Box<ConstVal<'tcx>>, u64),\n+    Aggregate(ConstAggregate<'tcx>),\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx ConstVal<'tcx> {}\n+\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, Eq, PartialEq)]\n+pub struct ByteArray<'tcx> {\n+    pub data: &'tcx [u8],\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for ByteArray<'tcx> {}\n+\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n+pub enum ConstAggregate<'tcx> {\n+    Struct(&'tcx [(ast::Name, &'tcx ConstVal<'tcx>)]),\n+    Tuple(&'tcx [&'tcx ConstVal<'tcx>]),\n+    Array(&'tcx [&'tcx ConstVal<'tcx>]),\n+    Repeat(&'tcx ConstVal<'tcx>, u64),\n+}\n+\n+impl<'tcx> Encodable for ConstAggregate<'tcx> {\n+    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> {\n+        bug!(\"should never encode ConstAggregate::{:?}\", self)\n+    }\n+}\n+\n+impl<'tcx> Decodable for ConstAggregate<'tcx> {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        bug!(\"should never decode ConstAggregate\")\n+    }\n }\n \n impl<'tcx> ConstVal<'tcx> {\n@@ -58,11 +84,11 @@ impl<'tcx> ConstVal<'tcx> {\n             Bool(_) => \"boolean\",\n             Char(..) => \"char\",\n             Variant(_) => \"enum variant\",\n-            Struct(_) => \"struct\",\n-            Tuple(_) => \"tuple\",\n+            Aggregate(Struct(_)) => \"struct\",\n+            Aggregate(Tuple(_)) => \"tuple\",\n             Function(..) => \"function definition\",\n-            Array(..) => \"array\",\n-            Repeat(..) => \"repeat\",\n+            Aggregate(Array(..)) => \"array\",\n+            Aggregate(Repeat(..)) => \"repeat\",\n         }\n     }\n \n@@ -233,7 +259,7 @@ pub fn eval_length(tcx: TyCtxt,\n     let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n     let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n     match tcx.at(count_expr.span).const_eval(param_env.and((count_def_id, substs))) {\n-        Ok(Integral(Usize(count))) => {\n+        Ok(&Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n             Ok(val as usize)"}, {"sha": "a7c4e529d24e1601ce7cae2ca0c8faa1c6a6603c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -1190,7 +1190,9 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span,\n             ty: tcx.type_of(def_id).subst(tcx, substs),\n-            literal: Literal::Value { value: ConstVal::Function(def_id, substs) },\n+            literal: Literal::Value {\n+                value: tcx.mk_const(ConstVal::Function(def_id, substs))\n+            },\n         })\n     }\n \n@@ -1478,7 +1480,7 @@ pub enum Literal<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ConstVal<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n@@ -1516,9 +1518,9 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n         Integral(n) => write!(fmt, \"{}\", n),\n-        Str(ref s) => write!(fmt, \"{:?}\", s),\n-        ByteStr(ref bytes) => {\n-            let escaped: String = bytes\n+        Str(s) => write!(fmt, \"{:?}\", s),\n+        ByteStr(bytes) => {\n+            let escaped: String = bytes.data\n                 .iter()\n                 .flat_map(|&ch| ascii::escape_default(ch).map(|c| c as char))\n                 .collect();\n@@ -1528,8 +1530,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Char(c) => write!(fmt, \"{:?}\", c),\n         Variant(def_id) |\n         Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n-            bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n+        Aggregate(_) => bug!(\"`ConstVal::{:?}` should not be in MIR\", const_val),\n     }\n }\n "}, {"sha": "d2719224e378396f31833c89cd7775ccfa18eaa2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -233,7 +233,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_const_val(&mut self,\n-                               const_val: & $($mutability)* ConstVal,\n+                               const_val: & $($mutability)* &'tcx ConstVal<'tcx>,\n                                _: Location) {\n                 self.super_const_val(const_val);\n             }\n@@ -760,7 +760,7 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_val(&mut self, _const_val: & $($mutability)* ConstVal) {\n+            fn super_const_val(&mut self, _const_val: & $($mutability)* &'tcx ConstVal<'tcx>) {\n             }\n \n             fn super_const_int(&mut self, _const_int: &ConstInt) {"}, {"sha": "5d15e3a8cab72dfd9ccdfaf77ee02b6a61317b24", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -21,6 +21,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use middle::const_val::ConstVal;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n@@ -108,6 +109,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n+    const_: RefCell<FxHashSet<Interned<'tcx, ConstVal<'tcx>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -120,6 +122,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n             predicates: RefCell::new(FxHashSet()),\n+            const_: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -934,6 +937,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n+    pub fn alloc_byte_array(self, bytes: &[u8]) -> &'gcx [u8] {\n+        if bytes.is_empty() {\n+            &[]\n+        } else {\n+            self.global_interners.arena.alloc_slice(bytes)\n+        }\n+    }\n+\n+    pub fn alloc_constval_slice(self, values: &[&'tcx ConstVal<'gcx>])\n+                                -> &'gcx [&'tcx ConstVal<'gcx>] {\n+        if values.is_empty() {\n+            &[]\n+        } else {\n+            self.global_interners.arena.alloc_slice(values)\n+        }\n+    }\n+\n+    pub fn alloc_name_constval_slice(self, values: &[(ast::Name, &'tcx ConstVal<'gcx>)])\n+                                     -> &'gcx [(ast::Name, &'tcx ConstVal<'gcx>)] {\n+        if values.is_empty() {\n+            &[]\n+        } else {\n+            self.global_interners.arena.alloc_slice(values)\n+        }\n+    }\n+\n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n         if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n@@ -1507,6 +1536,12 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<ConstVal<'lcx>> for Interned<'tcx, ConstVal<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a ConstVal<'lcx> {\n+        &self.0\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1587,7 +1622,8 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> RegionKind\n+    }) -> RegionKind,\n+    const_: mk_const(/*|c: &Const| keep_local(&c.ty)*/ |_| false) -> ConstVal<'tcx>\n );\n \n macro_rules! slice_interners {"}, {"sha": "9be12195952f90ba3408af37b0908505de16c204", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -1601,7 +1601,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                 match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                    Ok(ConstVal::Integral(v)) => {\n+                    Ok(&ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n                     err => {\n@@ -1641,7 +1641,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 ty::VariantDiscr::Explicit(expr_did) => {\n                     let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                     match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                        Ok(ConstVal::Integral(v)) => {\n+                        Ok(&ConstVal::Integral(v)) => {\n                             explicit_value = v;\n                             break;\n                         }"}, {"sha": "aea1f454d814183e4d97a8199eab7eb8d1740345", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -182,13 +182,13 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n                 box PatternKind::Constant {\n-                    value: ConstVal::ByteStr(ref data)\n+                    value: &ConstVal::ByteStr(b)\n                 } => {\n-                    data.iter().map(|c| &*pattern_arena.alloc(Pattern {\n+                    b.data.iter().map(|&b| &*pattern_arena.alloc(Pattern {\n                         ty: tcx.types.u8,\n                         span: pat.span,\n                         kind: box PatternKind::Constant {\n-                            value: ConstVal::Integral(ConstInt::U8(*c))\n+                            value: tcx.mk_const(ConstVal::Integral(ConstInt::U8(b)))\n                         }\n                     })).collect()\n                 }\n@@ -228,9 +228,9 @@ pub enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(ConstVal<'tcx>),\n+    ConstantValue(&'tcx ConstVal<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(ConstVal<'tcx>, ConstVal<'tcx>, RangeEnd),\n+    ConstantRange(&'tcx ConstVal<'tcx>, &'tcx ConstVal<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(usize),\n }\n@@ -370,7 +370,7 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(ref v) => PatternKind::Constant { value: v.clone() },\n+                        ConstantValue(value) => PatternKind::Constant { value },\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -404,8 +404,11 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n-        ty::TyBool =>\n-            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n+        ty::TyBool => {\n+            [true, false].iter().map(|&b| {\n+                ConstantValue(cx.tcx.mk_const(ConstVal::Bool(b)))\n+            }).collect()\n+        }\n         ty::TySlice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n@@ -511,8 +514,8 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } => {\n-                max_fixed_len = cmp::max(max_fixed_len, data.len());\n+            PatternKind::Constant { value: &ConstVal::ByteStr(b) } => {\n+                max_fixed_len = cmp::max(max_fixed_len, b.data.len());\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n                 let fixed_len = prefix.len() + suffix.len();\n@@ -715,10 +718,10 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n             Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } =>\n             Some(vec![Variant(adt_def.variants[variant_index].did)]),\n-        PatternKind::Constant { ref value } =>\n-            Some(vec![ConstantValue(value.clone())]),\n-        PatternKind::Range { ref lo, ref hi, ref end } =>\n-            Some(vec![ConstantRange(lo.clone(), hi.clone(), end.clone())]),\n+        PatternKind::Constant { value } =>\n+            Some(vec![ConstantValue(value)]),\n+        PatternKind::Range { lo, hi, end } =>\n+            Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::TyArray(_, length) => Some(vec![Slice(length)]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n@@ -806,7 +809,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n     let data = match *ctor {\n-        ConstantValue(ConstVal::ByteStr(ref data)) => data,\n+        ConstantValue(&ConstVal::ByteStr(b)) => b.data,\n         _ => bug!()\n     };\n \n@@ -820,7 +823,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { ref value } => match *value {\n+            box PatternKind::Constant { value } => match *value {\n                 ConstVal::Integral(ConstInt::U8(u)) => {\n                     if u != *ch {\n                         return Ok(false);\n@@ -843,19 +846,19 @@ fn constructor_covered_by_range(tcx: TyCtxt, span: Span,\n     let cmp_from = |c_from| Ok(compare_const_vals(tcx, span, c_from, from)? != Ordering::Less);\n     let cmp_to = |c_to| compare_const_vals(tcx, span, c_to, to);\n     match *ctor {\n-        ConstantValue(ref value) => {\n+        ConstantValue(value) => {\n             let to = cmp_to(value)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(cmp_from(value)? && end)\n         },\n-        ConstantRange(ref from, ref to, RangeEnd::Included) => {\n+        ConstantRange(from, to, RangeEnd::Included) => {\n             let to = cmp_to(to)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(cmp_from(from)? && end)\n         },\n-        ConstantRange(ref from, ref to, RangeEnd::Excluded) => {\n+        ConstantRange(from, to, RangeEnd::Excluded) => {\n             let to = cmp_to(to)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n@@ -919,11 +922,11 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             Some(vec![subpattern])\n         }\n \n-        PatternKind::Constant { ref value } => {\n+        PatternKind::Constant { value } => {\n             match *constructor {\n                 Slice(..) => match *value {\n-                    ConstVal::ByteStr(ref data) => {\n-                        if wild_patterns.len() == data.len() {\n+                    ConstVal::ByteStr(b) => {\n+                        if wild_patterns.len() == b.data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None"}, {"sha": "0339969f2b45adf21fc79436d94b08806e618f6c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn check_match(\n         &self,\n         scrut: &hir::Expr,\n-        arms: &[hir::Arm],\n+        arms: &'tcx [hir::Arm],\n         source: hir::MatchSource)\n     {\n         for arm in arms {\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_irrefutable(&self, pat: &Pat, origin: &str) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n         let module = self.tcx.hir.get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,"}, {"sha": "5f0a070229177dc086cbd156f4bb6bf8cf9136ba", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use rustc::middle::const_val::ConstVal::*;\n+use rustc::middle::const_val::ConstAggregate::*;\n use rustc::middle::const_val::ErrKind::*;\n-use rustc::middle::const_val::{ConstVal, ConstEvalErr, EvalResult, ErrKind};\n+use rustc::middle::const_val::{ByteArray, ConstVal, ConstEvalErr, EvalResult, ErrKind};\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -88,7 +89,7 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     substs: &'tcx Substs<'tcx>,\n-    fn_args: Option<NodeMap<ConstVal<'tcx>>>\n+    fn_args: Option<NodeMap<&'tcx ConstVal<'tcx>>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n@@ -107,7 +108,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n \n     /// Evaluate a constant expression in a context where the expression isn't\n     /// guaranteed to be evaluable.\n-    pub fn eval(&self, e: &Expr) -> EvalResult<'tcx> {\n+    pub fn eval(&self, e: &'tcx Expr) -> EvalResult<'tcx> {\n         if self.tables.tainted_by_errors {\n             signal!(e, TypeckError);\n         }\n@@ -118,7 +119,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n \n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &Expr) -> EvalResult<'tcx> {\n+                                     e: &'tcx Expr) -> EvalResult<'tcx> {\n     let tcx = cx.tcx;\n     let ety = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n \n@@ -133,65 +134,74 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n             const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n             const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            match (&lit.node, &ety.sty) {\n+            let negated = match (&lit.node, &ety.sty) {\n                 (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    return Ok(Integral(I8(i8::min_value())))\n+                    Some(I8(i8::min_value()))\n                 },\n                 (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    return Ok(Integral(I16(i16::min_value())))\n+                    Some(I16(i16::min_value()))\n                 },\n                 (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    return Ok(Integral(I32(i32::min_value())))\n+                    Some(I32(i32::min_value()))\n                 },\n                 (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    return Ok(Integral(I64(i64::min_value())))\n+                    Some(I64(i64::min_value()))\n                 },\n                 (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n                 (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n-                    return Ok(Integral(I128(i128::min_value())))\n+                    Some(I128(i128::min_value()))\n                 },\n                 (&LitKind::Int(n, _), &ty::TyInt(IntTy::Is)) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n-                            return Ok(Integral(Isize(Is16(i16::min_value()))));\n+                            Some(Isize(Is16(i16::min_value())))\n+                        } else {\n+                            None\n                         },\n                         IntTy::I32 => if n == I32_OVERFLOW {\n-                            return Ok(Integral(Isize(Is32(i32::min_value()))));\n+                            Some(Isize(Is32(i32::min_value())))\n+                        } else {\n+                            None\n                         },\n                         IntTy::I64 => if n == I64_OVERFLOW {\n-                            return Ok(Integral(Isize(Is64(i64::min_value()))));\n+                            Some(Isize(Is64(i64::min_value())))\n+                        } else {\n+                            None\n                         },\n                         _ => span_bug!(e.span, \"typeck error\")\n                     }\n                 },\n-                _ => {},\n+                _ => None\n+            };\n+            if let Some(i) = negated {\n+                return Ok(tcx.mk_const(Integral(i)));\n             }\n         }\n-        match cx.eval(inner)? {\n+        tcx.mk_const(match *cx.eval(inner)? {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n-        }\n+        })\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match cx.eval(inner)? {\n+        tcx.mk_const(match *cx.eval(inner)? {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n-        }\n+        })\n       }\n       hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n       hir::ExprBinary(op, ref a, ref b) => {\n         // technically, if we don't have type hints, but integral eval\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (cx.eval(a)?, cx.eval(b)?) {\n+        tcx.mk_const(match (*cx.eval(a)?, *cx.eval(b)?) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -260,16 +270,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           }\n \n           _ => signal!(e, MiscBinaryOp),\n-        }\n+        })\n       }\n       hir::ExprCast(ref base, _) => {\n         let base_val = cx.eval(base)?;\n         let base_ty = cx.tables.expr_ty(base).subst(tcx, cx.substs);\n         if ety == base_ty {\n             base_val\n         } else {\n-            match cast_const(tcx, base_val, ety) {\n-                Ok(val) => val,\n+            match cast_const(tcx, *base_val, ety) {\n+                Ok(val) => tcx.mk_const(val),\n                 Err(kind) => signal!(e, kind),\n             }\n         }\n@@ -291,32 +301,32 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                     }\n               },\n               Def::VariantCtor(variant_def, CtorKind::Const) => {\n-                Variant(variant_def)\n+                tcx.mk_const(Variant(variant_def))\n               }\n               Def::VariantCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"enum variants\"));\n               }\n               Def::StructCtor(_, CtorKind::Const) => {\n-                  ConstVal::Struct(Default::default())\n+                  tcx.mk_const(Aggregate(Struct(&[])))\n               }\n               Def::StructCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n               }\n               Def::Local(id) => {\n                   debug!(\"Def::Local({:?}): {:?}\", id, cx.fn_args);\n-                  if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n-                      val.clone()\n+                  if let Some(&val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n+                      val\n                   } else {\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Method(id) | Def::Fn(id) => Function(id, substs),\n+              Def::Method(id) | Def::Fn(id) => tcx.mk_const(Function(id, substs)),\n               Def::Err => span_bug!(e.span, \"typeck error\"),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (def_id, substs) = match cx.eval(callee)? {\n+          let (def_id, substs) = match *cx.eval(callee)? {\n               Function(def_id, substs) => (def_id, substs),\n               _ => signal!(e, TypeckError),\n           };\n@@ -329,14 +339,14 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             };\n             match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size(tcx);\n-                    return Ok(Integral(Usize(ConstUsize::new(size.bytes(),\n-                        tcx.sess.target.uint_type).unwrap())));\n+                    let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n+                    return Ok(tcx.mk_const(Integral(Usize(ConstUsize::new(size,\n+                        tcx.sess.target.uint_type).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align(tcx);\n-                    return Ok(Integral(Usize(ConstUsize::new(align.abi(),\n-                        tcx.sess.target.uint_type).unwrap())));\n+                    let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n+                    return Ok(tcx.mk_const(Integral(Usize(ConstUsize::new(align,\n+                        tcx.sess.target.uint_type).unwrap()))));\n                 }\n                 _ => signal!(e, TypeckError)\n             }\n@@ -385,83 +395,83 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           callee_cx.eval(&body.value)?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n-          Ok(val) => val,\n+          Ok(val) => tcx.mk_const(val),\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => cx.eval(expr)?,\n-            None => Tuple(vec![]),\n+            None => tcx.mk_const(Aggregate(Tuple(&[]))),\n         }\n       }\n       hir::ExprType(ref e, _) => cx.eval(e)?,\n       hir::ExprTup(ref fields) => {\n-        Tuple(fields.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n+        let values = fields.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n+        tcx.mk_const(Aggregate(Tuple(tcx.alloc_constval_slice(&values))))\n       }\n       hir::ExprStruct(_, ref fields, _) => {\n-        Struct(fields.iter().map(|f| {\n+        tcx.mk_const(Aggregate(Struct(tcx.alloc_name_constval_slice(&fields.iter().map(|f| {\n             cx.eval(&f.expr).map(|v| (f.name.node, v))\n-        }).collect::<Result<_, _>>()?)\n+        }).collect::<Result<Vec<_>, _>>()?))))\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr = cx.eval(arr)?;\n-        let idx = match cx.eval(idx)? {\n+        let idx = match *cx.eval(idx)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n             _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n-        match arr {\n-            Array(ref v) => {\n-                if let Some(elem) = v.get(idx as usize) {\n-                    elem.clone()\n+        match *arr {\n+            Aggregate(Array(v)) => {\n+                if let Some(&elem) = v.get(idx as usize) {\n+                    elem\n                 } else {\n                     let n = v.len() as u64;\n                     assert_eq!(n as usize as u64, n);\n                     signal!(e, IndexOutOfBounds { len: n, index: idx })\n                 }\n             }\n \n-            Repeat(.., n) if idx >= n => {\n+            Aggregate(Repeat(.., n)) if idx >= n => {\n                 signal!(e, IndexOutOfBounds { len: n, index: idx })\n             }\n-            Repeat(ref elem, _) => (**elem).clone(),\n+            Aggregate(Repeat(elem, _)) => elem,\n \n-            ByteStr(ref data) if idx >= data.len() as u64 => {\n-                signal!(e, IndexOutOfBounds { len: data.len() as u64, index: idx })\n+            ByteStr(b) if idx >= b.data.len() as u64 => {\n+                signal!(e, IndexOutOfBounds { len: b.data.len() as u64, index: idx })\n             }\n-            ByteStr(data) => {\n-                Integral(U8(data[idx as usize]))\n+            ByteStr(b) => {\n+                tcx.mk_const(Integral(U8(b.data[idx as usize])))\n             },\n \n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n       hir::ExprArray(ref v) => {\n-        Array(v.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n+        let values = v.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n+        tcx.mk_const(Aggregate(Array(tcx.alloc_constval_slice(&values))))\n       }\n       hir::ExprRepeat(ref elem, _) => {\n           let n = match ety.sty {\n             ty::TyArray(_, n) => n as u64,\n             _ => span_bug!(e.span, \"typeck error\")\n           };\n-          Repeat(Box::new(cx.eval(elem)?), n)\n+          tcx.mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n       },\n       hir::ExprTupField(ref base, index) => {\n-        let c = cx.eval(base)?;\n-        if let Tuple(ref fields) = c {\n-            fields[index.node].clone()\n+        if let Aggregate(Tuple(fields)) = *cx.eval(base)? {\n+            fields[index.node]\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n-        let c = cx.eval(base)?;\n-        if let Struct(ref fields) = c {\n-            if let Some(f) = fields.get(&field_name.node) {\n-                f.clone()\n+        if let Aggregate(Struct(fields)) = *cx.eval(base)? {\n+            if let Some(&(_, f)) = fields.iter().find(|&&(name, _)| name == field_name.node) {\n+                f\n             } else {\n                 signal!(e, MissingStructField);\n             }\n@@ -625,7 +635,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n             },\n             ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyArray(ty, n) if ty == tcx.types.u8 && n == b.len() => Ok(ByteStr(b)),\n+                ty::TyArray(ty, n) if ty == tcx.types.u8 && n == b.data.len() => Ok(val),\n                 ty::TySlice(_) => {\n                     Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n                 },\n@@ -645,7 +655,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n+fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           mut ty: Ty<'tcx>)\n                           -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n@@ -660,7 +670,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n \n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n-        LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n+        LitKind::ByteStr(ref data) => Ok(ByteStr(ByteArray { data })),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, hint) => {\n             match (&ty.sty, hint) {\n@@ -708,8 +718,8 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n         (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n-        (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n-        (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n+        (&ByteStr(a), &ByteStr(b)) => Some(a.data.cmp(b.data)),\n+        (&Char(a), &Char(b)) => Some(a.cmp(&b)),\n         _ => None,\n     };\n \n@@ -729,8 +739,8 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn compare_lit_exprs(&self,\n                              span: Span,\n-                             a: &Expr,\n-                             b: &Expr) -> Result<Ordering, ErrorReported> {\n+                             a: &'tcx Expr,\n+                             b: &'tcx Expr) -> Result<Ordering, ErrorReported> {\n         let tcx = self.tcx;\n         let a = match self.eval(a) {\n             Ok(a) => a,"}, {"sha": "e824c4789c7c64d681c3f16b66e17444b6166d5b", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -83,12 +83,12 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ConstVal<'tcx>,\n     },\n \n     Range {\n-        lo: ConstVal<'tcx>,\n-        hi: ConstVal<'tcx>,\n+        lo: &'tcx ConstVal<'tcx>,\n+        hi: &'tcx ConstVal<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -112,15 +112,12 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Float(ref x) => write!(f, \"{}\", x),\n         ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n         ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n-        ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n+        ConstVal::ByteStr(b) => write!(f, \"{:?}\", b.data),\n         ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n         ConstVal::Variant(_) |\n-        ConstVal::Struct(_) |\n-        ConstVal::Tuple(_) |\n         ConstVal::Function(..) |\n-        ConstVal::Array(..) |\n-        ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n+        ConstVal::Aggregate(_) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n@@ -230,12 +227,12 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"{}\", subpattern)\n             }\n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 print_const_val(value, f)\n             }\n-            PatternKind::Range { ref lo, ref hi, ref end } => {\n+            PatternKind::Range { lo, hi, end } => {\n                 print_const_val(lo, f)?;\n-                match *end {\n+                match end {\n                     RangeEnd::Included => write!(f, \"...\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n@@ -278,7 +275,7 @@ impl<'a, 'tcx> Pattern<'tcx> {\n     pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n                     tables: &'a ty::TypeckTables<'tcx>,\n-                    pat: &hir::Pat) -> Self {\n+                    pat: &'tcx hir::Pat) -> Self {\n         let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n@@ -302,19 +299,19 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo, ref hi, ref end) => {\n+            PatKind::Range(ref lo, ref hi, end) => {\n                 match (self.lower_lit(lo), self.lower_lit(hi)) {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n-                        PatternKind::Range { lo: lo, hi: hi, end: end.clone() }\n+                        PatternKind::Range { lo, hi, end }\n                     }\n                     _ => PatternKind::Wild\n                 }\n@@ -474,11 +471,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n     {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n@@ -521,9 +518,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n-        prefix: &[P<hir::Pat>],\n-        slice: &Option<P<hir::Pat>>,\n-        suffix: &[P<hir::Pat>])\n+        prefix: &'tcx [P<hir::Pat>],\n+        slice: &'tcx Option<P<hir::Pat>>,\n+        suffix: &'tcx [P<hir::Pat>])\n         -> PatternKind<'tcx>\n     {\n         let prefix = self.lower_patterns(prefix);\n@@ -631,17 +628,17 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n         let const_cx = eval::ConstContext::new(self.tcx,\n                                                self.param_env.and(self.substs),\n                                                self.tables);\n         match const_cx.eval(expr) {\n             Ok(value) => {\n-                if let ConstVal::Variant(def_id) = value {\n+                if let ConstVal::Variant(def_id) = *value {\n                     let ty = self.tables.expr_ty(expr);\n                     self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n                 } else {\n-                    PatternKind::Constant { value: value }\n+                    PatternKind::Constant { value }\n                 }\n             }\n             Err(e) => {\n@@ -652,7 +649,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     fn lower_const_expr(&mut self,\n-                        expr: &hir::Expr,\n+                        expr: &'tcx hir::Expr,\n                         pat_id: ast::NodeId,\n                         span: Span)\n                         -> Pattern<'tcx> {\n@@ -819,8 +816,8 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region<'tcx>,\n-    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ConstVal<'tcx>,\n+    Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }\n \n@@ -892,18 +889,18 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n                 subpattern: subpattern.fold_with(folder),\n             },\n             PatternKind::Constant {\n-                ref value\n+                value\n             } => PatternKind::Constant {\n                 value: value.fold_with(folder)\n             },\n             PatternKind::Range {\n-                ref lo,\n-                ref hi,\n-                ref end,\n+                lo,\n+                hi,\n+                end,\n             } => PatternKind::Range {\n                 lo: lo.fold_with(folder),\n                 hi: hi.fold_with(folder),\n-                end: end.clone(),\n+                end,\n             },\n             PatternKind::Slice {\n                 ref prefix,"}, {"sha": "46a33ce807d7d7ddbc66a0abe80e2062c5bd0b3f", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -76,7 +76,7 @@ impl LintPass for TypeLimits {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                                              cx.param_env.and(substs),\n                                                              cx.tables);\n                             match const_cx.eval(&r) {\n-                                Ok(ConstVal::Integral(i)) => {\n+                                Ok(&ConstVal::Integral(i)) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n                                         .map(|i| i >= bits)"}, {"sha": "b475b02ccfeaa9cef80f562395fe1e2aa8c356de", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -16,6 +16,7 @@ use schema::*;\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n \n+use rustc::middle::const_val::{ByteArray, ConstVal};\n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -377,6 +378,20 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n+        Ok(ByteArray {\n+            data: self.tcx().alloc_byte_array(&Vec::decode(self)?)\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ConstVal<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ConstVal<'tcx>, Self::Error> {\n+        Ok(self.tcx().mk_const(Decodable::decode(self)?))\n+    }\n+}\n+\n impl<'a, 'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)"}, {"sha": "c5f83b029ce00724b02cf20170abb2600fe7f03c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: expr_span,\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n-                            value: ConstVal::Integral(ConstInt::U32(0)),\n+                            value: this.hir.tcx().mk_const(ConstVal::Integral(ConstInt::U32(0))),\n                         },\n                     }));\n                     box AggregateKind::Generator(closure_id, substs, interior)\n@@ -391,7 +391,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n@@ -424,7 +426,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)"}, {"sha": "2d029f1a5b7f74f7e4f2a49466252b1ba930ac66", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -301,13 +301,13 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<ConstVal<'tcx>>,\n-        indices: FxHashMap<ConstVal<'tcx>, usize>,\n+        options: Vec<&'tcx ConstVal<'tcx>>,\n+        indices: FxHashMap<&'tcx ConstVal<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ConstVal<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "5553e2f4c9ca17e1322c3b4e63e8812da07150e9", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -61,24 +61,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n-                        value: value.clone(),\n+                        value,\n                         ty: match_pair.pattern.ty.clone()\n                     }\n                 }\n             }\n \n-            PatternKind::Range { ref lo, ref hi, ref end } => {\n+            PatternKind::Range { lo, hi, end } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n-                        lo: Literal::Value { value: lo.clone() },\n-                        hi: Literal::Value { value: hi.clone() },\n+                        lo: Literal::Value { value: lo },\n+                        hi: Literal::Value { value: hi },\n                         ty: match_pair.pattern.ty.clone(),\n-                        end: end.clone(),\n+                        end,\n                     },\n                 }\n             }\n@@ -112,8 +112,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_lvalue: &Lvalue<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<ConstVal<'tcx>>,\n-                                     indices: &mut FxHashMap<ConstVal<'tcx>, usize>)\n+                                     options: &mut Vec<&'tcx ConstVal<'tcx>>,\n+                                     indices: &mut FxHashMap<&'tcx ConstVal<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n@@ -122,13 +122,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 // if the lvalues match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n \n-                indices.entry(value.clone())\n+                indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.clone());\n+                           options.push(value);\n                            options.len() - 1\n                        });\n                 true\n@@ -228,9 +228,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n-                    let ret = match &options[0] {\n-                        &ConstVal::Bool(true) => vec![true_bb, false_bb],\n-                        &ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                    let ret = match *options[0] {\n+                        ConstVal::Bool(true) => vec![true_bb, false_bb],\n+                        ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n                     (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Consume(lvalue.clone()),\n@@ -258,12 +258,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ret\n             }\n \n-            TestKind::Eq { ref value, mut ty } => {\n+            TestKind::Eq { value, mut ty } => {\n                 let mut val = Operand::Consume(lvalue.clone());\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n-                let expect = if let ConstVal::ByteStr(ref bytes) = *value {\n+                let expect = if let ConstVal::ByteStr(bytes) = *value {\n                     let tcx = self.hir.tcx();\n \n                     // Unsize the lvalue to &[u8], too, if necessary.\n@@ -279,10 +279,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     assert!(ty.is_slice());\n \n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len());\n                     let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n-                        value: value.clone()\n+                        value\n                     });\n \n                     let slice = self.temp(ty, test.span);\n@@ -291,7 +291,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Operand::Consume(slice)\n                 } else {\n                     self.literal_operand(test.span, ty, Literal::Value {\n-                        value: value.clone()\n+                        value\n                     })\n                 };\n "}, {"sha": "12b9174f3a3a6883312e57b8d2b29ff874216d2a", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -59,7 +59,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty::TyBool => {\n                 self.hir.false_literal()\n             }\n-            ty::TyChar => Literal::Value { value: ConstVal::Char('\\0') },\n+            ty::TyChar => {\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ConstVal::Char('\\0'))\n+                }\n+            }\n             ty::TyUint(ity) => {\n                 let val = match ity {\n                     ast::UintTy::U8  => ConstInt::U8(0),\n@@ -74,7 +78,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                }\n             }\n             ty::TyInt(ity) => {\n                 let val = match ity {\n@@ -90,7 +96,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)"}, {"sha": "704d138b43b58824d53fbcd7c924f0f05688e008", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -11,7 +11,6 @@\n \n use build;\n use hair::cx::Cx;\n-use hair::Pattern;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -537,10 +536,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = Pattern::from_hir(self.hir.tcx().global_tcx(),\n-                                                self.hir.param_env.and(self.hir.identity_substs),\n-                                                self.hir.tables(),\n-                                                pattern);\n+                let pattern = self.hir.pattern_from_hir(pattern);\n                 scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "f6b847d6d6de55a7778ca6a550547d0f1943b0d1", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -64,10 +64,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: index as u32,\n                         });\n \n-                        let pattern = Pattern::from_hir(cx.tcx.global_tcx(),\n-                                                        cx.param_env.and(cx.identity_substs),\n-                                                        cx.tables(),\n-                                                        &local.pat);\n+                        let pattern = cx.pattern_from_hir(&local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_scope,"}, {"sha": "0e4d2b9a5aefe4e408a1020fd1f76c96cedd98dd", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -473,7 +473,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n+                Ok(&ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n             };\n@@ -597,7 +597,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: cx.tcx.mk_const(ConstVal::Function(def_id, substs)),\n             },\n         },\n     }\n@@ -612,12 +612,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| {\n-            Pattern::from_hir(cx.tcx.global_tcx(),\n-                              cx.param_env.and(cx.identity_substs),\n-                              cx.tables(),\n-                              p)\n-        }).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }\n@@ -635,7 +630,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: cx.tcx.mk_const(ConstVal::Function(def_id, substs)),\n             },\n         },\n "}, {"sha": "9244ea14514fc93dc76fb7dfc739c745c9e64bc8", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -113,7 +113,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n+            Ok(val) => {\n+                Literal::Value {\n+                    value: self.tcx.mk_const(ConstVal::Integral(ConstInt::Usize(val)))\n+                }\n+            }\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -127,24 +131,36 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(true) }\n+        Literal::Value { value: self.tcx.mk_const(ConstVal::Bool(true)) }\n     }\n \n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(false) }\n+        Literal::Value { value: self.tcx.mk_const(ConstVal::Bool(false)) }\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let const_cx = ConstContext::new(tcx,\n                                          self.param_env.and(self.identity_substs),\n                                          self.tables());\n-        match const_cx.eval(e) {\n-            Ok(value) => Literal::Value { value: value },\n+        match const_cx.eval(tcx.hir.expect_expr(e.id)) {\n+            Ok(value) => Literal::Value { value },\n             Err(s) => self.fatal_const_eval_err(&s, e.span, \"expression\")\n         }\n     }\n \n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n+        let tcx = self.tcx.global_tcx();\n+        let p = match tcx.hir.get(p.id) {\n+            hir::map::NodePat(p) | hir::map::NodeBinding(p) => p,\n+            node => bug!(\"pattern became {:?}\", node)\n+        };\n+        Pattern::from_hir(tcx,\n+                          self.param_env.and(self.identity_substs),\n+                          self.tables(),\n+                          p)\n+    }\n+\n     pub fn fatal_const_eval_err(&mut self,\n         err: &ConstEvalErr<'tcx>,\n         primary_span: Span,\n@@ -170,7 +186,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,\n                         Literal::Value {\n-                            value: ConstVal::Function(item.def_id, substs),\n+                            value: self.tcx.mk_const(ConstVal::Function(item.def_id, substs)),\n                         });\n             }\n         }"}, {"sha": "d0a78b57217089f7fb7af83360e8fc51928bcf30", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: tcx.mk_fn_def(self.def_id, substs),\n             literal: Literal::Value {\n-                value: ConstVal::Function(self.def_id, substs),\n+                value: tcx.mk_const(ConstVal::Function(self.def_id, substs)),\n             },\n         });\n \n@@ -472,7 +472,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::Usize(value))\n+                value: self.tcx.mk_const(ConstVal::Integral(ConstInt::Usize(value)))\n             }\n         }\n     }\n@@ -711,8 +711,8 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 span,\n                 ty: tcx.type_of(def_id),\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id,\n-                        Substs::identity_for_item(tcx, def_id)),\n+                    value: tcx.mk_const(ConstVal::Function(def_id,\n+                        Substs::identity_for_item(tcx, def_id))),\n                 },\n             }),\n             vec![rcvr]"}, {"sha": "971df70a74e256574928f27f9087127c81b20e6c", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -520,7 +520,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             ty: self.tcx.types.bool,\n-            literal: Literal::Value { value: ConstVal::Bool(val) }\n+            literal: Literal::Value {\n+                value: self.tcx.mk_const(ConstVal::Bool(val))\n+            }\n         })))\n     }\n "}, {"sha": "74edf510aa2e7ecb1dd9b6a9d1fb88fc9ec2616a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                value: self.tcx.mk_const(ConstVal::Integral(ConstInt::U32(state_disc))),\n             },\n         });\n         Statement {\n@@ -553,7 +553,7 @@ fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: ConstVal::Bool(false),\n+                value: tcx.mk_const(ConstVal::Bool(false)),\n             },\n         }),\n         expected: true,\n@@ -603,7 +603,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: ConstVal::Bool(false),\n+                value: tcx.mk_const(ConstVal::Bool(false)),\n             },\n         }),\n         expected: true,"}, {"sha": "6c0a44b7631707ada7d607166858f53532ae68f3", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -56,7 +56,7 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n+                        value: &ConstVal::Bool(cond)\n                     }, ..\n                 }), expected, .. } if cond == expected => {\n                     TerminatorKind::Goto { target: target }"}, {"sha": "eaafdb0ac41783e29a39247ecb4f0afbc91bf440", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -572,7 +572,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match operand {\n             &Operand::Constant(box Constant {\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id, _), ..\n+                    value: &ConstVal::Function(def_id, _), ..\n                 }, ..\n             }) => {\n                 Some(def_id) == self.tcx().lang_items().box_free_fn()"}, {"sha": "d770dbe6f4f47903fddd4168e51da6ce0799ee61", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -922,7 +922,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n-            literal: Literal::Value { value: ConstVal::Integral(self.tcx().const_usize(val)) }\n+            literal: Literal::Value {\n+                value: self.tcx().mk_const(ConstVal::Integral(self.tcx().const_usize(val)))\n+            }\n         })\n     }\n "}, {"sha": "67176276f96fb1beac3256f93616d94e71920fad", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n     }\n \n     fn visit_const_val(&mut self,\n-                       const_val: &ConstVal,\n+                       const_val: &&'tcx ConstVal<'tcx>,\n                        _: Location) {\n         self.record(\"ConstVal\", const_val);\n         self.super_const_val(const_val);"}, {"sha": "a843b4171bd80f25b992fa1e6a5dcc69461a0995", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -110,7 +110,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(box mir::Constant {\n                     literal: Literal::Value {\n-                        value: ConstVal::Function(def_id, _), ..\n+                        value: &ConstVal::Function(def_id, _), ..\n                     }, ..\n                 }),\n                 ref args, .."}, {"sha": "d43911df83a2b74399663e6109b610387bd52e71", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -90,11 +90,11 @@ impl<'tcx> Const<'tcx> {\n \n     /// Translate ConstVal into a LLVM constant value.\n     pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                             cv: ConstVal,\n+                             cv: &ConstVal,\n                              ty: Ty<'tcx>)\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n-        let val = match cv {\n+        let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n                     ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n@@ -105,12 +105,11 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n+            ConstVal::ByteStr(v) => consts::addr_of(ccx, C_bytes(ccx, v.data), 1, \"byte_str\"),\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n             ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n             ConstVal::Variant(_) |\n-            ConstVal::Struct(_) | ConstVal::Tuple(_) |\n-            ConstVal::Array(..) | ConstVal::Repeat(..) => {\n+            ConstVal::Aggregate(..) => {\n                 bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n             }\n         };"}, {"sha": "8c3cf481e5eeeb4977fdc0791457ee260e133fa4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50076b00c2790a7941772cc97ee371e15b2cb776/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=50076b00c2790a7941772cc97ee371e15b2cb776", "patch": "@@ -572,7 +572,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             match result {\n-                Ok(ConstVal::Integral(x)) => Some(x),\n+                Ok(&ConstVal::Integral(x)) => Some(x),\n                 _ => None\n             }\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {"}]}