{"sha": "94db38a530c820005443fdac890f6d862f63e9d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZGIzOGE1MzBjODIwMDA1NDQzZmRhYzg5MGY2ZDg2MmY2M2U5ZDk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T11:19:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T15:31:15Z"}, "message": "Move expr_unary to DPS style\n\nIssue #667", "tree": {"sha": "7949b2bcbea9f8c57c4d24b36b7c8aa0c949b7dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7949b2bcbea9f8c57c4d24b36b7c8aa0c949b7dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94db38a530c820005443fdac890f6d862f63e9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94db38a530c820005443fdac890f6d862f63e9d9", "html_url": "https://github.com/rust-lang/rust/commit/94db38a530c820005443fdac890f6d862f63e9d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94db38a530c820005443fdac890f6d862f63e9d9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92d63ffa65b801e43b91927f8b23f0767bc42cd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/92d63ffa65b801e43b91927f8b23f0767bc42cd2", "html_url": "https://github.com/rust-lang/rust/commit/92d63ffa65b801e43b91927f8b23f0767bc42cd2"}], "stats": {"total": 186, "additions": 90, "deletions": 96}, "files": [{"sha": "8902e76e7df5f3a036bebf0265bcaf90c96fdb7b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=94db38a530c820005443fdac890f6d862f63e9d9", "patch": "@@ -2178,50 +2178,45 @@ fn node_type(cx: @crate_ctxt, sp: span, id: ast::node_id) -> TypeRef {\n     type_of(cx, sp, ty)\n }\n \n-fn trans_unary(cx: @block_ctxt, op: ast::unop, e: @ast::expr,\n-               id: ast::node_id) -> result {\n-    let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n+fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n+               id: ast::node_id, dest: dest) -> @block_ctxt {\n+    if dest == ignore { ret trans_expr_dps(bcx, e, ignore); }\n+    let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n     alt op {\n       ast::not. {\n-        let sub = trans_expr(cx, e);\n-        ret rslt(sub.bcx, Not(sub.bcx, sub.val));\n+        let {bcx, val} = trans_expr(bcx, e);\n+        ret store_in_dest(bcx, Not(bcx, val), dest);\n       }\n       ast::neg. {\n-        let sub = trans_expr(cx, e);\n-        if ty::struct(bcx_tcx(cx), e_ty) == ty::ty_float {\n-            ret rslt(sub.bcx, FNeg(sub.bcx, sub.val));\n-        } else { ret rslt(sub.bcx, Neg(sub.bcx, sub.val)); }\n+        let {bcx, val} = trans_expr(bcx, e);\n+        let neg = if ty::struct(bcx_tcx(bcx), e_ty) == ty::ty_float {\n+            FNeg(bcx, val)\n+        } else { Neg(bcx, val) };\n+        ret store_in_dest(bcx, neg, dest);\n       }\n       ast::box(_) {\n-        let lv = trans_lval(cx, e);\n-        let box_ty = node_id_type(bcx_ccx(lv.bcx), id);\n-        let sub = trans_malloc_boxed(lv.bcx, e_ty);\n-        let body = sub.body;\n-        add_clean_temp(cx, sub.box, box_ty);\n-\n+        let {bcx, box, body} = trans_malloc_boxed(bcx, e_ty);\n+        add_clean_free(bcx, box, false);\n         // Cast the body type to the type of the value. This is needed to\n         // make tags work, since tags have a different LLVM type depending\n         // on whether they're boxed or not.\n-        let sub_ccx = bcx_ccx(sub.bcx);\n-        if check type_has_static_size(sub_ccx, e_ty) {\n+        let ccx = bcx_ccx(bcx);\n+        if check type_has_static_size(ccx, e_ty) {\n             let e_sp = e.span;\n-            let llety = T_ptr(type_of(sub_ccx, e_sp, e_ty));\n-            body = PointerCast(sub.bcx, body, llety);\n-        } else {\n-        } // FIXME: can remove the else{} once we have\n-          // a new snapshot\n-\n-\n-        let bcx = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n-        ret rslt(bcx, sub.box);\n+            let llety = T_ptr(type_of(ccx, e_sp, e_ty));\n+            body = PointerCast(bcx, body, llety);\n+        }\n+        bcx = trans_expr_save_in(bcx, e, body);\n+        revoke_clean(bcx, box);\n+        ret store_in_dest(bcx, box, dest);\n       }\n       ast::uniq(_) {\n-        ret trans_uniq::trans_uniq(cx, e, id);\n+        ret trans_uniq::trans_uniq(bcx, e, id, dest);\n       }\n       ast::deref. {\n-        bcx_ccx(cx).sess.bug(\"deref expressions should have been \\\n-                                 translated using trans_lval(), not \\\n-                                 trans_unary()\");\n+        bcx_ccx(bcx).sess.bug(\"deref expressions should have been \\\n+                               translated using trans_lval(), not \\\n+                               trans_unary()\");\n       }\n     }\n }\n@@ -2498,7 +2493,7 @@ fn join_returns(parent_cx: @block_ctxt, in_cxs: [@block_ctxt],\n     ret out;\n }\n \n-// Used to put an immediate value in a dest\n+// Used to put an immediate value in a dest.\n fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n     alt dest {\n       ignore. {}\n@@ -4092,23 +4087,23 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f } };\n     let temp_cleanups = [], i = 0;\n     for tf in ty_fields {\n-        let gep = GEP_tup_like_1(bcx, t, addr, [0, i]);\n-        bcx = gep.bcx;\n+        let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n+        bcx = dst.bcx;\n         // FIXME make this {|f| str::eq(f.node.ident, tf.ident)} again when\n         // bug #913 is fixed\n         fn test(n: str, f: ast::field) -> bool { str::eq(f.node.ident, n) }\n         alt vec::find(bind test(tf.ident, _), fields) {\n           some(f) {\n-            bcx = trans_expr_save_in(bcx, f.node.expr, gep.val);\n+            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val);\n           }\n           none. {\n             let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n             let val = load_if_immediate(base.bcx, base.val, tf.mt.ty);\n-            bcx = copy_val(base.bcx, INIT, gep.val, val, tf.mt.ty);\n+            bcx = copy_val(base.bcx, INIT, dst.val, val, tf.mt.ty);\n           }\n         }\n-        add_clean_temp_mem(bcx, addr, tf.mt.ty);\n-        temp_cleanups += [addr];\n+        add_clean_temp_mem(bcx, dst.val, tf.mt.ty);\n+        temp_cleanups += [dst.val];\n         i += 1;\n     }\n     // Now revoke the cleanups as we pass responsibility for the data\n@@ -4193,9 +4188,6 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n         if sub.is_mem { v = load_if_immediate(sub.bcx, v, t); }\n         ret rslt(sub.bcx, v);\n       }\n-      ast::expr_unary(op, x) {\n-        ret trans_unary(cx, op, x, e.id);\n-      }\n       // Fall through to DPS-style\n       _ {\n         ret dps_to_result(cx, {|bcx, dest| trans_expr_dps(bcx, e, dest)},\n@@ -4259,6 +4251,12 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n       ast::expr_binary(op, x, y) { ret trans_binary(bcx, op, x, y, dest); }\n+      ast::expr_unary(op, x) {\n+        if op == ast::deref {\n+            ret trans_expr_backwards_compat(bcx, e, dest);\n+        }\n+        ret trans_unary(bcx, op, x, e.id, dest);\n+      }\n \n       ast::expr_break. {\n         assert dest == ignore;\n@@ -4365,40 +4363,43 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n \n       ast::expr_mac(_) { ret bcx_ccx(bcx).sess.bug(\"unexpanded macro\"); }\n       // Convert back from result to DPS\n-      _ {\n-        let lv = trans_lval(bcx, e);\n-        let {bcx, val, is_mem} = lv;\n-        let ty = ty::expr_ty(bcx_tcx(bcx), e);\n-        alt dest {\n-          by_val(cell) {\n-            if !is_mem {\n-                revoke_clean(bcx, val);\n-                *cell = val;\n-            } else if ty::type_is_unique(bcx_tcx(bcx), ty) {\n-                // Do a song and a dance to work around the fact that take_ty\n-                // for unique boxes overwrites the pointer.\n-                let oldval = Load(bcx, val);\n-                bcx = take_ty(bcx, val, ty);\n-                *cell = Load(bcx, val);\n-                Store(bcx, oldval, val);\n-            } else {\n-                bcx = take_ty(bcx, val, ty);\n-                *cell = Load(bcx, val);\n-            }\n-          }\n-          by_ref(cell) {\n-            assert is_mem;\n+      _ { ret trans_expr_backwards_compat(bcx, e, dest); }\n+    }\n+}\n+\n+fn trans_expr_backwards_compat(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n+    -> @block_ctxt {\n+    let lv = trans_lval(bcx, e);\n+    let {bcx, val, is_mem} = lv;\n+    let ty = ty::expr_ty(bcx_tcx(bcx), e);\n+    alt dest {\n+      by_val(cell) {\n+        if !is_mem {\n+            revoke_clean(bcx, val);\n             *cell = val;\n-          }\n-          save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n-          overwrite(loc, _) {\n-            bcx = move_val_if_temp(bcx, DROP_EXISTING, loc, lv, ty);\n-          }\n-          ignore. {}\n+        } else if ty::type_is_unique(bcx_tcx(bcx), ty) {\n+            // Do a song and a dance to work around the fact that take_ty\n+            // for unique boxes overwrites the pointer.\n+            let oldval = Load(bcx, val);\n+            bcx = take_ty(bcx, val, ty);\n+            *cell = Load(bcx, val);\n+            Store(bcx, oldval, val);\n+        } else {\n+            bcx = take_ty(bcx, val, ty);\n+            *cell = Load(bcx, val);\n         }\n-        ret bcx;\n       }\n+      by_ref(cell) {\n+        assert is_mem;\n+        *cell = val;\n+      }\n+      save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n+      overwrite(loc, _) {\n+        bcx = move_val_if_temp(bcx, DROP_EXISTING, loc, lv, ty);\n+      }\n+      ignore. {}\n     }\n+    ret bcx;\n }\n \n // We pass structural values around the compiler \"by pointer\" and"}, {"sha": "eb6b6c9f31164138618b2e859d50b9189d1245ec", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=94db38a530c820005443fdac890f6d862f63e9d9", "patch": "@@ -288,6 +288,13 @@ fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     scope_cx.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n     scope_cx.lpad_dirty = true;\n }\n+fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n+    let scope_cx = find_scope_cx(cx);\n+    let free_fn = if shared { bind trans::trans_shared_free(_, ptr) }\n+                  else { bind trans::trans_non_gc_free(_, ptr) };\n+    scope_cx.cleanups += [clean_temp(ptr, free_fn)];\n+    scope_cx.lpad_dirty = true;\n+}\n \n // Note that this only works for temporaries. We should, at some point, move\n // to a system where we can also cancel the cleanup on local variables, but"}, {"sha": "52865564c0481e8ba64c1f9604983c8a50cbb678", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=94db38a530c820005443fdac890f6d862f63e9d9", "patch": "@@ -13,7 +13,8 @@ import trans::{\n     trans_shared_free,\n     drop_ty,\n     new_sub_block_ctxt,\n-    load_if_immediate\n+    load_if_immediate,\n+    dest\n };\n \n export trans_uniq, make_free_glue, type_is_unique_box, copy_val,\n@@ -23,31 +24,15 @@ pure fn type_is_unique_box(bcx: @block_ctxt, ty: ty::t) -> bool {\n     ty::type_is_unique_box(bcx_tcx(bcx), ty)\n }\n \n-fn trans_uniq(cx: @block_ctxt, contents: @ast::expr,\n-              node_id: ast::node_id) -> result {\n-    let bcx = cx;\n-\n-    let lv = trans_lval(bcx, contents);\n-    bcx = lv.bcx;\n-\n-    let uniq_ty = node_id_type(bcx_ccx(cx), node_id);\n-\n-    if ty::type_is_bot(bcx_tcx(bcx), uniq_ty) {\n-        // FIXME: Seems to work, obviously not 'right'. Story of my life.\n-        // Probably works because the builder turns lv.val into undef\n-        ret rslt(bcx, lv.val);\n-    }\n-\n+fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n+              node_id: ast::node_id, dest: dest) -> @block_ctxt {\n+    let uniq_ty = node_id_type(bcx_ccx(bcx), node_id);\n     check type_is_unique_box(bcx, uniq_ty);\n-    let content_ty = content_ty(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n-\n-    add_clean_temp(bcx, llptr, uniq_ty);\n-\n-    bcx = move_val_if_temp(bcx, INIT, llptr, lv,\n-                           content_ty);\n-\n-    ret rslt(bcx, llptr);\n+    add_clean_free(bcx, llptr, true);\n+    bcx = trans::trans_expr_save_in(bcx, contents, llptr);\n+    revoke_clean(bcx, llptr);\n+    ret trans::store_in_dest(bcx, llptr, dest);\n }\n \n fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)"}, {"sha": "cda37664ec18b96a5afb86e6b14051998d5c9f5b", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94db38a530c820005443fdac890f6d862f63e9d9/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=94db38a530c820005443fdac890f6d862f63e9d9", "patch": "@@ -116,10 +116,11 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n          llunitty: llunitty} =\n         alloc(bcx, vec_ty, vec::len(args), dest);\n \n+    let vptr = Load(bcx, vptrptr);\n+    add_clean_free(bcx, vptr, true);\n     // Store the individual elements.\n     let dataptr = get_dataptr(bcx, vptrptr, llunitty);\n-    add_clean_temp_mem(bcx, vptrptr, vec_ty);\n-    let i = 0u, temp_cleanups = [vptrptr];\n+    let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.bcx;"}]}