{"sha": "451363dc59b3030fee82e4faf04684c068f619cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MTM2M2RjNTliMzAzMGZlZTgyZTRmYWYwNDY4NGMwNjhmNjE5Y2M=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-05-14T22:20:07Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-06-08T20:00:33Z"}, "message": "still working on displaying nested imports", "tree": {"sha": "f412d63c8b603011edf1cb4cea436a0044e95995", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f412d63c8b603011edf1cb4cea436a0044e95995"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/451363dc59b3030fee82e4faf04684c068f619cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/451363dc59b3030fee82e4faf04684c068f619cc", "html_url": "https://github.com/rust-lang/rust/commit/451363dc59b3030fee82e4faf04684c068f619cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/451363dc59b3030fee82e4faf04684c068f619cc/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed", "html_url": "https://github.com/rust-lang/rust/commit/8bc106b29d3d2ee382f6dc4a2e9d6eecf534c6ed"}], "stats": {"total": 291, "additions": 214, "deletions": 77}, "files": [{"sha": "8dddd6d716d8ef711d1a8e66be3d1fb9bfbfdbaf", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 214, "deletions": 77, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/451363dc59b3030fee82e4faf04684c068f619cc/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451363dc59b3030fee82e4faf04684c068f619cc/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=451363dc59b3030fee82e4faf04684c068f619cc", "patch": "@@ -2,7 +2,7 @@ use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n use rustc_ast::ast;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -38,7 +38,7 @@ pub struct MacroRefData {\n }\n \n impl MacroRefData {\n-    pub fn new(name: &str, callee: Span, cx: &LateContext<'_, '_>) -> Self {\n+    pub fn new(name: String, callee: Span, cx: &LateContext<'_, '_>) -> Self {\n         let mut path = cx.sess().source_map().span_to_filename(callee).to_string();\n \n         // std lib paths are <::std::module::file type>\n@@ -50,7 +50,7 @@ impl MacroRefData {\n             path = path.split(' ').next().unwrap().to_string();\n         }\n         Self {\n-            name: name.to_string(),\n+            name,\n             path,\n         }\n     }\n@@ -69,128 +69,265 @@ pub struct MacroUseImports {\n impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n \n impl MacroUseImports {\n-    fn push_unique_macro(&mut self, cx: &LateContext<'_, '_>, name: &str, call_site: Span, callee: Span) {\n-        if !self.collected.contains(&call_site) {\n-            let name = if name.contains(\"::\") {\n-                name.split(\"::\").last().unwrap().to_string()\n-            } else {\n-                name.to_string()\n-            };\n-\n-            self.mac_refs.push(MacroRefData::new(&name, callee, cx));\n-            self.collected.insert(call_site);\n+    fn push_unique_macro(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+        let call_site = span.source_callsite();\n+        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+        if let Some(callee) = span.source_callee() {\n+            if !self.collected.contains(&call_site) {\n+                let name = if name.contains(\"::\") {\n+                    name.split(\"::\").last().unwrap().to_string()\n+                } else {\n+                    name.to_string()\n+                };\n+    \n+                self.mac_refs.push(MacroRefData::new(name, callee.def_site, cx));\n+                self.collected.insert(call_site);\n+            }\n         }\n     }\n \n-    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_, '_>, name: &str, call_site: Span, callee: Span) {\n-        if !self.collected.contains(&call_site) {\n-            self.mac_refs.push(MacroRefData::new(&name, callee, cx));\n-            self.collected.insert(call_site);\n+    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+        let call_site = span.source_callsite();\n+        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+        if let Some(callee) = span.source_callee() {\n+            if !self.collected.contains(&call_site) {\n+                self.mac_refs.push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n+                self.collected.insert(call_site);\n+            }\n         }\n     }\n }\n \n impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if_chain! {\n-                if cx.sess().opts.edition == Edition::Edition2018;\n-                if let hir::ItemKind::Use(path, _kind) = &item.kind;\n-                if let Some(mac_attr) = item\n-                    .attrs\n-                    .iter()\n-                    .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n-                if let Res::Def(DefKind::Mod, id) = path.res;\n-                then {\n-                    for kid in cx.tcx.item_children(id).iter() {\n-                        if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n-                            let span = mac_attr.span;\n-                            self.imports.push((cx.tcx.def_path_str(mac_id), span));\n-                        }\n-                    }\n-                } else {\n-                    if in_macro(item.span) {\n-                        let call_site = item.span.source_callsite();\n-                        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-                        if let Some(callee) = item.span.source_callee() {\n-                            if !self.collected.contains(&call_site) {\n-                                self.mac_refs.push(MacroRefData::new(&name, callee.def_site, cx));\n-                                self.collected.insert(call_site);\n-                            }\n-                        }\n+            if cx.sess().opts.edition == Edition::Edition2018;\n+            if let hir::ItemKind::Use(path, _kind) = &item.kind;\n+            if let Some(mac_attr) = item\n+                .attrs\n+                .iter()\n+                .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n+            if let Res::Def(DefKind::Mod, id) = path.res;\n+            then {\n+                for kid in cx.tcx.item_children(id).iter() {\n+                    if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n+                        let span = mac_attr.span;\n+                        self.imports.push((cx.tcx.def_path_str(mac_id), span));\n                     }\n+                }\n+            } else {\n+                if in_macro(item.span) {\n+                    self.push_unique_macro_pat_ty(cx, item.span);\n+                }\n             }\n         }\n     }\n     fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n         if in_macro(attr.span) {\n-            let call_site = attr.span.source_callsite();\n-            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-            if let Some(callee) = attr.span.source_callee() {\n-                self.push_unique_macro(cx, &name, call_site, callee.def_site);\n-            }\n+            self.push_unique_macro(cx, attr.span);\n         }\n     }\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         if in_macro(expr.span) {\n-            let call_site = expr.span.source_callsite();\n-            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-            if let Some(callee) = expr.span.source_callee() {\n-                self.push_unique_macro(cx, &name, call_site, callee.def_site);\n-            }\n+            self.push_unique_macro(cx, expr.span);\n         }\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n         if in_macro(stmt.span) {\n-            let call_site = stmt.span.source_callsite();\n-            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-            if let Some(callee) = stmt.span.source_callee() {\n-                self.push_unique_macro(cx, &name, call_site, callee.def_site);\n-            }\n+            self.push_unique_macro(cx, stmt.span);\n         }\n     }\n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n         if in_macro(pat.span) {\n-            let call_site = pat.span.source_callsite();\n-            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-            if let Some(callee) = pat.span.source_callee() {\n-                self.push_unique_macro_pat_ty(cx, &name, call_site, callee.def_site);\n-            }\n+            self.push_unique_macro_pat_ty(cx, pat.span);\n         }\n     }\n     fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n         if in_macro(ty.span) {\n-            let call_site = ty.span.source_callsite();\n-            let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-            if let Some(callee) = ty.span.source_callee() {\n-                self.push_unique_macro_pat_ty(cx, &name, call_site, callee.def_site);\n-            }\n+            self.push_unique_macro_pat_ty(cx, ty.span);\n         }\n     }\n \n     fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n+        let mut import_map = FxHashMap::default();\n         for (import, span) in &self.imports {\n-            let matched = self.mac_refs.iter().any(|mac| import.ends_with(&mac.name));\n+            let found_idx = self.mac_refs.iter().position(|mac| import.ends_with(&mac.name));\n+            \n+            if let Some(idx) = found_idx {\n+                let _ = self.mac_refs.remove(idx);\n+                proccess_macro_path(*span, import, &mut import_map);\n+            }\n+        }\n+        println!(\"{:#?}\", import_map);\n+        let mut imports = vec![];\n+        for (root, rest) in import_map {\n+            let mut path = format!(\"use {}::\", root);\n+            let mut s = None;\n+            let mut count = 1;\n+            let rest_len = rest.len();\n+            if rest_len > 1 {\n+                path.push_str(\"{\");\n+            }\n+            for m in &rest {\n+                println!(\"{} => {:?}\", root, m);\n+                if count == 1 {\n+                    s = Some(m.span());\n+                }\n+                \n+                let comma = if rest_len == count { \"\" } else { \", \" };\n+                match m {\n+                    ModPath::Item { item, .. } => {\n+                        path.push_str(&format!(\"{}{}\", item, comma));\n+                    }\n+                    ModPath::Nested { names, item, span } => {\n+                        let nested = rest.iter()\n+                            // filter \"self\" out\n+                            .filter(|other_m| other_m != &m)\n+                            // this matches the first path segment and filters non ModPath::Nested items\n+                            .filter(|other_m| other_m.matches(0, m))\n+                            .collect::<Vec<_>>();\n+\n+                        println!(\"{:#?}\", nested);\n+\n+                        if nested.is_empty() {\n+                            path.push_str(&format!(\"{}::{}{}\", names.join(\"::\").to_string(), item, comma))\n+                        } else {\n+                            // use mod_a::{mod_b::{one, two}, mod_c::item, item1, item2}\n+                            let mod_path = if names.len() - 1 > 0 {\n+                                ModPath::Nested { names: names.clone(), item: item.to_string(), span: *span, }\n+                            } else {\n+                                ModPath::Item { item: names[0].to_string(), span: *span, }\n+                            };\n+                            let names = recursive_path_push(mod_path, comma, &rest, String::new());\n+                            path.push_str(&format!(\"{}::{{{}}}{}\", names, item, comma))\n+                        }\n+                    }\n+                }\n+                count += 1;             \n+            }\n+            if rest_len > 1 {\n+                path.push_str(\"};\");\n+            }\n+            if let Some(span) = s {\n+                imports.push((span, path))\n+            }\n+        }\n \n-            if matched {\n-                self.mac_refs.retain(|mac| !import.ends_with(&mac.name));\n-                let msg = \"`macro_use` attributes are no longer needed in the Rust 2018 edition\";\n+        if !self.mac_refs.is_empty() {\n+            // TODO if not empty we found one we could not make a suggestion for\n+            // such as std::prelude::v1 or something else I haven't thought of.\n+            // If we defer the calling of span_lint_and_sugg we can make a decision about its\n+            // applicability?\n+        } else {\n+            for (span, import) in imports {\n                 let help = format!(\"use {}\", import);\n                 span_lint_and_sugg(\n                     cx,\n                     MACRO_USE_IMPORTS,\n-                    *span,\n-                    msg,\n+                    span,\n+                    \"`macro_use` attributes are no longer needed in the Rust 2018 edition\",\n                     \"remove the attribute and import the macro directly, try\",\n                     help,\n                     Applicability::MaybeIncorrect,\n                 )\n             }\n         }\n-        if !self.mac_refs.is_empty() {\n-            // TODO if not empty we found one we could not make a suggestion for\n-            // such as std::prelude::v1 or something else I haven't thought of.\n-            // If we defer the calling of span_lint_and_sugg we can make a decision about its\n-            // applicability?\n+    }\n+}\n+\n+#[derive(Debug, PartialEq)]\n+enum ModPath {\n+    Item { item: String, span: Span, },\n+    Nested { names: Vec<String>, item: String, span: Span, },\n+}\n+\n+impl ModPath {\n+    fn span(&self) -> Span {\n+        match self {\n+            Self::Item { span, .. } => *span,\n+            Self::Nested { span, .. } => *span,\n+        }\n+    }\n+\n+    fn item(&self) -> &str {\n+        match self {\n+            Self::Item { item, .. } => item,\n+            Self::Nested { item, .. } => item,\n+        }\n+    }\n+\n+    fn matches(&self, idx: usize, other: &ModPath) -> bool {\n+        match (self, other) {\n+            (Self::Item { item, .. }, Self::Item { item: other_item, .. }) => item == other_item,\n+            (Self::Nested { names, .. }, Self::Nested { names: other_names, .. }) => {\n+                match (names.get(idx), other_names.get(idx)) {\n+                    (Some(seg), Some(other_seg)) => seg == other_seg,\n+                    (_, _) => false,\n+                }\n+            }\n+            (_, _) => false,\n+        }\n+    }\n+}\n+\n+fn proccess_macro_path(span: Span, import: &str, import_map: &mut FxHashMap<String, Vec<ModPath>>) {\n+    let mut mod_path = import.split(\"::\").collect::<Vec<_>>();\n+\n+    if mod_path.len() == 2 {\n+        let item_list = import_map.entry(mod_path[0].to_string())\n+            .or_insert(vec![]);\n+\n+        if !item_list.iter().any(|mods| mods.item() == mod_path[1]) {\n+            item_list.push(ModPath::Item{\n+                item: mod_path[1].to_string(),\n+                span,\n+            });\n+        }\n+    } else if mod_path.len() > 2 {\n+        let first = mod_path.remove(0);\n+        let name = mod_path.remove(mod_path.len() - 1);\n+\n+        let nested = ModPath::Nested {\n+            names: mod_path.into_iter().map(ToString::to_string).collect(),\n+            item: name.to_string(),\n+            span,\n+        };\n+        import_map.entry(first.to_string())\n+            .or_insert(vec![])\n+            .push(nested);\n+    } else {\n+        unreachable!(\"test to see if code path hit TODO REMOVE\")\n+    }\n+}\n+\n+fn recursive_path_push(module: ModPath, comma: &str, rest: &[ModPath], mut path: String) -> String {\n+    match &module {\n+        ModPath::Item { item, .. } => {\n+            path.push_str(&format!(\"{}{}\", item, comma));\n+        }\n+        ModPath::Nested { names, item, span } => {\n+            let nested = rest.iter()\n+                // filter \"self\" out\n+                .filter(|other_m| other_m != &&module)\n+                // this matches the first path segment and filters non ModPath::Nested items\n+                .filter(|other_m| other_m.matches(0, &module))\n+                .collect::<Vec<_>>();\n+\n+            println!(\"{:#?}\", nested);\n+\n+            if nested.is_empty() {\n+                path.push_str(&format!(\"{}::{}{}\", names.join(\"::\").to_string(), item, comma))\n+            } else {\n+                // use mod_a::{mod_b::{one, two}, mod_c::item, item1, item2}\n+                let mod_path = if names.len() - 1 > 0 {\n+                    ModPath::Nested { names: names.clone(), item: item.to_string(), span: *span, }\n+                } else {\n+                    ModPath::Item { item: names[0].to_string(), span: *span, }\n+                };\n+                let names = recursive_path_push(mod_path, comma, rest, path.to_string());\n+                // path.push_str(&format!(\"{}{}\", item, comma));\n+            }\n         }\n     }\n+    path\n }"}]}