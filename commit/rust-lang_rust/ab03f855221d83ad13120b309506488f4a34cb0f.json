{"sha": "ab03f855221d83ad13120b309506488f4a34cb0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMDNmODU1MjIxZDgzYWQxMzEyMGIzMDk1MDY0ODhmNGEzNGNiMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-10T10:05:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-10T10:05:45Z"}, "message": "Auto merge of #37463 - jseyfried:refactor_macro_reexports, r=nrc\n\nmacros: improve reexports\n\nThis PR\n- avoids building multiple module graphs for a crate that is referenced by multiple `extern crate` items,\n- registers `#[no_link] extern crate`s to avoid loading the same crate metadata twice,\n- stability checks `#[no_link] extern crate`s,\n  - [breaking-chage]: `#[no_link] #[macro_use] extern crate syntax;` is allowed on stable today\n- fixes `$crate` in `#[macro_reexport]`ed macros,\n  - [breaking-change] for `#[feature(macro_reexport)]` (technically)\n- allows selective macro importing (i.e. `#[macro_use(foo, bar)]`) from custom derive crates, and\n- refactors the crate metadata to support re-exported macros in arbitrary modules (not yet needed).\n\nr? @nrc", "tree": {"sha": "247c8093d92f1203f19f59e47b8e19305539f321", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/247c8093d92f1203f19f59e47b8e19305539f321"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab03f855221d83ad13120b309506488f4a34cb0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab03f855221d83ad13120b309506488f4a34cb0f", "html_url": "https://github.com/rust-lang/rust/commit/ab03f855221d83ad13120b309506488f4a34cb0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab03f855221d83ad13120b309506488f4a34cb0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c11e2bda394c786fff27df94bfbe292ba33294df", "url": "https://api.github.com/repos/rust-lang/rust/commits/c11e2bda394c786fff27df94bfbe292ba33294df", "html_url": "https://github.com/rust-lang/rust/commit/c11e2bda394c786fff27df94bfbe292ba33294df"}, {"sha": "a0a9f8ca1bdfa5e71dc4e51661f80097cbe24513", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a9f8ca1bdfa5e71dc4e51661f80097cbe24513", "html_url": "https://github.com/rust-lang/rust/commit/a0a9f8ca1bdfa5e71dc4e51661f80097cbe24513"}], "stats": {"total": 896, "additions": 477, "deletions": 419}, "files": [{"sha": "044e36e5c9cd46fdc15aadd9e5ee0a01d401113d", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -52,6 +52,9 @@ pub enum Def {\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n \n+    // Macro namespace\n+    Macro(DefId),\n+\n     // Both namespaces\n     Err,\n }\n@@ -133,7 +136,7 @@ impl Def {\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) => {\n+            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n                 id\n             }\n \n@@ -173,6 +176,7 @@ impl Def {\n             Def::Upvar(..) => \"closure capture\",\n             Def::Label(..) => \"label\",\n             Def::SelfTy(..) => \"self type\",\n+            Def::Macro(..) => \"macro\",\n             Def::Err => \"unresolved item\",\n         }\n     }"}, {"sha": "d3771b1755b1659d5b36c61d908a50981a4ba444", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -34,6 +34,10 @@ impl Idx for CrateNum {\n /// LOCAL_CRATE in their DefId.\n pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n \n+/// Virtual crate for builtin macros\n+// FIXME(jseyfried): this is also used for custom derives until proc-macro crates get `CrateNum`s.\n+pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(!0);\n+\n impl CrateNum {\n     pub fn new(x: usize) -> CrateNum {\n         assert!(x < (u32::MAX as usize));"}, {"sha": "04fcf7e84508e986c4b6c0151a65d39525513062", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -226,4 +226,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.insert_entry(macro_def.id, NotPresent);\n+    }\n }"}, {"sha": "db3c7d0450b3859c9b290e7329857a3c7f2e2955", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -61,7 +61,18 @@ pub struct LinkMeta {\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: CrateNum,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+pub enum DepKind {\n+    /// A dependency that is only used for its macros.\n+    MacrosOnly,\n+    /// A dependency that is always injected into the dependency list and so\n+    /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n+    Implicit,\n+    /// A dependency that is required by an rlib version of this crate.\n+    /// Ordinary `extern crate`s result in `Explicit` dependencies.\n+    Explicit,\n }\n \n #[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n@@ -170,10 +181,10 @@ pub trait CrateStore<'tcx> {\n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                     -> Vec<(CrateNum, LinkagePreference)>;\n+    fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n     fn is_staged_api(&self, cnum: CrateNum) -> bool;\n-    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool;\n     fn is_allocator(&self, cnum: CrateNum) -> bool;\n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n@@ -200,6 +211,7 @@ pub trait CrateStore<'tcx> {\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n+    fn load_macro(&self, did: DefId, sess: &Session) -> ast::MacroDef;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -342,7 +354,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n     fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n-    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n     fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n@@ -371,6 +383,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n+    fn load_macro(&self, did: DefId, sess: &Session) -> ast::MacroDef { bug!(\"load_macro\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -410,22 +423,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub enum LoadedMacros {\n-    MacroRules(Vec<ast::MacroDef>),\n-    ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n-}\n-\n-impl LoadedMacros {\n-    pub fn is_proc_macros(&self) -> bool {\n-        match *self {\n-            LoadedMacros::ProcMacros(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n pub trait CrateLoader {\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n-                    -> Option<LoadedMacros>;\n+                    -> Vec<(ast::Name, SyntaxExtension)>;\n     fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "92d1ab85c5a05afcf806eb14e7330c9d595b22a1", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -65,6 +65,7 @@ use hir::def_id::CrateNum;\n \n use session;\n use session::config;\n+use middle::cstore::DepKind;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n@@ -123,6 +124,7 @@ fn calculate_type(sess: &session::Session,\n                 return v;\n             }\n             for cnum in sess.cstore.crates() {\n+                if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n                 let src = sess.cstore.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n@@ -155,6 +157,7 @@ fn calculate_type(sess: &session::Session,\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n     for cnum in sess.cstore.crates() {\n+        if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n         let name = sess.cstore.crate_name(cnum);\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {\n@@ -188,7 +191,7 @@ fn calculate_type(sess: &session::Session,\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n-           sess.cstore.is_explicitly_linked(cnum) {\n+           sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n@@ -272,7 +275,7 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n     // everything in explicitly so long as it's actually required.\n     let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.is_explicitly_linked(CrateNum::new(cnum)) {\n+        if sess.cstore.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked"}, {"sha": "0b0dd596784e91cf43b3af98f1bb8474c0fcc401", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -834,7 +834,8 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Local(..) |\n-            Def::Upvar(..) => {\n+            Def::Upvar(..) |\n+            Def::Macro(..) => {\n                 DefHash::SawDefId.hash(self.st);\n                 self.hash_def_id(def.def_id());\n             }"}, {"sha": "07b87072c435e6ef14d9ebc0322285e6fe3446ca", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -29,6 +29,7 @@\n #![feature(staged_api)]\n #![feature(linked_from)]\n #![feature(concat_idents)]\n+#![cfg_attr(not(stage0), feature(rustc_private))]\n \n extern crate libc;\n #[macro_use]"}, {"sha": "e53f1a0633b6211c2e43c86d0c28446bdb394154", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 87, "deletions": 146, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -16,7 +16,7 @@ use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::LoadedMacros;\n+use rustc::middle::cstore::DepKind;\n use rustc::session::{config, Session};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n@@ -29,15 +29,15 @@ use std::cell::{RefCell, Cell};\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::fs;\n+use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::parse;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n+use syntax::feature_gate::{self, emit_feature_err};\n use syntax::parse::token::{InternedString, intern};\n-use syntax_pos::{self, Span, mk_sp};\n+use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n pub struct Library {\n@@ -56,29 +56,23 @@ pub struct CrateLoader<'a> {\n \n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n-    cstore.iter_crate_data_origins(|_, data, opt_source| {\n+    cstore.iter_crate_data(|_, data| {\n         info!(\"  name: {}\", data.name());\n         info!(\"  cnum: {}\", data.cnum);\n         info!(\"  hash: {}\", data.hash());\n-        info!(\"  reqd: {}\", data.explicitly_linked.get());\n-        opt_source.map(|cs| {\n-            let CrateSource { dylib, rlib, cnum: _ } = cs;\n-            dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n-            rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n-        });\n+        info!(\"  reqd: {:?}\", data.dep_kind.get());\n+        let CrateSource { dylib, rlib } = data.source.clone();\n+        dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n+        rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n     })\n }\n \n-fn should_link(i: &ast::Item) -> bool {\n-    !attr::contains_name(&i.attrs, \"no_link\")\n-}\n-\n #[derive(Debug)]\n struct ExternCrateInfo {\n     ident: String,\n     name: String,\n     id: ast::NodeId,\n-    should_link: bool,\n+    dep_kind: DepKind,\n }\n \n fn register_native_lib(sess: &Session,\n@@ -170,7 +164,11 @@ impl<'a> CrateLoader<'a> {\n                     ident: i.ident.to_string(),\n                     name: name,\n                     id: i.id,\n-                    should_link: should_link(i),\n+                    dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n+                        DepKind::MacrosOnly\n+                    } else {\n+                        DepKind::Explicit\n+                    },\n                 })\n             }\n             _ => None\n@@ -260,9 +258,8 @@ impl<'a> CrateLoader<'a> {\n                       name: &str,\n                       span: Span,\n                       lib: Library,\n-                      explicitly_linked: bool)\n-                      -> (CrateNum, Rc<cstore::CrateMetadata>,\n-                          cstore::CrateSource) {\n+                      dep_kind: DepKind)\n+                      -> (CrateNum, Rc<cstore::CrateMetadata>) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n         let crate_root = lib.metadata.get_root();\n         self.verify_no_symbol_conflicts(span, &crate_root);\n@@ -286,7 +283,7 @@ impl<'a> CrateLoader<'a> {\n \n         let Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span);\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         if crate_root.macro_derive_registrar.is_some() {\n             self.sess.span_err(span, \"crates of the `proc-macro` crate type \\\n@@ -302,18 +299,15 @@ impl<'a> CrateLoader<'a> {\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n-            explicitly_linked: Cell::new(explicitly_linked),\n+            dep_kind: Cell::new(dep_kind),\n+            source: cstore::CrateSource {\n+                dylib: dylib,\n+                rlib: rlib,\n+            },\n         });\n \n-        let source = cstore::CrateSource {\n-            dylib: dylib,\n-            rlib: rlib,\n-            cnum: cnum,\n-        };\n-\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n-        self.cstore.add_used_crate_source(source.clone());\n-        (cnum, cmeta, source)\n+        (cnum, cmeta)\n     }\n \n     fn resolve_crate(&mut self,\n@@ -323,8 +317,8 @@ impl<'a> CrateLoader<'a> {\n                      hash: Option<&Svh>,\n                      span: Span,\n                      kind: PathKind,\n-                     explicitly_linked: bool)\n-                     -> (CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n+                     dep_kind: DepKind)\n+                     -> (CrateNum, Rc<cstore::CrateMetadata>) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n@@ -356,14 +350,11 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             LoadResult::Previous(cnum) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if explicitly_linked && !data.explicitly_linked.get() {\n-                    data.explicitly_linked.set(explicitly_linked);\n-                }\n-                (cnum, data, self.cstore.used_crate_source(cnum))\n+                data.dep_kind.set(cmp::max(data.dep_kind.get(), dep_kind));\n+                (cnum, data)\n             }\n             LoadResult::Loaded(library) => {\n-                self.register_crate(root, ident, name, span, library,\n-                                    explicitly_linked)\n+                self.register_crate(root, ident, name, span, library, dep_kind)\n             }\n         }\n     }\n@@ -436,21 +427,23 @@ impl<'a> CrateLoader<'a> {\n                           crate_root: &CrateRoot,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n-                          span: Span)\n+                          span: Span,\n+                          dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         let deps = crate_root.crate_deps.decode(metadata);\n         let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-            let (local_cnum, ..) = self.resolve_crate(root,\n-                                                        &dep.name.as_str(),\n-                                                        &dep.name.as_str(),\n-                                                        Some(&dep.hash),\n-                                                        span,\n-                                                        PathKind::Dependency,\n-                                                        dep.explicitly_linked);\n+            let dep_name = &dep.name.as_str();\n+            let dep_kind = match dep_kind {\n+                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                _ => dep.kind,\n+            };\n+            let (local_cnum, ..) = self.resolve_crate(\n+                root, dep_name, dep_name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+            );\n             (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n \n@@ -464,8 +457,8 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &ExternCrateInfo) -> ExtensionCrate {\n-        info!(\"read extension crate {} `extern crate {} as {}` linked={}\",\n-              info.id, info.name, info.ident, info.should_link);\n+        info!(\"read extension crate {} `extern crate {} as {}` dep_kind={:?}\",\n+              info.id, info.name, info.ident, info.dep_kind);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n@@ -508,9 +501,8 @@ impl<'a> CrateLoader<'a> {\n \n         let (dylib, metadata) = match library {\n             LoadResult::Previous(cnum) => {\n-                let dylib = self.cstore.opt_used_crate_source(cnum).unwrap().dylib;\n                 let data = self.cstore.get_crate_data(cnum);\n-                (dylib, PMDSource::Registered(data))\n+                (data.source.dylib.clone(), PMDSource::Registered(data))\n             }\n             LoadResult::Loaded(library) => {\n                 let dylib = library.dylib.clone();\n@@ -526,91 +518,49 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn read_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate) -> LoadedMacros {\n-        let root = ekrate.metadata.get_root();\n-        let source_name = format!(\"<{} macros>\", item.ident);\n-        let mut macro_rules = Vec::new();\n-\n-        for def in root.macro_defs.decode(&*ekrate.metadata) {\n-            // NB: Don't use parse::parse_tts_from_source_str because it parses with\n-            // quote_depth > 0.\n-            let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                          source_name.clone(),\n-                                                          def.body);\n-            let lo = p.span.lo;\n-            let body = match p.parse_all_token_trees() {\n-                Ok(body) => body,\n-                Err(mut err) => {\n-                    err.emit();\n-                    self.sess.abort_if_errors();\n-                    unreachable!();\n-                }\n-            };\n-            let local_span = mk_sp(lo, p.prev_span.hi);\n-\n-            // Mark the attrs as used\n-            for attr in &def.attrs {\n-                attr::mark_used(attr);\n-            }\n-\n-            macro_rules.push(ast::MacroDef {\n-                ident: ast::Ident::with_empty_ctxt(def.name),\n-                id: ast::DUMMY_NODE_ID,\n-                span: local_span,\n-                imported_from: Some(item.ident),\n-                allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n-                attrs: def.attrs,\n-                body: body,\n-            });\n-            self.sess.imported_macro_spans.borrow_mut()\n-                .insert(local_span, (def.name.as_str().to_string(), def.span));\n-        }\n-\n-        if let Some(id) = root.macro_derive_registrar {\n-            let dylib = match ekrate.dylib.clone() {\n-                Some(dylib) => dylib,\n-                None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n-            };\n-            if ekrate.target_only {\n-                let message = format!(\"proc-macro crate is not available for \\\n-                                       triple `{}` (only found {})\",\n-                                      config::host_triple(),\n-                                      self.sess.opts.target_triple);\n-                self.sess.span_fatal(item.span, &message);\n-            }\n-\n-            // custom derive crates currently should not have any macro_rules!\n-            // exported macros, enforced elsewhere\n-            assert_eq!(macro_rules.len(), 0);\n-            LoadedMacros::ProcMacros(self.load_derive_macros(item, id, root.hash, dylib))\n-        } else {\n-            LoadedMacros::MacroRules(macro_rules)\n-        }\n-    }\n-\n     /// Load custom derive macros.\n     ///\n     /// Note that this is intentionally similar to how we load plugins today,\n     /// but also intentionally separate. Plugins are likely always going to be\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, item: &ast::Item, index: DefIndex, svh: Svh, path: PathBuf)\n-                          -> Vec<(ast::Name, SyntaxExtension)> {\n+    fn load_derive_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate)\n+                          -> Option<Vec<(ast::Name, SyntaxExtension)>> {\n         use std::{env, mem};\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n \n+        let root = ekrate.metadata.get_root();\n+        let index = match root.macro_derive_registrar {\n+            Some(index) => index,\n+            None => return None,\n+        };\n+        if !self.sess.features.borrow().proc_macro {\n+            let issue = feature_gate::GateIssue::Language;\n+            let msg = \"loading custom derive macro crates is experimentally supported\";\n+            emit_feature_err(&self.sess.parse_sess, \"proc_macro\", item.span, issue, msg);\n+        }\n+\n+        if ekrate.target_only {\n+            let msg = format!(\"proc-macro crate is not available for triple `{}` (only found {})\",\n+                               config::host_triple(), self.sess.opts.target_triple);\n+            self.sess.span_fatal(item.span, &msg);\n+        }\n+        let path = match ekrate.dylib.clone() {\n+            Some(dylib) => dylib,\n+            None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n+        };\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n             Err(err) => self.sess.span_fatal(item.span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&svh, index);\n+        let sym = self.sess.generate_derive_registrar_symbol(&root.hash, index);\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n@@ -640,7 +590,7 @@ impl<'a> CrateLoader<'a> {\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n         mem::forget(lib);\n-        my_registrar.0\n+        Some(my_registrar.0)\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate\n@@ -651,7 +601,7 @@ impl<'a> CrateLoader<'a> {\n              name: name.to_string(),\n              ident: name.to_string(),\n              id: ast::DUMMY_NODE_ID,\n-             should_link: false,\n+             dep_kind: DepKind::MacrosOnly,\n         });\n \n         if ekrate.target_only {\n@@ -725,7 +675,7 @@ impl<'a> CrateLoader<'a> {\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n                                           &|data| data.needs_panic_runtime());\n-                runtime_found = runtime_found || data.explicitly_linked.get();\n+                runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n \n@@ -754,9 +704,9 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n-                                                 syntax_pos::DUMMY_SP,\n-                                                 PathKind::Crate, false);\n+        let dep_kind = DepKind::Implicit;\n+        let (cnum, data) =\n+            self.resolve_crate(&None, name, name, None, DUMMY_SP, PathKind::Crate, dep_kind);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -790,7 +740,7 @@ impl<'a> CrateLoader<'a> {\n                 self.inject_dependency_if(cnum, \"an allocator\",\n                                           &|data| data.needs_allocator());\n                 found_required_allocator = found_required_allocator ||\n-                    data.explicitly_linked.get();\n+                    data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n         if !needs_allocator || found_required_allocator { return }\n@@ -836,9 +786,9 @@ impl<'a> CrateLoader<'a> {\n         } else {\n             &self.sess.target.target.options.exe_allocation_crate\n         };\n-        let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n-                                                 syntax_pos::DUMMY_SP,\n-                                                 PathKind::Crate, false);\n+        let dep_kind = DepKind::Implicit;\n+        let (cnum, data) =\n+            self.resolve_crate(&None, name, name, None, DUMMY_SP, PathKind::Crate, dep_kind);\n \n         // Sanity check the crate we loaded to ensure that it is indeed an\n         // allocator.\n@@ -979,45 +929,36 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     }\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions, load_macros: bool)\n-                    -> Option<LoadedMacros> {\n+                    -> Vec<(ast::Name, SyntaxExtension)> {\n         match item.node {\n             ast::ItemKind::ExternCrate(_) => {}\n             ast::ItemKind::ForeignMod(ref fm) => {\n                 self.process_foreign_mod(item, fm);\n-                return None;\n+                return Vec::new();\n             }\n-            _ => return None,\n+            _ => return Vec::new(),\n         }\n \n         let info = self.extract_crate_info(item).unwrap();\n-        let loaded_macros = if load_macros {\n+        if load_macros {\n             let ekrate = self.read_extension_crate(item.span, &info);\n-            let loaded_macros = self.read_macros(item, &ekrate);\n \n-            // If this is a proc-macro crate or `#[no_link]` crate, it is only used at compile time,\n-            // so we return here to avoid registering the crate.\n-            if loaded_macros.is_proc_macros() || !info.should_link {\n-                return Some(loaded_macros);\n+            // If this is a proc-macro crate, return here to avoid registering.\n+            if let Some(custom_derives) = self.load_derive_macros(item, &ekrate) {\n+                return custom_derives;\n             }\n \n             // Register crate now to avoid double-reading metadata\n             if let PMDSource::Owned(lib) = ekrate.metadata {\n                 if ekrate.target_only || config::host_triple() == self.sess.opts.target_triple {\n-                    let ExternCrateInfo { ref ident, ref name, .. } = info;\n-                    self.register_crate(&None, ident, name, item.span, lib, true);\n+                    let ExternCrateInfo { ref ident, ref name, dep_kind, .. } = info;\n+                    self.register_crate(&None, ident, name, item.span, lib, dep_kind);\n                 }\n             }\n-\n-            Some(loaded_macros)\n-        } else {\n-            if !info.should_link {\n-                return None;\n-            }\n-            None\n-        };\n+        }\n \n         let (cnum, ..) = self.resolve_crate(\n-            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n+            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n \n         let def_id = definitions.opt_local_def_id(item.id).unwrap();\n@@ -1028,6 +969,6 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n \n-        loaded_macros\n+        Vec::new()\n     }\n }"}, {"sha": "10e86c427a832d7aecc6cf0b7dea664f7ac582a3", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -18,7 +18,7 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::ExternCrate;\n+use rustc::middle::cstore::{DepKind, ExternCrate};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n@@ -78,11 +78,8 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub key_map: FxHashMap<DefKey, DefIndex>,\n \n-    /// Flag if this crate is required by an rlib version of this crate, or in\n-    /// other words whether it was explicitly linked to. An example of a crate\n-    /// where this is false is when an allocator crate is injected into the\n-    /// dependency list, and therefore isn't actually needed to link an rlib.\n-    pub explicitly_linked: Cell<bool>,\n+    pub dep_kind: Cell<DepKind>,\n+    pub source: CrateSource,\n }\n \n pub struct CachedInlinedItem {\n@@ -97,7 +94,6 @@ pub struct CStore {\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n-    used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n@@ -112,7 +108,6 @@ impl CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n             extern_mod_crate_map: RefCell::new(FxHashMap()),\n-            used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n@@ -146,38 +141,9 @@ impl CStore {\n         }\n     }\n \n-    /// Like `iter_crate_data`, but passes source paths (if available) as well.\n-    pub fn iter_crate_data_origins<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>)\n-    {\n-        for (&k, v) in self.metas.borrow().iter() {\n-            let origin = self.opt_used_crate_source(k);\n-            origin.as_ref().map(|cs| {\n-                assert!(k == cs.cnum);\n-            });\n-            i(k, &v, origin);\n-        }\n-    }\n-\n-    pub fn add_used_crate_source(&self, src: CrateSource) {\n-        let mut used_crate_sources = self.used_crate_sources.borrow_mut();\n-        if !used_crate_sources.contains(&src) {\n-            used_crate_sources.push(src);\n-        }\n-    }\n-\n-    pub fn opt_used_crate_source(&self, cnum: CrateNum) -> Option<CrateSource> {\n-        self.used_crate_sources\n-            .borrow_mut()\n-            .iter()\n-            .find(|source| source.cnum == cnum)\n-            .cloned()\n-    }\n-\n     pub fn reset(&self) {\n         self.metas.borrow_mut().clear();\n         self.extern_mod_crate_map.borrow_mut().clear();\n-        self.used_crate_sources.borrow_mut().clear();\n         self.used_libraries.borrow_mut().clear();\n         self.used_link_args.borrow_mut().clear();\n         self.statically_included_foreign_items.borrow_mut().clear();\n@@ -223,15 +189,16 @@ impl CStore {\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n-        let mut libs = self.used_crate_sources\n+        let mut libs = self.metas\n             .borrow()\n             .iter()\n-            .map(|src| {\n-                (src.cnum,\n-                 match prefer {\n-                     LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n-                     LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n-                 })\n+            .filter_map(|(&cnum, data)| {\n+                if data.dep_kind.get() == DepKind::MacrosOnly { return None; }\n+                let path = match prefer {\n+                    LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n+                    LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n+                };\n+                Some((cnum, path))\n             })\n             .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {"}, {"sha": "3113bfcb5b45218a7dabda02ffbc1fbedb9b5976", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -13,10 +13,11 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, ExternCrate};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n+use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n@@ -30,7 +31,8 @@ use rustc_back::PanicStrategy;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::token;\n+use syntax::parse::{token, new_parser_from_source_str};\n+use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -221,6 +223,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).get_dylib_dependency_formats()\n     }\n \n+    fn dep_kind(&self, cnum: CrateNum) -> DepKind\n+    {\n+        self.get_crate_data(cnum).dep_kind.get()\n+    }\n+\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n         self.get_crate_data(cnum).get_lang_items()\n@@ -237,11 +244,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_staged_api()\n     }\n \n-    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool\n-    {\n-        self.get_crate_data(cnum).explicitly_linked.get()\n-    }\n-\n     fn is_allocator(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).is_allocator()\n@@ -351,6 +353,43 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n+    fn load_macro(&self, id: DefId, sess: &Session) -> ast::MacroDef {\n+        let (name, def) = self.get_crate_data(id.krate).get_macro(id.index);\n+        let source_name = format!(\"<{} macros>\", name);\n+\n+        // NB: Don't use parse_tts_from_source_str because it parses with quote_depth > 0.\n+        let mut parser = new_parser_from_source_str(&sess.parse_sess, source_name, def.body);\n+\n+        let lo = parser.span.lo;\n+        let body = match parser.parse_all_token_trees() {\n+            Ok(body) => body,\n+            Err(mut err) => {\n+                err.emit();\n+                sess.abort_if_errors();\n+                unreachable!();\n+            }\n+        };\n+        let local_span = mk_sp(lo, parser.prev_span.hi);\n+\n+        // Mark the attrs as used\n+        for attr in &def.attrs {\n+            attr::mark_used(attr);\n+        }\n+\n+        sess.imported_macro_spans.borrow_mut()\n+            .insert(local_span, (def.name.as_str().to_string(), def.span));\n+\n+        ast::MacroDef {\n+            ident: ast::Ident::with_empty_ctxt(def.name),\n+            id: ast::DUMMY_NODE_ID,\n+            span: local_span,\n+            imported_from: None, // FIXME\n+            allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n+            attrs: def.attrs,\n+            body: body,\n+        }\n+    }\n+\n     fn maybe_get_item_ast<'a>(&'tcx self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n@@ -507,7 +546,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n     {\n-        self.opt_used_crate_source(cnum).unwrap()\n+        self.get_crate_data(cnum).source.clone()\n     }\n \n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>"}, {"sha": "64a90d56d5561e86456ddbe95ac6064bd3ebc720", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -21,7 +21,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::middle::cstore::{DepKind, InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc::middle::lang_items;\n@@ -468,6 +468,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n             EntryKind::Enum => Def::Enum(did),\n+            EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n             EntryKind::Impl(_) |\n@@ -690,6 +691,8 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F)\n         where F: FnMut(def::Export)\n     {\n+        let macros_only = self.dep_kind.get() == DepKind::MacrosOnly;\n+\n         // Find the item.\n         let item = match self.maybe_entry(id) {\n             None => return,\n@@ -698,9 +701,19 @@ impl<'a, 'tcx> CrateMetadata {\n \n         // Iterate over all children.\n         for child_index in item.children.decode(self) {\n+            if macros_only {\n+                continue\n+            }\n+\n             // Get the item.\n             if let Some(child) = self.maybe_entry(child_index) {\n                 let child = child.decode(self);\n+                match child.kind {\n+                    EntryKind::MacroDef(..) => {}\n+                    _ if macros_only => continue,\n+                    _ => {}\n+                }\n+\n                 // Hand off the item to the callback.\n                 match child.kind {\n                     // FIXME(eddyb) Don't encode these in children.\n@@ -759,6 +772,11 @@ impl<'a, 'tcx> CrateMetadata {\n \n         if let EntryKind::Mod(data) = item.kind {\n             for exp in data.decode(self).reexports.decode(self) {\n+                match exp.def {\n+                    Def::Macro(..) => {}\n+                    _ if macros_only => continue,\n+                    _ => {}\n+                }\n                 callback(exp);\n             }\n         }\n@@ -987,6 +1005,14 @@ impl<'a, 'tcx> CrateMetadata {\n         self.root.reachable_ids.decode(self).map(|index| self.local_def_id(index)).collect()\n     }\n \n+    pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n+        let entry = self.entry(id);\n+        match entry.kind {\n+            EntryKind::MacroDef(macro_def) => (self.item_name(&entry), macro_def.decode(self)),\n+            _ => bug!(),\n+        }\n+    }\n+\n     pub fn is_const_fn(&self, id: DefIndex) -> bool {\n         let constness = match self.entry(id).kind {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,"}, {"sha": "ac1f2afcb2adbeba5eefcb8476a57011051b98d7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -830,6 +830,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             },\n         }\n     }\n+\n+    /// Serialize the text of exported macros\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n+        let def_id = self.tcx.map.local_def_id(macro_def.id);\n+        let macro_def = MacroDef {\n+            name: macro_def.name,\n+            attrs: macro_def.attrs.to_vec(),\n+            span: macro_def.span,\n+            body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n+        };\n+        Entry {\n+            kind: EntryKind::MacroDef(self.lazy(&macro_def)),\n+            visibility: ty::Visibility::Public,\n+            def_key: self.encode_def_key(def_id),\n+\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+            ty: None,\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n+            ast: None,\n+            mir: None,\n+        }\n+    }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -964,6 +992,10 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_ty(self, ty);\n         self.index.encode_info_for_ty(ty);\n     }\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n+        let def_id = self.index.tcx.map.local_def_id(macro_def.id);\n+        self.index.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+    }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -1043,6 +1075,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_items(&mut visitor);\n+        for macro_def in &krate.exported_macros {\n+            visitor.visit_macro_def(macro_def);\n+        }\n         visitor.index.into_items()\n     }\n \n@@ -1080,7 +1115,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             CrateDep {\n                 name: syntax::parse::token::intern(dep.name()),\n                 hash: dep.hash(),\n-                explicitly_linked: dep.explicitly_linked.get(),\n+                kind: dep.dep_kind.get(),\n             }\n         }))\n     }\n@@ -1122,19 +1157,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|filemap| &**filemap))\n     }\n-\n-    /// Serialize the text of the exported macros\n-    fn encode_macro_defs(&mut self) -> LazySeq<MacroDef> {\n-        let tcx = self.tcx;\n-        self.lazy_seq(tcx.map.krate().exported_macros.iter().map(|def| {\n-            MacroDef {\n-                name: def.name,\n-                attrs: def.attrs.to_vec(),\n-                span: def.span,\n-                body: ::syntax::print::pprust::tts_to_string(&def.body),\n-            }\n-        }))\n-    }\n }\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n@@ -1228,11 +1250,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.encode_codemap();\n         let codemap_bytes = self.position() - i;\n \n-        // Encode macro definitions\n-        i = self.position();\n-        let macro_defs = self.encode_macro_defs();\n-        let macro_defs_bytes = self.position() - i;\n-\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.encode_impls();\n@@ -1279,7 +1296,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing: lang_items_missing,\n             native_libraries: native_libraries,\n             codemap: codemap,\n-            macro_defs: macro_defs,\n             impls: impls,\n             reachable_ids: reachable_ids,\n             index: index,\n@@ -1300,7 +1316,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"       lang item bytes: {}\", lang_item_bytes);\n             println!(\"          native bytes: {}\", native_lib_bytes);\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n-            println!(\"       macro def bytes: {}\", macro_defs_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"       reachable bytes: {}\", reachable_bytes);\n             println!(\"            item bytes: {}\", item_bytes);"}, {"sha": "1a74a925454770928ff937df59978be95e5e5e33", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -195,6 +195,7 @@ read_hir!(hir::Item);\n read_hir!(hir::ImplItem);\n read_hir!(hir::TraitItem);\n read_hir!(hir::ForeignItem);\n+read_hir!(hir::MacroDef);\n \n /// Leaks access to a value of type T without any tracking. This is\n /// suitable for ambiguous types like `usize`, which *could* represent"}, {"sha": "d7a5f7ad71544ed42ebc851cdb9594796fc45dec", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -14,7 +14,7 @@ use index;\n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n-use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n+use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibraryKind};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n@@ -177,7 +177,6 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n-    pub macro_defs: LazySeq<MacroDef>,\n     pub impls: LazySeq<TraitImpls>,\n     pub reachable_ids: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n@@ -187,7 +186,7 @@ pub struct CrateRoot {\n pub struct CrateDep {\n     pub name: ast::Name,\n     pub hash: hir::svh::Svh,\n-    pub explicitly_linked: bool,\n+    pub kind: DepKind,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -241,6 +240,7 @@ pub enum EntryKind<'tcx> {\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n+    MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),"}, {"sha": "0833f85c1f6a201cb0f904123b5b00eb6634a95d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 115, "deletions": 115, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -14,18 +14,17 @@\n //! any imports resolved.\n \n use macros::{InvocationData, LegacyScope};\n+use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n-use {Module, ModuleS, ModuleKind};\n-use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind, ToNameBinding};\n-use Resolver;\n+use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use Namespace::{self, TypeNS, ValueNS, MacroNS};\n+use ResolveResult::Success;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacros;\n+use rustc::middle::cstore::DepKind;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, BUILTIN_MACROS_CRATE};\n use rustc::ty;\n-use rustc::util::nodemap::FxHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -37,10 +36,9 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n-use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n@@ -221,47 +219,53 @@ impl<'b> Resolver<'b> {\n                     legacy_imports.import_all.is_some() || !legacy_imports.imports.is_empty() ||\n                     !legacy_imports.reexports.is_empty()\n                 } {\n-                    if self.current_module.parent.is_some() {\n-                        span_err!(self.session, item.span, E0468,\n-                                  \"an `extern crate` loading macros must be at the crate root\");\n-                    }\n+                    span_err!(self.session, item.span, E0468,\n+                              \"an `extern crate` loading macros must be at the crate root\");\n                 }\n \n-                let loaded_macros = if legacy_imports != LegacyMacroImports::default() {\n-                    self.crate_loader.process_item(item, &self.definitions, true)\n-                } else {\n-                    self.crate_loader.process_item(item, &self.definitions, false)\n-                };\n+                let load_macros = legacy_imports != LegacyMacroImports::default();\n+                let proc_macros =\n+                    self.crate_loader.process_item(item, &self.definitions, load_macros);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id);\n                 let module = if let Some(crate_id) = crate_id {\n-                    let def_id = DefId {\n-                        krate: crate_id,\n-                        index: CRATE_DEF_INDEX,\n-                    };\n-                    let module = self.arenas.alloc_module(ModuleS {\n-                        extern_crate_id: Some(item.id),\n-                        populated: Cell::new(false),\n-                        ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n+                    let module = self.get_extern_crate_root(crate_id);\n+                    let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n+                    let binding = self.arenas.alloc_name_binding(binding);\n+                    let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                        id: item.id,\n+                        parent: parent,\n+                        imported_module: Cell::new(Some(module)),\n+                        subclass: ImportDirectiveSubclass::ExternCrate,\n+                        span: item.span,\n+                        module_path: Vec::new(),\n+                        vis: Cell::new(vis),\n                     });\n-                    self.define(parent, name, TypeNS, (module, sp, vis));\n+                    let imported_binding = self.import(binding, directive);\n+                    self.define(parent, name, TypeNS, imported_binding);\n                     self.populate_module_if_necessary(module);\n                     module\n                 } else {\n-                    // Define an empty module\n-                    let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                    let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n-                    let module = self.arenas.alloc_module(module);\n+                    // Define a module and populate it with proc macros.\n+                    let module_kind =\n+                        ModuleKind::Def(Def::Mod(self.definitions.local_def_id(item.id)), name);\n+                    let module = self.arenas.alloc_module(ModuleS::new(None, module_kind));\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n+                    for (name, ext) in proc_macros {\n+                        let def_id = DefId {\n+                            krate: BUILTIN_MACROS_CRATE,\n+                            index: DefIndex::new(self.macro_map.len()),\n+                        };\n+                        self.macro_map.insert(def_id, Rc::new(ext));\n+                        let vis = ty::Visibility::Public;\n+                        self.define(module, name, MacroNS, (Def::Macro(def_id), DUMMY_SP, vis));\n+                    }\n                     module\n                 };\n \n-                if let Some(loaded_macros) = loaded_macros {\n-                    self.import_extern_crate_macros(\n-                        item, module, loaded_macros, legacy_imports, expansion == Mark::root(),\n-                    );\n-                }\n+                let allow_shadowing = expansion == Mark::root();\n+                self.process_legacy_macro_imports(module, legacy_imports, allow_shadowing);\n             }\n \n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n@@ -484,6 +488,9 @@ impl<'b> Resolver<'b> {\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n+            Def::Macro(..) => {\n+                self.define(parent, name, MacroNS, (def, DUMMY_SP, vis));\n+            }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n             Def::TyParam(..) |\n@@ -496,6 +503,43 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n+    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'b> {\n+        let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        let macros_only = self.session.cstore.dep_kind(cnum) == DepKind::MacrosOnly;\n+        let arenas = self.arenas;\n+        *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n+            arenas.alloc_module(ModuleS {\n+                populated: Cell::new(false),\n+                ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n+            })\n+        })\n+    }\n+\n+    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n+        let def_id = match def {\n+            Def::Macro(def_id) => def_id,\n+            _ => panic!(\"Expected Def::Macro(..)\"),\n+        };\n+        if let Some(ext) = self.macro_map.get(&def_id) {\n+            return ext.clone();\n+        }\n+\n+        let mut macro_rules = self.session.cstore.load_macro(def_id, &self.session);\n+        let mark = Mark::fresh();\n+        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n+            def_index: CRATE_DEF_INDEX,\n+            const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        });\n+        self.invocations.insert(mark, invocation);\n+        macro_rules.body = mark_tts(&macro_rules.body, mark);\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_rules));\n+        self.macro_map.insert(def_id, ext.clone());\n+        ext\n+    }\n+\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n@@ -506,90 +550,46 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n-    fn import_extern_crate_macros(&mut self,\n-                                  extern_crate: &Item,\n-                                  module: Module<'b>,\n-                                  loaded_macros: LoadedMacros,\n-                                  legacy_imports: LegacyMacroImports,\n-                                  allow_shadowing: bool) {\n-        let import_macro = |this: &mut Self, name, ext: Rc<_>, span| {\n-            this.used_crates.insert(module.def_id().unwrap().krate);\n-            if let SyntaxExtension::NormalTT(..) = *ext {\n-                this.macro_names.insert(name);\n-            }\n-            if this.builtin_macros.insert(name, ext).is_some() && !allow_shadowing {\n-                let msg = format!(\"`{}` is already in scope\", name);\n-                let note =\n-                    \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-                this.session.struct_span_err(span, &msg).note(note).emit();\n-            }\n-        };\n-\n-        match loaded_macros {\n-            LoadedMacros::MacroRules(macros) => {\n-                let mark = Mark::fresh();\n-                if !macros.is_empty() {\n-                    let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-                        module: Cell::new(module),\n-                        def_index: CRATE_DEF_INDEX,\n-                        const_integer: false,\n-                        legacy_scope: Cell::new(LegacyScope::Empty),\n-                        expansion: Cell::new(LegacyScope::Empty),\n-                    });\n-                    self.invocations.insert(mark, invocation);\n-                }\n-\n-                let mut macros: FxHashMap<_, _> = macros.into_iter().map(|mut def| {\n-                    def.body = mark_tts(&def.body, mark);\n-                    let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                    (def.ident.name, (def, Rc::new(ext)))\n-                }).collect();\n+    fn legacy_import_macro(&mut self, name: Name, def: Def, span: Span, allow_shadowing: bool) {\n+        self.used_crates.insert(def.def_id().krate);\n+        self.macro_names.insert(name);\n+        if self.builtin_macros.insert(name, def.def_id()).is_some() && !allow_shadowing {\n+            let msg = format!(\"`{}` is already in scope\", name);\n+            let note =\n+                \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n+            self.session.struct_span_err(span, &msg).note(note).emit();\n+        }\n+    }\n \n-                if let Some(span) = legacy_imports.import_all {\n-                    for (&name, &(_, ref ext)) in macros.iter() {\n-                        import_macro(self, name, ext.clone(), span);\n-                    }\n+    fn process_legacy_macro_imports(&mut self,\n+                                    module: Module<'b>,\n+                                    legacy_imports: LegacyMacroImports,\n+                                    allow_shadowing: bool) {\n+        if let Some(span) = legacy_imports.import_all {\n+            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+            });\n+        } else {\n+            for (name, span) in legacy_imports.imports {\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                if let Success(binding) = result {\n+                    self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n                 } else {\n-                    for (name, span) in legacy_imports.imports {\n-                        if let Some(&(_, ref ext)) = macros.get(&name) {\n-                            import_macro(self, name, ext.clone(), span);\n-                        } else {\n-                            span_err!(self.session, span, E0469, \"imported macro not found\");\n-                        }\n-                    }\n-                }\n-                for (name, span) in legacy_imports.reexports {\n-                    if let Some((mut def, _)) = macros.remove(&name) {\n-                        def.id = self.next_node_id();\n-                        self.exported_macros.push(def);\n-                    } else {\n-                        span_err!(self.session, span, E0470, \"reexported macro not found\");\n-                    }\n+                    span_err!(self.session, span, E0469, \"imported macro not found\");\n                 }\n             }\n-\n-            LoadedMacros::ProcMacros(macros) => {\n-                if !self.session.features.borrow().proc_macro {\n-                    let sess = &self.session.parse_sess;\n-                    let issue = feature_gate::GateIssue::Language;\n-                    let msg =\n-                        \"loading custom derive macro crates is experimentally supported\";\n-                    emit_feature_err(sess, \"proc_macro\", extern_crate.span, issue, msg);\n-                }\n-                if !legacy_imports.imports.is_empty() {\n-                    let msg = \"`proc-macro` crates cannot be selectively imported from, \\\n-                               must use `#[macro_use]`\";\n-                    self.session.span_err(extern_crate.span, msg);\n-                }\n-                if !legacy_imports.reexports.is_empty() {\n-                    let msg = \"`proc-macro` crates cannot be reexported from\";\n-                    self.session.span_err(extern_crate.span, msg);\n-                }\n-                if let Some(span) = legacy_imports.import_all {\n-                    for (name, ext) in macros {\n-                        import_macro(self, name, Rc::new(ext), span);\n-                    }\n+        }\n+        for (name, span) in legacy_imports.reexports {\n+            self.used_crates.insert(module.def_id().unwrap().krate);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            if let Success(binding) = result {\n+                let def = binding.def();\n+                if let Def::Macro(DefId { krate: BUILTIN_MACROS_CRATE, .. }) = def {\n+                    self.session.span_err(span, \"`proc-macro` crates cannot be reexported from\");\n                 }\n+                self.macro_exports.push(Export { name: name, def: def });\n+            } else {\n+                span_err!(self.session, span, E0470, \"reexported macro not found\");\n             }\n         }\n     }"}, {"sha": "fe90cd34687c017aa3b5bba18e550d4a7a96f807", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -76,7 +76,7 @@ use std::fmt;\n use std::mem::replace;\n use std::rc::Rc;\n \n-use resolve_imports::{ImportDirective, NameResolution};\n+use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution};\n use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -533,6 +533,7 @@ impl PatternSource {\n pub enum Namespace {\n     TypeNS,\n     ValueNS,\n+    MacroNS,\n }\n \n impl<'a> Visitor for Resolver<'a> {\n@@ -796,10 +797,6 @@ pub struct ModuleS<'a> {\n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n \n-    // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n-    // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n-    extern_crate_id: Option<NodeId>,\n-\n     resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: bool,\n@@ -824,7 +821,6 @@ impl<'a> ModuleS<'a> {\n             parent: parent,\n             kind: kind,\n             normal_ancestor_id: None,\n-            extern_crate_id: None,\n             resolutions: RefCell::new(FxHashMap()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -953,7 +949,14 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_extern_crate(&self) -> bool {\n-        self.module().ok().and_then(|module| module.extern_crate_id).is_some()\n+        match self.kind {\n+            NameBindingKind::Import {\n+                directive: &ImportDirective {\n+                    subclass: ImportDirectiveSubclass::ExternCrate, ..\n+                }, ..\n+            } => true,\n+            _ => false,\n+        }\n     }\n \n     fn is_import(&self) -> bool {\n@@ -1081,6 +1084,7 @@ pub struct Resolver<'a> {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n     module_map: NodeMap<Module<'a>>,\n+    extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n \n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,\n@@ -1107,8 +1111,10 @@ pub struct Resolver<'a> {\n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n-    builtin_macros: FxHashMap<Name, Rc<SyntaxExtension>>,\n+    builtin_macros: FxHashMap<Name, DefId>,\n     lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n+    macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n+    macro_exports: Vec<Export>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1274,6 +1280,7 @@ impl<'a> Resolver<'a> {\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             module_map: module_map,\n+            extern_crate_roots: FxHashMap(),\n \n             emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n@@ -1300,6 +1307,8 @@ impl<'a> Resolver<'a> {\n             macro_names: FxHashSet(),\n             builtin_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n+            macro_map: FxHashMap(),\n+            macro_exports: Vec::new(),\n             invocations: invocations,\n         }\n     }\n@@ -1318,13 +1327,6 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        // Collect `DefId`s for exported macro defs.\n-        for def in &krate.exported_macros {\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(def)\n-            })\n-        }\n-\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n \n@@ -1342,7 +1344,11 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n-        match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n+        match ns {\n+            ValueNS => &mut self.value_ribs,\n+            TypeNS => &mut self.type_ribs,\n+            MacroNS => panic!(\"The macro namespace has no ribs\"),\n+        }\n     }\n \n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -3233,7 +3239,7 @@ impl<'a> Resolver<'a> {\n             in_module.for_each_child(|name, ns, name_binding| {\n \n                 // avoid imports entirely\n-                if name_binding.is_import() { return; }\n+                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n \n                 // collect results based on the filter function\n                 if name == lookup_name && ns == namespace {\n@@ -3269,21 +3275,11 @@ impl<'a> Resolver<'a> {\n                 // collect submodules to explore\n                 if let Ok(module) = name_binding.module() {\n                     // form the path\n-                    let path_segments = match module.kind {\n-                        _ if module.parent.is_none() => path_segments.clone(),\n-                        ModuleKind::Def(_, name) => {\n-                            let mut paths = path_segments.clone();\n-                            let ident = Ident::with_empty_ctxt(name);\n-                            let params = PathParameters::none();\n-                            let segm = PathSegment {\n-                                identifier: ident,\n-                                parameters: params,\n-                            };\n-                            paths.push(segm);\n-                            paths\n-                        }\n-                        _ => bug!(),\n-                    };\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(PathSegment {\n+                        identifier: Ident::with_empty_ctxt(name),\n+                        parameters: PathParameters::none(),\n+                    });\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3369,7 +3365,10 @@ impl<'a> Resolver<'a> {\n             if !reported_spans.insert(span) { continue }\n             if binding.is_extern_crate() {\n                 // Warn when using an inaccessible extern crate.\n-                let node_id = binding.module().unwrap().extern_crate_id.unwrap();\n+                let node_id = match binding.kind {\n+                    NameBindingKind::Import { directive, .. } => directive.id,\n+                    _ => unreachable!(),\n+                };\n                 let msg = format!(\"extern crate `{}` is private\", name);\n                 self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n             } else {\n@@ -3415,7 +3414,7 @@ impl<'a> Resolver<'a> {\n             _ => \"enum\",\n         };\n \n-        let (participle, noun) = match old_binding.is_import() || old_binding.is_extern_crate() {\n+        let (participle, noun) = match old_binding.is_import() {\n             true => (\"imported\", \"import\"),\n             false => (\"defined\", \"definition\"),\n         };\n@@ -3424,7 +3423,8 @@ impl<'a> Resolver<'a> {\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n-                (TypeNS, Ok(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n+                (MacroNS, _) => \"a macro\",\n+                (TypeNS, _) if old_binding.is_extern_crate() => \"an extern crate\",\n                 (TypeNS, Ok(module)) if module.is_normal() => \"a module\",\n                 (TypeNS, Ok(module)) if module.is_trait() => \"a trait\",\n                 (TypeNS, _) => \"a type\",\n@@ -3439,7 +3439,7 @@ impl<'a> Resolver<'a> {\n                 e.span_label(span, &format!(\"`{}` was already imported\", name));\n                 e\n             },\n-            (true, _) | (_, true) if binding.is_import() || old_binding.is_import() => {\n+            (true, _) | (_, true) if binding.is_import() && old_binding.is_import() => {\n                 let mut e = struct_span_err!(self.session, span, E0254, \"{}\", msg);\n                 e.span_label(span, &\"already imported\");\n                 e"}, {"sha": "f9d91e3aa63fdb0faf3f18395e9dd46b2f317265", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -10,7 +10,8 @@\n \n use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n use std::cell::Cell;\n use std::rc::Rc;\n@@ -23,6 +24,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::Visitor;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n@@ -128,6 +130,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         if export {\n             def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n             self.exported_macros.push(def);\n         }\n     }\n@@ -136,7 +145,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.builtin_macros.insert(ident.name, ext);\n+        let def_id = DefId {\n+            krate: BUILTIN_MACROS_CRATE,\n+            index: DefIndex::new(self.macro_map.len()),\n+        };\n+        self.macro_map.insert(def_id, ext);\n+        self.builtin_macros.insert(ident.name, def_id);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -147,7 +161,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n             match self.builtin_macros.get(&name) {\n-                Some(ext) => match **ext {\n+                Some(&def_id) => match *self.get_macro(Def::Macro(def_id)) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -226,7 +240,7 @@ impl<'a> Resolver<'a> {\n         if let Some(scope) = possible_time_travel {\n             self.lexical_macro_resolutions.push((name, scope));\n         }\n-        self.builtin_macros.get(&name).cloned()\n+        self.builtin_macros.get(&name).cloned().map(|def_id| self.get_macro(Def::Macro(def_id)))\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {"}, {"sha": "5d66caec31b3ed9958883f7ce3bf67eaaf741295", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -30,6 +30,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n+use std::mem;\n \n impl<'a> Resolver<'a> {\n     pub fn resolve_imports(&mut self) {\n@@ -51,6 +52,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         max_vis: Cell<ty::Visibility>, // The visibility of the greatest reexport.\n         // n.b. `max_vis` is only used in `finalize_import` to check for reexport errors.\n     },\n+    ExternCrate,\n }\n \n impl<'a> ImportDirectiveSubclass<'a> {\n@@ -68,12 +70,12 @@ impl<'a> ImportDirectiveSubclass<'a> {\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n-    parent: Module<'a>,\n-    module_path: Vec<Ident>,\n-    imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n-    subclass: ImportDirectiveSubclass<'a>,\n-    span: Span,\n-    vis: Cell<ty::Visibility>,\n+    pub parent: Module<'a>,\n+    pub module_path: Vec<Ident>,\n+    pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    pub subclass: ImportDirectiveSubclass<'a>,\n+    pub span: Span,\n+    pub vis: Cell<ty::Visibility>,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -169,7 +171,8 @@ impl<'a> Resolver<'a> {\n         let new_import_semantics = self.new_import_semantics;\n         let is_disallowed_private_import = |binding: &NameBinding| {\n             !new_import_semantics && !allow_private_imports && // disallowed\n-            binding.vis != ty::Visibility::Public && binding.is_import() // non-`pub` import\n+            binding.vis != ty::Visibility::Public && binding.is_import() && // non-`pub` import\n+            !binding.is_extern_crate() // not an `extern crate`\n         };\n \n         if let Some(span) = record_used {\n@@ -237,7 +240,7 @@ impl<'a> Resolver<'a> {\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n-                    GlobImport { .. } => unreachable!(),\n+                    _ => unreachable!(),\n                 };\n                 match self.resolve_name_in_module(module, name, ns, true, None) {\n                     Failed(_) => {}\n@@ -280,13 +283,14 @@ impl<'a> Resolver<'a> {\n             // which are not relevant to import resolution.\n             GlobImport { is_prelude: true, .. } => {}\n             GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n+            _ => unreachable!(),\n         }\n     }\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-              -> NameBinding<'a> {\n+    pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+                  -> NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n             directive.vis.get()\n@@ -529,6 +533,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 self.resolve_glob_import(directive);\n                 return Success(());\n             }\n+            _ => unreachable!(),\n         };\n \n         let mut indeterminate = false;\n@@ -616,6 +621,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 return Success(());\n             }\n+            _ => unreachable!(),\n         };\n \n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n@@ -767,6 +773,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         *module.globs.borrow_mut() = Vec::new();\n \n         let mut reexports = Vec::new();\n+        if module as *const _ == self.graph_root as *const _ {\n+            reexports = mem::replace(&mut self.macro_exports, Vec::new());\n+        }\n+\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n             let binding = match resolution.binding {\n@@ -831,5 +841,6 @@ fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> St\n     match *subclass {\n         SingleImport { source, .. } => source.to_string(),\n         GlobImport { .. } => \"*\".to_string(),\n+        ExternCrate => \"<extern crate>\".to_string(),\n     }\n }"}, {"sha": "e83c2359979c057466fec319fcdd533094343eb3", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -341,6 +341,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::AssociatedTy(..) |\n             Def::AssociatedConst(..) |\n             Def::PrimTy(_) |\n+            Def::Macro(_) |\n             Def::Err => {\n                span_bug!(span,\n                          \"process_def_kind for unexpected item: {:?}\","}, {"sha": "ab5bbea07a301582999a7fc9847f34781c6e77b6", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -565,6 +565,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n             Def::Label(..) |\n+            Def::Macro(..) |\n             Def::Err => None,\n         }\n     }"}, {"sha": "a25cb0bacc5cf785610a2bc634d8535868b80882", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -14,7 +14,7 @@ use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, ExportMap};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n@@ -74,6 +74,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n+    pub export_map: ExportMap,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -196,7 +197,7 @@ pub fn run_core(search_paths: SearchPaths,\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let ty::CrateAnalysis { access_levels, .. } = analysis;\n+        let ty::CrateAnalysis { access_levels, export_map, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access\n         // to the map from defid -> nodeid\n@@ -218,6 +219,7 @@ pub fn run_core(search_paths: SearchPaths,\n             renderinfo: Default::default(),\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n+            export_map: export_map,\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());\n "}, {"sha": "12d33dcb207f7c78ab170e5cbb69439a8b27b098", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -87,7 +87,7 @@ pub fn run(input: &str,\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n \n     let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n-    let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n+    let driver::ExpansionResult { defs, mut hir_forest, analysis, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n         ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n@@ -110,6 +110,7 @@ pub fn run(input: &str,\n         renderinfo: Default::default(),\n         ty_substs: Default::default(),\n         lt_substs: Default::default(),\n+        export_map: analysis.export_map,\n     };\n \n     let mut v = RustdocVisitor::new(&ctx);"}, {"sha": "b91d71198e8197e84e4e02a556091055ce192059", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -85,8 +85,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                               &krate.module,\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n-        self.module.macros = krate.exported_macros.iter()\n-            .map(|def| self.visit_macro(def)).collect();\n+        let macro_exports: Vec<_> =\n+            krate.exported_macros.iter().map(|def| self.visit_macro(def)).collect();\n+        self.module.macros.extend(macro_exports);\n         self.module.is_crate = true;\n     }\n \n@@ -191,6 +192,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             let item = self.cx.map.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n+        if let Some(exports) = self.cx.export_map.get(&id) {\n+            for export in exports {\n+                if let Def::Macro(def_id) = export.def {\n+                    if def_id.krate == LOCAL_CRATE {\n+                        continue // These are `krate.exported_macros`, handled in `self.visit()`.\n+                    }\n+                    let def = self.cx.sess().cstore.load_macro(def_id, self.cx.sess());\n+                    // FIXME(jseyfried) merge with `self.visit_macro()`\n+                    let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n+                    om.macros.push(Macro {\n+                        id: def.id,\n+                        attrs: def.attrs.clone().into(),\n+                        name: def.ident.name,\n+                        whence: def.span,\n+                        matchers: matchers,\n+                        stab: self.stability(def.id),\n+                        depr: self.deprecation(def.id),\n+                        imported_from: def.imported_from.map(|ident| ident.name),\n+                    })\n+                }\n+            }\n+        }\n         om\n     }\n "}, {"sha": "5ea07403cf793b7e25038e36f1fff7894236f19d", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03f855221d83ad13120b309506488f4a34cb0f/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=ab03f855221d83ad13120b309506488f4a34cb0f", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:empty-struct.rs\n+\n #[no_link]\n-extern crate libc;\n+extern crate empty_struct;\n \n fn main() {\n-    unsafe {\n-        libc::abs(0);  //~ ERROR unresolved name\n-    }\n+    empty_struct::XEmpty1; //~ ERROR unresolved name\n }"}]}