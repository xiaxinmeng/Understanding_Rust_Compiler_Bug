{"sha": "4061ca2bbd218356dad806368a4acef8be0e5e12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNjFjYTJiYmQyMTgzNTZkYWQ4MDYzNjhhNGFjZWY4YmUwZTVlMTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-04T17:46:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-04T17:46:10Z"}, "message": "rustc: Generate shapes", "tree": {"sha": "1ce7af2dda4491efe328bf550fdceff34601fa89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ce7af2dda4491efe328bf550fdceff34601fa89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4061ca2bbd218356dad806368a4acef8be0e5e12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4061ca2bbd218356dad806368a4acef8be0e5e12", "html_url": "https://github.com/rust-lang/rust/commit/4061ca2bbd218356dad806368a4acef8be0e5e12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4061ca2bbd218356dad806368a4acef8be0e5e12/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb6922c28e24afa3dc6e893e016bcdb07f4750e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb6922c28e24afa3dc6e893e016bcdb07f4750e", "html_url": "https://github.com/rust-lang/rust/commit/6bb6922c28e24afa3dc6e893e016bcdb07f4750e"}], "stats": {"total": 644, "additions": 625, "deletions": 19}, "files": [{"sha": "c9abfac24487f58a1b1068fd57ef1325fddb419a", "filename": "src/comp/middle/shape.rs", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=4061ca2bbd218356dad806368a4acef8be0e5e12", "patch": "@@ -0,0 +1,538 @@\n+// A \"shape\" is a compact encoding of a type that is used by interpreted glue.\n+// This substitutes for the runtime tags used by e.g. MLs.\n+\n+import lib::llvm::True;\n+import lib::llvm::llvm::ModuleRef;\n+import lib::llvm::llvm::TypeRef;\n+import lib::llvm::llvm::ValueRef;\n+import middle::trans;\n+import middle::trans_common::crate_ctxt;\n+import middle::trans::llsize_of;\n+import middle::trans_common::val_ty;\n+import middle::trans_common;\n+import middle::trans_common::C_bytes;\n+import middle::trans_common::C_int;\n+import middle::trans_common::C_named_struct;\n+import middle::trans_common::C_struct;\n+import middle::trans_common::C_uint;\n+import middle::trans_common::T_i8;\n+import middle::trans_common::T_ptr;\n+import middle::ty;\n+import middle::ty::field;\n+import middle::ty::mt;\n+import syntax::ast;\n+import syntax::codemap::span;\n+import syntax::util::interner;\n+import util::common;\n+\n+import std::ivec;\n+import std::map::hashmap;\n+import std::option::none;\n+import std::option::some;\n+import std::str;\n+\n+import ty_ctxt = middle::ty::ctxt;\n+\n+type res_info = { did: ast::def_id, t: ty::t };\n+\n+type ctxt = {\n+    mutable next_tag_id: u16,\n+    pad: u16,\n+    tag_id_to_index: hashmap[ast::def_id,u16],\n+    mutable tag_order: ast::def_id[],\n+    resources: interner::interner[res_info],\n+    llshapetablesty: TypeRef,\n+    llshapetables: ValueRef\n+};\n+\n+const shape_u8 : u8 = 0u8;\n+const shape_u16 : u8 = 1u8;\n+const shape_u32 : u8 = 2u8;\n+const shape_u64 : u8 = 3u8;\n+const shape_i8 : u8 = 4u8;\n+const shape_i16 : u8 = 5u8;\n+const shape_i32 : u8 = 6u8;\n+const shape_i64 : u8 = 7u8;\n+const shape_f32 : u8 = 8u8;\n+const shape_f64 : u8 = 9u8;\n+const shape_evec : u8 = 10u8;\n+const shape_ivec : u8 = 11u8;\n+const shape_tag : u8 = 12u8;\n+const shape_box : u8 = 13u8;\n+const shape_port : u8 = 14u8;\n+const shape_chan : u8 = 15u8;\n+const shape_task : u8 = 16u8;\n+const shape_struct : u8 = 17u8;\n+const shape_fn : u8 = 18u8;\n+const shape_obj : u8 = 19u8;\n+const shape_res : u8 = 20u8;\n+const shape_var : u8 = 21u8;\n+\n+// FIXME: This is a bad API in trans_common.\n+fn C_u8(n : u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n+\n+fn fake_span() -> span { ret { lo: 0u, hi: 0u }; }\n+\n+fn hash_res_info(ri : &res_info) -> uint {\n+    let h = 5381u;\n+    h *= 33u; h += (ri.did.crate as uint);\n+    h *= 33u; h += (ri.did.node as uint);\n+    h *= 33u; h += (ri.t as uint);\n+    ret h;\n+}\n+\n+fn eq_res_info(a : &res_info, b : &res_info) -> bool {\n+    ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n+}\n+\n+fn mk_global(ccx : &@crate_ctxt, name : &str, llval : ValueRef) -> ValueRef {\n+    let llglobal = lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval),\n+                                                   str::buf(name));\n+    lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n+    lib::llvm::llvm::LLVMSetGlobalConstant(llglobal, True);\n+    lib::llvm::llvm::LLVMSetLinkage(llglobal, lib::llvm::LLVMInternalLinkage\n+                                    as lib::llvm::llvm::Linkage);\n+    ret llglobal;\n+}\n+\n+\n+// Computes a set of variants of a tag that are guaranteed to have size and\n+// alignment at least as large as any other variant of the tag. This is an\n+// important performance optimization.\n+//\n+// TODO: Use this in dynamic_size_of() as well.\n+\n+fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> uint[] {\n+    // Compute the minimum and maximum size and alignment for each variant.\n+    //\n+    // TODO: We could do better here; e.g. we know that any variant that\n+    // contains (T,T) must be as least as large as any variant that contains\n+    // just T.\n+    let ranges = ~[];\n+    let variants = ty::tag_variants(ccx.tcx, tag_id);\n+    for variant : ty::variant_info in variants {\n+        let bounded = true;\n+        let { a: min_size, b: min_align } = { a: 0u, b: 0u };\n+        for elem_t : ty::t in variant.args {\n+            if ty::type_contains_params(ccx.tcx, elem_t) {\n+                // TODO: We could do better here; this causes us to\n+                // conservatively assume that (int, T) has minimum size 0,\n+                // when in fact it has minimum size sizeof(int).\n+                bounded = false;\n+            } else {\n+                let llty = trans::type_of(ccx, fake_span(), elem_t);\n+                min_size += trans::llsize_of_real(ccx, llty);\n+                min_align += trans::llalign_of_real(ccx, llty);\n+            }\n+        }\n+\n+        ranges += ~[{ size:  { min: min_size,  bounded: bounded },\n+                      align: { min: min_align, bounded: bounded } }];\n+    }\n+\n+    // Initialize the candidate set to contain all variants.\n+    let candidates = ~[mutable];\n+    for variant in variants { candidates += ~[mutable true]; }\n+\n+    // Do a pairwise comparison among all variants still in the candidate set.\n+    // Throw out any variant that we know has size and alignment at least as\n+    // small as some other variant.\n+    let i = 0u;\n+    while i < ivec::len(ranges) - 1u {\n+        if candidates.(i) {\n+            let j = i + 1u;\n+            while (j < ivec::len(ranges)) {\n+                if candidates.(j) {\n+                    if ranges.(i).size.bounded && ranges.(i).align.bounded &&\n+                            ranges.(j).size.bounded &&\n+                            ranges.(j).align.bounded {\n+                        if ranges.(i).size >= ranges.(j).size &&\n+                                ranges.(i).align >= ranges.(j).align {\n+                            // Throw out j.\n+                            candidates.(j) = false;\n+                        } else if ranges.(j).size >= ranges.(i).size &&\n+                                ranges.(j).align >= ranges.(j).align {\n+                            // Throw out i.\n+                            candidates.(i) = false;\n+                        }\n+                    }\n+                }\n+                j += 1u;\n+            }\n+        }\n+        i += 1u;\n+    }\n+\n+    // Return the resulting set.\n+    let result = ~[];\n+    i = 0u;\n+    while i < ivec::len(candidates) {\n+        if candidates.(i) { result += ~[i]; }\n+        i += 1u;\n+    }\n+    ret result;\n+}\n+\n+// Computes the static size of a tag, without using mk_imm_tup(), which is\n+// bad for performance.\n+//\n+// TODO: Migrate trans over to use this.\n+\n+fn round_up(size : u16, align : u8) -> u16 {\n+    assert align >= 1u8;\n+    let alignment = align as u16;\n+    ret ((size-1u16) + alignment) & !(alignment-1u16);\n+}\n+\n+type size_align = { size: u16, align: u8 };\n+\n+fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &uint[],\n+                           did : &ast::def_id) -> size_align {\n+    let max_size = 0u16; let max_align = 1u8;\n+    let variants = ty::tag_variants(ccx.tcx, did);\n+    for vid : uint in largest_variants {\n+        // We increment a \"virtual data pointer\" to compute the size.\n+        let lltys = ~[];\n+        for typ : ty::t in variants.(vid).args {\n+            lltys += ~[trans::type_of(ccx, fake_span(), typ)];\n+        }\n+\n+        let llty = trans_common::T_struct(lltys);\n+        let dp = trans::llsize_of_real(ccx, llty) as u16;\n+        let variant_align = trans::llalign_of_real(ccx, llty) as u8;\n+\n+        if max_size < dp { max_size = dp; }\n+        if max_align < variant_align { max_align = variant_align; }\n+    }\n+\n+    // Add space for the tag if applicable.\n+    // FIXME (issue #792): This is wrong. If the tag starts with an 8 byte\n+    // aligned quantity, we don't align it.\n+    if ivec::len(variants) > 1u {\n+        max_size += 4u16;\n+        max_align = 4u8;\n+    }\n+\n+    ret { size: max_size, align: max_align };\n+}\n+\n+tag tag_kind {\n+    tk_unit;\n+    tk_enum;\n+    tk_complex;\n+}\n+\n+fn tag_kind(ccx : &@crate_ctxt, did : &ast::def_id) -> tag_kind {\n+    let variants = ty::tag_variants(ccx.tcx, did);\n+    if ivec::len(variants) == 0u { ret tk_complex; }\n+    for v : ty::variant_info in variants {\n+        if ivec::len(v.args) > 0u { ret tk_complex; }\n+    }\n+    if ivec::len(variants) == 1u { ret tk_unit; }\n+    ret tk_enum;\n+}\n+\n+\n+// Returns the code corresponding to the pointer size on this architecture.\n+fn s_int(tcx : &ty_ctxt) -> u8 {\n+    ret shape_i32;      // TODO: x86-64\n+}\n+\n+fn s_uint(tcx : &ty_ctxt) -> u8 {\n+    ret shape_u32;      // TODO: x86-64\n+}\n+\n+fn s_float(tcx : &ty_ctxt) -> u8 {\n+    ret shape_f32;      // TODO: x86-64\n+}\n+\n+fn mk_ctxt(llmod : ModuleRef) -> ctxt {\n+    let llshapetablesty = trans_common::T_named_struct(\"shapes\");\n+    let llshapetables =\n+        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty,\n+                                       str::buf(\"shapes\"));\n+\n+    ret {\n+        mutable next_tag_id: 0u16,\n+        pad: 0u16,\n+        tag_id_to_index: common::new_def_hash(),\n+        mutable tag_order: ~[],\n+        resources: interner::mk(hash_res_info, eq_res_info),\n+        llshapetablesty: llshapetablesty,\n+        llshapetables: llshapetables\n+    };\n+}\n+\n+fn add_bool(dest : &mutable u8[], val : bool) {\n+    dest += ~[if val { 1u8 } else { 0u8 }];\n+}\n+\n+fn add_u16(dest : &mutable u8[], val : u16) {\n+    dest += ~[(val & 0xffu16) as u8, (val >> 8u16) as u8];\n+}\n+\n+fn add_substr(dest : &mutable u8[], src : &u8[]) {\n+    add_u16(dest, ivec::len(src) as u16);\n+    dest += src;\n+}\n+\n+fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> u8[] {\n+    let s = ~[];\n+\n+    alt ty::struct(ccx.tcx, t) {\n+      ty::ty_nil. | ty::ty_bool. | ty::ty_machine(ast::ty_u8.) {\n+        s += ~[shape_u8];\n+      }\n+\n+      ty::ty_bot. { fail \"bot ty in shape_of\"; }\n+\n+      ty::ty_int. { s += ~[s_int(ccx.tcx)]; }\n+      ty::ty_float. { s += ~[s_float(ccx.tcx)]; }\n+\n+      ty::ty_uint. | ty::ty_ptr(_) | ty::ty_type. | ty::ty_native(_) {\n+        s += ~[s_uint(ccx.tcx)];\n+      }\n+\n+      ty::ty_machine(ast::ty_i8.) { s += ~[shape_i8]; }\n+      ty::ty_machine(ast::ty_u16.) { s += ~[shape_u16]; }\n+      ty::ty_machine(ast::ty_i16.) { s += ~[shape_i16]; }\n+      ty::ty_machine(ast::ty_u32.) | ty::ty_char. { s += ~[shape_u32]; }\n+      ty::ty_machine(ast::ty_i32.) { s += ~[shape_i32]; }\n+\n+      ty::ty_str. { s += ~[shape_evec, 1u8, 1u8, 0u8, shape_u8]; }\n+      ty::ty_istr. { s += ~[shape_ivec, 1u8, 1u8, 0u8, shape_u8]; }\n+\n+      ty::ty_tag(did, tps) {\n+        alt tag_kind(ccx, did) {\n+          tk_unit. {\n+            // FIXME: For now we do this.\n+            s += ~[shape_u32];\n+          }\n+          tk_enum. { s += ~[shape_u32]; }\n+          tk_complex. {\n+            s += ~[shape_tag];\n+\n+            let sub = ~[];\n+\n+            let id;\n+            alt ccx.shape_cx.tag_id_to_index.find(did) {\n+              none. {\n+                id = ccx.shape_cx.next_tag_id;\n+                ccx.shape_cx.tag_id_to_index.insert(did, id);\n+                ccx.shape_cx.tag_order += ~[did];\n+                ccx.shape_cx.next_tag_id += 1u16;\n+              }\n+              some(existing_id) { id = existing_id; }\n+            }\n+            add_u16(sub, id as u16);\n+\n+            add_u16(sub, ivec::len(tps) as u16);\n+            for tp : ty::t in tps {\n+                let subshape = shape_of(ccx, tp);\n+                add_u16(sub, ivec::len(subshape) as u16);\n+                sub += subshape;\n+            }\n+\n+            s += sub;\n+          }\n+        }\n+      }\n+\n+      ty::ty_box(mt) {\n+        s += ~[shape_box];\n+        add_substr(s, shape_of(ccx, mt.ty));\n+      }\n+      ty::ty_vec(mt) {\n+        s += ~[shape_evec];\n+        add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n+        add_substr(s, shape_of(ccx, mt.ty));\n+      }\n+      ty::ty_ivec(mt) {\n+        s += ~[shape_ivec];\n+        add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n+        add_size_hint(ccx, s, mt.ty);\n+        add_substr(s, shape_of(ccx, mt.ty));\n+      }\n+      ty::ty_port(t) {\n+        s += ~[shape_port];\n+        add_substr(s, shape_of(ccx, t));\n+      }\n+      ty::ty_chan(t) { s += ~[shape_chan]; }\n+      ty::ty_task. { s += ~[shape_task]; }\n+\n+      ty::ty_rec(fields) {\n+        s += ~[shape_struct];\n+        let sub = ~[];\n+        for f : field in fields { sub += shape_of(ccx, f.mt.ty); }\n+        add_substr(s, sub);\n+      }\n+\n+      ty::ty_fn(_,_,_,_,_) { s += ~[shape_fn]; }\n+      ty::ty_native_fn(_,_,_) { s += ~[shape_u32]; }\n+      ty::ty_obj(_) { s += ~[shape_obj]; }\n+\n+      ty::ty_res(did, raw_subt, tps) {\n+        let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n+        let ri = { did: did, t: subt };\n+        let id = interner::intern(ccx.shape_cx.resources, ri);\n+\n+        s += ~[shape_res];\n+        add_u16(s, id as u16);\n+        add_u16(s, ivec::len(tps) as u16);\n+\n+        let sub = ~[];\n+        for tp : ty::t in tps { add_substr(s, sub); }\n+        add_substr(s, sub);\n+\n+        add_substr(s, shape_of(ccx, subt));\n+\n+      }\n+\n+      ty::ty_var(n) { fail \"shape_of ty_var\"; }\n+      ty::ty_param(n,_) { s += ~[shape_var, n as u8]; }\n+    }\n+\n+    ret s;\n+}\n+\n+fn add_size_hint(ccx : &@crate_ctxt, s : &mutable u8[], typ : ty::t) {\n+    if (ty::type_has_dynamic_size(ccx.tcx, typ)) {\n+        s += ~[ 0u8, 0u8, 0u8 ];\n+        ret;\n+    }\n+\n+    let llty = trans::type_of(ccx, fake_span(), typ);\n+    add_u16(s, trans::llsize_of_real(ccx, llty) as u16);\n+    s += ~[ trans::llalign_of_real(ccx, llty) as u8 ];\n+}\n+\n+// FIXME: We might discover other variants as we traverse these. Handle this.\n+fn shape_of_variant(ccx : &@crate_ctxt, v : &ty::variant_info) -> u8[] {\n+    let s = ~[];\n+    for t : ty::t in v.args { s += shape_of(ccx, t); }\n+    ret s;\n+}\n+\n+fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n+    // Loop over all the tag variants and write their shapes into a data\n+    // buffer. As we do this, it's possible for us to discover new tags, so we\n+    // must do this first.\n+    let i = 0u;\n+    let data = ~[]; let offsets = ~[];\n+    while (i < ivec::len(ccx.shape_cx.tag_order)) {\n+        let did = ccx.shape_cx.tag_order.(i);\n+        let variants = ty::tag_variants(ccx.tcx, did);\n+\n+        for v : ty::variant_info in variants {\n+            offsets += ~[ivec::len(data) as u16];\n+\n+            let variant_shape = shape_of_variant(ccx, v);\n+            add_substr(data, variant_shape);\n+        }\n+\n+        i += 1u;\n+    }\n+\n+    // Now calculate the sizes of the header space (which contains offsets to\n+    // info records for each tag) and the info space (which contains offsets\n+    // to each variant shape). As we do so, build up the header.\n+\n+    let header = ~[]; let info = ~[];\n+    let header_sz = 2u16 * ccx.shape_cx.next_tag_id;\n+    let data_sz = ivec::len(data) as u16;\n+\n+    let info_sz = 0u16;\n+    for did_ : ast::def_id in ccx.shape_cx.tag_order {\n+        let did = did_;    // Satisfy alias checker.\n+        let variants = ty::tag_variants(ccx.tcx, did);\n+        add_u16(header, header_sz + info_sz);\n+        info_sz += 2u16 * ((ivec::len(variants) as u16) + 2u16) + 3u16;\n+    }\n+\n+    // Construct the info tables, which contain offsets to the shape of each\n+    // variant. Also construct the largest-variant table for each tag, which\n+    // contains the variants that the size-of operation needs to look at.\n+\n+    let lv_table = ~[];\n+    i = 0u;\n+    for did_ : ast::def_id in ccx.shape_cx.tag_order {\n+        let did = did_;    // Satisfy alias checker.\n+        let variants = ty::tag_variants(ccx.tcx, did);\n+        add_u16(info, ivec::len(variants) as u16);\n+\n+        // Construct the largest-variants table.\n+        add_u16(info, header_sz + info_sz + data_sz +\n+                (ivec::len(lv_table) as u16));\n+\n+        let lv = largest_variants(ccx, did);\n+        add_u16(lv_table, ivec::len(lv) as u16);\n+        for v : uint in lv { add_u16(lv_table, v as u16); }\n+\n+        // Determine whether the tag has dynamic size.\n+        let dynamic = false;\n+        for variant : ty::variant_info in variants {\n+            for typ : ty::t in variant.args {\n+                if ty::type_has_dynamic_size(ccx.tcx, typ) { dynamic = true; }\n+            }\n+        }\n+\n+        // If we can, write in the static size and alignment of the tag.\n+        // Otherwise, write a placeholder.\n+        let size_align;\n+        if dynamic {\n+            size_align = { size: 0u16, align: 0u8 };\n+        } else {\n+            size_align = compute_static_tag_size(ccx, lv, did);\n+        }\n+        add_u16(info, size_align.size);\n+        info += ~[size_align.align];\n+\n+        // Now write in the offset of each variant.\n+        for v : ty::variant_info in variants {\n+            add_u16(info, header_sz + info_sz + offsets.(i));\n+            i += 1u;\n+        }\n+    }\n+\n+    assert (i == ivec::len(offsets));\n+    assert (header_sz == (ivec::len(header) as u16));\n+    assert (info_sz == (ivec::len(info) as u16));\n+    assert (data_sz == (ivec::len(data) as u16));\n+\n+    header += info;\n+    header += data;\n+    header += lv_table;\n+\n+    ret mk_global(ccx, \"tag_shapes\", C_bytes(header));\n+}\n+\n+fn gen_resource_shapes(ccx : &@crate_ctxt) -> ValueRef {\n+    let dtors = ~[];\n+    let i = 0u;\n+    let len = interner::len(ccx.shape_cx.resources);\n+    while i < len {\n+        let ri = interner::get(ccx.shape_cx.resources, i);\n+        dtors += ~[trans_common::get_res_dtor(ccx, fake_span(), ri.did,\n+                                              ri.t)];\n+        i += 1u;\n+    }\n+\n+    ret mk_global(ccx, \"resource_shapes\", C_struct(dtors));\n+}\n+\n+fn gen_shape_tables(ccx : &@crate_ctxt) {\n+    let lltagstable = gen_tag_shapes(ccx);\n+    let llresourcestable = gen_resource_shapes(ccx);\n+    trans_common::set_struct_body(ccx.shape_cx.llshapetablesty,\n+                                  ~[val_ty(lltagstable),\n+                                    val_ty(llresourcestable)]);\n+\n+    let lltables = C_named_struct(ccx.shape_cx.llshapetablesty,\n+                                  ~[lltagstable, llresourcestable]);\n+    lib::llvm::llvm::LLVMSetInitializer(ccx.shape_cx.llshapetables, lltables);\n+    lib::llvm::llvm::LLVMSetGlobalConstant(ccx.shape_cx.llshapetables, True);\n+    lib::llvm::llvm::LLVMSetLinkage(ccx.shape_cx.llshapetables,\n+                                    lib::llvm::LLVMInternalLinkage as\n+                                    lib::llvm::llvm::Linkage);\n+}\n+"}, {"sha": "817e82718ecc2ad5ee41b55fbf8dee815dda40bc", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4061ca2bbd218356dad806368a4acef8be0e5e12", "patch": "@@ -426,6 +426,11 @@ fn llsize_of_real(cx: &@crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t);\n }\n \n+// Returns the real alignment of the given type for the current target.\n+fn llalign_of_real(cx: &@crate_ctxt, t: TypeRef) -> uint {\n+    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t);\n+}\n+\n fn llsize_of(t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), T_int(),\n                                False);\n@@ -1424,23 +1429,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n     let val = GEP_tup_like(cx, tup_ty, rs, ~[0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n-    let dtor_pair =\n-        if did.crate == ast::local_crate {\n-            alt ccx.fn_pairs.find(did.node) {\n-              some(x) { x }\n-              _ { ccx.tcx.sess.bug(\"internal error in trans_res_drop\") }\n-            }\n-        } else {\n-            let params =\n-                csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n-            let f_t =\n-                type_of_fn(ccx, cx.sp, ast::proto_fn,\n-                           ~[{mode: ty::mo_alias(false), ty: inner_t}],\n-                           ty::mk_nil(ccx.tcx), params);\n-            get_extern_const(ccx.externs, ccx.llmod,\n-                             csearch::get_symbol(ccx.sess.get_cstore(), did),\n-                             T_fn_pair(*ccx, f_t))\n-        };\n+    let dtor_pair = trans_common::get_res_dtor(ccx, cx.sp, did, inner_t);\n     let dtor_addr =\n         cx.build.Load(cx.build.GEP(dtor_pair,\n                                    ~[C_int(0), C_int(abi::fn_field_code)]));\n@@ -8002,7 +7991,8 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n               upcall::declare_upcalls(tn, tydesc_type, taskptr_type, llmod),\n           rust_object_type: T_rust_object(),\n           tydesc_type: tydesc_type,\n-          task_type: task_type};\n+          task_type: task_type,\n+          shape_cx: shape::mk_ctxt(llmod)};\n     let cx = new_local_ctxt(ccx);\n     collect_items(ccx, crate);\n     collect_tag_ctors(ccx, crate);"}, {"sha": "32b25a8a062c0af81cd8190774257b504793f8cf", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=4061ca2bbd218356dad806368a4acef8be0e5e12", "patch": "@@ -4,6 +4,7 @@\n */\n \n import std::int;\n+import std::ivec;\n import std::str;\n import std::uint;\n import std::str::rustrt::sbuf;\n@@ -13,6 +14,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::fs;\n+import std::unsafe;\n import syntax::ast;\n import driver::session;\n import middle::ty;\n@@ -139,7 +141,8 @@ type crate_ctxt = {\n     upcalls: @upcall::upcalls,\n     rust_object_type: TypeRef,\n     tydesc_type: TypeRef,\n-    task_type: TypeRef\n+    task_type: TypeRef,\n+    shape_cx: shape::ctxt\n };\n \n type local_ctxt =\n@@ -314,6 +317,25 @@ fn revoke_clean(cx: &@block_ctxt, val: ValueRef) {\n                              std::ivec::len(sc_cx.cleanups));\n }\n \n+fn get_res_dtor(ccx : &@crate_ctxt, sp : &span, did : &ast::def_id,\n+                inner_t : ty::t) -> ValueRef {\n+    if did.crate == ast::local_crate {\n+        alt ccx.fn_pairs.find(did.node) {\n+            some(x) { ret x; }\n+            _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n+        }\n+    }\n+\n+    let params = csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n+    let f_t = trans::type_of_fn(ccx, sp, ast::proto_fn,\n+                                ~[{ mode: ty::mo_alias(false), ty: inner_t }],\n+                                ty::mk_nil(ccx.tcx), params);\n+    ret trans::get_extern_const(ccx.externs, ccx.llmod,\n+                                csearch::get_symbol(ccx.sess.get_cstore(),\n+                                                    did),\n+                                T_fn_pair(*ccx, f_t));\n+}\n+\n tag block_kind {\n \n \n@@ -846,3 +868,9 @@ fn C_array(ty: TypeRef, elts: &ValueRef[]) -> ValueRef {\n     ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n                              std::ivec::len(elts));\n }\n+\n+fn C_bytes(bytes : &u8[]) -> ValueRef {\n+    ret llvm::LLVMConstString(unsafe::reinterpret_cast(ivec::to_ptr(bytes)),\n+                              ivec::len(bytes), False);\n+}\n+"}, {"sha": "556c9e36bea442c05de715c5c6fd8b8c689f0d84", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4061ca2bbd218356dad806368a4acef8be0e5e12", "patch": "@@ -170,6 +170,7 @@ export type_is_fp;\n export type_is_integral;\n export type_is_native;\n export type_is_nil;\n+export type_is_pod;\n export type_is_scalar;\n export type_is_sequence;\n export type_is_signed;\n@@ -1340,6 +1341,50 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n     ret result;\n }\n \n+// Whether a type is Plain Old Data (i.e. can be safely memmoved).\n+fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n+    let result = true;\n+    alt struct(cx, ty) {\n+        // Scalar types\n+        ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n+        ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n+            result = true;\n+        }\n+\n+        // Boxed types\n+        ty_str. | ty_istr. | ty_box(_) | ty_vec(_) | ty_ivec(_) |\n+        ty_fn(_,_,_,_,_) | ty_native_fn(_,_,_) | ty_obj(_) | ty_port(_) |\n+        ty_chan(_) | ty_task. { result = false; }\n+\n+        // Structural types\n+        ty_tag(did, tps) {\n+            let variants = tag_variants(cx, did);\n+            for variant : variant_info in variants {\n+                let tup_ty = mk_imm_tup(cx, variant.args);\n+\n+                // Perform any type parameter substitutions.\n+                tup_ty = substitute_type_params(cx, tps, tup_ty);\n+                if !type_is_pod(cx, tup_ty) { result = false; }\n+            }\n+        }\n+        ty_rec(flds) {\n+            for f : field in flds {\n+                if !type_is_pod(cx, f.mt.ty) { result = false; }\n+            }\n+        }\n+        ty_res(_, inner, tps) {\n+            result = type_is_pod(cx,\n+                substitute_type_params(cx, tps, inner));\n+        }\n+        ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n+\n+        ty_var(_) { fail \"ty_var in type_is_pod\"; }\n+        ty_param(_,_) { result = false; }\n+    }\n+\n+    ret result;\n+}\n+\n fn type_param(cx: &ctxt, ty: &t) -> option::t[uint] {\n     alt struct(cx, ty) {\n       ty_param(id,_) { ret some(id); }"}, {"sha": "3181d3480718bd92af9c321f6f00c3d83a53ca20", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=4061ca2bbd218356dad806368a4acef8be0e5e12", "patch": "@@ -29,6 +29,7 @@ mod middle {\n     mod alias;\n     mod kind;\n     mod freevars;\n+    mod shape;\n \n     mod tstate {\n         mod ck;"}, {"sha": "7e7a9ca71073233969ac821525d5997ea59f4d74", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4061ca2bbd218356dad806368a4acef8be0e5e12/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=4061ca2bbd218356dad806368a4acef8be0e5e12", "patch": "@@ -20,6 +20,7 @@ fn mk[@T](hasher: hashfn[T], eqer: eqfn[T]) -> interner[T] {\n     let m = map::mk_hashmap[T, uint](hasher, eqer);\n     ret {map: m, mutable vect: ~[], hasher: hasher, eqer: eqer};\n }\n+\n fn intern[@T](itr: &interner[T], val: &T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n@@ -31,5 +32,8 @@ fn intern[@T](itr: &interner[T], val: &T) -> uint {\n       }\n     }\n }\n+\n fn get[T](itr: &interner[T], idx: uint) -> T { ret itr.vect.(idx); }\n \n+fn len[T](itr : &interner[T]) -> uint { ret ivec::len(itr.vect); }\n+"}]}