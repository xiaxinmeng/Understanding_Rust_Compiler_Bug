{"sha": "39151f2ad8d18554af1d6787bae0b02345e1d90b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MTUxZjJhZDhkMTg1NTRhZjFkNjc4N2JhZTBiMDIzNDVlMWQ5MGI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-13T22:44:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-13T22:44:09Z"}, "message": "Prohibit trailing whitespace under 'tidy' script. Clean up all caught cases.", "tree": {"sha": "c10c032214af521351cd46d6ee23a5007927bc48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c10c032214af521351cd46d6ee23a5007927bc48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39151f2ad8d18554af1d6787bae0b02345e1d90b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39151f2ad8d18554af1d6787bae0b02345e1d90b", "html_url": "https://github.com/rust-lang/rust/commit/39151f2ad8d18554af1d6787bae0b02345e1d90b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39151f2ad8d18554af1d6787bae0b02345e1d90b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b239f3cb9d4b62488dc2d219e9bd9a242bdf8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b239f3cb9d4b62488dc2d219e9bd9a242bdf8f", "html_url": "https://github.com/rust-lang/rust/commit/04b239f3cb9d4b62488dc2d219e9bd9a242bdf8f"}], "stats": {"total": 783, "additions": 393, "deletions": 390}, "files": [{"sha": "bf2a8e0b41849ef6e7ee1722fa15418ecbcee68b", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -257,6 +257,7 @@ include $(CFG_SRC_DIR)/mk/docs.mk\n ifneq ($(strip $(findstring dist,$(MAKECMDGOALS))   \\\n                $(findstring check,$(MAKECMDGOALS))  \\\n                $(findstring test,$(MAKECMDGOALS))   \\\n+               $(findstring tidy,$(MAKECMDGOALS))   \\\n                $(findstring clean,$(MAKECMDGOALS))),)\n   CFG_INFO := $(info cfg: including dist rules)\n   include $(CFG_SRC_DIR)/mk/dist.mk"}, {"sha": "2586fb9ba92a3132a0d986f1b0ce2ef9cdfee7c7", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -325,7 +325,7 @@ fn build_link_meta(&session::session sess, &ast::crate c,\n         fn len_and_str_lit(&ast::lit l) -> str {\n             ret len_and_str(pprust::lit_to_str(@l));\n         }\n-    \n+\n         auto cmh_items = attr::sort_meta_items(metas.cmh_items);\n \n         sha.reset();"}, {"sha": "8a51c1a319e3400917d58d365eb3bf78b03aba5a", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -199,7 +199,7 @@ fn require_unique_names(&session::session sess, &(@ast::meta_item)[] metas) {\n     for (@ast::meta_item meta in metas) {\n         auto name = get_meta_item_name(meta);\n         if (map.contains_key(name)) {\n-            sess.span_fatal(meta.span, \n+            sess.span_fatal(meta.span,\n                             #fmt(\"duplicate meta item `%s`\", name));\n         }\n         map.insert(name, ());"}, {"sha": "1bae202b4b145d53c911d442b6dd3012517e3a06", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -98,7 +98,7 @@ fn fold_item(&test_ctxt cx, &@ast::item i,\n }\n \n fn is_test_fn(&@ast::item i) -> bool {\n-    auto has_test_attr = \n+    auto has_test_attr =\n         ivec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n \n     fn has_test_signature(&@ast::item i) -> bool {\n@@ -173,7 +173,7 @@ fn mk_tests(&test_ctxt cx) -> @ast::item {\n                                 cf = ast::return,\n                                 constraints = ~[]);\n     auto proto = ast::proto_fn;\n-    \n+\n     // The vector of test_descs for this crate\n     auto test_descs = mk_test_desc_vec(cx);\n \n@@ -352,7 +352,7 @@ fn mk_test_main_call(&test_ctxt cx) -> @ast::expr {\n                                             node = test_main_path_expr_,\n                                             span = rec(lo=0u, hi=0u));\n \n-    let ast::expr_ test_main_call_expr_ \n+    let ast::expr_ test_main_call_expr_\n         = ast::expr_call(@test_main_path_expr, ~[@args_path_expr,\n                                                  @test_call_expr]);\n "}, {"sha": "0fb4fea03b54e25505daa63b61f1277ad591c585", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -889,7 +889,7 @@ native mod llvm = \"rustllvm\" {\n  * BuilderRef B into place.  A BuilderRef is a cursor-like LLVM value that\n  * inserts instructions for a particular BasicBlockRef at a particular\n  * position; for our purposes, it always inserts at the end of the basic block\n- * it's attached to.  \n+ * it's attached to.\n  */\n \n // FIXME: Do we want to support mutable object fields?\n@@ -1524,9 +1524,9 @@ fn type_to_str_inner(type_names names, &TypeRef[] outer0, TypeRef ty) -> str {\n             ret s;\n         }\n \n-        case (10) { \n+        case (10) {\n             auto el_ty = llvm::LLVMGetElementType(ty);\n-            ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\"; \n+            ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n         }\n \n         case (11) {"}, {"sha": "2f4e741a25d829f862297cb5e557136c71a18ead", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -236,7 +236,7 @@ fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n         if (semi) { w.write_char(';'); } else { semi = true; }\n         alt (a.node) {\n             case (carg_base) { w.write_char('*'); }\n-            case (carg_ident(?i)) { \n+            case (carg_ident(?i)) {\n                 w.write_uint(i);\n             }\n             case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }"}, {"sha": "365f5e84e75fe16030dffa98250947cccf42a720", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -156,7 +156,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n              with *visit::default_visitor[scopes]());\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_map_mod));\n-    // Register the top-level mod \n+    // Register the top-level mod\n \n     e.mod_map.insert(-1,\n                      @rec(m=some(c.node.module),\n@@ -342,7 +342,7 @@ fn visit_fn_with_scope(&@env e, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n     // for f's constrs in the table.\n \n     for (@ast::constr c in f.decl.constraints) {\n-        resolve_constr(e, id, c, sc, v); \n+        resolve_constr(e, id, c, sc, v);\n     }\n     visit::visit_fn(f, tp, sp, name, id,\n                     cons(scope_fn(f.decl, tp), @sc), v);\n@@ -1294,7 +1294,7 @@ fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n                     // Fight the alias checker\n                     auto name_ = name;\n                     e.sess.span_err\n-                        (a.pats.(i).span, \"binding \" + name_ + \n+                        (a.pats.(i).span, \"binding \" + name_ +\n                          \" does not occur in first pattern\");\n                 }\n             }"}, {"sha": "acd42ee71cd916f0d0e0034497a118d1fee80d94", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -2726,7 +2726,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         }\n         ret rslt(cx, C_nil());\n     }\n-    \n+\n     let result r = rslt(cx, C_nil());\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_tup(?args)) {\n@@ -4481,7 +4481,7 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n \n // Given a block context and a list of upvars, construct a closure that\n // contains pointers to all of the upvars and all of the tydescs in\n-// scope. Return the ValueRef and TypeRef corresponding to the closure. \n+// scope. Return the ValueRef and TypeRef corresponding to the closure.\n fn build_environment(&@block_ctxt cx, &ast::node_id[] upvars) ->\n     tup(ValueRef, TypeRef) {\n     auto upvar_count = std::ivec::len(upvars);\n@@ -5149,8 +5149,8 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n                     int_cast(e_res.bcx, lldsttype, llsrctype, e_res.val,\n                              ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)));\n         }\n-    } \n-    else { \n+    }\n+    else {\n         if (ty::type_is_integral(cx.fcx.lcx.ccx.tcx,\n                                  ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n             if (ty::type_is_signed(cx.fcx.lcx.ccx.tcx,\n@@ -5748,7 +5748,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     auto llretslot = args_res._2;\n     /*\n     log \"calling: \" + val_str(cx.fcx.lcx.ccx.tn, faddr);\n-    \n+\n     for (ValueRef arg in llargs) {\n         log \"arg: \" + val_str(cx.fcx.lcx.ccx.tn, arg);\n     }\n@@ -6181,7 +6181,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                check the value of that variable, doing nothing\n                if it's set to false and acting like a check\n                otherwise. */\n-            auto c = get_extern_const(cx.fcx.lcx.ccx.externs, \n+            auto c = get_extern_const(cx.fcx.lcx.ccx.externs,\n                                       cx.fcx.lcx.ccx.llmod,\n                                       \"check_claims\", T_bool());\n             auto cond = cx.build.Load(c);\n@@ -6215,7 +6215,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         }\n         case (_) {\n             // The expression is an lvalue. Fall through.\n-            assert (ty::is_lval(e)); // make sure it really is and that we \n+            assert (ty::is_lval(e)); // make sure it really is and that we\n                                // didn't forget to add a case for a new expr!\n         }\n     }\n@@ -6396,7 +6396,7 @@ fn trans_fail_expr(&@block_ctxt cx, &option::t[span] sp_opt,\n         }\n     }\n }\n- \n+\n fn trans_fail(&@block_ctxt cx, &option::t[span] sp_opt, &str fail_str)\n    -> result {\n     auto V_fail_str = C_cstr(cx.fcx.lcx.ccx, fail_str);\n@@ -6607,7 +6607,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     // order, so that they match the expected stack layout for the spawnee)\n     //\n     // 3. Fill the tuple with the arguments we evaluated.\n-    // \n+    //\n     // 3.5. Generate a wrapper function that takes the tuple and unpacks it to\n     // call the real task.\n     //\n@@ -6648,12 +6648,12 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     auto llargs = alloc_ty(bcx, args_ty);\n     auto i = 0u;\n     for (ValueRef v in arg_vals) {\n-        // log_err #fmt(\"ty(llargs) = %s\", \n+        // log_err #fmt(\"ty(llargs) = %s\",\n         //              val_str(bcx.fcx.lcx.ccx.tn, llargs.val));\n \n         auto target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n         // log_err #fmt(\"ty(v) = %s\", val_str(bcx.fcx.lcx.ccx.tn, v));\n-        // log_err #fmt(\"ty(target) = %s\", \n+        // log_err #fmt(\"ty(target) = %s\",\n         //              val_str(bcx.fcx.lcx.ccx.tn, target));\n \n         bcx.build.Store(v, target);\n@@ -6728,8 +6728,8 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n // tasks, and for sending things through channels. There are probably some\n // uniqueness optimizations and things we can do here for tasks in the same\n // domain.\n-fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task) \n-    -> result \n+fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n+    -> result\n {\n     // TODO: make sure all paths add any reference counting that they need to.\n \n@@ -6747,17 +6747,17 @@ fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n     else if(ty::type_is_chan(tcx, t)) {\n         // If this is a channel, we need to clone it.\n         auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n-      \n-        auto chan_raw_val = \n+\n+        auto chan_raw_val =\n             bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n                            ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n \n         // Cast back to the type the context was expecting.\n-        auto chan_val = bcx.build.PointerCast(chan_raw_val, \n+        auto chan_val = bcx.build.PointerCast(chan_raw_val,\n                                               val_ty(v));\n \n         ret rslt(bcx, chan_val);\n-    } \n+    }\n     else if(ty::type_is_structural(tcx, t)) {\n         fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n             log_err \"Unimplemented type for deep_copy.\";\n@@ -6865,7 +6865,7 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n // function and putting it in the generated code as an object item, we are\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n-fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n+fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n                   &ast::ty_param[] ty_params, ast::node_id id) -> result {\n \n     // Right now, we're assuming that anon objs don't take ty params, even\n@@ -6903,20 +6903,20 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n     // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n     // so we need to roll our own.\n-    fn anon_obj_field_to_obj_field(&ast::anon_obj_field f) \n+    fn anon_obj_field_to_obj_field(&ast::anon_obj_field f)\n         -> ast::obj_field {\n         ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n     }\n     let ast::_obj wrapper_obj = rec(\n-        fields = std::ivec::map(anon_obj_field_to_obj_field, \n+        fields = std::ivec::map(anon_obj_field_to_obj_field,\n                                 additional_fields),\n         methods = anon_obj.methods,\n         dtor = none[@ast::method]);\n \n     let ty::t with_obj_ty;\n     auto vtbl;\n     alt (anon_obj.with_obj) {\n-        case (none) { \n+        case (none) {\n             // If there's no with_obj -- that is, if we're just adding new\n             // fields rather than extending an existing object -- then we just\n             // pass the outer object to create_vtbl().  Our vtable won't need\n@@ -6949,16 +6949,16 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // create a forwarding slot.  And, of course, we need to create a\n             // normal vtable entry for every method being added.\n             vtbl = create_vtbl(bcx.fcx.lcx, sp, llouter_obj_ty, outer_obj_ty,\n-                               wrapper_obj, ty_params, \n+                               wrapper_obj, ty_params,\n                                some(with_obj_ty),\n                                additional_field_tys);\n         }\n     }\n-    \n+\n     // Allocate the object that we're going to return.  It's a two-word pair\n     // containing a vtable pointer and a body pointer.\n-    auto pair = \n-        alloca(bcx, \n+    auto pair =\n+        alloca(bcx,\n                T_struct(~[val_ty(vtbl),\n                           T_obj_ptr(ccx.tn, std::ivec::len(ty_params))]));\n \n@@ -7003,7 +7003,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         // Synthesize a tuple type for typarams: [typaram, ...]\n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n \n-        // Tuple type for body: \n+        // Tuple type for body:\n         // [tydesc_ty, [typaram, ...], [field, ...], with_obj]\n         let ty::t body_ty =\n             ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty,\n@@ -7068,7 +7068,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             auto capture =\n                 GEP_tup_like(bcx, typarams_ty, body_typarams.val, ~[0, i]);\n             bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram, \n+            bcx = copy_val(bcx, INIT, capture.val, typaram,\n                            tydesc_ty).bcx;\n             i += 1;\n         }\n@@ -7091,7 +7091,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n                 GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n             bcx = field.bcx;\n             bcx = copy_val(bcx, INIT, field.val,\n-                           additional_field_vals.(i).val, \n+                           additional_field_vals.(i).val,\n                            additional_field_tys.(i)).bcx;\n             i += 1;\n         }\n@@ -7258,7 +7258,7 @@ fn new_raw_block_ctxt(&@fn_ctxt fcx, BasicBlockRef llbb) -> @block_ctxt {\n \n \n // trans_block_cleanups: Go through all the cleanups attached to this\n-// block_ctxt and execute them.  \n+// block_ctxt and execute them.\n //\n // When translating a block that introdces new variables during its scope, we\n // need to make sure those variables go out of scope when the block ends.  We\n@@ -7685,7 +7685,7 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n     // Set up arguments to the function.\n     auto fcx = new_fn_ctxt(cx, sp, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto, ty_self,\n-                              ty::ret_ty_of_fn(cx.ccx.tcx, id), \n+                              ty::ret_ty_of_fn(cx.ccx.tcx, id),\n                               f.decl.inputs, ty_params);\n     copy_any_self_to_alloca(fcx, ty_self);\n     alt ({ fcx.llself }) {\n@@ -7782,13 +7782,13 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n     // method's return type, if necessary.\n     auto llretptr = fcx.llretptr;\n     if (ty::type_has_dynamic_size(cx.ccx.tcx, m.output)) {\n-        llretptr = bcx.build.PointerCast(llretptr, \n+        llretptr = bcx.build.PointerCast(llretptr,\n                                          T_typaram_ptr(cx.ccx.tn));\n     }\n \n     // Now, we have to get the the with_obj's vtbl out of the self_obj.  This\n     // is a multi-step process:\n-    \n+\n     // First, grab the box out of the self_obj.  It contains a refcount and a\n     // body.\n     auto llself_obj_box =\n@@ -7821,7 +7821,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n     // Synthesize a tuple type for typarams: [typaram, ...]\n     let ty::t typarams_ty = ty::mk_imm_tup(cx.ccx.tcx, tps);\n \n-    // Tuple type for body: \n+    // Tuple type for body:\n     // [tydesc_ty, [typaram, ...], [field, ...], with_obj]\n     let ty::t body_ty =\n         ty::mk_imm_tup(cx.ccx.tcx, ~[tydesc_ty, typarams_ty,\n@@ -7864,7 +7864,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n \n     // Pick out the original method from the vtable.  The +1 is because slot\n     // #0 contains the destructor.\n-    auto llorig_mthd = bcx.build.GEP(llwith_obj_vtbl, \n+    auto llorig_mthd = bcx.build.GEP(llwith_obj_vtbl,\n                                      ~[C_int(0), C_int(ix + 1u as int)]);\n \n     // Set up the original method to be called.\n@@ -7876,7 +7876,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n                         m.inputs,\n                         m.output,\n                         std::ivec::len[ast::ty_param](ty_params));\n-    llorig_mthd = bcx.build.PointerCast(llorig_mthd, \n+    llorig_mthd = bcx.build.PointerCast(llorig_mthd,\n                                         T_ptr(T_ptr(llorig_mthd_ty)));\n     llorig_mthd = bcx.build.Load(llorig_mthd);\n \n@@ -7886,13 +7886,13 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llorig_mthd_args.\n-    \n+\n     let uint a = 3u; // retptr, task ptr, env come first\n     let ValueRef passed_arg = llvm::LLVMGetParam(llforwarding_fn, a);\n     for (ty::arg arg in m.inputs) {\n         if (arg.mode == ty::mo_val) {\n             passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n-        } \n+        }\n         llorig_mthd_args += ~[passed_arg];\n         a += 1u;\n     }\n@@ -7908,16 +7908,16 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n \n // process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n // function for create_vtbl.\n-fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty, \n-                       ty::t self_ty, &ast::ty_param[] ty_params) \n+fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n+                       ty::t self_ty, &ast::ty_param[] ty_params)\n     -> ValueRef {\n \n     auto llfnty = T_nil();\n     alt (ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id))){\n         case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             llfnty =\n                 type_of_fn_full(\n-                    cx.ccx, m.span, proto, \n+                    cx.ccx, m.span, proto,\n                     some[TypeRef](llself_ty), inputs, output,\n                     std::ivec::len[ast::ty_param](ty_params));\n         }\n@@ -7927,14 +7927,14 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n     let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n     let ValueRef llfn =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n- \n+\n     // Every method on an object gets its node_id inserted into the\n     // crate-wide item_ids map, together with the ValueRef that points to\n     // where that method's definition will be in the executable.\n     cx.ccx.item_ids.insert(m.node.id, llfn);\n     cx.ccx.item_symbols.insert(m.node.id, s);\n     trans_fn(mcx, m.span, m.node.meth, llfn,\n-             some[ty_self_pair](tup(llself_ty, self_ty)), \n+             some[ty_self_pair](tup(llself_ty, self_ty)),\n              ty_params, m.node.id);\n \n     ret llfn;\n@@ -7996,7 +7996,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n                 case (ty::ty_obj(?with_obj_methods)) {\n                     for (ty::method m in with_obj_methods) {\n                         meths += ~[fwding_mthd(@m)];\n-                    } \n+                    }\n                 }\n                 case (_) {\n                     // Shouldn't happen.\n@@ -8008,7 +8008,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n             // Now, filter out any methods that we don't need forwarding slots\n             // for, because they're being replaced.\n             fn filtering_fn(@local_ctxt cx, &vtbl_mthd m,\n-                            (@ast::method)[] addtl_meths) \n+                            (@ast::method)[] addtl_meths)\n                 -> option::t[vtbl_mthd] {\n \n                 alt (m) {\n@@ -8040,15 +8040,15 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n             }\n             auto f = bind filtering_fn(cx, _, ob.methods);\n             meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n-            \n+\n             // And now add the additional ones (both replacements and entirely\n             // new ones).  These'll just be normal methods.\n             for (@ast::method m in ob.methods) {\n                 meths += ~[normal_mthd(m)];\n             }\n         }\n-    } \n-    \n+    }\n+\n     // Sort all the methods.\n     fn vtbl_mthd_lteq(&vtbl_mthd a, &vtbl_mthd b) -> bool {\n         alt (a) {\n@@ -8107,7 +8107,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n             }\n         }\n     }\n-    \n+\n     auto vtbl = C_struct(llmethods);\n     auto vtbl_name = mangle_internal_name_by_path(cx.ccx,\n                                                   cx.path + ~[\"vtbl\"]);\n@@ -8197,7 +8197,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n-    auto vtbl = create_vtbl(cx, sp, llself_ty, self_ty, ob, ty_params, none, \n+    auto vtbl = create_vtbl(cx, sp, llself_ty, self_ty, ob, ty_params, none,\n                             ~[]);\n \n     bcx.build.Store(vtbl, pair_vtbl);\n@@ -8344,7 +8344,7 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n     auto llctor_decl;\n     alt (cx.ccx.item_ids.find(ctor_id)) {\n         case (some(?x)) { llctor_decl = x; }\n-        case (_) { \n+        case (_) {\n             cx.ccx.sess.span_fatal(sp, \"unbound ctor_id in trans_res_ctor\");\n         }\n     }"}, {"sha": "c5fded689b69db50fbc428e1a7a9fbf46cabb648", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -180,7 +180,7 @@ fn get_options(&@crate_ctxt ccx, &match m, uint col) -> opt[] {\n     for (match_branch br in m) {\n         alt (br.pats.(col).node) {\n             ast::pat_lit(?l) { add_to_set(found, lit(l)); }\n-            ast::pat_tag(_, _) { \n+            ast::pat_tag(_, _) {\n                 add_to_set(found, variant_opt(ccx, br.pats.(col).id));\n             }\n             _ {}\n@@ -323,7 +323,7 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n                 }\n             }\n             lit(?l) {\n-                test_val = bcx.build.Load(val); \n+                test_val = bcx.build.Load(val);\n                 kind = alt (l.node) {\n                     ast::lit_str(_, _) { compare }\n                     _ { switch }\n@@ -386,7 +386,7 @@ fn make_phi_bindings(&@block_ctxt bcx, &exit_node[] map,\n         }\n         fail;\n     }\n-    \n+\n     auto our_block = bcx.llbb as uint;\n     for each (@tup(ast::ident, ast::node_id) item in ids.items()) {\n         auto llbbs = ~[];"}, {"sha": "6a46603c869cff95b7ac28ee45813af1de3b308c", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -3,7 +3,7 @@ import tritv::*;\n \n type precond = t;\n \n-/* 2 means \"this constraint may or may not be true after execution\" \n+/* 2 means \"this constraint may or may not be true after execution\"\n    1 means \"this constraint is definitely true after execution\"\n    0 means \"this constraint is definitely false after execution\" */\n type postcond = t;\n@@ -23,7 +23,7 @@ type poststate = t;\n   0 means \"don't know whether this variable is\n   initialized\" */\n \n-/* \n+/*\n    This says: this expression requires the constraints whose value is 1 in\n    <pre> to be true, and given the precondition, it guarantees that the\n    constraints in <post> whose values are 1 are true, and that the constraints"}, {"sha": "6df2f3ff01615d257c4ab60201c8263606c6e3c7", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -93,7 +93,7 @@ fn tritv_to_str(fn_ctxt fcx, &tritv::t v) -> str {\n             case (?t) {\n                 s +=\n                     if (comma) { \", \" } else { comma = true; \"\" } +\n-                    if (t == tfalse) { \"!\" } else { \"\" } +                  \n+                    if (t == tfalse) { \"!\" } else { \"\" } +\n                     constraint_to_str(fcx.ccx.tcx, p.c);\n             }\n         }\n@@ -119,7 +119,7 @@ fn log_tritv_err(fn_ctxt fcx, tritv::t v) { log_err tritv_to_str(fcx, v); }\n \n fn tos(&uint[] v) -> str {\n     auto rslt = \"\";\n-    for (uint i in v) { if (i == 0u) { rslt += \"0\"; } \n+    for (uint i in v) { if (i == 0u) { rslt += \"0\"; }\n         else if (i == 1u) { rslt += \"1\"; }\n         else { rslt += \"?\"; } }\n     ret rslt;\n@@ -190,7 +190,7 @@ once.\n norm_constraint, in contrast, gets used when handling an instance\n of a constraint rather than a definition of a constraint. It can\n also be init or pred (ninit or npred), but the npred case just has\n-a single argument list. \n+a single argument list.\n \n The representation of constraints, where multiple instances of the\n same predicate are collapsed into one entry in the table, makes it\n@@ -209,7 +209,7 @@ type pred_desc_ = rec((@constr_arg_use)[] args, uint bit_num);\n type pred_desc = spanned[pred_desc_];\n \n // FIXME: Should be node_id, since we can only talk\n-// about locals. \n+// about locals.\n type constr_arg_use = constr_arg_general[tup(ident, def_id)];\n \n tag constraint {\n@@ -559,7 +559,7 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n                 case (_) {\n                     tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n                                  \"as pred arg\");\n-                        \n+\n                 }\n             }\n         }\n@@ -694,7 +694,7 @@ type subst = tup(inst, inst)[];\n \n fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n         -> (tup(uint, uint))[] {\n-   \n+\n     let (tup(uint, uint))[] rslt = ~[];\n     if (ivec::len(subst) == 0u) {\n         ret rslt;\n@@ -765,7 +765,7 @@ fn replace(subst subst, pred_desc d) -> (constr_arg_general_[inst])[] {\n             }\n          }\n     }\n-    \n+\n     /*\n     for (constr_arg_general_[tup(ident, def_id)] p in rslt) {\n         alt (p) {\n@@ -787,12 +787,12 @@ fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n     }\n }\n \n-tag if_ty { \n+tag if_ty {\n     if_check;\n     plain_if;\n }\n \n-fn local_node_id_to_def_id_strict(&fn_ctxt fcx, &span sp, &node_id i) \n+fn local_node_id_to_def_id_strict(&fn_ctxt fcx, &span sp, &node_id i)\n     -> def_id {\n     alt (local_node_id_to_def(fcx, i)) {\n         case (some(def_local(?d_id))) {\n@@ -819,7 +819,7 @@ fn local_node_id_to_def(&fn_ctxt fcx, &node_id i) -> option::t[def]\n fn local_node_id_to_def_id(&fn_ctxt fcx, &node_id i) -> option::t[def_id] {\n     alt (local_node_id_to_def(fcx, i)) {\n         case (some(def_local(?d_id))) { some(d_id) }\n-        case (some (def_arg(?a_id)))  { some(a_id) } \n+        case (some (def_arg(?a_id)))  { some(a_id) }\n         case (_)                      { none }\n     }\n }\n@@ -865,7 +865,7 @@ fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n         // dest def_id\n         auto instances = find_instances(fcx, subst, p._1);\n \n-        for (tup(uint,uint) p in instances) { \n+        for (tup(uint,uint) p in instances) {\n             if (promises_(p._0, src_post)) {\n                 set_in_poststate_(p._1, target_post);\n             }"}, {"sha": "d0d4f9bde8fcdcac9213a01097e8e837e139d354", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -138,7 +138,7 @@ fn seq_preconds(&fn_ctxt fcx, &pre_and_post[] pps) -> precond {\n             auto next_first = clone(first.precondition);\n             union(next_first, second_pre);\n             auto next_first_post = clone(first.postcondition);\n-            seq_tritv(next_first_post, second.postcondition); \n+            seq_tritv(next_first_post, second.postcondition);\n             ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz),\n                                 @rec(precondition=next_first,\n                                      postcondition=next_first_post));\n@@ -189,7 +189,7 @@ fn relax_precond_stmt(&fn_ctxt fcx, node_id i, &@stmt s) {\n fn relax_precond_block(&fn_ctxt fcx, node_id i, &block b) {\n     relax_precond_block_non_recursive(fcx, i, b);\n     // FIXME: should use visit instead\n-    // could at least generalize this pattern \n+    // could at least generalize this pattern\n     // (also seen in ck::check_states_against_conditions)\n     let @mutable bool keepgoing = @mutable true;\n \n@@ -238,7 +238,7 @@ fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n                                                             c=ninit(i))), t);\n                         }\n                         case (some(_)) { /* ignore args (for now...) */ }\n-                        case (_) { \n+                        case (_) {\n                             fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n                                    unbound var\"); }\n                         }"}, {"sha": "84e5232a34998818fd083115f6a45985e0d0acca", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -187,7 +187,7 @@ fn fn_states(&_fn f, &ast::ty_param[] tps,\n              &visit::vt[crate_ctxt] v) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */\n-    \n+\n     assert (ccx.fm.contains_key(id));\n     auto f_info = ccx.fm.get(id);\n     auto name = option::from_maybe(\"anon\", i);"}, {"sha": "fb2d342f9226dda204cefd74cb6607f1afcf488e", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -47,7 +47,7 @@ fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n     // visit subexpressions\n     visit::visit_expr(e, cx, v);\n }\n- \n+\n fn find_locals(&ty::ctxt tcx, &_fn f, &ty_param[] tps, &span sp, &fn_ident i,\n                node_id id) -> ctxt {\n     let ctxt cx = rec(cs=@mutable ~[], tcx=tcx);"}, {"sha": "14067f7d01bdd954b4b17bf0e06dca3bad52f375", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -112,7 +112,7 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n \n /* Finds the pre and postcondition for each expr in <args>;\n    sets the precondition in a to be the result of combining\n-   the preconditions for <args>, and the postcondition in a to \n+   the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(&fn_ctxt fcx, &(@expr)[] args, node_id id) {\n     if (ivec::len[@expr](args) > 0u) {\n@@ -137,7 +137,7 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n     find_pre_post_block(fcx, body);\n     auto v_init = rec(id=l.node.id, c=ninit(l.node.ident));\n     relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n-    \n+\n     // Hack: for-loop index variables are frequently ignored,\n     // so we pretend they're used\n     use_var(fcx, l.node.id);\n@@ -149,7 +149,7 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n     copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n }\n \n-// Generates a pre/post assuming that a is the \n+// Generates a pre/post assuming that a is the\n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n@@ -236,7 +236,7 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n         case (expr_path(?p)) {\n             auto post = expr_postcond(fcx.ccx, parent);\n             auto tmp = tritv_clone(post);\n-            \n+\n             alt (ty) {\n                 case (oper_move) {\n                     if (is_path(rhs)) {\n@@ -255,7 +255,7 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n                     auto df = node_id_to_def_strict(fcx.ccx.tcx, lhs.id);\n                     alt (df) {\n                         case (def_local(?d_id)) {\n-                            auto i = \n+                            auto i =\n                                 bit_num(fcx,\n                                  rec(id=d_id._1,\n                                      c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n@@ -293,7 +293,7 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n                 case (_) { /* do nothing */ }\n             }\n         }\n-        case (_) { \n+        case (_) {\n             find_pre_post_expr(fcx, lhs);\n         }\n     }\n@@ -597,7 +597,7 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                              whether or not this is a move */\n \n                             find_pre_post_expr(fcx, an_init.expr);\n-                            copy_pre_post(fcx.ccx, alocal.node.id, \n+                            copy_pre_post(fcx.ccx, alocal.node.id,\n                                           an_init.expr);\n                             /* Inherit ann from initializer, and add var being\n                                initialized to the postcondition */\n@@ -617,7 +617,7 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                             }\n \n                             gen(fcx, id,\n-                                rec(id=alocal.node.id, \n+                                rec(id=alocal.node.id,\n                                     c=ninit(alocal.node.ident)));\n \n                             if (an_init.op == init_move &&\n@@ -650,7 +650,7 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     /* Want to say that if there is a break or cont in this\n      block, then that invalidates the poststate upheld by\n-    any of the stmts after it. \n+    any of the stmts after it.\n     Given that the typechecker has run, we know any break will be in\n     a block that forms a loop body. So that's ok. There'll never be an\n     expr_break outside a loop body, therefore, no expr_break outside a block.\n@@ -661,7 +661,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n      This will mean that:\n      x = 0;\n      break;\n-    \n+\n      won't have a postcondition that says x is initialized, but that's ok.\n      */\n "}, {"sha": "b8cee2c67159ea09bc1c095ceee6621016546489", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -98,7 +98,7 @@ fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr lhs,\n             // tmp remembers \"old\" constraints we'd otherwise forget,\n             // for substitution purposes\n             auto tmp = tritv_clone(post);\n-            \n+\n             alt (ty) {\n                 case (oper_move) {\n                     if (is_path(rhs)) {\n@@ -166,7 +166,7 @@ fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, node_id id,\n             changed |= set_poststate_ann\n                 (fcx.ccx, id, false_postcond(num_constraints(fcx.enclosing)));\n         }\n-        case (_) { \n+        case (_) {\n             changed |= set_poststate_ann(fcx.ccx, id, rs._1);\n         }\n     }\n@@ -188,7 +188,7 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n \n     changed |= find_pre_post_state_block(fcx, index_post, body);\n \n-    if (has_nonlocal_exits(body)) { \n+    if (has_nonlocal_exits(body)) {\n         // See [Break-unsound]\n         ret (changed | set_poststate_ann(fcx.ccx, id, pres));\n     }\n@@ -201,7 +201,7 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n \n fn gen_if_local(&fn_ctxt fcx, &poststate p, &@expr e) -> bool {\n     alt (e.node) {\n-        case (expr_path(?pth)) { \n+        case (expr_path(?pth)) {\n             alt (node_id_to_def(fcx.ccx, e.id)) {\n                 case (some(def_local(?loc))) {\n                     ret set_in_poststate_ident(fcx, loc._1,\n@@ -219,7 +219,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                   &prestate pres) -> bool {\n     auto changed = set_prestate_ann(fcx.ccx, id, pres) |\n         find_pre_post_state_expr(fcx, pres, antec);\n-    \n+\n     /*\n     log_err(\"join_then_else:\");\n     log_expr_err(*antec);\n@@ -259,7 +259,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n \n             changed |=\n                 find_pre_post_state_block(fcx, conseq_prestate, conseq);\n-   \n+\n             auto poststate_res =\n                 intersect_states(block_poststate(fcx.ccx, conseq),\n                                     expr_poststate(fcx.ccx, altern));\n@@ -271,7 +271,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 aux::tritv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n             fcx.ccx.tcx.sess.span_note(antec.span,\n             \"conseq poststate = \" + aux::tritv_to_str(fcx,\n-               block_poststate(fcx.ccx, conseq))); \n+               block_poststate(fcx.ccx, conseq)));\n             */\n \n             changed |= set_poststate_ann(fcx.ccx, id, poststate_res);\n@@ -373,7 +373,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                 (fcx, expr_poststate(fcx.ccx, lhs), rhs);\n             auto post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n             forget_in_poststate_still_init(fcx, post, rhs.id);\n-            gen_if_local(fcx, post, rhs); \n+            gen_if_local(fcx, post, rhs);\n             ret changed | set_poststate_ann(fcx.ccx, e.id, post);\n         }\n         case (expr_ret(?maybe_ret_val)) {\n@@ -452,7 +452,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             /* conservative approximation: if a loop contains a break\n                or cont, we assume nothing about the poststate */\n             /* which is still unsound -- see [Break-unsound] */\n-            if (has_nonlocal_exits(body)) { \n+            if (has_nonlocal_exits(body)) {\n                 ret changed | set_poststate_ann(fcx.ccx, e.id, pres);\n             }\n             else {\n@@ -580,7 +580,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n     auto stmt_ann = stmt_to_ann(fcx.ccx, *s);\n \n-    /*    \n+    /*\n     log_err \"*At beginning: stmt = \";\n     log_stmt_err(*s);\n     log_err \"*prestate = \";\n@@ -613,7 +613,7 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                                                           an_init.expr.id);\n                                     alt (rhs_d) {\n                                         case (some(?rhsid)) {\n-                                            auto instrhs = \n+                                            auto instrhs =\n                                                 tup(path_to_ident(fcx.ccx.tcx,\n                                                                   p), rhsid);\n                                             copy_in_poststate(fcx, post,"}, {"sha": "26ae3f491695083f692aa8672f9bd8a589bcd7c1", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -19,7 +19,7 @@ export tritv_clear;\n export tritv_doesntcare;\n export to_str;\n \n-/* for a fixed index: \n+/* for a fixed index:\n    10 = \"this constraint may or may not be true after execution\"\n    01 = \"this constraint is definitely true\"\n    00 = \"this constraint is definitely false\"\n@@ -165,7 +165,7 @@ fn tritv_get(&t v, uint i) -> trit {\n   else if (b2) { ttrue }\n   else         { tfalse}\n }\n- \n+\n fn tritv_set(uint i, &t v, trit t) -> bool {\n   auto old = tritv_get(v, i);\n   alt (t) {"}, {"sha": "b9e1f7aa669a5789f5c267b71681e592dad5b9d8", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -2328,7 +2328,7 @@ mod unify {\n                     }\n                     case (_) { ret ures_err(terr_mismatch); }\n                 }\n-            }       \n+            }\n             case (ty::ty_param(_)) { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_tag(?expected_id, ?expected_tps)) {\n                 alt (struct(cx.tcx, actual)) {"}, {"sha": "29acb7d9e53cfb1bc224846174db74c3330f5e42", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -95,7 +95,7 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n     alt (defn) {\n         case (ast::def_arg(?id)) {\n             assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, \n+            auto typ = ty::mk_var(fcx.ccx.tcx,\n                                   lookup_local(fcx, sp, id._1));\n             ret tup(0u, typ);\n         }\n@@ -1616,7 +1616,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         check_expr(fcx, e);\n         demand::simple(fcx, e.span, ty::mk_bool(fcx.ccx.tcx),\n                        expr_ty(fcx.ccx.tcx, e));\n-        \n+\n         /* e must be a call expr where all arguments are either\n            literals or slots */\n             alt (e.node) {\n@@ -1625,7 +1625,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         case (ast::expr_path(?oper_name)) {\n                             alt (fcx.ccx.tcx.def_map.find(operator.id)) {\n                                 case (some(ast::def_fn(?_d_id,\n-                                                       ast::pure_fn))) { \n+                                                       ast::pure_fn))) {\n                                     // do nothing\n                                 }\n                                 case (_) {\n@@ -1678,7 +1678,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         write::ty_only_fixup(fcx, id, if_t);\n     }\n \n-    // Checks the compatibility \n+    // Checks the compatibility\n     fn check_binop_type_compat(&@fn_ctxt fcx, span span,\n                                ty::t ty, ast::binop binop) {\n         auto resolved_t = resolve_type_vars_if_possible(fcx, ty);\n@@ -1745,7 +1745,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         case (ty::ty_ptr(?inner)) { oper_t = inner.ty; }\n                         case (_) {\n                             fcx.ccx.tcx.sess.span_fatal\n-                                (expr.span, \"dereferencing non-\" + \n+                                (expr.span, \"dereferencing non-\" +\n                                  \"dereferenceable type: \" +\n                                  ty_to_str(fcx.ccx.tcx, oper_t));\n                         }\n@@ -2191,7 +2191,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             alt (base) {\n                 case (none) {\n                     fn get_node(&spanned[field] f) -> field { f.node }\n-                    auto typ = ty::mk_rec(fcx.ccx.tcx, \n+                    auto typ = ty::mk_rec(fcx.ccx.tcx,\n                                           ivec::map(get_node, fields_t));\n                     write::ty_only_fixup(fcx, id, typ);\n                 }\n@@ -2313,8 +2313,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto t = next_ty_var(fcx);\n             alt(typ) {\n                 case (some(?_t)) {\n-                    demand::simple(fcx, expr.span, \n-                                   ast_ty_to_ty_crate(fcx.ccx, _t), \n+                    demand::simple(fcx, expr.span,\n+                                   ast_ty_to_ty_crate(fcx.ccx, _t),\n                                    t);\n                 }\n                 case (none) {}\n@@ -2352,7 +2352,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             // FIXME: this is duplicated between here and trans -- it should\n             // appear in one place\n-            fn anon_obj_field_to_obj_field(&ast::anon_obj_field f) \n+            fn anon_obj_field_to_obj_field(&ast::anon_obj_field f)\n                 -> ast::obj_field {\n                 ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n             }\n@@ -2417,7 +2417,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                 // The user is trying to extend a non-object.\n                                 fcx.ccx.tcx.sess.span_fatal(\n                                     e.span,\n-                                    syntax::print::pprust::expr_to_str(e) + \n+                                    syntax::print::pprust::expr_to_str(e) +\n                                     \" does not have object type\");\n                             }\n                         }"}, {"sha": "fd5a308cbb8f07707815f7f48ff0eddb5435da02", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -620,7 +620,7 @@ fn is_exported(ident i, _mod m) -> bool {\n             case (_) {/* fall through */ }\n         }\n     }\n-    // If there are no declared exports then \n+    // If there are no declared exports then\n     // everything not imported is exported\n \n     ret count == 0u && !nonlocal;"}, {"sha": "25a4110bd7d53e2d0cbad55eac5b6c9064de6b14", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -6,7 +6,7 @@ import codemap::span;\n import std::map::new_str_hash;\n import codemap;\n \n-type syntax_expander = \n+type syntax_expander =\n     fn(&ext_ctxt, span, &(@ast::expr)[], option::t[str]) -> @ast::expr;\n type macro_definer = fn(&ext_ctxt, span, &(@ast::expr)[],\n                         option::t[str]) -> tup(str, syntax_extension);\n@@ -22,7 +22,7 @@ fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n     auto syntax_expanders = new_str_hash[syntax_extension]();\n     syntax_expanders.insert(\"fmt\", normal(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\"env\", normal(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(\"macro\",    \n+    syntax_expanders.insert(\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));\n     ret syntax_expanders;\n }\n@@ -85,7 +85,7 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr, str error) -> str {\n fn expr_to_ident(&ext_ctxt cx, @ast::expr expr, str error) -> ast::ident {\n     alt(expr.node) {\n         case (ast::expr_path(?p)) {\n-            if (ivec::len(p.node.types) > 0u \n+            if (ivec::len(p.node.types) > 0u\n                     || ivec::len(p.node.idents) != 1u) {\n                 cx.span_fatal(expr.span, error);\n             } else {"}, {"sha": "cb93a4bf45c23f306b3178244e622a3add088afe", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -13,8 +13,8 @@ import std::option::some;\n import std::map::hashmap;\n import std::ivec;\n \n-fn expand_expr(&hashmap[str, base::syntax_extension] exts, \n-               &session::session sess, &expr_ e, ast_fold fld, \n+fn expand_expr(&hashmap[str, base::syntax_extension] exts,\n+               &session::session sess, &expr_ e, ast_fold fld,\n                &fn(&ast::expr_, ast_fold) -> expr_ orig) -> expr_ {\n     ret alt(e) {\n         case (expr_mac(?mac)) {\n@@ -25,18 +25,18 @@ fn expand_expr(&hashmap[str, base::syntax_extension] exts,\n                     auto ext_cx = base::mk_ctxt(sess);\n                     alt (exts.find(extname)) {\n                         case (none) {\n-                            emit_error(some(pth.span), \n+                            emit_error(some(pth.span),\n                                        \"unknown syntax expander: '\"\n                                        + extname + \"'\", sess.get_codemap());\n                             fail\n                         }\n                         case (some(base::normal(?ext))) {\n                             //keep going, outside-in\n-                            fld.fold_expr(ext(ext_cx, pth.span, \n+                            fld.fold_expr(ext(ext_cx, pth.span,\n                                               args, body)).node\n                         }\n                         case (some(base::macro_defining(?ext))) {\n-                            auto named_extension \n+                            auto named_extension\n                                 = ext(ext_cx, pth.span, args, body);\n                             exts.insert(named_extension._0,\n                                         named_extension._1);\n@@ -65,7 +65,7 @@ fn expand_crate(&session::session sess, &@crate c) -> @crate {\n     auto res = @f.fold_crate(*c);\n     dummy_out(f); //temporary: kill circular reference\n     ret res;\n-    \n+\n }\n \n // Local Variables:"}, {"sha": "09c2ebc508b02ab5d02a834d2b041cae3f4c3f34", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -61,8 +61,8 @@ fn subst_path(&ext_ctxt cx, &(invk_binding)[] ibs, &path_ p, ast_fold fld)\n     // Don't substitute into qualified names.\n     if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n     ret alt (lookup(ibs, p.idents.(0))) {\n-        case (some(ident_binding(_, ?id))) { \n-            rec(global=false, idents=~[id.node], types=~[]) \n+        case (some(ident_binding(_, ?id))) {\n+            rec(global=false, idents=~[id.node], types=~[])\n         }\n         case (some(path_binding(_, ?a_pth))) { a_pth.node }\n         case (some(expr_binding(_, ?expr))) {\n@@ -74,18 +74,18 @@ fn subst_path(&ext_ctxt cx, &(invk_binding)[] ibs, &path_ p, ast_fold fld)\n }\n \n \n-fn subst_expr(&ext_ctxt cx, &(invk_binding)[] ibs, &ast::expr_ e, \n-              ast_fold fld, fn(&ast::expr_, ast_fold) -> ast::expr_ orig) \n+fn subst_expr(&ext_ctxt cx, &(invk_binding)[] ibs, &ast::expr_ e,\n+              ast_fold fld, fn(&ast::expr_, ast_fold) -> ast::expr_ orig)\n     -> ast::expr_ {\n     ret alt(e) {\n         case (expr_path(?p)){\n             // Don't substitute into qualified names.\n-            if (ivec::len(p.node.types) > 0u || \n+            if (ivec::len(p.node.types) > 0u ||\n                 ivec::len(p.node.idents) != 1u) { e }\n             alt (lookup(ibs, p.node.idents.(0))) {\n-                case (some(ident_binding(_, ?id))) { \n-                    expr_path(respan(id.span, \n-                                     rec(global=false, \n+                case (some(ident_binding(_, ?id))) {\n+                    expr_path(respan(id.span,\n+                                     rec(global=false,\n                                          idents=~[id.node],types=~[])))\n                 }\n                 case (some(path_binding(_, ?a_pth))) { expr_path(*a_pth) }\n@@ -107,15 +107,15 @@ tag invk_binding {\n }\n \n fn path_to_ident(&path pth) -> option::t[ident] {\n-    if (ivec::len(pth.node.idents) == 1u \n+    if (ivec::len(pth.node.idents) == 1u\n         && ivec::len(pth.node.types) == 0u) {\n         ret some(pth.node.idents.(0u));\n     }\n     ret none;\n }\n \n fn process_clause(&ext_ctxt cx, &mutable vec[pat_ext] pes,\n-                  &mutable option::t[str] macro_name, &path pth, \n+                  &mutable option::t[str] macro_name, &path pth,\n                   &(@ast::expr)[] invoc_args, @ast::expr body) {\n     let str clause_name = alt(path_to_ident(pth)) {\n         case (some(?id)) { id }\n@@ -139,10 +139,10 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n     for (@ast::expr arg in args) {\n         alt(arg.node) {\n             case(expr_vec(?elts, ?mut, ?seq_kind)) {\n-                \n+\n                 if (ivec::len(elts) != 2u) {\n-                    cx.span_fatal((*arg).span, \n-                                  \"extension clause must consist of [\" + \n+                    cx.span_fatal((*arg).span,\n+                                  \"extension clause must consist of [\" +\n                                   \"macro invocation, expansion body]\");\n                 }\n                 alt(elts.(0u).node) {\n@@ -168,10 +168,10 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n     }\n \n     auto ext = bind generic_extension(_,_,_,_,@pat_exts);\n-    \n+\n     ret tup(alt (macro_name) {\n                 case (some(?id)) { id }\n-                case (none) { \n+                case (none) {\n                     cx.span_fatal(sp, \"macro definition must have \"\n                                   + \"at least one clause\")\n                 }\n@@ -192,7 +192,7 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                 case (expr_vec(?p_elts, _, _)) {\n                     alt (arg) {\n                         case (expr_vec(?a_elts, _, _)) {\n-                            if (ivec::len(p_elts) != ivec::len(a_elts)) { \n+                            if (ivec::len(p_elts) != ivec::len(a_elts)) {\n                                 none[vec[invk_binding]]\n                             }\n                             let uint i = 0u;\n@@ -218,12 +218,12 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                                     alt (path_to_ident(a_pth)) {\n                                         case (some(?a_id)) {\n                                             some(~[ident_binding\n-                                                   (p_id, \n+                                                   (p_id,\n                                                     respan(argument.span,\n                                                                  a_id))])\n                                         }\n                                         case (none) {\n-                                            some(~[path_binding(p_id, \n+                                            some(~[path_binding(p_id,\n                                                                 @a_pth)])\n                                         }\n                                     }"}, {"sha": "a4921b46bcad140669bbe050d9a25401ae3261b3", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -18,9 +18,9 @@ type ast_fold = @mutable a_f;\n \n // We may eventually want to be able to fold over type parameters, too\n \n-type ast_fold_precursor = \n+type ast_fold_precursor =\n     rec(fn (&crate_ c, ast_fold) -> crate_                fold_crate,\n-        fn (&crate_directive_ cd, ast_fold) -> crate_directive_ \n+        fn (&crate_directive_ cd, ast_fold) -> crate_directive_\n                                                  fold_crate_directive,\n         fn (&view_item_ i, ast_fold) -> view_item_        fold_view_item,\n         fn (&@native_item i, ast_fold) -> @native_item    fold_native_item,\n@@ -72,27 +72,27 @@ type a_f =\n \n //fn nf_dummy[T](&T node) -> T { fail; }\n fn nf_crate_dummy(&crate c) -> crate { fail; }\n-fn nf_crate_directive_dummy(&@crate_directive c) \n+fn nf_crate_directive_dummy(&@crate_directive c)\n     -> @crate_directive { fail; }\n-fn nf_view_item_dummy(&@view_item v) -> @view_item { fail; } \n-fn nf_native_item_dummy(&@native_item n) -> @native_item { fail; } \n-fn nf_item_dummy(&@item i) -> @item { fail; } \n-fn nf_item_underscore_dummy(&item_ i) -> item_ { fail; } \n-fn nf_method_dummy(&@method m) -> @method { fail; } \n-fn nf_block_dummy(&block b) -> block { fail; } \n-fn nf_stmt_dummy(&@stmt s) -> @stmt { fail; } \n-fn nf_arm_dummy(&arm a) -> arm { fail; } \n-fn nf_pat_dummy(&@pat p) -> @pat { fail; } \n-fn nf_decl_dummy(&@decl d) -> @decl { fail; } \n-fn nf_expr_dummy(&@expr e) -> @expr { fail; } \n-fn nf_ty_dummy(&@ty t) -> @ty { fail; } \n-fn nf_constr_dummy(&@constr c) -> @constr { fail; } \n-fn nf_fn_dummy(&_fn f) -> _fn { fail; } \n-fn nf_mod_dummy(&_mod m) -> _mod { fail; } \n-fn nf_native_mod_dummy(&native_mod n) -> native_mod { fail; } \n-fn nf_variant_dummy(&variant v) -> variant { fail; } \n-fn nf_ident_dummy(&ident i) -> ident { fail; } \n-fn nf_path_dummy(&path p) -> path { fail; } \n+fn nf_view_item_dummy(&@view_item v) -> @view_item { fail; }\n+fn nf_native_item_dummy(&@native_item n) -> @native_item { fail; }\n+fn nf_item_dummy(&@item i) -> @item { fail; }\n+fn nf_item_underscore_dummy(&item_ i) -> item_ { fail; }\n+fn nf_method_dummy(&@method m) -> @method { fail; }\n+fn nf_block_dummy(&block b) -> block { fail; }\n+fn nf_stmt_dummy(&@stmt s) -> @stmt { fail; }\n+fn nf_arm_dummy(&arm a) -> arm { fail; }\n+fn nf_pat_dummy(&@pat p) -> @pat { fail; }\n+fn nf_decl_dummy(&@decl d) -> @decl { fail; }\n+fn nf_expr_dummy(&@expr e) -> @expr { fail; }\n+fn nf_ty_dummy(&@ty t) -> @ty { fail; }\n+fn nf_constr_dummy(&@constr c) -> @constr { fail; }\n+fn nf_fn_dummy(&_fn f) -> _fn { fail; }\n+fn nf_mod_dummy(&_mod m) -> _mod { fail; }\n+fn nf_native_mod_dummy(&native_mod n) -> native_mod { fail; }\n+fn nf_variant_dummy(&variant v) -> variant { fail; }\n+fn nf_ident_dummy(&ident i) -> ident { fail; }\n+fn nf_path_dummy(&path p) -> path { fail; }\n fn nf_obj_field_dummy(&obj_field o) -> obj_field { fail; }\n fn nf_local_dummy(&@local o) -> @local { fail; }\n \n@@ -114,26 +114,26 @@ fn fold_meta_item_(&@meta_item mi, ast_fold fld) -> @meta_item {\n              span=mi.span);\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(&attribute at, fn(&@meta_item) -> @meta_item fmi) \n+fn fold_attribute_(&attribute at, fn(&@meta_item) -> @meta_item fmi)\n     -> attribute {\n     ret rec(node=rec(style=at.node.style,\n                      value=*fmi(@at.node.value)),\n             span=at.span);\n }\n //used in noop_fold_native_item and noop_fold_fn\n fn fold_arg_(&arg a, ast_fold fld) -> arg {\n-    ret rec(mode=a.mode, ty=fld.fold_ty(a.ty), \n+    ret rec(mode=a.mode, ty=fld.fold_ty(a.ty),\n             ident=fld.fold_ident(a.ident), id=a.id);\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(&mac m, ast_fold fld) -> mac {\n     ret rec(node=\n             alt(m.node) {\n                 case (mac_invoc(?pth,?args,?body)) {\n-                    mac_invoc(fld.fold_path(pth), \n+                    mac_invoc(fld.fold_path(pth),\n                               ivec::map(fld.fold_expr, args), body)\n                 }\n-                case (mac_embed_type(?ty)) { \n+                case (mac_embed_type(?ty)) {\n                     mac_embed_type(fld.fold_ty(ty))\n                 }\n                 case (mac_embed_block(?block)) {\n@@ -158,17 +158,17 @@ fn noop_fold_crate(&crate_ c, ast_fold fld) -> crate_ {\n             config=ivec::map(fold_meta_item, c.config));\n }\n \n-fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld) \n+fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld)\n     -> crate_directive_ {\n     ret alt(cd) {\n-        case(cdir_src_mod(?id,?fname,?attrs)) { \n+        case(cdir_src_mod(?id,?fname,?attrs)) {\n             cdir_src_mod(fld.fold_ident(id), fname, attrs)\n                 }\n         case(cdir_dir_mod(?id,?fname,?cds,?attrs)) {\n             cdir_dir_mod(fld.fold_ident(id),fname,\n                          ivec::map(fld.fold_crate_directive, cds), attrs)\n                 }\n-        case(cdir_view_item(?vi)) { \n+        case(cdir_view_item(?vi)) {\n             cdir_view_item(fld.fold_view_item(vi))\n                 }\n         case(cdir_syntax(_)) { cd }\n@@ -191,7 +191,7 @@ fn noop_fold_native_item(&@native_item ni, ast_fold fld) -> @native_item {\n              node=alt (ni.node) {\n                  case (native_item_ty) { native_item_ty }\n                  case (native_item_fn(?st, ?fdec, ?typms)) {\n-                     native_item_fn(st, \n+                     native_item_fn(st,\n                                     rec(inputs=ivec::map(fold_arg,\n                                                          fdec.inputs),\n                                         output=fld.fold_ty(fdec.output),\n@@ -217,7 +217,7 @@ fn noop_fold_item(&@item i, ast_fold fld) -> @item {\n \n fn noop_fold_item_underscore(&item_ i, ast_fold fld) -> item_ {\n     fn fold_obj_field_(&obj_field of, ast_fold fld) -> obj_field {\n-        ret rec(mut=of.mut, ty=fld.fold_ty(of.ty), \n+        ret rec(mut=of.mut, ty=fld.fold_ty(of.ty),\n                 ident=fld.fold_ident(of.ident), id=of.id);\n     }\n     auto fold_obj_field = bind fold_obj_field_(_,fld);\n@@ -253,7 +253,7 @@ fn noop_fold_item_underscore(&item_ i, ast_fold fld) -> item_ {\n \n fn noop_fold_method(&method_ m, ast_fold fld) -> method_ {\n     ret rec(ident=fld.fold_ident(m.ident),\n-            meth=fld.fold_fn(m.meth), id=m.id); \n+            meth=fld.fold_fn(m.meth), id=m.id);\n }\n \n \n@@ -319,9 +319,9 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n     }\n     auto fold_field = bind fold_field_(_,fld);\n     fn fold_anon_obj_(&anon_obj ao, ast_fold fld) -> anon_obj {\n-        fn fold_anon_obj_field_(&anon_obj_field aof, ast_fold fld) \n+        fn fold_anon_obj_field_(&anon_obj_field aof, ast_fold fld)\n             -> anon_obj_field {\n-            ret rec(mut=aof.mut, ty=fld.fold_ty(aof.ty), \n+            ret rec(mut=aof.mut, ty=fld.fold_ty(aof.ty),\n                     expr=fld.fold_expr(aof.expr),\n                     ident=fld.fold_ident(aof.ident), id=aof.id);\n         }\n@@ -337,7 +337,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n                 with_obj=option::map(fld.fold_expr, ao.with_obj))\n     }\n     auto fold_anon_obj = bind fold_anon_obj_(_,fld);\n-    \n+\n     auto fold_mac = bind fold_mac_(_,fld);\n \n     ret alt (e) {\n@@ -362,7 +362,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n             expr_bind(fld.fold_expr(f), ivec::map(opt_map_se, args))\n                 }\n         case (expr_spawn(?spawn_dom, ?name, ?f, ?args)) {\n-            expr_spawn(spawn_dom, name, fld.fold_expr(f), \n+            expr_spawn(spawn_dom, name, fld.fold_expr(f),\n                        ivec::map(fld.fold_expr, args))\n                 }\n         case (expr_binary(?binop, ?lhs, ?rhs)) {\n@@ -376,7 +376,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n             expr_cast(fld.fold_expr(expr), ty)\n         }\n         case (expr_if(?cond, ?tr, ?fl)) {\n-            expr_if(fld.fold_expr(cond), fld.fold_block(tr), \n+            expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n                     option::map(fld.fold_expr, fl))\n                 }\n         case (expr_ternary(?cond, ?tr, ?fl)) {\n@@ -388,11 +388,11 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n             expr_while(fld.fold_expr(cond), fld.fold_block(body))\n                 }\n         case (expr_for(?decl, ?expr, ?block)) {\n-            expr_for(fld.fold_local(decl), fld.fold_expr(expr), \n+            expr_for(fld.fold_local(decl), fld.fold_expr(expr),\n                      fld.fold_block(block))\n                 }\n         case (expr_for_each(?decl, ?expr, ?block)) {\n-            expr_for_each(fld.fold_local(decl), fld.fold_expr(expr), \n+            expr_for_each(fld.fold_local(decl), fld.fold_expr(expr),\n                           fld.fold_block(block))\n                 }\n         case (expr_do_while(?block, ?expr)) {\n@@ -437,21 +437,21 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n         case (expr_fail(?e)) { expr_fail(option::map(fld.fold_expr, e)) }\n         case (expr_break()) { e }\n         case (expr_cont()) { e }\n-        case (expr_ret(?e)) { \n+        case (expr_ret(?e)) {\n             expr_ret(option::map(fld.fold_expr, e))\n                 }\n-        case (expr_put(?e)) { \n+        case (expr_put(?e)) {\n             expr_put(option::map(fld.fold_expr, e))\n                 }\n         case (expr_be(?e)) { expr_be(fld.fold_expr(e)) }\n         case (expr_log(?lv, ?e)) { expr_log(lv, fld.fold_expr(e)) }\n         case (expr_assert(?e)) { expr_assert(fld.fold_expr(e)) }\n         case (expr_check(?m, ?e)) { expr_check(m, fld.fold_expr(e)) }\n         case (expr_if_check(?cond, ?tr, ?fl)) {\n-            expr_if_check(fld.fold_expr(cond), fld.fold_block(tr), \n+            expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n                           option::map(fld.fold_expr, fl))\n                 }\n-        case (expr_port(?ot)) { \n+        case (expr_port(?ot)) {\n             expr_port(alt(ot) {\n                     case (option::some(?t)) { option::some(fld.fold_ty(t)) }\n                     case (option::none) { option::none }\n@@ -531,7 +531,7 @@ fn noop_fold_local(&local_ l, ast_fold fld) -> local_ {\n                 case (option::none[initializer]) { l.init }\n                 case (option::some[initializer](?init)) {\n                     option::some[initializer]\n-                    (rec(op=init.op, \n+                    (rec(op=init.op,\n                          expr=fld.fold_expr(init.expr)))\n                 }\n             },\n@@ -591,7 +591,7 @@ fn dummy_out(ast_fold a) {\n \n \n fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n-    let ast_fold result = \n+    let ast_fold result =\n         @mutable rec(fold_crate = nf_crate_dummy,\n                      fold_crate_directive = nf_crate_directive_dummy,\n                      fold_view_item = nf_view_item_dummy,\n@@ -620,7 +620,7 @@ fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n         ret rec(node=afp.fold_crate(c.node, f),\n                 span=c.span);\n     }\n-    fn f_crate_directive(&ast_fold_precursor afp, ast_fold f, \n+    fn f_crate_directive(&ast_fold_precursor afp, ast_fold f,\n                          &@crate_directive c) -> @crate_directive {\n         ret @rec(node=afp.fold_crate_directive(c.node, f),\n                  span=c.span);\n@@ -669,14 +669,14 @@ fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n     }\n     fn f_fn(&ast_fold_precursor afp, ast_fold f, &_fn x) -> _fn {\n         ret afp.fold_fn(x, f);\n-    }    \n+    }\n     fn f_mod(&ast_fold_precursor afp, ast_fold f, &_mod x) -> _mod {\n         ret afp.fold_mod(x, f);\n     }\n-    fn f_native_mod(&ast_fold_precursor afp, ast_fold f, &native_mod x) -> \n+    fn f_native_mod(&ast_fold_precursor afp, ast_fold f, &native_mod x) ->\n         native_mod {\n         ret afp.fold_native_mod(x, f);\n-    }    \n+    }\n     fn f_variant(&ast_fold_precursor afp, ast_fold f, &variant x)\n         -> variant {\n         ret rec(node=afp.fold_variant(x.node, f), span=x.span);"}, {"sha": "29670d21e8649291f1262d0970264438c12b13ae", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -370,8 +370,8 @@ fn next_token(&reader rdr) -> token::token {\n         case ('?') { rdr.bump(); ret token::QUES; }\n         case (';') { rdr.bump(); ret token::SEMI; }\n         case (',') { rdr.bump(); ret token::COMMA; }\n-        case ('.') { \n-            rdr.bump(); \n+        case ('.') {\n+            rdr.bump();\n             if (rdr.curr() == '.' && rdr.next() == '.') {\n                 rdr.bump();\n                 rdr.bump();\n@@ -386,8 +386,8 @@ fn next_token(&reader rdr) -> token::token {\n         case ('[') { rdr.bump(); ret token::LBRACKET; }\n         case (']') { rdr.bump(); ret token::RBRACKET; }\n         case ('@') { rdr.bump(); ret token::AT; }\n-        case ('#') { \n-            rdr.bump(); \n+        case ('#') {\n+            rdr.bump();\n             if (rdr.curr() == '<') {\n                 rdr.bump();\n                 ret token::POUND_LT;"}, {"sha": "a8fd51993b1e34cb22f1ffb9583ea6cfc0de9aeb", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -361,7 +361,7 @@ fn parse_ty_constr(&ast::arg[] fn_args, &parser p) -> @ast::constr {\n }\n \n \n-// Use the args list to translate each bound variable \n+// Use the args list to translate each bound variable\n // mentioned in a constraint to an arg index.\n // Seems weird to do this in the parser, but I'm not sure how else to.\n fn parse_constrs(&ast::arg[] args, &parser p)\n@@ -932,7 +932,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_assert(e);\n         hi = e.span.hi;\n     } else if (eat_word(p, \"check\")) {\n-        /* Should be a predicate (pure boolean function) applied to \n+        /* Should be a predicate (pure boolean function) applied to\n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n@@ -943,7 +943,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n-        \n+\n         auto e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::unchecked, e);\n@@ -1310,7 +1310,7 @@ fn parse_else_expr(&parser p) -> @ast::expr {\n fn parse_head_local(&parser p) -> @ast::local {\n     if (is_word(p, \"auto\")) {\n         ret parse_auto_local(p);\n-    } else { \n+    } else {\n         ret parse_typed_local(p);\n     }\n }\n@@ -1709,7 +1709,7 @@ fn parse_block(&parser p) -> ast::block {\n     be parse_block_tail(p);\n }\n \n-// some blocks start with \"#{\"... \n+// some blocks start with \"#{\"...\n fn parse_block_tail(&parser p) -> ast::block {\n     auto lo = p.get_lo_pos();\n     let (@ast::stmt)[] stmts = ~[];\n@@ -1865,7 +1865,7 @@ fn parse_dtor(&parser p) -> @ast::method {\n             purity=ast::impure_fn,\n             cf=ast::return,\n \n-            // I guess dtors can't have constraints? \n+            // I guess dtors can't have constraints?\n             constraints=~[]);\n     let ast::_fn f = rec(decl=d, proto=ast::proto_fn, body=b);\n     let ast::method_ m =\n@@ -2432,7 +2432,7 @@ fn parse_crate_from_source_str(&str name, &str source, &ast::crate_cfg cfg,\n }\n \n // Parses a source module as a crate\n-fn parse_crate_mod(&parser p, &ast::crate_cfg cfg, parse_sess sess) \n+fn parse_crate_mod(&parser p, &ast::crate_cfg cfg, parse_sess sess)\n     -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto crate_attrs = parse_inner_attrs_and_next(p);"}, {"sha": "41ba5715d3b940b4e8a20b54b20f5f198430a12c", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -574,7 +574,7 @@ fn print_stmt(&ps s, &ast::stmt st) {\n \n fn print_block(&ps s, &ast::block blk) {\n     print_possibly_embedded_block(s, blk, false);\n-} \n+}\n \n fn print_possibly_embedded_block(&ps s, &ast::block blk, bool embedded) {\n     maybe_print_comment(s, blk.span.lo);\n@@ -1003,13 +1003,13 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                 print_expr(s, field.expr);\n                 end(s);\n             }\n-            fn get_span(&ast::anon_obj_field f) -> codemap::span { \n-                ret f.ty.span; \n+            fn get_span(&ast::anon_obj_field f) -> codemap::span {\n+                ret f.ty.span;\n             }\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n-                    commasep_cmnt(s, consistent, fields, print_field, \n+                    commasep_cmnt(s, consistent, fields, print_field,\n                                        get_span);\n                 }\n             }"}, {"sha": "a99d980ce9e9911099ebba160d1249f017e658d4", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -394,7 +394,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n-                    for (ast::anon_obj_field f in fields) { \n+                    for (ast::anon_obj_field f in fields) {\n                         walk_ty(v, f.ty);\n                         walk_expr(v, f.expr);\n                     }"}, {"sha": "b1951cb58601b736c4e791a3489346f545fa1ed8", "filename": "src/etc/tidy.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -25,6 +25,9 @@ def report_err(s):\n     if not autocrlf and line.find('\\r') != -1:\n         report_err(\"CR character\")\n \n+    if line.endswith(\" \\n\") or line.endswith(\"\\t\\n\"):\n+        report_err(\"trailing whitespace\")\n+\n     line_len = len(line)-2 if autocrlf else len(line)-1\n     if line_len > cols:\n         report_err(\"line longer than %d chars\" % cols)"}, {"sha": "32e5dd3bac95b5b1ae6871a103404797f96f0cc1", "filename": "src/lib/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Flib%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Flib%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu64.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -2,7 +2,7 @@ fn to_str(u64 n, uint radix) -> str {\n     assert(0u < radix && radix <= 16u);\n \n     auto r64 = radix as u64;\n-    \n+\n     fn digit(u64 n) -> str {\n         ret alt (n) {\n             case (0u64) { \"0\" }"}, {"sha": "445ac8fe125f945d933b5e2654d3c05d1870c0eb", "filename": "src/lib/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -300,13 +300,13 @@ fn or(&vec[bool] v) -> bool {\n \n fn any[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n     for (T t in v) {\n-        if (f(t)) { ret true; } \n+        if (f(t)) { ret true; }\n     }\n     ret false;\n }\n fn all[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n     for (T t in v) {\n-        if (!f(t)) { ret false; } \n+        if (!f(t)) { ret false; }\n     }\n     ret true;\n }"}, {"sha": "5e96e2b777dea27fbcaca70cee7cf366f2bca85b", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -11,7 +11,7 @@ fn list_dir(str path) -> str[] {\n }\n \n fn path_is_absolute(str p) -> bool {\n-    ret str::char_at(p, 0u) == '/' \n+    ret str::char_at(p, 0u) == '/'\n         || (str::char_at(p, 1u) == ':' && str::char_at(p, 2u) == '\\\\');\n }\n "}, {"sha": "a3853d636ee77a55d2451a1944cf6630b5f0bc5c", "filename": "src/rt/arch/i386/context.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -5,7 +5,7 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-extern \"C\" uint32_t CDECL swap_registers(registers_t *oregs, \n+extern \"C\" uint32_t CDECL swap_registers(registers_t *oregs,\n                                          registers_t *regs)\n   asm (\"swap_registers\");\n "}, {"sha": "22c331b347e97869596fcd65f4e9a7a91607c8f8", "filename": "src/rt/arch/i386/context.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Farch%2Fi386%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Farch%2Fi386%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -22,7 +22,7 @@ class context {\n \n public:\n   context();\n-  \n+\n   context *next;\n \n   void swap(context &out);"}, {"sha": "011d4d93218477a44138111fd314c31badf649a6", "filename": "src/rt/globals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fglobals.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fglobals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fglobals.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -45,6 +45,6 @@ extern \"C\" {\n                     __FILE__, __LINE__, res, strerror(res));        \\\n             abort();                                                \\\n         }                                                           \\\n-    }                                                               \n+    }\n \n #endif /* GLOBALS_H */"}, {"sha": "5b40506f8565f94ee4432ece26168f8ba3e4e9d4", "filename": "src/rt/isaac/randport.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fisaac%2Frandport.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fisaac%2Frandport.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Frandport.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -76,7 +76,7 @@ void randinit(randctx *ctx, word flag)\n      mix(a,b,c,d,e,f,g,h);\n    }\n \n-   if (flag) \n+   if (flag)\n    {\n      /* initialize using the contents of r[] as the seed */\n      for (i=0; i<RANDSIZ; i+=8)"}, {"sha": "13de56a3361a5b9c4555854bbe5ab1de32689b28", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -67,7 +67,7 @@ memory_region::realloc(void *mem, size_t size) {\n     void *newMem = _srv->realloc(mem, size);\n #ifdef TRACK_ALLOCATIONS\n     if (_allocation_list[index] != mem) {\n-        printf(\"at index %d, found %p, expected %p\\n\", \n+        printf(\"at index %d, found %p, expected %p\\n\",\n                index, _allocation_list[index], mem);\n         printf(\"realloc: ptr 0x%\" PRIxPTR \" is not in allocation_list\\n\",\n             (uintptr_t) mem);\n@@ -76,7 +76,7 @@ memory_region::realloc(void *mem, size_t size) {\n     else {\n         _allocation_list[index] = newMem;\n         (*(int*)newMem) = index;\n-        // printf(\"realloc: stored %p at index %d, replacing %p\\n\", \n+        // printf(\"realloc: stored %p at index %d, replacing %p\\n\",\n         //        newMem, index, mem);\n     }\n #endif\n@@ -101,7 +101,7 @@ memory_region::malloc(size_t size) {\n     *p = index;\n     // printf(\"malloc: stored %p at index %d\\n\", mem, index);\n #endif\n-    // printf(\"malloc: ptr 0x%\" PRIxPTR \" region=%p\\n\", \n+    // printf(\"malloc: ptr 0x%\" PRIxPTR \" region=%p\\n\",\n     //        (uintptr_t) mem, this);\n     if (_synchronized) { _lock.unlock(); }\n #ifdef TRACK_ALLOCATIONS"}, {"sha": "76cef811e7529e3f85093e2768f2cb444a0f0da8", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -105,7 +105,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     rust_kernel *kernel = new rust_kernel(srv);\n     kernel->start();\n     rust_scheduler *sched = kernel->get_scheduler();\n-    command_line_args *args \n+    command_line_args *args\n         = new (kernel) command_line_args(sched->root_task, argc, argv);\n \n     DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,"}, {"sha": "1ed2c4ec36d8925e1d58515e5bdf8b49dfa261ef", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -83,7 +83,7 @@ rust_getcwd(rust_task *task) {\n     rust_str *st;\n     st = new (mem) rust_str(sched, alloc, fill, (const uint8_t *)cbuf);\n \n-    return st;    \n+    return st;\n }\n \n extern \"C\" CDECL"}, {"sha": "4c176636713618a7f73e42c99c4849cd10ff12a6", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -6,7 +6,7 @@\n  */\n rust_chan::rust_chan(rust_task *task,\n                      maybe_proxy<rust_port> *port,\n-                     size_t unit_sz) \n+                     size_t unit_sz)\n     : ref_count(1),\n       kernel(task->kernel),\n       task(task),"}, {"sha": "6a8114e6f52c12b7f05543163d95b169d286a383", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -11,7 +11,7 @@ rust_kernel::rust_kernel(rust_srv *srv) :\n     _region(&srv->local_region),\n     _log(srv, NULL),\n     _srv(srv),\n-    _interrupt_kernel_loop(FALSE) \n+    _interrupt_kernel_loop(FALSE)\n {\n     sched = create_scheduler(\"main\");\n }\n@@ -245,14 +245,14 @@ rust_kernel::signal_kernel_lock() {\n int rust_kernel::start_task_threads(int num_threads)\n {\n     rust_task_thread *thread = NULL;\n-    \n+\n     // -1, because this thread will also be a thread.\n     for(int i = 0; i < num_threads - 1; ++i) {\n         thread = new rust_task_thread(i + 1, this);\n         thread->start();\n         threads.push(thread);\n     }\n-    \n+\n     sched->start_main_loop(0);\n \n     while(threads.pop(&thread)) {"}, {"sha": "9ebd77a0de1a80fad2855bad22449ce305d1b5ad", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -126,10 +126,10 @@ class rust_kernel : public rust_thread {\n class rust_task_thread : public rust_thread {\n     int id;\n     rust_kernel *owner;\n-    \n+\n public:\n     rust_task_thread(int id, rust_kernel *owner);\n-    \n+\n     virtual void run();\n };\n "}, {"sha": "85b6ed6b08902c5d0c511f1a565cfe3c38674afe", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -106,7 +106,7 @@ void data_message::kernel_process() {\n \n }\n \n-rust_message_queue::rust_message_queue(rust_srv *srv, rust_kernel *kernel) \n+rust_message_queue::rust_message_queue(rust_srv *srv, rust_kernel *kernel)\n     : region(srv, true),\n       kernel(kernel),\n       sched_handle(NULL) {"}, {"sha": "aa909ca109bb8f4d2347b82d96b868b14ff56fd1", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,7 +1,7 @@\n #include \"rust_internal.h\"\n #include \"rust_port.h\"\n \n-rust_port::rust_port(rust_task *task, size_t unit_sz) \n+rust_port::rust_port(rust_task *task, size_t unit_sz)\n     : maybe_proxy<rust_port>(this), kernel(task->kernel), task(task),\n       unit_sz(unit_sz), writers(task), chans(task) {\n "}, {"sha": "be30f229e7e381c3f7e9b0dacf3d51d054faa443", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -127,7 +127,7 @@ void task_start_wrapper(spawn_args *a)\n     a->f(&rval, task, a->a3, a->a4);\n \n     LOG(task, task, \"task exited with value %d\", rval);\n-    \n+\n \n     LOG(task, task, \"task ref_count: %d\", task->ref_count);\n     A(task->sched, task->ref_count >= 0,\n@@ -147,7 +147,7 @@ rust_task::start(uintptr_t spawnee_fn,\n     LOGPTR(sched, \"from spawnee\", spawnee_fn);\n \n     I(sched, stk->data != NULL);\n-    \n+\n     char *sp = (char *)rust_sp;\n \n     sp -= sizeof(spawn_args);\n@@ -481,7 +481,7 @@ rust_task::get_handle() {\n \n bool rust_task::can_schedule(int id)\n {\n-    return yield_timer.has_timed_out() && \n+    return yield_timer.has_timed_out() &&\n         running_on == -1 &&\n         (pinned_on == -1 || pinned_on == id);\n }"}, {"sha": "0babf4ab7e7fb07ebf3950f27e87ea3a5e563af5", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -74,7 +74,7 @@ rust_task : public maybe_proxy<rust_task>,\n     rust_handle<rust_task> *handle;\n \n     context ctx;\n-    \n+\n     // This flag indicates that a worker is either currently running the task\n     // or is about to run this task.\n     int running_on;"}, {"sha": "eb1f30b93ee148ee340de18d4d64241c1fa8c47f", "filename": "src/rt/rust_timer.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_timer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_timer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_timer.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -71,7 +71,7 @@ rust_timer::~rust_timer() {\n     exit_flag = 1;\n #if defined(__WIN32__)\n     sched->kernel->win32_require(\"WaitForSingleObject\",\n-                               WaitForSingleObject(thread, INFINITE) == \n+                               WaitForSingleObject(thread, INFINITE) ==\n                                WAIT_OBJECT_0);\n #else\n     pthread_join(thread, NULL);"}, {"sha": "16d7f7c4f8317d11455c29cd4bf9ab59b6ea543a", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -192,20 +192,20 @@ upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     {\n         scoped_lock with(port->lock);\n         LOG_UPCALL_ENTRY(task);\n-    \n+\n         LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n             \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n             (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n             port->chans.length());\n-    \n+\n         if (port->receive(dptr)) {\n             return;\n         }\n-    \n+\n         // No data was buffered on any incoming channel, so block this task on\n         // the port. Remember the rendezvous location so that any sender task\n         // can write to it before waking up this task.\n-    \n+\n         LOG(task, comm, \"<=== waiting for rendezvous data ===\");\n         task->rendezvous_ptr = dptr;\n         task->block(port, \"waiting for rendezvous data\");\n@@ -351,7 +351,6 @@ rust_str *make_str(rust_task *task, char const *s, size_t fill) {\n extern \"C\" CDECL rust_str *\n upcall_new_str(rust_task *task, char const *s, size_t fill) {\n     LOG_UPCALL_ENTRY(task);\n-    \n     return make_str(task, s, fill);\n }\n \n@@ -537,7 +536,7 @@ upcall_start_task(rust_task *spawner,\n     rust_scheduler *sched = spawner->sched;\n     DLOG(sched, task,\n          \"upcall start_task(task %s @0x%\" PRIxPTR\n-         \", spawnee 0x%\" PRIxPTR \")\", \n+         \", spawnee 0x%\" PRIxPTR \")\",\n          task->name, task,\n          spawnee_fn);\n "}, {"sha": "cf0e4ea20c937bf405a9c97dafeb16c105b8d089", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -157,7 +157,7 @@ isaac_init(rust_scheduler *sched, randctx *rctx)\n         } else {\n             int fd = open(\"/dev/urandom\", O_RDONLY);\n             I(sched, fd > 0);\n-            I(sched, \n+            I(sched,\n               read(fd, (void*) &rctx->randrsl, sizeof(rctx->randrsl))\n               == sizeof(rctx->randrsl));\n             I(sched, close(fd) == 0);\n@@ -175,8 +175,8 @@ rust_vec : public rc_base<rust_vec>\n     size_t fill;\n     size_t pad; // Pad to align data[0] to 16 bytes.\n     uint8_t data[];\n-    rust_vec(rust_scheduler *sched, size_t alloc, size_t fill, \n-             uint8_t const *d) \n+    rust_vec(rust_scheduler *sched, size_t alloc, size_t fill,\n+             uint8_t const *d)\n         : alloc(alloc),\n           fill(fill)\n     {"}, {"sha": "3d0d101388908da4ba7d86933838a112408f658e", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -21,7 +21,7 @@ lock_and_signal::lock_and_signal() {\n }\n \n #else\n-lock_and_signal::lock_and_signal() \n+lock_and_signal::lock_and_signal()\n     : _locked(false)\n {\n     CHECKED(pthread_cond_init(&_cond, NULL));"}, {"sha": "60c22958342fb3f6f773c3fa8a77360b8f08e6db", "filename": "src/rt/sync/lock_and_signal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -30,7 +30,7 @@ class lock_and_signal {\n \n class scoped_lock {\n   lock_and_signal &lock;\n-  \n+\n public:\n   scoped_lock(lock_and_signal &lock);\n   ~scoped_lock();"}, {"sha": "a932ef1c2cab4d0c072eba0275b23122d966f0e7", "filename": "src/rt/sync/sync.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fsync%2Fsync.h", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Frt%2Fsync%2Fsync.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fsync.h?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -11,7 +11,7 @@ class sync {\n         T oldValue, T newValue) {\n         return __sync_bool_compare_and_swap(address, oldValue, newValue);\n     }\n-    \n+\n     template <class T>\n     static T increment(T *address) {\n         return __sync_add_and_fetch(address, 1);\n@@ -20,7 +20,7 @@ class sync {\n     template <class T>\n     static T decrement(T *address) {\n         return __sync_sub_and_fetch(address, 1);\n-    }    \n+    }\n \n     template <class T>\n     static T increment(T &address) {\n@@ -30,7 +30,7 @@ class sync {\n     template <class T>\n     static T decrement(T &address) {\n         return __sync_sub_and_fetch(&address, 1);\n-    }    \n+    }\n };\n \n /**"}, {"sha": "657096178636e4a684cd9a0f6dfb4305b43adcb7", "filename": "src/snapshots.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -58,7 +58,7 @@ S 2011-06-15 02018fe\n   macos-i386 4942eeb8897d75cbdb8cf15bef3b9bc941bc9f34\n   winnt-i386 b8cf72007bf751062de0802984e7e5a68b66ae61\n \n-S 2011-06-15 92bd350 \n+S 2011-06-15 92bd350\n   linux-i386 145b68488a780623cc31c5e043c6770007273f80\n   macos-i386 d3149431f12603927bb211f53f8572fc188eb7d2\n   winnt-i386 8ee37c22195ce180961db1fad013a0743cf97cdd"}, {"sha": "b077aac7b1911e32735759da64657c54af10f9af", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,6 +1,6 @@\n \n \n-/* -*- mode::rust;indent-tabs-mode::nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*-\n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */"}, {"sha": "d4790d36d6e3f611ee8a32e1d7be85abe2c793ee", "filename": "src/test/bench/99-bottles/99bob-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,6 +1,6 @@\n \n \n-/* -*- mode::rust;indent-tabs-mode::nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*-\n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */"}, {"sha": "3135030d4d07ef6b6f62882e8cb7baa640c571e1", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,6 +1,6 @@\n \n \n-/* -*- mode::rust;indent-tabs-mode::nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*-\n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */"}, {"sha": "d1612e2143d27982df283d16b0bb1e1cb7b5a15b", "filename": "src/test/bench/99-bottles/99bob-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,4 +1,4 @@\n-/* -*- mode::rust;indent-tabs-mode::nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*-\n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */"}, {"sha": "540be7c6c73f28e2adf57625a69566515e763ab8", "filename": "src/test/bench/shootout/nbody.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -40,10 +40,10 @@ mod NBodySystem {\n     fn MakeNBodySystem() -> vec[Body::props] {\n         let vec[Body::props] bodies = [\n             // these each return a Body::props\n-            Body::sun(), \n-            Body::jupiter(), \n-            Body::saturn(), \n-            Body::uranus(), \n+            Body::sun(),\n+            Body::jupiter(),\n+            Body::saturn(),\n+            Body::uranus(),\n             Body::neptune()];\n \n         let float px = 0.0;\n@@ -132,7 +132,7 @@ mod NBodySystem {\n \n                 distance = llvm::sqrt(dx*dx + dy*dy + dz*dz);\n                 e -= (bodies.(i).mass * bodies.(j).mass) / distance;\n-                \n+\n                 j += 1;\n             }\n \n@@ -149,12 +149,12 @@ mod Body {\n     const float SOLAR_MASS = 39.478417604357432; // was 4 * PI * PI originally\n     const float DAYS_PER_YEAR = 365.24;\n \n-    type props = rec(mutable float x, \n-                     mutable float y, \n-                     mutable float z, \n-                     mutable float vx, \n+    type props = rec(mutable float x,\n+                     mutable float y,\n+                     mutable float z,\n+                     mutable float vx,\n                      mutable float vy,\n-                     mutable float vz, \n+                     mutable float vz,\n                      float mass);\n \n     fn jupiter() -> Body::props {\n@@ -218,8 +218,8 @@ mod Body {\n    }\n \n    fn offsetMomentum(&Body::props props,\n-                            float px, \n-                            float py, \n+                            float px,\n+                            float py,\n                             float pz) -> () {\n        props.vx = -px / SOLAR_MASS;\n        props.vy = -py / SOLAR_MASS;"}, {"sha": "dfdf30f7836d40fa8cb64619b41437e1f940023c", "filename": "src/test/bench/shootout/pfib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -27,7 +27,7 @@ fn fib(int n) -> int {\n         }\n         else {\n             let port[int] p = port();\n-      \n+\n             auto t1 = spawn pfib(chan(p), n - 1);\n             auto t2 = spawn pfib(chan(p), n - 2);\n \n@@ -58,12 +58,12 @@ fn main(vec[str] argv) {\n         assert(stop >= start);\n \n         auto elapsed = stop - start;\n-        auto us_task = elapsed / (fibn as u64) / (1000 as u64); \n+        auto us_task = elapsed / (fibn as u64) / (1000 as u64);\n \n         log_err #fmt(\"Determined that fib(%d) = %d in %d%d ns (%d us / task)\",\n-                     n, fibn, \n-                     (elapsed / (1000000 as u64)) as int, \n-                     (elapsed % (1000000 as u64)) as int, \n+                     n, fibn,\n+                     (elapsed / (1000000 as u64)) as int,\n+                     (elapsed % (1000000 as u64)) as int,\n                      us_task as int);\n     }\n }"}, {"sha": "ce56eafeb21e2cfba88586c7d25169a5f3a914c9", "filename": "src/test/bench/task-perf/pfib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Ftask-perf%2Fpfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Ftask-perf%2Fpfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf%2Fpfib.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -37,7 +37,7 @@ fn fib(int n) -> int {\n         }\n         else {\n             auto p = port();\n-      \n+\n             auto t1 = spawn pfib(chan(p), n - 1);\n             auto t2 = spawn pfib(chan(p), n - 2);\n \n@@ -84,7 +84,7 @@ fn stress(int num_tasks) {\n     }\n     for each(int i in range(0, num_tasks)) {\n         task::join(tasks.(i));\n-    }    \n+    }\n }\n \n fn main(vec[str] argv) {\n@@ -107,16 +107,16 @@ fn main(vec[str] argv) {\n             auto num_trials = 10;\n \n             auto out = io::stdout();\n-            \n+\n             for each(int n in range(1, max + 1)) {\n                 for each(int i in range(0, num_trials)) {\n                     auto start = time::precise_time_ns();\n                     auto fibn = fib(n);\n                     auto stop = time::precise_time_ns();\n \n                     auto elapsed = stop - start;\n-            \n-                    out.write_line(#fmt(\"%d\\t%d\\t%s\", n, fibn, \n+\n+                    out.write_line(#fmt(\"%d\\t%d\\t%s\", n, fibn,\n                                         u64::str(elapsed)));\n                 }\n             }"}, {"sha": "960ca9efcee6aa5f807129896326485d173e801a", "filename": "src/test/bench/task-perf/word-count.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -30,10 +30,10 @@ mod map_reduce {\n     type mapper = fn(str, putter);\n \n     type getter = fn() -> option[str];\n-    \n+\n     type reducer = fn(str, getter);\n \n-    \n+\n     fn map_reduce (vec[str] inputs,\n                    mapper f,\n                    reducer reduce) {\n@@ -48,7 +48,7 @@ mod map_reduce {\n                 }\n                 case (none) { }\n             }\n-            \n+\n             im.insert(key, old + [val]);\n         }\n \n@@ -86,7 +86,7 @@ fn main(vec[str] argv) {\n \n         while(true) {\n             alt(read_word(f)) {\n-                case (some(?w)) { \n+                case (some(?w)) {\n                     emit(w, \"1\");\n                 }\n                 case (none) {\n@@ -98,7 +98,7 @@ fn main(vec[str] argv) {\n \n     fn reduce(str word, map_reduce::getter get) {\n         auto count = 0;\n-        \n+\n         while(true) {\n             alt(get()) {\n                 case(some(_)) { count += 1 }"}, {"sha": "970dbb94af9b6282140d7fde8b85fa51806ed802", "filename": "src/test/compile-fail/bind-parameterized-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -3,7 +3,7 @@\n fn main() {\n   fn echo[T](int c, vec[T] x) {\n   }\n-  \n+\n   let fn(vec[int]) -> () y = bind echo(42, _);\n \n   y([1]);"}, {"sha": "54aa1fe67e8cc870a38399ad58221f62ed9e8a02", "filename": "src/test/compile-fail/if-check-precond-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -17,7 +17,7 @@ fn print_even(uint x) : even(x) {\n }\n \n fn foo(uint x) -> () {\n-  if check(even(x)) { \n+  if check(even(x)) {\n       fail;\n     }\n   else {"}, {"sha": "e163d34387912ea7a08a7b7875128c9f383f5913", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -3,13 +3,13 @@\n \n fn g() -> () {}\n \n-pred f(int q) -> bool { \n+pred f(int q) -> bool {\n   g();\n   ret true;\n }\n \n fn main() {\n   auto x = 0;\n \n-  check f(x); \n+  check f(x);\n }"}, {"sha": "ee03ad708347c9e08ae5c9d5f2b932239088e11a", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,6 +1,6 @@\n //error-pattern:expanded as an identifier\n fn main() {\n   #macro([#mylambda(x, body), {fn f(int x) -> int {ret body}; f}]);\n-  \n+\n   assert(#mylambda(y*1, y*2)(8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "a3f2df4f1871b34b1853c6b1882ad03a01d049ff", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -2,6 +2,6 @@\n \n fn main() {\n   #macro([#trivial(), 1*2*4*2*1]);\n-  \n+\n   assert(#trivial(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) == 16);\n }"}, {"sha": "0ba3d01e380d20ac971fca542dc64b4c00d531aa", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -17,5 +17,5 @@ fn main() {\n   // the next statement, since it's not true in the\n   // prestate.\n   auto d <- a;\n-  log (safe_slice(\"kitties\", b, d)); \n+  log (safe_slice(\"kitties\", b, d));\n }\n\\ No newline at end of file"}, {"sha": "40f4d3b71a6ff0ac458cdcb3aab81926a6b20df8", "filename": "src/test/compile-fail/not-a-pred-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -6,5 +6,5 @@ fn f(int q) -> bool { ret true; }\n fn main() {\n   auto x = 0;\n \n-  check f(x); \n+  check f(x);\n }"}, {"sha": "daf781fd3fe0254035be70c15892b3511592892e", "filename": "src/test/compile-fail/not-pred-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -6,5 +6,5 @@ pred f(int q) -> bool { ret true; }\n \n fn main() {\n // should fail to typecheck, as pred args must be slot variables or literals\n-  check f(42 * 17); \n+  check f(42 * 17);\n }"}, {"sha": "c415c289da87bed8e28ceb3bec08d07fd2b10775", "filename": "src/test/compile-fail/self-missing-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -6,7 +6,7 @@ fn main() {\n           self();\n       }\n   }\n-  \n+\n   auto a = foo;\n   a.m();\n }"}, {"sha": "22027f7dc650e7abc5e6c57776f6e0727b10baf2", "filename": "src/test/run-fail/fail-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-fail%2Ffail-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-fail%2Ffail-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-arg.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -4,6 +4,6 @@ fn f(int a) {\n   log a;\n }\n \n-fn main() { \n+fn main() {\n   f(fail \"woe\");\n-} \n+}"}, {"sha": "2c77bc80478d044b5965740fd080ac00ef0078d6", "filename": "src/test/run-fail/if-check-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -13,7 +13,7 @@ pred even(uint x) -> bool {\n }\n \n fn foo(uint x) -> () {\n-  if check(even(x)) { \n+  if check(even(x)) {\n       log x;\n     }\n   else {"}, {"sha": "09e9920d4f1804fee01157089ca99570f52c09d6", "filename": "src/test/run-fail/task-comm-14.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -12,17 +12,17 @@ io fn main() {\n         i = i - 1;\n     }\n \n-    // Spawned tasks are likely killed before they get a chance to send \n+    // Spawned tasks are likely killed before they get a chance to send\n     // anything back, so we deadlock here.\n-    \n+\n     i = 10;\n     let int value = 0;\n     while (i > 0) {\n         log i;\n         po |> value;\n         i = i - 1;\n     }\n-  \n+\n     log \"main thread exiting\";\n }\n "}, {"sha": "9639467a4d9a6e7dfd276286f58a431e9fea3624", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -8,7 +8,7 @@ import std::option::some;\n fn foo[T](&option::t[T] y) {\n     let int x;\n     let vec[int] rs = [];\n-    /* tests that x doesn't get put in the precondition for the \n+    /* tests that x doesn't get put in the precondition for the\n        entire if expression */\n \n     if (true) {"}, {"sha": "646e50042ceed4d7193ba5473773e68326ba61fd", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -9,5 +9,5 @@ fn main() {\n   let uint c = 17u;\n   check le(a, b);\n   c <- a;\n-  log (safe_slice(\"kitties\", c, b)); \n+  log (safe_slice(\"kitties\", c, b));\n }\n\\ No newline at end of file"}, {"sha": "9f3a901ac16c33eaf42baa0fe1c6ec7a84ed7620", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   let uint b = 4u;\n   check le(a, b);\n   auto c <- a;\n-  log (safe_slice(\"kitties\", c, b)); \n+  log (safe_slice(\"kitties\", c, b));\n }\n\\ No newline at end of file"}, {"sha": "324d0a03f4ded73ff69505a8774a71bdc19ebc77", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   let uint b = 1u;\n   check le(b, a);\n   b <-> a;\n-  log (safe_slice(\"kitties\", a, b)); \n+  log (safe_slice(\"kitties\", a, b));\n }\n\\ No newline at end of file"}, {"sha": "69221ed25ae04303aa743c67f0eff9645fdb99ab", "filename": "src/test/run-pass/constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   let uint b = 4u;\n   check le(a, b);\n   auto c = b;\n-  log (safe_slice(\"kitties\", a, c)); \n+  log (safe_slice(\"kitties\", a, c));\n }\n\\ No newline at end of file"}, {"sha": "a14cb3ab69cd5c43831dd721acfd746979b9f755", "filename": "src/test/run-pass/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -6,5 +6,5 @@ fn main() {\n   let uint a = 1u;\n   let uint b = 4u;\n   check le(a, b);\n-  log (safe_slice(\"kitties\", a, b)); \n+  log (safe_slice(\"kitties\", a, b));\n }\n\\ No newline at end of file"}, {"sha": "1c61f40d60c431ad623ab7fa9a5e4e1e3302609d", "filename": "src/test/run-pass/if-check-precond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check-precond.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -16,7 +16,7 @@ fn print_even(uint x) : even(x) {\n }\n \n fn foo(uint x) -> () {\n-  if check(even(x)) { \n+  if check(even(x)) {\n       print_even(x);\n     }\n   else {"}, {"sha": "6c6c2ac39d30009afd65bf7503c254f4463fad9c", "filename": "src/test/run-pass/if-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fif-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fif-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -12,7 +12,7 @@ pred even(uint x) -> bool {\n }\n \n fn foo(uint x) -> () {\n-  if check(even(x)) { \n+  if check(even(x)) {\n       log x;\n     }\n   else {"}, {"sha": "62a6ed32e7054dd06045569945e9fc944a2e4456", "filename": "src/test/run-pass/import-glob-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,8 +1,8 @@\n import a1::b1::word_traveler;\n \n-mod a1 {                    // \n-  mod b1 {                  // \n-    import a2::b1::*;       //         <-\\ \n+mod a1 {                    //\n+  mod b1 {                  //\n+    import a2::b1::*;       //         <-\\\n     export word_traveler;   //           |\n   }                         //           |\n   mod b2 {                  //           |"}, {"sha": "66e19a168d1c4e2b86e756dac2992e04c6379bf8", "filename": "src/test/run-pass/import-glob-circular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -48,7 +48,7 @@ mod test2 {\n     //assert(f1() == 1u);\n     assert(f2() == 2u);\n     assert(f2() == 2u);\n-    assert(common() == 2u);    \n+    assert(common() == 2u);\n     assert(common() == 2u);\n   }\n }"}, {"sha": "3d81c857414ccea51708408886fabc90f1e454f7", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,5 +1,5 @@\n \n-/* \n+/*\n    This is a test case for Issue 507.\n \n    https://github.com/graydon/rust/issues/507\n@@ -22,7 +22,7 @@ fn main() {\n   let port[int] p = port();\n \n   auto _child = spawn child(chan(p));\n-  \n+\n   let int x;\n   p |> x;\n "}, {"sha": "e4aa41c27b06fe56bd62dbc85010e73f839fe489", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -190,7 +190,7 @@ fn main() {\n                               two(17, 42));\n     /*\n      * FIXME: Segfault.  Also appears to be caused only after upcall_grow_task\n-    \n+\n     log \"*** test parameterized: taggypar[int]\";\n     let eqfn[taggypar[int]] eq4 = taggypareq[int];\n     test_parameterized[taggypar[int]](eq4,\n@@ -199,7 +199,7 @@ fn main() {\n                                       threepar[int](1, 2, 3),\n                                       twopar[int](17, 42));\n     log \"*** end test parameterized: taggypar[int]\";\n-    \n+\n      */\n \n     log \"*** test parameterized: reccy\";"}, {"sha": "82a404755f77d95f015b4439663ce6c936873191", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -194,15 +194,15 @@ fn test_removal() {\n         /**\n          * FIXME (issue #150): we want to check the removed value as in the\n          * following:\n-        \n+\n         let util.option[uint] v = hm.remove(i);\n         alt (v) {\n           case (util.some[uint](u)) {\n             assert (u == (i * i));\n           }\n           case (util.none[uint]()) { fail; }\n         }\n-        \n+\n          * but we util.option is a tag type so util.some and util.none are\n          * off limits until we parse the dwarf for tag types.\n          */"}, {"sha": "54d51e616fb6c7a55ae2263e409b044dceefa105", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n   #macro([#mylambda(x,body), {fn f(int x) -> int { ret body }; f}]);\n-  \n+\n   assert(#mylambda(y,y*2)(8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "c7558bc9553b643103301d40ded57d990377a7ba", "filename": "src/test/run-pass/macro-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-3.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n   #macro([#trivial(), 1*2*4*2*1]);\n-  \n+\n   assert(#trivial() == 16);\n }"}, {"sha": "efd5611f85fefa921c56ad4b4b5ad60e19ae847e", "filename": "src/test/run-pass/macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n   #macro([#m1(a), a*4]);\n-  assert (#m1(2) == 8);  \n+  assert (#m1(2) == 8);\n }\n\\ No newline at end of file"}, {"sha": "dd0743323cdfe8a8c7e86eea54301e278e2f27a1", "filename": "src/test/run-pass/simple-anon-objs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     auto my_normal_obj = normal();\n \n     // Extending an object with a new method\n-    auto my_anon_obj = obj { \n-        fn bar() -> int { \n+    auto my_anon_obj = obj {\n+        fn bar() -> int {\n             ret 3;\n         }\n         with my_normal_obj"}, {"sha": "948521076801e8d46797ace7284b199b9f2bf6c3", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -13,7 +13,7 @@ fn child(int i1,\n          int i6,\n          int i7,\n          int i8,\n-         int i9) \n+         int i9)\n {\n   log_err i1;\n   log_err i2;"}, {"sha": "e09792c2fb89ec38f785f3dd4ee4496c73e8d624", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -14,7 +14,7 @@ fn main() {\n \n     test(#fmt(\"test\"), \"test\");\n \n-    // a quadratic optimization in LLVM (jump-threading) makes this test a \n+    // a quadratic optimization in LLVM (jump-threading) makes this test a\n     // bit slow to compile unless we break it up\n     part1();\n     part2();\n@@ -133,10 +133,10 @@ fn part4() {\n     // conversions support precision - it's not standard printf so we\n     // can do whatever. For now I'm making it behave the same as string\n     // conversions.\n-    \n+\n     test(#fmt(\"%.b\", true), \"\");\n     test(#fmt(\"%.0b\", true), \"\");\n-    test(#fmt(\"%.1b\", true), \"t\");  \n+    test(#fmt(\"%.1b\", true), \"t\");\n }\n \n fn part5() {"}, {"sha": "764919f3ba470541551685bfa71a20672ed59937", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -5,7 +5,7 @@ use std;\n import std::task::join;\n \n fn main() -> () {\n-   test00(); \n+   test00();\n }\n \n fn start() {"}, {"sha": "54d54f3eb7819fa8653554fb8635a8f5814eb0a1", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -10,16 +10,16 @@ fn main() -> () {\n fn start(int task_number) {\n     log \"Started / Finished task.\";\n }\n-    \n-fn test00() {    \n+\n+fn test00() {\n     let int i = 0;\n     let task t = spawn start(i);\n-    \n+\n     // Sleep long enough for the task to finish.\n     task::sleep(10000u);\n-    \n+\n     // Try joining tasks that have already finished.\n     task::join(t);\n-    \n+\n     log \"Joined task.\";\n }\n\\ No newline at end of file"}, {"sha": "62bbf5e149bfd02241a81fdaee91b37ab84899a2", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -8,7 +8,7 @@ fn start(chan[int] c, int start, int number_of_messages) {\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n-    }    \n+    }\n }\n \n fn main() -> () {"}, {"sha": "51ba9052c4fc376ef59c885cb758300bf88dd88c", "filename": "src/test/run-pass/task-comm-2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -4,7 +4,7 @@ use std;\n \n import std::task;\n \n-fn main() -> () {    \n+fn main() -> () {\n     log \"===== SPAWNING and JOINING THREAD TASKS =====\";\n     test00();\n }\n@@ -17,20 +17,20 @@ fn start(int task_number) {\n     }\n     log \"Finished task.\";\n }\n-    \n+\n fn test00() {\n     let int number_of_tasks = 8;\n-    \n+\n     let int i = 0;\n     let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         i = i + 1;\n         tasks += [spawn start(i)];\n     }\n-    \n+\n     for (task t in tasks) {\n         task::join(t);\n     }\n-    \n+\n     log \"Joined all task.\";\n }\n\\ No newline at end of file"}, {"sha": "8b95df17575a4c044d544edf4f15469912b614dd", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -22,21 +22,21 @@ fn test00_start(chan[int] ch, int message, int count) {\n fn test00() {\n     let int number_of_tasks = 16;\n     let int number_of_messages = 4;\n-    \n+\n     log \"Creating tasks\";\n-    \n+\n     let port[int] po = port();\n     let chan[int] ch = chan(po);\n-    \n+\n     let int i = 0;\n-    \n+\n     // Create and spawn tasks...\n     let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         tasks += [spawn test00_start(ch, i, number_of_messages)];\n         i = i + 1;\n     }\n-    \n+\n     // Read from spawned tasks...\n     let int sum = 0;\n     for (task t in tasks) {\n@@ -52,9 +52,9 @@ fn test00() {\n     for (task t in tasks) {\n         task::join(t);\n     }\n-    \n+\n     log \"Completed: Final number is: \";\n-    // assert (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) * \n+    // assert (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) *\n     //       number_of_messages));\n     assert (sum == 480);\n }"}, {"sha": "8f61a20dde0b712f99b2a343e57c3c939cfda668", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -32,7 +32,7 @@ fn test00() {\n         i += 1;\n     }\n     assert (sum == 1998000);\n-    // assert (sum == 4 * ((number_of_messages * \n+    // assert (sum == 4 * ((number_of_messages *\n     //                   (number_of_messages - 1)) / 2));\n \n }\n\\ No newline at end of file"}, {"sha": "6f23ffe2267f121e371110f23a51bd24297be0bb", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -12,24 +12,24 @@ fn test00_start(chan[int] c, int start, int number_of_messages) {\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n-    }    \n+    }\n }\n \n fn test00() {\n-    let int r = 0;    \n+    let int r = 0;\n     let int sum = 0;\n     let port[int] p = port();\n     let int number_of_messages = 10;\n-        \n-    let task t0 = spawn test00_start(chan(p), \n+\n+    let task t0 = spawn test00_start(chan(p),\n                         number_of_messages * 0, number_of_messages);\n-    let task t1 = spawn test00_start(chan(p), \n+    let task t1 = spawn test00_start(chan(p),\n                         number_of_messages * 1, number_of_messages);\n-    let task t2 = spawn test00_start(chan(p), \n+    let task t2 = spawn test00_start(chan(p),\n                         number_of_messages * 2, number_of_messages);\n-    let task t3 = spawn test00_start(chan(p), \n+    let task t3 = spawn test00_start(chan(p),\n                         number_of_messages * 3, number_of_messages);\n-    \n+\n     let int i = 0;\n     while (i < number_of_messages) {\n         p |> r; sum += r;\n@@ -38,12 +38,12 @@ fn test00() {\n         p |> r; sum += r;\n         i += 1;\n     }\n-            \n+\n     task::join(t0);\n     task::join(t1);\n     task::join(t2);\n     task::join(t3);\n-    \n-    assert (sum == (((number_of_messages * 4) * \n+\n+    assert (sum == (((number_of_messages * 4) *\n                    ((number_of_messages * 4) - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "6f23ffe2267f121e371110f23a51bd24297be0bb", "filename": "src/test/run-pass/task-comm-8.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -12,24 +12,24 @@ fn test00_start(chan[int] c, int start, int number_of_messages) {\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n-    }    \n+    }\n }\n \n fn test00() {\n-    let int r = 0;    \n+    let int r = 0;\n     let int sum = 0;\n     let port[int] p = port();\n     let int number_of_messages = 10;\n-        \n-    let task t0 = spawn test00_start(chan(p), \n+\n+    let task t0 = spawn test00_start(chan(p),\n                         number_of_messages * 0, number_of_messages);\n-    let task t1 = spawn test00_start(chan(p), \n+    let task t1 = spawn test00_start(chan(p),\n                         number_of_messages * 1, number_of_messages);\n-    let task t2 = spawn test00_start(chan(p), \n+    let task t2 = spawn test00_start(chan(p),\n                         number_of_messages * 2, number_of_messages);\n-    let task t3 = spawn test00_start(chan(p), \n+    let task t3 = spawn test00_start(chan(p),\n                         number_of_messages * 3, number_of_messages);\n-    \n+\n     let int i = 0;\n     while (i < number_of_messages) {\n         p |> r; sum += r;\n@@ -38,12 +38,12 @@ fn test00() {\n         p |> r; sum += r;\n         i += 1;\n     }\n-            \n+\n     task::join(t0);\n     task::join(t1);\n     task::join(t2);\n     task::join(t3);\n-    \n-    assert (sum == (((number_of_messages * 4) * \n+\n+    assert (sum == (((number_of_messages * 4) *\n                    ((number_of_messages * 4) - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "cb2479b4fbd8d9683def0efb5e319232e8663de0", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -12,25 +12,25 @@ fn test00_start(chan[int] c, int number_of_messages) {\n     while (i < number_of_messages) {\n         c <| i;\n         i += 1;\n-    }    \n+    }\n }\n \n fn test00() {\n-    let int r = 0;    \n+    let int r = 0;\n     let int sum = 0;\n     let port[int] p = port();\n     let int number_of_messages = 10;\n-        \n+\n     let task t0 = spawn\n         test00_start(chan(p), number_of_messages);\n-    \n+\n     let int i = 0;\n     while (i < number_of_messages) {\n         p |> r; sum += r; log (r);\n         i += 1;\n     }\n-            \n+\n     task::join(t0);\n-    \n+\n     assert (sum == (number_of_messages * (number_of_messages - 1)) / 2);\n }\n\\ No newline at end of file"}, {"sha": "26087f98cd0d21a250f93d6be7f1ffe25c9cb203", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -29,18 +29,18 @@ fn test00() {\n     let int number_of_tasks = 1;\n     let int number_of_messages = 4;\n     log \"Creating tasks\";\n-    \n+\n     let port[int] po = port();\n     let chan[int] ch = chan(po);\n-    \n+\n     let int i = 0;\n-    \n+\n     let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         i = i + 1;\n         tasks += [spawn test00_start(ch, i, number_of_messages)];\n     }\n-    \n+\n     let int sum = 0;\n     for (task t in tasks) {\n         i = 0;\n@@ -54,9 +54,9 @@ fn test00() {\n     for (task t in tasks) {\n         task::join(t);\n     }\n-    \n+\n     log \"Completed: Final number is: \";\n-    assert (sum == number_of_messages * \n+    assert (sum == number_of_messages *\n            (number_of_tasks * number_of_tasks + number_of_tasks) / 2);\n }\n \n@@ -116,7 +116,7 @@ fn test05_start(chan[int] ch) {\n     ch <| 20;\n     ch <| 30;\n     ch <| 30;\n-    ch <| 30;    \n+    ch <| 30;\n }\n \n fn test05() {\n@@ -133,23 +133,23 @@ fn test06_start(int task_number) {\n     log \"Started task.\";\n     let int i = 0;\n     while (i < 100000000) {\n-        i = i + 1;    \n+        i = i + 1;\n     }\n     log \"Finished task.\";\n }\n-    \n+\n fn test06() {\n     let int number_of_tasks = 4;\n     log \"Creating tasks\";\n-    \n+\n     let int i = 0;\n-    \n+\n     let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         i = i + 1;\n         tasks += [spawn test06_start(i)];\n     }\n-    \n+\n     for (task t in tasks) {\n         task::join(t);\n     }"}, {"sha": "d6e92838efd14b759f5f00eee5119f5b85781e9b", "filename": "src/test/run-pass/task-compare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-compare.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -23,16 +23,16 @@ fn main() {\n \n     // ports\n     auto p1; auto p2;\n-    \n+\n     p1 = port[int]();\n     p2 = port[int]();\n \n     assert(p1 == p1);\n     assert(p1 != p2);\n-    \n+\n     // channels\n     auto c1; auto c2;\n-    \n+\n     c1 = chan(p1);\n     c2 = chan(p2);\n "}, {"sha": "a73773bab9aac5d87aa21d184dc6e2a4f97cc2f0", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -4,5 +4,5 @@ fn main() -> () {\n }\n \n fn child(str s) {\n-    \n+\n }"}, {"sha": "d39fa1a2eea9d84d9386c5642fc03ea1acde151e", "filename": "src/test/run-pass/while-loop-constraints-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39151f2ad8d18554af1d6787bae0b02345e1d90b/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs?ref=39151f2ad8d18554af1d6787bae0b02345e1d90b", "patch": "@@ -5,7 +5,7 @@ fn main() {\n   let int z = 42;\n   let int x;\n   while (z < 50) {\n-    z += 1; \n+    z += 1;\n     while (false) {\n       x <- y;\n       y = z;"}]}