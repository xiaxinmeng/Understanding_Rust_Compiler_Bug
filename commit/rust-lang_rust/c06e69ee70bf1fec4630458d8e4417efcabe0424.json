{"sha": "c06e69ee70bf1fec4630458d8e4417efcabe0424", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNmU2OWVlNzBiZjFmZWM0NjMwNDU4ZDhlNDQxN2VmY2FiZTA0MjQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-24T12:07:03Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-26T21:32:34Z"}, "message": "resolve: Fallback to uniform paths in 2015 imports used from global 2018 edition", "tree": {"sha": "f4a615546e5f256170db6e7307285ac16e1dc8a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4a615546e5f256170db6e7307285ac16e1dc8a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c06e69ee70bf1fec4630458d8e4417efcabe0424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c06e69ee70bf1fec4630458d8e4417efcabe0424", "html_url": "https://github.com/rust-lang/rust/commit/c06e69ee70bf1fec4630458d8e4417efcabe0424", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c06e69ee70bf1fec4630458d8e4417efcabe0424/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dae4c7b1ff62da4901caf28653baa3133a40496c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dae4c7b1ff62da4901caf28653baa3133a40496c", "html_url": "https://github.com/rust-lang/rust/commit/dae4c7b1ff62da4901caf28653baa3133a40496c"}], "stats": {"total": 223, "additions": 186, "deletions": 37}, "files": [{"sha": "2966e9ec9d9f1c1ba1ef9e92f288ffc24cd6bc31", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -132,9 +132,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // so prefixes are prepended with crate root segment if necessary.\n         // The root is prepended lazily, when the first non-empty prefix or terminating glob\n         // appears, so imports in braced groups can have roots prepended independently.\n+        // 2015 identifiers used on global 2018 edition enter special \"virtual 2015 mode\", don't\n+        // get crate root prepended, but get special treatment during in-scope resolution instead.\n         let is_glob = if let ast::UseTreeKind::Glob = use_tree.kind { true } else { false };\n         let crate_root = match prefix_iter.peek() {\n-            Some(seg) if !seg.ident.is_path_segment_keyword() && seg.ident.span.rust_2015() => {\n+            Some(seg) if !seg.ident.is_path_segment_keyword() &&\n+                         seg.ident.span.rust_2015() && self.session.rust_2015() => {\n                 Some(seg.ident.span.ctxt())\n             }\n             None if is_glob && use_tree.span.rust_2015() => {"}, {"sha": "07ded5c6723f2efcdc9e48dac42b789a25e2e6e8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -13,6 +13,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n+#![feature(label_break_value)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n@@ -2191,28 +2192,45 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n-        mut ident: Ident,\n+        ident: Ident,\n         ns: Namespace,\n         parent_scope: Option<&ParentScope<'a>>,\n         record_used: bool,\n         path_span: Span\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        ident.span = ident.span.modern();\n+        self.resolve_ident_in_module_ext(\n+            module, ident, ns, parent_scope, record_used, path_span\n+        ).map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    fn resolve_ident_in_module_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: Option<&ParentScope<'a>>,\n+        record_used: bool,\n+        path_span: Span\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let orig_current_module = self.current_module;\n         match module {\n             ModuleOrUniformRoot::Module(module) => {\n+                ident.span = ident.span.modern();\n                 if let Some(def) = ident.span.adjust(module.expansion) {\n                     self.current_module = self.macro_def_scope(def);\n                 }\n             }\n             ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude) => {\n+                ident.span = ident.span.modern();\n                 ident.span.adjust(Mark::root());\n             }\n-            _ => {}\n+            ModuleOrUniformRoot::UniformRoot(UniformRootKind::CurrentScope) => {\n+                // No adjustments\n+            }\n         }\n         let result = self.resolve_ident_in_module_unadjusted_ext(\n             module, ident, ns, parent_scope, false, record_used, path_span,\n-        ).map_err(|(determinacy, _)| determinacy);\n+        );\n         self.current_module = orig_current_module;\n         result\n     }"}, {"sha": "bc3700b8c6319050c9206b54a816b8392d462c15", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 72, "deletions": 30, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n-        mut ident: Ident,\n+        orig_ident: Ident,\n         ns: Namespace,\n         macro_kind: Option<MacroKind>,\n         is_import: bool,\n@@ -582,6 +582,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         enum WhereToResolve<'a> {\n             DeriveHelpers,\n             MacroRules(LegacyScope<'a>),\n+            CrateRoot,\n             Module(Module<'a>),\n             MacroUsePrelude,\n             BuiltinMacros,\n@@ -605,8 +606,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         assert!(force || !record_used); // `record_used` implies `force`\n         assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n-        let rust_2015 = ident.span.rust_2015();\n-        ident = ident.modern();\n+        let rust_2015 = orig_ident.span.rust_2015();\n+        let mut ident = orig_ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if ident.is_path_segment_keyword() {\n@@ -627,10 +628,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = if ns == MacroNS {\n-            WhereToResolve::DeriveHelpers\n-        } else {\n-            WhereToResolve::Module(parent_scope.module)\n+        let mut where_to_resolve = match ns {\n+            _ if is_import && rust_2015 => WhereToResolve::CrateRoot,\n+            TypeNS | ValueNS => WhereToResolve::Module(parent_scope.module),\n+            MacroNS => WhereToResolve::DeriveHelpers,\n         };\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         let mut determinacy = Determinacy::Determined;\n@@ -668,6 +669,26 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n+                WhereToResolve::CrateRoot => {\n+                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_module = self.resolve_crate_root(root_ident);\n+                    let binding = self.resolve_ident_in_module_ext(\n+                        ModuleOrUniformRoot::Module(root_module),\n+                        orig_ident,\n+                        ns,\n+                        None,\n+                        record_used,\n+                        path_span,\n+                    );\n+                    match binding {\n+                        Ok(binding) => Ok((binding, Flags::MODULE)),\n+                        Err((Determinacy::Undetermined, Weak::No)) =>\n+                            return Err(Determinacy::determined(force)),\n+                        Err((Determinacy::Undetermined, Weak::Yes)) =>\n+                            Err(Determinacy::Undetermined),\n+                        Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                    }\n+                }\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n                     let binding = self.resolve_ident_in_module_unadjusted_ext(\n@@ -816,7 +837,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n                                       flags.contains(Flags::MODULE) &&\n                                       !self.disambiguate_legacy_vs_modern(innermost_binding,\n-                                                                          binding) {\n+                                                                          binding) ||\n+                                      flags.contains(Flags::MACRO_RULES) &&\n+                                      innermost_flags.contains(Flags::MODULE) &&\n+                                      !self.disambiguate_legacy_vs_modern(binding,\n+                                                                          innermost_binding) {\n                                 Some(AmbiguityKind::LegacyVsModern)\n                             } else if innermost_binding.is_glob_import() {\n                                 Some(AmbiguityKind::GlobVsOuter)\n@@ -867,6 +892,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n                     LegacyScope::Uninitialized => unreachable!(),\n                 }\n+                WhereToResolve::CrateRoot => match ns {\n+                    TypeNS | ValueNS => WhereToResolve::Module(parent_scope.module),\n+                    MacroNS => WhereToResolve::DeriveHelpers,\n+                }\n                 WhereToResolve::Module(module) => {\n                     match self.hygienic_lexical_parent(module, &mut ident.span) {\n                         Some(parent_module) => WhereToResolve::Module(parent_module),\n@@ -899,30 +928,43 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         // The first found solution was the only one, return it.\n         if let Some((binding, flags)) = innermost_result {\n-            if is_import && !self.session.features_untracked().uniform_paths {\n-                // We get to here only if there's no ambiguity, in ambiguous cases an error will\n-                // be reported anyway, so there's no reason to report an additional feature error.\n-                // The `binding` can actually be introduced by something other than `--extern`,\n-                // but its `Def` should coincide with a crate passed with `--extern`\n-                // (otherwise there would be ambiguity) and we can skip feature error in this case.\n-                if ns != TypeNS || !use_prelude ||\n-                   self.extern_prelude_get(ident, true).is_none() {\n-                    let msg = \"imports can only refer to extern crate names \\\n-                               passed with `--extern` on stable channel\";\n-                    let mut err = feature_err(&self.session.parse_sess, \"uniform_paths\",\n-                                              ident.span, GateIssue::Language, msg);\n-\n-                    let what = self.binding_description(binding, ident,\n-                                                        flags.contains(Flags::MISC_FROM_PRELUDE));\n-                    let note_msg = format!(\"this import refers to {what}\", what = what);\n-                    if binding.span.is_dummy() {\n-                        err.note(&note_msg);\n-                    } else {\n-                        err.span_note(binding.span, &note_msg);\n-                        err.span_label(binding.span, \"not an extern crate passed with `--extern`\");\n+            // We get to here only if there's no ambiguity, in ambiguous cases an error will\n+            // be reported anyway, so there's no reason to report an additional feature error.\n+            // The `binding` can actually be introduced by something other than `--extern`,\n+            // but its `Def` should coincide with a crate passed with `--extern`\n+            // (otherwise there would be ambiguity) and we can skip feature error in this case.\n+            'ok: {\n+                if !is_import || self.session.features_untracked().uniform_paths {\n+                    break 'ok;\n+                }\n+                if ns == TypeNS && use_prelude && self.extern_prelude_get(ident, true).is_some() {\n+                    break 'ok;\n+                }\n+                if rust_2015 {\n+                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_module = self.resolve_crate_root(root_ident);\n+                    if self.resolve_ident_in_module_ext(ModuleOrUniformRoot::Module(root_module),\n+                                                        orig_ident, ns, None, false, path_span)\n+                                                        .is_ok() {\n+                        break 'ok;\n                     }\n-                    err.emit();\n                 }\n+\n+                let msg = \"imports can only refer to extern crate names \\\n+                           passed with `--extern` on stable channel\";\n+                let mut err = feature_err(&self.session.parse_sess, \"uniform_paths\",\n+                                          ident.span, GateIssue::Language, msg);\n+\n+                let what = self.binding_description(binding, ident,\n+                                                    flags.contains(Flags::MISC_FROM_PRELUDE));\n+                let note_msg = format!(\"this import refers to {what}\", what = what);\n+                if binding.span.is_dummy() {\n+                    err.note(&note_msg);\n+                } else {\n+                    err.span_note(binding.span, &note_msg);\n+                    err.span_label(binding.span, \"not an extern crate passed with `--extern`\");\n+                }\n+                err.emit();\n             }\n \n             return Ok(binding);"}, {"sha": "d7985d12dae619bafd2742d724a085533df89947", "filename": "src/test/ui/editions/auxiliary/edition-imports-2015.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -3,7 +3,7 @@\n #[macro_export]\n macro_rules! gen_imports { () => {\n     use import::Path;\n-    // use std::collections::LinkedList; // FIXME\n+    use std::collections::LinkedList;\n \n     fn check_absolute() {\n         ::absolute::Path;\n@@ -15,3 +15,16 @@ macro_rules! gen_imports { () => {\n macro_rules! gen_glob { () => {\n     use *;\n }}\n+\n+#[macro_export]\n+macro_rules! gen_gated { () => {\n+    fn check_gated() {\n+        enum E { A }\n+        use E::*;\n+    }\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_ambiguous { () => {\n+    use Ambiguous;\n+}}"}, {"sha": "989170d041fe72ac10d53e5e498d48b52f720804", "filename": "src/test/ui/editions/edition-imports-2018.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -17,7 +17,7 @@ mod check {\n \n     fn check() {\n         Path;\n-        // LinkedList::<u8>::new(); // FIXME\n+        LinkedList::<u8>::new();\n     }\n }\n "}, {"sha": "2527b30f07b332801c21330d0867be5a3c8abe8d", "filename": "src/test/ui/editions/edition-imports-virtual-2015-ambiguity.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -0,0 +1,18 @@\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+// error-pattern: `Ambiguous` is ambiguous\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+pub struct Ambiguous {}\n+\n+mod check {\n+    pub struct Ambiguous {}\n+\n+    fn check() {\n+        gen_ambiguous!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8e0b135121e0749dadb420d7fc2947501ba2f5c7", "filename": "src/test/ui/editions/edition-imports-virtual-2015-ambiguity.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.stderr?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -0,0 +1,21 @@\n+error[E0659]: `Ambiguous` is ambiguous (name vs any other name during import resolution)\n+  --> <::edition_imports_2015::gen_ambiguous macros>:1:15\n+   |\n+LL | (  ) => { use Ambiguous ; }\n+   |               ^^^^^^^^^ ambiguous name\n+   |\n+note: `Ambiguous` could refer to the struct defined here\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:8:1\n+   |\n+LL | pub struct Ambiguous {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+note: `Ambiguous` could also refer to the struct defined here\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:11:5\n+   |\n+LL |     pub struct Ambiguous {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::Ambiguous` to refer to this struct unambiguously\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "a1bf4f5eb51dc58e1edf69f8bab56653ea5b2f3c", "filename": "src/test/ui/editions/edition-imports-virtual-2015-gated.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.rs?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+// error-pattern: imports can only refer to extern crate names passed with `--extern`\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+mod check {\n+    gen_gated!();\n+}\n+\n+fn main() {}"}, {"sha": "7c1837e3f56e3e90275e6b6084e5481b63fb68fb", "filename": "src/test/ui/editions/edition-imports-virtual-2015-gated.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c06e69ee70bf1fec4630458d8e4417efcabe0424/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr?ref=c06e69ee70bf1fec4630458d8e4417efcabe0424", "patch": "@@ -0,0 +1,22 @@\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> <::edition_imports_2015::gen_gated macros>:1:50\n+   |\n+LL | (  ) => { fn check_gated (  ) { enum E { A } use E :: * ; } }\n+   |                                                  ^\n+   | \n+  ::: $DIR/edition-imports-virtual-2015-gated.rs:9:5\n+   |\n+LL |     gen_gated!();\n+   |     ------------- not an extern crate passed with `--extern`\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the enum defined here\n+  --> $DIR/edition-imports-virtual-2015-gated.rs:9:5\n+   |\n+LL |     gen_gated!();\n+   |     ^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}