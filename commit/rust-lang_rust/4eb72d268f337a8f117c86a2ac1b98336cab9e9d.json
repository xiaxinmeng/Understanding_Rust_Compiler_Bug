{"sha": "4eb72d268f337a8f117c86a2ac1b98336cab9e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYjcyZDI2OGYzMzdhOGYxMTdjODZhMmFjMWI5ODMzNmNhYjllOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-27T17:26:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-27T17:26:22Z"}, "message": "auto merge of #19112 : steveklabnik/rust/doc_rc, r=Gankro", "tree": {"sha": "a00fb37b04e02de08e3791f83ec745273aa69810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a00fb37b04e02de08e3791f83ec745273aa69810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eb72d268f337a8f117c86a2ac1b98336cab9e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb72d268f337a8f117c86a2ac1b98336cab9e9d", "html_url": "https://github.com/rust-lang/rust/commit/4eb72d268f337a8f117c86a2ac1b98336cab9e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eb72d268f337a8f117c86a2ac1b98336cab9e9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82fc1aa8756bf47679e09a30c5968da9f84b89e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/82fc1aa8756bf47679e09a30c5968da9f84b89e5", "html_url": "https://github.com/rust-lang/rust/commit/82fc1aa8756bf47679e09a30c5968da9f84b89e5"}, {"sha": "a1d983aa1619a3a6f9459b76ae9be06decd19b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d983aa1619a3a6f9459b76ae9be06decd19b94", "html_url": "https://github.com/rust-lang/rust/commit/a1d983aa1619a3a6f9459b76ae9be06decd19b94"}], "stats": {"total": 353, "additions": 296, "deletions": 57}, "files": [{"sha": "e626d63937bc2a84e00c93f2d268424a32985ed5", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 296, "deletions": 57, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/4eb72d268f337a8f117c86a2ac1b98336cab9e9d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb72d268f337a8f117c86a2ac1b98336cab9e9d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4eb72d268f337a8f117c86a2ac1b98336cab9e9d", "patch": "@@ -8,27 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task-local reference-counted boxes (the `Rc` type).\n+//! Task-local reference-counted boxes (the `Rc<T>` type).\n //!\n-//! The `Rc` type provides shared ownership of an immutable value. Destruction is\n-//! deterministic, and will occur as soon as the last owner is gone. It is marked\n-//! as non-sendable because it avoids the overhead of atomic reference counting.\n+//! The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic,\n+//! and will occur as soon as the last owner is gone. It is marked as non-sendable because it\n+//! avoids the overhead of atomic reference counting.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak` pointer to the\n-//! box. A `Weak` pointer can be upgraded to an `Rc` pointer, but will return\n-//! `None` if the value has already been freed.\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n+//! `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but will return `None` if the value\n+//! has already been dropped.\n //!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Rc` pointers, and then storing the parent pointers as\n-//! `Weak` pointers.\n+//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n+//! `Rc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n //!\n //! # Examples\n //!\n-//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n-//! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n-//! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s, and\n-//! have the `Owner` kept alive as long as any `Gadget` points at it.\n+//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.  We want to have our\n+//! `Gadget`s point to their `Owner`. We can't do this with unique ownership, because more than one\n+//! gadget may belong to the same `Owner`. `Rc<T>` allows us to share an `Owner` between multiple\n+//! `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```rust\n //! use std::rc::Rc;\n@@ -51,7 +49,7 @@\n //!     );\n //!\n //!     // Create Gadgets belonging to gadget_owner. To increment the reference\n-//!     // count we clone the Rc object.\n+//!     // count we clone the `Rc<T>` object.\n //!     let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n //!     let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n //!\n@@ -60,8 +58,8 @@\n //!     // Despite dropping gadget_owner, we're still able to print out the name of\n //!     // the Owner of the Gadgets. This is because we've only dropped the\n //!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other Rc objects pointing at the same Owner, it will stay alive. Notice\n-//!     // that the Rc wrapper around Gadget.owner gets automatically dereferenced\n+//!     // other `Rc<T>` objects pointing at the same Owner, it will remain allocated. Notice\n+//!     // that the `Rc<T>` wrapper around Gadget.owner gets automatically dereferenced\n //!     // for us.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n@@ -72,23 +70,19 @@\n //! }\n //! ```\n //!\n-//! If our requirements change, and we also need to be able to traverse from\n-//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc` pointer from Owner \u2192\u00a0Gadget\n-//! introduces a cycle between the objects. This means that their reference counts\n-//! can never reach 0, and the objects will stay alive: a memory leak. In order to\n-//! get around this, we can use `Weak` pointers. These are reference counted\n-//! pointers that don't keep an object alive if there are no normal `Rc` (or\n-//! *strong*) pointers left.\n+//! If our requirements change, and we also need to be able to traverse from Owner \u2192\u00a0Gadget, we\n+//! will run into problems: an `Rc<T>` pointer from Owner \u2192\u00a0Gadget introduces a cycle between the\n+//! objects. This means that their reference counts can never reach 0, and the objects will remain\n+//! allocated: a memory leak. In order to get around this, we can use `Weak<T>` pointers. These\n+//! pointers don't contribute to the total count.\n //!\n-//! Rust actually makes it somewhat difficult to produce this loop in the first\n-//! place: in order to end up with two objects that point at each other, one of\n-//! them needs to be mutable. This is problematic because `Rc` enforces memory\n-//! safety by only giving out shared references to the object it wraps, and these\n-//! don't allow direct mutation. We need to wrap the part of the object we wish to\n-//! mutate in a `RefCell`, which provides *interior mutability*: a method to\n-//! achieve mutability through a shared reference. `RefCell` enforces Rust's\n-//! borrowing rules at runtime. Read the `Cell` documentation for more details on\n-//! interior mutability.\n+//! Rust actually makes it somewhat difficult to produce this loop in the first place: in order to\n+//! end up with two objects that point at each other, one of them needs to be mutable. This is\n+//! problematic because `Rc<T>` enforces memory safety by only giving out shared references to the\n+//! object it wraps, and these don't allow direct mutation. We need to wrap the part of the object\n+//! we wish to mutate in a `RefCell`, which provides *interior mutability*: a method to achieve\n+//! mutability through a shared reference. `RefCell` enforces Rust's borrowing rules at runtime.\n+//! Read the `Cell` documentation for more details on interior mutability.\n //!\n //! ```rust\n //! use std::rc::Rc;\n@@ -131,15 +125,15 @@\n //!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still alive, we need to call upgrade() on them\n+//!         // that their object is still allocated, we need to call upgrade() on them\n //!         // to turn them into a strong reference. This returns an Option, which\n //!         // contains a reference to our object if it still exists.\n //!         let gadget = gadget_opt.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n //!\n //!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n-//!     // destroyed. There are now no strong (Rc) references to the gadgets.\n+//!     // destroyed. There are now no strong (`Rc<T>`) references to the gadgets.\n //!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n //!     // reference count on Gadget Man, so he gets destroyed as well.\n //! }\n@@ -169,6 +163,8 @@ struct RcBox<T> {\n }\n \n /// An immutable reference-counted pointer type.\n+///\n+/// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Rc<T> {\n@@ -180,7 +176,15 @@ pub struct Rc<T> {\n }\n \n impl<T> Rc<T> {\n-    /// Constructs a new reference-counted pointer.\n+    /// Constructs a new `Rc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    /// ```\n     #[stable]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n@@ -201,7 +205,17 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Downgrades the reference-counted pointer to a weak reference.\n+    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n     #[experimental = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -223,27 +237,36 @@ pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n #[experimental]\n pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n-/// Returns true if the `Rc` currently has unique ownership.\n+/// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::rc;\n+/// use std::rc::Rc;\n+///\n+/// let five = Rc::new(5i);\n ///\n-/// Unique ownership means that there are no other `Rc` or `Weak` values\n-/// that share the same contents.\n+/// rc::is_unique(&five);\n+/// ```\n #[inline]\n #[experimental]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n     weak_count(rc) == 0 && strong_count(rc) == 1\n }\n \n-/// Unwraps the contained value if the `Rc` has unique ownership.\n+/// Unwraps the contained value if the `Rc<T>` is unique.\n ///\n-/// If the `Rc` does not have unique ownership, `Err` is returned with the\n-/// same `Rc`.\n+/// If the `Rc<T>` is not unique, an `Err` is returned with the same `Rc<T>`.\n ///\n /// # Example\n ///\n /// ```\n /// use std::rc::{mod, Rc};\n+///\n /// let x = Rc::new(3u);\n /// assert_eq!(rc::try_unwrap(x), Ok(3u));\n+///\n /// let x = Rc::new(4u);\n /// let _y = x.clone();\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n@@ -266,18 +289,19 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     }\n }\n \n-/// Returns a mutable reference to the contained value if the `Rc` has\n-/// unique ownership.\n+/// Returns a mutable reference to the contained value if the `Rc<T>` is unique.\n ///\n-/// Returns `None` if the `Rc` does not have unique ownership.\n+/// Returns `None` if the `Rc<T>` is not unique.\n ///\n /// # Example\n ///\n /// ```\n /// use std::rc::{mod, Rc};\n+///\n /// let mut x = Rc::new(3u);\n /// *rc::get_mut(&mut x).unwrap() = 4u;\n /// assert_eq!(*x, 4u);\n+///\n /// let _y = x.clone();\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n@@ -293,11 +317,20 @@ pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Acquires a mutable pointer to the inner contents by guaranteeing that\n-    /// the reference count is one (no sharing is possible).\n+    /// Make a mutable reference from the given `Rc<T>`.\n+    ///\n+    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n+    /// the reference count is greater than one.\n+    ///\n+    /// # Examples\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::new(5i);\n+    ///\n+    /// let mut_five = five.make_unique();\n+    /// ```\n     #[inline]\n     #[experimental]\n     pub fn make_unique(&mut self) -> &mut T {\n@@ -307,16 +340,15 @@ impl<T: Clone> Rc<T> {\n         // This unsafety is ok because we're guaranteed that the pointer\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n-        // the Rc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n+        // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n+        // reference to the inner value.\n         let inner = unsafe { &mut *self._ptr };\n         &mut inner.value\n     }\n }\n \n #[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Rc<T> {\n-    /// Borrows the value contained in the reference-counted pointer.\n     #[inline(always)]\n     fn deref(&self) -> &T {\n         &self.inner().value\n@@ -326,6 +358,30 @@ impl<T> Deref<T> for Rc<T> {\n #[unsafe_destructor]\n #[experimental = \"Drop is experimental.\"]\n impl<T> Drop for Rc<T> {\n+    /// Drops the `Rc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference count becomes zero\n+    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n         unsafe {\n             if !self._ptr.is_null() {\n@@ -349,6 +405,19 @@ impl<T> Drop for Rc<T> {\n \n #[unstable = \"Clone is unstable.\"]\n impl<T> Clone for Rc<T> {\n+    /// Makes a clone of the `Rc<T>`.\n+    ///\n+    /// This increases the strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n@@ -358,6 +427,16 @@ impl<T> Clone for Rc<T> {\n \n #[stable]\n impl<T: Default> Default for Rc<T> {\n+    /// Creates a new `Rc<T>`, with the `Default` value for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    /// use std::default::Default;\n+    ///\n+    /// let x: Rc<int> = Default::default();\n+    /// ```\n     #[inline]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n@@ -366,8 +445,35 @@ impl<T: Default> Default for Rc<T> {\n \n #[unstable = \"PartialEq is unstable.\"]\n impl<T: PartialEq> PartialEq for Rc<T> {\n+    /// Equality for two `Rc<T>`s.\n+    ///\n+    /// Two `Rc<T>`s are equal if their inner value are equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five == Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n+\n+    /// Inequality for two `Rc<T>`s.\n+    ///\n+    /// Two `Rc<T>`s are unequal if their inner value are unequal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five != Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n@@ -377,26 +483,104 @@ impl<T: Eq> Eq for Rc<T> {}\n \n #[unstable = \"PartialOrd is unstable.\"]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n+    /// Partial comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `partial_cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.partial_cmp(&Rc::new(5i));\n+    /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n+    /// Less-than comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `<` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five < Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n \n+    /// 'Less-than or equal to' comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `<=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five <= Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n \n+    /// Greater-than comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `>` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five > Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n \n+    /// 'Greater-than or equal to' comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `>=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five >= Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n #[unstable = \"Ord is unstable.\"]\n impl<T: Ord> Ord for Rc<T> {\n+    /// Comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.partial_cmp(&Rc::new(5i));\n+    /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n@@ -408,7 +592,11 @@ impl<T: fmt::Show> fmt::Show for Rc<T> {\n     }\n }\n \n-/// A weak reference to a reference-counted pointer.\n+/// A weak version of `Rc<T>`.\n+///\n+/// Weak references do not count when determining if the inner value should be dropped.\n+///\n+/// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n@@ -423,8 +611,21 @@ pub struct Weak<T> {\n impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// ```\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -438,6 +639,31 @@ impl<T> Weak<T> {\n #[unsafe_destructor]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n         unsafe {\n             if !self._ptr.is_null() {\n@@ -455,6 +681,19 @@ impl<T> Drop for Weak<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Clone for Weak<T> {\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let weak_five = Rc::new(5i).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();"}]}