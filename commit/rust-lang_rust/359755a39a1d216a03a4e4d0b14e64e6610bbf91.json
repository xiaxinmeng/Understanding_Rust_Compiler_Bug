{"sha": "359755a39a1d216a03a4e4d0b14e64e6610bbf91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1OTc1NWEzOWExZDIxNmEwM2E0ZTRkMGIxNGU2NGU2NjEwYmJmOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-24T00:49:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-24T00:49:54Z"}, "message": "auto merge of #7885 : graydon/rust/workcache-fixes-1, r=pcwalton\n\nThis just redoes various parts of workcache to support context-cloning (eventually quite crudely, via ARCs), the absence of which was blocking rustpkg from being able to use it. Better versions of this are possible (notably removing the ARCs on everything except the database) but it ought to work well enough for now.", "tree": {"sha": "46946f9e8d0f097fdc08e8537bce297e2a21d829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46946f9e8d0f097fdc08e8537bce297e2a21d829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/359755a39a1d216a03a4e4d0b14e64e6610bbf91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/359755a39a1d216a03a4e4d0b14e64e6610bbf91", "html_url": "https://github.com/rust-lang/rust/commit/359755a39a1d216a03a4e4d0b14e64e6610bbf91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/359755a39a1d216a03a4e4d0b14e64e6610bbf91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "995440943839ecbdd1b5876244b3b8f390c97dfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/995440943839ecbdd1b5876244b3b8f390c97dfa", "html_url": "https://github.com/rust-lang/rust/commit/995440943839ecbdd1b5876244b3b8f390c97dfa"}, {"sha": "ff0c2ae8124661b1bdc233f77126e312671563e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0c2ae8124661b1bdc233f77126e312671563e9", "html_url": "https://github.com/rust-lang/rust/commit/ff0c2ae8124661b1bdc233f77126e312671563e9"}], "stats": {"total": 365, "additions": 199, "deletions": 166}, "files": [{"sha": "6a7f0607dd66aa3240f999534240302839ec4ca0", "filename": "src/libextra/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=359755a39a1d216a03a4e4d0b14e64e6610bbf91", "patch": "@@ -41,7 +41,7 @@ pub enum Json {\n }\n \n pub type List = ~[Json];\n-pub type Object = HashMap<~str, Json>;\n+pub type Object = TreeMap<~str, Json>;\n \n #[deriving(Eq)]\n /// If an error occurs while parsing some JSON, this is the structure which is\n@@ -809,7 +809,7 @@ impl<T : iterator::Iterator<char>> Parser<T> {\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = ~HashMap::new();\n+        let mut values = ~TreeMap::new();\n \n         if self.ch == '}' {\n           self.bump();\n@@ -1087,7 +1087,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n-                for obj.consume().advance |(key, value)| {\n+                for obj.consume_iter().advance |(key, value)| {\n                     self.stack.push(value);\n                     self.stack.push(String(key));\n                 }\n@@ -1294,19 +1294,19 @@ impl<A:ToJson> ToJson for ~[A] {\n     fn to_json(&self) -> Json { List(self.map(|elt| elt.to_json())) }\n }\n \n-impl<A:ToJson> ToJson for HashMap<~str, A> {\n+impl<A:ToJson> ToJson for TreeMap<~str, A> {\n     fn to_json(&self) -> Json {\n-        let mut d = HashMap::new();\n+        let mut d = TreeMap::new();\n         for self.iter().advance |(key, value)| {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n     }\n }\n \n-impl<A:ToJson> ToJson for TreeMap<~str, A> {\n+impl<A:ToJson> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n-        let mut d = HashMap::new();\n+        let mut d = TreeMap::new();\n         for self.iter().advance |(key, value)| {\n             d.insert((*key).clone(), value.to_json());\n         }\n@@ -1338,11 +1338,11 @@ mod tests {\n \n     use super::*;\n \n-    use std::hashmap::HashMap;\n     use std::io;\n     use std::result;\n \n-    use extra::serialize::Decodable;\n+    use serialize::Decodable;\n+    use treemap::TreeMap;\n \n     #[deriving(Eq, Encodable, Decodable)]\n     enum Animal {\n@@ -1363,7 +1363,7 @@ mod tests {\n     }\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n-        let mut d = ~HashMap::new();\n+        let mut d = ~TreeMap::new();\n \n         for items.iter().advance |item| {\n             match *item {\n@@ -1954,7 +1954,7 @@ mod tests {\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n         let mut decoder = Decoder(from_str(s).unwrap());\n-        let mut map: HashMap<~str, Animal> = Decodable::decode(&mut decoder);\n+        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n         assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));"}, {"sha": "a5705d08b72bed1ef28c903c8a1c181cd9136e7d", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=359755a39a1d216a03a4e4d0b14e64e6610bbf91", "patch": "@@ -38,7 +38,6 @@ use std::task;\n use std::to_str::ToStr;\n use std::u64;\n use std::f64;\n-use std::hashmap::HashMap;\n use std::os;\n \n \n@@ -852,7 +851,7 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n \n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n-        let mut map = ~HashMap::new();\n+        let mut map = ~TreeMap::new();\n         map.insert(~\"value\", json::Number(self.value as float));\n         map.insert(~\"noise\", json::Number(self.noise as float));\n         json::Object(map)"}, {"sha": "4ad1f56a9ae54a77e610dc5df53f7011a9f5c4ec", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=359755a39a1d216a03a4e4d0b14e64e6610bbf91", "patch": "@@ -204,6 +204,19 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root, remaining: self.length}\n     }\n+\n+    /// Get a lazy iterator that consumes the treemap.\n+    pub fn consume_iter(self) -> TreeMapConsumeIterator<K, V> {\n+        let TreeMap { root: root, length: length } = self;\n+        let stk = match root {\n+            None => ~[],\n+            Some(~tn) => ~[tn]\n+        };\n+        TreeMapConsumeIterator {\n+            stack: stk,\n+            remaining: length\n+        }\n+    }\n }\n \n /// Lazy forward iterator over a map\n@@ -241,6 +254,56 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n     }\n }\n \n+/// Lazy forward iterator over a map that consumes the map while iterating\n+pub struct TreeMapConsumeIterator<K, V> {\n+    priv stack: ~[TreeNode<K, V>],\n+    priv remaining: uint\n+}\n+\n+impl<K, V> Iterator<(K, V)> for TreeMapConsumeIterator<K,V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        while !self.stack.is_empty() {\n+            let TreeNode {\n+                key: key,\n+                value: value,\n+                left: left,\n+                right: right,\n+                level: level\n+            } = self.stack.pop();\n+\n+            match left {\n+                Some(~left) => {\n+                    let n = TreeNode {\n+                        key: key,\n+                        value: value,\n+                        left: None,\n+                        right: right,\n+                        level: level\n+                    };\n+                    self.stack.push(n);\n+                    self.stack.push(left);\n+                }\n+                None => {\n+                    match right {\n+                        Some(~right) => self.stack.push(right),\n+                        None => ()\n+                    }\n+                    self.remaining -= 1;\n+                    return Some((key, value))\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.remaining, Some(self.remaining))\n+    }\n+\n+}\n+\n impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]"}, {"sha": "42210d0cd895c392ce8237492f6b1a7e2c527b02", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 124, "deletions": 153, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/359755a39a1d216a03a4e4d0b14e64e6610bbf91/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=359755a39a1d216a03a4e4d0b14e64e6610bbf91", "patch": "@@ -15,18 +15,16 @@ use digest::DigestUtil;\n use json;\n use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n-use sort;\n+use arc::{ARC,RWARC};\n+use treemap::TreeMap;\n \n use std::cell::Cell;\n-use std::cmp;\n use std::comm::{PortOne, oneshot, send_one, recv_one};\n use std::either::{Either, Left, Right};\n-use std::hashmap::HashMap;\n use std::io;\n use std::result;\n use std::run;\n use std::task;\n-use std::to_bytes;\n \n /**\n *\n@@ -96,36 +94,12 @@ use std::to_bytes;\n *\n */\n \n-#[deriving(Clone, Eq, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Encodable, Decodable, TotalOrd, TotalEq)]\n struct WorkKey {\n     kind: ~str,\n     name: ~str\n }\n \n-impl to_bytes::IterBytes for WorkKey {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.kind.iter_bytes(lsb0, |b| f(b)) && self.name.iter_bytes(lsb0, |b| f(b))\n-    }\n-}\n-\n-impl cmp::Ord for WorkKey {\n-    fn lt(&self, other: &WorkKey) -> bool {\n-        self.kind < other.kind ||\n-            (self.kind == other.kind &&\n-             self.name < other.name)\n-    }\n-    fn le(&self, other: &WorkKey) -> bool {\n-        self.lt(other) || self.eq(other)\n-    }\n-    fn ge(&self, other: &WorkKey) -> bool {\n-        self.gt(other) || self.eq(other)\n-    }\n-    fn gt(&self, other: &WorkKey) -> bool {\n-        ! self.le(other)\n-    }\n-}\n-\n impl WorkKey {\n     pub fn new(kind: &str, name: &str) -> WorkKey {\n         WorkKey {\n@@ -135,48 +109,30 @@ impl WorkKey {\n     }\n }\n \n-struct WorkMap(HashMap<WorkKey, ~str>);\n-\n-impl Clone for WorkMap {\n-    fn clone(&self) -> WorkMap {\n-        WorkMap((**self).clone())\n-    }\n-}\n+#[deriving(Clone, Eq, Encodable, Decodable)]\n+struct WorkMap(TreeMap<WorkKey, ~str>);\n \n impl WorkMap {\n-    fn new() -> WorkMap { WorkMap(HashMap::new()) }\n-}\n-\n-impl<S:Encoder> Encodable<S> for WorkMap {\n-    fn encode(&self, s: &mut S) {\n-        let mut d = ~[];\n-        for self.iter().advance |(k, v)| {\n-            d.push(((*k).clone(), (*v).clone()))\n-        }\n-        sort::tim_sort(d);\n-        d.encode(s)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for WorkMap {\n-    fn decode(d: &mut D) -> WorkMap {\n-        let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n-        let mut w = WorkMap::new();\n-        for v.iter().advance |pair| {\n-            w.insert(pair.first(), pair.second());\n-        }\n-        w\n-    }\n+    fn new() -> WorkMap { WorkMap(TreeMap::new()) }\n }\n \n struct Database {\n     db_filename: Path,\n-    db_cache: HashMap<~str, ~str>,\n+    db_cache: TreeMap<~str, ~str>,\n     db_dirty: bool\n }\n \n impl Database {\n-    pub fn prepare(&mut self,\n+\n+    pub fn new(p: Path) -> Database {\n+        Database {\n+            db_filename: p,\n+            db_cache: TreeMap::new(),\n+            db_dirty: false\n+        }\n+    }\n+\n+    pub fn prepare(&self,\n                    fn_name: &str,\n                    declared_inputs: &WorkMap)\n                    -> Option<(WorkMap, WorkMap, ~str)> {\n@@ -208,22 +164,27 @@ struct Logger {\n }\n \n impl Logger {\n+\n+    pub fn new() -> Logger {\n+        Logger { a: () }\n+    }\n+\n     pub fn info(&self, i: &str) {\n         io::println(~\"workcache: \" + i);\n     }\n }\n \n+#[deriving(Clone)]\n struct Context {\n-    db: @mut Database,\n-    logger: @mut Logger,\n-    cfg: @json::Object,\n-    freshness: HashMap<~str,@fn(&str,&str)->bool>\n+    db: RWARC<Database>,\n+    logger: RWARC<Logger>,\n+    cfg: ARC<json::Object>,\n+    freshness: ARC<TreeMap<~str,extern fn(&str,&str)->bool>>\n }\n \n-#[deriving(Clone)]\n-struct Prep {\n-    ctxt: @Context,\n-    fn_name: ~str,\n+struct Prep<'self> {\n+    ctxt: &'self Context,\n+    fn_name: &'self str,\n     declared_inputs: WorkMap,\n }\n \n@@ -232,8 +193,8 @@ struct Exec {\n     discovered_outputs: WorkMap\n }\n \n-struct Work<T> {\n-    prep: @mut Prep,\n+struct Work<'self, T> {\n+    prep: &'self Prep<'self>,\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n@@ -267,43 +228,40 @@ fn digest_file(path: &Path) -> ~str {\n }\n \n impl Context {\n-    pub fn new(db: @mut Database, lg: @mut Logger, cfg: @json::Object)\n-               -> Context {\n+\n+    pub fn new(db: RWARC<Database>,\n+               lg: RWARC<Logger>,\n+               cfg: ARC<json::Object>) -> Context {\n         Context {\n             db: db,\n             logger: lg,\n             cfg: cfg,\n-            freshness: HashMap::new()\n+            freshness: ARC(TreeMap::new())\n         }\n     }\n \n-    pub fn prep<T:Send +\n-                  Encodable<json::Encoder> +\n-                  Decodable<json::Decoder>>(@self, // FIXME(#5121)\n-                                            fn_name:&str,\n-                                            blk: &fn(@mut Prep)->Work<T>)\n-                                            -> Work<T> {\n-        let p = @mut Prep {\n-            ctxt: self,\n-            fn_name: fn_name.to_owned(),\n-            declared_inputs: WorkMap::new()\n-        };\n-        blk(p)\n+    pub fn prep<'a>(&'a self, fn_name: &'a str) -> Prep<'a> {\n+        Prep::new(self, fn_name)\n     }\n-}\n \n+    pub fn with_prep<'a, T>(&'a self, fn_name: &'a str, blk: &fn(p: &mut Prep) -> T) -> T {\n+        let mut p = self.prep(fn_name);\n+        blk(&mut p)\n+    }\n \n-trait TPrep {\n-    fn declare_input(&mut self, kind:&str, name:&str, val:&str);\n-    fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n-    fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n-    fn exec<T:Send +\n-              Encodable<json::Encoder> +\n-              Decodable<json::Decoder>>( // FIXME(#5121)\n-        &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n-impl TPrep for Prep {\n+impl<'self> Prep<'self> {\n+    fn new(ctxt: &'self Context, fn_name: &'self str) -> Prep<'self> {\n+        Prep {\n+            ctxt: ctxt,\n+            fn_name: fn_name,\n+            declared_inputs: WorkMap::new()\n+        }\n+    }\n+}\n+\n+impl<'self> Prep<'self> {\n     fn declare_input(&mut self, kind:&str, name:&str, val:&str) {\n         self.declared_inputs.insert(WorkKey::new(kind, name),\n                                  val.to_owned());\n@@ -312,16 +270,21 @@ impl TPrep for Prep {\n     fn is_fresh(&self, cat: &str, kind: &str,\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n-        let f = (*self.ctxt.freshness.get(&k))(name, val);\n-        let lg = self.ctxt.logger;\n-            if f {\n+        let f = self.ctxt.freshness.get().find(&k);\n+        let fresh = match f {\n+            None => fail!(\"missing freshness-function for '%s'\", kind),\n+            Some(f) => (*f)(name, val)\n+        };\n+        do self.ctxt.logger.write |lg| {\n+            if fresh {\n                 lg.info(fmt!(\"%s %s:%s is fresh\",\n                              cat, kind, name));\n             } else {\n                 lg.info(fmt!(\"%s %s:%s is not fresh\",\n                              cat, kind, name))\n             }\n-        f\n+        };\n+        fresh\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n@@ -334,20 +297,28 @@ impl TPrep for Prep {\n     }\n \n     fn exec<T:Send +\n-              Encodable<json::Encoder> +\n-              Decodable<json::Decoder>>( // FIXME(#5121)\n-            &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n+        Encodable<json::Encoder> +\n+        Decodable<json::Decoder>>(\n+            &'self self, blk: ~fn(&Exec) -> T) -> T {\n+        self.exec_work(blk).unwrap()\n+    }\n+\n+    fn exec_work<T:Send +\n+        Encodable<json::Encoder> +\n+        Decodable<json::Decoder>>( // FIXME(#5121)\n+            &'self self, blk: ~fn(&Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n-        let cached = self.ctxt.db.prepare(self.fn_name, &self.declared_inputs);\n+        let cached = do self.ctxt.db.read |db| {\n+            db.prepare(self.fn_name, &self.declared_inputs)\n+        };\n \n-        match cached {\n+        let res = match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n-            if self.all_fresh(\"declared input\",\n-                              &self.declared_inputs) &&\n-            self.all_fresh(\"discovered input\", disc_in) &&\n-            self.all_fresh(\"discovered output\", disc_out) => {\n-                Work::new(@mut (*self).clone(), Left(json_decode(*res)))\n+            if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n+               self.all_fresh(\"discovered input\", disc_in) &&\n+               self.all_fresh(\"discovered output\", disc_out) => {\n+                Left(json_decode(*res))\n             }\n \n             _ => {\n@@ -364,72 +335,72 @@ impl TPrep for Prep {\n                     let v = blk(&exe);\n                     send_one(chan, (exe, v));\n                 }\n-                Work::new(@mut (*self).clone(), Right(port))\n+                Right(port)\n             }\n-        }\n+        };\n+        Work::new(self, res)\n     }\n }\n \n-impl<T:Send +\n+impl<'self, T:Send +\n        Encodable<json::Encoder> +\n-       Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n-    pub fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+       Decodable<json::Decoder>>\n+    Work<'self, T> { // FIXME(#5121)\n+\n+    pub fn new(p: &'self Prep<'self>, e: Either<T,PortOne<(Exec,T)>>) -> Work<'self, T> {\n         Work { prep: p, res: Some(e) }\n     }\n-}\n \n-// FIXME (#3724): movable self. This should be in impl Work.\n-fn unwrap<T:Send +\n-            Encodable<json::Encoder> +\n-            Decodable<json::Decoder>>( // FIXME(#5121)\n-        w: Work<T>) -> T {\n-    let mut ww = w;\n-    let s = ww.res.take();\n-\n-    match s {\n-        None => fail!(),\n-        Some(Left(v)) => v,\n-        Some(Right(port)) => {\n-            let (exe, v) = recv_one(port);\n-\n-            let s = json_encode(&v);\n-\n-            let p = &*ww.prep;\n-            let db = p.ctxt.db;\n-            db.cache(p.fn_name,\n-                 &p.declared_inputs,\n-                 &exe.discovered_inputs,\n-                 &exe.discovered_outputs,\n-                 s);\n-            v\n+    pub fn unwrap(self) -> T {\n+        let Work { prep, res } = self;\n+        match res {\n+            None => fail!(),\n+            Some(Left(v)) => v,\n+            Some(Right(port)) => {\n+                let (exe, v) = recv_one(port);\n+                let s = json_encode(&v);\n+                do prep.ctxt.db.write |db| {\n+                    db.cache(prep.fn_name,\n+                             &prep.declared_inputs,\n+                             &exe.discovered_inputs,\n+                             &exe.discovered_outputs,\n+                             s);\n+                }\n+                v\n+            }\n         }\n     }\n }\n \n+\n //#[test]\n fn test() {\n     use std::io::WriterUtil;\n \n-    let db = @mut Database { db_filename: Path(\"db.json\"),\n-                             db_cache: HashMap::new(),\n-                             db_dirty: false };\n-    let lg = @mut Logger { a: () };\n-    let cfg = @HashMap::new();\n-    let cx = @Context::new(db, lg, cfg);\n-    let w:Work<~str> = do cx.prep(\"test1\") |prep| {\n-        let pth = Path(\"foo.c\");\n-        {\n-            let file = io::file_writer(&pth, [io::Create]).unwrap();\n-            file.write_str(\"int main() { return 0; }\");\n-        }\n+    let pth = Path(\"foo.c\");\n+    {\n+        let r = io::file_writer(&pth, [io::Create]);\n+        r.get_ref().write_str(\"int main() { return 0; }\");\n+    }\n+\n+    let cx = Context::new(RWARC(Database::new(Path(\"db.json\"))),\n+                          RWARC(Logger::new()),\n+                          ARC(TreeMap::new()));\n+\n+    let s = do cx.with_prep(\"test1\") |prep| {\n+\n+        let subcx = cx.clone();\n \n         prep.declare_input(\"file\", pth.to_str(), digest_file(&pth));\n         do prep.exec |_exe| {\n             let out = Path(\"foo.o\");\n             run::process_status(\"gcc\", [~\"foo.c\", ~\"-o\", out.to_str()]);\n+\n+            let _proof_of_concept = subcx.prep(\"subfn\");\n+            // Could run sub-rules inside here.\n+\n             out.to_str()\n         }\n     };\n-    let s = unwrap(w);\n     io::println(s);\n }"}]}