{"sha": "8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNWMwZWY3YjkxMGZmYWZjOWM2ODRjYjcwNzYxNDlhYjc5ZjRiZGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-13T19:06:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-13T19:06:18Z"}, "message": "Merge #9256\n\n9256: internal: kill diagnostic sink r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "cb85647c41d797b885ac579312043df4b3112648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb85647c41d797b885ac579312043df4b3112648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxlcqCRBK7hj4Ov3rIwAALEsIABA/fUsA9VtS4ok08BYD3q1y\nYaP3Ks4SUJUyNu73iG4rVlRUc+Mqsti1K28Xh0E3MujHpQ2yyBnprUlt9phnmLG4\n6fiKE6537zP9sAtCMw0Fl1aRtXSIfM11AGmNBSlVbaxz6fsvjxh0oj1Yw/sEZOWG\nzeIiCiv8CClsGumLDhHc+7l5fXinIKzOZ2+IAFhyK9hJzrdUBxLu8h/LW/1mgNec\nq13FQDHmsY4aUf6nXfqoEhVKo3bxYoyNLx/XqZRcAGsm7AqGbVg6HhyiP1XQZfNo\nWLddCqNtKD9uEUo/qGBjZp+ymK2ClwfnfsEeqt9v5W4pozM2LDasPZKOMTdeq8E=\n=eJv6\n-----END PGP SIGNATURE-----\n", "payload": "tree cb85647c41d797b885ac579312043df4b3112648\nparent 76530664e7f01091e0d820eb49bf59db1f06115c\nparent ff52167c9a8dd6f99a56a35eae8d634d0ddf1286\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623611178 +0000\ncommitter GitHub <noreply@github.com> 1623611178 +0000\n\nMerge #9256\n\n9256: internal: kill diagnostic sink r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "html_url": "https://github.com/rust-lang/rust/commit/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76530664e7f01091e0d820eb49bf59db1f06115c", "url": "https://api.github.com/repos/rust-lang/rust/commits/76530664e7f01091e0d820eb49bf59db1f06115c", "html_url": "https://github.com/rust-lang/rust/commit/76530664e7f01091e0d820eb49bf59db1f06115c"}, {"sha": "ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "html_url": "https://github.com/rust-lang/rust/commit/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286"}], "stats": {"total": 2122, "additions": 965, "deletions": 1157}, "files": [{"sha": "b4c505898e6f97eabad15ed800bdd4072c4b013b", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "patch": "@@ -3,18 +3,12 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnistics should\n //! be expressed in terms of hir types themselves.\n-use std::any::Any;\n-\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-pub use crate::diagnostics_sink::{\n-    Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n-};\n-\n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n         pub enum AnyDiagnostic {$(\n@@ -38,6 +32,7 @@ diagnostics![\n     MacroError,\n     MismatchedArgCount,\n     MissingFields,\n+    MissingMatchArms,\n     MissingOkOrSomeInTailExpr,\n     MissingUnsafe,\n     NoSuchField,\n@@ -149,50 +144,11 @@ pub struct MissingOkOrSomeInTailExpr {\n     pub required: String,\n }\n \n-// Diagnostic: missing-match-arm\n-//\n-// This diagnostic is triggered if `match` block is missing one or more match arms.\n #[derive(Debug)]\n pub struct MissingMatchArms {\n     pub file: HirFileId,\n     pub match_expr: AstPtr<ast::Expr>,\n     pub arms: AstPtr<ast::MatchArmList>,\n }\n \n-impl Diagnostic for MissingMatchArms {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-match-arm\")\n-    }\n-    fn message(&self) -> String {\n-        String::from(\"Missing match arm\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.match_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct InternalBailedOut {\n-    pub file: HirFileId,\n-    pub pat_syntax_ptr: SyntaxNodePtr,\n-}\n-\n-impl Diagnostic for InternalBailedOut {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"internal:match-check-bailed-out\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"Internal: match check bailed out\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.pat_syntax_ptr.clone() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "084fa8b06aa2c4eb53abcf8ba1cb624c2cc5d640", "filename": "crates/hir/src/diagnostics_sink.rs", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -1,109 +0,0 @@\n-//! Semantic errors and warnings.\n-//!\n-//! The `Diagnostic` trait defines a trait object which can represent any\n-//! diagnostic.\n-//!\n-//! `DiagnosticSink` struct is used as an emitter for diagnostic. When creating\n-//! a `DiagnosticSink`, you supply a callback which can react to a `dyn\n-//! Diagnostic` or to any concrete diagnostic (downcasting is used internally).\n-//!\n-//! Because diagnostics store file offsets, it's a bad idea to store them\n-//! directly in salsa. For this reason, every hir subsytem defines it's own\n-//! strongly-typed closed set of diagnostics which use hir ids internally, are\n-//! stored in salsa and do *not* implement the `Diagnostic` trait. Instead, a\n-//! subsystem provides a separate, non-query-based API which can walk all stored\n-//! values and transform them into instances of `Diagnostic`.\n-\n-use std::{any::Any, fmt};\n-\n-use hir_expand::InFile;\n-use syntax::SyntaxNodePtr;\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct DiagnosticCode(pub &'static str);\n-\n-impl DiagnosticCode {\n-    pub fn as_str(&self) -> &str {\n-        self.0\n-    }\n-}\n-\n-pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n-    fn code(&self) -> DiagnosticCode;\n-    fn message(&self) -> String;\n-    /// Source element that triggered the diagnostics.\n-    ///\n-    /// Note that this should reflect \"semantics\", rather than specific span we\n-    /// want to highlight. When rendering the diagnostics into an error message,\n-    /// the IDE will fetch the `SyntaxNode` and will narrow the span\n-    /// appropriately.\n-    fn display_source(&self) -> InFile<SyntaxNodePtr>;\n-    fn as_any(&self) -> &(dyn Any + Send + 'static);\n-    fn is_experimental(&self) -> bool {\n-        false\n-    }\n-}\n-\n-pub struct DiagnosticSink<'a> {\n-    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n-    filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n-    default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n-}\n-\n-impl<'a> DiagnosticSink<'a> {\n-    pub fn push(&mut self, d: impl Diagnostic) {\n-        let d: &dyn Diagnostic = &d;\n-        self._push(d);\n-    }\n-\n-    fn _push(&mut self, d: &dyn Diagnostic) {\n-        for filter in &mut self.filters {\n-            if !filter(d) {\n-                return;\n-            }\n-        }\n-        for cb in &mut self.callbacks {\n-            match cb(d) {\n-                Ok(()) => return,\n-                Err(()) => (),\n-            }\n-        }\n-        (self.default_callback)(d)\n-    }\n-}\n-\n-pub struct DiagnosticSinkBuilder<'a> {\n-    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n-    filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n-}\n-\n-impl<'a> DiagnosticSinkBuilder<'a> {\n-    pub fn new() -> Self {\n-        Self { callbacks: Vec::new(), filters: Vec::new() }\n-    }\n-\n-    pub fn filter<F: FnMut(&dyn Diagnostic) -> bool + 'a>(mut self, cb: F) -> Self {\n-        self.filters.push(Box::new(cb));\n-        self\n-    }\n-\n-    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> Self {\n-        let cb = move |diag: &dyn Diagnostic| match diag.as_any().downcast_ref::<D>() {\n-            Some(d) => {\n-                cb(d);\n-                Ok(())\n-            }\n-            None => Err(()),\n-        };\n-        self.callbacks.push(Box::new(cb));\n-        self\n-    }\n-\n-    pub fn build<F: FnMut(&dyn Diagnostic) + 'a>(self, default_callback: F) -> DiagnosticSink<'a> {\n-        DiagnosticSink {\n-            callbacks: self.callbacks,\n-            filters: self.filters,\n-            default_callback: Box::new(default_callback),\n-        }\n-    }\n-}"}, {"sha": "ce38396d07951725dff00ad07a3517ad79530005", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 17, "deletions": 46, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "patch": "@@ -27,7 +27,6 @@ mod attrs;\n mod has_source;\n \n pub mod diagnostics;\n-pub mod diagnostics_sink;\n pub mod db;\n \n mod display;\n@@ -78,16 +77,13 @@ use syntax::{\n };\n use tt::{Ident, Leaf, Literal, TokenTree};\n \n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    diagnostics_sink::DiagnosticSink,\n-};\n+use crate::db::{DefDatabase, HirDatabase};\n \n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InternalBailedOut,\n-        MacroError, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, MacroError,\n+        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n         UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedModule, UnresolvedProcMacro,\n@@ -457,16 +453,10 @@ impl Module {\n         self.id.def_map(db.upcast())[self.id.local_id].scope.visibility_of((*def).into())\n     }\n \n-    pub fn diagnostics(\n-        self,\n-        db: &dyn HirDatabase,\n-        sink: &mut DiagnosticSink,\n-        internal_diagnostics: bool,\n-    ) -> Vec<AnyDiagnostic> {\n+    pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n         });\n-        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n         let def_map = self.id.def_map(db.upcast());\n         for diag in def_map.diagnostics() {\n             if diag.in_module != self.id.local_id {\n@@ -619,11 +609,11 @@ impl Module {\n         }\n         for decl in self.declarations(db) {\n             match decl {\n-                ModuleDef::Function(f) => acc.extend(f.diagnostics(db, sink, internal_diagnostics)),\n+                ModuleDef::Function(f) => f.diagnostics(db, acc),\n                 ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n-                        acc.extend(m.diagnostics(db, sink, internal_diagnostics))\n+                        m.diagnostics(db, acc)\n                     }\n                 }\n                 _ => acc.extend(decl.diagnostics(db)),\n@@ -633,11 +623,10 @@ impl Module {\n         for impl_def in self.impl_defs(db) {\n             for item in impl_def.items(db) {\n                 if let AssocItem::Function(f) = item {\n-                    acc.extend(f.diagnostics(db, sink, internal_diagnostics));\n+                    f.diagnostics(db, acc);\n                 }\n             }\n         }\n-        acc\n     }\n \n     pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n@@ -1036,13 +1025,7 @@ impl Function {\n         db.function_data(self.id).is_async()\n     }\n \n-    pub fn diagnostics(\n-        self,\n-        db: &dyn HirDatabase,\n-        sink: &mut DiagnosticSink,\n-        internal_diagnostics: bool,\n-    ) -> Vec<AnyDiagnostic> {\n-        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n+    pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n         let source_map = db.body_with_source_map(self.id.into()).1;\n@@ -1100,9 +1083,7 @@ impl Function {\n             }\n         }\n \n-        for diagnostic in\n-            BodyValidationDiagnostic::collect(db, self.id.into(), internal_diagnostics)\n-        {\n+        for diagnostic in BodyValidationDiagnostic::collect(db, self.id.into()) {\n             match diagnostic {\n                 BodyValidationDiagnostic::RecordMissingFields {\n                     record,\n@@ -1209,36 +1190,26 @@ impl Function {\n                                 if let (Some(match_expr), Some(arms)) =\n                                     (match_expr.expr(), match_expr.match_arm_list())\n                                 {\n-                                    sink.push(MissingMatchArms {\n-                                        file: source_ptr.file_id,\n-                                        match_expr: AstPtr::new(&match_expr),\n-                                        arms: AstPtr::new(&arms),\n-                                    })\n+                                    acc.push(\n+                                        MissingMatchArms {\n+                                            file: source_ptr.file_id,\n+                                            match_expr: AstPtr::new(&match_expr),\n+                                            arms: AstPtr::new(&arms),\n+                                        }\n+                                        .into(),\n+                                    )\n                                 }\n                             }\n                         }\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                BodyValidationDiagnostic::InternalBailedOut { pat } => {\n-                    match source_map.pat_syntax(pat) {\n-                        Ok(source_ptr) => {\n-                            let pat_syntax_ptr = source_ptr.value.either(Into::into, Into::into);\n-                            sink.push(InternalBailedOut {\n-                                file: source_ptr.file_id,\n-                                pat_syntax_ptr,\n-                            });\n-                        }\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n             }\n         }\n \n         for diag in hir_ty::diagnostics::validate_module_item(db, krate, self.id.into()) {\n             acc.push(diag.into())\n         }\n-        acc\n     }\n \n     /// Whether this function declaration has a definition."}, {"sha": "b809b96a0f60074ebd874b4fef5ae21be9e18c60", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "patch": "@@ -50,21 +50,13 @@ pub enum BodyValidationDiagnostic {\n     MissingMatchArms {\n         match_expr: ExprId,\n     },\n-    InternalBailedOut {\n-        pat: PatId,\n-    },\n }\n \n impl BodyValidationDiagnostic {\n-    pub fn collect(\n-        db: &dyn HirDatabase,\n-        owner: DefWithBodyId,\n-        internal_diagnostics: bool,\n-    ) -> Vec<BodyValidationDiagnostic> {\n+    pub fn collect(db: &dyn HirDatabase, owner: DefWithBodyId) -> Vec<BodyValidationDiagnostic> {\n         let _p = profile::span(\"BodyValidationDiagnostic::collect\");\n         let infer = db.infer(owner);\n         let mut validator = ExprValidator::new(owner, infer.clone());\n-        validator.internal_diagnostics = internal_diagnostics;\n         validator.validate_body(db);\n         validator.diagnostics\n     }\n@@ -74,12 +66,11 @@ struct ExprValidator {\n     owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n     pub(super) diagnostics: Vec<BodyValidationDiagnostic>,\n-    internal_diagnostics: bool,\n }\n \n impl ExprValidator {\n     fn new(owner: DefWithBodyId, infer: Arc<InferenceResult>) -> ExprValidator {\n-        ExprValidator { owner, infer, diagnostics: Vec::new(), internal_diagnostics: false }\n+        ExprValidator { owner, infer, diagnostics: Vec::new() }\n     }\n \n     fn validate_body(&mut self, db: &dyn HirDatabase) {\n@@ -308,9 +299,7 @@ impl ExprValidator {\n             // fit the match expression, we skip this diagnostic. Skipping the entire\n             // diagnostic rather than just not including this match arm is preferred\n             // to avoid the chance of false positives.\n-            if self.internal_diagnostics {\n-                self.diagnostics.push(BodyValidationDiagnostic::InternalBailedOut { pat: arm.pat })\n-            }\n+            cov_mark::hit!(validate_match_bailed_out);\n             return;\n         }\n "}, {"sha": "c024e3e1ec531fbea628a18279b28c7d13e2be33", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 943, "changes": 958, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "patch": "@@ -10,6 +10,7 @@ mod incorrect_case;\n mod macro_error;\n mod mismatched_arg_count;\n mod missing_fields;\n+mod missing_match_arms;\n mod missing_ok_or_some_in_tail_expr;\n mod missing_unsafe;\n mod no_such_field;\n@@ -25,12 +26,7 @@ mod unresolved_proc_macro;\n \n mod field_shorthand;\n \n-use std::cell::RefCell;\n-\n-use hir::{\n-    diagnostics::{AnyDiagnostic, DiagnosticCode, DiagnosticSinkBuilder},\n-    Semantics,\n-};\n+use hir::{diagnostics::AnyDiagnostic, Semantics};\n use ide_assists::AssistResolveStrategy;\n use ide_db::{base_db::SourceDatabase, RootDatabase};\n use itertools::Itertools;\n@@ -44,6 +40,15 @@ use unlinked_file::UnlinkedFile;\n \n use crate::{Assist, AssistId, AssistKind, FileId, Label, SourceChange};\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct DiagnosticCode(pub &'static str);\n+\n+impl DiagnosticCode {\n+    pub fn as_str(&self) -> &str {\n+        self.0\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct Diagnostic {\n     // pub name: Option<String>,\n@@ -112,10 +117,6 @@ impl Diagnostic {\n     fn with_unused(self, unused: bool) -> Self {\n         Self { unused, ..self }\n     }\n-\n-    fn with_code(self, code: Option<DiagnosticCode>) -> Self {\n-        Self { code, ..self }\n-    }\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -160,36 +161,13 @@ pub(crate) fn diagnostics(\n         check_unnecessary_braces_in_use_statement(&mut res, file_id, &node);\n         field_shorthand::check(&mut res, file_id, &node);\n     }\n-    let res = RefCell::new(res);\n-    let sink_builder = DiagnosticSinkBuilder::new()\n-        // Only collect experimental diagnostics when they're enabled.\n-        .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n-        .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n-\n-    // Finalize the `DiagnosticSink` building process.\n-    let mut sink = sink_builder\n-        // Diagnostics not handled above get no fix and default treatment.\n-        .build(|d| {\n-            res.borrow_mut().push(\n-                Diagnostic::error(\n-                    sema.diagnostics_display_range(d.display_source()).range,\n-                    d.message(),\n-                )\n-                .with_code(Some(d.code())),\n-            );\n-        });\n \n     let mut diags = Vec::new();\n-    let internal_diagnostics = cfg!(test);\n     let module = sema.to_module_def(file_id);\n     if let Some(m) = module {\n-        diags = m.diagnostics(db, &mut sink, internal_diagnostics)\n+        m.diagnostics(db, &mut diags)\n     }\n \n-    drop(sink);\n-\n-    let mut res = res.into_inner();\n-\n     let ctx = DiagnosticsContext { config, sema, resolve };\n     if module.is_none() {\n         let d = UnlinkedFile { file: file_id };\n@@ -205,6 +183,7 @@ pub(crate) fn diagnostics(\n             AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n+            AnyDiagnostic::MissingMatchArms(d) => missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n@@ -349,8 +328,8 @@ mod tests {\n             )\n             .unwrap()\n             .pop()\n-            .unwrap();\n-        let fix = &diagnostic.fixes.unwrap()[nth];\n+            .expect(\"no diagnostics\");\n+        let fix = &diagnostic.fixes.expect(\"diagnostic misses fixes\")[nth];\n         let actual = {\n             let source_change = fix.source_change.as_ref().unwrap();\n             let file_id = *source_change.source_file_edits.keys().next().unwrap();\n@@ -545,910 +524,3 @@ pub struct Claims {\n         );\n     }\n }\n-\n-#[cfg(test)]\n-pub(super) mod match_check_tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match () { }\n-        //^^ Missing match arm\n-    match (()) { }\n-        //^^^^ Missing match arm\n-\n-    match () { _ => (), }\n-    match () { () => (), }\n-    match (()) { (()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match ((), ()) { }\n-        //^^^^^^^^ Missing match arm\n-\n-    match ((), ()) { ((), ()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn boolean() {\n-        check_diagnostics(\n-            r#\"\n-fn test_main() {\n-    match false { }\n-        //^^^^^ Missing match arm\n-    match false { true => (), }\n-        //^^^^^ Missing match arm\n-    match (false, true) {}\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) { (true, true) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) {\n-        //^^^^^^^^^^^^^ Missing match arm\n-        (false, true) => (),\n-        (false, false) => (),\n-        (true, false) => (),\n-    }\n-    match (false, true) { (true, _x) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-\n-    match false { true => (), false => (), }\n-    match (false, true) {\n-        (false, _) => (),\n-        (true, false) => (),\n-        (_, true) => (),\n-    }\n-    match (false, true) {\n-        (true, true) => (),\n-        (true, false) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true) {\n-        (true, _x) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true, false) {\n-        (false, ..) => (),\n-        (true, ..) => (),\n-    }\n-    match (false, true, false) {\n-        (.., false) => (),\n-        (.., true) => (),\n-    }\n-    match (false, true, false) { (..) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, ((), false)) {}\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, ((), true)) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, _) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, ((), true)) => (),\n-        (false, ((), false)) => (),\n-    }\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enums() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B, }\n-\n-fn main() {\n-    match Either::A { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B { Either::A => (), }\n-        //^^^^^^^^^ Missing match arm\n-\n-    match &Either::B {\n-        //^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-\n-    match Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-    match &Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_containing_bool() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B }\n-\n-fn main() {\n-    match Either::B { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true) => (), Either::B => ()\n-    }\n-\n-    match Either::B {\n-        Either::A(true) => (),\n-        Either::A(false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::B => (),\n-        _ => (),\n-    }\n-    match Either::B {\n-        Either::A(_) => (),\n-        Either::B => (),\n-    }\n-\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_different_sizes() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-\n-fn main() {\n-    match Either::A(false) {\n-        //^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A(_) => (),\n-        Either::B(false, _) => (),\n-    }\n-\n-    match Either::A(false) {\n-        Either::A(_) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-    match Either::A(false) {\n-        Either::A(true) | Either::A(false) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_enum_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match (Either::A(false), Either2::C) {\n-        (Either::A(true), _) | (Either::A(false), _) => (),\n-        (Either::B(true, _), Either2::C) => (),\n-        (Either::B(false, _), Either2::C) => (),\n-        (Either::B(_, _), Either2::D) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn or_pattern_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {A, B}\n-\n-fn main() {\n-    match (Either::A, Either::B) {\n-        (Either::A | Either::B, _) => (),\n-    }\n-}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match Either::A {\n-        Either2::C => (),\n-    //  ^^^^^^^^^^ Internal: match check bailed out\n-        Either2::D => (),\n-    }\n-    match (true, false) {\n-        (true, false, true) => (),\n-    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n-        (true) => (),\n-    }\n-    match (true, false) { (true,) => {} }\n-    //                    ^^^^^^^ Internal: match check bailed out\n-    match (0) { () => () }\n-            //  ^^ Internal: match check bailed out\n-    match Unresolved::Bar { Unresolved::Baz => () }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn mismatched_types_in_or_patterns() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match false { true | () => {} }\n-    //            ^^^^^^^^^ Internal: match check bailed out\n-    match (false,) { (true | (),) => {} }\n-    //               ^^^^^^^^^^^^ Internal: match check bailed out\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_tuple_enum_missing_pattern() {\n-        // We are testing to be sure we don't panic here when the match\n-        // arm `Either::B` is missing its pattern.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B(u32) }\n-\n-fn main() {\n-    match Either::A {\n-        Either::A => (),\n-        Either::B() => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_extra_fields() {\n-        check_diagnostics(\n-            r#\"\n-enum A { B(isize, isize), C }\n-fn main() {\n-    match A::B(1, 2) {\n-        A::B(_, _, _) => (),\n-    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match A::B(1, 2) {\n-        A::C(_) => (),\n-    //  ^^^^^^^ Internal: match check bailed out\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-\n-fn main() {\n-    match loop {} {\n-        Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n-        Either::B => (),\n-    }\n-    match loop {} {\n-        Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match loop { break Foo::A } {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-    match loop { break Foo::A } {\n-        Either::A => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_partially_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either<T> { A(T), B }\n-\n-fn foo() -> Either<!> { Either::B }\n-fn main() -> u32 {\n-    match foo() {\n-        Either::A(val) => val,\n-        Either::B => 0,\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A { foo: bool }, B }\n-\n-fn main() {\n-    let a = Either::A { foo: true };\n-    match a { }\n-        //^ Missing match arm\n-    match a { Either::A { foo: true } => () }\n-        //^ Missing match arm\n-    match a {\n-        Either::A { } => (),\n-      //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { } => (),\n-    } //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-\n-    match a {\n-        Either::A { foo: true } => (),\n-        Either::A { foo: false } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        Either::A { foo: _ } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: () },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::A { foo: true, bar: () };\n-    match a {\n-        //^ Missing match arm\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-    }\n-\n-    match a {\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: bool },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::B;\n-    match a {\n-        //^ Missing match arm\n-        Either::A { foo: true, .. } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { .. } => (),\n-    }\n-\n-    match a {\n-        Either::A { foo: true, .. } => (),\n-        Either::A { foo: false, .. } => (),\n-        Either::B => (),\n-    }\n-\n-    match a {\n-        Either::A { .. } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A(bool, bool, bool, bool),\n-    B,\n-}\n-\n-fn main() {\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::B => (),\n-    }\n-\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., true) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::A(.., false) => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn never() {\n-        check_diagnostics(\n-            r#\"\n-enum Never {}\n-\n-fn enum_(never: Never) {\n-    match never {}\n-}\n-fn enum_ref(never: &Never) {\n-    match never {}\n-        //^^^^^ Missing match arm\n-}\n-fn bang(never: !) {\n-    match never {}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unknown_type() {\n-        check_diagnostics(\n-            r#\"\n-enum Option<T> { Some(T), None }\n-\n-fn main() {\n-    // `Never` is deliberately not defined so that it's an uninferred type.\n-    match Option::<Never>::None {\n-        None => (),\n-        Some(never) => match never {},\n-    //  ^^^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match Option::<Never>::None {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Option::Some(_never) => {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (false, ..) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (.., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (true, .., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo { a: bool }\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo { a: true } => () }\n-        //^ Missing match arm\n-    match &f { Foo { a: true } => () }\n-        //^^ Missing match arm\n-    match f { Foo { a: _ } => () }\n-    match f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-    match &f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo(bool);\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo(true) => () }\n-        //^ Missing match arm\n-    match f {\n-        Foo(true) => (),\n-        Foo(false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unit_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo;\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo => () }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_ellipsis() {\n-        check_diagnostics(\n-            r#\"struct Foo { foo: bool, bar: bool }\n-fn main(f: Foo) {\n-    match f { Foo { foo: true, .. } => () }\n-        //^ Missing match arm\n-    match f {\n-        //^ Missing match arm\n-        Foo { foo: true, .. } => (),\n-        Foo { bar: false, .. } => ()\n-    }\n-    match f { Foo { .. } => () }\n-    match f {\n-        Foo { foo: true, .. } => (),\n-        Foo { foo: false, .. } => ()\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn internal_or() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    enum Either { A(bool), B }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true | false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_panic_at_unimplemented_subpattern_type() {\n-        check_diagnostics(\n-            r#\"\n-struct S { a: char}\n-fn main(v: S) {\n-    match v { S{ a }      => {} }\n-    match v { S{ a: _x }  => {} }\n-    match v { S{ a: 'a' } => {} }\n-            //^^^^^^^^^^^ Internal: match check bailed out\n-    match v { S{..}       => {} }\n-    match v { _           => {} }\n-    match v { }\n-        //^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        _x @ true => {}\n-        false     => {}\n-    }\n-    match true { _x @ true => {} }\n-        //^^^^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding_ref_has_correct_type() {\n-        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n-        // If that's not true match checking will panic with \"incompatible constructors\"\n-        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n-        check_diagnostics(\n-            r#\"\n-enum Foo { A }\n-fn main() {\n-    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n-    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n-    match Foo::A {\n-        ref _x => {}\n-    //  ^^^^^^ Internal: match check bailed out\n-        Foo::A => {}\n-    }\n-    match (true,) {\n-        (ref _x,) => {}\n-        (true,) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_non_exhaustive() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:lib\n-#[non_exhaustive]\n-pub enum E { A, B }\n-fn _local() {\n-    match E::A { _ => {} }\n-    match E::A {\n-        E::A => {}\n-        E::B => {}\n-    }\n-    match E::A {\n-        E::A | E::B => {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:lib\n-use lib::E;\n-fn main() {\n-    match E::A { _ => {} }\n-    match E::A {\n-        //^^^^ Missing match arm\n-        E::A => {}\n-        E::B => {}\n-    }\n-    match E::A {\n-        //^^^^ Missing match arm\n-        E::A | E::B => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_guard() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        true if false => {}\n-        true          => {}\n-        false         => {}\n-    }\n-    match true {\n-        //^^^^ Missing match arm\n-        true if false => {}\n-        false         => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn pattern_type_is_of_substitution() {\n-        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n-        check_diagnostics(\n-            r#\"\n-struct Foo<T>(T);\n-struct Bar;\n-fn main() {\n-    match Foo(Bar) {\n-        _ | Foo(Bar) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_no_such_field() {\n-        check_diagnostics(\n-            r#\"\n-struct Foo { }\n-fn main(f: Foo) {\n-    match f { Foo { bar } => () }\n-    //        ^^^^^^^^^^^ Internal: match check bailed out\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_ergonomics_issue_9095() {\n-        check_diagnostics(\n-            r#\"\n-enum Foo<T> { A(T) }\n-fn main() {\n-    match &Foo::A(true) {\n-        _ => {}\n-        Foo::A(_) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    mod false_negatives {\n-        //! The implementation of match checking here is a work in progress. As we roll this out, we\n-        //! prefer false negatives to false positives (ideally there would be no false positives). This\n-        //! test module should document known false negatives. Eventually we will have a complete\n-        //! implementation of match checking and this module will be empty.\n-        //!\n-        //! The reasons for documenting known false negatives:\n-        //!\n-        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-        //!   2. It ensures the code doesn't panic when handling these cases.\n-        use super::*;\n-\n-        #[test]\n-        fn integers() {\n-            // We don't currently check integer exhaustiveness.\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match 5 {\n-        10 => (),\n-    //  ^^ Internal: match check bailed out\n-        11..20 => (),\n-    }\n-}\n-\"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn reference_patterns_at_top_level() {\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match &false {\n-        &true => {}\n-    //  ^^^^^ Internal: match check bailed out\n-    }\n-}\n-            \"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn reference_patterns_in_fields() {\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match (&false,) {\n-        (true,) => {}\n-    //  ^^^^^^^ Internal: match check bailed out\n-    }\n-    match (&false,) {\n-        (&true,) => {}\n-    //  ^^^^^^^^ Internal: match check bailed out\n-    }\n-}\n-            \"#,\n-            );\n-        }\n-    }\n-}"}, {"sha": "b636489b3f7e67fabfadb410c48f7904e725f250", "filename": "crates/ide/src/diagnostics/missing_match_arms.rs", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs?ref=8c5c0ef7b910ffafc9c684cb7076149ab79f4bdd", "patch": "@@ -0,0 +1,929 @@\n+use hir::InFile;\n+\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: missing-match-arm\n+//\n+// This diagnostic is triggered if `match` block is missing one or more match arms.\n+pub(super) fn missing_match_arms(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::MissingMatchArms,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"missing-match-arm\",\n+        \"missing match arm\",\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file, d.match_expr.clone().into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+pub(super) mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    fn check_diagnostics_no_bails(ra_fixture: &str) {\n+        cov_mark::check_count!(validate_match_bailed_out, 0);\n+        crate::diagnostics::tests::check_diagnostics(ra_fixture)\n+    }\n+\n+    #[test]\n+    fn empty_tuple() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match () { }\n+        //^^ missing match arm\n+    match (()) { }\n+        //^^^^ missing match arm\n+\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match ((), ()) { }\n+        //^^^^^^^^ missing match arm\n+\n+    match ((), ()) { ((), ()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn test_main() {\n+    match false { }\n+        //^^^^^ missing match arm\n+    match false { true => (), }\n+        //^^^^^ missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n+    }\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enums() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either { A, B, }\n+\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ missing match arm\n+\n+    match &Either::B {\n+        //^^^^^^^^^^ missing match arm\n+        Either::A => (),\n+    }\n+\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either { A(bool), B }\n+\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true) => (), Either::B => ()\n+    }\n+\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n+    }\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n+    }\n+\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n+    }\n+\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_enum_no_diagnostic() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern_no_diagnostic() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either {A, B}\n+\n+fn main() {\n+    match (Either::A, Either::B) {\n+        (Either::A | Either::B, _) => (),\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn mismatched_types() {\n+        cov_mark::check_count!(validate_match_bailed_out, 4);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+        (true) => (),\n+    }\n+    match (true, false) { (true,) => {} }\n+    match (0) { () => () }\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mismatched_types_in_or_patterns() {\n+        cov_mark::check_count!(validate_match_bailed_out, 2);\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match false { true | () => {} }\n+    match (false,) { (true | (),) => {} }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either { A, B(u32) }\n+\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_extra_fields() {\n+        cov_mark::check_count!(validate_match_bailed_out, 2);\n+        check_diagnostics(\n+            r#\"\n+enum A { B(isize, isize), C }\n+fn main() {\n+    match A::B(1, 2) {\n+        A::B(_, _, _) => (),\n+    }\n+    match A::B(1, 2) {\n+        A::C(_) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_diverges() {\n+        cov_mark::check_count!(validate_match_bailed_out, 2);\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_partially_diverges() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either<T> { A(T), B }\n+\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n+\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n+        //^ missing match arm\n+    match a { Either::A { foo: true } => () }\n+        //^ missing match arm\n+    match a {\n+        Either::A { } => (),\n+      //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ missing match arm\n+        Either::A { } => (),\n+    } //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n+        //^ missing match arm\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+    }\n+\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ missing match arm\n+        Either::A { .. } => (),\n+    }\n+\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n+    }\n+\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n+\n+fn main() {\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n+    }\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Never {}\n+\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+        //^^^^^ missing match arm\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unknown_type() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n+        check_diagnostics(\n+            r#\"\n+enum Option<T> { Some(T), None }\n+\n+fn main() {\n+    // `Never` is deliberately not defined so that it's an uninferred type.\n+    match Option::<Never>::None {\n+        None => (),\n+        Some(never) => match never {},\n+    }\n+    match Option::<Never>::None {\n+        //^^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        Option::Some(_never) => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        (false, ..) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        (.., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        (true, .., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct() {\n+        check_diagnostics_no_bails(\n+            r#\"struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f {}\n+        //^ missing match arm\n+    match f { Foo { a: true } => () }\n+        //^ missing match arm\n+    match &f { Foo { a: true } => () }\n+        //^^ missing match arm\n+    match f { Foo { a: _ } => () }\n+    match f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+    match &f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics_no_bails(\n+            r#\"struct Foo(bool);\n+fn main(f: Foo) {\n+    match f {}\n+        //^ missing match arm\n+    match f { Foo(true) => () }\n+        //^ missing match arm\n+    match f {\n+        Foo(true) => (),\n+        Foo(false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unit_struct() {\n+        check_diagnostics_no_bails(\n+            r#\"struct Foo;\n+fn main(f: Foo) {\n+    match f {}\n+        //^ missing match arm\n+    match f { Foo => () }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_ellipsis() {\n+        check_diagnostics_no_bails(\n+            r#\"struct Foo { foo: bool, bar: bool }\n+fn main(f: Foo) {\n+    match f { Foo { foo: true, .. } => () }\n+        //^ missing match arm\n+    match f {\n+        //^ missing match arm\n+        Foo { foo: true, .. } => (),\n+        Foo { bar: false, .. } => ()\n+    }\n+    match f { Foo { .. } => () }\n+    match f {\n+        Foo { foo: true, .. } => (),\n+        Foo { foo: false, .. } => ()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn internal_or() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true | false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_panic_at_unimplemented_subpattern_type() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n+        check_diagnostics(\n+            r#\"\n+struct S { a: char}\n+fn main(v: S) {\n+    match v { S{ a }      => {} }\n+    match v { S{ a: _x }  => {} }\n+    match v { S{ a: 'a' } => {} }\n+    match v { S{..}       => {} }\n+    match v { _           => {} }\n+    match v { }\n+        //^ missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match true {\n+        _x @ true => {}\n+        false     => {}\n+    }\n+    match true { _x @ true => {} }\n+        //^^^^ missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding_ref_has_correct_type() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n+        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n+        // If that's not true match checking will panic with \"incompatible constructors\"\n+        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n+        check_diagnostics(\n+            r#\"\n+enum Foo { A }\n+fn main() {\n+    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n+    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n+    match Foo::A {\n+        ref _x => {}\n+        Foo::A => {}\n+    }\n+    match (true,) {\n+        (ref _x,) => {}\n+        (true,) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_non_exhaustive() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+//- /lib.rs crate:lib\n+#[non_exhaustive]\n+pub enum E { A, B }\n+fn _local() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        E::A | E::B => {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:lib\n+use lib::E;\n+fn main() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        //^^^^ missing match arm\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        //^^^^ missing match arm\n+        E::A | E::B => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_guard() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+fn main() {\n+    match true {\n+        true if false => {}\n+        true          => {}\n+        false         => {}\n+    }\n+    match true {\n+        //^^^^ missing match arm\n+        true if false => {}\n+        false         => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn pattern_type_is_of_substitution() {\n+        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n+        check_diagnostics_no_bails(\n+            r#\"\n+struct Foo<T>(T);\n+struct Bar;\n+fn main() {\n+    match Foo(Bar) {\n+        _ | Foo(Bar) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_no_such_field() {\n+        cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n+        check_diagnostics(\n+            r#\"\n+struct Foo { }\n+fn main(f: Foo) {\n+    match f { Foo { bar } => () }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_ergonomics_issue_9095() {\n+        check_diagnostics_no_bails(\n+            r#\"\n+enum Foo<T> { A(T) }\n+fn main() {\n+    match &Foo::A(true) {\n+        _ => {}\n+        Foo::A(_) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    mod false_negatives {\n+        //! The implementation of match checking here is a work in progress. As we roll this out, we\n+        //! prefer false negatives to false positives (ideally there would be no false positives). This\n+        //! test module should document known false negatives. Eventually we will have a complete\n+        //! implementation of match checking and this module will be empty.\n+        //!\n+        //! The reasons for documenting known false negatives:\n+        //!\n+        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+        //!   2. It ensures the code doesn't panic when handling these cases.\n+        use super::*;\n+\n+        #[test]\n+        fn integers() {\n+            cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n+            // We don't currently check integer exhaustiveness.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+        11..20 => (),\n+    }\n+}\n+\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_at_top_level() {\n+            cov_mark::check_count!(validate_match_bailed_out, 1);\n+\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match &false {\n+        &true => {}\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_in_fields() {\n+            cov_mark::check_count!(validate_match_bailed_out, 2);\n+\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (&false,) {\n+        (true,) => {}\n+    }\n+    match (&false,) {\n+        (&true,) => {}\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+    }\n+}"}]}