{"sha": "546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NmYxZTk4Y2IwZGE0YTRmNzJiOWY2NGFmZDBlMzhlNmVhNDVjMDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-04T02:22:56Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-04T02:22:56Z"}, "message": "Typecheck expr_bind.", "tree": {"sha": "5fdfdaf88a57e7e0577686dca35daf41493bd7a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fdfdaf88a57e7e0577686dca35daf41493bd7a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08", "html_url": "https://github.com/rust-lang/rust/commit/546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "771d76e5520bb886624e4541ff3b74f2d6513bd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/771d76e5520bb886624e4541ff3b74f2d6513bd6", "html_url": "https://github.com/rust-lang/rust/commit/771d76e5520bb886624e4541ff3b74f2d6513bd6"}], "stats": {"total": 70, "additions": 57, "deletions": 13}, "files": [{"sha": "ab82537b40291c5dbcba361047f3a42e705426d5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=546f1e98cb0da4a4f72b9f64afd0e38e6ea45c08", "patch": "@@ -672,6 +672,10 @@ fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n             }\n             e_1 = ast.expr_rec(fields_1, ast.ann_type(t));\n         }\n+        case (ast.expr_bind(?sube, ?es, ?ann)) {\n+            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            e_1 = ast.expr_bind(sube, es, ast.ann_type(t));\n+        }\n         case (ast.expr_call(?sube, ?es, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_call(sube, es, ast.ann_type(t));\n@@ -1105,6 +1109,50 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_alt(expr_1, arms_1, ann));\n         }\n \n+        case (ast.expr_bind(?f, ?args, _)) {\n+            auto f_0 = check_expr(fcx, f);\n+            auto t_0 = expr_ty(f_0);\n+\n+            if (!ty.is_fn_ty(t_0)) {\n+                fcx.ccx.sess.span_err(f_0.span,\n+                                      \"mismatched types: bind callee has \" +\n+                                      \"non-function type: \" +\n+                                      ty_to_str(t_0));\n+            }\n+\n+            let vec[arg] arg_tys_0 = ty.ty_fn_args(t_0);\n+            let @ty.t rt_0 = ty.ty_fn_ret(t_0);\n+            let vec[option.t[@ast.expr]] args_1 = vec();\n+\n+            let uint i = 0u;\n+\n+            let vec[arg] residual_args = vec();\n+            for (option.t[@ast.expr] a in args) {\n+                alt (a) {\n+                    case (none[@ast.expr]) {\n+                        append[arg](residual_args,\n+                                    arg_tys_0.(i));\n+                        append[option.t[@ast.expr]](args_1,\n+                                                    none[@ast.expr]);\n+                    }\n+                    case (some[@ast.expr](?sa)) {\n+                        auto arg_1 = check_expr(fcx, sa);\n+                        auto arg_t = expr_ty(arg_1);\n+                        demand_expr(fcx, arg_tys_0.(i).ty, arg_1);\n+                        append[option.t[@ast.expr]](args_1,\n+                                                    some[@ast.expr](arg_1));\n+                    }\n+                }\n+                i += 1u;\n+            }\n+\n+            let @ty.t t_1 = plain_ty(ty.ty_fn(residual_args, rt_0));\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_bind(f_0, args_1,\n+                                                      ast.ann_type(t_1)));\n+\n+        }\n+\n         case (ast.expr_call(?f, ?args, _)) {\n \n             // Check the function.\n@@ -1128,21 +1176,17 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Take the argument types out of the resulting function type.\n             auto t_1 = expr_ty(f_1);\n-            let vec[arg] arg_tys_1 = vec();        // TODO: typestate botch\n-            let @ty.t rt_1 = plain_ty(ty.ty_nil);  // TODO: typestate botch\n-            alt (t_1.struct) {\n-                case (ty.ty_fn(?arg_tys, ?rt)) {\n-                    arg_tys_1 = arg_tys;\n-                    rt_1 = rt;\n-                }\n-                case (_) {\n-                    fcx.ccx.sess.span_err(f_1.span,\n-                                          \"mismatched types: callee has \" +\n-                                          \"non-function type: \" +\n-                                          ty_to_str(t_1));\n-                }\n+\n+            if (!ty.is_fn_ty(t_1)) {\n+                fcx.ccx.sess.span_err(f_1.span,\n+                                      \"mismatched types: callee has \" +\n+                                      \"non-function type: \" +\n+                                      ty_to_str(t_1));\n             }\n \n+            let vec[arg] arg_tys_1 = ty.ty_fn_args(t_1);\n+            let @ty.t rt_1 = ty.ty_fn_ret(t_1);\n+\n             // Unify and write back to the arguments.\n             auto i = 0u;\n             let vec[@ast.expr] args_1 = vec();"}]}