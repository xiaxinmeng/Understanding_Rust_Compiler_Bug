{"sha": "1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOWFhMTMzMmZjOWYwMTk0YmFjMTc2MWVmMDRlNTQ1NjRlMjZmYzg=", "commit": {"author": {"name": "Josef Reinhard Brandl", "email": "mail@josefbrandl.de", "date": "2018-06-26T14:40:42Z"}, "committer": {"name": "Josef Reinhard Brandl", "email": "mail@josefbrandl.de", "date": "2018-06-26T14:40:42Z"}, "message": "Split libcore/task.rs into submodules", "tree": {"sha": "50740ba0d7a3ea05d100ab2b52df077e26b78a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50740ba0d7a3ea05d100ab2b52df077e26b78a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "html_url": "https://github.com/rust-lang/rust/commit/1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/comments", "author": {"login": "MajorBreakfast", "id": 340142, "node_id": "MDQ6VXNlcjM0MDE0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/340142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MajorBreakfast", "html_url": "https://github.com/MajorBreakfast", "followers_url": "https://api.github.com/users/MajorBreakfast/followers", "following_url": "https://api.github.com/users/MajorBreakfast/following{/other_user}", "gists_url": "https://api.github.com/users/MajorBreakfast/gists{/gist_id}", "starred_url": "https://api.github.com/users/MajorBreakfast/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MajorBreakfast/subscriptions", "organizations_url": "https://api.github.com/users/MajorBreakfast/orgs", "repos_url": "https://api.github.com/users/MajorBreakfast/repos", "events_url": "https://api.github.com/users/MajorBreakfast/events{/privacy}", "received_events_url": "https://api.github.com/users/MajorBreakfast/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MajorBreakfast", "id": 340142, "node_id": "MDQ6VXNlcjM0MDE0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/340142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MajorBreakfast", "html_url": "https://github.com/MajorBreakfast", "followers_url": "https://api.github.com/users/MajorBreakfast/followers", "following_url": "https://api.github.com/users/MajorBreakfast/following{/other_user}", "gists_url": "https://api.github.com/users/MajorBreakfast/gists{/gist_id}", "starred_url": "https://api.github.com/users/MajorBreakfast/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MajorBreakfast/subscriptions", "organizations_url": "https://api.github.com/users/MajorBreakfast/orgs", "repos_url": "https://api.github.com/users/MajorBreakfast/repos", "events_url": "https://api.github.com/users/MajorBreakfast/events{/privacy}", "received_events_url": "https://api.github.com/users/MajorBreakfast/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764232cb2a8407c72b9fea68835e686240e30ef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/764232cb2a8407c72b9fea68835e686240e30ef3", "html_url": "https://github.com/rust-lang/rust/commit/764232cb2a8407c72b9fea68835e686240e30ef3"}], "stats": {"total": 695, "additions": 401, "deletions": 294}, "files": [{"sha": "c69d45248a597c09ea434208292f5ec40a23900d", "filename": "src/libcore/task/context.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fcontext.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use fmt;\n+use super::{Executor, Waker, LocalWaker};\n+\n+/// Information about the currently-running task.\n+///\n+/// Contexts are always tied to the stack, since they are set up specifically\n+/// when performing a single `poll` step on a task.\n+pub struct Context<'a> {\n+    local_waker: &'a LocalWaker,\n+    executor: &'a mut Executor,\n+}\n+\n+impl<'a> fmt::Debug for Context<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Context\")\n+            .finish()\n+    }\n+}\n+\n+impl<'a> Context<'a> {\n+    /// Create a new task `Context` with the provided `local_waker`, `waker`, and `executor`.\n+    #[inline]\n+    pub fn new(local_waker: &'a LocalWaker, executor: &'a mut Executor) -> Context<'a> {\n+        Context {\n+            local_waker,\n+            executor,\n+        }\n+    }\n+\n+    /// Get the `LocalWaker` associated with the current task.\n+    #[inline]\n+    pub fn local_waker(&self) -> &'a LocalWaker {\n+        self.local_waker\n+    }\n+\n+    /// Get the `Waker` associated with the current task.\n+    #[inline]\n+    pub fn waker(&self) -> &'a Waker {\n+        unsafe { &*(self.local_waker as *const LocalWaker as *const Waker) }\n+    }\n+\n+    /// Get the default executor associated with this task.\n+    ///\n+    /// This method is useful primarily if you want to explicitly handle\n+    /// spawn failures.\n+    #[inline]\n+    pub fn executor(&mut self) -> &mut Executor {\n+        self.executor\n+    }\n+\n+    /// Produce a context like the current one, but using the given waker instead.\n+    ///\n+    /// This advanced method is primarily used when building \"internal\n+    /// schedulers\" within a task, where you want to provide some customized\n+    /// wakeup logic.\n+    #[inline]\n+    pub fn with_waker<'b>(&'b mut self, local_waker: &'b LocalWaker) -> Context<'b> {\n+        Context {\n+            local_waker,\n+            executor: self.executor,\n+        }\n+    }\n+\n+    /// Produce a context like the current one, but using the given executor\n+    /// instead.\n+    ///\n+    /// This advanced method is primarily used when building \"internal\n+    /// schedulers\" within a task.\n+    #[inline]\n+    pub fn with_executor<'b, E>(&'b mut self, executor: &'b mut E) -> Context<'b>\n+        where E: Executor\n+    {\n+        Context {\n+            local_waker: self.local_waker,\n+            executor: executor,\n+        }\n+    }\n+}"}, {"sha": "fcef6d5ffc84d135d09a29bdc712e15ef952c498", "filename": "src/libcore/task/executor.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fexecutor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fexecutor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fexecutor.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use super::{TaskObj, SpawnObjError, SpawnErrorKind};\n+\n+/// A task executor.\n+///\n+/// A *task* is a `()`-producing async value that runs at the top level, and will\n+/// be `poll`ed until completion. It's also the unit at which wake-up\n+/// notifications occur. Executors, such as thread pools, allow tasks to be\n+/// spawned and are responsible for putting tasks onto ready queues when\n+/// they are woken up, and polling them when they are ready.\n+pub trait Executor {\n+    /// Spawn the given task, polling it until completion.\n+    ///\n+    /// # Errors\n+    ///\n+    /// The executor may be unable to spawn tasks, either because it has\n+    /// been shut down or is resource-constrained.\n+    fn spawn_obj(&mut self, task: TaskObj) -> Result<(), SpawnObjError>;\n+\n+    /// Determine whether the executor is able to spawn new tasks.\n+    ///\n+    /// # Returns\n+    ///\n+    /// An `Ok` return means the executor is *likely* (but not guaranteed)\n+    /// to accept a subsequent spawn attempt. Likewise, an `Err` return\n+    /// means that `spawn` is likely, but not guaranteed, to yield an error.\n+    #[inline]\n+    fn status(&self) -> Result<(), SpawnErrorKind> {\n+        Ok(())\n+    }\n+}"}, {"sha": "66ab21d177d83ecb13da949a7fe64e17a6040cb5", "filename": "src/libcore/task/mod.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+//! Types and Traits for working with asynchronous tasks.\n+\n+mod context;\n+pub use self::context::Context;\n+\n+mod executor;\n+pub use self::executor::Executor;\n+\n+mod poll;\n+pub use self::poll::Poll;\n+\n+mod spawn_error;\n+pub use self::spawn_error::{SpawnErrorKind, SpawnObjError};\n+\n+mod task;\n+pub use self::task::{TaskObj, UnsafeTask};\n+\n+mod wake;\n+pub use self::wake::{Waker, LocalWaker, UnsafeWake};"}, {"sha": "10c954f0e80ecc83080202a9959e3fdbf73d53ec", "filename": "src/libcore/task/poll.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+/// Indicates whether a value is available or if the current task has been\n+/// scheduled to receive a wakeup instead.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+pub enum Poll<T> {\n+    /// Represents that a value is immediately ready.\n+    Ready(T),\n+\n+    /// Represents that a value is not ready yet.\n+    ///\n+    /// When a function returns `Pending`, the function *must* also\n+    /// ensure that the current task is scheduled to be awoken when\n+    /// progress can be made.\n+    Pending,\n+}\n+\n+impl<T> Poll<T> {\n+    /// Change the ready value of this `Poll` with the closure provided\n+    pub fn map<U, F>(self, f: F) -> Poll<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        match self {\n+            Poll::Ready(t) => Poll::Ready(f(t)),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+\n+    /// Returns whether this is `Poll::Ready`\n+    pub fn is_ready(&self) -> bool {\n+        match *self {\n+            Poll::Ready(_) => true,\n+            Poll::Pending => false,\n+        }\n+    }\n+\n+    /// Returns whether this is `Poll::Pending`\n+    pub fn is_pending(&self) -> bool {\n+        !self.is_ready()\n+    }\n+}\n+\n+impl<T, E> Poll<Result<T, E>> {\n+    /// Change the success value of this `Poll` with the closure provided\n+    pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n+        where F: FnOnce(T) -> U\n+    {\n+        match self {\n+            Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n+            Poll::Ready(Err(e)) => Poll::Ready(Err(e)),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+\n+    /// Change the error value of this `Poll` with the closure provided\n+    pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n+        where F: FnOnce(E) -> U\n+    {\n+        match self {\n+            Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n+            Poll::Ready(Err(e)) => Poll::Ready(Err(f(e))),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for Poll<T> {\n+    fn from(t: T) -> Poll<T> {\n+        Poll::Ready(t)\n+    }\n+}"}, {"sha": "5dd9c5be689296f1a7328f6c0b1ed4e6d2340c97", "filename": "src/libcore/task/spawn_error.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fspawn_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fspawn_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn_error.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use fmt;\n+use super::TaskObj;\n+\n+/// Provides the reason that an executor was unable to spawn.\n+pub struct SpawnErrorKind {\n+    _hidden: (),\n+}\n+\n+impl fmt::Debug for SpawnErrorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"SpawnErrorKind\")\n+            .field(&\"shutdown\")\n+            .finish()\n+    }\n+}\n+\n+impl SpawnErrorKind {\n+    /// Spawning is failing because the executor has been shut down.\n+    pub fn shutdown() -> SpawnErrorKind {\n+        SpawnErrorKind { _hidden: () }\n+    }\n+\n+    /// Check whether this error is the `shutdown` error.\n+    pub fn is_shutdown(&self) -> bool {\n+        true\n+    }\n+}\n+\n+/// The result of a failed spawn\n+#[derive(Debug)]\n+pub struct SpawnObjError {\n+    /// The kind of error\n+    pub kind: SpawnErrorKind,\n+\n+    /// The task for which spawning was attempted\n+    pub task: TaskObj,\n+}"}, {"sha": "dc4ff314e5bd8a4eb7276c51ef96d2e191e6c802", "filename": "src/libcore/task/task.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Ftask.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use fmt;\n+use future::Future;\n+use mem::PinMut;\n+use super::{Context, Poll};\n+\n+/// A custom trait object for polling tasks, roughly akin to\n+/// `Box<Future<Output = ()> + Send>`.\n+pub struct TaskObj {\n+    ptr: *mut (),\n+    poll_fn: unsafe fn(*mut (), &mut Context) -> Poll<()>,\n+    drop_fn: unsafe fn(*mut ()),\n+}\n+\n+unsafe impl Send for TaskObj {}\n+\n+impl TaskObj {\n+    /// Create a `TaskObj` from a custom trait object representation.\n+    #[inline]\n+    pub fn new<T: UnsafeTask>(t: T) -> TaskObj {\n+        TaskObj {\n+            ptr: t.into_raw(),\n+            poll_fn: T::poll,\n+            drop_fn: T::drop,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for TaskObj {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TaskObj\")\n+            .finish()\n+    }\n+}\n+\n+impl Future for TaskObj {\n+    type Output = ();\n+\n+    #[inline]\n+    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+        unsafe {\n+            (self.poll_fn)(self.ptr, cx)\n+        }\n+    }\n+}\n+\n+impl Drop for TaskObj {\n+    fn drop(&mut self) {\n+        unsafe {\n+            (self.drop_fn)(self.ptr)\n+        }\n+    }\n+}\n+\n+/// A custom implementation of a task trait object for `TaskObj`, providing\n+/// a hand-rolled vtable.\n+///\n+/// This custom representation is typically used only in `no_std` contexts,\n+/// where the default `Box`-based implementation is not available.\n+///\n+/// The implementor must guarantee that it is safe to call `poll` repeatedly (in\n+/// a non-concurrent fashion) with the result of `into_raw` until `drop` is\n+/// called.\n+pub unsafe trait UnsafeTask: Send + 'static {\n+    /// Convert a owned instance into a (conceptually owned) void pointer.\n+    fn into_raw(self) -> *mut ();\n+\n+    /// Poll the task represented by the given void pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The trait implementor must guarantee that it is safe to repeatedly call\n+    /// `poll` with the result of `into_raw` until `drop` is called; such calls\n+    /// are not, however, allowed to race with each other or with calls to `drop`.\n+    unsafe fn poll(task: *mut (), cx: &mut Context) -> Poll<()>;\n+\n+    /// Drops the task represented by the given void pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The trait implementor must guarantee that it is safe to call this\n+    /// function once per `into_raw` invocation; that call cannot race with\n+    /// other calls to `drop` or `poll`.\n+    unsafe fn drop(task: *mut ());\n+}"}, {"sha": "4fd45be56fbfb8d092102732da0347fbe26f2bef", "filename": "src/libcore/task/wake.rs", "status": "renamed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9aa1332fc9f0194bac1761ef04e54564e26fc8/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=1f9aa1332fc9f0194bac1761ef04e54564e26fc8", "patch": "@@ -12,82 +12,8 @@\n             reason = \"futures in libcore are unstable\",\n             issue = \"50547\")]\n \n-//! Types and Traits for working with asynchronous tasks.\n-\n use fmt;\n use ptr::NonNull;\n-use future::Future;\n-use mem::PinMut;\n-\n-/// Indicates whether a value is available or if the current task has been\n-/// scheduled to receive a wakeup instead.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-pub enum Poll<T> {\n-    /// Represents that a value is immediately ready.\n-    Ready(T),\n-\n-    /// Represents that a value is not ready yet.\n-    ///\n-    /// When a function returns `Pending`, the function *must* also\n-    /// ensure that the current task is scheduled to be awoken when\n-    /// progress can be made.\n-    Pending,\n-}\n-\n-impl<T> Poll<T> {\n-    /// Change the ready value of this `Poll` with the closure provided\n-    pub fn map<U, F>(self, f: F) -> Poll<U>\n-        where F: FnOnce(T) -> U\n-    {\n-        match self {\n-            Poll::Ready(t) => Poll::Ready(f(t)),\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-\n-    /// Returns whether this is `Poll::Ready`\n-    pub fn is_ready(&self) -> bool {\n-        match *self {\n-            Poll::Ready(_) => true,\n-            Poll::Pending => false,\n-        }\n-    }\n-\n-    /// Returns whether this is `Poll::Pending`\n-    pub fn is_pending(&self) -> bool {\n-        !self.is_ready()\n-    }\n-}\n-\n-impl<T, E> Poll<Result<T, E>> {\n-    /// Change the success value of this `Poll` with the closure provided\n-    pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n-        where F: FnOnce(T) -> U\n-    {\n-        match self {\n-            Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n-            Poll::Ready(Err(e)) => Poll::Ready(Err(e)),\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-\n-    /// Change the error value of this `Poll` with the closure provided\n-    pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n-        where F: FnOnce(E) -> U\n-    {\n-        match self {\n-            Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n-            Poll::Ready(Err(e)) => Poll::Ready(Err(f(e))),\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-}\n-\n-impl<T> From<T> for Poll<T> {\n-    fn from(t: T) -> Poll<T> {\n-        Poll::Ready(t)\n-    }\n-}\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n@@ -347,223 +273,3 @@ pub unsafe trait UnsafeWake: Send + Sync {\n         self.wake()\n     }\n }\n-\n-/// Information about the currently-running task.\n-///\n-/// Contexts are always tied to the stack, since they are set up specifically\n-/// when performing a single `poll` step on a task.\n-pub struct Context<'a> {\n-    local_waker: &'a LocalWaker,\n-    executor: &'a mut Executor,\n-}\n-\n-impl<'a> fmt::Debug for Context<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Context\")\n-            .finish()\n-    }\n-}\n-\n-impl<'a> Context<'a> {\n-    /// Create a new task `Context` with the provided `local_waker`, `waker`, and `executor`.\n-    #[inline]\n-    pub fn new(local_waker: &'a LocalWaker, executor: &'a mut Executor) -> Context<'a> {\n-        Context {\n-            local_waker,\n-            executor,\n-        }\n-    }\n-\n-    /// Get the `LocalWaker` associated with the current task.\n-    #[inline]\n-    pub fn local_waker(&self) -> &'a LocalWaker {\n-        self.local_waker\n-    }\n-\n-    /// Get the `Waker` associated with the current task.\n-    #[inline]\n-    pub fn waker(&self) -> &'a Waker {\n-        unsafe { &*(self.local_waker as *const LocalWaker as *const Waker) }\n-    }\n-\n-    /// Get the default executor associated with this task.\n-    ///\n-    /// This method is useful primarily if you want to explicitly handle\n-    /// spawn failures.\n-    #[inline]\n-    pub fn executor(&mut self) -> &mut Executor {\n-        self.executor\n-    }\n-\n-    /// Produce a context like the current one, but using the given waker instead.\n-    ///\n-    /// This advanced method is primarily used when building \"internal\n-    /// schedulers\" within a task, where you want to provide some customized\n-    /// wakeup logic.\n-    #[inline]\n-    pub fn with_waker<'b>(&'b mut self, local_waker: &'b LocalWaker) -> Context<'b> {\n-        Context {\n-            local_waker,\n-            executor: self.executor,\n-        }\n-    }\n-\n-    /// Produce a context like the current one, but using the given executor\n-    /// instead.\n-    ///\n-    /// This advanced method is primarily used when building \"internal\n-    /// schedulers\" within a task.\n-    #[inline]\n-    pub fn with_executor<'b, E>(&'b mut self, executor: &'b mut E) -> Context<'b>\n-        where E: Executor\n-    {\n-        Context {\n-            local_waker: self.local_waker,\n-            executor: executor,\n-        }\n-    }\n-}\n-\n-/// A task executor.\n-///\n-/// A *task* is a `()`-producing async value that runs at the top level, and will\n-/// be `poll`ed until completion. It's also the unit at which wake-up\n-/// notifications occur. Executors, such as thread pools, allow tasks to be\n-/// spawned and are responsible for putting tasks onto ready queues when\n-/// they are woken up, and polling them when they are ready.\n-pub trait Executor {\n-    /// Spawn the given task, polling it until completion.\n-    ///\n-    /// # Errors\n-    ///\n-    /// The executor may be unable to spawn tasks, either because it has\n-    /// been shut down or is resource-constrained.\n-    fn spawn_obj(&mut self, task: TaskObj) -> Result<(), SpawnObjError>;\n-\n-    /// Determine whether the executor is able to spawn new tasks.\n-    ///\n-    /// # Returns\n-    ///\n-    /// An `Ok` return means the executor is *likely* (but not guaranteed)\n-    /// to accept a subsequent spawn attempt. Likewise, an `Err` return\n-    /// means that `spawn` is likely, but not guaranteed, to yield an error.\n-    #[inline]\n-    fn status(&self) -> Result<(), SpawnErrorKind> {\n-        Ok(())\n-    }\n-}\n-\n-/// A custom trait object for polling tasks, roughly akin to\n-/// `Box<Future<Output = ()> + Send>`.\n-pub struct TaskObj {\n-    ptr: *mut (),\n-    poll_fn: unsafe fn(*mut (), &mut Context) -> Poll<()>,\n-    drop_fn: unsafe fn(*mut ()),\n-}\n-\n-impl fmt::Debug for TaskObj {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"TaskObj\")\n-            .finish()\n-    }\n-}\n-\n-unsafe impl Send for TaskObj {}\n-\n-/// A custom implementation of a task trait object for `TaskObj`, providing\n-/// a hand-rolled vtable.\n-///\n-/// This custom representation is typically used only in `no_std` contexts,\n-/// where the default `Box`-based implementation is not available.\n-///\n-/// The implementor must guarantee that it is safe to call `poll` repeatedly (in\n-/// a non-concurrent fashion) with the result of `into_raw` until `drop` is\n-/// called.\n-pub unsafe trait UnsafeTask: Send + 'static {\n-    /// Convert a owned instance into a (conceptually owned) void pointer.\n-    fn into_raw(self) -> *mut ();\n-\n-    /// Poll the task represented by the given void pointer.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The trait implementor must guarantee that it is safe to repeatedly call\n-    /// `poll` with the result of `into_raw` until `drop` is called; such calls\n-    /// are not, however, allowed to race with each other or with calls to `drop`.\n-    unsafe fn poll(task: *mut (), cx: &mut Context) -> Poll<()>;\n-\n-    /// Drops the task represented by the given void pointer.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The trait implementor must guarantee that it is safe to call this\n-    /// function once per `into_raw` invocation; that call cannot race with\n-    /// other calls to `drop` or `poll`.\n-    unsafe fn drop(task: *mut ());\n-}\n-\n-impl TaskObj {\n-    /// Create a `TaskObj` from a custom trait object representation.\n-    #[inline]\n-    pub fn new<T: UnsafeTask>(t: T) -> TaskObj {\n-        TaskObj {\n-            ptr: t.into_raw(),\n-            poll_fn: T::poll,\n-            drop_fn: T::drop,\n-        }\n-    }\n-}\n-\n-impl Future for TaskObj {\n-    type Output = ();\n-\n-    #[inline]\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n-        unsafe {\n-            (self.poll_fn)(self.ptr, cx)\n-        }\n-    }\n-}\n-\n-impl Drop for TaskObj {\n-    fn drop(&mut self) {\n-        unsafe {\n-            (self.drop_fn)(self.ptr)\n-        }\n-    }\n-}\n-\n-/// Provides the reason that an executor was unable to spawn.\n-pub struct SpawnErrorKind {\n-    _hidden: (),\n-}\n-\n-impl fmt::Debug for SpawnErrorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"SpawnErrorKind\")\n-            .field(&\"shutdown\")\n-            .finish()\n-    }\n-}\n-\n-impl SpawnErrorKind {\n-    /// Spawning is failing because the executor has been shut down.\n-    pub fn shutdown() -> SpawnErrorKind {\n-        SpawnErrorKind { _hidden: () }\n-    }\n-\n-    /// Check whether this error is the `shutdown` error.\n-    pub fn is_shutdown(&self) -> bool {\n-        true\n-    }\n-}\n-\n-/// The result of a failed spawn\n-#[derive(Debug)]\n-pub struct SpawnObjError {\n-    /// The kind of error\n-    pub kind: SpawnErrorKind,\n-\n-    /// The task for which spawning was attempted\n-    pub task: TaskObj,\n-}", "previous_filename": "src/libcore/task.rs"}]}