{"sha": "c709ed2faf4ea28df1395a924453b5298b87fa57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MDllZDJmYWY0ZWEyOGRmMTM5NWE5MjQ0NTNiNTI5OGI4N2ZhNTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-28T17:33:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-28T18:01:03Z"}, "message": "Merge remote-tracking branch 'origin/master' into rollup\n\nConflicts:\n\tsrc/libcollections/slice.rs\n\tsrc/libcore/nonzero.rs\n\tsrc/libcore/ops.rs", "tree": {"sha": "9567cea197e37b96607f471b18dd1c77908c8965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9567cea197e37b96607f471b18dd1c77908c8965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c709ed2faf4ea28df1395a924453b5298b87fa57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c709ed2faf4ea28df1395a924453b5298b87fa57", "html_url": "https://github.com/rust-lang/rust/commit/c709ed2faf4ea28df1395a924453b5298b87fa57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c709ed2faf4ea28df1395a924453b5298b87fa57/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "249c29fe2746d251dc8aab63cd8730df9ff8434c", "url": "https://api.github.com/repos/rust-lang/rust/commits/249c29fe2746d251dc8aab63cd8730df9ff8434c", "html_url": "https://github.com/rust-lang/rust/commit/249c29fe2746d251dc8aab63cd8730df9ff8434c"}, {"sha": "a45e117733b866302fa99390553d1c548508dcca", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45e117733b866302fa99390553d1c548508dcca", "html_url": "https://github.com/rust-lang/rust/commit/a45e117733b866302fa99390553d1c548508dcca"}], "stats": {"total": 9526, "additions": 5765, "deletions": 3761}, "files": [{"sha": "e28f56fffe41b3d547f7c82ed3f1b86ef2b18725", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -301,6 +301,7 @@ tidy:\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \t\t$(Q) $(CFG_PYTHON) $(S)src/etc/errorck.py $(S)src/\n+\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/featureck.py $(S)src/\n \n \n endif"}, {"sha": "eedff1d11760ca70ac9160593dc5ae4b9779f9a8", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -13,7 +13,15 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(test)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(path)]\n+#![feature(io)]\n+#![feature(core)]\n+#![feature(collections)]\n+#![feature(os)]\n+#![feature(unicode)]\n \n #![deny(warnings)]\n "}, {"sha": "59ac173f97a29d73ca50cb37f7ba8b66497517aa", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -2359,77 +2359,6 @@ Supported traits for `derive` are:\n * `Show`, to format a value using the `{}` formatter.\n * `Zero`, to create a zero instance of a numeric data type.\n \n-### Stability\n-\n-One can indicate the stability of an API using the following attributes:\n-\n-* `deprecated`: This item should no longer be used, e.g. it has been\n-  replaced. No guarantee of backwards-compatibility.\n-* `experimental`: This item was only recently introduced or is\n-  otherwise in a state of flux. It may change significantly, or even\n-  be removed. No guarantee of backwards-compatibility.\n-* `unstable`: This item is still under development, but requires more\n-  testing to be considered stable. No guarantee of backwards-compatibility.\n-* `stable`: This item is considered stable, and will not change\n-  significantly. Guarantee of backwards-compatibility.\n-* `frozen`: This item is very stable, and is unlikely to\n-  change. Guarantee of backwards-compatibility.\n-* `locked`: This item will never change unless a serious bug is\n-  found. Guarantee of backwards-compatibility.\n-\n-These levels are directly inspired by\n-[Node.js' \"stability index\"](http://nodejs.org/api/documentation.html).\n-\n-Stability levels are inherited, so an item's stability attribute is the default\n-stability for everything nested underneath it.\n-\n-There are lints for disallowing items marked with certain levels: `deprecated`,\n-`experimental` and `unstable`. For now, only `deprecated` warns by default, but\n-this will change once the standard library has been stabilized. Stability\n-levels are meant to be promises at the crate level, so these lints only apply\n-when referencing items from an _external_ crate, not to items defined within\n-the current crate. Items with no stability level are considered to be unstable\n-for the purposes of the lint. One can give an optional string that will be\n-displayed when the lint flags the use of an item.\n-\n-For example, if we define one crate called `stability_levels`:\n-\n-```{.ignore}\n-#[deprecated=\"replaced by `best`\"]\n-pub fn bad() {\n-    // delete everything\n-}\n-\n-pub fn better() {\n-    // delete fewer things\n-}\n-\n-#[stable]\n-pub fn best() {\n-    // delete nothing\n-}\n-```\n-\n-then the lints will work as follows for a client crate:\n-\n-```{.ignore}\n-#![warn(unstable)]\n-extern crate stability_levels;\n-use stability_levels::{bad, better, best};\n-\n-fn main() {\n-    bad(); // \"warning: use of deprecated item: replaced by `best`\"\n-\n-    better(); // \"warning: use of unmarked item\"\n-\n-    best(); // no warning\n-}\n-```\n-\n-> **Note:** Currently these are only checked when applied to individual\n-> functions, structs, methods and enum variants, *not* to entire modules,\n-> traits, impls or enums themselves.\n-\n ### Compiler Features\n \n Certain aspects of Rust may be implemented in the compiler, but they're not"}, {"sha": "601f130341bf95cb3a436bc45c659248c8561460", "filename": "src/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unstable)]\n+#![allow(unknown_features)]\n+#![cfg_attr(rustc, feature(rustc_private))]\n+#![cfg_attr(rustdoc, feature(rustdoc))]\n \n #[cfg(rustdoc)]\n extern crate \"rustdoc\" as this;"}, {"sha": "064cf1d40ab36ce881aad53dad4d0ff841323284", "filename": "src/etc/featureck.py", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fetc%2Ffeatureck.py", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fetc%2Ffeatureck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ffeatureck.py?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -0,0 +1,243 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# This script does a tree-wide sanity checks against stability\n+# attributes, currently:\n+#   * For all feature_name/level pairs the 'since' field is the same\n+#   * That no features are both stable and unstable.\n+#   * That lib features don't have the same name as lang features\n+#     unless they are on the 'joint_features' whitelist\n+#   * That features that exist in both lang and lib and are stable\n+#     since the same version\n+#   * Prints information about features\n+\n+import sys, os, re\n+\n+src_dir = sys.argv[1]\n+\n+# Features that are allowed to exist in both the language and the library\n+joint_features = [ ]\n+\n+# Grab the list of language features from the compiler\n+language_gate_statuses = [ \"Active\", \"Deprecated\", \"Removed\", \"Accepted\" ]\n+feature_gate_source = os.path.join(src_dir, \"libsyntax\", \"feature_gate.rs\")\n+language_features = []\n+language_feature_names = []\n+with open(feature_gate_source, 'r') as f:\n+    for line in f:\n+        original_line = line\n+        line = line.strip()\n+        is_feature_line = False\n+        for status in language_gate_statuses:\n+            if status in line and line.startswith(\"(\"):\n+                is_feature_line = True\n+\n+        if is_feature_line:\n+            line = line.replace(\"(\", \"\").replace(\"),\", \"\").replace(\")\", \"\")\n+            parts = line.split(\",\")\n+            if len(parts) != 3:\n+                print \"error: unexpected number of components in line: \" + original_line\n+                sys.exit(1)\n+            feature_name = parts[0].strip().replace('\"', \"\")\n+            since = parts[1].strip().replace('\"', \"\")\n+            status = parts[2].strip()\n+            assert len(feature_name) > 0\n+            assert len(since) > 0\n+            assert len(status) > 0\n+\n+            language_feature_names += [feature_name]\n+            language_features += [(feature_name, since, status)]\n+\n+assert len(language_features) > 0\n+\n+errors = False\n+\n+lib_features = { }\n+lib_features_and_level = { }\n+for (dirpath, dirnames, filenames) in os.walk(src_dir):\n+    # Don't look for feature names in tests\n+    if \"src/test\" in dirpath:\n+        continue\n+\n+    # Takes a long time to traverse LLVM\n+    if \"src/llvm\" in dirpath:\n+        continue\n+\n+    for filename in filenames:\n+        if not filename.endswith(\".rs\"):\n+            continue\n+\n+        path = os.path.join(dirpath, filename)\n+        with open(path, 'r') as f:\n+            line_num = 0\n+            for line in f:\n+                line_num += 1\n+                level = None\n+                if \"[unstable(\" in line:\n+                    level = \"unstable\"\n+                elif \"[stable(\" in line:\n+                    level = \"stable\"\n+                else:\n+                    continue\n+\n+                # This is a stability attribute. For the purposes of this\n+                # script we expect both the 'feature' and 'since' attributes on\n+                # the same line, e.g.\n+                # `#[unstable(feature = \"foo\", since = \"1.0.0\")]`\n+\n+                p = re.compile('(unstable|stable).*feature *= *\"(\\w*)\"')\n+                m = p.search(line)\n+                if not m is None:\n+                    feature_name = m.group(2)\n+                    since = None\n+                    if re.compile(\"\\[ *stable\").search(line) is not None:\n+                        pp = re.compile('since *= *\"([\\w\\.]*)\"')\n+                        mm = pp.search(line)\n+                        if not mm is None:\n+                            since = mm.group(1)\n+                        else:\n+                            print \"error: misformed stability attribute\"\n+                            print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                            print line\n+                            errors = True\n+\n+                    lib_features[feature_name] = feature_name\n+                    if lib_features_and_level.get((feature_name, level)) is None:\n+                        # Add it to the observed features\n+                        lib_features_and_level[(feature_name, level)] = \\\n+                            (since, path, line_num, line)\n+                    else:\n+                        # Verify that for this combination of feature_name and level the 'since'\n+                        # attribute matches.\n+                        (expected_since, source_path, source_line_num, source_line) = \\\n+                            lib_features_and_level.get((feature_name, level))\n+                        if since != expected_since:\n+                            print \"error: mismatch in \" + level + \" feature '\" + feature_name + \"'\"\n+                            print \"line \" + str(source_line_num) + \" of \" + source_path + \":\"\n+                            print source_line\n+                            print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                            print line\n+                            errors = True\n+\n+                    # Verify that this lib feature doesn't duplicate a lang feature\n+                    if feature_name in language_feature_names:\n+                        print \"error: lib feature '\" + feature_name + \"' duplicates a lang feature\"\n+                        print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                        print line\n+                        errors = True\n+\n+                else:\n+                    print \"error: misformed stability attribute\"\n+                    print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                    print line\n+                    errors = True\n+\n+# Merge data about both lists\n+# name, lang, lib, status, stable since\n+\n+language_feature_stats = {}\n+\n+for f in language_features:\n+    name = f[0]\n+    lang = True\n+    lib = False\n+    status = \"unstable\"\n+    stable_since = None\n+\n+    if f[2] == \"Accepted\":\n+        status = \"stable\"\n+    if status == \"stable\":\n+        stable_since = f[1]\n+\n+    language_feature_stats[name] = (name, lang, lib, status, stable_since)\n+\n+lib_feature_stats = {}\n+\n+for f in lib_features:\n+    name = f\n+    lang = False\n+    lib = True\n+    status = \"unstable\"\n+    stable_since = None\n+\n+    is_stable = lib_features_and_level.get((name, \"stable\")) is not None\n+    is_unstable = lib_features_and_level.get((name, \"unstable\")) is not None\n+\n+    if is_stable and is_unstable:\n+        print \"error: feature '\" + name + \"' is both stable and unstable\"\n+        errors = True\n+\n+    if is_stable:\n+        status = \"stable\"\n+        stable_since = lib_features_and_level[(name, \"stable\")][0]\n+    elif is_unstable:\n+        status = \"unstable\"\n+\n+    lib_feature_stats[name] = (name, lang, lib, status, stable_since)\n+\n+# Check for overlap in two sets\n+merged_stats = { }\n+\n+for name in lib_feature_stats:\n+    if language_feature_stats.get(name) is not None:\n+        if not name in joint_features:\n+            print \"error: feature '\" + name + \"' is both a lang and lib feature but not whitelisted\"\n+            errors = True\n+        lang_status = lang_feature_stats[name][3]\n+        lib_status = lib_feature_stats[name][3]\n+        lang_stable_since = lang_feature_stats[name][4]\n+        lib_stable_since = lib_feature_stats[name][4]\n+\n+        if lang_status != lib_status and lib_status != \"deprecated\":\n+            print \"error: feature '\" + name + \"' has lang status \" + lang_status + \\\n+                  \" but lib status \" + lib_status\n+            errors = True\n+\n+        if lang_stable_since != lib_stable_since:\n+            print \"error: feature '\" + name + \"' has lang stable since \" + lang_stable_since + \\\n+                  \" but lib stable since \" + lib_stable_since\n+            errors = True\n+\n+        merged_stats[name] = (name, True, True, lang_status, lang_stable_since)\n+\n+        del language_feature_stats[name]\n+        del lib_feature_stats[name]\n+\n+if errors:\n+    sys.exit(1)\n+\n+# Finally, display the stats\n+stats = {}\n+stats.update(language_feature_stats)\n+stats.update(lib_feature_stats)\n+stats.update(merged_stats)\n+lines = []\n+for s in stats:\n+    s = stats[s]\n+    type_ = \"lang\"\n+    if s[1] and s[2]:\n+        type_ = \"lang/lib\"\n+    elif s[2]:\n+        type_ = \"lib\"\n+    line = \"{: <32}\".format(s[0]) + \\\n+           \"{: <8}\".format(type_) + \\\n+           \"{: <12}\".format(s[3]) + \\\n+           \"{: <8}\".format(str(s[4]))\n+    lines += [line]\n+\n+lines.sort()\n+\n+print\n+print \"Rust feature summary:\"\n+print\n+for line in lines:\n+    print line\n+print\n+"}, {"sha": "1b75289c64f9fa57dfa43764ba2b549a7990d171", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n@@ -110,7 +110,7 @@ use heap::deallocate;\n /// }\n /// ```\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -126,7 +126,8 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n /// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -156,7 +157,7 @@ impl<T> Arc<T> {\n     /// let five = Arc::new(5i);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(data: T) -> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n@@ -179,7 +180,8 @@ impl<T> Arc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable = \"Weak pointers may not belong in this module.\"]\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module.\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, Relaxed);\n@@ -200,15 +202,15 @@ impl<T> Arc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n     ///\n@@ -245,7 +247,7 @@ impl<T> BorrowFrom<Arc<T>> for T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n \n@@ -271,7 +273,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n@@ -289,7 +291,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n@@ -355,7 +357,8 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -393,7 +396,8 @@ impl<T: Sync + Send> Weak<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -417,7 +421,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -460,7 +464,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n@@ -492,7 +496,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n@@ -571,30 +575,30 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Arc<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n@@ -605,7 +609,6 @@ impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n }\n \n #[cfg(test)]\n-#[allow(unstable)]\n mod tests {\n     use std::clone::Clone;\n     use std::sync::mpsc::channel;"}, {"sha": "51e5fc5820cbf9002e9251b219a780dd87ed5024", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -43,7 +43,7 @@\n //!\n //! This will print `Cons(1i32, Box(Cons(2i32, Box(Nil))))`.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n use core::clone::Clone;\n@@ -77,14 +77,15 @@ use core::result::Result;\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n-#[unstable = \"may be renamed; uncertain about custom allocator design\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"may be renamed; uncertain about custom allocator design\")]\n pub static HEAP: () = ();\n \n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n@@ -95,25 +96,25 @@ impl<T> Box<T> {\n     /// ```\n     /// let x = Box::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(x: T) -> Box<T> {\n         box x\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Box<T> { box Default::default() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Box<[T]> { box [] }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a new box with a `clone()` of this box's contents.\n     ///\n@@ -144,14 +145,14 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -166,14 +167,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n@@ -184,19 +185,20 @@ impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n }\n \n /// Extension methods for an owning `Any` trait object.\n-#[unstable = \"this trait will likely disappear once compiler bugs blocking \\\n-              a direct impl on `Box<Any>` have been fixed \"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"this trait will likely disappear once compiler bugs blocking \\\n+                     a direct impl on `Box<Any>` have been fixed \")]\n // FIXME(#18737): this should be a direct impl on `Box<Any>`. If you're\n //                removing this please make sure that you can downcase on\n //                `Box<Any + Send>` as well as `Box<Any>`\n pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any> {\n     #[inline]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n@@ -215,35 +217,35 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Box<Any> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Box<Any>\")\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }"}, {"sha": "dcbd4d57cf990399ca0feae11b623b4340bdc398", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -80,7 +80,7 @@ pub fn usable_size(size: uint, align: uint) -> uint {\n ///\n /// These statistics may be inconsistent if other threads use the allocator\n /// during the call.\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn stats_print() {\n     imp::stats_print();\n }"}, {"sha": "6830a1c33dfabe0d830fcdaa327515a149f89d00", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -57,7 +57,8 @@\n //! default global allocator. It is not compatible with the libc allocator API.\n \n #![crate_name = \"alloc\"]\n-#![unstable]\n+#![unstable(feature = \"alloc\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -66,13 +67,15 @@\n \n #![no_std]\n #![allow(unknown_features)]\n-#![allow(unstable)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n // FIXME(#21363) remove `old_impl_check` when bug is fixed\n #![feature(old_impl_check)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(libc)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "d41673f56edda2cb2a7e13b625fac3d5d4cbac80", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -142,7 +142,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::borrow::BorrowFrom;\n use core::cell::Cell;\n@@ -173,7 +173,7 @@ struct RcBox<T> {\n ///\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n@@ -185,7 +185,6 @@ impl<T> !marker::Send for Rc<T> {}\n impl<T> !marker::Sync for Rc<T> {}\n \n impl<T> Rc<T> {\n-\n     /// Constructs a new `Rc<T>`.\n     ///\n     /// # Examples\n@@ -195,7 +194,7 @@ impl<T> Rc<T> {\n     ///\n     /// let five = Rc::new(5i);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -222,7 +221,8 @@ impl<T> Rc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable = \"Weak pointers may not belong in this module\"]\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n@@ -231,12 +231,12 @@ impl<T> Rc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n@@ -252,7 +252,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// rc::is_unique(&five);\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n     weak_count(rc) == 0 && strong_count(rc) == 1\n }\n@@ -274,7 +274,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     if is_unique(&rc) {\n         unsafe {\n@@ -308,7 +308,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n         let inner = unsafe { &mut **rc._ptr };\n@@ -334,7 +334,7 @@ impl<T: Clone> Rc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n@@ -354,7 +354,7 @@ impl<T> BorrowFrom<Rc<T>> for T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n \n@@ -365,7 +365,7 @@ impl<T> Deref for Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n@@ -413,7 +413,7 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n \n     /// Makes a clone of the `Rc<T>`.\n@@ -436,7 +436,7 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Rc<T> {\n     /// Creates a new `Rc<T>`, with the `Default` value for `T`.\n     ///\n@@ -449,13 +449,13 @@ impl<T: Default> Default for Rc<T> {\n     /// let x: Rc<int> = Default::default();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -490,10 +490,10 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Rc<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -578,7 +578,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///\n@@ -605,14 +605,14 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n@@ -625,21 +625,21 @@ impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n ///\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[allow(unstable)]\n impl<T> !marker::Send for Weak<T> {}\n \n-#[allow(unstable)]\n impl<T> !marker::Sync for Weak<T> {}\n \n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n \n     /// Upgrades a weak reference to a strong reference.\n@@ -670,7 +670,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -713,7 +713,8 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n \n     /// Makes a clone of the `Weak<T>`.\n@@ -736,7 +737,7 @@ impl<T> Clone for Weak<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n@@ -777,7 +778,6 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n }\n \n #[cfg(test)]\n-#[allow(unstable)]\n mod tests {\n     use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;"}, {"sha": "9396e2d6fb2f9d4cfb948be9e9d38eb26b7695d0", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -20,7 +20,8 @@\n //! more complex, slower arena which can hold objects of any type.\n \n #![crate_name = \"arena\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -34,7 +35,10 @@\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(missing_docs)]\n-#![allow(unstable)]\n+#![feature(alloc)]\n+#![feature(core)]\n+#![cfg_attr(test, feature(test))]\n+#![cfg_attr(test, feature(collections))]\n \n extern crate alloc;\n "}, {"sha": "13a37882ed9c9face4d283983106b297e1e7b63b", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -148,7 +148,7 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -164,12 +164,12 @@ use vec::{self, Vec};\n ///\n /// This will be a max-heap.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n@@ -185,7 +185,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -200,7 +200,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::with_capacity(10);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -238,7 +238,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.data.iter() }\n     }\n@@ -259,7 +259,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { iter: self.data.into_iter() }\n     }\n@@ -279,7 +279,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n@@ -294,7 +294,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -317,7 +317,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.data.reserve_exact(additional);\n     }\n@@ -338,13 +338,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.data.reserve(additional);\n     }\n \n     /// Discards as much additional capacity as possible.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n     }\n@@ -362,7 +362,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n@@ -387,7 +387,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n@@ -542,40 +542,41 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain() }\n     }\n \n     /// Drops all items from the binary heap.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -586,22 +587,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -612,22 +613,22 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable = \"recent addition\"]\n+#[unstable(feature = \"collections\", reason = \"recent addition\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -638,23 +639,23 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n         BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();"}, {"sha": "2c9a502a20987bb298155c4a3b588c4bd6faaea6", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -156,7 +156,8 @@ static FALSE: bool = false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -252,7 +253,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -288,7 +289,7 @@ impl Bitv {\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n@@ -374,7 +375,7 @@ impl Bitv {\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n@@ -402,7 +403,8 @@ impl Bitv {\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n-    #[unstable = \"panic semantics are likely to change in the future\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -585,7 +587,7 @@ impl Bitv {\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n@@ -706,7 +708,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -733,7 +735,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -763,7 +765,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -785,7 +787,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n@@ -856,7 +858,7 @@ impl Bitv {\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<bool> {\n         if self.is_empty() {\n             None\n@@ -886,7 +888,7 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n         if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n@@ -898,29 +900,29 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for Bitv {\n     #[inline]\n     fn default() -> Bitv { Bitv::new() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n@@ -929,7 +931,7 @@ impl FromIterator<bool> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n@@ -941,7 +943,7 @@ impl Extend<bool> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for Bitv {\n     #[inline]\n     fn clone(&self) -> Bitv {\n@@ -955,23 +957,23 @@ impl Clone for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Bitv {\n     #[inline]\n     fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Bitv {\n     #[inline]\n     fn cmp(&self, other: &Bitv) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n@@ -981,7 +983,7 @@ impl fmt::Debug for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n@@ -991,7 +993,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n@@ -1002,19 +1004,19 @@ impl cmp::PartialEq for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n     bitv: &'a Bitv,\n     next_idx: uint,\n     end_idx: uint,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = bool;\n \n@@ -1035,7 +1037,7 @@ impl<'a> Iterator for Iter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n@@ -1048,10 +1050,10 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> ExactSizeIterator for Iter<'a> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1107,18 +1109,19 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub struct BitvSet {\n     bitv: Bitv,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for BitvSet {\n     #[inline]\n     fn default() -> BitvSet { BitvSet::new() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<uint> for BitvSet {\n     fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n@@ -1127,7 +1130,7 @@ impl FromIterator<uint> for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<uint> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n@@ -1137,7 +1140,7 @@ impl Extend<uint> for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for BitvSet {\n     #[inline]\n     fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n@@ -1146,7 +1149,7 @@ impl PartialOrd for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for BitvSet {\n     #[inline]\n     fn cmp(&self, other: &BitvSet) -> Ordering {\n@@ -1155,7 +1158,7 @@ impl Ord for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for BitvSet {\n     #[inline]\n     fn eq(&self, other: &BitvSet) -> bool {\n@@ -1164,7 +1167,7 @@ impl cmp::PartialEq for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n@@ -1178,7 +1181,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BitvSet {\n         BitvSet { bitv: Bitv::new() }\n     }\n@@ -1195,7 +1198,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1233,7 +1236,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.bitv.capacity()\n     }\n@@ -1254,7 +1257,7 @@ impl BitvSet {\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1280,7 +1283,7 @@ impl BitvSet {\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1374,7 +1377,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let bitv = &mut self.bitv;\n         // Obtain original length\n@@ -1402,7 +1405,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bitv_set::Iter {\n         SetIter {set: self, next_idx: 0u}\n     }\n@@ -1424,7 +1427,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n@@ -1454,7 +1457,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bitv.len(), other.bitv.len());\n@@ -1491,7 +1494,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n@@ -1522,7 +1525,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n@@ -1639,28 +1642,28 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &uint) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n@@ -1669,14 +1672,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let self_bitv = &self.bitv;\n         let other_bitv = &other.bitv;\n@@ -1690,14 +1693,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1715,7 +1718,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n@@ -1752,7 +1755,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n \n /// An iterator for `BitvSet`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n@@ -1768,16 +1771,16 @@ struct TwoBitPositions<'a> {\n     next_idx: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a>(TwoBitPositions<'a>);\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a>(TwoBitPositions<'a>);\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SetIter<'a> {\n     type Item = uint;\n \n@@ -1800,7 +1803,7 @@ impl<'a> Iterator for SetIter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = uint;\n \n@@ -1838,31 +1841,31 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Intersection<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Difference<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SymmetricDifference<'a> {\n     type Item = uint;\n "}, {"sha": "17d26ed1a21e80908e942af4a16288343e198a6a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -81,7 +81,7 @@ use super::node::{self, Node, Found, GoDown};\n /// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n /// it is certainly much slower when it does.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n     length: uint,\n@@ -96,31 +96,31 @@ struct AbsIter<T> {\n }\n \n /// An iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -136,7 +136,8 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, K, V>),\n@@ -145,21 +146,23 @@ pub enum Entry<'a, K:'a, V:'a> {\n }\n \n /// A vacant Entry.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -190,7 +193,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n@@ -220,7 +223,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n@@ -252,7 +255,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n@@ -276,7 +279,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n@@ -337,7 +340,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n@@ -446,7 +449,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n@@ -807,7 +810,7 @@ mod stack {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -816,7 +819,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n@@ -826,7 +829,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n@@ -835,42 +838,42 @@ impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeMap {{\"));\n@@ -884,7 +887,7 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -895,7 +898,7 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -1006,75 +1009,75 @@ impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n impl<'a, K, V> Iterator for Range<'a, K, V> {\n@@ -1096,7 +1099,8 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n@@ -1109,41 +1113,47 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1169,7 +1179,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n@@ -1202,7 +1212,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1231,7 +1241,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1258,7 +1268,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let keys: Vec<uint> = a.keys().cloned().collect();\n     /// assert_eq!(keys, vec![1u,2,]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n@@ -1280,7 +1290,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n@@ -1300,7 +1310,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1315,7 +1325,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n@@ -1470,7 +1480,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n         range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n     }\n@@ -1496,7 +1507,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n         range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n                                                                       edges_mut, [mut])\n@@ -1528,7 +1540,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[unstable = \"precise API still under development\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"precise API still under development\")]\n     pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);"}, {"sha": "95e424fb7a03cd04bcee56099299dc696ffbc91e", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -420,7 +420,7 @@ impl<K, V> Node<K, V> {\n }\n \n // FIXME(gereeter) Write an efficient clone_from\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for Node<K, V> {\n     fn clone(&self) -> Node<K, V> {\n         let mut ret = if self.is_leaf() {"}, {"sha": "a090e4f24ce1d35ba16d7827e1f270fb8e6c2f0d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -31,19 +31,19 @@ use Bound;\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n /// benefits and drawbacks.\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n@@ -54,28 +54,28 @@ pub struct Range<'a, T: 'a> {\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n@@ -91,15 +91,16 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n-    #[unstable = \"probably want this to be on the type, eventually\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"probably want this to be on the type, eventually\")]\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n@@ -122,7 +123,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -139,7 +140,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -169,7 +170,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// }\n     /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a T, &'a ())) -> &'a T = first; // coerce to fn pointer\n@@ -197,7 +199,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -220,7 +222,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n     /// assert_eq!(sym_diff, vec![1u,3]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymmetricDifference<'a, T> {\n         SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -244,7 +246,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n     /// assert_eq!(intersection, vec![2u]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> Intersection<'a, T> {\n         Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -266,7 +268,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let union: Vec<uint> = a.union(&b).cloned().collect();\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n         Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -283,7 +285,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -298,7 +300,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -313,7 +315,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -333,7 +335,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n@@ -355,7 +357,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -376,7 +378,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -421,7 +423,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -440,7 +442,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n         self.map.insert(value, ()).is_none()\n     }\n@@ -463,13 +465,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n@@ -478,7 +480,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n@@ -488,15 +490,15 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BTreeSet<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -519,7 +521,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -542,7 +544,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -565,7 +567,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -588,7 +590,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeSet {{\"));\n@@ -602,33 +604,33 @@ impl<T: Debug> Debug for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n@@ -651,7 +653,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n@@ -666,7 +668,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     type Item = &'a T;\n \n@@ -681,7 +683,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n@@ -702,7 +704,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n@@ -756,7 +758,9 @@ mod test {\n         expected: &'b [int],\n     }\n \n-    impl<'a, 'b, 'c> FnMut(&'c int) -> bool for Counter<'a, 'b> {\n+    impl<'a, 'b, 'c> FnMut<(&'c int,)> for Counter<'a, 'b> {\n+        type Output = bool;\n+\n         extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n             assert_eq!(x, self.expected[*self.i]);\n             *self.i += 1;"}, {"sha": "08f7cea4e92453063bbceb3614309bcb6b4d52cb", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -19,7 +19,7 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -33,7 +33,7 @@ use core::mem;\n use core::ptr;\n \n /// A doubly-linked list.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DList<T> {\n     length: uint,\n     list_head: Link<T>,\n@@ -57,15 +57,15 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter {\n@@ -77,7 +77,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n /// An iterator over mutable references to the items of a `DList`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n@@ -87,7 +87,7 @@ pub struct IterMut<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     list: DList<T>\n }\n@@ -206,17 +206,17 @@ impl<T> DList<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for DList<T> {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> DList<T> { DList::new() }\n }\n \n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n@@ -273,14 +273,14 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n@@ -296,7 +296,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter{list: self}\n     }\n@@ -317,7 +317,7 @@ impl<T> DList<T> {\n     /// assert!(!dl.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -344,7 +344,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -371,7 +371,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n@@ -392,7 +392,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n@@ -419,7 +419,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n@@ -440,7 +440,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n@@ -467,7 +467,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n@@ -490,7 +490,7 @@ impl<T> DList<T> {\n     /// assert_eq!(dl.front().unwrap(), &1);\n     ///\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -516,7 +516,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     ///\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n@@ -533,7 +533,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n@@ -552,7 +552,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n@@ -577,7 +577,7 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), Some(1));\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split_off(&mut self, at: uint) -> DList<T> {\n         let len = self.len();\n         assert!(at < len, \"Cannot split off at a nonexistent index\");\n@@ -620,7 +620,7 @@ impl<T> DList<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for DList<T> {\n     fn drop(&mut self) {\n         // Dissolve the dlist in backwards direction\n@@ -642,7 +642,7 @@ impl<T> Drop for DList<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -664,7 +664,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n@@ -679,10 +679,10 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n     #[inline]\n@@ -706,7 +706,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n@@ -721,7 +721,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n // private methods for IterMut\n@@ -770,7 +770,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n     }\n@@ -791,7 +792,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n@@ -800,7 +802,7 @@ impl<'a, A> IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -813,13 +815,13 @@ impl<A> Iterator for IntoIter<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for DList<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n         let mut ret = DList::new();\n@@ -828,14 +830,14 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n@@ -848,32 +850,32 @@ impl<A: PartialEq> PartialEq for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for DList<A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for DList<A> {\n     #[inline]\n     fn cmp(&self, other: &DList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n         self.iter().map(|x| x.clone()).collect()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: fmt::Debug> fmt::Debug for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DList [\"));\n@@ -887,7 +889,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);"}, {"sha": "f36da6f82eb730047323e4a42b02a74025855008", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -82,19 +82,22 @@ fn bit<E:CLike>(e: &E) -> uint {\n \n impl<E:CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> uint {\n         self.bits.count_ones()\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n@@ -104,19 +107,22 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == 0\n     }\n \n     /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == other.bits\n     }\n \n     /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n         other.is_superset(self)\n     }\n@@ -132,29 +138,33 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, e: E) -> bool {\n         let result = !self.contains(&e);\n         self.bits |= bit(&e);\n         result\n     }\n \n     /// Removes an enum from the EnumSet\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn remove(&mut self, e: &E) -> bool {\n         let result = self.contains(e);\n         self.bits &= !bit(e);\n         result\n     }\n \n     /// Returns `true` if an `EnumSet` contains a given enum.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn iter(&self) -> Iter<E> {\n         Iter::new(self.bits)\n     }"}, {"sha": "954de14a50a9314444518eda481885b10220d763", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,8 @@\n \n \n #![crate_name = \"collections\"]\n-#![unstable]\n+#![unstable(feature = \"collections\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -27,8 +28,12 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![no_std]\n+#![feature(core)]\n+#![feature(alloc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n #[macro_use]\n extern crate core;\n@@ -70,23 +75,25 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_map {\n     pub use btree::map::*;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_set {\n     pub use btree::set::*;\n }"}, {"sha": "15048998592a9dcf6a050d6db0306a06722b2642", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n /// Creates a `Vec` containing the arguments.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! vec {\n     ($x:expr; $y:expr) => (\n         <[_] as $crate::slice::SliceExt>::into_vec("}, {"sha": "2e3f61981122ee6dcadd36ee0df7a8003d820611", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,7 @@\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -36,7 +36,7 @@ static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n@@ -50,21 +50,21 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Send> Send for RingBuf<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for RingBuf<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n         self.iter().map(|t| t.clone()).collect()\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for RingBuf<T> {\n     fn drop(&mut self) {\n         self.clear();\n@@ -78,7 +78,7 @@ impl<T> Drop for RingBuf<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n@@ -146,13 +146,13 @@ impl<T> RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n@@ -191,7 +191,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -221,7 +221,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -250,7 +250,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -273,7 +273,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -296,7 +296,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.reserve(additional);\n     }\n@@ -317,7 +317,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n@@ -480,7 +480,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: uint) {\n         for _ in range(len, self.len()) {\n             self.pop_back();\n@@ -501,7 +502,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n             tail: self.tail,\n@@ -527,7 +528,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         IterMut {\n             tail: self.tail,\n@@ -539,7 +540,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Consumes the list into an iterator yielding elements by value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter {\n             inner: self,\n@@ -549,7 +550,8 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -568,7 +570,8 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -600,7 +603,7 @@ impl<T> RingBuf<T> {\n     /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n@@ -615,7 +618,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Creates a draining iterator that clears the `RingBuf` and iterates over\n@@ -632,7 +635,8 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n             inner: self,\n@@ -651,7 +655,7 @@ impl<T> RingBuf<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -672,7 +676,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n@@ -696,7 +700,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n@@ -716,7 +720,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n@@ -740,7 +744,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n@@ -762,7 +766,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -785,7 +789,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -809,7 +813,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -835,7 +839,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -872,7 +876,8 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(10);\n     /// assert_eq!(buf.swap_back_remove(1), Some(99));\n     /// ```\n-    #[unstable = \"the naming of this function may be altered\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"the naming of this function may be altered\")]\n     pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n@@ -904,7 +909,8 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(20i);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n-    #[unstable = \"the naming of this function may be altered\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"the naming of this function may be altered\")]\n     pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length && index != 0 {\n@@ -1137,7 +1143,7 @@ impl<T> RingBuf<T> {\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, i: uint) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n@@ -1304,7 +1310,8 @@ impl<T: Clone> RingBuf<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n \n@@ -1331,7 +1338,7 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n@@ -1349,7 +1356,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -1370,7 +1377,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n@@ -1382,10 +1389,10 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1408,7 +1415,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n@@ -1417,7 +1424,7 @@ pub struct IterMut<'a, T:'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -1441,7 +1448,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n@@ -1456,16 +1463,16 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// A by-value RingBuf iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1481,25 +1488,26 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut RingBuf<T>,\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in *self {}\n@@ -1508,7 +1516,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1524,44 +1532,44 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for RingBuf<A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n     fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for RingBuf<A> {\n     #[inline]\n     fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -1571,7 +1579,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Index<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1581,7 +1589,7 @@ impl<A> Index<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1591,7 +1599,7 @@ impl<A> IndexMut<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n@@ -1601,7 +1609,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n@@ -1610,7 +1618,7 @@ impl<A> Extend<A> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"RingBuf [\"));"}, {"sha": "b3bf55be46b6a8327a4817b74448cb3258b444b5", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 88, "deletions": 70, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -86,7 +86,7 @@\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n@@ -120,9 +120,9 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SliceExt {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n     /// Sorts the slice, in place, using `compare` to compare\n@@ -142,7 +142,7 @@ pub trait SliceExt {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n@@ -166,19 +166,26 @@ pub trait SliceExt {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable = \"uncertain about this API approach\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain about this API approach\")]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Deprecated: use `&s[start .. end]` notation instead.\n-    #[deprecated = \"use &s[start .. end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Deprecated: use `&s[start..]` notation instead.\n-    #[deprecated = \"use &s[start..] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Deprecated: use `&s[..end]` notation instead.\n-    #[deprecated = \"use &s[..end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -197,11 +204,11 @@ pub trait SliceExt {\n     /// assert_eq!([10, 40], v1);\n     /// assert_eq!([30, 20, 50], v2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -218,7 +225,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n                 where F: FnMut(&Self::Item) -> bool;\n \n@@ -237,7 +244,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n \n@@ -257,7 +264,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n \n@@ -280,7 +287,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n@@ -303,7 +310,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n@@ -316,7 +323,7 @@ pub trait SliceExt {\n     /// assert_eq!(Some(&40), v.get(1));\n     /// assert_eq!(None, v.get(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n@@ -330,15 +337,15 @@ pub trait SliceExt {\n     /// let w: &[i32] = &[];\n     /// assert_eq!(None, w.first());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n     /// Returns all but the first element of a slice.\n-    #[unstable = \"likely to be renamed\"]\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n-    #[unstable = \"likely to be renamed\"]\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n@@ -352,12 +359,12 @@ pub trait SliceExt {\n     /// let w: &[i32] = &[];\n     /// assert_eq!(None, w.last());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Returns an unsafe pointer to the slice's buffer\n@@ -367,7 +374,7 @@ pub trait SliceExt {\n     ///\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n@@ -402,7 +409,7 @@ pub trait SliceExt {\n     /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n         F: FnMut(&Self::Item) -> Ordering;\n \n@@ -414,7 +421,7 @@ pub trait SliceExt {\n     /// let a = [1i, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len(&self) -> uint;\n \n     /// Returns true if the slice has a length of 0\n@@ -426,68 +433,76 @@ pub trait SliceExt {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[start .. end]` instead.\n-    #[deprecated = \"use &mut s[start .. end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[start ..]` instead.\n-    #[deprecated = \"use &mut s[start ..] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[.. end]` instead.\n-    #[deprecated = \"use &mut s[.. end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns all but the first element of a mutable slice\n-    #[unstable = \"likely to be renamed or removed\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n     fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n-    #[unstable = \"likely to be renamed or removed\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n     fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n                       where F: FnMut(&Self::Item) -> bool;\n \n@@ -499,7 +514,7 @@ pub trait SliceExt {\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n@@ -520,7 +535,7 @@ pub trait SliceExt {\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap(&mut self, a: uint, b: uint);\n \n     /// Divides one `&mut` into two at an index.\n@@ -557,7 +572,7 @@ pub trait SliceExt {\n     ///     assert!(right == []);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n@@ -569,11 +584,11 @@ pub trait SliceExt {\n     /// v.reverse();\n     /// assert!(v == [3i, 2, 1]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn reverse(&mut self);\n \n     /// Returns an unsafe mutable pointer to the element in index\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n@@ -584,11 +599,11 @@ pub trait SliceExt {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n     /// Copies `self` into a new `Vec`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n \n     /// Creates an iterator that yields every possible permutation of the\n@@ -615,7 +630,7 @@ pub trait SliceExt {\n     /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n \n     /// Copies as many elements from `src` as it can into `self` (the\n@@ -635,7 +650,7 @@ pub trait SliceExt {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n@@ -650,7 +665,7 @@ pub trait SliceExt {\n     /// v.sort();\n     /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort(&mut self) where Self::Item: Ord;\n \n     /// Binary search a sorted slice for a given element.\n@@ -676,11 +691,12 @@ pub trait SliceExt {\n     /// let r = s.binary_search(&1);\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n \n     /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n     fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n         self.binary_search(x)\n     }\n@@ -701,7 +717,8 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [1i, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n     fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Mutates the slice to the previous lexicographic permutation.\n@@ -720,15 +737,16 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [0i, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Find the first index containing a matching value.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Returns true if the slice contains an element with the given value.\n@@ -740,7 +758,7 @@ pub trait SliceExt {\n     /// assert!(v.contains(&30));\n     /// assert!(!v.contains(&50));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a prefix of the slice.\n@@ -754,7 +772,7 @@ pub trait SliceExt {\n     /// assert!(!v.starts_with(&[50]));\n     /// assert!(!v.starts_with(&[10, 50]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a suffix of the slice.\n@@ -768,15 +786,15 @@ pub trait SliceExt {\n     /// assert!(!v.ends_with(&[50]));\n     /// assert!(!v.ends_with(&[50, 30]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -1064,7 +1082,7 @@ impl<T> SliceExt for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable = \"U should be an associated type\"]\n+#[unstable(feature = \"collections\", reason = \"U should be an associated type\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n@@ -1078,7 +1096,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     ///\n     /// println!(\"{}\", s); // prints \"helloworld\"\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> U;\n \n     /// Flattens a slice of `T` into a single value `U`, placing a given separator between each.\n@@ -1092,7 +1110,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     ///\n     /// println!(\"{}\", s); // prints \"hello world\"\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn connect(&self, sep: &T) -> U;\n }\n \n@@ -1128,7 +1146,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n #[derive(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n@@ -1140,7 +1158,7 @@ pub struct ElementSwaps {\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     pub fn new(length: uint) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -1157,17 +1175,17 @@ impl ElementSwaps {\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n     fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n     fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T: Clone> ToOwned<Vec<T>> for [T] {\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n }\n@@ -1186,7 +1204,7 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ElementSwaps {\n     type Item = (uint, uint);\n \n@@ -1249,13 +1267,13 @@ impl Iterator for ElementSwaps {\n /// swap applied.\n ///\n /// Generates even and odd permutations alternately.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n     v: Vec<T>,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T: Clone> Iterator for Permutations<T> {\n     type Item = Vec<T>;\n "}, {"sha": "63ae743b421b0ac15bdeb0d8587cb48693114b1e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 93, "deletions": 64, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -50,7 +50,7 @@\n //! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n@@ -165,15 +165,15 @@ enum DecompositionType {\n /// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n     buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Decompositions<'a> {\n     type Item = char;\n \n@@ -255,7 +255,7 @@ enum RecompositionState {\n /// External iterator for a string's recomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -264,7 +264,7 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Recompositions<'a> {\n     type Item = char;\n \n@@ -352,12 +352,12 @@ impl<'a> Iterator for Recompositions<'a> {\n /// External iterator for a string's UTF16 codeunits.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n@@ -384,12 +384,12 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl BorrowFrom<String> for str {\n     fn borrow_from(owned: &String) -> &str { &owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl ToOwned<String> for str {\n     fn to_owned(&self) -> String {\n         unsafe {\n@@ -407,16 +407,18 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable = \"return type may change to be an iterator\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n     fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable = \"return type may change to be an iterator\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n     fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n@@ -445,7 +447,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn replace(&self, from: &str, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;\n@@ -461,7 +463,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -474,7 +477,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -487,7 +491,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -501,7 +506,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -523,7 +529,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n         core_str::StrExt::contains(&self[], pat)\n     }\n@@ -539,7 +545,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable = \"might get removed in favour of a more generic contains()\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[], pat)\n     }\n@@ -553,7 +560,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n         core_str::StrExt::chars(&self[])\n     }\n@@ -566,13 +573,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(&self) -> Bytes {\n         core_str::StrExt::bytes(&self[])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(&self[])\n     }\n@@ -595,7 +602,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n         core_str::StrExt::split(&self[], pat)\n     }\n@@ -622,7 +629,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n@@ -651,7 +658,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable = \"might get removed\"]\n+    #[unstable(feature = \"collections\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n         core_str::StrExt::split_terminator(&self[], pat)\n     }\n@@ -672,7 +679,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n@@ -697,7 +704,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable = \"might have its iterator type changed\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n         core_str::StrExt::match_indices(&self[], pat)\n     }\n@@ -713,7 +721,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might get removed in the future in favor of a more generic split()\")]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n         core_str::StrExt::split_str(&self[], pat)\n     }\n@@ -729,7 +738,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n         core_str::StrExt::lines(&self[])\n     }\n@@ -745,21 +754,27 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n         core_str::StrExt::lines_any(&self[])\n     }\n \n     /// Deprecated: use `s[a .. b]` instead.\n-    #[deprecated = \"use slice notation [a..b] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n     fn slice(&self, begin: uint, end: uint) -> &str;\n \n     /// Deprecated: use `s[a..]` instead.\n-    #[deprecated = \"use slice notation [a..] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n     fn slice_from(&self, begin: uint) -> &str;\n \n     /// Deprecated: use `s[..a]` instead.\n-    #[deprecated = \"use slice notation [..a] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n     fn slice_to(&self, end: uint) -> &str;\n \n     /// Returns a slice of the string from the character range\n@@ -785,7 +800,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[unstable = \"may have yet to prove its worth\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"may have yet to prove its worth\")]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n@@ -796,7 +812,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// Caller must check both UTF-8 character boundaries and the boundaries of\n     /// the entire slice as well.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n@@ -808,7 +824,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n         core_str::StrExt::starts_with(&self[], pat)\n     }\n@@ -820,7 +836,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, pat: &str) -> bool {\n         core_str::StrExt::ends_with(&self[], pat)\n     }\n@@ -840,7 +856,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_matches(&self[], pat)\n     }\n@@ -860,7 +876,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n@@ -880,7 +896,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n@@ -908,7 +924,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         core_str::StrExt::is_char_boundary(&self[], index)\n     }\n@@ -966,7 +983,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n     }\n@@ -981,7 +999,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n@@ -1001,7 +1020,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: uint) -> char {\n         core_str::StrExt::char_at(&self[], i)\n     }\n@@ -1012,7 +1032,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: uint) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n     }\n@@ -1024,7 +1045,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(&self[])\n     }\n@@ -1052,7 +1073,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.find(x), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::find(&self[], pat)\n     }\n@@ -1080,7 +1101,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n@@ -1104,7 +1125,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable = \"might get removed in favor of a more generic find in the future\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might get removed in favor of a more generic find in the future\")]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         core_str::StrExt::find_str(&self[], needle)\n     }\n@@ -1127,7 +1149,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable = \"awaiting conventions about shifting and slices\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"awaiting conventions about shifting and slices\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[])\n     }\n@@ -1146,7 +1169,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"awaiting convention about comparability of arbitrary slices\")]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         core_str::StrExt::subslice_offset(&self[], inner)\n     }\n@@ -1156,14 +1180,15 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// The caller must ensure that the string outlives this pointer,\n     /// and that it is not reallocated (e.g. by pushing to the\n     /// string).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n         core_str::StrExt::as_ptr(&self[])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n     }\n@@ -1176,7 +1201,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"foo\".len(), 3);\n     /// assert_eq!(\"\u0192oo\".len(), 4);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> uint {\n         core_str::StrExt::len(&self[])\n@@ -1190,7 +1215,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(\"\".is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool {\n         core_str::StrExt::is_empty(&self[])\n     }\n@@ -1204,7 +1229,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"j\".parse::<u32>(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"this method was just created\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this method was just created\")]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n         core_str::StrExt::parse(&self[])\n     }\n@@ -1228,7 +1254,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[], is_extended)\n     }\n@@ -1243,7 +1270,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[], is_extended)\n     }\n@@ -1259,7 +1287,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn words(&self) -> Words {\n         UnicodeStr::words(&self[])\n     }\n@@ -1273,31 +1301,32 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the locale is unknown.\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> uint {\n         UnicodeStr::width(&self[], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n         UnicodeStr::trim(&self[])\n     }\n \n     /// Returns a string with leading whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(&self[])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[])\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl StrExt for str {\n     fn slice(&self, begin: uint, end: uint) -> &str {\n         &self[begin..end]"}, {"sha": "5189b825f1615230e384ea1fb4c3ad4914d68e52", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 64, "deletions": 60, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,7 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -34,21 +34,21 @@ use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[derive(Clone, PartialOrd, Eq, Ord)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n     vec: Vec<u8>,\n }\n \n /// A possible error value from the `String::from_utf8` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Show)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n }\n \n /// A possible error value from the `String::from_utf16` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_copy_implementations)]\n #[derive(Show)]\n pub struct FromUtf16Error(());\n@@ -62,7 +62,7 @@ impl String {\n     /// let mut s = String::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> String {\n         String {\n             vec: Vec::new(),\n@@ -79,7 +79,7 @@ impl String {\n     /// let mut s = String::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n@@ -95,7 +95,8 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[unstable = \"needs investigation to see if to_string() can match perf\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"needs investigation to see if to_string() can match perf\")]\n     pub fn from_str(string: &str) -> String {\n         String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n@@ -123,7 +124,7 @@ impl String {\n     /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(vec.as_slice()) {\n             Ok(..) => Ok(String { vec: vec }),\n@@ -141,7 +142,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         let mut i = 0;\n         match str::from_utf8(v) {\n@@ -279,7 +280,7 @@ impl String {\n     /// v[4] = 0xD800;\n     /// assert!(String::from_utf16(v).is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         let mut s = String::with_capacity(v.len());\n         for c in unicode_str::utf16_items(v) {\n@@ -306,7 +307,7 @@ impl String {\n     ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n@@ -317,7 +318,7 @@ impl String {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n@@ -328,7 +329,7 @@ impl String {\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n         String { vec: bytes }\n     }\n@@ -343,7 +344,7 @@ impl String {\n     /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n@@ -358,7 +359,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -373,7 +374,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n@@ -394,7 +395,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.vec.reserve(additional)\n     }\n@@ -419,7 +420,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.vec.reserve_exact(additional)\n     }\n@@ -436,7 +437,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -453,7 +454,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, ch: char) {\n         if (ch as u32) < 0x80 {\n             self.vec.push(ch as u8);\n@@ -486,7 +487,7 @@ impl String {\n     /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n@@ -506,7 +507,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -525,7 +526,7 @@ impl String {\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -561,7 +562,7 @@ impl String {\n     /// assert_eq!(s.remove(0), 'o');\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -588,7 +589,7 @@ impl String {\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -625,7 +626,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -639,7 +640,7 @@ impl String {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.vec.len() }\n \n     /// Returns true if the string contains no bytes\n@@ -653,7 +654,7 @@ impl String {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Truncates the string, returning it to 0 length.\n@@ -666,7 +667,7 @@ impl String {\n     /// assert!(s.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.vec.clear()\n     }\n@@ -675,39 +676,39 @@ impl String {\n impl FromUtf8Error {\n     /// Consume this error, returning the bytes that were attempted to make a\n     /// `String` with.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n \n     /// Access the underlying UTF8-error that was the cause of this error.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.error, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for FromUtf8Error {\n     fn description(&self) -> &str { \"invalid utf-8\" }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for FromUtf16Error {\n     fn description(&self) -> &str { \"invalid utf-16\" }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -716,7 +717,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -725,7 +726,8 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n-#[unstable = \"waiting on Extend stabilization\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n     fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n@@ -736,7 +738,8 @@ impl Extend<char> for String {\n     }\n }\n \n-#[unstable = \"waiting on Extend stabilization\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n@@ -748,7 +751,7 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -758,15 +761,15 @@ impl PartialEq for String {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -780,65 +783,66 @@ macro_rules! impl_eq {\n impl_eq! { String, &'a str }\n impl_eq! { CowString<'a>, String }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     #[inline]\n     fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[unstable = \"waiting on Str stabilization\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n impl Str for String {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for String {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> String {\n         String::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-#[unstable = \"waiting on Hash stabilization\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n \n-#[unstable = \"recent addition, needs more experience\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"recent addition, needs more experience\")]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n@@ -849,31 +853,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self[][*index]\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self[][*index]\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self[][*index]\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::FullRange> for String {\n     type Output = str;\n     #[inline]\n@@ -882,7 +886,7 @@ impl ops::Index<ops::FullRange> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {\n     type Target = str;\n \n@@ -893,7 +897,7 @@ impl ops::Deref for String {\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n@@ -921,7 +925,7 @@ impl<'a> Deref for DerefString<'a> {\n /// let string = as_string(\"foo\").clone();\n /// string_consumer(string);\n /// ```\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n@@ -965,7 +969,7 @@ impl<'a> IntoCow<'a, String, str> for &'a str {\n }\n \n /// A clone-on-write string\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n impl<'a> Str for CowString<'a> {"}, {"sha": "367ab28e47bdca52340e7f0b5f4e605cf34c2940", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -44,7 +44,7 @@\n //! let two = xs.pop();\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -134,7 +134,7 @@ use core::uint;\n /// to reallocate, which can be slow. For this reason, it is recommended to use\n /// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n     len: uint,\n@@ -159,7 +159,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<int> = Vec::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n         // We want ptr to never be NULL so instead we set it to some arbitrary\n         // non-null value which is fine since we never call deallocate on the ptr\n@@ -194,7 +194,7 @@ impl<T> Vec<T> {\n     /// vec.push(11);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n@@ -243,7 +243,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -255,7 +255,8 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable = \"may be better expressed via composition\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n@@ -273,7 +274,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n@@ -292,7 +293,7 @@ impl<T> Vec<T> {\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             let err_msg = \"Vec::reserve: `uint` overflow\";\n@@ -321,7 +322,7 @@ impl<T> Vec<T> {\n     /// vec.reserve_exact(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             match self.len.checked_add(additional) {\n@@ -345,7 +346,7 @@ impl<T> Vec<T> {\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -376,7 +377,7 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n@@ -398,7 +399,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -422,7 +423,7 @@ impl<T> Vec<T> {\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -446,7 +447,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -477,7 +478,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n@@ -503,7 +504,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: uint) -> T {\n         let length = self.len();\n         self.swap(index, length - 1);\n@@ -527,7 +528,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -563,7 +564,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: uint) -> T {\n         let len = self.len();\n         assert!(index < len);\n@@ -597,7 +598,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0u;\n@@ -631,7 +632,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -669,7 +670,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n             None\n@@ -696,7 +697,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, vec![]);\n     /// ```\n     #[inline]\n-    #[unstable = \"new API, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -732,7 +734,8 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n             let begin = *self.ptr as *const T;\n@@ -762,7 +765,7 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.truncate(0)\n     }\n@@ -776,7 +779,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.len }\n \n     /// Returns `true` if the vector contains no elements.\n@@ -790,7 +793,7 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n@@ -814,7 +817,8 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[unstable = \"API may change to provide stronger guarantees\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"API may change to provide stronger guarantees\")]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n         // size.\n@@ -1005,7 +1009,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, vec![2, 3]);\n     /// ```\n     #[inline]\n-    #[unstable = \"new API, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"new API, waiting for dust to settle\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at < self.len(), \"`at` out of bounds\");\n \n@@ -1044,7 +1049,8 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification; waiting for dust to settle\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n \n@@ -1068,7 +1074,8 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[unstable = \"likely to be replaced by a more optimized extend\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be replaced by a more optimized extend\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n@@ -1102,7 +1109,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1236,7 +1243,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n@@ -1265,7 +1272,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1275,7 +1282,7 @@ impl<T> Index<uint> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1286,31 +1293,31 @@ impl<T> IndexMut<uint> for Vec<T> {\n }\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1319,31 +1326,31 @@ impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1352,19 +1359,19 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n@@ -1377,7 +1384,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Extend stability\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n@@ -1452,18 +1459,19 @@ macro_rules! impl_eq_for_cowvec {\n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable = \"waiting on PartialOrd stability\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"waiting on PartialOrd stability\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(other.as_slice())\n     }\n }\n \n-#[unstable = \"waiting on Eq stability\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Eq stability\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[unstable = \"waiting on Ord stability\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Ord stability\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -1483,7 +1491,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -1494,7 +1502,8 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"recent addition, needs more experience\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"recent addition, needs more experience\")]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     type Output = Vec<T>;\n \n@@ -1506,7 +1515,7 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n@@ -1522,15 +1531,15 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Vec<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(self.as_slice(), f)\n@@ -1548,11 +1557,12 @@ impl<'a> fmt::Writer for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"unclear how valuable this alias is\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"unclear how valuable this alias is\")]\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n     fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1576,7 +1586,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that moves out of a vector.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n@@ -1590,7 +1600,7 @@ unsafe impl<T: Sync> Sync for IntoIter<T> { }\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n@@ -1601,7 +1611,7 @@ impl<T> IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1638,7 +1648,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n@@ -1662,11 +1672,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -1681,14 +1691,15 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n-#[unstable = \"recently added as part of collections reform 2\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"recently added as part of collections reform 2\")]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n     end: *const T,\n     marker: ContravariantLifetime<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1725,7 +1736,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1749,11 +1760,11 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // self.ptr == self.end == null if drop has already been called,\n@@ -1769,13 +1780,13 @@ impl<'a, T> Drop for Drain<'a, T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct DerefVec<'a, T> {\n     x: Vec<T>,\n     l: ContravariantLifetime<'a>\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1786,7 +1797,7 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1795,7 +1806,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n }\n \n /// Convert a slice to a wrapper type providing a `&Vec<T>` reference.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "3d28284c9bf97e55245fea7c0f6d68e6805bb9a3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -66,9 +66,9 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Default for VecMap<V> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n@@ -107,7 +107,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -119,7 +119,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n@@ -135,7 +135,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.v.capacity()\n     }\n@@ -154,7 +154,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -178,7 +178,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len_exact(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -188,7 +188,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all keys in ascending order of the keys.\n     /// The iterator's element type is `uint`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n@@ -198,7 +198,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all values in ascending order of the keys.\n     /// The iterator's element type is `&'r V`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n@@ -224,7 +224,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n         Iter {\n             front: 0,\n@@ -255,7 +255,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n         IterMut {\n             front: 0,\n@@ -282,7 +282,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -310,7 +310,8 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -332,7 +333,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -349,7 +350,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -366,7 +367,7 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.v.clear() }\n \n     /// Returns a reference to the value corresponding to the key.\n@@ -381,7 +382,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -406,7 +407,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key(&self, key: &uint) -> bool {\n         self.get(key).is_some()\n     }\n@@ -426,7 +427,7 @@ impl<V> VecMap<V> {\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n@@ -454,7 +455,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n@@ -476,7 +477,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n@@ -486,33 +487,33 @@ impl<V> VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n         iter::order::eq(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: Eq> Eq for VecMap<V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n     fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n     fn cmp(&self, other: &VecMap<V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"VecMap {{\"));\n@@ -526,7 +527,7 @@ impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n@@ -535,7 +536,7 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n@@ -553,7 +554,7 @@ impl<V> Index<uint> for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<uint> for VecMap<V> {\n     type Output = V;\n \n@@ -565,7 +566,7 @@ impl<V> IndexMut<uint> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, V> Iterator for $name<'a, V> {\n             type Item = $elem;\n \n@@ -600,7 +601,7 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, V> DoubleEndedIterator for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -626,7 +627,7 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -649,7 +650,7 @@ double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -660,7 +661,7 @@ iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n     iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n@@ -675,7 +676,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n }\n \n /// An iterator over the values of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n     iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n@@ -690,7 +691,7 @@ impl<'a, V> Clone for Values<'a, V> {\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -699,7 +700,7 @@ pub struct IntoIter<V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -708,51 +709,51 @@ pub struct Drain<'a, V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Keys<'a, V> {\n     type Item = uint;\n \n     fn next(&mut self) -> Option<uint> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n     fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Values<'a, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Iterator for IntoIter<V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> DoubleEndedIterator for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }"}, {"sha": "87030ed778da767d7139dffd54a6d1c85b2785db", "filename": "src/libcore/any.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -69,7 +69,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem::transmute;\n use option::Option::{self, Some, None};\n@@ -86,10 +86,11 @@ use marker::Sized;\n ///\n /// Every type with no non-`'static` references implements `Any`, so `Any` can\n /// be used as a trait object to emulate the effects dynamic typing.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n-    #[unstable = \"this method will likely be replaced by an associated static\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }\n \n@@ -103,7 +104,7 @@ impl<T: 'static> Any for T {\n \n impl Any {\n     /// Returns true if the boxed type is the same as `T`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: 'static>(&self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n@@ -118,7 +119,7 @@ impl Any {\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n         if self.is::<T>() {\n@@ -136,7 +137,7 @@ impl Any {\n \n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n@@ -167,15 +168,16 @@ impl Any {\n /// but this limitation may be removed in the future.\n #[cfg_attr(stage0, lang = \"type_id\")]\n #[derive(Clone, Copy, PartialEq, Eq, Show, Hash)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,\n }\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n-    #[unstable = \"may grow a `Reflect` bound soon via marker traits\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"may grow a `Reflect` bound soon via marker traits\")]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },"}, {"sha": "44541c34ee278fb6637a586502994b4ac716424d", "filename": "src/libcore/array.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,7 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![unstable] // not yet reviewed\n+#![unstable(feature = \"core\")] // not yet reviewed\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -26,7 +26,7 @@ use option::Option;\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self\n@@ -39,14 +39,14 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                     fmt::Debug::fmt(&&self[], f)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n@@ -58,7 +58,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n                 A: PartialEq<B>,\n                 Rhs: Deref<Target=[B]>,\n@@ -73,7 +73,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n                 A: PartialEq<B>,\n                 Lhs: Deref<Target=[A]>\n@@ -88,10 +88,10 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Eq> Eq for [T; $N] { }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n@@ -115,7 +115,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {"}, {"sha": "cf2854be016e1da9b9c9d17fab2e136d0b299743", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -68,7 +68,7 @@\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -78,31 +78,31 @@ use intrinsics;\n use cell::UnsafeCell;\n \n /// A boolean type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicIsize {\n     v: UnsafeCell<isize>,\n }\n \n unsafe impl Sync for AtomicIsize {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicUsize {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicUsize {}\n \n /// A raw pointer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<usize>,\n }\n@@ -119,42 +119,42 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n ///\n /// Rust's memory orderings are [the same as\n /// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An `AtomicBool` initialized to `false`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicIsize` initialized to `0`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n         AtomicIsize { v: UnsafeCell { value: 0 } };\n /// An `AtomicUsize` initialized to `0`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_USIZE_INIT: AtomicUsize =\n         AtomicUsize { v: UnsafeCell { value: 0, } };\n \n@@ -173,7 +173,7 @@ impl AtomicBool {\n     /// let atomic_false = AtomicBool::new(false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val) }\n@@ -197,7 +197,7 @@ impl AtomicBool {\n     /// let value = some_bool.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get(), order) > 0 }\n     }\n@@ -220,7 +220,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -241,7 +241,7 @@ impl AtomicBool {\n     /// let value = some_bool.swap(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -265,7 +265,7 @@ impl AtomicBool {\n     /// let value = some_bool.store(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -298,7 +298,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -331,7 +331,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -363,7 +363,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -395,15 +395,15 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AtomicIsize {\n     /// Creates a new `AtomicIsize`.\n     ///\n@@ -580,7 +580,7 @@ impl AtomicIsize {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AtomicUsize {\n     /// Creates a new `AtomicUsize`.\n     ///\n@@ -769,7 +769,7 @@ impl<T> AtomicPtr<T> {\n     /// let atomic_ptr  = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as usize) }\n     }\n@@ -793,7 +793,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get(), order) as *mut T\n@@ -821,7 +821,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n     }\n@@ -843,7 +843,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n     }\n@@ -869,7 +869,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as usize,\n@@ -890,7 +890,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -902,7 +902,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -915,7 +915,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -928,7 +928,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -940,7 +940,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -952,7 +952,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -964,7 +964,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -977,7 +977,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -990,7 +990,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -1023,7 +1023,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is `Relaxed`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {\n     unsafe {\n         match order {\n@@ -1036,27 +1036,35 @@ pub fn fence(order: Ordering) {\n     }\n }\n \n-#[deprecated=\"renamed to AtomicIsize\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"renamed to AtomicIsize\")]\n #[allow(missing_docs)]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n }\n \n unsafe impl Sync for AtomicInt {}\n \n-#[deprecated=\"renamed to AtomicUsize\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"renamed to AtomicUsize\")]\n #[allow(missing_docs)]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n }\n \n unsafe impl Sync for AtomicUint {}\n \n-#[deprecated=\"use ATOMIC_ISIZE_INIT instead\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use ATOMIC_ISIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n-#[deprecated=\"use ATOMIC_USIZE_INIT instead\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use ATOMIC_USIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };"}, {"sha": "be144b052c7867056ab49a61770531a4b1aedf46", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -42,7 +42,8 @@\n //! is desired, `to_mut` will obtain a mutable references to an owned\n //! value, cloning if necessary.\n \n-#![unstable = \"recently added as part of collections reform\"]\n+#![unstable(feature = \"core\",\n+            reason = \"recently added as part of collections reform\")]\n \n use clone::Clone;\n use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n@@ -141,7 +142,7 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n@@ -195,7 +196,7 @@ impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n@@ -207,18 +208,18 @@ impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n@@ -229,15 +230,15 @@ impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T,\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n     B: fmt::Debug + ToOwned<T>,\n     T: fmt::Debug,\n@@ -250,7 +251,7 @@ impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> fmt::Display for Cow<'a, T, B> where\n     B: fmt::Display + ToOwned<T>,\n     T: fmt::Display,"}, {"sha": "02cc4038a69bc7b140bcf527a81d58d87bb4374a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -139,7 +139,7 @@\n //! ```\n //!\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::PartialEq;\n@@ -152,7 +152,7 @@ use option::Option::{None, Some};\n /// A mutable memory location that admits only `Copy` data.\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n }\n@@ -167,7 +167,7 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// let c = Cell::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -186,7 +186,7 @@ impl<T:Copy> Cell<T> {\n     /// let five = c.get();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n@@ -203,7 +203,7 @@ impl<T:Copy> Cell<T> {\n     /// c.set(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;\n@@ -226,31 +226,31 @@ impl<T:Copy> Cell<T> {\n     /// let uc = unsafe { c.as_unsafe_cell() };\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for Cell<T> where T: Send {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Copy> Clone for Cell<T> {\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default + Copy> Default for Cell<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n@@ -260,7 +260,7 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n@@ -282,7 +282,7 @@ impl<T> RefCell<T> {\n     ///\n     /// let c = RefCell::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n@@ -301,7 +301,7 @@ impl<T> RefCell<T> {\n     ///\n     /// let five = c.into_inner();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -316,7 +316,7 @@ impl<T> RefCell<T> {\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable = \"may be renamed or removed\"]\n+    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -359,7 +359,7 @@ impl<T> RefCell<T> {\n     ///\n     /// assert!(result.is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n@@ -373,7 +373,7 @@ impl<T> RefCell<T> {\n     /// cannot be borrowed while this borrow is active.\n     ///\n     /// Returns `None` if the value is currently borrowed.\n-    #[unstable = \"may be renamed or removed\"]\n+    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -415,7 +415,7 @@ impl<T> RefCell<T> {\n     ///\n     /// assert!(result.is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n@@ -429,31 +429,31 @@ impl<T> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for RefCell<T> where T: Send {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default> Default for RefCell<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -496,18 +496,19 @@ impl<'b> Clone for BorrowRef<'b> {\n     }\n }\n \n+/// Wraps a borrowed reference to a value in a `RefCell` box.\n /// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b T,\n     _borrow: BorrowRef<'b>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> Deref for Ref<'b, T> {\n     type Target = T;\n \n@@ -523,7 +524,8 @@ impl<'b, T> Deref for Ref<'b, T> {\n ///\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n-#[unstable = \"likely to be moved to a method, pending language changes\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be moved to a method, pending language changes\")]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n         _value: orig._value,\n@@ -559,15 +561,15 @@ impl<'b> BorrowRefMut<'b> {\n /// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b mut T,\n     _borrow: BorrowRefMut<'b>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> Deref for RefMut<'b, T> {\n     type Target = T;\n \n@@ -577,7 +579,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n@@ -619,13 +621,13 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n /// recommended to access its fields directly, `get` should be used instead.\n #[lang=\"unsafe\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n     /// Wrapped value\n     ///\n     /// This field should not be accessed directly, it is made public for static\n     /// initializers.\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub value: T,\n }\n \n@@ -643,7 +645,7 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// let uc = UnsafeCell::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n@@ -660,7 +662,7 @@ impl<T> UnsafeCell<T> {\n     /// let five = uc.get();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n@@ -680,6 +682,6 @@ impl<T> UnsafeCell<T> {\n     /// let five = unsafe { uc.into_inner() };\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn into_inner(self) -> T { self.value }\n }"}, {"sha": "22bfd47893c973700a20b7529a86af892cfd04c6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -64,12 +64,12 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n /// Converts from `u32` to a `char`\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n@@ -92,7 +92,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// Panics if given an `radix` > 36.\n ///\n #[inline]\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n@@ -111,7 +111,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n }\n \n /// Basic `char` manipulations.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CharExt {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -126,7 +126,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n@@ -140,7 +141,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n@@ -149,7 +151,7 @@ pub trait CharExt {\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n@@ -164,44 +166,46 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n@@ -216,12 +220,12 @@ impl CharExt for char {\n         else { None }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode {\n         EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n@@ -237,7 +241,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint {\n         let code = self as u32;\n         match () {\n@@ -249,20 +253,22 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n         encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n         encode_utf16_raw(self as u32, dst)\n     }\n@@ -274,7 +280,7 @@ impl CharExt for char {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && dst.len() >= 1 {\n@@ -306,7 +312,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n@@ -327,14 +333,14 @@ pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n     c: char,\n     state: EscapeUnicodeState\n }\n \n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -344,7 +350,7 @@ enum EscapeUnicodeState {\n     Done,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeUnicode {\n     type Item = char;\n \n@@ -390,21 +396,21 @@ impl Iterator for EscapeUnicode {\n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n     state: EscapeDefaultState\n }\n \n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),\n     Done,\n     Unicode(EscapeUnicode),\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = char;\n "}, {"sha": "28c306fc0099f2bce5cbf9a73138e11b703d1551", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -19,15 +19,15 @@\n //! explicitly, by convention implementing the `Clone` trait and calling\n //! the `clone` method.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A common trait for cloning an object.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone(&self) -> Self;\n \n     /// Perform copy-assignment from `source`.\n@@ -36,13 +36,14 @@ pub trait Clone : Sized {\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n     #[inline(always)]\n-    #[unstable = \"this function is rarely used\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"this function is rarely used\")]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n@@ -51,7 +52,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n \n macro_rules! clone_impl {\n     ($t:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n             #[inline]\n@@ -81,7 +82,8 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[unstable = \"this may not be sufficient for fns with region parameters\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"this may not be sufficient for fns with region parameters\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Return a copy of a function pointer\n             #[inline]"}, {"sha": "2ecbd55fcb1d542c830ab1d351baa254b824eea3", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -39,7 +39,7 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -68,16 +68,16 @@ use option::Option::{self, Some, None};\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n #[lang=\"eq\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[old_orphan_check]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n@@ -90,7 +90,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -106,16 +106,16 @@ pub trait Eq: PartialEq<Self> {\n \n /// An ordering is, e.g, a result of a comparison between two values.\n #[derive(Clone, Copy, PartialEq, Show)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Ordering {\n     /// An ordering where a compared value is less [than another].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Less = -1,\n     /// An ordering where a compared value is equal [to another].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Equal = 0,\n     /// An ordering where a compared value is greater [than another].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Greater = 1,\n }\n \n@@ -141,7 +141,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         unsafe {\n             // this compiles really nicely (to a single instruction);\n@@ -164,7 +164,7 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -178,26 +178,26 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ordering {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Ordering {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ordering {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as int).partial_cmp(&(*other as int))\n     }\n@@ -224,16 +224,16 @@ impl PartialOrd for Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n@@ -243,7 +243,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n@@ -253,7 +253,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n@@ -263,7 +263,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n@@ -274,14 +274,14 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n /// Compare and return the minimum of two values.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n@@ -290,7 +290,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -303,7 +303,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) => Some(v2),\n@@ -322,7 +322,7 @@ mod impls {\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -332,7 +332,7 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -346,7 +346,7 @@ mod impls {\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl Eq for $t {}\n         )*)\n     }\n@@ -355,7 +355,7 @@ mod impls {\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -378,15 +378,15 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -398,7 +398,7 @@ mod impls {\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -410,13 +410,13 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -428,14 +428,14 @@ mod impls {\n \n     // & pointers\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n@@ -450,24 +450,24 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n@@ -482,23 +482,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }"}, {"sha": "d79b613f589495c92ef4f360c6103386af567e65", "filename": "src/libcore/default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -81,7 +81,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n /// A trait that types which have a useful default value should implement.\n ///\n@@ -97,7 +97,7 @@\n ///     bar: f32,\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Default {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -131,16 +131,16 @@ pub trait Default {\n     ///     fn default() -> Kind { Kind::A }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Self;\n }\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Default for $t {\n             #[inline]\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             fn default() -> $t { $v }\n         }\n     }"}, {"sha": "71d5e88cccff70e9cd647e3bacf66ff9476eab09", "filename": "src/libcore/error.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -79,13 +79,14 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::*;\n use fmt::Display;\n \n /// Base functionality for all errors in Rust.\n-#[unstable = \"the exact API of this trait may change\"]\n+#[unstable(feature = \"core\",\n+           reason = \"the exact API of this trait may change\")]\n pub trait Error: Display {\n     /// A short description of the error; usually a static string.\n     fn description(&self) -> &str;\n@@ -95,14 +96,15 @@ pub trait Error: Display {\n }\n \n /// A trait for types that can be converted from a given error type `E`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromError<E> {\n     /// Perform the conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_error(err: E) -> Self;\n }\n \n // Any type is convertable from itself\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E> FromError<E> for E {\n     fn from_error(err: E) -> E {\n         err"}, {"sha": "0f444ef186f9abe37ec960601b91a334c3cc74d0", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -30,10 +30,12 @@\n //! })\n //! ```\n \n-#![deprecated = \"It is unclear if this module is more robust than implementing \\\n-                 Drop on a custom type, and this module is being removed with no \\\n-                 replacement. Use a custom Drop implementation to regain existing \\\n-                 functionality.\"]\n+#![unstable(feature = \"core\")]\n+#![deprecated(since = \"1.0.0\",\n+              reason = \"It is unclear if this module is more robust than implementing \\\n+                        Drop on a custom type, and this module is being removed with no \\\n+                        replacement. Use a custom Drop implementation to regain existing \\\n+                        functionality.\")]\n #![allow(deprecated)]\n \n use ops::{Drop, FnMut, FnOnce};"}, {"sha": "06428ad2f39a66e23b43e53c17c431bff45e8381", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 89, "deletions": 62, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -11,7 +11,7 @@\n //! Utilities for formatting and printing strings\n \n #![allow(unused_variables)]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any;\n use cell::{Cell, RefCell, Ref, RefMut};\n@@ -39,7 +39,8 @@ mod num;\n mod float;\n pub mod rt;\n \n-#[unstable = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable(feature = \"core\",\n+           reason = \"core and I/O reconciliation may alter this definition\")]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n@@ -48,7 +49,8 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[unstable = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable(feature = \"core\",\n+           reason = \"core and I/O reconciliation may alter this definition\")]\n #[derive(Copy, Show)]\n pub struct Error;\n \n@@ -61,7 +63,8 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[unstable = \"waiting for core and I/O reconciliation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"waiting for core and I/O reconciliation\")]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -104,7 +107,8 @@ pub trait Writer {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-#[unstable = \"name may change and implemented traits are also unstable\"]\n+#[unstable(feature = \"core\",\n+           reason = \"name may change and implemented traits are also unstable\")]\n pub struct Formatter<'a> {\n     flags: uint,\n     fill: char,\n@@ -126,7 +130,8 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"core\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n #[derive(Copy)]\n pub struct Argument<'a> {\n     value: &'a Void,\n@@ -165,7 +170,8 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn new(pieces: &'a [&'a str],\n                args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -182,7 +188,8 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n                              fmt: &'a [rt::Argument],\n                              args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -203,7 +210,7 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n@@ -217,14 +224,14 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Debug for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         Display::fmt(self, fmt)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Display for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n@@ -233,7 +240,9 @@ impl<'a> Display for Arguments<'a> {\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[deprecated = \"renamed to Debug\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n #[cfg(not(stage0))]\n pub trait Show {\n     /// Formats the value using the given formatter.\n@@ -242,7 +251,8 @@ pub trait Show {\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is defined in your \\\n                             crate, add `#[derive(Debug)]` or manually implement it\"]\n #[lang = \"debug_trait\"]\n@@ -259,7 +269,8 @@ impl<T: Show + ?Sized> Debug for T {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[deprecated = \"renamed to Display\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n #[cfg(not(stage0))]\n pub trait String {\n     /// Formats the value using the given formatter.\n@@ -268,7 +279,8 @@ pub trait String {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default formatter; try using \\\n                             `:?` instead if you are using a format string\"]\n pub trait Display {\n@@ -283,49 +295,56 @@ impl<T: String + ?Sized> Display for T {\n }\n \n /// Format trait for the `o` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -339,8 +358,9 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[unstable = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                  implementation detail which should not otherwise be exported\"]\n+#[unstable(feature = \"core\",\n+           reason = \"libcore and I/O have yet to be reconciled, and this is an \\\n+                     implementation detail which should not otherwise be exported\")]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n@@ -436,7 +456,8 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    #[unstable = \"definition may change slightly over time\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"definition may change slightly over time\")]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n@@ -512,7 +533,8 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    #[unstable = \"definition may change slightly over time\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"definition may change slightly over time\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n@@ -589,39 +611,42 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n         self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[unstable = \"return type may change and method was just created\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return type may change and method was just created\")]\n     pub fn flags(&self) -> uint { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn align(&self) -> rt::Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn width(&self) -> Option<uint> { self.width }\n \n     /// Optionally specified precision for numeric types\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<uint> { self.precision }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Display::fmt(\"an error occurred when formatting an argument\", f)\n@@ -631,7 +656,8 @@ impl Display for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"core\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     Argument::new(t, f)\n@@ -640,7 +666,8 @@ pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"core\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     Argument::from_uint(s)\n }\n@@ -650,11 +677,11 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n macro_rules! fmt_refs {\n     ($($tr:ident),*) => {\n         $(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T: ?Sized + $tr> $tr for &'a T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n@@ -664,21 +691,21 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Display::fmt(self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         try!(write!(f, \"\\\"\"));\n@@ -689,14 +716,14 @@ impl Debug for str {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n@@ -708,7 +735,7 @@ impl Debug for char {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n@@ -718,7 +745,7 @@ impl Display for char {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n@@ -728,21 +755,21 @@ impl<T> Pointer for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(&**self as *const T), f)\n@@ -751,14 +778,14 @@ impl<'a, T> Pointer for &'a mut T {\n \n macro_rules! floating { ($ty:ident) => {\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             Display::fmt(self, fmt)\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -780,7 +807,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -802,7 +829,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -829,11 +856,11 @@ floating! { f64 }\n \n // Implementation of Display/Debug for various core types\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Debug for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Debug for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n@@ -845,7 +872,7 @@ macro_rules! peel {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($name:Debug),*> Debug for ($($name,)*) {\n             #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n@@ -871,12 +898,12 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Debug for &'a (any::Any+'a) {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n@@ -898,21 +925,21 @@ impl<T: Debug> Debug for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         write!(f, \"Cell {{ value: {:?} }}\", self.get())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.try_borrow() {\n@@ -922,14 +949,14 @@ impl<T: Debug> Debug for RefCell<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: Debug> Debug for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: Debug> Debug for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&*(self.deref()), f)"}, {"sha": "1222126b5e0cdef73c0a3bccc4ce5dff3630c90f", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -111,7 +111,8 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[derive(Clone, Copy, PartialEq)]\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or move to a different module\")]\n pub struct Radix {\n     base: u8,\n }\n@@ -135,7 +136,8 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or move to a different module\")]\n #[derive(Copy)]\n pub struct RadixFmt<T, R>(T, R);\n \n@@ -147,20 +149,21 @@ pub struct RadixFmt<T, R>(T, R);\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or move to a different module\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }\n \n macro_rules! radix_fmt {\n     ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Debug for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 fmt::Display::fmt(self, f)\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Display for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n@@ -170,7 +173,7 @@ macro_rules! radix_fmt {\n }\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::$Trait for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 $Radix.fmt_int(*self as $U, f)\n@@ -181,7 +184,7 @@ macro_rules! int_base {\n \n macro_rules! show {\n     ($T:ident with $S:expr) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Debug for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 fmt::Display::fmt(self, f)"}, {"sha": "0b2c1efbc5dee1682228f5e2ea263589265c2ee0", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,8 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![unstable = \"implementation detail of the `format_args!` macro\"]\n+#![unstable(feature = \"core\",\n+            reason = \"implementation detail of the `format_args!` macro\")]\n \n pub use self::Alignment::*;\n pub use self::Count::*;"}, {"sha": "5a4d2fffade6348598849c7ac29aafabc8078aa7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -56,7 +56,8 @@\n //! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![unstable = \"module was recently redesigned\"]\n+#![unstable(feature = \"hash\",\n+            reason = \"module was recently redesigned\")]\n \n use prelude::*;\n \n@@ -95,7 +96,8 @@ pub trait Hasher {\n \n /// A common bound on the `Hasher` parameter to `Hash` implementations in order\n /// to generically hash an aggregate.\n-#[experimental = \"this trait will likely be replaced by io::Writer\"]\n+#[unstable(feature = \"hash\",\n+           reason = \"this trait will likely be replaced by io::Writer\")]\n #[allow(missing_docs)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);"}, {"sha": "bef196d48246040ebef25f1d7688ae907a58eff0", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -112,7 +112,8 @@ impl SipHasher {\n     }\n \n     /// Returns the computed hash.\n-    #[deprecated = \"renamed to finish\"]\n+    #[unstable(feature = \"hash\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to finish\")]\n     pub fn result(&self) -> u64 { self.finish() }\n }\n "}, {"sha": "dd6b1e7b4e8325d4c025a455e85f79bbc19fbc35", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -39,7 +39,7 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable]\n+#![unstable(feature = \"core\")]\n #![allow(missing_docs)]\n \n use marker::Sized;\n@@ -221,7 +221,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn forget<T>(_: T) -> ();\n \n     /// Unsafely transforms a value of one type into a value of another type.\n@@ -237,7 +237,7 @@ extern \"rust-intrinsic\" {\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n     /// assert!(v == [76u8]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Gives the address for the return value of the enclosing function.\n@@ -297,7 +297,7 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -327,12 +327,13 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[unstable = \"uncertain about naming and semantics\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"uncertain about naming and semantics\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "74d8a7ae1d6b56913cd10cf9afd36baa65d03fc7", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 196, "deletions": 172, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -54,7 +54,7 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::MinMaxResult::*;\n \n@@ -81,23 +81,23 @@ use usize;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling `.iter()` or a similar \\\n                             method\"]\n pub trait Iterator {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `usize`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n }\n \n@@ -116,7 +116,7 @@ impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n }\n \n /// Conversion from an `Iterator`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n@@ -125,15 +125,15 @@ pub trait FromIterator<A> {\n }\n \n /// A type growable from an `Iterator` implementation\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n /// An extension trait providing numerous methods applicable to all iterators.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IteratorExt: Iterator + Sized {\n     /// Counts the number of elements in this iterator.\n     ///\n@@ -144,7 +144,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n@@ -159,7 +159,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(mut self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n@@ -178,7 +178,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n@@ -202,7 +202,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<U>(self, other: U) -> Chain<Self, U> where\n         U: Iterator<Item=Self::Item>,\n     {\n@@ -224,7 +224,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n         U: Iterator<Item=B>,\n     {\n@@ -244,7 +244,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> B,\n     {\n@@ -264,7 +264,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -284,7 +284,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n@@ -304,7 +304,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> {\n         Enumerate{iter: self, count: 0}\n     }\n@@ -327,7 +327,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn peekable(self) -> Peekable<Self::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n@@ -347,7 +347,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -368,7 +368,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -388,7 +388,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: usize) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n@@ -407,7 +407,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n@@ -433,7 +433,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -459,7 +459,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(Self::Item) -> U,\n@@ -495,7 +495,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fuse(self) -> Fuse<Self> {\n         Fuse{iter: self, done: false}\n     }\n@@ -519,7 +519,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n         F: FnMut(&Self::Item),\n     {\n@@ -540,7 +540,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(partial_sum == 10);\n     /// assert!(it.next() == Some(5));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n         ByRef{iter: self}\n     }\n@@ -556,7 +556,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(a, b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -572,7 +572,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n-    #[unstable = \"recently added as part of collections reform\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added as part of collections reform\")]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n@@ -601,7 +602,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, Self::Item) -> B,\n     {\n@@ -622,7 +623,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -642,7 +643,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -660,7 +661,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n     /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -682,7 +683,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n     /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n     {\n@@ -710,7 +711,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n     /// assert_eq!(it.as_slice(), [1, 2]);\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n@@ -733,7 +734,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |max, x| {\n@@ -753,7 +754,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |min, x| {\n@@ -794,7 +795,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// let a = [1, 1, 1, 1];\n     /// assert!(a.iter().min_max() == MinMax(&1, &1));\n     /// ```\n-    #[unstable = \"return type may change\"]\n+    #[unstable(feature = \"core\", reason = \"return type may change\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n@@ -851,7 +852,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n     {\n@@ -880,7 +882,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n     {\n@@ -910,7 +913,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Note: Random access with flipped indices still only applies to the first\n     /// `std::usize::MAX` elements of the original iterator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> {\n         Rev{iter: self}\n     }\n@@ -928,7 +931,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!([1, 3], left);\n     /// assert_eq!([2, 4], right);\n     /// ```\n-    #[unstable = \"recent addition\"]\n+    #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -961,7 +964,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Creates an iterator that clones the elements it yields. Useful for converting an\n     /// Iterator<&T> to an Iterator<T>.\n-    #[unstable = \"recent addition\"]\n+    #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn cloned<T, D>(self) -> Cloned<Self> where\n         Self: Iterator<Item=D>,\n         D: Deref<Target=T>,\n@@ -981,14 +984,15 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn cycle(self) -> Cycle<Self> where Self: Clone {\n         Cycle{orig: self.clone(), iter: self}\n     }\n \n     /// Use an iterator to reverse a container in place.\n-    #[unstable = \"uncertain about placement or widespread use\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"uncertain about placement or widespread use\")]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n     {\n@@ -1001,17 +1005,17 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n@@ -1021,7 +1025,8 @@ pub trait DoubleEndedIterator: Iterator {\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n-#[unstable = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n+#[unstable(feature = \"core\",\n+           reason = \"not widely used, may be better decomposed into Index and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -1038,7 +1043,7 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `usize`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n@@ -1055,32 +1060,32 @@ pub trait ExactSizeIterator: Iterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rev<T> {\n     iter: T\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1090,13 +1095,13 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize { self.iter.indexable() }\n@@ -1109,12 +1114,12 @@ impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAcc\n \n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1124,17 +1129,18 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> ExactSizeIterator for ByRef<'a, I> where I: 'a + ExactSizeIterator {}\n \n /// A trait for iterators over elements which can be added together\n-#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable(feature = \"core\",\n+           reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n@@ -1152,7 +1158,7 @@ pub trait AdditiveIterator<A> {\n \n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n-        #[unstable = \"trait is experimental\"]\n+        #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n@@ -1175,7 +1181,8 @@ impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n-#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable(feature = \"core\",\n+           reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n@@ -1196,7 +1203,7 @@ pub trait MultiplicativeIterator<A> {\n \n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n-        #[unstable = \"trait is experimental\"]\n+        #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n@@ -1220,7 +1227,8 @@ impl_multiplicative! { f64,  1.0 }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable = \"unclear whether such a fine-grained result is widely useful\"]\n+#[unstable(feature = \"core\",\n+           reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1252,7 +1260,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1, 2);\n     /// assert_eq!(r.into_option(), Some((1, 2)));\n     /// ```\n-    #[unstable = \"type is unstable\"]\n+    #[unstable(feature = \"core\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1263,14 +1271,14 @@ impl<T: Clone> MinMaxResult<T> {\n }\n \n /// An iterator that clones the elements of an underlying iterator\n-#[unstable = \"recent addition\"]\n+#[unstable(feature = \"core\", reason = \"recent addition\")]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[derive(Clone)]\n pub struct Cloned<I> {\n     it: I,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1287,7 +1295,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1298,7 +1306,7 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1308,13 +1316,13 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n     orig: I,\n     iter: I,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1337,7 +1345,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1367,14 +1375,14 @@ impl<I> RandomAccessIterator for Cycle<I> where\n /// An iterator that strings two iterators together\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n     a: A,\n     b: B,\n     flag: bool,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1408,7 +1416,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator<Item=T>,\n     B: DoubleEndedIterator<Item=T>,\n@@ -1422,7 +1430,7 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=T>,\n@@ -1447,13 +1455,13 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n /// An iterator that iterates two other iterators simultaneously\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n     a: A,\n     b: B\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1489,7 +1497,7 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     A: DoubleEndedIterator + ExactSizeIterator<Item=T>,\n     B: DoubleEndedIterator + ExactSizeIterator<Item=U>,\n@@ -1514,7 +1522,7 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=U>,\n@@ -1538,14 +1546,14 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n \n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> B,\n@@ -1568,7 +1576,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1584,7 +1592,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1596,7 +1604,7 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1615,14 +1623,14 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n \n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for Filter<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1635,7 +1643,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1658,7 +1666,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1676,14 +1684,14 @@ impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n \n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> Option<B>,\n@@ -1696,7 +1704,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1721,7 +1729,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1741,13 +1749,13 @@ impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n /// An iterator that yields the current count and the element during iteration\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n     count: usize\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (usize, <I as Iterator>::Item);\n \n@@ -1769,7 +1777,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Enumerate<I> where\n     I: ExactSizeIterator + DoubleEndedIterator\n {\n@@ -1785,7 +1793,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1803,14 +1811,14 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     iter: I,\n     peeked: Option<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1836,10 +1844,10 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> ExactSizeIterator for Peekable<T, I> where I: ExactSizeIterator<Item = T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n@@ -1863,15 +1871,15 @@ impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n \n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1885,7 +1893,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1909,15 +1917,15 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n \n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1931,7 +1939,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1964,13 +1972,13 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n /// An iterator that skips over `n` elements of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n     n: usize\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2014,7 +2022,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2031,19 +2039,19 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n \n /// An iterator that only iterates over the first `n` iterations of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n     iter: I,\n     n: usize\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2072,7 +2080,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2089,13 +2097,13 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n \n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2105,7 +2113,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Optio\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     I: Clone + Iterator<Item=A>,\n     St: Clone,\n@@ -2120,7 +2128,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2143,7 +2151,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2156,7 +2164,7 @@ pub struct FlatMap<A, B, I, U, F> where\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     I: Clone + Iterator<Item=A>,\n     U: Clone + Iterator<Item=B>,\n@@ -2172,7 +2180,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2207,7 +2215,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator<Item=A>,\n     U: DoubleEndedIterator<Item=B>,\n@@ -2234,13 +2242,13 @@ impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n /// yields `None` once.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n     iter: I,\n     done: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2269,7 +2277,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2288,7 +2296,7 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2301,14 +2309,14 @@ impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n \n impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n-    #[unstable = \"seems marginal\"]\n+    #[unstable(feature = \"core\", reason = \"seems marginal\")]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2317,14 +2325,14 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(&A),\n@@ -2349,7 +2357,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2365,7 +2373,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2377,7 +2385,7 @@ impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2426,15 +2434,15 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, St, F> Clone for Unfold<A, St, F> where\n     F: Clone + FnMut(&mut St) -> Option<A>,\n     St: Clone,\n@@ -2447,7 +2455,7 @@ impl<A, St, F> Clone for Unfold<A, St, F> where\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2460,7 +2468,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2479,7 +2487,8 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or replaced by range notation adapaters\")]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2489,12 +2498,13 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or replaced by range notation adapaters\")]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2513,7 +2523,8 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2534,7 +2545,8 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2544,7 +2556,8 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2594,7 +2607,8 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2609,23 +2623,26 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2660,7 +2677,8 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2679,7 +2697,8 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2689,13 +2708,15 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n \n@@ -2716,7 +2737,8 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2727,7 +2749,8 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2739,7 +2762,8 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2761,7 +2785,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n \n macro_rules! range_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Iterator for ::ops::Range<$t> {\n             type Item = $t;\n \n@@ -2784,14 +2808,14 @@ macro_rules! range_impl {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n macro_rules! range_impl_no_hint {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Iterator for ::ops::Range<$t> {\n             type Item = $t;\n \n@@ -2811,7 +2835,7 @@ macro_rules! range_impl_no_hint {\n \n macro_rules! range_other_impls {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl DoubleEndedIterator for ::ops::Range<$t> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$t> {\n@@ -2824,7 +2848,7 @@ macro_rules! range_other_impls {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Iterator for ::ops::RangeFrom<$t> {\n             type Item = $t;\n \n@@ -2849,12 +2873,12 @@ range_other_impls!(usize u8 u16 u32 u64 isize i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n     element: A\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2864,13 +2888,13 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> usize { usize::MAX }\n@@ -2882,12 +2906,12 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,\n@@ -2918,7 +2942,7 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n \n /// Create a new iterator that endlessly repeats the element `elt`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n     Repeat{element: elt}\n }\n@@ -2930,7 +2954,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[unstable = \"needs review and revision\"]\n+#[unstable(feature = \"core\", reason = \"needs review and revision\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "d4ca5e3f8dcb59412edf41546a970c773afdb933", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -48,7 +48,8 @@\n // separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_name = \"core\"]\n-#![unstable]\n+#![unstable(feature = \"core\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "943365d8454d4629ed65a6757aa17ef28817e961", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -52,7 +52,7 @@ macro_rules! panic {\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n@@ -79,7 +79,7 @@ macro_rules! assert {\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n@@ -123,7 +123,7 @@ macro_rules! assert_eq {\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n }\n@@ -185,7 +185,7 @@ macro_rules! write {\n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))\n@@ -235,7 +235,8 @@ macro_rules! writeln {\n /// }\n /// ```\n #[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n+#[unstable(feature = \"core\",\n+           reason = \"relationship with panic is unclear\")]\n macro_rules! unreachable {\n     () => ({\n         panic!(\"internal error: entered unreachable code\")\n@@ -251,7 +252,8 @@ macro_rules! unreachable {\n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n+#[unstable(feature = \"core\",\n+           reason = \"relationship with panic is unclear\")]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }"}, {"sha": "1fc3e34af5e31dafd1dc4e9cf903be7ef603947d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -23,20 +23,21 @@\n //! implemented using unsafe code. In that case, you may want to embed\n //! some of the marker types below into your type.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n \n /// Types able to be transferred across thread boundaries.\n-#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n pub unsafe trait Send: 'static {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n pub trait Sized {\n@@ -142,7 +143,7 @@ pub trait Sized {\n /// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n /// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty.\n@@ -193,7 +194,8 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n pub unsafe trait Sync {\n@@ -238,7 +240,8 @@ pub unsafe trait Sync {\n /// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n /// for some lifetime `'a`, but not the other way around).\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantType<T: ?Sized>;\n@@ -287,7 +290,8 @@ impl<T: ?Sized> Clone for CovariantType<T> {\n /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n /// function requires arguments of type `T`, it must also accept\n /// arguments of type `U`, hence such a conversion is safe.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantType<T: ?Sized>;\n@@ -317,14 +321,17 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// The type system would infer that `value` is only read here and\n /// never written, but in fact `Cell` uses unsafe code to achieve\n /// interior mutability.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantType<T: ?Sized>;\n \n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Clone for InvariantType<T> {\n     fn clone(&self) -> InvariantType<T> { *self }\n }\n@@ -345,7 +352,8 @@ impl<T: ?Sized> Clone for InvariantType<T> {\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantLifetime<'a>;\n@@ -362,7 +370,8 @@ pub struct CovariantLifetime<'a>;\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantLifetime<'a>;\n@@ -374,23 +383,26 @@ pub struct ContravariantLifetime<'a>;\n /// pointer that is actually a pointer into memory with lifetime `'a`,\n /// and this pointer is itself stored in an inherently mutable\n /// location (such as a `Cell`).\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantLifetime<'a>;\n \n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]\n pub struct NoCopy;\n \n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]"}, {"sha": "0d26c8e79142ae728bf071fc216143a496387841", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -13,13 +13,13 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n use intrinsics;\n use ptr;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n /// Moves a thing into the void.\n@@ -29,7 +29,7 @@ pub use intrinsics::transmute;\n ///\n /// This function is the unsafe version of the `drop` function because it does\n /// not run any destructors.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::forget;\n \n /// Returns the size of a type in bytes.\n@@ -42,7 +42,7 @@ pub use intrinsics::forget;\n /// assert_eq!(4, mem::size_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -57,7 +57,7 @@ pub fn size_of<T>() -> uint {\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n@@ -74,7 +74,7 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::min_align_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -89,7 +89,7 @@ pub fn min_align_of<T>() -> uint {\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n@@ -107,7 +107,7 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::align_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of<T>() -> uint {\n     // We use the preferred alignment as the default alignment for a type. This\n     // appears to be what clang migrated towards as well:\n@@ -129,7 +129,7 @@ pub fn align_of<T>() -> uint {\n /// assert_eq!(4, mem::align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of_val<T>(_val: &T) -> uint {\n     align_of::<T>()\n }\n@@ -153,7 +153,7 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n /// let x: int = unsafe { mem::zeroed() };\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n@@ -174,7 +174,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// let x: int = unsafe { mem::uninitialized() };\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n@@ -196,7 +196,7 @@ pub unsafe fn uninitialized<T>() -> T {\n /// assert_eq!(5, *y);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -261,7 +261,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src\n@@ -288,7 +288,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n@@ -311,24 +311,26 @@ pub fn drop<T>(_x: T) { }\n /// assert_eq!(1, one);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     ptr::read(src as *const T as *const U)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline]\n-#[unstable = \"this function may be removed in the future due to its \\\n-              questionable utility\"]\n+#[unstable(feature = \"core\",\n+           reason = \"this function may be removed in the future due to its \\\n+                     questionable utility\")]\n pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n-#[unstable = \"this function may be removed in the future due to its \\\n-              questionable utility\"]\n+#[unstable(feature = \"core\",\n+           reason = \"this function may be removed in the future due to its \\\n+                     questionable utility\")]\n pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n                                                             ptr: &mut T)\n                                                             -> &'a mut T {"}, {"sha": "495c7c2bc2e3a982f6d52a8073d432eb879e9fd1", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -32,7 +32,7 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show, Hash)]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {\n@@ -52,4 +52,4 @@ impl<T: Zeroable> Deref for NonZero<T> {\n         let NonZero(ref inner) = *self;\n         inner\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "83d070feb8a69303f7d2791cdcb2aebb649dc999", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,54 +14,55 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MANTISSA_DIGITS: uint = 24;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 6;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n /// Smallest positive, normalized f32 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n /// Largest finite f32 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -125;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 128;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -37;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 38;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f32 = 0.0_f32/0.0_f32;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants.\n-#[unstable = \"naming scheme needs to be revisited\"]\n+#[unstable(feature = \"core\",\n+           reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n@@ -117,7 +118,7 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }\n@@ -177,43 +178,53 @@ impl Float for f32 {\n     }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn digits(_: Option<f32>) -> uint { DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn epsilon() -> f32 { EPSILON }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_value() -> f32 { MIN_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_value() -> f32 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "ce011b3c2eeb6a40e2e33a462cad58da92dfdee6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,7 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n@@ -26,45 +26,46 @@ use option::Option;\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2;\n \n pub const MANTISSA_DIGITS: uint = 53;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 15;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n /// Smallest positive, normalized f64 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n /// Largest finite f64 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -1021;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 1024;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -307;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 308;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f64 = 0.0_f64/0.0_f64;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Various useful constants.\n-#[unstable = \"naming scheme needs to be revisited\"]\n+#[unstable(feature = \"core\",\n+           reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n@@ -124,7 +125,7 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }\n@@ -184,43 +185,53 @@ impl Float for f64 {\n     }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn digits(_: Option<f64>) -> uint { DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn epsilon() -> f64 { EPSILON }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_value() -> f64 { MIN_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_value() -> f64 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "5ea60d0d96d29f44943a0c751cf760d7c7deef0c", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n int_module! { i16, 16 }"}, {"sha": "7d9faa998c12e87769a8519d416b7085d802dcbf", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n int_module! { i32, 32 }"}, {"sha": "5a70911387b9b7192ab7a86fae52a90e77ddaa7b", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n int_module! { i64, 64 }"}, {"sha": "1d7d78ffa6c2352a20ad49cbfda99a0b3fc7ce17", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n int_module! { i8, 8 }"}, {"sha": "2132b9516abad0973d95c422f34e503f246c6c03", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,8 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by isize\"]\n+#![unstable(feature = \"core\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced by isize\")]\n \n #[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n #[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }"}, {"sha": "954c8a08e64d6bafdd15a6ef6c2fe9e6ad29e8c9", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,21 +14,21 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BITS : uint = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: $T = !MIN;\n \n ) }"}, {"sha": "0fd0d90b12501ea87b257bb523b56a1c6d0f1b47", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "9e460492b64bd9789d37c666d902e111d093a6c7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 113, "deletions": 75, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,7 @@\n \n //! Numeric traits and functions for the built-in numeric types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n use char::CharExt;\n@@ -30,7 +30,7 @@ use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -50,22 +50,26 @@ pub trait Int\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n \n     /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n \n     /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n     /// Returns the number of ones in the binary representation of `self`.\n@@ -79,7 +83,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn count_ones(self) -> uint;\n \n     /// Returns the number of zeros in the binary representation of `self`.\n@@ -93,7 +98,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     #[inline]\n     fn count_zeros(self) -> uint {\n         (!self).count_ones()\n@@ -111,7 +117,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n@@ -126,7 +133,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn trailing_zeros(self) -> uint;\n \n     /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n@@ -142,7 +150,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn rotate_left(self, n: uint) -> Self;\n \n     /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n@@ -158,7 +167,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn rotate_right(self, n: uint) -> Self;\n \n     /// Reverses the byte order of the integer.\n@@ -173,7 +183,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap_bytes(self) -> Self;\n \n     /// Convert an integer from big endian to the target's endianness.\n@@ -193,7 +203,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn from_be(x: Self) -> Self {\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -216,7 +226,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn from_le(x: Self) -> Self {\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -239,7 +249,7 @@ pub trait Int\n     ///     assert_eq!(n.to_be(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn to_be(self) -> Self { // or not to be?\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -262,7 +272,7 @@ pub trait Int\n     ///     assert_eq!(n.to_le(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -279,7 +289,7 @@ pub trait Int\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n     /// assert_eq!(6u16.checked_add(65530), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n     /// Checked integer subtraction. Computes `self - other`, returning `None`\n@@ -293,7 +303,7 @@ pub trait Int\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n     /// assert_eq!((-128i8).checked_sub(1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n     /// Checked integer multiplication. Computes `self * other`, returning\n@@ -307,7 +317,7 @@ pub trait Int\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n     /// assert_eq!(5u8.checked_mul(52), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n     /// Checked integer division. Computes `self / other`, returning `None` if\n@@ -322,12 +332,12 @@ pub trait Int\n     /// assert_eq!((-128i8).checked_div(-1), None);\n     /// assert_eq!((1i8).checked_div(0), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n     /// Saturating integer addition. Computes `self + other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -339,7 +349,7 @@ pub trait Int\n \n     /// Saturating integer subtraction. Computes `self - other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -358,7 +368,8 @@ pub trait Int\n     ///\n     /// assert_eq!(2.pow(4), 16);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {\n         let mut base = self;\n@@ -390,7 +401,7 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -521,7 +532,7 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -614,38 +625,38 @@ int_impl! { int = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n-    #[unstable = \"overflow in debug builds?\"]\n+    #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n     fn abs(self) -> Self;\n \n     /// Returns a number representing sign of `self`.\n     ///\n     /// - `0` if the number is zero\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n \n     /// Returns `true` if `self` is positive and `false` if the number\n     /// is zero or negative.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n \n     /// Returns `true` if `self` is negative and `false` if the number\n     /// is zero or positive.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -677,18 +688,18 @@ signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n         (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     /// Unspecified behavior on overflow.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n@@ -699,7 +710,7 @@ pub trait UnsignedInt: Int {\n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let npot = self.next_power_of_two();\n         if npot >= self {\n@@ -710,23 +721,23 @@ pub trait UnsignedInt: Int {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for uint {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u8 {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u16 {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u32 {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n     #[inline]\n@@ -991,7 +1002,7 @@ impl_to_primitive_float! { f32 }\n impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n@@ -1073,73 +1084,73 @@ pub trait FromPrimitive : ::marker::Sized {\n }\n \n /// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n     FromPrimitive::from_int(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n     FromPrimitive::from_i8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n     FromPrimitive::from_i16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n     FromPrimitive::from_i32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n     FromPrimitive::from_i64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n     FromPrimitive::from_uint(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n     FromPrimitive::from_u8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n     FromPrimitive::from_u16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n     FromPrimitive::from_u32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n     FromPrimitive::from_u64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n     FromPrimitive::from_f32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n     FromPrimitive::from_f64(n)\n }\n@@ -1190,13 +1201,13 @@ impl_from_primitive! { f64, to_f64 }\n /// ```\n ///\n #[inline]\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait NumCast: ToPrimitive {\n     /// Creates a number from another value that can be converted into a primitive via the\n     /// `ToPrimitive` trait.\n@@ -1231,7 +1242,7 @@ impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n #[derive(Copy, PartialEq, Show)]\n-#[unstable = \"may be renamed\"]\n+#[unstable(feature = \"core\", reason = \"may be renamed\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n     Nan,\n@@ -1251,7 +1262,8 @@ pub enum FpCategory {\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable = \"distribution of methods between core/std is unclear\"]\n+#[unstable(feature = \"core\",\n+           reason = \"distribution of methods between core/std is unclear\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -1280,34 +1292,56 @@ pub trait Float\n     // FIXME (#5527): These should be associated constants\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n-    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n+                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n     /// Returns the number of base-10 digits of precision that this type supports.\n-    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     fn digits(unused_self: Option<Self>) -> uint;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     fn min_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     fn max_exp(unused_self: Option<Self>) -> int;\n     /// Returns the minimum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the smallest finite value that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_POS_VALUE` or `std::f64::MIN_POS_VALUE` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_POS_VALUE` or \\\n+                           `std::f64::MIN_POS_VALUE` as appropriate\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n@@ -1394,20 +1428,21 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[unstable = \"might need to return Result\"]\n+#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n pub trait FromStrRadix {\n     fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[unstable = \"might need to return Result\"]\n+#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             /// Convert a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n@@ -1440,7 +1475,8 @@ macro_rules! from_str_radix_float_impl {\n             }\n         }\n \n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             /// Convert a string in a given base to a float.\n             ///\n@@ -1604,15 +1640,17 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             #[inline]\n             fn from_str(src: &str) -> Option<$T> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n                 assert!(radix >= 2 && radix <= 36,"}, {"sha": "21635799a77a26a458619bcd3b3431ce2ae0c7ba", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "7d520770503d4b2507cb483afc8bcf04204ca443", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "f10822077dc7511e3e44d12596e6e2198e0e941d", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "3d6922b07b19407b325941dd14888e4fea334214", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "f66a0eed971612913bf5e7e0b1fa98cfbdbfeab4", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,6 +14,7 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by usize\"]\n+#![unstable(feature = \"core\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced by usize\")]\n \n uint_module! { uint, int, ::int::BITS }"}, {"sha": "06502be54aaccded31e2541928248cde27f77407", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,14 +12,14 @@\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BITS : uint = $bits;\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n ) }"}, {"sha": "602ef4fe45e734e0f1a931a2a50c98ce98e0511a", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "bbb964508b4da30b2277f1f6d5bb5976806c1c24", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 157, "deletions": 87, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -65,7 +65,7 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n use fmt;\n@@ -92,18 +92,19 @@ use fmt;\n /// }\n /// ```\n #[lang=\"drop\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }\n \n // implements the unary operator \"op &T\"\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n \n@@ -119,7 +120,8 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -129,7 +131,8 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -139,7 +142,8 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -178,19 +182,19 @@ macro_rules! forward_ref_binop {\n /// }\n /// ```\n #[lang=\"add\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `+` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -231,19 +235,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `-` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -284,19 +288,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `*` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -337,19 +341,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `/` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -390,19 +394,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n     /// The method for the `%` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -416,7 +420,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -462,25 +466,25 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `-` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Neg for $t {\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             type Output = $t;\n \n             #[inline]\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             fn neg(self) -> $t { -self }\n         }\n \n@@ -490,7 +494,7 @@ macro_rules! neg_impl {\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -538,19 +542,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `!` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -591,19 +595,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `&` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -644,19 +648,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `|` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -697,19 +701,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `^` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -750,19 +754,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `<<` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($t:ty, $f:ty) => (\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n \n@@ -821,13 +825,13 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"shr\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `>>` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -894,12 +898,12 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// ```\n #[lang=\"index\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Index}`\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n }\n \n@@ -933,22 +937,22 @@ pub trait Index<Index: ?Sized> {\n /// ```\n #[lang=\"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Index}`\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable = \"may be renamed to RangeFull\"]\n+#[unstable(feature = \"core\", reason  = \"may be renamed to RangeFull\")]\n pub struct FullRange;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(\"..\", fmt)\n@@ -958,15 +962,15 @@ impl fmt::Debug for FullRange {\n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n@@ -976,15 +980,15 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n@@ -994,13 +998,13 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)\n@@ -1037,24 +1041,24 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n     /// The method called to dereference a value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n@@ -1097,42 +1101,49 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n-pub trait Fn<Args,Result> {\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(stage0)]\n+pub trait Fn<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call(&self, args: Args) -> Result;\n+    extern \"rust-call\" fn call(&self, args: Args) -> Output;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n-pub trait FnMut<Args,Result> {\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(stage0)]\n+pub trait FnMut<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Output;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n-pub trait FnOnce<Args,Result> {\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(stage0)]\n+pub trait FnOnce<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Output;\n }\n \n+#[cfg(stage0)]\n impl<F: ?Sized, A, R> FnMut<A, R> for F\n     where F : Fn<A, R>\n {\n@@ -1141,10 +1152,69 @@ impl<F: ?Sized, A, R> FnMut<A, R> for F\n     }\n }\n \n+#[cfg(stage0)]\n impl<F,A,R> FnOnce<A,R> for F\n     where F : FnMut<A,R>\n {\n     extern \"rust-call\" fn call_once(mut self, args: A) -> R {\n         self.call_mut(args)\n     }\n }\n+\n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait Fn<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait FnMut<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a by-value receiver.\n+#[lang=\"fn_once\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait FnOnce<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[cfg(not(stage0))]\n+impl<F: ?Sized, A> FnMut<A> for F\n+    where F : Fn<A>\n+{\n+    type Output = <F as Fn<A>>::Output;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> <F as Fn<A>>::Output {\n+        self.call(args)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<F,A> FnOnce<A> for F\n+    where F : FnMut<A>\n+{\n+    type Output = <F as FnMut<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: A) -> <F as FnMut<A>>::Output {\n+        self.call_mut(args)\n+    }\n+}"}, {"sha": "c7266aa4f1a8b1d98f1548160475854501b1e378", "filename": "src/libcore/option.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -141,7 +141,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Option::*;\n \n@@ -164,13 +164,13 @@ use slice;\n \n /// The `Option` type.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     None,\n     /// Some value `T`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Some(T)\n }\n \n@@ -195,7 +195,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -241,7 +241,7 @@ impl<T> Option<T> {\n     /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self {\n             Some(ref x) => Some(x),\n@@ -262,7 +262,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(42));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n@@ -285,7 +285,8 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n             Some(ref mut x) => {\n@@ -322,7 +323,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -354,7 +355,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -371,7 +372,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -389,7 +390,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n@@ -413,7 +414,7 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -433,7 +434,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -455,7 +456,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -476,7 +477,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or(0), Err(0));\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -497,7 +498,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -521,7 +522,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: Item { opt: self.as_ref() } }\n     }\n@@ -542,7 +543,8 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"waiting for iterator conventions\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: Item { opt: self.as_mut() } }\n     }\n@@ -561,7 +563,7 @@ impl<T> Option<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: Item { opt: self } }\n     }\n@@ -592,7 +594,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.and(y), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n@@ -615,7 +617,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.and_then(sq).and_then(sq), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -645,7 +647,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.or(y), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -667,7 +669,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.or_else(nobody), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -693,7 +695,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n@@ -702,7 +704,8 @@ impl<T> Option<T> {\n impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n     /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n     /// Useful for converting an Option<&T> to an Option<T>.\n-    #[unstable = \"recently added as part of collections reform\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added as part of collections reform\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.deref().clone())\n     }\n@@ -732,7 +735,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0, bad_year);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -745,7 +748,8 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"waiting on the stability of the trait itself\"]\n+#[unstable(feature = \"core\",\n+           reason = \"waiting on the stability of the trait itself\")]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n@@ -760,10 +764,10 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Option<T> { None }\n }\n \n@@ -803,10 +807,10 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -816,27 +820,27 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Clone for Iter<'a, A> {\n     fn clone(&self) -> Iter<'a, A> {\n         Iter { inner: self.inner.clone() }\n     }\n }\n \n /// An iterator over a mutable reference of the contained item in an Option.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n@@ -846,20 +850,20 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -869,20 +873,20 @@ impl<A> Iterator for IntoIter<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a\n@@ -902,7 +906,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// assert!(res == Some(vec!(2, 3)));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed."}, {"sha": "9c18cd0f6d9af0cc9d3dac1c4313ba2492aaf973", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -86,7 +86,7 @@\n //! but C APIs hand out a lot of pointers generally, so are a common source\n //! of unsafe pointers in Rust.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem;\n use clone::Clone;\n@@ -99,13 +99,14 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub use intrinsics::copy_nonoverlapping_memory;\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub use intrinsics::copy_memory;\n \n-#[unstable = \"uncertain about naming and semantics\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about naming and semantics\")]\n pub use intrinsics::set_memory;\n \n \n@@ -120,7 +121,7 @@ pub use intrinsics::set_memory;\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -134,7 +135,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n@@ -145,7 +146,8 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n /// contents of `dst`, and may be used to create invalid instances of `T`.\n #[inline]\n-#[unstable = \"may play a larger role in std::ptr future extensions\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n@@ -158,7 +160,7 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n ///\n /// This is only unsafe because it accepts a raw pointer.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n@@ -182,7 +184,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// This is only unsafe because it accepts a raw pointer.\n /// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n@@ -200,7 +202,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n@@ -213,7 +215,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[unstable = \"may play a larger role in std::ptr future extensions\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n     let tmp = read(&*dest);\n@@ -236,18 +239,18 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n /// Methods on raw pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PtrExt: Sized {\n     type Target;\n \n     /// Returns true if the pointer is null.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool;\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -259,8 +262,9 @@ pub trait PtrExt: Sized {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable = \"Option is not clearly the right return type, and we may want \\\n-                  to tie the return lifetime to a borrow of the raw pointer\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"Option is not clearly the right return type, and we may want \\\n+                         to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n@@ -271,12 +275,12 @@ pub trait PtrExt: Sized {\n     /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n     type Target;\n \n@@ -287,28 +291,30 @@ pub trait MutPtrExt {\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n-    #[unstable = \"Option is not clearly the right return type, and we may want \\\n-                  to tie the return lifetime to a borrow of the raw pointer\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"Option is not clearly the right return type, and we may want \\\n+                         to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PtrExt for *const T {\n     type Target = T;\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *const T {\n         intrinsics::offset(self, count)\n     }\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -318,23 +324,24 @@ impl<T> PtrExt for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -344,13 +351,14 @@ impl<T> PtrExt for *mut T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> MutPtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n         if self.is_null() {\n             None\n@@ -361,7 +369,7 @@ impl<T> MutPtrExt for *mut T {\n }\n \n // Equality for pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -371,10 +379,10 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Eq for *const T {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -384,18 +392,18 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Eq for *mut T {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -408,7 +416,7 @@ mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n@@ -419,7 +427,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq {\n         ($($p:ident),*) => {\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n@@ -439,7 +447,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n@@ -453,7 +461,7 @@ impl<T> Ord for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n@@ -473,7 +481,7 @@ impl<T> PartialOrd for *const T {\n     fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n@@ -487,7 +495,7 @@ impl<T> Ord for *mut T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n@@ -513,32 +521,34 @@ impl<T> PartialOrd for *mut T {\n /// raw `*mut T` (which conveys no particular ownership semantics).\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n pub struct Unique<T>(pub *mut T);\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T:Send> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T:Sync> Sync for Unique<T> { }\n \n impl<T> Unique<T> {\n     /// Returns a null Unique.\n-    #[unstable = \"recently added to this module\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added to this module\")]\n     pub fn null() -> Unique<T> {\n         Unique(null_mut())\n     }\n \n     /// Return an (unsafe) pointer into the memory owned by `self`.\n-    #[unstable = \"recently added to this module\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added to this module\")]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n         self.0.offset(offset)\n     }"}, {"sha": "3fd244b46e30f4d27d897c29accbb7c7ddc53a77", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable]\n+#![unstable(feature = \"core\")]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!"}, {"sha": "ade257165c6ad0f24e1bdde4e62a18f9247ea8e0", "filename": "src/libcore/result.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -224,7 +224,7 @@\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Result::{Ok, Err};\n \n@@ -241,22 +241,22 @@ use slice;\n /// See the [`std::result`](index.html) module documentation for details.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[must_use]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n     /// Contains the success value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Ok(T),\n \n     /// Contains the error value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Err(E)\n }\n \n /////////////////////////////////////////////////////////////////////////////\n // Type implementation\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n     // Querying the contained values\n@@ -274,7 +274,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n@@ -294,7 +294,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n@@ -318,7 +318,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.ok(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x)  => Some(x),\n@@ -341,7 +341,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.err(), Some(\"Nothing here\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn err(self) -> Option<E> {\n         match self {\n             Ok(_)  => None,\n@@ -366,7 +366,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ref(&self) -> Result<&T, &E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n@@ -393,7 +393,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n@@ -417,7 +417,8 @@ impl<T, E> Result<T, E> {\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n             Ok(ref mut x) => slice::mut_ref_slice(x),\n@@ -463,7 +464,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n         match self {\n             Ok(t) => Ok(op(t)),\n@@ -489,7 +490,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -513,7 +514,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: self.as_ref().ok() }\n     }\n@@ -534,7 +535,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n@@ -553,7 +554,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self.ok() }\n     }\n@@ -584,7 +585,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n@@ -608,7 +609,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -638,7 +639,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n             Ok(_) => self,\n@@ -662,7 +663,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -684,7 +685,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -704,7 +705,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n@@ -713,7 +714,7 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E: Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n@@ -734,7 +735,7 @@ impl<T, E: Debug> Result<T, E> {\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -744,7 +745,7 @@ impl<T, E: Debug> Result<T, E> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n@@ -765,7 +766,7 @@ impl<T: Debug, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -782,7 +783,7 @@ impl<T: Debug, E> Result<T, E> {\n impl<T, E> AsSlice<T> for Result<T, E> {\n     /// Convert from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Ok(ref x) => slice::ref_slice(x),\n@@ -800,10 +801,10 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n /////////////////////////////////////////////////////////////////////////////\n \n /// An iterator over a reference to the `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -816,24 +817,24 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n /// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -846,20 +847,20 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -872,20 +873,20 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -949,7 +950,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "4a1c123668f27171b9907711bd3469cd8c75949c", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -19,7 +19,6 @@\n //! provided beyond this module.\n //!\n //! ```rust\n-//! #[allow(unstable)];\n //!\n //! fn main() {\n //!     use std::simd::f32x4;\n@@ -37,7 +36,7 @@\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -46,26 +45,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -74,32 +73,32 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]"}, {"sha": "a113a34ef3569b1c814d25b48eb8d06db9253cf2", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"slice\")]\n \n // How this module is organized.\n@@ -125,7 +125,7 @@ pub trait SliceExt {\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -230,7 +230,7 @@ impl<T> SliceExt for [T] {\n         self.repr().data\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n         F: FnMut(&T) -> Ordering\n     {\n@@ -410,12 +410,12 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[m-n..]\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -446,7 +446,7 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -489,7 +489,7 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<uint> for [T] {\n     type Output = T;\n \n@@ -500,7 +500,7 @@ impl<T> ops::Index<uint> for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<uint> for [T] {\n     type Output = T;\n \n@@ -511,7 +511,7 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -526,23 +526,23 @@ impl<T> ops::Index<ops::Range<uint>> for [T] {\n         }\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -551,7 +551,7 @@ impl<T> ops::Index<ops::FullRange> for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -566,15 +566,15 @@ impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n         }\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -583,7 +583,7 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -598,33 +598,34 @@ impl<T> ops::IndexMut<ops::FullRange> for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable = \"will be replaced by slice syntax\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by slice syntax\")]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a [T] { &[] }\n }\n \n@@ -635,7 +636,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n \n@@ -673,7 +674,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -715,14 +716,14 @@ macro_rules! make_slice {\n }\n \n /// Immutable slice iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -731,7 +732,7 @@ impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -740,7 +741,7 @@ impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -749,7 +750,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -763,7 +764,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n@@ -773,15 +774,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n \n iterator!{struct Iter -> *const T, &'a T}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -807,39 +808,39 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -848,31 +849,31 @@ impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -889,15 +890,15 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n@@ -910,15 +911,15 @@ trait SplitIter: DoubleEndedIterator {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     fn clone(&self) -> Split<'a, T, P> {\n         Split {\n@@ -929,7 +930,7 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a [T];\n \n@@ -957,7 +958,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -983,7 +984,7 @@ impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n@@ -1002,7 +1003,7 @@ impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a mut [T];\n \n@@ -1037,7 +1038,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n@@ -1092,37 +1093,37 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n@@ -1148,13 +1149,13 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Windows<'a, T> {\n     type Item = &'a [T];\n \n@@ -1186,13 +1187,13 @@ impl<'a, T> Iterator for Windows<'a, T> {\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Chunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -1221,7 +1222,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1237,10 +1238,10 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1264,13 +1265,13 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for ChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -1300,7 +1301,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1318,23 +1319,23 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n //\n // Free functions\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1368,7 +1369,8 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"should be renamed to from_raw_parts\"]\n+#[unstable(feature = \"core\",\n+           reason = \"should be renamed to from_raw_parts\")]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1380,7 +1382,8 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"should be renamed to from_raw_parts_mut\"]\n+#[unstable(feature = \"core\",\n+           reason = \"should be renamed to from_raw_parts_mut\")]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1390,7 +1393,7 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[unstable = \"needs review\"]\n+#[unstable(feature = \"core\", reason = \"needs review\")]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1403,7 +1406,6 @@ pub mod bytes {\n \n     impl MutableByteVector for [u8] {\n         #[inline]\n-        #[allow(unstable)]\n         fn set_memory(&mut self, value: u8) {\n             unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }\n@@ -1432,7 +1434,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n@@ -1444,17 +1446,17 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for [T] {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n@@ -1479,7 +1481,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1494,7 +1496,7 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable]\n+        #[unstable(feature = \"core\")]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "101d349c3517084896bf207c22c8df28e055a539", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 72, "deletions": 53, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -47,7 +47,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     ($te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n \n@@ -60,7 +60,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -69,7 +69,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern $te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -82,7 +82,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -91,7 +91,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern forward $te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -110,7 +110,8 @@ macro_rules! delegate_iter {\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n // FIXME(#17307): there should be an `E` associated type for a `Result` return\n-#[unstable = \"will return a Result once associated types are working\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will return a Result once associated types are working\")]\n pub trait FromStr {\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n@@ -145,7 +146,8 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone, Show)]\n-#[unstable = \"error enumeration recently added and definitions may be refined\"]\n+#[unstable(feature = \"core\",\n+           reason = \"error enumeration recently added and definitions may be refined\")]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n     ///\n@@ -169,15 +171,15 @@ pub enum Utf8Error {\n ///\n /// Returns `Err` if the slice is not utf-8 with a description as to why the\n /// provided slice is not utf-8.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n@@ -195,7 +197,9 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[deprecated = \"use std::ffi::c_str_to_bytes + str::from_utf8\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n@@ -207,7 +211,8 @@ pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n }\n \n /// Something that can be used to compare against a character\n-#[unstable = \"definition may change as pattern-related methods are stabilized\"]\n+#[unstable(feature = \"core\",\n+           reason = \"definition may change as pattern-related methods are stabilized\")]\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -244,7 +249,7 @@ impl<'a> CharEq for &'a [char] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for Utf8Error {\n     fn description(&self) -> &str {\n         match *self {\n@@ -254,7 +259,7 @@ impl Error for Utf8Error {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -276,7 +281,7 @@ Section: Iterators\n ///\n /// Created with the method `.chars()`.\n #[derive(Clone, Copy)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n@@ -307,7 +312,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n \n /// Reads the next code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n     let x = match bytes.next() {\n@@ -339,7 +344,7 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     Some(ch)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n@@ -360,7 +365,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n@@ -397,13 +402,13 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n     type Item = (uint, char);\n \n@@ -427,7 +432,7 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n@@ -446,7 +451,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// Use with the `std::iter` module.\n ///\n /// Created with `StrExt::bytes`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n delegate_iter!{exact u8 : Bytes<'a>}\n@@ -456,13 +461,24 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n+#[cfg(stage0)]\n impl<'a> Fn(&'a u8) -> u8 for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n         *ptr\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Fn<(&'a u8,)> for BytesDeref {\n+    type Output = u8;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        *ptr\n+    }\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n #[derive(Clone)]\n struct CharSplits<'a, Sep> {\n@@ -486,13 +502,13 @@ struct CharSplitsN<'a, Sep> {\n }\n \n /// An iterator over the lines of a string, separated by `\\n`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<'a> {\n     inner: CharSplits<'a, char>,\n }\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinesAny<'a> {\n     inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n }\n@@ -509,7 +525,7 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     type Item = &'a str;\n \n@@ -544,7 +560,7 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n@@ -586,7 +602,7 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     type Item = &'a str;\n \n@@ -892,7 +908,7 @@ impl Searcher {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[derive(Clone)]\n-#[unstable = \"type may be removed\"]\n+#[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct MatchIndices<'a> {\n     // constants\n     haystack: &'a str,\n@@ -903,14 +919,14 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[derive(Clone)]\n-#[unstable = \"type may be removed\"]\n+#[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n     finished: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -927,7 +943,7 @@ impl<'a> Iterator for MatchIndices<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SplitStr<'a> {\n     type Item = &'a str;\n \n@@ -1087,7 +1103,8 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[derive(Copy)]\n-#[unstable = \"naming is uncertain with container conventions\"]\n+#[unstable(feature = \"core\",\n+           reason = \"naming is uncertain with container conventions\")]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1113,7 +1130,7 @@ mod traits {\n     use ops;\n     use str::{StrExt, eq_slice};\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1129,7 +1146,7 @@ mod traits {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1139,10 +1156,10 @@ mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Eq for str {}\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n@@ -1176,7 +1193,7 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n@@ -1199,7 +1216,7 @@ mod traits {\n     ///\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n@@ -1219,7 +1236,7 @@ mod traits {\n     ///\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n@@ -1233,7 +1250,7 @@ mod traits {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::FullRange> for str {\n         type Output = str;\n         #[inline]\n@@ -1244,9 +1261,10 @@ mod traits {\n }\n \n /// Any string that can be represented as a slice\n-#[unstable = \"Instead of taking this bound generically, this trait will be \\\n-              replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n-              a more generic conversion trait\"]\n+#[unstable(feature = \"core\",\n+           reason = \"Instead of taking this bound generically, this trait will be \\\n+                     replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n+                     a more generic conversion trait\")]\n pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n@@ -1264,25 +1282,26 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n \n /// Return type of `StrExt::split`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n-#[unstable = \"might get removed in favour of a constructor method on Split\"]\n+#[unstable(feature = \"core\",\n+           reason = \"might get removed in favour of a constructor method on Split\")]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n@@ -1648,7 +1667,7 @@ impl StrExt for str {\n /// Pluck a code point out of a UTF-8-like byte slice and return the\n /// index of the next code point.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n@@ -1671,13 +1690,13 @@ pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n     multibyte_char_range_at(bytes, i)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a str { \"\" }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n@@ -1687,13 +1706,13 @@ impl<'a> Iterator for Lines<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n@@ -1703,7 +1722,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }"}, {"sha": "64c2964eb7c6986fc36d3c2d89fc786e39ceeae8", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -33,7 +33,7 @@\n //! * `Ord`\n //! * `Default`\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::*;\n@@ -55,14 +55,14 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(e!(self.$idx.clone()),)+)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -74,10 +74,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -101,17 +101,17 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$idx, other.$idx),+)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[stable]\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "8bd2ed95ed5689071dc743aaed8f191f75fea9d5", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -114,7 +114,6 @@ fn discard_doesnt_unborrow() {\n }\n \n #[test]\n-#[allow(unstable)]\n fn clone_ref_updates_flag() {\n     let x = RefCell::new(0i);\n     {"}, {"sha": "0d371dbe15375bd1c0d14c210939ee160f2d920c", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,6 @@\n #![feature(unboxed_closures)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n \n extern crate core;\n extern crate test;"}, {"sha": "5f3a68a9e344db215cf23204d157238f310eea1a", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -15,15 +15,18 @@\n //! [mz]: https://code.google.com/p/miniz/\n \n #![crate_name = \"flate\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+#![feature(hash)]\n+#![feature(core)]\n+#![feature(libc)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "d76e4b2ed956aa232afd6f296a61578686c602db", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -15,7 +15,8 @@\n //! generated instead.\n \n #![crate_name = \"fmt_macros\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -26,7 +27,9 @@\n \n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(unicode)]\n \n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "4774262246a338de906dbcaebde80afb29e001e5", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -78,7 +78,9 @@\n //! ```\n \n #![crate_name = \"getopts\"]\n-#![unstable = \"use the crates.io `getopts` library instead\"]\n+#![unstable(feature = \"rustc_private\",\n+            reason = \"use the crates.io `getopts` library instead\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -88,8 +90,10 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;\n \n@@ -538,7 +542,9 @@ pub fn opt(short_name: &str,\n \n impl Fail {\n     /// Convert a `Fail` enum into an error string.\n-    #[deprecated=\"use `fmt::String` (`{}` format specifier)\"]\n+    #[unstable(feature = \"rustc_private\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `fmt::String` (`{}` format specifier)\")]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }"}, {"sha": "171b4ec2097b090d0d273deaa2d9957363b95d25", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -265,7 +265,8 @@\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n #![crate_name = \"graphviz\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -274,7 +275,10 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(path)]\n \n use self::LabelText::*;\n "}, {"sha": "71f117835935d63c8aa4fadab9005537f191b11e", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deprecated = \"use std::vec::CowVec\"]\n+#![unstable(feature = \"rustc_private\")]\n+#![deprecated(since = \"1.0.0\", reason = \"use std::vec::CowVec\")]\n \n pub use self::MaybeOwnedVector::*;\n "}, {"sha": "548782216bbe5f5d8ea936c0c01e38c89e2ae360", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,15 +10,18 @@\n \n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n-#![cfg_attr(not(feature = \"cargo-build\"), unstable)]\n+#![cfg_attr(not(feature = \"cargo-build\"),\n+            unstable(feature = \"libc\"))]\n+#![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n+#![cfg_attr(not(feature = \"cargo-build\"), feature(core))]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![cfg_attr(test, feature(test))]\n \n //! Bindings for the C standard library and other platform libraries\n //!\n@@ -73,7 +76,6 @@\n //! one from Berkeley after the lawsuits died down and the CSRG dissolved.\n \n #![allow(bad_style, raw_pointer_derive)]\n-\n #[cfg(feature = \"cargo-build\")] extern crate \"std\" as core;\n #[cfg(not(feature = \"cargo-build\"))] extern crate core;\n "}, {"sha": "dfec2c18816e407ce7bf4a8fd34b6a1c0f888806", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -156,7 +156,9 @@\n //! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n-#![unstable = \"use the crates.io `log` library instead\"]\n+#![unstable(feature = \"rustc_private\",\n+            reason = \"use the crates.io `log` library instead\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -169,8 +171,13 @@\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n use std::cell::RefCell;\n use std::fmt;"}, {"sha": "25c205b2bf2a8d1a02614e400b32ab1f488bbe0c", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -17,7 +17,7 @@\n //! internally. The `IndependentSample` trait is for generating values\n //! that do not need to record state.\n \n-#![unstable]\n+#![unstable(feature = \"rand\")]\n \n use core::prelude::*;\n use core::num::{Float, Int};"}, {"sha": "762581518505f675b349e5b2696773fa12890438", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -23,10 +23,11 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![no_std]\n-#![unstable]\n+#![unstable(feature = \"rand\")]\n+#![feature(staged_api)]\n #![staged_api]\n+#![feature(core)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "10c71cff5be80775a21557fb41664be5766e14a5", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -141,9 +141,9 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n         *rng = Default::default();\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for ReseedWithDefault {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> ReseedWithDefault { ReseedWithDefault }\n }\n "}, {"sha": "2500cb864632e27a24fa8c1c5dd628123ade3a89", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -16,7 +16,8 @@\n //!     http://www.matroska.org/technical/specs/rfc/index.html\n \n #![crate_name = \"rbml\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -27,7 +28,10 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(rustc_private)]\n \n extern crate serialize;\n #[macro_use] extern crate log;\n@@ -853,7 +857,10 @@ pub mod writer {\n \n     // Set to true to generate more debugging in EBML code.\n     // Totally lame approach.\n+    #[cfg(not(ndebug))]\n     static DEBUG: bool = true;\n+    #[cfg(ndebug)]\n+    static DEBUG: bool = false;\n \n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         // used internally to emit things like the vector length and so on"}, {"sha": "580e55f78a9e5385504780e42af0a663df5fc7e2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -15,7 +15,8 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -29,7 +30,17 @@\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "f13814527cdfd3a6ddb58b691839c85753a34814", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 131, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -46,7 +46,7 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast, ast_map};\n use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::{self, Span, DUMMY_SP};\n+use syntax::codemap::{self, Span};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ast_util;\n@@ -662,9 +662,6 @@ impl LintPass for UnusedAttributes {\n             // FIXME: #14407 these are only looked at on-demand so we can't\n             // guarantee they'll have already been checked\n             \"deprecated\",\n-            \"experimental\",\n-            \"frozen\",\n-            \"locked\",\n             \"must_use\",\n             \"stable\",\n             \"unstable\",\n@@ -1696,37 +1693,16 @@ declare_lint! {\n     \"detects use of #[deprecated] items\"\n }\n \n-declare_lint! {\n-    UNSTABLE,\n-    Warn,\n-    \"detects use of #[unstable] items (incl. items with no stability attribute)\"\n-}\n-\n-/// Checks for use of items with `#[deprecated]`, `#[unstable]` and\n-/// `#[unstable]` attributes, or no stability attribute.\n+/// Checks for use of items with `#[deprecated]` attributes\n #[derive(Copy)]\n-pub struct Stability { this_crate_staged: bool }\n+pub struct Stability;\n \n impl Stability {\n-    pub fn new() -> Stability { Stability { this_crate_staged: false } }\n-\n-    fn lint(&self, cx: &Context, id: ast::DefId, span: Span) {\n-\n-        let ref stability = stability::lookup(cx.tcx, id);\n-        let cross_crate = !ast_util::is_local(id);\n-        let staged = (!cross_crate && self.this_crate_staged)\n-            || (cross_crate && stability::is_staged_api(cx.tcx, id));\n+    fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n \n-        if !staged { return }\n-\n-        // stability attributes are promises made across crates; only\n-        // check DEPRECATED for crate-local usage.\n+        // deprecated attributes apply in-crate and cross-crate\n         let (lint, label) = match *stability {\n-            // no stability attributes == Unstable\n-            None if cross_crate => (UNSTABLE, \"unmarked\"),\n-            Some(attr::Stability { level: attr::Unstable, .. }) if cross_crate =>\n-                (UNSTABLE, \"unstable\"),\n-            Some(attr::Stability { level: attr::Deprecated, .. }) =>\n+            Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n             _ => return\n         };\n@@ -1736,7 +1712,7 @@ impl Stability {\n         fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n-                Some(attr::Stability { text: Some(ref s), .. }) => {\n+                Some(attr::Stability { reason: Some(ref s), .. }) => {\n                     format!(\"use of {} item: {}\", label, *s)\n                 }\n                 _ => format!(\"use of {} item\", label)\n@@ -1745,111 +1721,21 @@ impl Stability {\n             cx.span_lint(lint, span, &msg[]);\n         }\n     }\n-\n-\n-    fn is_internal(&self, cx: &Context, span: Span) -> bool {\n-        cx.tcx.sess.codemap().span_is_internal(span)\n-    }\n-\n }\n \n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED, UNSTABLE)\n-    }\n-\n-    fn check_crate(&mut self, _: &Context, c: &ast::Crate) {\n-        // Just mark the #[staged_api] attribute used, though nothing else is done\n-        // with it during this pass over the source.\n-        for attr in c.attrs.iter() {\n-            if attr.name().get() == \"staged_api\" {\n-                match attr.node.value.node {\n-                    ast::MetaWord(_) => {\n-                        attr::mark_used(attr);\n-                        self.this_crate_staged = true;\n-                    }\n-                    _ => (/*pass*/)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if self.is_internal(cx, e.span) { return; }\n-\n-        let mut span = e.span;\n-\n-        let id = match e.node {\n-            ast::ExprPath(..) | ast::ExprQPath(..) | ast::ExprStruct(..) => {\n-                match cx.tcx.def_map.borrow().get(&e.id) {\n-                    Some(&def) => def.def_id(),\n-                    None => return\n-                }\n-            }\n-            ast::ExprMethodCall(i, _, _) => {\n-                span = i.span;\n-                let method_call = ty::MethodCall::expr(e.id);\n-                match cx.tcx.method_map.borrow().get(&method_call) {\n-                    Some(method) => {\n-                        match method.origin {\n-                            ty::MethodStatic(def_id) => {\n-                                def_id\n-                            }\n-                            ty::MethodStaticClosure(def_id) => {\n-                                def_id\n-                            }\n-                            ty::MethodTypeParam(ty::MethodParam {\n-                                ref trait_ref,\n-                                method_num: index,\n-                                ..\n-                            }) |\n-                            ty::MethodTraitObject(ty::MethodObject {\n-                                ref trait_ref,\n-                                method_num: index,\n-                                ..\n-                            }) => {\n-                                ty::trait_item(cx.tcx, trait_ref.def_id, index).def_id()\n-                            }\n-                        }\n-                    }\n-                    None => return\n-                }\n-            }\n-            _ => return\n-        };\n-\n-        self.lint(cx, id, span);\n+        lint_array!(DEPRECATED)\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if self.is_internal(cx, item.span) { return }\n-\n-        match item.node {\n-            ast::ItemExternCrate(_) => {\n-                // compiler-generated `extern crate` items have a dummy span.\n-                if item.span == DUMMY_SP { return }\n+        stability::check_item(cx.tcx, item,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n \n-                let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    Some(cnum) => cnum,\n-                    None => return,\n-                };\n-                let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n-                self.lint(cx, id, item.span);\n-            }\n-            ast::ItemTrait(_, _, ref supertraits, _) => {\n-                for t in supertraits.iter() {\n-                    if let ast::TraitTyParamBound(ref t, _) = *t {\n-                        let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n-                        self.lint(cx, id, t.trait_ref.path.span);\n-                    }\n-                }\n-            }\n-            ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n-                let id = ty::trait_ref_to_def_id(cx.tcx, t);\n-                self.lint(cx, id, t.path.span);\n-            }\n-            _ => (/* pass */)\n-        }\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        stability::check_expr(cx.tcx, e,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n     }\n }\n \n@@ -2096,9 +1982,9 @@ declare_lint! {\n }\n \n declare_lint! {\n-    pub UNKNOWN_FEATURES,\n+    pub UNUSED_FEATURES,\n     Deny,\n-    \"unknown features found in crate-level #[feature] directives\"\n+    \"unused or unknown features found in crate-level #[feature] directives\"\n }\n \n declare_lint! {\n@@ -2142,7 +2028,7 @@ impl LintPass for HardwiredLints {\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n             WARNINGS,\n-            UNKNOWN_FEATURES,\n+            UNUSED_FEATURES,\n             UNKNOWN_CRATE_TYPES,\n             VARIANT_SIZE_DIFFERENCES,\n             FAT_PTR_TRANSMUTES"}, {"sha": "3a103e421016f398cbbe4f20e766b5476e9b27d5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -211,14 +211,14 @@ impl LintStore {\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n+                     Stability,\n                      UnconditionalRecursion,\n         );\n \n         add_builtin_with_new!(sess,\n                               TypeLimits,\n                               RawPointerDerive,\n                               MissingDoc,\n-                              Stability,\n                               MissingDebugImplementations,\n         );\n \n@@ -236,6 +236,7 @@ impl LintStore {\n         // Insert temporary renamings for a one-time deprecation\n         self.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n \n+        self.register_renamed(\"unknown_features\", \"unused_features\");\n     }\n \n     #[allow(unused_variables)]\n@@ -295,15 +296,6 @@ impl LintStore {\n             },\n             None => unreachable!()\n         }\n-        match self.by_name.get(\"unstable\") {\n-            Some(&Id(lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n-                self.set_level(lint_id, (lvl, ReleaseChannel))\n-            },\n-            Some(&Renamed(_, lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n-                self.set_level(lint_id, (lvl, ReleaseChannel))\n-            },\n-            None => unreachable!()\n-        }\n     }\n }\n \n@@ -809,6 +801,5 @@ pub fn check_crate(tcx: &ty::ctxt,\n         }\n     }\n \n-    tcx.sess.abort_if_errors();\n     *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n }"}, {"sha": "af41844b2df1220f2cf2208e23ec295b4431a59c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -904,8 +904,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(o.method_num)\n                             }));\n-                            try!(this.emit_struct_field(\"real_index\", 0, |this| {\n-                                this.emit_uint(o.real_index)\n+                            try!(this.emit_struct_field(\"vtable_index\", 0, |this| {\n+                                this.emit_uint(o.vtable_index)\n                             }));\n                             Ok(())\n                         })\n@@ -1492,8 +1492,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                             this.read_uint()\n                                         }).unwrap()\n                                     },\n-                                    real_index: {\n-                                        this.read_struct_field(\"real_index\", 3, |this| {\n+                                    vtable_index: {\n+                                        this.read_struct_field(\"vtable_index\", 3, |this| {\n                                             this.read_uint()\n                                         }).unwrap()\n                                     },"}, {"sha": "eaec4fac0a3f96ef66154b698d31102ea8815288", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -79,16 +79,13 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n-    int_unification_table:\n-        RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>,\n+    int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n \n     // Map from floating variable to the kind of float it represents\n-    float_unification_table:\n-        RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>,\n+    float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars:\n-        RegionVarBindings<'a, 'tcx>,\n+    region_vars: RegionVarBindings<'a, 'tcx>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized"}, {"sha": "4bbc503579972593e39217b3077462ed9fb3784a", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -19,7 +19,7 @@ use std::u32;\n use util::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<TypeVariableData<'tcx>,UndoEntry,Delegate>,\n+    values: sv::SnapshotVec<Delegate<'tcx>>,\n }\n \n struct TypeVariableData<'tcx> {\n@@ -42,7 +42,7 @@ enum UndoEntry {\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n-struct Delegate;\n+struct Delegate<'tcx>;\n \n type Relation = (RelationDir, ty::TyVid);\n \n@@ -195,9 +195,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n }\n \n-impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {\n+impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n+    type Value = TypeVariableData<'tcx>;\n+    type Undo = UndoEntry;\n+\n     fn reverse(&mut self,\n-               values: &mut Vec<TypeVariableData>,\n+               values: &mut Vec<TypeVariableData<'tcx>>,\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {"}, {"sha": "e15eb9c05766595424b88ca0e0c066ae2262de1e", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -19,7 +19,6 @@ use middle::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Debug;\n use syntax::ast;\n-use util::ppaux::Repr;\n use util::snapshot_vec as sv;\n \n /// This trait is implemented by any type that can serve as a type\n@@ -32,15 +31,17 @@ use util::snapshot_vec as sv;\n /// (possibly not yet known) sort of integer.\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n+pub trait UnifyKey : Clone + Debug + PartialEq {\n+    type Value : UnifyValue;\n+\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;\n \n     // Given an inference context, returns the unification table\n     // appropriate to this key type.\n     fn unification_table<'v>(infcx: &'v InferCtxt)\n-                             -> &'v RefCell<UnificationTable<Self,V>>;\n+                             -> &'v RefCell<UnificationTable<Self>>;\n \n     fn tag(k: Option<Self>) -> &'static str;\n }\n@@ -51,7 +52,7 @@ pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n /// whose value is not yet set).\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n+pub trait UnifyValue : Clone + PartialEq + Debug {\n }\n \n /// Value of a unification key. We implement Tarjan's union-find\n@@ -62,44 +63,44 @@ pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n /// to keep the DAG relatively balanced, which helps keep the running\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-#[derive(PartialEq,Clone)]\n-pub enum VarValue<K,V> {\n+#[derive(PartialEq,Clone,Show)]\n+pub enum VarValue<K:UnifyKey> {\n     Redirect(K),\n-    Root(V, uint),\n+    Root(K::Value, uint),\n }\n \n /// Table of unification keys and their values.\n-pub struct UnificationTable<K,V> {\n+pub struct UnificationTable<K:UnifyKey> {\n     /// Indicates the current value of each key.\n-    values: sv::SnapshotVec<VarValue<K,V>,(),Delegate>,\n+    values: sv::SnapshotVec<Delegate<K>>,\n }\n \n /// At any time, users may snapshot a unification table.  The changes\n /// made during the snapshot may either be *committed* or *rolled back*.\n-pub struct Snapshot<K> {\n+pub struct Snapshot<K:UnifyKey> {\n     // Link snapshot to the key type `K` of the table.\n     marker: marker::CovariantType<K>,\n     snapshot: sv::Snapshot,\n }\n \n /// Internal type used to represent the result of a `get()` operation.\n /// Conveys the current root and value of the key.\n-pub struct Node<K,V> {\n+pub struct Node<K:UnifyKey> {\n     pub key: K,\n-    pub value: V,\n+    pub value: K::Value,\n     pub rank: uint,\n }\n \n #[derive(Copy)]\n-pub struct Delegate;\n+pub struct Delegate<K>;\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n // other type parameter U, and we have no way to say\n // Option<U>:LatticeValue.\n \n-impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K,V> {\n-    pub fn new() -> UnificationTable<K,V> {\n+impl<K:UnifyKey> UnificationTable<K> {\n+    pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n             values: sv::SnapshotVec::new(Delegate),\n         }\n@@ -126,7 +127,7 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n         self.values.commit(snapshot.snapshot);\n     }\n \n-    pub fn new_key(&mut self, value: V) -> K {\n+    pub fn new_key(&mut self, value: K::Value) -> K {\n         let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n         debug!(\"{}: created new key: {:?}\",\n@@ -137,12 +138,12 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n \n     /// Find the root node for `vid`. This uses the standard union-find algorithm with path\n     /// compression: http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n-    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K,V> {\n+    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K> {\n         let index = vid.index();\n         let value = (*self.values.get(index)).clone();\n         match value {\n             Redirect(redirect) => {\n-                let node: Node<K,V> = self.get(tcx, redirect.clone());\n+                let node: Node<K> = self.get(tcx, redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n                     self.values.set(index, Redirect(node.key.clone()));\n@@ -164,33 +165,32 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n \n     /// Sets the value for `vid` to `new_value`. `vid` MUST be a root node! Also, we must be in the\n     /// middle of a snapshot.\n-    pub fn set(&mut self,\n-               tcx: &ty::ctxt<'tcx>,\n-               key: K,\n-               new_value: VarValue<K,V>)\n+    pub fn set<'tcx>(&mut self,\n+                     _tcx: &ty::ctxt<'tcx>,\n+                     key: K,\n+                     new_value: VarValue<K>)\n     {\n         assert!(self.is_root(&key));\n \n-        debug!(\"Updating variable {} to {}\",\n-               key.repr(tcx),\n-               new_value.repr(tcx));\n+        debug!(\"Updating variable {:?} to {:?}\",\n+               key, new_value);\n \n         self.values.set(key.index(), new_value);\n     }\n \n     /// Either redirects node_a to node_b or vice versa, depending on the relative rank. Returns\n     /// the new root and rank. You should then update the value of the new root to something\n     /// suitable.\n-    pub fn unify(&mut self,\n-                 tcx: &ty::ctxt<'tcx>,\n-                 node_a: &Node<K,V>,\n-                 node_b: &Node<K,V>)\n-                 -> (K, uint)\n+    pub fn unify<'tcx>(&mut self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       node_a: &Node<K>,\n+                       node_b: &Node<K>)\n+                       -> (K, uint)\n     {\n-        debug!(\"unify(node_a(id={}, rank={}), node_b(id={}, rank={}))\",\n-               node_a.key.repr(tcx),\n+        debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n+               node_a.key,\n                node_a.rank,\n-               node_b.key.repr(tcx),\n+               node_b.key,\n                node_b.rank);\n \n         if node_a.rank > node_b.rank {\n@@ -212,8 +212,11 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n     }\n }\n \n-impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n-    fn reverse(&mut self, _: &mut Vec<VarValue<K,V>>, _: ()) {\n+impl<K> sv::SnapshotVecDelegate for Delegate<K> {\n+    type Value = VarValue<K>;\n+    type Undo = ();\n+\n+    fn reverse(&mut self, _: &mut Vec<VarValue<K>>, _: ()) {\n         panic!(\"Nothing to reverse\");\n     }\n }\n@@ -224,7 +227,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n \n /// Indicates a type that does not have any kind of subtyping\n /// relationship.\n-pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n+pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Debug {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n     fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n@@ -242,8 +245,11 @@ pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n-                                                  K:UnifyKey<'tcx, Option<V>>> {\n+pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V>\n+    where K : UnifyKey<Value=Option<V>>,\n+          V : SimplyUnifiable<'tcx>,\n+          Option<V> : UnifyValue,\n+{\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n@@ -257,8 +263,10 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n     fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n }\n \n-impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V, K> for InferCtxt<'a, 'tcx>\n+impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtxt<'a,'tcx>\n+    where K : UnifyKey<Value=Option<V>>,\n+          V : SimplyUnifiable<'tcx>,\n+          Option<V> : UnifyValue,\n {\n     /// Unifies two simple keys. Because simple keys do not have any subtyping relationships, if\n     /// both keys have already been associated with a value, then those two values must be the\n@@ -271,8 +279,8 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n     {\n         let tcx = self.tcx;\n         let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n+        let node_a: Node<K> = table.borrow_mut().get(tcx, a_id);\n+        let node_b: Node<K> = table.borrow_mut().get(tcx, b_id);\n         let a_id = node_a.key.clone();\n         let b_id = node_b.key.clone();\n \n@@ -346,14 +354,14 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n \n // Integral type keys\n \n-impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n+impl UnifyKey for ty::IntVid {\n+    type Value = Option<IntVarValue>;\n+\n     fn index(&self) -> uint { self.index as uint }\n \n     fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>\n-    {\n+    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n         return &infcx.int_unification_table;\n     }\n \n@@ -375,18 +383,18 @@ impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n     }\n }\n \n-impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n+impl UnifyValue for Option<IntVarValue> { }\n \n // Floating point type keys\n \n-impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n+impl UnifyKey for ty::FloatVid {\n+    type Value = Option<ast::FloatTy>;\n+\n     fn index(&self) -> uint { self.index as uint }\n \n     fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>\n-    {\n+    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n         return &infcx.float_unification_table;\n     }\n \n@@ -395,7 +403,7 @@ impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n     }\n }\n \n-impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n+impl UnifyValue for Option<ast::FloatTy> {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n@@ -407,12 +415,3 @@ impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n         ty::terr_float_mismatch(err)\n     }\n }\n-\n-impl<'tcx, K:Repr<'tcx>, V:Repr<'tcx>> Repr<'tcx> for VarValue<K,V> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            Redirect(ref k) => format!(\"Redirect({})\", k.repr(tcx)),\n-            Root(ref v, r) => format!(\"Root({}, {})\", v.repr(tcx), r)\n-        }\n-    }\n-}"}, {"sha": "7b5af0ab1aa2ff2cc848ac7da12d25645b2cd961", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 256, "deletions": 40, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -11,48 +11,55 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n+use session::Session;\n+use lint;\n use middle::ty;\n use metadata::csearch;\n-use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem};\n use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n use syntax::ast_util::is_local;\n-use syntax::attr::Stability;\n+use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, FkMethod, Visitor};\n-use util::nodemap::{NodeMap, DefIdMap};\n+use syntax::feature_gate::emit_feature_warn;\n+use util::nodemap::{NodeMap, DefIdMap, FnvHashSet, FnvHashMap};\n use util::ppaux::Repr;\n \n use std::mem::replace;\n \n /// A stability index, giving the stability level for items and methods.\n pub struct Index {\n+    // Indicates whether this crate has #![feature(staged_api)]\n+    staged_api: bool,\n     // stability for crate-local items; unmarked stability == no entry\n     local: NodeMap<Stability>,\n     // cache for extern-crate items; unmarked stability == entry with None\n     extern_cache: DefIdMap<Option<Stability>>\n }\n \n // A private tree-walker for producing an Index.\n-struct Annotator {\n+struct Annotator<'a> {\n+    sess: &'a Session,\n     index: Index,\n     parent: Option<Stability>\n }\n \n-impl Annotator {\n+impl<'a> Annotator<'a> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n-                   attrs: &Vec<Attribute>, f: F) where\n+                   attrs: &Vec<Attribute>, item_sp: Span, f: F) where\n         F: FnOnce(&mut Annotator),\n     {\n-        match attr::find_stability(attrs.as_slice()) {\n+        match attr::find_stability(self.sess.diagnostic(), attrs.as_slice(), item_sp) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());\n \n-                // Don't inherit #[stable]\n+                // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 if stab.level != attr::Stable {\n                     let parent = replace(&mut self.parent, Some(stab));\n                     f(self);\n@@ -71,7 +78,7 @@ impl Annotator {\n     }\n }\n \n-impl<'v> Visitor<'v> for Annotator {\n+impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n     fn visit_item(&mut self, i: &Item) {\n         // FIXME (#18969): the following is a hack around the fact\n         // that we cannot currently annotate the stability of\n@@ -86,72 +93,276 @@ impl<'v> Visitor<'v> for Annotator {\n             _ => true,\n         };\n \n-        self.annotate(i.id, use_parent, &i.attrs, |v| visit::walk_item(v, i));\n+        self.annotate(i.id, use_parent, &i.attrs, i.span, |v| visit::walk_item(v, i));\n \n         if let ast::ItemStruct(ref sd, _) = i.node {\n             sd.ctor_id.map(|id| {\n-                self.annotate(id, true, &i.attrs, |_| {})\n+                self.annotate(id, true, &i.attrs, i.span, |_| {})\n             });\n         }\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, _: &'v FnDecl,\n-                _: &'v Block, _: Span, _: NodeId) {\n+                _: &'v Block, sp: Span, _: NodeId) {\n         if let FkMethod(_, _, meth) = fk {\n             // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, true, &meth.attrs, |_| {});\n+            self.annotate(meth.id, true, &meth.attrs, sp, |_| {});\n         }\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n     }\n \n     fn visit_trait_item(&mut self, t: &TraitItem) {\n-        let (id, attrs) = match *t {\n-            RequiredMethod(TypeMethod {id, ref attrs, ..}) => (id, attrs),\n+        let (id, attrs, sp) = match *t {\n+            RequiredMethod(TypeMethod {id, ref attrs, span, ..}) => (id, attrs, span),\n \n             // work around lack of pattern matching for @ types\n             ProvidedMethod(ref method) => {\n                 match **method {\n-                    Method {ref attrs, id, ..} => (id, attrs),\n+                    Method {ref attrs, id, span, ..} => (id, attrs, span),\n                 }\n             }\n \n-            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs),\n+            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs,\n+                                           typedef.ty_param.span),\n         };\n-        self.annotate(id, true, attrs, |v| visit::walk_trait_item(v, t));\n+        self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t));\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n-        self.annotate(var.node.id, true, &var.node.attrs,\n+        self.annotate(var.node.id, true, &var.node.attrs, var.span,\n                       |v| visit::walk_variant(v, var, g))\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n-        self.annotate(s.node.id, true, &s.node.attrs,\n+        self.annotate(s.node.id, true, &s.node.attrs, s.span,\n                       |v| visit::walk_struct_field(v, s));\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        self.annotate(i.id, true, &i.attrs, |_| {});\n+        self.annotate(i.id, true, &i.attrs, i.span, |_| {});\n     }\n }\n \n impl Index {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(krate: &Crate) -> Index {\n+    pub fn build(sess: &Session, krate: &Crate) -> Index {\n+        let mut staged_api = false;\n+        for attr in krate.attrs.iter() {\n+            if attr.name().get() == \"staged_api\" {\n+                match attr.node.value.node {\n+                    ast::MetaWord(_) => {\n+                        attr::mark_used(attr);\n+                        staged_api = true;\n+                    }\n+                    _ => (/*pass*/)\n+                }\n+            }\n+        }\n+        let index = Index {\n+            staged_api: staged_api,\n+            local: NodeMap(),\n+            extern_cache: DefIdMap()\n+        };\n+        if !staged_api {\n+            return index;\n+        }\n         let mut annotator = Annotator {\n-            index: Index {\n-                local: NodeMap(),\n-                extern_cache: DefIdMap()\n-            },\n+            sess: sess,\n+            index: index,\n             parent: None\n         };\n-        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs,\n+        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs, krate.span,\n                            |v| visit::walk_crate(v, krate));\n         annotator.index\n     }\n }\n \n+/// Cross-references the feature names of unstable APIs with enabled\n+/// features and possibly prints errors. Returns a list of all\n+/// features used.\n+pub fn check_unstable_api_usage(tcx: &ty::ctxt) -> FnvHashSet<InternedString> {\n+    let ref active_lib_features = tcx.sess.features.borrow().lib_features;\n+\n+    // Put the active features into a map for quick lookup\n+    let active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n+    let mut checker = Checker {\n+        tcx: tcx,\n+        active_features: active_features,\n+        used_features: FnvHashSet()\n+    };\n+\n+    let krate = tcx.map.krate();\n+    visit::walk_crate(&mut checker, krate);\n+\n+    let used_features = checker.used_features;\n+    return used_features;\n+}\n+\n+struct Checker<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    active_features: FnvHashSet<InternedString>,\n+    used_features: FnvHashSet<InternedString>\n+}\n+\n+impl<'a, 'tcx> Checker<'a, 'tcx> {\n+    fn check(&mut self, id: ast::DefId, span: Span, stab: &Option<Stability>) {\n+        // Only the cross-crate scenario matters when checking unstable APIs\n+        let cross_crate = !is_local(id);\n+        if !cross_crate { return }\n+\n+        match *stab {\n+            Some(Stability { level: attr::Unstable, ref feature, ref reason, .. }) => {\n+                self.used_features.insert(feature.clone());\n+\n+                if !self.active_features.contains(feature) {\n+                    let msg = match *reason {\n+                        Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n+                                               feature.get(), r.get()),\n+                        None => format!(\"use of unstable library feature '{}'\", feature.get())\n+                    };\n+\n+                    emit_feature_warn(&self.tcx.sess.parse_sess.span_diagnostic,\n+                                      feature.get(), span, &msg[]);\n+                }\n+            }\n+            Some(..) => {\n+                // Stable APIs are always ok to call and deprecated APIs are\n+                // handled by a lint.\n+            }\n+            None => {\n+                // This is an 'unmarked' API, which should not exist\n+                // in the standard library.\n+                self.tcx.sess.span_err(span, \"use of unmarked library feature\");\n+                self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n+                                               using or a bug in the compiler - there is \\\n+                                               no way to use this feature\");\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        check_item(self.tcx, item,\n+                   &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_item(self, item);\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n+        check_expr(self.tcx, ex,\n+                   &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_expr(self, ex);\n+    }\n+}\n+\n+/// Helper for discovering nodes to check for stability\n+pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    match item.node {\n+        ast::ItemExternCrate(_) => {\n+            // compiler-generated `extern crate` items have a dummy span.\n+            if item.span == DUMMY_SP { return }\n+\n+            let cnum = match tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                Some(cnum) => cnum,\n+                None => return,\n+            };\n+            let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+            maybe_do_stability_check(tcx, id, item.span, cb);\n+        }\n+        ast::ItemTrait(_, _, ref supertraits, _) => {\n+            for t in supertraits.iter() {\n+                if let ast::TraitTyParamBound(ref t, _) = *t {\n+                    let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n+                    maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n+                }\n+            }\n+        }\n+        ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n+            let id = ty::trait_ref_to_def_id(tcx, t);\n+            maybe_do_stability_check(tcx, id, t.path.span, cb);\n+        }\n+        _ => (/* pass */)\n+    }\n+}\n+\n+/// Helper for discovering nodes to check for stability\n+pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    if is_internal(tcx, e.span) { return; }\n+\n+    let mut span = e.span;\n+\n+    let id = match e.node {\n+        ast::ExprPath(..) | ast::ExprQPath(..) | ast::ExprStruct(..) => {\n+            match tcx.def_map.borrow().get(&e.id) {\n+                Some(&def) => def.def_id(),\n+                None => return\n+            }\n+        }\n+        ast::ExprMethodCall(i, _, _) => {\n+            span = i.span;\n+            let method_call = ty::MethodCall::expr(e.id);\n+            match tcx.method_map.borrow().get(&method_call) {\n+                Some(method) => {\n+                    match method.origin {\n+                        ty::MethodStatic(def_id) => {\n+                            def_id\n+                        }\n+                        ty::MethodStaticClosure(def_id) => {\n+                            def_id\n+                        }\n+                        ty::MethodTypeParam(ty::MethodParam {\n+                            ref trait_ref,\n+                            method_num: index,\n+                            ..\n+                        }) |\n+                        ty::MethodTraitObject(ty::MethodObject {\n+                            ref trait_ref,\n+                            method_num: index,\n+                            ..\n+                        }) => {\n+                            ty::trait_item(tcx, trait_ref.def_id, index).def_id()\n+                        }\n+                    }\n+                }\n+                None => return\n+            }\n+        }\n+        _ => return\n+    };\n+\n+    maybe_do_stability_check(tcx, id, span, cb);\n+}\n+\n+fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n+                            cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    if !is_staged_api(tcx, id) { return  }\n+    let ref stability = lookup(tcx, id);\n+    cb(id, span, stability);\n+}\n+\n+fn is_internal(tcx: &ty::ctxt, span: Span) -> bool {\n+    tcx.sess.codemap().span_is_internal(span)\n+}\n+\n+fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n+    match ty::trait_item_of_item(tcx, id) {\n+        Some(ty::MethodTraitItemId(trait_method_id))\n+            if trait_method_id != id => {\n+                is_staged_api(tcx, trait_method_id)\n+            }\n+        _ if is_local(id) => {\n+            tcx.stability.borrow().staged_api\n+        }\n+        _ => {\n+            csearch::is_staged_api(&tcx.sess.cstore, id)\n+        }\n+    }\n+}\n+\n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n@@ -190,18 +401,23 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     })\n }\n \n-pub fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n-    match ty::trait_item_of_item(tcx, id) {\n-        Some(ty::MethodTraitItemId(trait_method_id))\n-            if trait_method_id != id => {\n-                is_staged_api(tcx, trait_method_id)\n-            }\n-        _ if is_local(id) => {\n-            // Unused case\n-            unreachable!()\n-        }\n-        _ => {\n-            csearch::is_staged_api(&tcx.sess.cstore, id)\n-        }\n+/// Given the list of enabled features that were not language features (i.e. that\n+/// were expected to be library features), and the list of features used from\n+/// libraries, identify activated features that don't exist and error about them.\n+pub fn check_unused_features(sess: &Session,\n+                             used_lib_features: &FnvHashSet<InternedString>) {\n+    let ref lib_features = sess.features.borrow().lib_features;\n+    let mut active_lib_features: FnvHashMap<InternedString, Span>\n+        = lib_features.clone().into_iter().collect();\n+\n+    for used_feature in used_lib_features.iter() {\n+        active_lib_features.remove(used_feature);\n+    }\n+\n+    for (_, &span) in active_lib_features.iter() {\n+        sess.add_lint(lint::builtin::UNUSED_FEATURES,\n+                      ast::CRATE_NODE_ID,\n+                      span,\n+                      \"unused or unknown feature\".to_string());\n     }\n }"}, {"sha": "5e7168b67358eaf32ad19ec55527888a9cf7776d", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -408,7 +408,7 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             span_note!(tcx.sess, cause_span,\n-                      \"the requirement `{}` appears on the impl method\\\n+                      \"the requirement `{}` appears on the impl method \\\n                       but not on the corresponding trait method\",\n                       predicate.user_string(infcx.tcx));\n         }"}, {"sha": "ed0582804831a3767882cb105d9278cb81c19416", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -394,7 +394,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n             let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n-            debug!(\"poly_project_and_unify_type({}) = {}\",\n+            debug!(\"process_predicate: poly_project_and_unify_type({}) returned {}\",\n                    project_obligation.repr(tcx),\n                    result.repr(tcx));\n             match result {"}, {"sha": "82a4a60cebbf7ea0c921dc6225d5315b90629464", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -18,7 +18,7 @@ pub use self::ObligationCauseCode::*;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{self, Ty};\n-use middle::infer::InferCtxt;\n+use middle::infer::{self, InferCtxt};\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n@@ -392,6 +392,65 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n+                                             cause: ObligationCause<'tcx>)\n+                                             -> ty::ParameterEnvironment<'a,'tcx>\n+{\n+    match normalize_param_env(&unnormalized_env, cause) {\n+        Ok(p) => p,\n+        Err(errors) => {\n+            // I'm not wild about reporting errors here; I'd prefer to\n+            // have the errors get reported at a defined place (e.g.,\n+            // during typeck). Instead I have all parameter\n+            // environments, in effect, going through this function\n+            // and hence potentially reporting errors. This ensurse of\n+            // course that we never forget to normalize (the\n+            // alternative seemed like it would involve a lot of\n+            // manual invocations of this fn -- and then we'd have to\n+            // deal with the errors at each of those sites).\n+            //\n+            // In any case, in practice, typeck constructs all the\n+            // parameter environments once for every fn as it goes,\n+            // and errors will get reported then; so after typeck we\n+            // can be sure that no errors should occur.\n+            let infcx = infer::new_infer_ctxt(unnormalized_env.tcx);\n+            report_fulfillment_errors(&infcx, &errors);\n+\n+            // Normalized failed? use what they gave us, it's better than nothing.\n+            unnormalized_env\n+        }\n+    }\n+}\n+\n+pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n+                                    cause: ObligationCause<'tcx>)\n+                                    -> Result<ty::ParameterEnvironment<'a,'tcx>,\n+                                              Vec<FulfillmentError<'tcx>>>\n+{\n+    let tcx = param_env.tcx;\n+\n+    debug!(\"normalize_param_env(param_env={})\",\n+           param_env.repr(tcx));\n+\n+    let predicates: Vec<ty::Predicate<'tcx>> = {\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        let mut selcx = &mut SelectionContext::new(&infcx, param_env);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let Normalized { value: predicates, obligations } =\n+            project::normalize(selcx, cause, &param_env.caller_bounds);\n+        for obligation in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+        }\n+        try!(fulfill_cx.select_all_or_error(selcx.infcx(), param_env));\n+        predicates.iter().map(|p| infcx.resolve_type_vars_if_possible(p)).collect()\n+    };\n+\n+    debug!(\"normalize_param_env: predicates={}\",\n+           predicates.repr(tcx));\n+\n+    Ok(param_env.with_caller_bounds(predicates))\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "56c1419502fd0db868149db69a452c5161f2b102", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -122,17 +122,15 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    let param_env = ty::construct_parameter_environment(tcx,\n-                                                        &trait_def.generics,\n-                                                        ast::DUMMY_NODE_ID);\n-    let predicates = param_env.caller_bounds.predicates.as_slice().to_vec();\n     let sized_def_id = match tcx.lang_items.sized_trait() {\n         Some(def_id) => def_id,\n         None => { return false; /* No Sized trait, can't require it! */ }\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let free_substs = ty::construct_free_substs(tcx, &trait_def.generics, ast::DUMMY_NODE_ID);\n+    let predicates = trait_def.generics.to_bounds(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n             match predicate {"}, {"sha": "d1dd086a5a342b0adface7779e15ca9f60ff452f", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 197, "deletions": 74, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -18,13 +18,17 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableImplData;\n+use super::util;\n \n use middle::infer;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n                  HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use std::rc::Rc;\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::common::FN_OUTPUT_NAME;\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -53,19 +57,26 @@ pub struct MismatchedProjectionTypes<'tcx> {\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+    Closure(ast::DefId, Substs<'tcx>),\n+    FnPointer(Ty<'tcx>),\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n     vec: Vec<ProjectionTyCandidate<'tcx>>,\n     ambiguous: bool\n }\n \n+/// Evaluates constraints of the form:\n+///\n+///     for<...> <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n pub fn poly_project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"poly_project(obligation={})\",\n+    debug!(\"poly_project_and_unify_type(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n@@ -102,14 +113,17 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n-/// Compute result of projecting an associated type and unify it with\n-/// `obligation.predicate.ty` (if we can).\n+/// Evaluates constraints of the form:\n+///\n+///     <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n fn project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"project_and_unify(obligation={})\",\n+    debug!(\"project_and_unify_type(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n     let Normalized { value: normalized_ty, obligations } =\n@@ -133,6 +147,10 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n+/// Normalizes any associated type projections in `value`, replacing\n+/// them with a fully resolved type where possible. The return value\n+/// combines the normalized result and any additional obligations that\n+/// were incurred as result.\n pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n@@ -142,6 +160,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n     normalize_with_depth(selcx, cause, 0, value)\n }\n \n+/// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                           cause: ObligationCause<'tcx>,\n                                           depth: uint,\n@@ -251,6 +270,12 @@ impl<'tcx,T> Normalized<'tcx,T> {\n     }\n }\n \n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). If ambiguity arises, which implies that\n+/// there are unresolved type variables in the projection, we will\n+/// substitute a fresh type variable `$X` and generate a new\n+/// obligation `<T as Trait>::Item == $X` for later.\n pub fn normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n@@ -277,6 +302,10 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n         })\n }\n \n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). Returns `None` in the case of ambiguity,\n+/// which indicates that there are unbound type variables.\n fn opt_normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n@@ -440,8 +469,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n-    let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n-    let env_predicates = env_predicates.iter().cloned().collect();\n+    let env_predicates = selcx.param_env().caller_bounds.clone();\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, env_predicates);\n }\n@@ -464,20 +492,22 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n \n                 let is_match = same_name && infcx.probe(|_| {\n                     let origin = infer::Misc(obligation.cause.span);\n-                    let obligation_poly_trait_ref =\n-                        obligation_trait_ref.to_poly_trait_ref();\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n+                    let obligation_poly_trait_ref =\n+                        obligation_trait_ref.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n                                               origin,\n-                                              obligation_poly_trait_ref,\n-                                              data_poly_trait_ref).is_ok()\n+                                              data_poly_trait_ref,\n+                                              obligation_poly_trait_ref).is_ok()\n                 });\n \n-                if is_match {\n-                    debug!(\"assemble_candidates_from_predicates: candidate {}\",\n-                           data.repr(selcx.tcx()));\n+                debug!(\"assemble_candidates_from_predicates: candidate {} is_match {} same_name {}\",\n+                       data.repr(selcx.tcx()),\n+                       is_match,\n+                       same_name);\n \n+                if is_match {\n                     candidate_set.vec.push(\n                         ProjectionTyCandidate::ParamEnv(data.clone()));\n                 }\n@@ -551,6 +581,14 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n                 selcx, obligation, obligation_trait_ref, candidate_set,\n                 data.object_ty);\n         }\n+        super::VtableClosure(closure_def_id, substs) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::Closure(closure_def_id, substs));\n+        }\n+        super::VtableFnPointer(fn_type) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::FnPointer(fn_type));\n+        }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n             // associated type. Consider:\n@@ -578,9 +616,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // projection. And the projection where clause is handled\n             // in `assemble_candidates_from_param_env`.\n         }\n-        super::VtableBuiltin(..) |\n-        super::VtableClosure(..) |\n-        super::VtableFnPointer(..) => {\n+        super::VtableBuiltin(..) => {\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n@@ -606,67 +642,150 @@ fn confirm_candidate<'cx,'tcx>(\n \n     match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n-            let projection =\n-                infcx.replace_late_bound_regions_with_fresh_var(\n-                    obligation.cause.span,\n-                    infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &poly_projection).0;\n-\n-            assert_eq!(projection.projection_ty.item_name,\n-                       obligation.predicate.item_name);\n-\n-            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-            match infcx.sub_trait_refs(false,\n-                                       origin,\n-                                       obligation.predicate.trait_ref.clone(),\n-                                       projection.projection_ty.trait_ref.clone()) {\n-                Ok(()) => { }\n-                Err(e) => {\n-                    selcx.tcx().sess.span_bug(\n-                        obligation.cause.span,\n-                        format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                                obligation.repr(selcx.tcx()),\n-                                projection.repr(selcx.tcx()),\n-                                ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n-                }\n-            }\n-\n-            (projection.ty, vec!())\n+            confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n         ProjectionTyCandidate::Impl(impl_vtable) => {\n-            // there don't seem to be nicer accessors to these:\n-            let impl_items_map = selcx.tcx().impl_items.borrow();\n-            let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n-\n-            let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n-            let mut impl_ty = None;\n-            for impl_item in impl_items.iter() {\n-                let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n-                    ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-                    ty::MethodTraitItem(..) => { continue; }\n-                };\n-\n-                if assoc_type.name != obligation.predicate.item_name {\n-                    continue;\n-                }\n+            confirm_impl_candidate(selcx, obligation, impl_vtable)\n+        }\n \n-                let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n-                impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n-                break;\n-            }\n+        ProjectionTyCandidate::Closure(def_id, substs) => {\n+            confirm_closure_candidate(selcx, obligation, def_id, &substs)\n+        }\n \n-            match impl_ty {\n-                Some(ty) => (ty, impl_vtable.nested.into_vec()),\n-                None => {\n-                    // This means that the impl is missing a\n-                    // definition for the associated type. This error\n-                    // ought to be reported by the type checker method\n-                    // `check_impl_items_against_trait`, so here we\n-                    // just return ty_err.\n-                    (selcx.tcx().types.err, vec!())\n-                }\n-            }\n+        ProjectionTyCandidate::FnPointer(fn_type) => {\n+            confirm_fn_pointer_candidate(selcx, obligation, fn_type)\n+        }\n+    }\n+}\n+\n+fn confirm_fn_pointer_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_type: Ty<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let fn_type = selcx.infcx().shallow_resolve(fn_type);\n+    let sig = ty::ty_fn_sig(fn_type);\n+    confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n+}\n+\n+fn confirm_closure_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: &Substs<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let closure_typer = selcx.closure_typer();\n+    let closure_type = closure_typer.closure_type(closure_def_id, substs);\n+    confirm_callable_candidate(selcx, obligation, &closure_type.sig, util::TupleArgumentsFlag::No)\n+}\n+\n+fn confirm_callable_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_sig: &ty::PolyFnSig<'tcx>,\n+    flag: util::TupleArgumentsFlag)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let tcx = selcx.tcx();\n+\n+    debug!(\"confirm_closure_candidate({},{})\",\n+           obligation.repr(tcx),\n+           fn_sig.repr(tcx));\n+\n+    // Note: we unwrap the binder here but re-create it below (1)\n+    let ty::Binder((trait_ref, ret_type)) =\n+        util::closure_trait_ref_and_return_type(tcx,\n+                                                obligation.predicate.trait_ref.def_id,\n+                                                obligation.predicate.trait_ref.self_ty(),\n+                                                fn_sig,\n+                                                flag);\n+\n+    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: trait_ref,\n+            item_name: token::intern(FN_OUTPUT_NAME),\n+        },\n+        ty: ret_type\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+}\n+\n+fn confirm_param_env_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    poly_projection: ty::PolyProjectionPredicate<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let infcx = selcx.infcx();\n+\n+    let projection =\n+        infcx.replace_late_bound_regions_with_fresh_var(\n+            obligation.cause.span,\n+            infer::LateBoundRegionConversionTime::HigherRankedType,\n+            &poly_projection).0;\n+\n+    assert_eq!(projection.projection_ty.item_name,\n+               obligation.predicate.item_name);\n+\n+    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    match infcx.sub_trait_refs(false,\n+                               origin,\n+                               obligation.predicate.trait_ref.clone(),\n+                               projection.projection_ty.trait_ref.clone()) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n+                        obligation.repr(selcx.tcx()),\n+                        projection.repr(selcx.tcx()),\n+                        ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n+        }\n+    }\n+\n+    (projection.ty, vec!())\n+}\n+\n+fn confirm_impl_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    // there don't seem to be nicer accessors to these:\n+    let impl_items_map = selcx.tcx().impl_items.borrow();\n+    let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n+\n+    let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+    let mut impl_ty = None;\n+    for impl_item in impl_items.iter() {\n+        let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+            ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n+            ty::MethodTraitItem(..) => { continue; }\n+        };\n+\n+        if assoc_type.name != obligation.predicate.item_name {\n+            continue;\n+        }\n+\n+        let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n+        impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n+        break;\n+    }\n+\n+    match impl_ty {\n+        Some(ty) => (ty, impl_vtable.nested.into_vec()),\n+        None => {\n+            // This means that the impl is missing a\n+            // definition for the associated type. This error\n+            // ought to be reported by the type checker method\n+            // `check_impl_items_against_trait`, so here we\n+            // just return ty_err.\n+            (selcx.tcx().types.err, vec!())\n         }\n     }\n }\n@@ -688,7 +807,11 @@ impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n             ProjectionTyCandidate::ParamEnv(ref data) =>\n                 format!(\"ParamEnv({})\", data.repr(tcx)),\n             ProjectionTyCandidate::Impl(ref data) =>\n-                format!(\"Impl({})\", data.repr(tcx))\n+                format!(\"Impl({})\", data.repr(tcx)),\n+            ProjectionTyCandidate::Closure(ref a, ref b) =>\n+                format!(\"Closure(({},{}))\", a.repr(tcx), b.repr(tcx)),\n+            ProjectionTyCandidate::FnPointer(a) =>\n+                format!(\"FnPointer(({}))\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "4d5f3d925b09abfeb764b6d123dc8ac0de9eaf37", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 98, "deletions": 57, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -214,6 +214,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.closure_typer.param_env()\n     }\n \n+    pub fn closure_typer(&self) -> &'cx (ty::ClosureTyper<'tcx>+'cx) {\n+        self.closure_typer\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -526,9 +530,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n-        debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n-               cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n-        self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n+\n+        if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n+            debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n+                   cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n+            self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n+        }\n+\n         candidate\n     }\n \n@@ -705,6 +713,47 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n     }\n \n+    fn should_update_candidate_cache(&mut self,\n+                                     cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>,\n+                                     candidate: &SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n+                                     -> bool\n+    {\n+        // In general, it's a good idea to cache results, even\n+        // ambigious ones, to save us some trouble later. But we have\n+        // to be careful not to cache results that could be\n+        // invalidated later by advances in inference. Normally, this\n+        // is not an issue, because any inference variables whose\n+        // types are not yet bound are \"freshened\" in the cache key,\n+        // which means that if we later get the same request once that\n+        // type variable IS bound, we'll have a different cache key.\n+        // For example, if we have `Vec<_#0t> : Foo`, and `_#0t` is\n+        // not yet known, we may cache the result as `None`. But if\n+        // later `_#0t` is bound to `Bar`, then when we freshen we'll\n+        // have `Vec<Bar> : Foo` as the cache key.\n+        //\n+        // HOWEVER, it CAN happen that we get an ambiguity result in\n+        // one particular case around closures where the cache key\n+        // would not change. That is when the precise types of the\n+        // upvars that a closure references have not yet been figured\n+        // out (i.e., because it is not yet known if they are captured\n+        // by ref, and if by ref, what kind of ref). In these cases,\n+        // when matching a builtin bound, we will yield back an\n+        // ambiguous result. But the *cache key* is just the closure type,\n+        // it doesn't capture the state of the upvar computation.\n+        //\n+        // To avoid this trap, just don't cache ambiguous results if\n+        // the self-type contains no inference byproducts (that really\n+        // shouldn't happen in other circumstances anyway, given\n+        // coherence).\n+\n+        match *candidate {\n+            Ok(Some(_)) | Err(_) => true,\n+            Ok(None) => {\n+                cache_fresh_trait_pred.0.input_types().iter().any(|&t| ty::type_has_ty_infer(t))\n+            }\n+        }\n+    }\n+\n     fn assemble_candidates<'o>(&mut self,\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n@@ -788,6 +837,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // FIXME(#20297) -- being strict about this can cause\n                 // inference failures with BorrowFrom, which is\n                 // unfortunate. Can we do better here?\n+                debug!(\"assemble_candidates_for_projected_tys: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return;\n             }\n@@ -905,7 +955,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                stack.obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n-            self.param_env().caller_bounds.predicates.iter()\n+            self.param_env().caller_bounds.iter()\n             .filter_map(|o| o.to_opt_poly_trait_ref())\n             .collect();\n \n@@ -962,6 +1012,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n             }\n@@ -1000,6 +1051,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.sty {\n             ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n@@ -1270,7 +1322,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(())\n             }\n             Ok(ParameterBuiltin) => { Ok(()) }\n-            Ok(AmbiguousBuiltin) => { Ok(candidates.ambiguous = true) }\n+            Ok(AmbiguousBuiltin) => {\n+                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n+                Ok(candidates.ambiguous = true)\n+            }\n             Err(e) => { Err(e) }\n         }\n     }\n@@ -1476,6 +1531,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Ok(If(upvars.iter().map(|c| c.ty).collect()))\n                     }\n                     None => {\n+                        debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n                     }\n                 }\n@@ -1512,6 +1568,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n+                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(AmbiguousBuiltin)\n             }\n \n@@ -1860,33 +1917,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let sig = match self_ty.sty {\n-            ty::ty_bare_fn(_, &ty::BareFnTy {\n-                unsafety: ast::Unsafety::Normal,\n-                abi: abi::Rust,\n-                ref sig\n-            }) => {\n-                sig\n-            }\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    &format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx()))[]);\n-            }\n-        };\n-\n-        let arguments_tuple = ty::mk_tup(self.tcx(), sig.0.inputs.to_vec());\n-        let output_type = sig.0.output.unwrap();\n-        let substs =\n-            Substs::new_trait(\n-                vec![arguments_tuple, output_type],\n-                vec![],\n-                self_ty);\n-        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n-            def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(substs),\n-        }));\n+        let sig = ty::ty_fn_sig(self_ty);\n+        let ty::Binder((trait_ref, _)) =\n+            util::closure_trait_ref_and_return_type(self.tcx(),\n+                                                    obligation.predicate.def_id(),\n+                                                    self_ty,\n+                                                    sig,\n+                                                    util::TupleArgumentsFlag::Yes);\n+        let trait_ref = ty::Binder(trait_ref);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -1905,23 +1943,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n-\n-        debug!(\"confirm_closure_candidate: closure_def_id={} closure_type={}\",\n-               closure_def_id.repr(self.tcx()),\n-               closure_type.repr(self.tcx()));\n-\n-        let closure_sig = &closure_type.sig;\n-        let arguments_tuple = closure_sig.0.inputs[0];\n-        let trait_substs =\n-            Substs::new_trait(\n-                vec![arguments_tuple, closure_sig.0.output.unwrap()],\n-                vec![],\n-                obligation.self_ty());\n-        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n-            def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(trait_substs),\n-        }));\n+        let trait_ref = self.closure_trait_ref(obligation,\n+                                               closure_def_id,\n+                                               substs);\n \n         debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n@@ -2104,16 +2128,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        let where_clause_trait_ref =\n-            project::normalize_with_depth(self,\n-                                          obligation.cause.clone(),\n-                                          obligation.recursion_depth+1,\n-                                          &where_clause_trait_ref);\n-\n         let () =\n-            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref.value.clone()));\n+            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n \n-        Ok(where_clause_trait_ref.obligations)\n+        Ok(Vec::new())\n     }\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n@@ -2233,6 +2251,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn closure_trait_ref(&self,\n+                         obligation: &TraitObligation<'tcx>,\n+                         closure_def_id: ast::DefId,\n+                         substs: &Substs<'tcx>)\n+                         -> ty::PolyTraitRef<'tcx>\n+    {\n+        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n+        let ty::Binder((trait_ref, _)) =\n+            util::closure_trait_ref_and_return_type(self.tcx(),\n+                                                    obligation.predicate.def_id(),\n+                                                    obligation.predicate.0.self_ty(), // (1)\n+                                                    &closure_type.sig,\n+                                                    util::TupleArgumentsFlag::No);\n+\n+        // (1) Feels icky to skip the binder here, but OTOH we know\n+        // that the self-type is an unboxed closure type and hence is\n+        // in fact unparameterized (or at least does not reference any\n+        // regions bound in the obligation). Still probably some\n+        // refactoring could make this nicer.\n+\n+        ty::Binder(trait_ref)\n+    }\n+\n     fn impl_obligations(&mut self,\n                         cause: ObligationCause<'tcx>,\n                         recursion_depth: uint,"}, {"sha": "edeca83d5697f6dadba1300840e019f50d61d01c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -329,28 +329,67 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object_trait_ref: ty::PolyTraitRef<'tcx>,\n                                                trait_def_id: ast::DefId,\n-                                               method_index_in_trait: uint) -> uint {\n+                                               method_offset_in_trait: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until\n     // we find the trait the method came from, counting up the\n     // methods from them.\n     let mut method_count = 0;\n-    ty::each_bound_trait_and_supertraits(tcx, &[object_trait_ref], |bound_ref| {\n+\n+    for bound_ref in transitive_bounds(tcx, &[object_trait_ref]) {\n         if bound_ref.def_id() == trait_def_id {\n-            false\n-        } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-            for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(_) => method_count += 1,\n-                    ty::TypeTraitItem(_) => {}\n-                }\n+            break;\n+        }\n+\n+        let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+        for trait_item in trait_items.iter() {\n+            match *trait_item {\n+                ty::MethodTraitItem(_) => method_count += 1,\n+                ty::TypeTraitItem(_) => {}\n             }\n-            true\n         }\n+    }\n+\n+    // count number of methods preceding the one we are selecting and\n+    // add them to the total offset; skip over associated types.\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    for trait_item in trait_items.iter().take(method_offset_in_trait) {\n+        match *trait_item {\n+            ty::MethodTraitItem(_) => method_count += 1,\n+            ty::TypeTraitItem(_) => {}\n+        }\n+    }\n+\n+    // the item at the offset we were given really ought to be a method\n+    assert!(match trait_items[method_offset_in_trait] {\n+        ty::MethodTraitItem(_) => true,\n+        ty::TypeTraitItem(_) => false\n+    });\n+\n+    method_count\n+}\n+\n+pub enum TupleArgumentsFlag { Yes, No }\n+\n+pub fn closure_trait_ref_and_return_type<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    fn_trait_def_id: ast::DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: &ty::PolyFnSig<'tcx>,\n+    tuple_arguments: TupleArgumentsFlag)\n+    -> ty::Binder<(Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)>\n+{\n+    let arguments_tuple = match tuple_arguments {\n+        TupleArgumentsFlag::No => sig.0.inputs[0],\n+        TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n+    };\n+    let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n+    let trait_ref = Rc::new(ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs(trait_substs),\n     });\n-    method_count + method_index_in_trait\n+    ty::Binder((trait_ref, sig.0.output.unwrap()))\n }\n \n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {"}, {"sha": "062ddd23d9de936ee5d93fadd080ef9d6c8ae919", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -452,7 +452,10 @@ pub struct MethodParam<'tcx> {\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n-    // index of uint in the list of methods for the trait\n+\n+    // index of uint in the list of trait items. Note that this is NOT\n+    // the index into the vtable, because the list of trait items\n+    // includes associated types.\n     pub method_num: uint,\n \n     /// The impl for the trait from which the method comes. This\n@@ -471,14 +474,14 @@ pub struct MethodObject<'tcx> {\n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n \n-    // index of the method to be invoked amongst the trait's methods\n+    // index of the method to be invoked amongst the trait's items\n     pub method_num: uint,\n \n     // index into the actual runtime vtable.\n     // the vtable is formed by concatenating together the method lists of\n-    // the base object trait and all supertraits;  this is the index into\n+    // the base object trait and all supertraits; this is the index into\n     // that vtable\n-    pub real_index: uint,\n+    pub vtable_index: uint,\n }\n \n #[derive(Clone)]\n@@ -2084,11 +2087,7 @@ impl<'tcx> TraitRef<'tcx> {\n pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     pub tcx: &'a ctxt<'tcx>,\n \n-    /// A substitution that can be applied to move from\n-    /// the \"outer\" view of a type or method to the \"inner\" view.\n-    /// In general, this means converting from bound parameters to\n-    /// free parameters. Since we currently represent bound/free type\n-    /// parameters in the same way, this only has an effect on regions.\n+    /// See `construct_free_substs` for details.\n     pub free_substs: Substs<'tcx>,\n \n     /// Each type parameter has an implicit region bound that\n@@ -2100,14 +2099,27 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations.\n-    pub caller_bounds: ty::GenericBounds<'tcx>,\n+    pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn with_caller_bounds(&self,\n+                              caller_bounds: Vec<ty::Predicate<'tcx>>)\n+                              -> ParameterEnvironment<'a,'tcx>\n+    {\n+        ParameterEnvironment {\n+            tcx: self.tcx,\n+            free_substs: self.free_substs.clone(),\n+            implicit_region_bound: self.implicit_region_bound,\n+            caller_bounds: caller_bounds,\n+            selection_cache: traits::SelectionCache::new(),\n+        }\n+    }\n+\n     pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n@@ -2119,6 +2131,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -2153,6 +2166,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -2179,6 +2193,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n+                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -2189,7 +2204,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, &pty.generics, id)\n+                        construct_parameter_environment(cx, item.span, &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -6258,23 +6273,22 @@ impl Variance {\n pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvironment<'a,'tcx> {\n     ty::ParameterEnvironment { tcx: cx,\n                                free_substs: Substs::empty(),\n-                               caller_bounds: GenericBounds::empty(),\n+                               caller_bounds: Vec::new(),\n                                implicit_region_bound: ty::ReEmpty,\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n-/// See `ParameterEnvironment` struct def'n for details\n-pub fn construct_parameter_environment<'a,'tcx>(\n+/// Constructs and returns a substitution that can be applied to move from\n+/// the \"outer\" view of a type or method to the \"inner\" view.\n+/// In general, this means converting from bound parameters to\n+/// free parameters. Since we currently represent bound/free type\n+/// parameters in the same way, this only has an effect on regions.\n+pub fn construct_free_substs<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n-    -> ParameterEnvironment<'a, 'tcx>\n+    -> Substs<'tcx>\n {\n-\n-    //\n-    // Construct the free substs.\n-    //\n-\n     // map T => T\n     let mut types = VecPerParamSpace::empty();\n     push_types_from_defs(tcx, &mut types, generics.types.as_slice());\n@@ -6283,11 +6297,45 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     let mut regions = VecPerParamSpace::empty();\n     push_region_params(&mut regions, free_id, generics.regions.as_slice());\n \n-    let free_substs = Substs {\n+    return Substs {\n         types: types,\n         regions: subst::NonerasedRegions(regions)\n     };\n \n+    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n+                          free_id: ast::NodeId,\n+                          region_params: &[RegionParameterDef])\n+    {\n+        for r in region_params.iter() {\n+            regions.push(r.space, ty::free_region_from_def(free_id, r));\n+        }\n+    }\n+\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut VecPerParamSpace<Ty<'tcx>>,\n+                                  defs: &[TypeParameterDef<'tcx>]) {\n+        for def in defs.iter() {\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n+                   def.repr(tcx));\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n+       }\n+    }\n+}\n+\n+/// See `ParameterEnvironment` struct def'n for details\n+pub fn construct_parameter_environment<'a,'tcx>(\n+    tcx: &'a ctxt<'tcx>,\n+    span: Span,\n+    generics: &ty::Generics<'tcx>,\n+    free_id: ast::NodeId)\n+    -> ParameterEnvironment<'a, 'tcx>\n+{\n+    //\n+    // Construct the free substs.\n+    //\n+\n+    let free_substs = construct_free_substs(tcx, generics, free_id);\n     let free_id_scope = region::CodeExtent::from_node_id(free_id);\n \n     //\n@@ -6296,52 +6344,50 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n     let bounds = liberate_late_bound_regions(tcx, free_id_scope, &ty::Binder(bounds));\n+    let predicates = bounds.predicates.into_vec();\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n     // global table on the tcx, so just enter them there. I'm not\n     // crazy about this scheme, but it's convenient, at least.\n     //\n \n-    record_region_bounds(tcx, &bounds);\n+    record_region_bounds(tcx, &*predicates);\n \n-    debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} bounds={:?}\",\n+    debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n            free_id,\n            free_substs.repr(tcx),\n-           bounds.repr(tcx));\n+           predicates.repr(tcx));\n+\n+    //\n+    // Finally, we have to normalize the bounds in the environment, in\n+    // case they contain any associated type projections. This process\n+    // can yield errors if the put in illegal associated types, like\n+    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n+    // report these errors right here; this doesn't actually feel\n+    // right to me, because constructing the environment feels like a\n+    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // a better place. In practice, we construct environments for\n+    // every fn once during type checking, and we'll abort if there\n+    // are any errors at that point, so after type checking you can be\n+    // sure that this will succeed without errors anyway.\n+    //\n \n-    return ty::ParameterEnvironment {\n+    let unnormalized_env = ty::ParameterEnvironment {\n         tcx: tcx,\n         free_substs: free_substs,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n-        caller_bounds: bounds,\n+        caller_bounds: predicates,\n         selection_cache: traits::SelectionCache::new(),\n     };\n \n-    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n-                          free_id: ast::NodeId,\n-                          region_params: &[RegionParameterDef])\n-    {\n-        for r in region_params.iter() {\n-            regions.push(r.space, ty::free_region_from_def(free_id, r));\n-        }\n-    }\n-\n-    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  types: &mut VecPerParamSpace<Ty<'tcx>>,\n-                                  defs: &[TypeParameterDef<'tcx>]) {\n-        for def in defs.iter() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                   def.repr(tcx));\n-            let ty = ty::mk_param_from_def(tcx, def);\n-            types.push(def.space, ty);\n-       }\n-    }\n+    let cause = traits::ObligationCause::misc(span, free_id);\n+    return traits::normalize_param_env_or_error(unnormalized_env, cause);\n \n-    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, bounds: &GenericBounds<'tcx>) {\n-        debug!(\"record_region_bounds(bounds={:?})\", bounds.repr(tcx));\n+    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, predicates: &[ty::Predicate<'tcx>]) {\n+        debug!(\"record_region_bounds(predicates={:?})\", predicates.repr(tcx));\n \n-        for predicate in bounds.predicates.iter() {\n+        for predicate in predicates.iter() {\n             match *predicate {\n                 Predicate::Projection(..) |\n                 Predicate::Trait(..) |"}, {"sha": "69d32c3f5fc33b4a8333dd5bd436c4f13b279a37", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -71,7 +71,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     fn exit_region_binder(&mut self) { }\n \n     fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n         super_fold_binder(self, t)\n@@ -186,7 +186,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>+Clone> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n@@ -319,7 +319,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n                     trait_ref: object.trait_ref.fold_with(folder),\n                     object_trait_id: object.object_trait_id,\n                     method_num: object.method_num,\n-                    real_index: object.real_index\n+                    vtable_index: object.vtable_index,\n                 })\n             }\n         }"}, {"sha": "e62f3145e5a2e5e894a5ac06bdbfaf7fc9533ce0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -305,9 +305,19 @@ pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<Path>,\n                      registry: diagnostics::registry::Registry)\n                      -> Session {\n+    // FIXME: This is not general enough to make the warning lint completely override\n+    // normal diagnostic warnings, since the warning lint can also be denied and changed\n+    // later via the source code.\n+    let can_print_warnings = sopts.lint_opts\n+        .iter()\n+        .filter(|&&(ref key, _)| *key == \"warnings\")\n+        .map(|&(_, ref level)| *level != lint::Allow)\n+        .last()\n+        .unwrap_or(true);\n+\n     let codemap = codemap::CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::default_handler(sopts.color, Some(registry));\n+        diagnostic::default_handler(sopts.color, Some(registry), can_print_warnings);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "bdb6ea22f8b457fa2c779ac945bef9804e64407b", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -22,6 +22,9 @@ use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// The name of the associated type for `Fn` return types\n+pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n+\n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n #[derive(Clone, Copy, Show)]"}, {"sha": "1be99a8e569f3f55bb8b536b19b790c0998eee01", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 96, "deletions": 45, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -298,17 +298,9 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n     fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n-\n-        match cty.unsafety {\n-            ast::Unsafety::Normal => {}\n-            ast::Unsafety::Unsafe => {\n-                s.push_str(cty.unsafety.to_string().as_slice());\n-                s.push(' ');\n-            }\n-        };\n-\n-        push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n-\n+        s.push_str(\"[closure\");\n+        push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n+        s.push(']');\n         s\n     }\n \n@@ -399,18 +391,10 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, base.as_slice(), substs, &generics, did)\n+            parameterized(cx, base.as_slice(), substs, &generics, did, &[])\n         }\n-        ty_trait(box ty::TyTrait {\n-            ref principal, ref bounds\n-        }) => {\n-            let principal = principal.user_string(cx);\n-            let bound_str = bounds.user_string(cx);\n-            let bound_sep = if bound_str.is_empty() { \"\" } else { \" + \" };\n-            format!(\"{}{}{}\",\n-                    principal,\n-                    bound_sep,\n-                    bound_str)\n+        ty_trait(ref data) => {\n+            data.user_string(cx)\n         }\n         ty::ty_projection(ref data) => {\n             format!(\"<{} as {}>::{}\",\n@@ -420,14 +404,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_str => \"str\".to_string(),\n         ty_closure(ref did, _, substs) => {\n-            cx.closures.borrow().get(did).map(|cl| {\n+            let closures = cx.closures.borrow();\n+            closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| {\n                 if did.krate == ast::LOCAL_CRATE {\n                     let span = cx.map.span(did.node);\n-                    format!(\"closure[{}]\", span.repr(cx))\n+                    format!(\"[closure {}]\", span.repr(cx))\n                 } else {\n-                    format!(\"closure\")\n+                    format!(\"[closure]\")\n                 }\n             })\n         }\n@@ -458,7 +443,8 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n                            base: &str,\n                            substs: &subst::Substs<'tcx>,\n                            generics: &ty::Generics<'tcx>,\n-                           did: ast::DefId)\n+                           did: ast::DefId,\n+                           projections: &[ty::ProjectionPredicate<'tcx>])\n                            -> String\n {\n     if cx.sess.verbose() {\n@@ -511,7 +497,20 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if cx.lang_items.fn_trait_kind(did).is_some() {\n+    for projection in projections.iter() {\n+        strs.push(format!(\"{}={}\",\n+                          projection.projection_ty.item_name.user_string(cx),\n+                          projection.ty.user_string(cx)));\n+    }\n+\n+    if cx.lang_items.fn_trait_kind(did).is_some() && projections.len() == 1 {\n+        let projection_ty = projections[0].ty;\n+        let tail =\n+            if ty::type_is_nil(projection_ty) {\n+                format!(\"\")\n+            } else {\n+                format!(\" -> {}\", projection_ty.user_string(cx))\n+            };\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n@@ -521,7 +520,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n                 } else {\n                     &strs[0][]\n                 },\n-                if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n+                tail)\n     } else if strs.len() > 0 {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n@@ -623,6 +622,65 @@ impl<'tcx> Repr<'tcx> for def::Def {\n     }\n }\n \n+/// This curious type is here to help pretty-print trait objects. In\n+/// a trait object, the projections are stored separately from the\n+/// main trait bound, but in fact we want to package them together\n+/// when printing out; they also have separate binders, but we want\n+/// them to share a binder when we print them out. (And the binder\n+/// pretty-printing logic is kind of clever and we don't want to\n+/// reproduce it.) So we just repackage up the structure somewhat.\n+///\n+/// Right now there is only one trait in an object that can have\n+/// projection bounds, so we just stuff them altogether. But in\n+/// reality we should eventually sort things out better.\n+type TraitAndProjections<'tcx> =\n+    (Rc<ty::TraitRef<'tcx>>, Vec<ty::ProjectionPredicate<'tcx>>);\n+\n+impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let &(ref trait_ref, ref projection_bounds) = self;\n+        let base = ty::item_path_str(tcx, trait_ref.def_id);\n+        let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n+        parameterized(tcx,\n+                      base.as_slice(),\n+                      trait_ref.substs,\n+                      &trait_def.generics,\n+                      trait_ref.def_id,\n+                      &projection_bounds[])\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let &ty::TyTrait { ref principal, ref bounds } = self;\n+\n+        let mut components = vec![];\n+\n+        let tap: ty::Binder<TraitAndProjections<'tcx>> =\n+            ty::Binder((principal.0.clone(),\n+                        bounds.projection_bounds.iter().map(|x| x.0.clone()).collect()));\n+\n+        // Generate the main trait ref, including associated types.\n+        components.push(tap.user_string(tcx));\n+\n+        // Builtin bounds.\n+        for bound in bounds.builtin_bounds.iter() {\n+            components.push(bound.user_string(tcx));\n+        }\n+\n+        // Region, if not obviously implied by builtin bounds.\n+        if bounds.region_bound != ty::ReStatic ||\n+            !bounds.builtin_bounds.contains(&ty::BoundSend)\n+        { // Region bound is implied by builtin bounds:\n+            components.push(bounds.region_bound.user_string(tcx));\n+        }\n+\n+        components.retain(|s| !s.is_empty());\n+\n+        components.connect(\" + \")\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TypeParameterDef({:?}, {}, {:?}/{})\",\n@@ -701,12 +759,6 @@ impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        self.user_string(tcx)\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n@@ -727,7 +779,8 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), self.substs, &trait_def.generics, self.def_id))\n+                parameterized(tcx, base.as_slice(), self.substs,\n+                              &trait_def.generics, self.def_id, &[]))\n     }\n }\n \n@@ -1062,7 +1115,7 @@ impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n         format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n-                self.real_index)\n+                self.vtable_index)\n     }\n }\n \n@@ -1110,14 +1163,8 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        if self.builtin_bounds.contains(&ty::BoundSend) &&\n-            self.region_bound == ty::ReStatic\n-        { // Region bound is implied by builtin bounds:\n-            return self.builtin_bounds.repr(tcx);\n-        }\n-\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n \n         let region_str = self.region_bound.user_string(tcx);\n@@ -1129,6 +1176,10 @@ impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n             res.push(bound.user_string(tcx));\n         }\n \n+        for projection_bound in self.projection_bounds.iter() {\n+            res.push(projection_bound.user_string(tcx));\n+        }\n+\n         res.connect(\"+\")\n     }\n }\n@@ -1184,7 +1235,7 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n         let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         parameterized(tcx, path_str.as_slice(), self.substs,\n-                      &trait_def.generics, self.def_id)\n+                      &trait_def.generics, self.def_id, &[])\n     }\n }\n "}, {"sha": "151173b3a40850b55df8a3a8b686cd27ee1a8e70", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -22,8 +22,7 @@ use self::UndoLog::*;\n \n use std::mem;\n \n-#[derive(PartialEq)]\n-pub enum UndoLog<T,U> {\n+pub enum UndoLog<D:SnapshotVecDelegate> {\n     /// Indicates where a snapshot started.\n     OpenSnapshot,\n \n@@ -34,15 +33,15 @@ pub enum UndoLog<T,U> {\n     NewElem(uint),\n \n     /// Variable with given index was changed *from* the given value.\n-    SetElem(uint, T),\n+    SetElem(uint, D::Value),\n \n     /// Extensible set of actions\n-    Other(U)\n+    Other(D::Undo)\n }\n \n-pub struct SnapshotVec<T,U,D> {\n-    values: Vec<T>,\n-    undo_log: Vec<UndoLog<T,U>>,\n+pub struct SnapshotVec<D:SnapshotVecDelegate> {\n+    values: Vec<D::Value>,\n+    undo_log: Vec<UndoLog<D>>,\n     delegate: D\n }\n \n@@ -53,12 +52,15 @@ pub struct Snapshot {\n     length: uint,\n }\n \n-pub trait SnapshotVecDelegate<T,U> {\n-    fn reverse(&mut self, values: &mut Vec<T>, action: U);\n+pub trait SnapshotVecDelegate {\n+    type Value;\n+    type Undo;\n+\n+    fn reverse(&mut self, values: &mut Vec<Self::Value>, action: Self::Undo);\n }\n \n-impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n-    pub fn new(delegate: D) -> SnapshotVec<T,U,D> {\n+impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n+    pub fn new(delegate: D) -> SnapshotVec<D> {\n         SnapshotVec {\n             values: Vec::new(),\n             undo_log: Vec::new(),\n@@ -70,13 +72,13 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         !self.undo_log.is_empty()\n     }\n \n-    pub fn record(&mut self, action: U) {\n+    pub fn record(&mut self, action: D::Undo) {\n         if self.in_snapshot() {\n             self.undo_log.push(Other(action));\n         }\n     }\n \n-    pub fn push(&mut self, elem: T) -> uint {\n+    pub fn push(&mut self, elem: D::Value) -> uint {\n         let len = self.values.len();\n         self.values.push(elem);\n \n@@ -87,20 +89,20 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         len\n     }\n \n-    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, index: uint) -> &'a D::Value {\n         &self.values[index]\n     }\n \n     /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n     /// automatically, so you should be sure call `record()` with some sort of suitable undo\n     /// action.\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut D::Value {\n         &mut self.values[index]\n     }\n \n     /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n     /// a snapshot is active.\n-    pub fn set(&mut self, index: uint, new_elem: T) {\n+    pub fn set(&mut self, index: uint, new_elem: D::Value) {\n         let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));\n@@ -115,7 +117,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n \n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n-                                  -> &[UndoLog<T,U>] {\n+                                  -> &[UndoLog<D>] {\n         &self.undo_log[snapshot.length..]\n     }\n "}, {"sha": "13dec65d13ea70c6f7e9e949acf0712e11c19707", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -22,7 +22,8 @@\n //! build speedups.\n \n #![crate_name = \"rustc_back\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -32,7 +33,13 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax, box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "a63e8237b4bef01780b68125debe00955e18a111", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -223,7 +223,7 @@ impl Target {\n         // this is 1. ugly, 2. error prone.\n \n \n-        let handler = diagnostic::default_handler(diagnostic::Auto, None);\n+        let handler = diagnostic::default_handler(diagnostic::Auto, None, true);\n \n         let get_req_field = |&: name: &str| {\n             match obj.find(name)"}, {"sha": "e0f5b5c387f9ab11829a2fbf7ef4c86561b20396", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_bitflags\"]\n-#![unstable]\n+#![allow(unknown_features)]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![no_std]\n+#![unstable(feature = \"rustc_private\")]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "d525c22f0ab6f22de8bfc8603bc87c3493fb4bd3", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_borrowck\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -23,7 +24,10 @@\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "6e76519ce23607fdbaf1b6567febd5f45b2e44c0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -390,16 +390,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // baz! should not use this definition unless foo is enabled.\n \n     time(time_passes, \"gated macro checking\", (), |_| {\n-        let (features, unknown_features) =\n+        let features =\n             syntax::feature_gate::check_crate_macros(sess.codemap(),\n                                                      &sess.parse_sess.span_diagnostic,\n                                                      &krate);\n-        for uf in unknown_features.iter() {\n-            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n-                          ast::CRATE_NODE_ID,\n-                          *uf,\n-                          \"unknown feature\".to_string());\n-        }\n \n         // these need to be set \"early\" so that expansion sees `quote` if enabled.\n         *sess.features.borrow_mut() = features;\n@@ -492,9 +486,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(time_passes, \"complete gated feature checking\", (), |_| {\n-        syntax::feature_gate::check_crate(sess.codemap(),\n+        let features =\n+            syntax::feature_gate::check_crate(sess.codemap(),\n                                           &sess.parse_sess.span_diagnostic,\n                                           &krate);\n+        *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });\n \n@@ -599,7 +595,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n          middle::check_loop::check_crate(&sess, krate));\n \n     let stability_index = time(time_passes, \"stability index\", (), |_|\n-                               stability::Index::build(krate));\n+                               stability::Index::build(&sess, krate));\n \n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n@@ -668,9 +664,20 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                   &reachable_map)\n     });\n \n+    let ref lib_features_used =\n+        time(time_passes, \"stability checking\", (), |_|\n+             stability::check_unstable_api_usage(&ty_cx));\n+\n+    time(time_passes, \"unused feature checking\", (), |_|\n+         stability::check_unused_features(\n+             &ty_cx.sess, lib_features_used));\n+\n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(&ty_cx, &exported_items));\n \n+    // The above three passes generate errors w/o aborting\n+    ty_cx.sess.abort_if_errors();\n+\n     ty::CrateAnalysis {\n         export_map: export_map,\n         ty_cx: ty_cx,"}, {"sha": "727638c29c35fb196c4ee9c154031a5971baa319", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -15,7 +15,8 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_driver\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -29,7 +30,15 @@\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "52d7415a523df3467ea215b1a13f7a88327325b0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -103,7 +103,7 @@ fn test_env<F>(source_string: &str,\n     let codemap =\n         CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::mk_handler(emitter);\n+        diagnostic::mk_handler(true, emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -125,7 +125,7 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    let stability_index = stability::Index::build(krate);\n+    let stability_index = stability::Index::build(&sess, krate);\n     let tcx = ty::mk_ctxt(sess,\n                           &arenas,\n                           def_map,"}, {"sha": "17191356d3fb063a3dd656c7e20b7dd11e73c3d8", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,8 @@\n #![allow(dead_code)]\n \n #![crate_name = \"rustc_llvm\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -26,7 +27,12 @@\n #![feature(link_args)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(libc)]\n+#![feature(path)]\n+#![feature(std_misc)]\n+#![feature(hash)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "dbac2358047dfb561cad273bbc7db595961d73eb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_privacy\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -19,7 +20,9 @@\n \n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "1d9c701a16c417aa36d195f230984b3307d7be6e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_resolve\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -20,7 +21,12 @@\n #![feature(slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(alloc)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "15b9d6237ed4ce2db0041f39719d17c0269b82c1", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -911,7 +911,7 @@ fn run_work_multithreaded(sess: &Session,\n         futures.push(rx);\n \n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move |:| {\n-            let diag_handler = mk_handler(box diag_emitter);\n+            let diag_handler = mk_handler(true, box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields."}, {"sha": "bb026e237df82051b917b20a5b25ba9b1e596c1a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -15,7 +15,8 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_trans\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -29,7 +30,17 @@\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(alloc)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "c4240fa9ebae7230c5e973cede7c674a8acd1bee", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use back::link;\n use llvm::{self, ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -29,6 +29,7 @@ use trans::expr::{SaveIn, Ignore};\n use trans::expr;\n use trans::glue;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty};\n@@ -162,7 +163,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             trans_trait_callee(bcx,\n                                monomorphize_type(bcx, method_ty),\n-                               mt.real_index,\n+                               mt.vtable_index,\n                                self_expr,\n                                arg_cleanup_scope)\n         }\n@@ -439,7 +440,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   method_ty: Ty<'tcx>,\n-                                  n_method: uint,\n+                                  vtable_index: uint,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Callee<'blk, 'tcx> {\n@@ -469,28 +470,28 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         self_datum.val\n     };\n \n-    trans_trait_callee_from_llval(bcx, method_ty, n_method, llval)\n+    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llval)\n }\n \n /// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n /// pair.\n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  callee_ty: Ty<'tcx>,\n-                                                 n_method: uint,\n+                                                 vtable_index: uint,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"(translating trait callee) loading second index from pair\");\n+    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n+           callee_ty.repr(ccx.tcx()),\n+           vtable_index,\n+           bcx.val_to_string(llpair));\n     let llboxptr = GEPi(bcx, llpair, &[0u, abi::FAT_PTR_ADDR]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n-    // Load the function from the vtable and cast it to the expected type.\n-    debug!(\"(translating trait callee) loading method\");\n-\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n@@ -500,10 +501,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     output: f.sig.0.output,\n                     variadic: f.sig.0.variadic,\n                 });\n-            type_of_rust_fn(ccx,\n-                            Some(Type::i8p(ccx)),\n-                            &fake_sig,\n-                            f.abi)\n+            type_of_rust_fn(ccx, Some(Type::i8p(ccx)), &fake_sig, f.abi)\n         }\n         _ => {\n             ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n@@ -514,7 +512,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     GEPi(bcx, llpair,\n                                          &[0u, abi::FAT_PTR_EXTRA]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, n_method + VTABLE_OFFSET]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, vtable_index + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -558,7 +556,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(object_ty={}, trait_id={}, n_method={})\",\n+    debug!(\"trans_object_shim(object_ty={}, trait_id={}, method_offset_in_trait={})\",\n            object_ty.repr(tcx),\n            trait_id.repr(tcx),\n            method_offset_in_trait);\n@@ -587,7 +585,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             tcx.sess.bug(\"can't create a method shim for an associated type\")\n         }\n     };\n-    let fty = method_ty.fty.subst(tcx, &object_substs);\n+    let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n     debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n "}, {"sha": "6b6ca600a88310bed56931b48a376d359f3ef1ce", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -103,6 +103,10 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  abi: abi::Abi)\n                                  -> Type\n {\n+    debug!(\"type_of_rust_fn(sig={},abi={:?})\",\n+           sig.repr(cx.tcx()),\n+           abi);\n+\n     let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n     assert!(!sig.variadic); // rust fns are never variadic\n "}, {"sha": "6e8dd6b0ae7551740ba5410cd594cce8dd1a960e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -57,7 +57,7 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n-use util::common::ErrorReported;\n+use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n@@ -268,7 +268,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n-            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n+            convert_parenthesized_parameters(this, data)\n         }\n     };\n \n@@ -479,7 +479,9 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n \n fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n                                           data: &ast::ParenthesizedParameterData)\n-                                          -> Vec<Ty<'tcx>>\n+                                          -> (Vec<ty::Region>,\n+                                              Vec<Ty<'tcx>>,\n+                                              Vec<ConvertedBinding<'tcx>>)\n {\n     let binding_rscope = BindingRscope::new();\n     let inputs = data.inputs.iter()\n@@ -492,15 +494,26 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n \n     let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n-    let output = match data.output {\n-        Some(ref output_ty) => convert_ty_with_lifetime_elision(this,\n-                                                                implied_output_region,\n-                                                                params_lifetimes,\n-                                                                &**output_ty),\n-        None => ty::mk_nil(this.tcx()),\n+    let (output, output_span) = match data.output {\n+        Some(ref output_ty) => {\n+            (convert_ty_with_lifetime_elision(this,\n+                                              implied_output_region,\n+                                              params_lifetimes,\n+                                              &**output_ty),\n+             output_ty.span)\n+        }\n+        None => {\n+            (ty::mk_nil(this.tcx()), data.span)\n+        }\n+    };\n+\n+    let output_binding = ConvertedBinding {\n+        item_name: token::intern(FN_OUTPUT_NAME),\n+        ty: output,\n+        span: output_span\n     };\n \n-    vec![input_ty, output]\n+    (vec![], vec![input_ty], vec![output_binding])\n }\n \n pub fn instantiate_poly_trait_ref<'tcx>(\n@@ -630,7 +643,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n+            convert_parenthesized_parameters(this, data)\n         }\n     };\n "}, {"sha": "bdae34e7878504e5709d59f1288cbef36455b131", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -34,7 +34,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expected.repr(fcx.tcx()));\n \n     let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_closure_expectations_from_expected_type(fcx, ty)\n+        deduce_expectations_from_expected_type(fcx, ty)\n     });\n \n     match opt_kind {\n@@ -137,36 +137,73 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fcx.inh.closures.borrow_mut().insert(expr_def_id, closure);\n }\n \n-fn deduce_closure_expectations_from_expected_type<'a,'tcx>(\n+fn deduce_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n     -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n-            let trait_ref =\n-                object_type.principal_trait_ref_with_self_ty(fcx.tcx(),\n-                                                             fcx.tcx().types.err);\n-            deduce_closure_expectations_from_trait_ref(fcx, &trait_ref)\n+            let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n+                                                                         fcx.tcx().types.err);\n+            proj_bounds.iter()\n+                       .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n+                       .next()\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n-            deduce_closure_expectations_from_obligations(fcx, vid)\n+            deduce_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n             None\n         }\n     }\n }\n \n-fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n+fn deduce_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n-    trait_ref: &ty::PolyTraitRef<'tcx>)\n+    expected_vid: ty::TyVid)\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+{\n+    let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n+    // Here `expected_ty` is known to be a type inference variable.\n+\n+    fulfillment_cx.pending_obligations()\n+                  .iter()\n+                  .filter_map(|obligation| {\n+                      match obligation.predicate {\n+                          ty::Predicate::Projection(ref proj_predicate) => {\n+                              let trait_ref = proj_predicate.to_poly_trait_ref();\n+                              let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+                              match self_ty.sty {\n+                                  ty::ty_infer(ty::TyVar(v)) if expected_vid == v => {\n+                                      deduce_expectations_from_projection(fcx, proj_predicate)\n+                                  }\n+                                  _ => {\n+                                      None\n+                                  }\n+                              }\n+                          }\n+                          _ => {\n+                              None\n+                          }\n+                      }\n+                  })\n+                  .next()\n+}\n+\n+/// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n+/// everything we need to know about a closure.\n+fn deduce_expectations_from_projection<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    projection: &ty::PolyProjectionPredicate<'tcx>)\n     -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_closure_expectations_from_object_type({})\",\n-           trait_ref.repr(tcx));\n+    debug!(\"deduce_expectations_from_projection({})\",\n+           projection.repr(tcx));\n+\n+    let trait_ref = projection.to_poly_trait_ref();\n \n     let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n         Some(k) => k,\n@@ -185,7 +222,7 @@ fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     };\n     debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n-    let ret_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n+    let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n@@ -199,30 +236,3 @@ fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n-fn deduce_closure_expectations_from_obligations<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n-    expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n-{\n-    // Here `expected_ty` is known to be a type inference variable.\n-    for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref trait_predicate) => {\n-                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-                match self_ty.sty {\n-                    ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n-                    _ => { continue; }\n-                }\n-\n-                match deduce_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n-                    Some(e) => { return Some(e); }\n-                    None => { }\n-                }\n-            }\n-            _ => { }\n-        }\n-    }\n-\n-    None\n-}"}, {"sha": "31b14ea3f3dec8aba90473b559b4bed584afcd98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -215,14 +215,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_bounds={}\",\n            impl_bounds.repr(tcx));\n \n-    // // Normalize the associated types in the impl_bounds.\n-    // let traits::Normalized { value: impl_bounds, .. } =\n-    //     traits::normalize(&mut selcx, normalize_cause.clone(), &impl_bounds);\n-\n     // Normalize the associated types in the trait_bounds.\n     let trait_bounds = trait_m.generics.to_bounds(tcx, &trait_to_skol_substs);\n-    // let traits::Normalized { value: trait_bounds, .. } =\n-    //     traits::normalize(&mut selcx, normalize_cause, &trait_bounds);\n \n     // Obtain the predicate split predicate sets for each.\n     let trait_pred = trait_bounds.predicates.split();\n@@ -242,19 +236,18 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     );\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n-    let mut trait_param_env = impl_param_env.clone();\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    trait_param_env.caller_bounds.predicates = hybrid_preds;\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n+    let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n+                                                               normalize_cause.clone());\n \n     debug!(\"compare_impl_method: trait_bounds={}\",\n         trait_param_env.caller_bounds.repr(tcx));\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n-    let normalize_cause =\n-        traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-\n     for predicate in impl_pred.fns.into_iter() {\n         let traits::Normalized { value: predicate, .. } =\n             traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);"}, {"sha": "8188835718cd61456f7db35c5148b43dc8b7fc81", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -60,7 +60,8 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),\n            expr_ty.repr(fcx.ccx.tcx));\n-    let expected = fcx.infcx().resolve_type_vars_if_possible(&expected);\n+    let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n+    let expected = fcx.resolve_type_vars_if_possible(expected);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {"}, {"sha": "67b055ac946cc0cf56c61ddaa55ca8ea920acd8d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -206,7 +206,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n             }\n \n-            probe::ObjectPick(trait_def_id, method_num, real_index) => {\n+            probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n                 self.extract_trait_ref(self_ty, |this, object_ty, data| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -233,7 +233,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         trait_ref: upcast_trait_ref,\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n-                        real_index: real_index,\n+                        vtable_index: vtable_index,\n                     });\n                     (substs, origin)\n                 })"}, {"sha": "6a3554314e215ac3e85c3910c130a982f62dc373", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -59,7 +59,7 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* vtable index */ uint),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n@@ -318,7 +318,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let vtable_index =\n@@ -343,7 +343,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let bounds: Vec<_> =\n-            self.fcx.inh.param_env.caller_bounds.predicates\n+            self.fcx.inh.param_env.caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n@@ -365,7 +365,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(bounds.as_slice(), true, |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds.as_slice(), |this, poly_trait_ref, m, method_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n@@ -405,7 +405,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn elaborate_bounds<F>(\n         &mut self,\n         bounds: &[ty::PolyTraitRef<'tcx>],\n-        num_includes_types: bool,\n         mut mk_cand: F,\n     ) where\n         F: for<'b> FnMut(\n@@ -427,8 +426,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             let (pos, method) = match trait_method(tcx,\n                                                    bound_trait_ref.def_id(),\n-                                                   self.method_name,\n-                                                   num_includes_types) {\n+                                                   self.method_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -697,8 +695,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n-        let caller_predicates =\n-            self.fcx.inh.param_env.caller_bounds.predicates.as_slice().to_vec();\n+        let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n                           .filter_map(|p| p.to_opt_poly_trait_ref())\n                           .filter(|b| b.def_id() == trait_def_id)\n@@ -1140,19 +1137,13 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// index (or `None`, if no such method).\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n-                      method_name: ast::Name,\n-                      num_includes_types: bool)\n+                      method_name: ast::Name)\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n-        .filter(|item|\n-            num_includes_types || match *item {\n-                &ty::MethodTraitItem(_) => true,\n-                &ty::TypeTraitItem(_) => false\n-            })\n         .enumerate()\n         .find(|&(_, ref item)| item.name() == method_name)\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))"}, {"sha": "fe3d9157be48b1aa806699d2677bfef3dda66e8e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -467,7 +467,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'a, 'tcx>) {\n+                           param_env: ty::ParameterEnvironment<'a, 'tcx>)\n+{\n     match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n@@ -1242,6 +1243,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Resolves type variables in `ty` if possible. Unlike the infcx\n+    /// version, this version will also select obligations if it seems\n+    /// useful, in an effort to get more type information.\n+    fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // No ty::infer()? Nothing needs doing.\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If `ty` is a type variable, see whether we already know what it is.\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If not, try resolving any new fcx obligations that have cropped up.\n+        vtable::select_new_fcx_obligations(self);\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If not, try resolving *all* pending obligations as much as\n+        // possible. This can help substantially when there are\n+        // indirect dependencies that don't seem worth tracking\n+        // precisely.\n+        vtable::select_fcx_obligations_where_possible(self);\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n+    }\n+\n     /// Resolves all type variables in `t` and then, if any were left\n     /// unresolved, substitutes an error type. This is used after the\n     /// main checking when doing a second pass before writeback. The\n@@ -2333,9 +2364,9 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let check_blocks = *check_blocks;\n         debug!(\"check_blocks={}\", check_blocks);\n \n-        // More awful hacks: before we check the blocks, try to do\n-        // an \"opportunistic\" vtable resolution of any trait\n-        // bounds on the call.\n+        // More awful hacks: before we check argument types, try to do\n+        // an \"opportunistic\" vtable resolution of any trait bounds on\n+        // the call. This helps coercions.\n         if check_blocks {\n             vtable::select_new_fcx_obligations(fcx);\n         }\n@@ -2875,7 +2906,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n-            let rhs_ty = fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+            let rhs_ty = structurally_resolved_type(fcx, rhs.span, rhs_ty);\n             if ty::type_is_integral(rhs_ty) {\n                 fcx.write_ty(expr.id, lhs_t);\n             } else {\n@@ -5127,21 +5158,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                            mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-    // If `ty` is a type variable, see whether we already know what it is.\n-    ty = fcx.infcx().shallow_resolve(ty);\n-\n-    // If not, try resolve pending fcx obligations. Those can shed light.\n-    //\n-    // FIXME(#18391) -- This current strategy can lead to bad performance in\n-    // extreme cases.  We probably ought to smarter in general about\n-    // only resolving when we need help and only resolving obligations\n-    // will actually help.\n-    if ty::type_is_ty_var(ty) {\n-        vtable::select_fcx_obligations_where_possible(fcx);\n-        ty = fcx.infcx().shallow_resolve(ty);\n-    }\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                            sp: Span,\n+                                            ty: Ty<'tcx>)\n+                                            -> Ty<'tcx>\n+{\n+    let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n     // If not, error.\n     if ty::type_is_ty_var(ty) {"}, {"sha": "b039f3ab8e44de2b069a7a1fd08d2e0c2fb4ea0f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -1482,7 +1482,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let mut param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n                                    generic.to_ty(rcx.tcx()),\n-                                   param_env.caller_bounds.predicates.as_slice().to_vec());\n+                                   param_env.caller_bounds.clone());\n \n     // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n     match *generic {"}, {"sha": "db226295cd970f26538ddf93ee0ca89f4556402b", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -127,6 +127,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_scheme.generics);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n+                                                item.span,\n                                                 &type_scheme.generics,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);"}, {"sha": "31c9f9961260a116552ed2fa1b70cb97d05d1f7e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -64,7 +64,8 @@ This API is completely unstable and subject to change.\n */\n \n #![crate_name = \"rustc_typeck\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -79,7 +80,10 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "63ad47ff31f6115c5e7add1e0422a46b0e0508c4", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -818,6 +818,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     trait_def.generics.regions.get_slice(subst::TypeSpace),\n                     trait_ref.substs(),\n                     variance);\n+\n+                let projections = data.projection_bounds_with_self_ty(self.tcx(),\n+                                                                      self.tcx().types.err);\n+                for projection in projections.iter() {\n+                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                }\n             }\n \n             ty::ty_param(ref data) => {"}, {"sha": "d2080419469510ebec759567e5208d3b365fee22", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -32,6 +32,7 @@ use syntax::ast_util;\n use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::codemap;\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::ptr::P;\n@@ -446,11 +447,13 @@ impl attr::AttrMetaMethods for Attribute {\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+    fn span(&self) -> codemap::Span { unimplemented!() }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n     fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n+    fn span(&self) -> codemap::Span { unimplemented!() }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n@@ -533,7 +536,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n         (Some(did), Some(ref tcx)) if tcx.lang_items.fn_trait_kind(did).is_some() => {\n-            assert_eq!(types.len(), 2);\n+            assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n                 sty::ty_tup(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n@@ -544,10 +547,12 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n                     }\n                 }\n             };\n-            let output = match types[1].sty {\n-                sty::ty_tup(ref v) if v.is_empty() => None, // -> ()\n-                _ => Some(types[1].clean(cx))\n-            };\n+            let output = None;\n+            // FIXME(#20299) return type comes from a projection now\n+            // match types[1].sty {\n+            //     sty::ty_tup(ref v) if v.is_empty() => None, // -> ()\n+            //     _ => Some(types[1].clean(cx))\n+            // };\n             PathParameters::Parenthesized {\n                 inputs: inputs,\n                 output: output\n@@ -2473,15 +2478,20 @@ impl Clean<Item> for doctree::Macro {\n #[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Stability {\n     pub level: attr::StabilityLevel,\n-    pub text: String\n+    pub feature: String,\n+    pub since: String,\n+    pub reason: String\n }\n \n impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n             level: self.level,\n-            text: self.text.as_ref().map_or(\"\".to_string(),\n-                                            |interned| interned.get().to_string()),\n+            feature: self.feature.get().to_string(),\n+            since: self.since.as_ref().map_or(\"\".to_string(),\n+                                              |interned| interned.get().to_string()),\n+            reason: self.reason.as_ref().map_or(\"\".to_string(),\n+                                                |interned| interned.get().to_string()),\n         }\n     }\n }"}, {"sha": "fc3d6f5912ffb566c1a88f73001fc21551192c87", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -108,7 +108,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     };\n \n     let codemap = codemap::CodeMap::new();\n-    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None, true);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "b6db3222f3053b3c3fe0cb5eaa3207ecddab7080", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -714,7 +714,7 @@ impl<'a> fmt::Display for Stability<'a> {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level,\n-                       reason = stability.text)\n+                       reason = stability.reason)\n             }\n             None => Ok(())\n         }\n@@ -728,8 +728,8 @@ impl<'a> fmt::Display for ConciseStability<'a> {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n                        lvl = stability.level,\n-                       colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n-                       reason = stability.text)\n+                       colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n+                       reason = stability.reason)\n             }\n             None => {\n                 write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")\n@@ -765,12 +765,6 @@ impl fmt::Display for ModuleSummary {\n             try!(write!(f, \"<span class='summary Unstable' \\\n                             style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n                         (100 * cnt.unstable) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Experimental' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.experimental) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Deprecated' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.deprecated) as f64/tot as f64));\n             try!(write!(f, \"<span class='summary Unmarked' \\\n                             style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n                         (100 * cnt.unmarked) as f64/tot as f64));\n@@ -786,13 +780,11 @@ impl fmt::Display for ModuleSummary {\n         let mut context = Vec::new();\n \n         let tot = self.counts.total();\n-        let (stable, unstable, experimental, deprecated, unmarked) = if tot == 0 {\n-            (0, 0, 0, 0, 0)\n+        let (stable, unstable, unmarked) = if tot == 0 {\n+            (0, 0, 0)\n         } else {\n             ((100 * self.counts.stable)/tot,\n              (100 * self.counts.unstable)/tot,\n-             (100 * self.counts.experimental)/tot,\n-             (100 * self.counts.deprecated)/tot,\n              (100 * self.counts.unmarked)/tot)\n         };\n \n@@ -804,13 +796,11 @@ its children (percentages total for {name}):\n <blockquote>\n <a class='stability Stable'></a> stable ({}%),<br/>\n <a class='stability Unstable'></a> unstable ({}%),<br/>\n-<a class='stability Experimental'></a> experimental ({}%),<br/>\n-<a class='stability Deprecated'></a> deprecated ({}%),<br/>\n <a class='stability Unmarked'></a> unmarked ({}%)\n </blockquote>\n The counts do not include methods or trait\n implementations that are visible only through a re-exported type.\",\n-stable, unstable, experimental, deprecated, unmarked,\n+stable, unstable, unmarked,\n name=self.name));\n         try!(write!(f, \"<table>\"));\n         try!(fmt_inner(f, &mut context, self));"}, {"sha": "75812a2803c07fad4598fe01189a4b7de607aa51", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustdoc\"]\n-#![unstable]\n+#![unstable(feature = \"rustdoc\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -20,7 +21,17 @@\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(test)]\n+#![feature(unicode)]\n+#![feature(hash)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "f1d9aef7f7ce8c10b71526cacbb7248c42728fef", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -16,7 +16,7 @@\n use std::cmp::Ordering;\n use std::ops::Add;\n \n-use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n+use syntax::attr::{Unstable, Stable};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n@@ -29,12 +29,8 @@ use html::render::cache;\n /// The counts for each stability level.\n #[derive(Copy)]\n pub struct Counts {\n-    pub deprecated: uint,\n-    pub experimental: uint,\n     pub unstable: uint,\n     pub stable: uint,\n-    pub frozen: uint,\n-    pub locked: uint,\n \n     /// No stability level, inherited or otherwise.\n     pub unmarked: uint,\n@@ -45,12 +41,8 @@ impl Add for Counts {\n \n     fn add(self, other: Counts) -> Counts {\n         Counts {\n-            deprecated:   self.deprecated   + other.deprecated,\n-            experimental: self.experimental + other.experimental,\n             unstable:     self.unstable     + other.unstable,\n             stable:       self.stable       + other.stable,\n-            frozen:       self.frozen       + other.frozen,\n-            locked:       self.locked       + other.locked,\n             unmarked:     self.unmarked     + other.unmarked,\n         }\n     }\n@@ -59,19 +51,14 @@ impl Add for Counts {\n impl Counts {\n     fn zero() -> Counts {\n         Counts {\n-            deprecated:   0,\n-            experimental: 0,\n             unstable:     0,\n             stable:       0,\n-            frozen:       0,\n-            locked:       0,\n             unmarked:     0,\n         }\n     }\n \n     pub fn total(&self) -> uint {\n-        self.deprecated + self.experimental + self.unstable + self.stable +\n-            self.frozen + self.locked + self.unmarked\n+        self.unstable + self.stable + self.unmarked\n     }\n }\n \n@@ -106,14 +93,10 @@ fn visible(item: &Item) -> bool {\n \n fn count_stability(stab: Option<&Stability>) -> Counts {\n     match stab {\n-        None             => Counts { unmarked: 1,     .. Counts::zero() },\n+        None            => Counts { unmarked: 1,     .. Counts::zero() },\n         Some(ref stab) => match stab.level {\n-            Deprecated   => Counts { deprecated: 1,   .. Counts::zero() },\n-            Experimental => Counts { experimental: 1, .. Counts::zero() },\n-            Unstable     => Counts { unstable: 1,     .. Counts::zero() },\n-            Stable       => Counts { stable: 1,       .. Counts::zero() },\n-            Frozen       => Counts { frozen: 1,       .. Counts::zero() },\n-            Locked       => Counts { locked: 1,       .. Counts::zero() },\n+            Unstable    => Counts { unstable: 1,     .. Counts::zero() },\n+            Stable      => Counts { stable: 1,       .. Counts::zero() },\n         }\n     }\n }"}, {"sha": "2f692fe99cda7f61275a4f204a1fd1946bbf512b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -58,7 +58,7 @@ pub fn run(input: &str,\n     };\n \n     let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None, true);\n     let span_diagnostic_handler =\n     diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -164,7 +164,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n \n     // Compile the code\n     let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::mk_handler(box emitter);\n+    let diagnostic_handler = diagnostic::mk_handler(true, box emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "d51bb3af62728a98f929c1a37a6d6844bcf15503", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -15,7 +15,9 @@ Core encoding and decoding interfaces.\n */\n \n #![crate_name = \"serialize\"]\n-#![unstable = \"deprecated in favor of rustc-serialize on crates.io\"]\n+#![unstable(feature = \"rustc_private\",\n+            reason = \"deprecated in favor of rustc-serialize on crates.io\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -28,7 +30,14 @@ Core encoding and decoding interfaces.\n #![feature(old_impl_check)]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![cfg_attr(test, feature(test))]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "9aa38e711e70f3501b1ccd49d5e736a20e46c13e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,8 @@\n \n //! Operations on ASCII strings and characters\n \n-#![unstable = \"unsure about placement and naming\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"unsure about placement and naming\")]\n \n use iter::IteratorExt;\n use ops::FnMut;\n@@ -22,7 +23,8 @@ use string::String;\n use vec::Vec;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -36,7 +38,8 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n pub trait AsciiExt<T = Self> {\n     /// Check if within the ASCII range.\n     fn is_ascii(&self) -> bool;\n@@ -57,7 +60,8 @@ pub trait AsciiExt<T = Self> {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<String> for str {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -82,7 +86,8 @@ impl AsciiExt<String> for str {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_uppercase(self) -> String {\n@@ -97,7 +102,8 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -123,7 +129,8 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n@@ -142,7 +149,8 @@ impl OwnedAsciiExt for Vec<u8> {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for u8 {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -165,7 +173,8 @@ impl AsciiExt for u8 {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for char {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -207,7 +216,8 @@ impl AsciiExt for char {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n-#[unstable = \"needs to be updated to use an iterator\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"needs to be updated to use an iterator\")]\n pub fn escape_default<F>(c: u8, mut f: F) where\n     F: FnMut(u8),\n {"}, {"sha": "0d8b233a1697d72f264a09526e50c18f62384888", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -11,5 +11,5 @@\n //! The boolean type\n \n #![doc(primitive = \"bool\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "ae295c3e8e44239db67514754b788bf96e2a2790", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -296,7 +296,7 @@ fn test_resize_policy() {\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hash_state: S,\n@@ -499,7 +499,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n@@ -513,7 +513,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n         HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n@@ -539,7 +539,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n             hash_state:    hash_state,\n@@ -567,7 +567,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n@@ -591,7 +591,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n@@ -611,7 +611,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n@@ -723,7 +723,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.shrink_to_fit();\n     /// assert!(map.capacity() >= 2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let min_capacity = self.resize_policy.min_capacity(self.len());\n         let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n@@ -817,7 +817,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n@@ -842,7 +842,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n@@ -867,7 +867,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter { inner: self.table.iter() }\n     }\n@@ -895,7 +895,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut { inner: self.table.iter_mut() }\n     }\n@@ -917,7 +917,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n@@ -928,7 +928,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[unstable = \"precise API still being fleshed out\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"precise API still being fleshed out\")]\n     pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n         // Gotta resize now.\n@@ -950,7 +951,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Returns true if the map contains no elements.\n@@ -966,7 +967,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n@@ -989,7 +990,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n@@ -1012,7 +1014,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -1034,7 +1036,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1057,7 +1059,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1083,7 +1085,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1106,7 +1108,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n@@ -1135,7 +1137,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1208,14 +1210,14 @@ impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Eq for HashMap<K, V, S>\n     where K: Eq + Hash<H>, V: Eq,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Debug for HashMap<K, V, S>\n     where K: Eq + Hash<H> + Debug, V: Debug,\n           S: HashState<Hasher=H>,\n@@ -1233,7 +1235,7 @@ impl<K, V, S, H> Debug for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Default for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1244,7 +1246,7 @@ impl<K, V, S, H> Default for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1259,7 +1261,7 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1275,7 +1277,7 @@ impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n }\n \n /// HashMap iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n }\n@@ -1290,13 +1292,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n }\n \n /// HashMap mutable values iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1307,7 +1309,7 @@ pub struct IntoIter<K, V> {\n }\n \n /// HashMap keys iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n@@ -1322,7 +1324,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n }\n \n /// HashMap values iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -1337,7 +1339,8 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n }\n \n /// HashMap drain iterator.\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1348,21 +1351,24 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single occupied location in a HashMap.\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single empty location in a HashMap.\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n     Occupied(OccupiedEntry<'a, K, V>),\n@@ -1379,79 +1385,80 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> Entry<'a, K, V> {\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n@@ -1462,7 +1469,8 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n     pub fn get(&self) -> &V {\n@@ -1493,7 +1501,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n@@ -1509,7 +1518,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1524,7 +1533,7 @@ impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1545,13 +1554,15 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n #[allow(missing_copy_implementations)]\n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n pub struct RandomState {\n     k0: u64,\n     k1: u64,\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl RandomState {\n     /// Construct a new `RandomState` that is initialized with random keys.\n     #[inline]\n@@ -1561,15 +1572,17 @@ impl RandomState {\n     }\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n     type Hasher = Hasher;\n     fn hasher(&self) -> Hasher {\n         Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n     }\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl Default for RandomState {\n     #[inline]\n     fn default() -> RandomState {"}, {"sha": "84f01f70c3e885b722b5af6252e058b172dc7d1b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -90,7 +90,7 @@ use super::state::HashState;\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n     map: HashMap<T, (), S>\n }\n@@ -105,7 +105,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -120,7 +120,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -147,7 +147,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n         HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n@@ -171,7 +171,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n@@ -189,7 +189,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert!(set.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.map.capacity()\n     }\n@@ -209,7 +209,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.map.reserve(additional)\n     }\n@@ -230,7 +230,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.shrink_to_fit();\n     /// assert!(set.capacity() >= 2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.map.shrink_to_fit()\n     }\n@@ -251,7 +251,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -276,7 +276,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first;\n@@ -306,7 +306,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference {\n             iter: self.iter(),\n@@ -334,7 +334,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n         -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n@@ -357,7 +357,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         Intersection {\n             iter: self.iter(),\n@@ -382,7 +382,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n@@ -399,7 +399,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -414,12 +414,13 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -439,7 +440,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -457,7 +458,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n@@ -481,7 +482,7 @@ impl<T, S, H> HashSet<T, S>\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -502,7 +503,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -527,7 +528,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n         other.is_subset(self)\n     }\n@@ -546,7 +547,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -567,15 +568,15 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> PartialEq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -588,14 +589,14 @@ impl<T, S, H> PartialEq for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Eq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> fmt::Debug for HashSet<T, S>\n     where T: Eq + Hash<H> + fmt::Debug,\n           S: HashState<Hasher=H>,\n@@ -613,7 +614,7 @@ impl<T, S, H> fmt::Debug for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -627,7 +628,7 @@ impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -640,19 +641,19 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Default for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n           H: hash::Hasher<Output=u64>\n {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> HashSet<T, S> {\n         HashSet::with_hash_state(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -685,7 +686,7 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -718,7 +719,7 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -751,7 +752,7 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -785,25 +786,25 @@ impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n /// HashSet iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>\n }\n \n /// HashSet move iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n     iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n     iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -812,7 +813,7 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n }\n \n /// Difference iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -821,54 +822,54 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n }\n \n /// Symmetric difference iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n     iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n }\n \n /// Set union iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -893,7 +894,7 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -918,7 +919,7 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -930,7 +931,7 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Union<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "9e6a45d8bf0b5877fa3ae8159d83d61e8b120cb8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -629,7 +629,6 @@ impl<K, V> RawTable<K, V> {\n \n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n-    #[allow(unstable)]\n     pub fn new(capacity: uint) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);"}, {"sha": "0c55850b32a2dd5d689bd21914e173fb36728059", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -359,7 +359,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n@@ -373,21 +373,21 @@ pub use self::hash_set::HashSet;\n \n mod hash;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_map {\n     //! A hashmap\n     pub use super::hash::map::*;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;\n }\n \n /// Experimental support for providing custom hash algorithms to a HashMap and\n /// HashSet.\n-#[unstable = \"module was recently added\"]\n+#[unstable(feature = \"std_misc\", reason = \"module was recently added\")]\n pub mod hash_state {\n     pub use super::hash::state::*;\n }"}, {"sha": "f35f63143ef8275cdeab063398d4da89c16e0adf", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -12,7 +12,7 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n #![allow(missing_docs)]\n \n use prelude::v1::*;"}, {"sha": "c184d3f4661f16e519ae356771f5d7b824e14b4a", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use prelude::v1::*;\n "}, {"sha": "fdd7aa216d3c0edc9c84711a0de71353856ee5ca", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -119,7 +119,7 @@ impl Deref for CString {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for CString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         String::from_utf8_lossy(self.as_bytes()).fmt(f)"}, {"sha": "69ada28a4b4a456ba05b452591d163d1e7c53fa4", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,8 +10,9 @@\n \n //! Utilities related to FFI bindings.\n \n-#![unstable = \"module just underwent fairly large reorganization and the dust \\\n-               still needs to settle\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"module just underwent fairly large reorganization and the dust \\\n+                      still needs to settle\")]\n \n pub use self::c_str::CString;\n pub use self::c_str::c_str_to_bytes;"}, {"sha": "8fdc5547e46b106994600555fab427c74b8f8eaa", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -29,7 +29,8 @@\n //! for conversion to/from various other string types. Eventually these types\n //! will offer a full-fledged string API.\n \n-#![unstable = \"recently added as part of path/io reform\"]\n+#![unstable(feature = \"os\",\n+            reason = \"recently added as part of path/io reform\")]\n \n use core::prelude::*;\n "}, {"sha": "4ab43e875cdffad9d8033bbf50e7c95e43b4f719", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -401,7 +401,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use string;\n \n@@ -431,8 +431,9 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[unstable = \"this is an implementation detail of format! and should not \\\n-                  be called directly\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"this is an implementation detail of format! and should not \\\n+                     be called directly\")]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();\n     let _ = write!(&mut output, \"{}\", args);"}, {"sha": "3a745389e1e719f83d8d7159c864efe4275b5c1e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -96,7 +96,8 @@\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -114,7 +115,14 @@\n #![feature(optin_builtin_traits)]\n #![feature(int_uint)]\n #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(core)]\n+#![feature(libc)]\n+#![feature(alloc)]\n+#![feature(unicode)]\n+#![feature(collections)]\n+#![feature(rand)]\n+#![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -177,7 +185,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core_collections::vec;\n \n pub use unicode::char;"}, {"sha": "9c3285a9d0890b701300603b0599a45100b8035c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -14,7 +14,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -36,7 +36,7 @@\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n@@ -71,15 +71,15 @@ macro_rules! panic {\n /// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n     ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n }\n \n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! print {\n     ($($arg:tt)*) => ($crate::old_io::stdio::print_args(format_args!($($arg)*)))\n }\n@@ -97,7 +97,7 @@ macro_rules! print {\n /// println!(\"format {} arguments\", \"some\");\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! println {\n     ($($arg:tt)*) => ($crate::old_io::stdio::println_args(format_args!($($arg)*)))\n }\n@@ -106,7 +106,7 @@ macro_rules! println {\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! try {\n     ($expr:expr) => (match $expr {\n         $crate::result::Result::Ok(val) => val,\n@@ -148,7 +148,7 @@ macro_rules! try {\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n-#[unstable]\n+#[unstable(feature = \"std_misc\")]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+"}, {"sha": "9b5b0e62a3c1a7a141e4f965b867371ce36da187", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n@@ -73,7 +73,7 @@ mod cmath {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { num::Float::nan() }\n@@ -366,7 +366,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -379,7 +379,7 @@ pub fn to_string(num: f32) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -394,7 +394,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -407,7 +407,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -422,7 +422,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -438,7 +438,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -454,7 +454,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "1c9558325292b207fb98bda6639c113dcb99b52f", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2b730cd6f9ad81e8755db53e25b420bbef9b1643", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "498f19b9b8307f3d45a68c90ff3d4a5d216276b2", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "aea1e92117bb0f315e0f414b1ccf000584135543", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "43794345fe7a4ebcd9b2b88ed2263ae2efa3f2b3", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1b03bf6f4f0097c7b8cb9e20c9ee1a1b74051355", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "669952eee3924a8bb81e94cd953a16ca965cdc77", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "af1976d5750932db4eb3d5187a2db2f778dfecc7", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "7fb2cd81ababf2dbfc44f0722f3f31e781446df2", "filename": "src/libstd/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fisize.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "dad8b70ceacdf7fce72daca57d971dc72fea7b73", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 103, "deletions": 72, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3fda77fb69c402ecd739b28811687f1517006bbc", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "8610f0c01473f8887d0938ed68d39243991b310b", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3587b06965624930b38cf0976a19b3e5e2c481e0", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "6a285e8299c1eccbb437558866da2881c2a5b7b2", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "c7b491381f337abca0b65054bfdaa8b620469cd9", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "82c55d7b5b83c43df529cdea4fa88a9fe078fc81", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "19964c306a79bbcc08bdf8047ae23e96be9e8a89", "filename": "src/libstd/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fusize.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1590598c0b8a76a5d7993c4bc1168cf896c078a1", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "feb2ef6f4f3ca1d94bba0ad555e7d47b27032f93", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "254daf3202a9e2cb1ff3b10157574192a65d41fc", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "6c5ce129a33cf9fab28e193c78429a39da236646", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "e60b455aecda6cce7b763942bfc10342aa5e08d1", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "71b77adcd964de8b7ce2af065dcb68dd8c2ece2b", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1e76bb3ab0dffa4f60a7a441bb924b6d8afae5a0", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "9055a089eec7f3fde3e672338172dfcfd7b17db4", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "78910882467290789c5c3bb7b6702ad0032f60bc", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "979a61d20d5c7018d38590d89bcf72f16a87a522", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "b42353e964c511993cd2d89612ca502632ca6a61", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "39138e148032b96f5527e78fcb81a73ea8b63a9b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "34faa65af75a199851c3f1f2a5b2b5672fa4dc3c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "09fa10dacf98c2807a7186165d6692415dbc2074", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "51c9f9de83cc88e7fc210550665c7629186c7342", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "0a6dc386edf25d816e8d003399b5c2dc75e414fc", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "7e19f1cac2c5bf5a0c74c7d25e3f0823061ba086", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "18298f1c7f4f5ac3c5dd8e0d1d6e6ffceddd34dd", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "06b6816248709abc66379bda43b11f596e103767", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "40710d627c0ec3df6f4562d7d1b29a1f591f5a17", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a7a5b084582caafa6df03953be83e079dbdf0051", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a79fb684f477036b861258463ed78ce0e5c0a845", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "f3b721438d807a2872f2fa706e441ebc2df3a3f2", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "322c6137984abf27762cee60c2bff0bec0cc83da", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "c222c313ba6864748a50882d5d91a011e458c83e", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "e97c82a5b1b027122a8d36416bea597b9e566e35", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "c1983fcab194de1a614641e3834ca1eed5411608", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "f7fdd60eb8cb7e117731f39efc6620f626d9f245", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1c489540581824aeb4ce66dd1c3d7845d2de4830", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "18680b96592ce3b9589de4b0a5f7b863bb36def5", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "12befbf72e37e4d3f377f308ba91a9a64612ebc4", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "0304b898884ccb2e47cfa0d11faf0484dac82c25", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3fac998d3e72d0e52452e45e9845da74687bbd55", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "4a82b2807e7a3c914ab58c220fb694b1c04dc33c", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a3bbf5c5fe795d5c3c3c42abef13178884d90369", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "c19ec8ea25c641db80f09634b9a799b7a5ec2000", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2a9bf452329cd636cf438340d0bb361b494ec849", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1a20612d60a8475b2072de79a0856719d4899cf5", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2e53d0ceecbdfc0b00b1602d34d9b06ca43afd37", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "fdd9cbdccf515e175aab6ba43417f6998ba26d5c", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2a911557765b5b9949f0bda1831e4fd98882af17", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2c3ddcd9d4947188f937401a07ff3a01801fc8e0", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "4dada5bc81ec23f96fb65529c23d9652236c63c8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "061600d9420f5c3c89cf7b6361ed0494a6ae866a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 127, "deletions": 29, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "f3e6689731656c5b46b800896bc8f074b1d585ef", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "dd89153d497100ab190c34d349a6bc6182dddf5a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "9d5be3fff61a60ee81ca8f5efe7617e5d0b15943", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "666281ac6b61060bb4c31f1a37fb38361f969982", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "6e797844c18c0b3cb3008ab32564553b74a64edc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 106, "deletions": 77, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a1362f5382c979b4f3864039181f5e7e2fd5e434", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "ff4c7b565cbbe469375cac7706eb8b0bf8882c4a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "99be1b11b11cbc6ee2137a7b21e1b00c3dfa3fc3", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "4bd476885a04cecd1b7f06ce05e4e79bf0e7c046", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "4c1ae532d13cdb151064ff0eabfe4400fb92f8e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a7679adca2e178eeca05d954605132af0d2fdb50", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "21a7d6808475142edeab13ee9684c01c520e30df", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "aa3af76d46c1b7397b3842cc216b8101936af65c", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "43a1bbd6c02ce2937d0efb8fec1090625263000e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "02f738c9d29e1c2e50437e2d7252c31b2541e8e0", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "467fed5d246706ede73c6b98a6e0398311bb2c6d", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "b4bafe31ff24a4c702b9e07c00b8f4086eed02e8", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3e571bad09ca43dd62c42f560ae5f37809b18d44", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "77eb82f80228649965299a2e1be76ffe26a84a03", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1977e2aad285e902350eb498f1c632fdd8748cf2", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3679557d06bb761b7f69424b0dc9e5c715163197", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 74, "deletions": 79, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3a92cf59611cf95f105382c64b05e0445e14954d", "filename": "src/test/auxiliary/stability_cfg1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "d9ed76e5c58e766ba8fbe7a4ad3ac718e5bd95ef", "filename": "src/test/auxiliary/stability_cfg2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "0bd69b73214c9b6f2209b5c141a49a26e439c6a4", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "b388b6a28e340a30eb714d28ef0dc7757b1ed8e9", "filename": "src/test/compile-fail/associated-type-projection-from-supertrait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "55ba65d6102bee85f1d5c20db8fb9407c98598a2", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "04d73cc36f04cb2fd1d23945973a45c0a0aebd1c", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "c65b2366bf10f7360f69e167aa453f57e18bb4d9", "filename": "src/test/compile-fail/enable-unstable-lib-feature.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "db3373ea02772285a8300795963091b2e992609b", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "9923db3c56636ad25accf1e3032652cace5b9faa", "filename": "src/test/compile-fail/fail-no-dead-code-core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "e5e5ddadafccf8014d09b675f53a1b093c896e4c", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-manual-impls.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "460e05c8438cde27612d43a109ee762b1026e1c7", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "977586483b031568c4f2ef08230daa3975b35aad", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "ff640793afe01f314662a9a26310baad8505fdc4", "filename": "src/test/compile-fail/issue-17337.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "84800218efc9402065b41f21860d6fa1fb5a854c", "filename": "src/test/compile-fail/issue-17545.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a8804a6df061a5297900bbb11d970b7c2a8296cd", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "f3b2b3d5667a398bbb85b4f925fc56335770f475", "filename": "src/test/compile-fail/issue-18400.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "9f0e81a662f55c38a0190140a8a623ceb498c89b", "filename": "src/test/compile-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "5f0f0fc05a929372e32b797533f81630d35a64ef", "filename": "src/test/compile-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "45b7fbbd0b46a614b28d85b0292ea34911616d5e", "filename": "src/test/compile-fail/issue-21160.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "fefd432e22982c66c47b60f5d8ffdf56311c053b", "filename": "src/test/compile-fail/issue-21356.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-21356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fissue-21356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21356.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3f25e9c7b76aac34ea92298574f4584b3faf16c2", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "dc59194373124a9c70b0b99af684b384d0956a5d", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "be135978d2dad3b1aba763429954e0db391b4546", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "22570bad616963c3cfca4da05c7510c2bfc5d86d", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "98853a2e9a119948669b9bf9bf985d4d82dcabe4", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "fcc8fb6f933bda47e52bf96a7e30f48a7bc7f5ae", "filename": "src/test/compile-fail/lint-forbid-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "be927297be7b2a800ee0a949cf552e929c9134a8", "filename": "src/test/compile-fail/lint-forbid-cmdline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "ec4e3c774dbf02d9e9aae57ef8b42788513cfdba", "filename": "src/test/compile-fail/lint-output-format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "5b093a8556cdd112f16300bf7dd4d099ca11440f", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 114, "deletions": 221, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "d5e9cc630c359eb1a7a6e6525d371fb53ce93d92", "filename": "src/test/compile-fail/lint-unknown-feature-default.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "ac1720b339e8412087645dfdbf03ab47ee968200", "filename": "src/test/compile-fail/lint-unknown-feature.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "03bb7cc1f15e049091b6916e637260703e3ccf6f", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "057b8e3acc6e37224fbdab11cd4211cbc59a8d7a", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "4a3f7e9cad972b9f8b564ce87b04849e42f9e172", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "5b781a40fe5482258c20e3abf3b689b9ba8ce3f4", "filename": "src/test/compile-fail/missing_debug_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "61752e62abdefe90e80100478f48b9f6c5246bba", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "41ecf7146138dbb8d7ba1503a4d02ce0fe608977", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2a246124f6f9d5163eadf2b3d0960baa3ec266c2", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "901ae1d5e2ab1584e6d3053ee7d36942be4c019d", "filename": "src/test/compile-fail/shift-various-bad-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "f028c9af46235647a0fbe65c47fdbf8dd169fe63", "filename": "src/test/compile-fail/simd-binop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "e6acc32545178734bb080c908b3bca3b7c24de0d", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "dcbb1880b1089da7de0a85b896226e9cb8963962", "filename": "src/test/compile-fail/stability-attribute-sanity.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "53d687b5cfefe16f6649abb6bfb3f42ddb2c60c1", "filename": "src/test/compile-fail/staged_api.rs", "status": "renamed", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fstaged_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fstaged_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstaged_api.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57", "previous_filename": "src/test/compile-fail/simd-experimental.rs"}, {"sha": "2e29a61846edafaaaa3a39d267235564489860b3", "filename": "src/test/compile-fail/traits-multidispatch-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "3536244f011654d482dc5f8544e5f01fa7e1a796", "filename": "src/test/compile-fail/unboxed-closure-feature-gate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "870377bc1add760e811680f0e3e4740bbe549d6d", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "dc5576aee650a56ed814b9bbcd9abc09d5f24723", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "d2f781bba11eaa3d30d8c5121d05480a90540425", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "1f0d5aae36db5abaefa64597eff7537312522474", "filename": "src/test/compile-fail/unboxed-closure-sugar-not-used-on-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "75688e44e80761c2758012316a6cb6e655602c8f", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "a3991a87b78f8a1caa47891adc7c43c2c5d3f4ee", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct-1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "ad85cdcaa03a15246be7261f407f6ab69ce5b4d9", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "c9837da58e75a1d4a86801075a806d1c873199bf", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "e63f510b890d7902d248e491a2cb43097f291404", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "bbafd5109edff0b25cbdf00b3ecfae7dd42b280d", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "23f7ee2b0101d78cca2d2db9fcaa4702ac8e33bd", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "305dd33e5a05a950b03280e36cc29675ff027a6b", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "96619bef36fd5fb400deeec4c343351183b7e74a", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "ebcbdbbc006df83585ba4d02dad8817285a1109d", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "2ada0dd22e75f4a160cdbc28aa8972a451b6cac5", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "50217ff9e5dc6c37826c05e35b4f11c58778a8bf", "filename": "src/test/compile-fail/unused-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-attr.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}, {"sha": "972ec96f5f27ba0dece011768f6358d95b8bb02a", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c709ed2faf4ea28df1395a924453b5298b87fa57/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=c709ed2faf4ea28df1395a924453b5298b87fa57"}]}