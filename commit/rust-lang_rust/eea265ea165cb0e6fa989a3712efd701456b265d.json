{"sha": "eea265ea165cb0e6fa989a3712efd701456b265d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYTI2NWVhMTY1Y2IwZTZmYTk4OWEzNzEyZWZkNzAxNDU2YjI2NWQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-17T10:10:26Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-21T14:02:37Z"}, "message": "syntax/ext: Remove the trait-object indirection of the ext_ctxt object.", "tree": {"sha": "d58658faa37d8e44303fe3eff65040417a46cbdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d58658faa37d8e44303fe3eff65040417a46cbdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eea265ea165cb0e6fa989a3712efd701456b265d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eea265ea165cb0e6fa989a3712efd701456b265d", "html_url": "https://github.com/rust-lang/rust/commit/eea265ea165cb0e6fa989a3712efd701456b265d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eea265ea165cb0e6fa989a3712efd701456b265d/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e9eba8013490e7b6ba059397bbe73b7128c04b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9eba8013490e7b6ba059397bbe73b7128c04b3", "html_url": "https://github.com/rust-lang/rust/commit/8e9eba8013490e7b6ba059397bbe73b7128c04b3"}], "stats": {"total": 188, "additions": 82, "deletions": 106}, "files": [{"sha": "b387694c6c191320c02e7480d686955e5ec0d1e9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 82, "deletions": 106, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/eea265ea165cb0e6fa989a3712efd701456b265d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea265ea165cb0e6fa989a3712efd701456b265d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=eea265ea165cb0e6fa989a3712efd701456b265d", "patch": "@@ -202,131 +202,107 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n-pub trait ext_ctxt {\n-    fn codemap(&self) -> @CodeMap;\n-    fn parse_sess(&self) -> @mut parse::ParseSess;\n-    fn cfg(&self) -> ast::crate_cfg;\n-    fn call_site(&self) -> span;\n-    fn print_backtrace(&self);\n-    fn backtrace(&self) -> Option<@ExpnInfo>;\n-    fn mod_push(&self, mod_name: ast::ident);\n-    fn mod_pop(&self);\n-    fn mod_path(&self) -> ~[ast::ident];\n-    fn bt_push(&self, ei: codemap::ExpnInfo);\n-    fn bt_pop(&self);\n-    fn span_fatal(&self, sp: span, msg: &str) -> !;\n-    fn span_err(&self, sp: span, msg: &str);\n-    fn span_warn(&self, sp: span, msg: &str);\n-    fn span_unimpl(&self, sp: span, msg: &str) -> !;\n-    fn span_bug(&self, sp: span, msg: &str) -> !;\n-    fn bug(&self, msg: &str) -> !;\n-    fn next_id(&self) -> ast::node_id;\n-    fn trace_macros(&self) -> bool;\n-    fn set_trace_macros(&self, x: bool);\n-    /* for unhygienic identifier transformation */\n-    fn str_of(&self, id: ast::ident) -> ~str;\n-    fn ident_of(&self, st: &str) -> ast::ident;\n+pub struct ext_ctxt {\n+    parse_sess: @mut parse::ParseSess,\n+    cfg: ast::crate_cfg,\n+    backtrace: @mut Option<@ExpnInfo>,\n+\n+    // These two @mut's should really not be here,\n+    // but the self types for CtxtRepr are all wrong\n+    // and there are bugs in the code for object\n+    // types that make this hard to get right at the\n+    // moment. - nmatsakis\n+    mod_path: @mut ~[ast::ident],\n+    trace_mac: @mut bool\n }\n \n-pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n-            -> @ext_ctxt {\n-    struct CtxtRepr {\n-        parse_sess: @mut parse::ParseSess,\n-        cfg: ast::crate_cfg,\n-        backtrace: @mut Option<@ExpnInfo>,\n-\n-        // These two @mut's should really not be here,\n-        // but the self types for CtxtRepr are all wrong\n-        // and there are bugs in the code for object\n-        // types that make this hard to get right at the\n-        // moment. - nmatsakis\n-        mod_path: @mut ~[ast::ident],\n-        trace_mac: @mut bool\n-    }\n-    impl ext_ctxt for CtxtRepr {\n-        fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n-        fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n-        fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n-        fn call_site(&self) -> span {\n-            match *self.backtrace {\n-                Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n-                None => self.bug(\"missing top span\")\n-            }\n+pub impl ext_ctxt {\n+    fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n+    fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n+    fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n+    fn call_site(&self) -> span {\n+        match *self.backtrace {\n+            Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n+            None => self.bug(\"missing top span\")\n         }\n-        fn print_backtrace(&self) { }\n-        fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n-        fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n-        fn mod_pop(&self) { self.mod_path.pop(); }\n-        fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n-        fn bt_push(&self, ei: codemap::ExpnInfo) {\n-            match ei {\n-              ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n+    }\n+    fn print_backtrace(&self) { }\n+    fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n+    fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n+    fn mod_pop(&self) { self.mod_path.pop(); }\n+    fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n+    fn bt_push(&self, ei: codemap::ExpnInfo) {\n+        match ei {\n+            ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n                     Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n                         callee: copy *callee}));\n-              }\n             }\n         }\n-        fn bt_pop(&self) {\n-            match *self.backtrace {\n-              Some(@ExpandedFrom(CallInfo {\n-                  call_site: span {expn_info: prev, _}, _\n-              })) => {\n+    }\n+    fn bt_pop(&self) {\n+        match *self.backtrace {\n+            Some(@ExpandedFrom(\n+                CallInfo {\n+                    call_site: span {expn_info: prev, _}, _\n+                })) => {\n                 *self.backtrace = prev\n-              }\n-              _ => self.bug(\"tried to pop without a push\")\n             }\n-        }\n-        fn span_fatal(&self, sp: span, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n-        }\n-        fn span_err(&self, sp: span, msg: &str) {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_err(sp, msg);\n-        }\n-        fn span_warn(&self, sp: span, msg: &str) {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_warn(sp, msg);\n-        }\n-        fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n-        }\n-        fn span_bug(&self, sp: span, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.span_bug(sp, msg);\n-        }\n-        fn bug(&self, msg: &str) -> ! {\n-            self.print_backtrace();\n-            self.parse_sess.span_diagnostic.handler().bug(msg);\n-        }\n-        fn next_id(&self) -> ast::node_id {\n-            return parse::next_node_id(self.parse_sess);\n-        }\n-        fn trace_macros(&self) -> bool {\n-            *self.trace_mac\n-        }\n-        fn set_trace_macros(&self, x: bool) {\n-            *self.trace_mac = x\n-        }\n-        fn str_of(&self, id: ast::ident) -> ~str {\n-            copy *self.parse_sess.interner.get(id)\n-        }\n-        fn ident_of(&self, st: &str) -> ast::ident {\n-            self.parse_sess.interner.intern(st)\n+            _ => self.bug(\"tried to pop without a push\")\n         }\n     }\n-    let imp: @CtxtRepr = @CtxtRepr {\n+    fn span_fatal(&self, sp: span, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n+    }\n+    fn span_err(&self, sp: span, msg: &str) {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_err(sp, msg);\n+    }\n+    fn span_warn(&self, sp: span, msg: &str) {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_warn(sp, msg);\n+    }\n+    fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n+    }\n+    fn span_bug(&self, sp: span, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.span_bug(sp, msg);\n+    }\n+    fn bug(&self, msg: &str) -> ! {\n+        self.print_backtrace();\n+        self.parse_sess.span_diagnostic.handler().bug(msg);\n+    }\n+    fn next_id(&self) -> ast::node_id {\n+        parse::next_node_id(self.parse_sess)\n+    }\n+    fn trace_macros(&self) -> bool {\n+        *self.trace_mac\n+    }\n+    fn set_trace_macros(&self, x: bool) {\n+        *self.trace_mac = x\n+    }\n+    fn str_of(&self, id: ast::ident) -> ~str {\n+        copy *self.parse_sess.interner.get(id)\n+    }\n+    fn ident_of(&self, st: &str) -> ast::ident {\n+        self.parse_sess.interner.intern(st)\n+    }\n+}\n+\n+pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n+    -> @ext_ctxt {\n+    @ext_ctxt {\n         parse_sess: parse_sess,\n         cfg: cfg,\n         backtrace: @mut None,\n         mod_path: @mut ~[],\n         trace_mac: @mut false\n-    };\n-    ((imp) as @ext_ctxt)\n+    }\n }\n \n pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {"}]}