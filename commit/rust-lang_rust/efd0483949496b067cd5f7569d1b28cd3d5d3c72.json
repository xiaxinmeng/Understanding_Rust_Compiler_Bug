{"sha": "efd0483949496b067cd5f7569d1b28cd3d5d3c72", "node_id": "C_kwDOAAsO6NoAKGVmZDA0ODM5NDk0OTZiMDY3Y2Q1Zjc1NjlkMWIyOGNkM2Q1ZDNjNzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-20T17:57:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-20T17:57:35Z"}, "message": "Auto merge of #89978 - cjgillot:qarray, r=Mark-Simulacrum\n\nMerge the two depkind vtables\n\nKnowledge of `DepKind`s is managed using two arrays containing flags (is_anon, eval_always, fingerprint_style), and function pointers (forcing and loading code).\n\nThis PR aims at merging the two arrays so as to reduce unneeded indirect calls and (hopefully) increase code locality.\nr? `@ghost`", "tree": {"sha": "08d6811d9ded63416e9b93fce99f8ca865bfab23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08d6811d9ded63416e9b93fce99f8ca865bfab23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efd0483949496b067cd5f7569d1b28cd3d5d3c72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efd0483949496b067cd5f7569d1b28cd3d5d3c72", "html_url": "https://github.com/rust-lang/rust/commit/efd0483949496b067cd5f7569d1b28cd3d5d3c72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efd0483949496b067cd5f7569d1b28cd3d5d3c72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d71e749a244890cd370d49963e747cf92f4a037", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d71e749a244890cd370d49963e747cf92f4a037", "html_url": "https://github.com/rust-lang/rust/commit/3d71e749a244890cd370d49963e747cf92f4a037"}, {"sha": "b11ec29e2828fe4d3df9d78c57f0e548a594991f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b11ec29e2828fe4d3df9d78c57f0e548a594991f", "html_url": "https://github.com/rust-lang/rust/commit/b11ec29e2828fe4d3df9d78c57f0e548a594991f"}], "stats": {"total": 958, "additions": 420, "deletions": 538}, "files": [{"sha": "8385f1a18e5cd86a5a5cafaae67bc3f36a840df0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -4319,7 +4319,6 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"tracing\",\n ]\n \n [[package]]"}, {"sha": "0a8d6122aa7a79bf4ec870df31498ec93ba9cd16", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -224,7 +224,7 @@ pub(crate) fn run_aot(\n                     tcx,\n                     (backend_config.clone(), cgu.name()),\n                     module_codegen,\n-                    rustc_middle::dep_graph::hash_result,\n+                    Some(rustc_middle::dep_graph::hash_result),\n                 );\n \n                 if let Some((id, product)) = work_product {"}, {"sha": "a3b8d328388e0d5154dc88fd667b177b504d1b2c", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -59,7 +59,13 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n-    let (module, _) = tcx.dep_graph.with_task(dep_node, tcx, cgu_name, module_codegen, dep_graph::hash_result);\n+    let (module, _) = tcx.dep_graph.with_task(\n+        dep_node,\n+        tcx,\n+        cgu_name,\n+        module_codegen,\n+        Some(dep_graph::hash_result),\n+    );\n     let time_to_codegen = start_time.elapsed();\n     drop(prof_timer);\n "}, {"sha": "8766caef6e37946dafc18feb684dbb8da749e37e", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -113,8 +113,13 @@ pub fn compile_codegen_unit(\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n-    let (module, _) =\n-        tcx.dep_graph.with_task(dep_node, tcx, cgu_name, module_codegen, dep_graph::hash_result);\n+    let (module, _) = tcx.dep_graph.with_task(\n+        dep_node,\n+        tcx,\n+        cgu_name,\n+        module_codegen,\n+        Some(dep_graph::hash_result),\n+    );\n     let time_to_codegen = start_time.elapsed();\n \n     // We assume that the cost to run LLVM on a CGU is proportional to"}, {"sha": "571337a8dcbc6a3e2ec3ad13acdb56cfac8996f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -126,30 +126,36 @@ impl IfThisChanged<'tcx> {\n             if attr.has_name(sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    None => DepNode::from_def_path_hash(def_path_hash, DepKind::hir_owner),\n-                    Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {\n-                        Ok(n) => n,\n-                        Err(()) => {\n-                            self.tcx.sess.span_fatal(\n-                                attr.span,\n-                                &format!(\"unrecognized DepNode variant {:?}\", n),\n-                            );\n+                    None => {\n+                        DepNode::from_def_path_hash(self.tcx, def_path_hash, DepKind::hir_owner)\n+                    }\n+                    Some(n) => {\n+                        match DepNode::from_label_string(self.tcx, &n.as_str(), def_path_hash) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n+                                );\n+                            }\n                         }\n-                    },\n+                    }\n                 };\n                 self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n             } else if attr.has_name(sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {\n-                        Ok(n) => n,\n-                        Err(()) => {\n-                            self.tcx.sess.span_fatal(\n-                                attr.span,\n-                                &format!(\"unrecognized DepNode variant {:?}\", n),\n-                            );\n+                    Some(n) => {\n+                        match DepNode::from_label_string(self.tcx, &n.as_str(), def_path_hash) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n+                                );\n+                            }\n                         }\n-                    },\n+                    }\n                     None => {\n                         self.tcx.sess.span_fatal(attr.span, \"missing DepNode variant\");\n                     }"}, {"sha": "b2eaf61b7d14560912011fcea60ed46f8723e739", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -15,7 +15,7 @@\n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node as HirNode;\n@@ -302,18 +302,6 @@ impl DirtyCleanVisitor<'tcx> {\n         out\n     }\n \n-    fn dep_nodes<'l>(\n-        &self,\n-        labels: &'l Labels,\n-        def_id: DefId,\n-    ) -> impl Iterator<Item = DepNode> + 'l {\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n-        labels.iter().map(move |label| match DepNode::from_label_string(label, def_path_hash) {\n-            Ok(dep_node) => dep_node,\n-            Err(()) => unreachable!(\"label: {}\", label),\n-        })\n-    }\n-\n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n         if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n             format!(\"{:?}({})\", dep_node.kind, self.tcx.def_path_str(def_id))\n@@ -345,16 +333,19 @@ impl DirtyCleanVisitor<'tcx> {\n     }\n \n     fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n+        let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n         for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n                 None => continue,\n             };\n             self.checked_attrs.insert(attr.id);\n-            for dep_node in self.dep_nodes(&assertion.clean, item_id.to_def_id()) {\n+            for label in assertion.clean {\n+                let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_clean(item_span, dep_node);\n             }\n-            for dep_node in self.dep_nodes(&assertion.dirty, item_id.to_def_id()) {\n+            for label in assertion.dirty {\n+                let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_dirty(item_span, dep_node);\n             }\n         }"}, {"sha": "eea320835685cd5066039057601fd3a6f7b4fb08", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -838,6 +838,7 @@ pub fn create_global_ctxt<'tcx>(\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n                 queries.as_dyn(),\n+                rustc_query_impl::query_callbacks(arena),\n                 crate_name,\n                 outputs,\n             )"}, {"sha": "420c500a7de22e427e34a3eb4f68795ba799c0ec", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -100,6 +100,8 @@ macro_rules! arena_types {\n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n             [decode] span: rustc_span::Span,\n             [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n+\n+            [] dep_kind: rustc_middle::dep_graph::DepKindStruct,\n         ], $tcx);\n     )\n }"}, {"sha": "f3100010770307a08e1168547bd4c3d1082880d5", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 81, "deletions": 143, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -75,145 +75,71 @@ pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n /// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n /// jump table instead of large matches.\n pub struct DepKindStruct {\n-    /// Whether the DepNode has parameters (query keys).\n-    pub(super) has_params: bool,\n-\n     /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n     /// When their result is needed, it is recomputed. They are useful for fine-grained\n     /// dependency tracking, and caching within one compiler invocation.\n-    pub(super) is_anon: bool,\n+    pub is_anon: bool,\n \n     /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n     /// their inputs have not changed since the last compiler invocation. The result is still\n     /// cached within one compiler invocation.\n-    pub(super) is_eval_always: bool,\n+    pub is_eval_always: bool,\n \n     /// Whether the query key can be recovered from the hashed fingerprint.\n     /// See [DepNodeParams] trait for the behaviour of each key type.\n-    // FIXME: Make this a simple boolean once DepNodeParams::fingerprint_style\n-    // can be made a specialized associated const.\n-    fingerprint_style: fn() -> FingerprintStyle,\n-}\n-\n-impl std::ops::Deref for DepKind {\n-    type Target = DepKindStruct;\n-    fn deref(&self) -> &DepKindStruct {\n-        &DEP_KINDS[*self as usize]\n-    }\n+    pub fingerprint_style: FingerprintStyle,\n+\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    pub force_from_dep_node: Option<fn(tcx: TyCtxt<'_>, dep_node: DepNode) -> bool>,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub try_load_from_on_disk_cache: Option<fn(TyCtxt<'_>, DepNode)>,\n }\n \n impl DepKind {\n     #[inline(always)]\n-    pub fn fingerprint_style(&self) -> FingerprintStyle {\n+    pub fn fingerprint_style(self, tcx: TyCtxt<'_>) -> FingerprintStyle {\n         // Only fetch the DepKindStruct once.\n-        let data: &DepKindStruct = &**self;\n+        let data = tcx.query_kind(self);\n         if data.is_anon {\n             return FingerprintStyle::Opaque;\n         }\n-\n-        (data.fingerprint_style)()\n-    }\n-}\n-\n-// erase!() just makes tokens go away. It's used to specify which macro argument\n-// is repeated (i.e., which sub-expression of the macro we are in) but don't need\n-// to actually use any of the arguments.\n-macro_rules! erase {\n-    ($x:tt) => {{}};\n-}\n-\n-macro_rules! is_anon_attr {\n-    (anon) => {\n-        true\n-    };\n-    ($attr:ident) => {\n-        false\n-    };\n-}\n-\n-macro_rules! is_eval_always_attr {\n-    (eval_always) => {\n-        true\n-    };\n-    ($attr:ident) => {\n-        false\n-    };\n-}\n-\n-macro_rules! contains_anon_attr {\n-    ($(($attr:ident $($attr_args:tt)* )),*) => ({$(is_anon_attr!($attr) | )* false});\n-}\n-\n-macro_rules! contains_eval_always_attr {\n-    ($(($attr:ident $($attr_args:tt)* )),*) => ({$(is_eval_always_attr!($attr) | )* false});\n-}\n-\n-#[allow(non_upper_case_globals)]\n-pub mod dep_kind {\n-    use super::*;\n-    use crate::ty::query::query_keys;\n-    use rustc_query_system::dep_graph::FingerprintStyle;\n-\n-    // We use this for most things when incr. comp. is turned off.\n-    pub const Null: DepKindStruct = DepKindStruct {\n-        has_params: false,\n-        is_anon: false,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Unit,\n-    };\n-\n-    pub const TraitSelect: DepKindStruct = DepKindStruct {\n-        has_params: false,\n-        is_anon: true,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Unit,\n-    };\n-\n-    pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n-        has_params: true,\n-        is_anon: false,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Opaque,\n-    };\n-\n-    pub const CompileMonoItem: DepKindStruct = DepKindStruct {\n-        has_params: true,\n-        is_anon: false,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Opaque,\n-    };\n-\n-    macro_rules! define_query_dep_kinds {\n-        ($(\n-            [$($attrs:tt)*]\n-            $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n-        ,)*) => (\n-            $(pub const $variant: DepKindStruct = {\n-                const has_params: bool = $({ erase!($tuple_arg_ty); true } |)* false;\n-                const is_anon: bool = contains_anon_attr!($($attrs)*);\n-                const is_eval_always: bool = contains_eval_always_attr!($($attrs)*);\n-\n-                #[inline(always)]\n-                fn fingerprint_style() -> rustc_query_system::dep_graph::FingerprintStyle {\n-                    <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>\n-                        ::fingerprint_style()\n-                }\n-\n-                DepKindStruct {\n-                    has_params,\n-                    is_anon,\n-                    is_eval_always,\n-                    fingerprint_style,\n-                }\n-            };)*\n-        );\n+        data.fingerprint_style\n     }\n-\n-    rustc_dep_node_append!([define_query_dep_kinds!][]);\n }\n \n macro_rules! define_dep_nodes {\n@@ -225,12 +151,10 @@ macro_rules! define_dep_nodes {\n     ) => (\n         #[macro_export]\n         macro_rules! make_dep_kind_array {\n-            ($mod:ident) => {[ $(($mod::$variant),)* ]};\n+            ($mod:ident) => {[ $($mod::$variant()),* ]};\n         }\n \n-        static DEP_KINDS: &[DepKindStruct] = &make_dep_kind_array!(dep_kind);\n-\n-        /// This enum serves as an index into the `DEP_KINDS` array.\n+        /// This enum serves as an index into arrays built by `make_dep_kind_array`.\n         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n         #[allow(non_camel_case_types)]\n         pub enum DepKind {\n@@ -296,7 +220,7 @@ pub trait DepNodeExt: Sized {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+    fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> Self;\n \n     /// Extracts the DefId corresponding to this DepNode. This will work\n     /// if two conditions are met:\n@@ -311,7 +235,11 @@ pub trait DepNodeExt: Sized {\n     fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n \n     /// Used in testing\n-    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<Self, ()>;\n+    fn from_label_string(\n+        tcx: TyCtxt<'_>,\n+        label: &str,\n+        def_path_hash: DefPathHash,\n+    ) -> Result<Self, ()>;\n \n     /// Used in testing\n     fn has_label_string(label: &str) -> bool;\n@@ -321,8 +249,8 @@ impl DepNodeExt for DepNode {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n-        debug_assert!(kind.fingerprint_style() == FingerprintStyle::DefPathHash);\n+    fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n+        debug_assert!(kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash);\n         DepNode { kind, hash: def_path_hash.0.into() }\n     }\n \n@@ -337,31 +265,27 @@ impl DepNodeExt for DepNode {\n     /// refers to something from the previous compilation session that\n     /// has been removed.\n     fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n-        if self.kind.fingerprint_style() == FingerprintStyle::DefPathHash {\n-            Some(\n-                tcx.on_disk_cache\n-                    .as_ref()?\n-                    .def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into())),\n-            )\n+        if self.kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash {\n+            Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into())))\n         } else {\n             None\n         }\n     }\n \n     /// Used in testing\n-    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n+    fn from_label_string(\n+        tcx: TyCtxt<'_>,\n+        label: &str,\n+        def_path_hash: DefPathHash,\n+    ) -> Result<DepNode, ()> {\n         let kind = dep_kind_from_label_string(label)?;\n \n-        match kind.fingerprint_style() {\n+        match kind.fingerprint_style(tcx) {\n             FingerprintStyle::Opaque => Err(()),\n-            FingerprintStyle::Unit => {\n-                if !kind.has_params {\n-                    Ok(DepNode::new_no_params(kind))\n-                } else {\n-                    Err(())\n-                }\n+            FingerprintStyle::Unit => Ok(DepNode::new_no_params(tcx, kind)),\n+            FingerprintStyle::DefPathHash => {\n+                Ok(DepNode::from_def_path_hash(tcx, def_path_hash, kind))\n             }\n-            FingerprintStyle::DefPathHash => Ok(DepNode::from_def_path_hash(def_path_hash, kind)),\n         }\n     }\n \n@@ -377,10 +301,12 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for () {\n         FingerprintStyle::Unit\n     }\n \n+    #[inline(always)]\n     fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n         Fingerprint::ZERO\n     }\n \n+    #[inline(always)]\n     fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n         Some(())\n     }\n@@ -392,14 +318,17 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n         FingerprintStyle::DefPathHash\n     }\n \n+    #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n+    #[inline(always)]\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n \n+    #[inline(always)]\n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx)\n     }\n@@ -411,14 +340,17 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n         FingerprintStyle::DefPathHash\n     }\n \n+    #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         self.to_def_id().to_fingerprint(tcx)\n     }\n \n+    #[inline(always)]\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         self.to_def_id().to_debug_str(tcx)\n     }\n \n+    #[inline(always)]\n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.expect_local())\n     }\n@@ -430,15 +362,18 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n         FingerprintStyle::DefPathHash\n     }\n \n+    #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         def_id.to_fingerprint(tcx)\n     }\n \n+    #[inline(always)]\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.crate_name(*self).to_string()\n     }\n \n+    #[inline(always)]\n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.krate)\n     }\n@@ -453,6 +388,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n+    #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let (def_id_0, def_id_1) = *self;\n \n@@ -462,6 +398,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n         def_path_hash_0.0.combine(def_path_hash_1.0)\n     }\n \n+    #[inline(always)]\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         let (def_id_0, def_id_1) = *self;\n \n@@ -478,6 +415,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n+    #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n "}, {"sha": "79d7ca32f35553ba9e525404bd5b7f0cdda71e67", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 49, "deletions": 23, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -12,7 +12,7 @@ pub use rustc_query_system::dep_graph::{\n     SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n-pub use dep_node::{label_strs, DepKind, DepNode, DepNodeExt};\n+pub use dep_node::{label_strs, DepKind, DepKindStruct, DepNode, DepNodeExt};\n crate use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n@@ -24,29 +24,8 @@ pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;\n \n-    #[inline(always)]\n-    fn fingerprint_style(&self) -> rustc_query_system::dep_graph::FingerprintStyle {\n-        DepKind::fingerprint_style(self)\n-    }\n-\n-    #[inline(always)]\n-    fn is_eval_always(&self) -> bool {\n-        self.is_eval_always\n-    }\n-\n-    #[inline(always)]\n-    fn has_params(&self) -> bool {\n-        self.has_params\n-    }\n-\n     fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"{:?}\", node.kind)?;\n-\n-        if !node.kind.has_params && !node.kind.is_anon {\n-            return Ok(());\n-        }\n-\n-        write!(f, \"(\")?;\n+        write!(f, \"{:?}(\", node.kind)?;\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n@@ -110,4 +89,51 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     fn sess(&self) -> &Session {\n         self.sess\n     }\n+\n+    #[inline(always)]\n+    fn fingerprint_style(&self, kind: DepKind) -> rustc_query_system::dep_graph::FingerprintStyle {\n+        kind.fingerprint_style(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn is_eval_always(&self, kind: DepKind) -> bool {\n+        self.query_kind(kind).is_eval_always\n+    }\n+\n+    fn try_force_from_dep_node(&self, dep_node: DepNode) -> bool {\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            dep_node.kind != DepKind::codegen_unit,\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        let cb = self.query_kind(dep_node.kind);\n+        if let Some(f) = cb.force_from_dep_node {\n+            f(*self, dep_node);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn try_load_from_on_disk_cache(&self, dep_node: DepNode) {\n+        let cb = self.query_kind(dep_node.kind);\n+        if let Some(f) = cb.try_load_from_on_disk_cache {\n+            f(*self, dep_node)\n+        }\n+    }\n }"}, {"sha": "8240273acad4cd89eb1bcabfff4defc8dbf00cf7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n+use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n@@ -79,11 +79,6 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     where\n         Self: Sized;\n \n-    /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n-    /// session, if it still exists. This is used during incremental compilation to\n-    /// turn a deserialized `DefPathHash` into its current `DefId`.\n-    fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, def_path_hash: DefPathHash) -> DefId;\n-\n     fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>);\n \n     fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n@@ -1016,6 +1011,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n+    query_kinds: &'tcx [DepKindStruct],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n     pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -1149,6 +1145,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n+        query_kinds: &'tcx [DepKindStruct],\n         crate_name: &str,\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n@@ -1175,6 +1172,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n+            query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n@@ -1188,6 +1186,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    crate fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n+        &self.query_kinds[k as usize]\n+    }\n+\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n     pub fn ty_error(self) -> Ty<'tcx> {\n@@ -1301,6 +1303,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n+    /// session, if it still exists. This is used during incremental compilation to\n+    /// turn a deserialized `DefPathHash` into its current `DefId`.\n+    pub fn def_path_hash_to_def_id(self, hash: DefPathHash) -> DefId {\n+        debug!(\"def_path_hash_to_def_id({:?})\", hash);\n+\n+        let stable_crate_id = hash.stable_crate_id();\n+\n+        // If this is a DefPathHash from the local crate, we can look up the\n+        // DefId in the tcx's `Definitions`.\n+        if stable_crate_id == self.sess.local_stable_crate_id() {\n+            self.untracked_resolutions.definitions.local_def_path_hash_to_def_id(hash).to_def_id()\n+        } else {\n+            // If this is a DefPathHash from an upstream crate, let the CrateStore map\n+            // it to a DefId.\n+            let cstore = &self.untracked_resolutions.cstore;\n+            let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n+            cstore.def_path_hash_to_def_id(cnum, hash)\n+        }\n+    }\n+\n     pub fn def_path_debug_str(self, def_id: DefId) -> String {\n         // We are explicitly not going through queries here in order to get\n         // crate name and stable crate id since this code is called from debug!()"}, {"sha": "6c1175ebdb4ee8b60115d25d15a2114eff8652e9", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -102,6 +102,10 @@ impl TyCtxt<'tcx> {\n     }\n }\n \n+/// Helper for `TyCtxtEnsure` to avoid a closure.\n+#[inline(always)]\n+fn noop<T>(_: &T) {}\n+\n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n     ($K:ty) => { $K };\n@@ -165,7 +169,7 @@ macro_rules! define_callbacks {\n             #[inline(always)]\n             pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n                 let key = key.into_query_param();\n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |_| {});\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, noop);\n \n                 let lookup = match cached {\n                     Ok(()) => return,\n@@ -192,9 +196,7 @@ macro_rules! define_callbacks {\n             pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n             {\n                 let key = key.into_query_param();\n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |value| {\n-                    value.clone()\n-                });\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, Clone::clone);\n \n                 let lookup = match cached {\n                     Ok(value) => return value,"}, {"sha": "f984bb1872b2842ea21538bd86a57566c4ceed6a", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -9,7 +9,6 @@ doctest = false\n [dependencies]\n measureme = \"10.0.0\"\n rustc-rayon-core = \"0.3.1\"\n-tracing = \"0.1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "b216d78da945cd64921bd0f27571c5720b1f0bbf", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -13,13 +13,12 @@\n extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n-#[macro_use]\n-extern crate tracing;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::DiagnosticBuilder;\n-use rustc_middle::dep_graph;\n+use rustc_middle::arena::Arena;\n+use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{Providers, QueryEngine};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -29,7 +28,6 @@ use rustc_span::Span;\n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n-use plumbing::QueryStruct;\n use rustc_query_system::query::*;\n \n mod stats;"}, {"sha": "86b12b3586a9be142dbd58c27ee34a191dd1f8e7", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -219,7 +219,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n         // loading existing queries may cause us to create new DepNodes, which\n         // may in turn end up invoking `store_foreign_def_id_hash`\n-        tcx.dep_graph.exec_cache_promotions(QueryCtxt::from_tcx(tcx));\n+        tcx.dep_graph.exec_cache_promotions(tcx);\n \n         *self.serialized_data.write() = None;\n     }\n@@ -358,23 +358,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             Ok(())\n         })\n     }\n-\n-    fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, hash: DefPathHash) -> DefId {\n-        debug!(\"def_path_hash_to_def_id({:?})\", hash);\n-\n-        let stable_crate_id = hash.stable_crate_id();\n-\n-        // If this is a DefPathHash from the local crate, we can look up the\n-        // DefId in the tcx's `Definitions`.\n-        if stable_crate_id == tcx.sess.local_stable_crate_id() {\n-            tcx.definitions_untracked().local_def_path_hash_to_def_id(hash).to_def_id()\n-        } else {\n-            // If this is a DefPathHash from an upstream crate, let the CrateStore map\n-            // it to a DefId.\n-            let cnum = tcx.cstore_untracked().stable_crate_id_to_crate_num(stable_crate_id);\n-            tcx.cstore_untracked().def_path_hash_to_def_id(cnum, hash)\n-        }\n-    }\n }\n \n impl<'sess> OnDiskCache<'sess> {\n@@ -764,7 +747,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // If we get to this point, then all of the query inputs were green,\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n-        Ok(d.tcx().on_disk_cache.as_ref().unwrap().def_path_hash_to_def_id(d.tcx(), def_path_hash))\n+        Ok(d.tcx().def_path_hash_to_def_id(def_path_hash))\n     }\n }\n "}, {"sha": "8c3fbb2071c043e46f2e93e7ccbdb745950ad3a6", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 82, "deletions": 139, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -3,7 +3,7 @@\n //! manage the caches, and so forth.\n \n use crate::{on_disk_cache, queries, Queries};\n-use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{DepKind, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n@@ -53,36 +53,6 @@ impl QueryContext for QueryCtxt<'tcx> {\n         self.queries.try_collect_active_jobs(**self)\n     }\n \n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n-        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n-        (cb.try_load_from_on_disk_cache)(*self, dep_node)\n-    }\n-\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n-        // We must avoid ever having to call `force_from_dep_node()` for a\n-        // `DepNode::codegen_unit`:\n-        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-        // would always end up having to evaluate the first caller of the\n-        // `codegen_unit` query that *is* reconstructible. This might very well be\n-        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-        // to re-trigger calling the `codegen_unit` query with the right key. At\n-        // that point we would already have re-done all the work we are trying to\n-        // avoid doing in the first place.\n-        // The solution is simple: Just explicitly call the `codegen_unit` query for\n-        // each CGU, right after partitioning. This way `try_mark_green` will always\n-        // hit the cache instead of having to go through `force_from_dep_node`.\n-        // This assertion makes sure, we actually keep applying the solution above.\n-        debug_assert!(\n-            dep_node.kind != DepKind::codegen_unit,\n-            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-        );\n-\n-        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n-        (cb.force_from_dep_node)(*self, dep_node)\n-    }\n-\n     // Interactions with on_disk_cache\n     fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects {\n         self.queries\n@@ -193,60 +163,6 @@ impl<'tcx> QueryCtxt<'tcx> {\n     }\n }\n \n-/// This struct stores metadata about each Query.\n-///\n-/// Information is retrieved by indexing the `QUERIES` array using the integer value\n-/// of the `DepKind`. Overall, this allows to implement `QueryContext` using this manual\n-/// jump table instead of large matches.\n-pub struct QueryStruct {\n-    /// The red/green evaluation system will try to mark a specific DepNode in the\n-    /// dependency graph as green by recursively trying to mark the dependencies of\n-    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-    /// where we don't know if it is red or green and we therefore actually have\n-    /// to recompute its value in order to find out. Since the only piece of\n-    /// information that we have at that point is the `DepNode` we are trying to\n-    /// re-evaluate, we need some way to re-run a query from just that. This is what\n-    /// `force_from_dep_node()` implements.\n-    ///\n-    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-    /// is usually constructed by computing a stable hash of the query-key that the\n-    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-    /// back from hash to query-key (since hash functions are not reversible). For\n-    /// this reason `force_from_dep_node()` is expected to fail from time to time\n-    /// because we just cannot find out, from the `DepNode` alone, what the\n-    /// corresponding query-key is and therefore cannot re-run the query.\n-    ///\n-    /// The system deals with this case letting `try_mark_green` fail which forces\n-    /// the root query to be re-evaluated.\n-    ///\n-    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-    /// Fortunately, we can use some contextual information that will allow us to\n-    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n-    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-    /// everything we need to re-run the query.\n-    ///\n-    /// Take the `mir_promoted` query as an example. Like many other queries, it\n-    /// just has a single parameter: the `DefId` of the item it will compute the\n-    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    ///\n-    /// When you implement a new query, it will likely have a corresponding new\n-    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-    /// add it to the \"We don't have enough information to reconstruct...\" group in\n-    /// the match below.\n-    pub(crate) force_from_dep_node: fn(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool,\n-\n-    /// Invoke a query to put the on-disk cached value in memory.\n-    pub(crate) try_load_from_on_disk_cache: fn(QueryCtxt<'_>, &DepNode),\n-}\n-\n macro_rules! handle_cycle_error {\n     ([][$tcx: expr, $error:expr]) => {{\n         $error.emit();\n@@ -291,14 +207,14 @@ macro_rules! is_eval_always {\n }\n \n macro_rules! hash_result {\n-    ([][$hcx:expr, $result:expr]) => {{\n-        dep_graph::hash_result($hcx, &$result)\n+    ([]) => {{\n+        Some(dep_graph::hash_result)\n     }};\n-    ([(no_hash) $($rest:tt)*][$hcx:expr, $result:expr]) => {{\n+    ([(no_hash) $($rest:tt)*]) => {{\n         None\n     }};\n-    ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n-        hash_result!([$($modifiers)*][$($args)*])\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        hash_result!([$($modifiers)*])\n     };\n }\n \n@@ -378,6 +294,7 @@ macro_rules! define_queries {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n             const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$name;\n+            const HASH_RESULT: Option<fn(&mut StableHashingContext<'_>, &Self::Value) -> Fingerprint> = hash_result!([$($modifiers)*]);\n \n             type Cache = query_storage::$name<$tcx>;\n \n@@ -406,13 +323,6 @@ macro_rules! define_queries {\n                 }\n             }\n \n-            fn hash_result(\n-                _hcx: &mut StableHashingContext<'_>,\n-                _result: &Self::Value\n-            ) -> Option<Fingerprint> {\n-                hash_result!([$($modifiers)*][_hcx, _result])\n-            }\n-\n             fn handle_cycle_error(\n                 tcx: QueryCtxt<'tcx>,\n                 mut error: DiagnosticBuilder<'_>,\n@@ -421,7 +331,7 @@ macro_rules! define_queries {\n             }\n         })*\n \n-        #[allow(non_upper_case_globals)]\n+        #[allow(nonstandard_style)]\n         pub mod query_callbacks {\n             use super::*;\n             use rustc_middle::dep_graph::DepNode;\n@@ -431,68 +341,101 @@ macro_rules! define_queries {\n             use rustc_query_system::dep_graph::FingerprintStyle;\n \n             // We use this for most things when incr. comp. is turned off.\n-            pub const Null: QueryStruct = QueryStruct {\n-                force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+            pub fn Null() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Unit,\n+                    force_from_dep_node: Some(|_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node)),\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-            pub const TraitSelect: QueryStruct = QueryStruct {\n-                force_from_dep_node: |_, _| false,\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+            pub fn TraitSelect() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: true,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Unit,\n+                    force_from_dep_node: None,\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-            pub const CompileCodegenUnit: QueryStruct = QueryStruct {\n-                force_from_dep_node: |_, _| false,\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+            pub fn CompileCodegenUnit() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Opaque,\n+                    force_from_dep_node: None,\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-            pub const CompileMonoItem: QueryStruct = QueryStruct {\n-                force_from_dep_node: |_, _| false,\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+            pub fn CompileMonoItem() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Opaque,\n+                    force_from_dep_node: None,\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-            $(pub const $name: QueryStruct = {\n-                const is_anon: bool = is_anon!([$($modifiers)*]);\n+            $(pub fn $name()-> DepKindStruct {\n+                let is_anon = is_anon!([$($modifiers)*]);\n+                let is_eval_always = is_eval_always!([$($modifiers)*]);\n \n-                #[inline(always)]\n-                fn fingerprint_style() -> FingerprintStyle {\n-                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>\n-                        ::fingerprint_style()\n-                }\n+                let fingerprint_style =\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::fingerprint_style();\n \n-                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$name<'tcx>> {\n-                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n+                if is_anon || !fingerprint_style.reconstructible() {\n+                    return DepKindStruct {\n+                        is_anon,\n+                        is_eval_always,\n+                        fingerprint_style,\n+                        force_from_dep_node: None,\n+                        try_load_from_on_disk_cache: None,\n+                    }\n                 }\n \n-                fn force_from_dep_node(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool {\n-                    force_query::<queries::$name<'_>, _>(tcx, dep_node)\n+                #[inline(always)]\n+                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> Option<query_keys::$name<'tcx>> {\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, &dep_node)\n                 }\n \n-                fn try_load_from_on_disk_cache(tcx: QueryCtxt<'_>, dep_node: &DepNode) {\n-                    if is_anon {\n-                        return\n-                    }\n-\n-                    if !fingerprint_style().reconstructible() {\n-                        return\n+                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: DepNode) -> bool {\n+                    if let Some(key) = recover(tcx, dep_node) {\n+                        let tcx = QueryCtxt::from_tcx(tcx);\n+                        force_query::<queries::$name<'_>, _>(tcx, key, dep_node);\n+                        true\n+                    } else {\n+                        false\n                     }\n+                }\n \n-                    debug_assert!(tcx.dep_graph.is_green(dep_node));\n+                fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: DepNode) {\n+                    debug_assert!(tcx.dep_graph.is_green(&dep_node));\n \n-                    let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n+                    let key = recover(tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n+                    let tcx = QueryCtxt::from_tcx(tcx);\n                     if queries::$name::cache_on_disk(tcx, &key, None) {\n                         let _ = tcx.$name(key);\n                     }\n                 }\n \n-                QueryStruct {\n-                    force_from_dep_node,\n-                    try_load_from_on_disk_cache,\n+                DepKindStruct {\n+                    is_anon,\n+                    is_eval_always,\n+                    fingerprint_style,\n+                    force_from_dep_node: Some(force_from_dep_node),\n+                    try_load_from_on_disk_cache: Some(try_load_from_on_disk_cache),\n                 }\n-            };)*\n+            })*\n         }\n \n-        static QUERY_CALLBACKS: &[QueryStruct] = &make_dep_kind_array!(query_callbacks);\n+        pub fn query_callbacks<'tcx>(arena: &'tcx Arena<'tcx>) -> &'tcx [DepKindStruct] {\n+            arena.alloc_from_iter(make_dep_kind_array!(query_callbacks))\n+        }\n     }\n }\n "}, {"sha": "c274c2cc26c157008ee9b7eec3d207564cfd385c", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -60,8 +60,11 @@ impl<K: DepKind> DepNode<K> {\n     /// Creates a new, parameterless DepNode. This method will assert\n     /// that the DepNode corresponding to the given DepKind actually\n     /// does not require any parameters.\n-    pub fn new_no_params(kind: K) -> DepNode<K> {\n-        debug_assert!(!kind.has_params());\n+    pub fn new_no_params<Ctxt>(tcx: Ctxt, kind: K) -> DepNode<K>\n+    where\n+        Ctxt: super::DepContext<DepKind = K>,\n+    {\n+        debug_assert_eq!(tcx.fingerprint_style(kind), FingerprintStyle::Unit);\n         DepNode { kind, hash: Fingerprint::ZERO.into() }\n     }\n \n@@ -75,7 +78,7 @@ impl<K: DepKind> DepNode<K> {\n \n         #[cfg(debug_assertions)]\n         {\n-            if !kind.fingerprint_style().reconstructible()\n+            if !tcx.fingerprint_style(kind).reconstructible()\n                 && (tcx.sess().opts.debugging_opts.incremental_info\n                     || tcx.sess().opts.debugging_opts.query_dep_graph)\n             {\n@@ -121,11 +124,12 @@ impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n where\n     T: for<'a> HashStable<StableHashingContext<'a>> + fmt::Debug,\n {\n-    #[inline]\n+    #[inline(always)]\n     default fn fingerprint_style() -> FingerprintStyle {\n         FingerprintStyle::Opaque\n     }\n \n+    #[inline(always)]\n     default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n@@ -135,10 +139,12 @@ where\n         hasher.finish()\n     }\n \n+    #[inline(always)]\n     default fn to_debug_str(&self, _: Ctxt) -> String {\n         format!(\"{:?}\", *self)\n     }\n \n+    #[inline(always)]\n     default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n         None\n     }"}, {"sha": "a8be1ca34c04f0f0e8cd59a8777d90e15a6eae13", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -33,12 +33,6 @@ pub struct DepGraph<K: DepKind> {\n     /// each task has a `DepNodeIndex` that uniquely identifies it. This unique\n     /// ID is used for self-profiling.\n     virtual_dep_node_index: Lrc<AtomicU32>,\n-\n-    /// The cached event id for profiling node interning. This saves us\n-    /// from having to look up the event id every time we intern a node\n-    /// which may incur too much overhead.\n-    /// This will be None if self-profiling is disabled.\n-    node_intern_event_id: Option<EventId>,\n }\n \n rustc_index::newtype_index! {\n@@ -96,14 +90,13 @@ struct DepGraphData<K: DepKind> {\n     dep_node_debug: Lock<FxHashMap<DepNode<K>, String>>,\n }\n \n-pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Fingerprint\n where\n     R: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let mut stable_hasher = StableHasher::new();\n     result.hash_stable(hcx, &mut stable_hasher);\n-\n-    Some(stable_hasher.finish())\n+    stable_hasher.finish()\n }\n \n impl<K: DepKind> DepGraph<K> {\n@@ -117,8 +110,13 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n-        let current =\n-            CurrentDepGraph::new(prev_graph_node_count, encoder, record_graph, record_stats);\n+        let current = CurrentDepGraph::new(\n+            profiler,\n+            prev_graph_node_count,\n+            encoder,\n+            record_graph,\n+            record_stats,\n+        );\n \n         // Instantiate a dependy-less node only once for anonymous queries.\n         let _green_node_index = current.intern_new_node(\n@@ -129,10 +127,6 @@ impl<K: DepKind> DepGraph<K> {\n         );\n         debug_assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n \n-        let node_intern_event_id = profiler\n-            .get_or_alloc_cached_string(\"incr_comp_intern_dep_graph_node\")\n-            .map(EventId::from_label);\n-\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n@@ -143,16 +137,11 @@ impl<K: DepKind> DepGraph<K> {\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n             })),\n             virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n-            node_intern_event_id,\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph<K> {\n-        DepGraph {\n-            data: None,\n-            virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n-            node_intern_event_id: None,\n-        }\n+        DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n     /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n@@ -215,7 +204,7 @@ impl<K: DepKind> DepGraph<K> {\n         cx: Ctxt,\n         arg: A,\n         task: fn(Ctxt, A) -> R,\n-        hash_result: fn(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n         if self.is_fully_enabled() {\n             self.with_task_impl(key, cx, arg, task, hash_result)\n@@ -234,7 +223,7 @@ impl<K: DepKind> DepGraph<K> {\n         cx: Ctxt,\n         arg: A,\n         task: fn(Ctxt, A) -> R,\n-        hash_result: fn(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n         // This function is only called when the graph is enabled.\n         let data = self.data.as_ref().unwrap();\n@@ -253,7 +242,7 @@ impl<K: DepKind> DepGraph<K> {\n             key\n         );\n \n-        let task_deps = if key.kind.is_eval_always() {\n+        let task_deps = if cx.dep_context().is_eval_always(key.kind) {\n             None\n         } else {\n             Some(Lock::new(TaskDeps {\n@@ -268,15 +257,14 @@ impl<K: DepKind> DepGraph<K> {\n         let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n         let dcx = cx.dep_context();\n-        let mut hcx = dcx.create_stable_hashing_context();\n         let hashing_timer = dcx.profiler().incr_result_hashing();\n-        let current_fingerprint = hash_result(&mut hcx, &result);\n+        let current_fingerprint = hash_result.map(|f| {\n+            let mut hcx = dcx.create_stable_hashing_context();\n+            f(&mut hcx, &result)\n+        });\n \n         let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n-        // Get timer for profiling `DepNode` interning\n-        let node_intern_timer =\n-            self.node_intern_event_id.map(|eid| dcx.profiler().generic_activity_with_event_id(eid));\n         // Intern the new `DepNode`.\n         let (dep_node_index, prev_and_color) = data.current.intern_node(\n             dcx.profiler(),\n@@ -286,7 +274,6 @@ impl<K: DepKind> DepGraph<K> {\n             current_fingerprint,\n             print_status,\n         );\n-        drop(node_intern_timer);\n \n         hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -315,7 +302,7 @@ impl<K: DepKind> DepGraph<K> {\n     where\n         OP: FnOnce() -> R,\n     {\n-        debug_assert!(!dep_kind.is_eval_always());\n+        debug_assert!(!cx.is_eval_always(dep_kind));\n \n         if let Some(ref data) = self.data {\n             let task_deps = Lock::new(TaskDeps::default());\n@@ -492,7 +479,7 @@ impl<K: DepKind> DepGraph<K> {\n         tcx: Ctxt,\n         dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n-        debug_assert!(!dep_node.kind.is_eval_always());\n+        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n \n         // Return None if the dep graph is disabled\n         let data = self.data.as_ref()?;\n@@ -552,7 +539,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // We don't know the state of this dependency. If it isn't\n         // an eval_always node, let's try to mark it green recursively.\n-        if !dep_dep_node.kind.is_eval_always() {\n+        if !tcx.dep_context().is_eval_always(dep_dep_node.kind) {\n             debug!(\n                 \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n                                  is unknown, trying to mark it green\",\n@@ -575,7 +562,7 @@ impl<K: DepKind> DepGraph<K> {\n             \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n             dep_node, dep_dep_node\n         );\n-        if !tcx.try_force_from_dep_node(dep_dep_node) {\n+        if !tcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n             // The DepNode could not be forced.\n             debug!(\n                 \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n@@ -642,7 +629,7 @@ impl<K: DepKind> DepGraph<K> {\n         }\n \n         // We never try to mark eval_always nodes as green\n-        debug_assert!(!dep_node.kind.is_eval_always());\n+        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n \n         debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n@@ -740,16 +727,15 @@ impl<K: DepKind> DepGraph<K> {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<Ctxt: QueryContext<DepKind = K>>(&self, qcx: Ctxt) {\n-        let tcx = qcx.dep_context();\n+    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    qcx.try_load_from_on_disk_cache(&dep_node);\n+                    tcx.try_load_from_on_disk_cache(dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked\n@@ -876,10 +862,17 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     /// debugging and only active with `debug_assertions`.\n     total_read_count: AtomicU64,\n     total_duplicate_read_count: AtomicU64,\n+\n+    /// The cached event id for profiling node interning. This saves us\n+    /// from having to look up the event id every time we intern a node\n+    /// which may incur too much overhead.\n+    /// This will be None if self-profiling is disabled.\n+    node_intern_event_id: Option<EventId>,\n }\n \n impl<K: DepKind> CurrentDepGraph<K> {\n     fn new(\n+        profiler: &SelfProfilerRef,\n         prev_graph_node_count: usize,\n         encoder: FileEncoder,\n         record_graph: bool,\n@@ -908,6 +901,10 @@ impl<K: DepKind> CurrentDepGraph<K> {\n \n         let new_node_count_estimate = 102 * prev_graph_node_count / 100 + 200;\n \n+        let node_intern_event_id = profiler\n+            .get_or_alloc_cached_string(\"incr_comp_intern_dep_graph_node\")\n+            .map(EventId::from_label);\n+\n         CurrentDepGraph {\n             encoder: Steal::new(GraphEncoder::new(\n                 encoder,\n@@ -927,6 +924,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n+            node_intern_event_id,\n         }\n     }\n \n@@ -970,6 +968,10 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     ) -> (DepNodeIndex, Option<(SerializedDepNodeIndex, DepNodeColor)>) {\n         let print_status = cfg!(debug_assertions) && print_status;\n \n+        // Get timer for profiling `DepNode` interning\n+        let _node_intern_timer =\n+            self.node_intern_event_id.map(|eid| profiler.generic_activity_with_event_id(eid));\n+\n         if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n             // Determine the color and index of the new `DepNode`.\n             if let Some(fingerprint) = fingerprint {"}, {"sha": "047fc9f10cc2f0e1e7e61e3fa4190400186b6ae0", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -32,6 +32,17 @@ pub trait DepContext: Copy {\n \n     /// Access the compiler session.\n     fn sess(&self) -> &Session;\n+\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self, kind: Self::DepKind) -> bool;\n+\n+    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle;\n+\n+    /// Try to force a dep node to execute and see if it's green.\n+    fn try_force_from_dep_node(&self, dep_node: DepNode<Self::DepKind>) -> bool;\n+\n+    /// Load data from the on-disk cache.\n+    fn try_load_from_on_disk_cache(&self, dep_node: DepNode<Self::DepKind>);\n }\n \n pub trait HasDepContext: Copy {\n@@ -51,7 +62,7 @@ impl<T: DepContext> HasDepContext for T {\n }\n \n /// Describes the contents of the fingerprint generated by a given query.\n-#[derive(PartialEq, Eq, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum FingerprintStyle {\n     /// The fingerprint is actually a DefPathHash.\n     DefPathHash,\n@@ -75,12 +86,6 @@ impl FingerprintStyle {\n pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder> + 'static {\n     const NULL: Self;\n \n-    /// Return whether this kind always require evaluation.\n-    fn is_eval_always(&self) -> bool;\n-\n-    /// Return whether this kind requires additional parameters to be executed.\n-    fn has_params(&self) -> bool;\n-\n     /// Implementation of `std::fmt::Debug` for `DepNode`.\n     fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n \n@@ -93,6 +98,4 @@ pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder>\n     fn read_deps<OP>(op: OP)\n     where\n         OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>);\n-\n-    fn fingerprint_style(&self) -> FingerprintStyle;\n }"}, {"sha": "fc3b7980dfb17f4584f92975e15222d6a04355de", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -24,7 +24,8 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n \n-    pub hash_result: fn(&mut StableHashingContext<'_>, &V) -> Option<Fingerprint>,\n+    pub compute: fn(CTX::DepContext, K) -> V,\n+    pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n     pub handle_cycle_error: fn(CTX, DiagnosticBuilder<'_>) -> V,\n     pub cache_on_disk: fn(CTX, &K, Option<&V>) -> bool,\n     pub try_load_from_disk: fn(CTX, SerializedDepNodeIndex) -> Option<V>,\n@@ -38,12 +39,8 @@ impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n \n-    pub(crate) fn hash_result(\n-        &self,\n-        hcx: &mut StableHashingContext<'_>,\n-        value: &V,\n-    ) -> Option<Fingerprint> {\n-        (self.hash_result)(hcx, value)\n+    pub(crate) fn compute(&self, tcx: CTX::DepContext, key: K) -> V {\n+        (self.compute)(tcx, key)\n     }\n \n     pub(crate) fn cache_on_disk(&self, tcx: CTX, key: &K, value: Option<&V>) -> bool {\n@@ -59,6 +56,9 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: CTX::DepKind;\n+    const HASH_RESULT: Option<\n+        fn(hcx: &mut StableHashingContext<'_>, result: &Self::Value) -> Fingerprint,\n+    >;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n@@ -75,9 +75,6 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute_fn(tcx: CTX, key: &Self::Key) -> fn(CTX::DepContext, Self::Key) -> Self::Value;\n \n-    fn hash_result(hcx: &mut StableHashingContext<'_>, result: &Self::Value)\n-    -> Option<Fingerprint>;\n-\n     fn handle_cycle_error(tcx: CTX, diag: DiagnosticBuilder<'_>) -> Self::Value;\n }\n \n@@ -95,21 +92,24 @@ pub trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n }\n \n pub(crate) trait QueryVtableExt<CTX: QueryContext, K, V> {\n-    const VTABLE: QueryVtable<CTX, K, V>;\n+    fn make_vtable(tcx: CTX, key: &K) -> QueryVtable<CTX, K, V>;\n }\n \n impl<CTX, Q> QueryVtableExt<CTX, Q::Key, Q::Value> for Q\n where\n     CTX: QueryContext,\n     Q: QueryDescription<CTX>,\n {\n-    const VTABLE: QueryVtable<CTX, Q::Key, Q::Value> = QueryVtable {\n-        anon: Q::ANON,\n-        dep_kind: Q::DEP_KIND,\n-        eval_always: Q::EVAL_ALWAYS,\n-        hash_result: Q::hash_result,\n-        handle_cycle_error: Q::handle_cycle_error,\n-        cache_on_disk: Q::cache_on_disk,\n-        try_load_from_disk: Q::try_load_from_disk,\n-    };\n+    fn make_vtable(tcx: CTX, key: &Q::Key) -> QueryVtable<CTX, Q::Key, Q::Value> {\n+        QueryVtable {\n+            anon: Q::ANON,\n+            dep_kind: Q::DEP_KIND,\n+            eval_always: Q::EVAL_ALWAYS,\n+            hash_result: Q::HASH_RESULT,\n+            compute: Q::compute_fn(tcx, key),\n+            handle_cycle_error: Q::handle_cycle_error,\n+            cache_on_disk: Q::cache_on_disk,\n+            try_load_from_disk: Q::try_load_from_disk,\n+        }\n+    }\n }"}, {"sha": "e2b0a65ab77b17e013cc3c088aa87efb13474955", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -14,7 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n-use crate::dep_graph::{DepNode, DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n \n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -122,12 +122,6 @@ pub trait QueryContext: HasDepContext {\n \n     fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>>;\n \n-    /// Load data from the on-disk cache.\n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n-\n-    /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n-\n     /// Load side effects associated to the node in the previous session.\n     fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;\n "}, {"sha": "056611317dcf18cb601e6fa0f2b62a8966efedf1", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 39, "deletions": 84, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=efd0483949496b067cd5f7569d1b28cd3d5d3c72", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{\n@@ -382,7 +382,6 @@ fn try_execute_query<CTX, C>(\n     lookup: QueryLookup,\n     dep_node: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n-    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n ) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n@@ -398,7 +397,7 @@ where\n         query.dep_kind,\n     ) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id, compute);\n+            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id);\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n@@ -429,7 +428,6 @@ fn execute_job<CTX, K, V>(\n     mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVtable<CTX, K, V>,\n     job_id: QueryJobId<CTX::DepKind>,\n-    compute: fn(CTX::DepContext, K) -> V,\n ) -> (V, DepNodeIndex)\n where\n     K: Clone + DepNodeParams<CTX::DepContext>,\n@@ -441,7 +439,7 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job_id, None, || compute(*tcx.dep_context(), key));\n+        let result = tcx.start_query(job_id, None, || query.compute(*tcx.dep_context(), key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n@@ -455,7 +453,7 @@ where\n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = tcx.start_query(job_id, None, || {\n-            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query, compute)\n+            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query)\n         }) {\n             return ret;\n         }\n@@ -467,14 +465,14 @@ where\n     let (result, dep_node_index) = tcx.start_query(job_id, Some(&diagnostics), || {\n         if query.anon {\n             return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                compute(*tcx.dep_context(), key)\n+                query.compute(*tcx.dep_context(), key)\n             });\n         }\n \n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node = dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n \n-        dep_graph.with_task(dep_node, *tcx.dep_context(), key, compute, query.hash_result)\n+        dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n     });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -498,7 +496,6 @@ fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n     key: &K,\n     dep_node: &DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, K, V>,\n-    compute: fn(CTX::DepContext, K) -> V,\n ) -> Option<(V, DepNodeIndex)>\n where\n     K: Clone,\n@@ -520,14 +517,6 @@ where\n         let result = query.try_load_from_disk(tcx, prev_dep_node_index);\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-        // We always expect to find a cached result for things that\n-        // can be forced from `DepNode`.\n-        debug_assert!(\n-            !dep_node.kind.fingerprint_style().reconstructible() || result.is_some(),\n-            \"missing on-disk cache entry for {:?}\",\n-            dep_node\n-        );\n-\n         if let Some(result) = result {\n             // If `-Zincremental-verify-ich` is specified, re-hash results from\n             // the cache and make sure that they have the expected fingerprint.\n@@ -537,14 +526,22 @@ where\n \n             return Some((result, dep_node_index));\n         }\n+\n+        // We always expect to find a cached result for things that\n+        // can be forced from `DepNode`.\n+        debug_assert!(\n+            !tcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n+            \"missing on-disk cache entry for {:?}\",\n+            dep_node\n+        );\n     }\n \n     // We could not load a result from the on-disk cache, so\n     // recompute.\n     let prof_timer = tcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| compute(*tcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| query.compute(*tcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -577,12 +574,12 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     );\n \n     debug!(\"BEGIN verify_ich({:?})\", dep_node);\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n-    let new_hash = query.hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n-    debug!(\"END verify_ich({:?})\", dep_node);\n-\n+    let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        f(&mut hcx, result)\n+    });\n     let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n+    debug!(\"END verify_ich({:?})\", dep_node);\n \n     if Some(new_hash) != old_hash {\n         let run_cmd = if let Some(crate_name) = &tcx.sess().opts.crate_name {\n@@ -665,41 +662,6 @@ where\n     }\n }\n \n-#[inline(never)]\n-fn force_query_impl<CTX, C>(\n-    tcx: CTX,\n-    state: &QueryState<CTX::DepKind, C::Key>,\n-    cache: &QueryCacheStore<C>,\n-    key: C::Key,\n-    dep_node: DepNode<CTX::DepKind>,\n-    query: &QueryVtable<CTX, C::Key, C::Value>,\n-    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n-) -> bool\n-where\n-    C: QueryCache,\n-    C::Key: DepNodeParams<CTX::DepContext>,\n-    CTX: QueryContext,\n-{\n-    debug_assert!(!query.anon);\n-\n-    // We may be concurrently trying both execute and force a query.\n-    // Ensure that only one of them runs the query.\n-    let cached = cache.cache.lookup(cache, &key, |_, index| {\n-        if unlikely!(tcx.dep_context().profiler().enabled()) {\n-            tcx.dep_context().profiler().query_cache_hit(index.into());\n-        }\n-    });\n-\n-    let lookup = match cached {\n-        Ok(()) => return true,\n-        Err(lookup) => lookup,\n-    };\n-\n-    let _ =\n-        try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), query, compute);\n-    true\n-}\n-\n pub enum QueryMode {\n     Get,\n     Ensure,\n@@ -717,9 +679,9 @@ where\n     Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    let query = &Q::VTABLE;\n+    let query = Q::make_vtable(tcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(tcx, &key, query);\n+        let (must_run, dep_node) = ensure_must_run(tcx, &key, &query);\n         if !must_run {\n             return None;\n         }\n@@ -729,7 +691,6 @@ where\n     };\n \n     debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n-    let compute = Q::compute_fn(tcx, &key);\n     let (result, dep_node_index) = try_execute_query(\n         tcx,\n         Q::query_state(tcx),\n@@ -738,43 +699,37 @@ where\n         key,\n         lookup,\n         dep_node,\n-        query,\n-        compute,\n+        &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n         tcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n     Some(result)\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, dep_node: &DepNode<CTX::DepKind>) -> bool\n+pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n where\n     Q: QueryDescription<CTX>,\n     Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    if Q::ANON {\n-        return false;\n-    }\n+    assert!(!Q::ANON);\n \n-    if !<Q::Key as DepNodeParams<CTX::DepContext>>::fingerprint_style().reconstructible() {\n-        return false;\n-    }\n+    // We may be concurrently trying both execute and force a query.\n+    // Ensure that only one of them runs the query.\n+    let cache = Q::query_cache(tcx);\n+    let cached = cache.cache.lookup(cache, &key, |_, index| {\n+        if unlikely!(tcx.dep_context().profiler().enabled()) {\n+            tcx.dep_context().profiler().query_cache_hit(index.into());\n+        }\n+    });\n \n-    let Some(key) =\n-        <Q::Key as DepNodeParams<CTX::DepContext>>::recover(*tcx.dep_context(), &dep_node)\n-    else {\n-        return false;\n+    let lookup = match cached {\n+        Ok(()) => return,\n+        Err(lookup) => lookup,\n     };\n \n-    let compute = Q::compute_fn(tcx, &key);\n-    force_query_impl(\n-        tcx,\n-        Q::query_state(tcx),\n-        Q::query_cache(tcx),\n-        key,\n-        *dep_node,\n-        &Q::VTABLE,\n-        compute,\n-    )\n+    let query = Q::make_vtable(tcx, &key);\n+    let state = Q::query_state(tcx);\n+    try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), &query);\n }"}]}