{"sha": "3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZjdmZjhiODkyYWEyYWQ3ZTgyMWQ4ODU4YzM0OWUyMmQxMTk3YmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-06T16:14:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-15T00:37:32Z"}, "message": "infer the scope of borrows", "tree": {"sha": "41c4ef19b8c978ecd84daf6c2f103d7ecdb704da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41c4ef19b8c978ecd84daf6c2f103d7ecdb704da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "html_url": "https://github.com/rust-lang/rust/commit/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41a21f053ced3df8fe9acc66cb30fb6005339b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/41a21f053ced3df8fe9acc66cb30fb6005339b3e", "html_url": "https://github.com/rust-lang/rust/commit/41a21f053ced3df8fe9acc66cb30fb6005339b3e"}], "stats": {"total": 575, "additions": 375, "deletions": 200}, "files": [{"sha": "bf2e4cb0e3358710a19e3ea80827990078e880df", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 98, "deletions": 62, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -74,8 +74,7 @@ import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n import rscope::{in_binding_rscope, region_scope, type_rscope};\n import syntax::ast::ty_i;\n import typeck::infer::{unify_methods}; // infcx.set()\n-import typeck::infer::{force_level, force_none, force_ty_vars_only,\n-                       force_all};\n+import typeck::infer::{resolve_type, force_tvar};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -89,7 +88,22 @@ type fn_ctxt =\n      infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, tv_vid>,\n \n-     mut blocks: ~[ast::node_id], // stack of blocks in scope, may be empty\n+     // Sometimes we generate region pointers where the precise region\n+     // to use is not known. For example, an expression like `&x.f`\n+     // where `x` is of type `@T`: in this case, we will be rooting\n+     // `x` onto the stack frame, and we could choose to root it until\n+     // the end of (almost) any enclosing block or expression.  We\n+     // want to pick the narrowest block that encompasses all uses.\n+     //\n+     // What we do in such cases is to generate a region variable and\n+     // assign it the following two fields as bounds.  The lower bound\n+     // is always the innermost enclosing expression.  The upper bound\n+     // is the outermost enclosing expression that we could legally\n+     // use.  In practice, this is the innermost loop or function\n+     // body.\n+     mut region_lb: ast::node_id,\n+     mut region_ub: ast::node_id,\n+\n      in_scope_regions: isr_alist,\n \n      node_types: smallintmap::smallintmap<ty::t>,\n@@ -98,7 +112,8 @@ type fn_ctxt =\n      ccx: @crate_ctxt};\n \n // Used by check_const and check_enum_variants\n-fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t) -> @fn_ctxt {\n+fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n+                 region_bnd: ast::node_id) -> @fn_ctxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n     @{self_ty: none,\n@@ -107,7 +122,8 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t) -> @fn_ctxt {\n       purity: ast::pure_fn,\n       infcx: infer::new_infer_ctxt(ccx.tcx),\n       locals: int_hash(),\n-      mut blocks: ~[],\n+      mut region_lb: region_bnd,\n+      mut region_ub: region_bnd,\n       in_scope_regions: @nil,\n       node_types: smallintmap::mk(),\n       node_type_substs: map::int_hash(),\n@@ -217,7 +233,8 @@ fn check_fn(ccx: @crate_ctxt,\n           purity: purity,\n           infcx: infcx,\n           locals: locals,\n-          mut blocks: ~[],\n+          mut region_lb: body.node.id,\n+          mut region_ub: body.node.id,\n           in_scope_regions: isr,\n           node_types: node_types,\n           node_type_substs: node_type_substs,\n@@ -307,9 +324,12 @@ fn check_fn(ccx: @crate_ctxt,\n         };\n \n         let visit_block = fn@(b: ast::blk, &&e: (), v: visit::vt<()>) {\n-            vec::push(fcx.blocks, b.node.id);\n-            visit::visit_block(b, e, v);\n-            vec::pop(fcx.blocks);\n+            // non-obvious: the `blk` variable maps to region lb, so\n+            // we have to keep this up-to-date.  This\n+            // is... unfortunate.  It'd be nice to not need this.\n+            do fcx.with_region_lb(b.node.id) {\n+                visit::visit_block(b, e, v);\n+            }\n         };\n \n         // Don't descend into fns and items\n@@ -430,7 +450,7 @@ impl of ast_conv for @fn_ctxt {\n \n impl of region_scope for @fn_ctxt {\n     fn anon_region() -> result<ty::region, ~str> {\n-        result::ok(self.infcx.next_region_var())\n+        result::ok(self.infcx.next_region_var_nb())\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, ~str> {\n         do empty_rscope.named_region(id).chain_err |_e| {\n@@ -448,10 +468,7 @@ impl of region_scope for @fn_ctxt {\n impl methods for @fn_ctxt {\n     fn tag() -> ~str { #fmt[\"%x\", ptr::addr_of(*self) as uint] }\n     fn block_region() -> result<ty::region, ~str> {\n-        alt vec::last_opt(self.blocks) {\n-          some(bid) { result::ok(ty::re_scope(bid)) }\n-          none { result::err(~\"no block is in scope here\") }\n-        }\n+        result::ok(ty::re_scope(self.region_lb))\n     }\n     #[inline(always)]\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n@@ -534,15 +551,17 @@ impl methods for @fn_ctxt {\n         infer::can_mk_subty(self.infcx, sub, sup)\n     }\n \n-    fn mk_assignty(expr: @ast::expr, borrow_scope: ast::node_id,\n+    fn mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n                    sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n-        let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n+        let anmnt = {expr_id: expr.id, borrow_lb: borrow_lb,\n+                     borrow_ub: self.region_ub};\n         infer::mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n-    fn can_mk_assignty(expr: @ast::expr, borrow_scope: ast::node_id,\n+    fn can_mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n                       sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n-        let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n+        let anmnt = {expr_id: expr.id, borrow_lb: borrow_lb,\n+                     borrow_ub: self.region_ub};\n         infer::can_mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n@@ -564,6 +583,20 @@ impl methods for @fn_ctxt {\n           }\n         }\n     }\n+    fn with_region_lb<R>(lb: ast::node_id, f: fn() -> R) -> R {\n+        let old_region_lb = self.region_lb;\n+        self.region_lb = lb;\n+        let v <- f();\n+        self.region_lb = old_region_lb;\n+        ret v;\n+    }\n+    fn with_region_ub<R>(ub: ast::node_id, f: fn() -> R) -> R {\n+        let old_region_ub = self.region_ub;\n+        self.region_ub = ub;\n+        let v <- f();\n+        self.region_ub = old_region_ub;\n+        ret v;\n+    }\n }\n \n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n@@ -682,7 +715,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n          raw_ty: ity.ty}\n     };\n \n-    let self_r = if rp {some(fcx.infcx.next_region_var())} else {none};\n+    let self_r = if rp {some(fcx.infcx.next_region_var_nb())} else {none};\n     let tps = fcx.infcx.next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};\n@@ -733,7 +766,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               sty @ ty::ty_fn(fn_ty) {\n                 replace_bound_regions_in_fn_ty(\n                     fcx.ccx.tcx, @nil, none, fn_ty,\n-                    |_br| fcx.infcx.next_region_var()).fn_ty\n+                    |_br| fcx.infcx.next_region_var_nb()).fn_ty\n               }\n               sty {\n                 // I would like to make this span_err, but it's\n@@ -1017,7 +1050,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         -> option<O> {\n         alt expected {\n           some(t) {\n-            alt infer::resolve_shallow(fcx.infcx, t, force_none) {\n+            alt resolve_type(fcx.infcx, t, force_tvar) {\n               result::ok(t) { unpack(ty::get(t).struct) }\n               _ { none }\n             }\n@@ -1119,9 +1152,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n             // this will be the call or block that immediately\n             // encloses the method call\n-            let borrow_scope = fcx.tcx().region_map.get(expr.id);\n+            let borrow_lb = fcx.tcx().region_map.get(expr.id);\n \n-            let lkup = method::lookup(fcx, expr, base, borrow_scope,\n+            let lkup = method::lookup(fcx, expr, base, borrow_lb,\n                                       expr.id, field, expr_t, tps,\n                                       is_self_ref);\n             alt lkup.method() {\n@@ -1364,13 +1397,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n-        check_block_no_value(fcx, body);\n+        do fcx.with_region_ub(body.node.id) {\n+            check_block_no_value(fcx, body);\n+        }\n         fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n       ast::expr_loop(body) {\n-          check_block_no_value(fcx, body);\n-          fcx.write_ty(id, ty::mk_nil(tcx));\n-          bot = !may_break(body);\n+        do fcx.with_region_ub(body.node.id) {\n+            check_block_no_value(fcx, body);\n+        }\n+        fcx.write_ty(id, ty::mk_nil(tcx));\n+        bot = !may_break(body);\n       }\n       ast::expr_alt(discrim, arms, _) {\n         bot = alt::check_alt(fcx, expr, discrim, arms);\n@@ -1754,44 +1791,44 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n       ast::unsafe_blk { @{purity: ast::unsafe_fn with *fcx0} }\n       ast::default_blk { fcx0 }\n     };\n-    vec::push(fcx.blocks, blk.node.id);\n-    let mut bot = false;\n-    let mut warned = false;\n-    for blk.node.stmts.each |s| {\n-        if bot && !warned &&\n-               alt s.node {\n-                 ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n-                 ast::stmt_expr(_, _) | ast::stmt_semi(_, _) {\n-                   true\n-                 }\n-                 _ { false }\n-               } {\n-            fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n-            warned = true;\n+    do fcx.with_region_lb(blk.node.id) {\n+        let mut bot = false;\n+        let mut warned = false;\n+        for blk.node.stmts.each |s| {\n+            if bot && !warned &&\n+                alt s.node {\n+                  ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n+                  ast::stmt_expr(_, _) | ast::stmt_semi(_, _) {\n+                    true\n+                  }\n+                  _ { false }\n+                } {\n+                fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n+                warned = true;\n+            }\n+            bot |= check_stmt(fcx, s);\n         }\n-        bot |= check_stmt(fcx, s);\n-    }\n-    alt blk.node.expr {\n-      none { fcx.write_nil(blk.node.id); }\n-      some(e) {\n-        if bot && !warned {\n-            fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n+        alt blk.node.expr {\n+          none { fcx.write_nil(blk.node.id); }\n+          some(e) {\n+            if bot && !warned {\n+                fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n+            }\n+            bot |= check_expr(fcx, e, none);\n+            let ety = fcx.expr_ty(e);\n+            fcx.write_ty(blk.node.id, ety);\n+          }\n         }\n-        bot |= check_expr(fcx, e, none);\n-        let ety = fcx.expr_ty(e);\n-        fcx.write_ty(blk.node.id, ety);\n-      }\n-    }\n-    if bot {\n-        fcx.write_bot(blk.node.id);\n+        if bot {\n+            fcx.write_bot(blk.node.id);\n+        }\n+        bot\n     }\n-    vec::pop(fcx.blocks);\n-    ret bot;\n }\n \n fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx = blank_fn_ctxt(ccx, rty);\n+    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n     check_expr(fcx, e, none);\n     let cty = fcx.expr_ty(e);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n@@ -1817,13 +1854,13 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                        vs: ~[ast::variant],\n                        id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx = blank_fn_ctxt(ccx, rty);\n     let mut disr_vals: ~[int] = ~[];\n     let mut disr_val = 0;\n     let mut variants = ~[];\n     for vs.each |v| {\n         alt v.node.disr_expr {\n           some(e) {\n+            let fcx = blank_fn_ctxt(ccx, rty, e.id);\n             check_expr(fcx, e, none);\n             let cty = fcx.expr_ty(e);\n             let declty = ty::mk_int(ccx.tcx);\n@@ -2003,7 +2040,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n         some(ast_region_to_region(fcx, fcx, sp, r))\n       }\n       none if tpt.rp => {\n-        some(fcx.infcx.next_region_var())\n+        some(fcx.infcx.next_region_var_nb())\n       }\n       none => {\n         none\n@@ -2037,8 +2074,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt infer::resolve_shallow(fcx.infcx, tp,\n-                               force_ty_vars_only) {\n+    alt infer::resolve_type(fcx.infcx, tp, force_tvar) {\n       result::ok(t_s) if !ty::type_is_var(t_s) { ret t_s; }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal"}, {"sha": "3718660472bcaa3f3fae3c41f3b09f504403eb16", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -26,11 +26,10 @@ fn eqtype(fcx: @fn_ctxt, sp: span,\n }\n \n // Checks that the type `actual` can be assigned to `expected`.\n-fn assign(fcx: @fn_ctxt, sp: span, borrow_scope: ast::node_id,\n+fn assign(fcx: @fn_ctxt, sp: span, borrow_lb: ast::node_id,\n           expected: ty::t, expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n-    let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n-    alt infer::mk_assignty(fcx.infcx, anmnt, expr_ty, expected) {\n+    alt fcx.mk_assignty(expr, borrow_lb, expr_ty, expected) {\n       result::ok(()) { /* ok */ }\n       result::err(err) {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);"}, {"sha": "5627625daa36e248a2a02044f2a004df3ed994fc", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -19,7 +19,7 @@ class lookup {\n     let fcx: @fn_ctxt;\n     let expr: @ast::expr;\n     let self_expr: @ast::expr;\n-    let borrow_scope: ast::node_id;\n+    let borrow_lb: ast::node_id;\n     let node_id: ast::node_id;\n     let m_name: ast::ident;\n     let mut self_ty: ty::t;\n@@ -32,7 +32,7 @@ class lookup {\n     new(fcx: @fn_ctxt,\n         expr: @ast::expr,           //expr for a.b in a.b()\n         self_expr: @ast::expr,      //a in a.b(...)\n-        borrow_scope: ast::node_id, //scope to borrow the expr for\n+        borrow_lb: ast::node_id, //scope to borrow the expr for\n         node_id: ast::node_id,      //node id where to store type of fn\n         m_name: ast::ident,         //b in a.b(...)\n         self_ty: ty::t,             //type of a in a.b(...)\n@@ -42,7 +42,7 @@ class lookup {\n         self.fcx = fcx;\n         self.expr = expr;\n         self.self_expr = self_expr;\n-        self.borrow_scope = borrow_scope;\n+        self.borrow_lb = borrow_lb;\n         self.node_id = node_id;\n         self.m_name = m_name;\n         self.self_ty = self_ty;\n@@ -315,7 +315,7 @@ class lookup {\n                     // type assignability. Collect the matches.\n                     let matches = if use_assignability {\n                         self.fcx.can_mk_assignty(\n-                            self.self_expr, self.borrow_scope,\n+                            self.self_expr, self.borrow_lb,\n                             self.self_ty, impl_ty)\n                     } else {\n                         self.fcx.can_mk_subty(self.self_ty, impl_ty)\n@@ -377,7 +377,7 @@ class lookup {\n         // Make the actual receiver type (cand.self_ty) assignable to the\n         // required receiver type (cand.rcvr_ty).  If this method is not\n         // from an impl, this'll basically be a no-nop.\n-        alt self.fcx.mk_assignty(self.self_expr, self.borrow_scope,\n+        alt self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n                                  cand.self_ty, cand.rcvr_ty) {\n           result::ok(_) {}\n           result::err(_) {"}, {"sha": "e136ccd7b692ef3941b194fd2c61867df4a4150f", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -8,13 +8,19 @@ know whether a given type will be a region pointer or not until this\n phase.\n \n In particular, we ensure that, if the type of an expression or\n-variable is `&r.T`, then the expression or variable must occur within\n-the region scope `r`.\n+variable is `&r/T`, then the expression or variable must occur within\n+the region scope `r`.  Note that in some cases `r` may still be a\n+region variable, so this gives us a chance to influence the value for\n+`r` that we infer to ensure we choose a value large enough to enclose\n+all uses.  There is a lengthy comment in visit_node() that explains\n+this point a bit better.\n \n */\n \n import util::ppaux;\n import syntax::print::pprust;\n+import infer::{resolve_type, resolve_all, force_all,\n+               resolve_rvar, force_rvar};\n \n type rcx = @{fcx: @fn_ctxt, mut errors_reported: uint};\n type rvt = visit::vt<rcx>;\n@@ -114,8 +120,31 @@ fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n+    //\n+    // Note one important point: we do not attempt to resolve *region\n+    // variables* here.  This is because regionck is essentially adding\n+    // constraints to those region variables and so may yet influence\n+    // how they are resolved.\n+    //\n+    // Consider this silly example:\n+    //\n+    //     fn borrow(x: &int) -> &int {x}\n+    //     fn foo(x: @int) -> int {  /* block: B */\n+    //         let b = borrow(x);    /* region: <R0> */\n+    //         *b\n+    //     }\n+    //\n+    // Here, the region of `b` will be `<R0>`.  `<R0>` is constrainted\n+    // to be some subregion of the block B and some superregion of\n+    // the call.  If we forced it now, we'd choose the smaller region\n+    // (the call).  But that would make the *b illegal.  Since we don't\n+    // resolve, the type of b will be `&<R0>.int` and then `*b` will require\n+    // that `<R0>` be bigger than the let and the `*b` expression, so we\n+    // will effectively resolve `<R0>` to be the block B.\n     let ty0 = fcx.node_ty(id);\n-    let ty = alt infer::resolve_deep(fcx.infcx, ty0, force_none) {\n+    let ty = alt resolve_type(fcx.infcx, ty0,\n+                              (resolve_all | force_all) -\n+                              (resolve_rvar | force_rvar)) {\n       result::err(_) { ret true; }\n       result::ok(ty) { ty }\n     };\n@@ -161,11 +190,12 @@ fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n \n         alt rcx.fcx.mk_subr(encl_region, region) {\n           result::err(_) {\n+            let region1 = rcx.fcx.infcx.resolve_region_if_possible(region);\n             tcx.sess.span_err(\n                 span,\n                 #fmt[\"reference is not valid outside \\\n                       of its lifetime, %s\",\n-                     ppaux::region_to_str(tcx, region)]);\n+                     ppaux::region_to_str(tcx, region1)]);\n             rcx.errors_reported += 1u;\n           }\n           result::ok(()) {"}, {"sha": "a4dd6bae933c1387ded693da251ee8482b00fa5f", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -1,4 +1,5 @@\n import check::{fn_ctxt, impl_self_ty, methods};\n+import infer::{resolve_type, resolve_all, force_all, fixup_err_to_str};\n \n fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n@@ -178,14 +179,14 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n \n fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n-    alt infer::resolve_deep(fcx.infcx, ty, force_all) {\n+    alt resolve_type(fcx.infcx, ty, resolve_all | force_all) {\n       result::ok(new_type) { new_type }\n       result::err(e) {\n         tcx.sess.span_fatal(\n             sp,\n             #fmt[\"cannot determine a type \\\n                   for this bounded type parameter: %s\",\n-                 infer::fixup_err_to_str(e)])\n+                 fixup_err_to_str(e)])\n       }\n     }\n }"}, {"sha": "720c85bf18e2cf705b80cb55b9359ffe1dc6b30e", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -3,14 +3,14 @@\n // substitutions.\n \n import check::{fn_ctxt, lookup_local, methods};\n-\n+import infer::{resolve_type, resolve_all, force_all};\n export resolve_type_vars_in_fn;\n export resolve_type_vars_in_expr;\n \n fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n     option<ty::t> {\n     if !ty::type_needs_infer(typ) { ret some(typ); }\n-    alt infer::resolve_deep(fcx.infcx, typ, force_all) {\n+    alt resolve_type(fcx.infcx, typ, resolve_all | force_all) {\n       result::ok(new_type) { ret some(new_type); }\n       result::err(e) {\n         if !fcx.ccx.tcx.sess.has_errors() {\n@@ -130,7 +130,8 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { ret; }\n     let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n-    alt infer::resolve_deep_var(wbcx.fcx.infcx, var_id, force_all) {\n+    let var_ty = ty::mk_var(wbcx.fcx.tcx(), var_id);\n+    alt resolve_type(wbcx.fcx.infcx, var_ty, resolve_all | force_all) {\n       result::ok(lty) {\n         #debug[\"Type for local %s (id %d) resolved to %s\",\n                pat_to_str(l.node.pat), l.node.id,\n@@ -166,6 +167,9 @@ fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n     visit.visit_expr(e, wbcx, visit);\n+    if wbcx.success {\n+        infer::resolve_borrowings(fcx.infcx);\n+    }\n     ret wbcx.success;\n }\n \n@@ -178,5 +182,8 @@ fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n     for decl.inputs.each |arg| {\n         resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n     }\n+    if wbcx.success {\n+        infer::resolve_borrowings(fcx.infcx);\n+    }\n     ret wbcx.success;\n }"}, {"sha": "593b7d2a2e15480ca4fe6638c1cf154409f425cb", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -242,7 +242,7 @@ class CoherenceChecker {\n     fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n         let self_region =\n             if polytype.rp {none}\n-            else {some(self.inference_context.next_region_var())};\n+            else {some(self.inference_context.next_region_var_nb())};\n \n         let bounds_count = polytype.bounds.len();\n         let type_parameters ="}, {"sha": "f437aa2ed62354f2974de8f591879fb0f755ef62", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 160, "deletions": 110, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -181,23 +181,24 @@ import driver::session::session;\n import util::common::{indent, indenter};\n import ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n import ast::{m_const, m_imm, m_mutbl};\n+import dvec::{dvec, extensions};\n \n export infer_ctxt;\n export new_infer_ctxt;\n export mk_subty, can_mk_subty;\n export mk_subr;\n export mk_eqty;\n export mk_assignty, can_mk_assignty;\n-export resolve_shallow;\n-export resolve_deep;\n-export resolve_deep_var;\n+export resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all;\n+export force_tvar, force_rvar, force_ivar, force_all;\n+export resolve_type, resolve_region;\n+export resolve_borrowings;\n export methods; // for infer_ctxt\n export unify_methods; // for infer_ctxt\n export fixup_err, fixup_err_to_str;\n export assignment;\n export root, to_str;\n export int_ty_set_all;\n-export force_level, force_none, force_ty_vars_only, force_all;\n \n // Bitvector to represent sets of integral types\n enum int_ty_set = uint;\n@@ -280,7 +281,8 @@ fn convert_integral_ty_to_int_ty_set(tcx: ty::ctxt, t: ty::t)\n // value should be borrowed.\n type assignment = {\n     expr_id: ast::node_id,\n-    borrow_scope: ast::node_id\n+    borrow_lb: ast::node_id,\n+    borrow_ub: ast::node_id,\n };\n \n type bound<T:copy> = option<T>;\n@@ -321,14 +323,18 @@ enum infer_ctxt = @{\n     ty_var_counter: @mut uint,\n     ty_var_integral_counter: @mut uint,\n     region_var_counter: @mut uint,\n+\n+    borrowings: dvec<{expr_id: ast::node_id,\n+                      scope: ty::region,\n+                      mutbl: ast::mutability}>\n };\n \n enum fixup_err {\n     unresolved_int_ty(tvi_vid),\n     unresolved_ty(tv_vid),\n     cyclic_ty(tv_vid),\n     unresolved_region(region_vid),\n-    cyclic_region(region_vid)\n+    region_var_bound_by_region_var(region_vid, region_vid)\n }\n \n fn fixup_err_to_str(f: fixup_err) -> ~str {\n@@ -337,7 +343,10 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n       unresolved_ty(_) { ~\"unconstrained type\" }\n       cyclic_ty(_) { ~\"cyclic type of infinite size\" }\n       unresolved_region(_) { ~\"unconstrained region\" }\n-      cyclic_region(_) { ~\"cyclic region\" }\n+      region_var_bound_by_region_var(r1, r2) {\n+        #fmt[\"region var %? bound by another region var %?; this is \\\n+              a bug in rustc\", r1, r2]\n+      }\n     }\n }\n \n@@ -351,7 +360,8 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n                  rb: {vals: smallintmap::mk(), mut bindings: ~[]},\n                  ty_var_counter: @mut 0u,\n                  ty_var_integral_counter: @mut 0u,\n-                 region_var_counter: @mut 0u})}\n+                 region_var_counter: @mut 0u,\n+                 borrowings: dvec()})}\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n@@ -387,32 +397,44 @@ fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     #debug[\"can_mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)];\n \n-    // FIXME (#2593): this will not unroll any entries we make in the\n-    // borrowings table.  But this is OK for the moment because this is only\n-    // used in method lookup, and there must be exactly one match or an\n-    // error is reported. Still, it should be fixed.\n+    // FIXME(#2593)---this will not unroll any entries we make in the\n+    // borrowings table.  But this is OK for the moment because this\n+    // is only used in method lookup, and there must be exactly one\n+    // match or an error is reported. Still, it should be fixed. (#2593)\n+    // NDM OUTDATED\n \n     indent(|| cx.probe(||\n         cx.assign_tys(anmnt, a, b)\n     ) ).to_ures()\n }\n \n // See comment on the type `resolve_state` below\n-fn resolve_shallow(cx: infer_ctxt, a: ty::t,\n-                   force_vars: force_level) -> fres<ty::t> {\n-    resolver(cx, false, force_vars).resolve(a)\n+fn resolve_type(cx: infer_ctxt, a: ty::t, modes: uint)\n+    -> fres<ty::t> {\n+    resolver(cx, modes).resolve_type_chk(a)\n }\n \n-// See comment on the type `resolve_state` below\n-fn resolve_deep_var(cx: infer_ctxt, vid: tv_vid,\n-                    force_vars: force_level) -> fres<ty::t> {\n-    resolver(cx, true, force_vars).resolve(ty::mk_var(cx.tcx, vid))\n+fn resolve_region(cx: infer_ctxt, r: ty::region, modes: uint)\n+    -> fres<ty::region> {\n+    resolver(cx, modes).resolve_region_chk(r)\n }\n \n-// See comment on the type `resolve_state` below\n-fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: force_level)\n-    -> fres<ty::t> {\n-    resolver(cx, true, force_vars).resolve(a)\n+fn resolve_borrowings(cx: infer_ctxt) {\n+    for cx.borrowings.each |item| {\n+        alt resolve_region(cx, item.scope, resolve_all|force_all) {\n+          ok(ty::re_scope(scope_id)) => {\n+            #debug[\"borrowing for expr %d resolved to scope %d, mutbl %?\",\n+                   item.expr_id, scope_id, item.mutbl];\n+            cx.tcx.borrowings.insert(\n+                item.expr_id, {scope_id: scope_id, mutbl: item.mutbl});\n+          }\n+\n+          r => {\n+            cx.tcx.sess.bug(\n+                #fmt[\"borrowing resolved to %?, not a valid scope\", r]);\n+          }\n+        }\n+    }\n }\n \n impl methods for ures {\n@@ -567,6 +589,8 @@ impl transaction_methods for infer_ctxt {\n \n         let tvbl = self.tvb.bindings.len();\n         let rbl = self.rb.bindings.len();\n+        let bl = self.borrowings.len();\n+\n         #debug[\"try(tvbl=%u, rbl=%u)\", tvbl, rbl];\n         let r <- f();\n         alt r {\n@@ -575,6 +599,7 @@ impl transaction_methods for infer_ctxt {\n             #debug[\"try--rollback\"];\n             rollback_to(self.tvb, tvbl);\n             rollback_to(self.rb, rbl);\n+            while self.borrowings.len() != bl { self.borrowings.pop(); }\n           }\n         }\n         ret r;\n@@ -621,16 +646,19 @@ impl methods for infer_ctxt {\n         ty::mk_var_integral(self.tcx, self.next_ty_var_integral_id())\n     }\n \n-    fn next_region_var_id() -> region_vid {\n+    fn next_region_var_id(bnds: bounds<ty::region>) -> region_vid {\n         let id = *self.region_var_counter;\n         *self.region_var_counter += 1u;\n-        self.rb.vals.insert(id,\n-                            root({lb: none, ub: none}, 0u));\n+        self.rb.vals.insert(id, root(bnds, 0));\n         ret region_vid(id);\n     }\n \n-    fn next_region_var() -> ty::region {\n-        ty::re_var(self.next_region_var_id())\n+    fn next_region_var(bnds: bounds<ty::region>) -> ty::region {\n+        ty::re_var(self.next_region_var_id(bnds))\n+    }\n+\n+    fn next_region_var_nb() -> ty::region { // nb == \"no bounds\"\n+        self.next_region_var({lb: none, ub: none})\n     }\n \n     fn ty_to_str(t: ty::t) -> ~str {\n@@ -639,11 +667,18 @@ impl methods for infer_ctxt {\n     }\n \n     fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n-        alt infer::resolve_deep(self, typ, force_none) {\n+        alt resolve_type(self, typ, resolve_all) {\n           result::ok(new_type) { ret new_type; }\n           result::err(_) { ret typ; }\n         }\n     }\n+\n+    fn resolve_region_if_possible(oldr: ty::region) -> ty::region {\n+        alt resolve_region(self, oldr, resolve_all) {\n+          result::ok(newr) { ret newr; }\n+          result::err(_) { ret oldr; }\n+        }\n+    }\n }\n \n impl unify_methods for infer_ctxt {\n@@ -1029,67 +1064,70 @@ impl unify_methods for infer_ctxt {\n // the behavior in the face of unconstrained type and region\n // variables.\n \n-enum force_level {\n-    // Any unconstrained variables are OK.\n-    force_none,\n-\n-    // Unconstrained region vars and integral ty vars are OK;\n-    // unconstrained general-purpose ty vars result in an error.\n-    force_ty_vars_only,\n-\n-    // Any unconstrained variables result in an error.\n-    force_all,\n-}\n-\n+const resolve_nested_tvar: uint = 0b00000001;\n+const resolve_rvar: uint        = 0b00000010;\n+const resolve_ivar: uint        = 0b00000100;\n+const resolve_all: uint         = 0b00000111;\n+const force_tvar: uint          = 0b00010000;\n+const force_rvar: uint          = 0b00100000;\n+const force_ivar: uint          = 0b01000000;\n+const force_all: uint           = 0b01110000;\n \n type resolve_state = @{\n     infcx: infer_ctxt,\n-    deep: bool,\n-    force_vars: force_level,\n+    modes: uint,\n     mut err: option<fixup_err>,\n-    mut r_seen: ~[region_vid],\n     mut v_seen: ~[tv_vid]\n };\n \n-fn resolver(infcx: infer_ctxt, deep: bool, fvars: force_level)\n+fn resolver(infcx: infer_ctxt, modes: uint)\n     -> resolve_state {\n     @{infcx: infcx,\n-      deep: deep,\n-      force_vars: fvars,\n+      modes: modes,\n       mut err: none,\n-      mut r_seen: ~[],\n       mut v_seen: ~[]}\n }\n \n impl methods for resolve_state {\n-    fn resolve(typ: ty::t) -> fres<ty::t> {\n+    fn should(mode: uint) -> bool {\n+        (self.modes & mode) == mode\n+    }\n+\n+    fn resolve_type_chk(typ: ty::t) -> fres<ty::t> {\n         self.err = none;\n \n-        #debug[\"Resolving %s (deep=%b, force_vars=%?)\",\n+        #debug[\"Resolving %s (modes=%x)\",\n                ty_to_str(self.infcx.tcx, typ),\n-               self.deep,\n-               self.force_vars];\n+               self.modes];\n \n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n-        assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n-        let rty = indent(|| self.resolve1(typ) );\n-        assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n+        assert vec::is_empty(self.v_seen);\n+        let rty = indent(|| self.resolve_type(typ) );\n+        assert vec::is_empty(self.v_seen);\n         alt self.err {\n           none {\n-            #debug[\"Resolved to %s (deep=%b, force_vars=%?)\",\n+            #debug[\"Resolved to %s (modes=%x)\",\n                    ty_to_str(self.infcx.tcx, rty),\n-                   self.deep,\n-                   self.force_vars];\n+                   self.modes];\n             ret ok(rty);\n           }\n           some(e) { ret err(e); }\n         }\n     }\n \n-    fn resolve1(typ: ty::t) -> ty::t {\n-        #debug(\"Resolve1(%s)\", typ.to_str(self.infcx));\n+    fn resolve_region_chk(orig: ty::region) -> fres<ty::region> {\n+        self.err = none;\n+        let resolved = indent(|| self.resolve_region(orig) );\n+        alt self.err {\n+          none {ok(resolved)}\n+          some(e) {err(e)}\n+        }\n+    }\n+\n+    fn resolve_type(typ: ty::t) -> ty::t {\n+        #debug(\"resolve_type(%s)\", typ.to_str(self.infcx));\n         indent(fn&() -> ty::t {\n             if !ty::type_needs_infer(typ) { ret typ; }\n \n@@ -1100,23 +1138,30 @@ impl methods for resolve_state {\n               ty::ty_var_integral(vid) {\n                 self.resolve_ty_var_integral(vid)\n               }\n-              _ if !ty::type_has_regions(typ) && !self.deep {\n-                typ\n-              }\n               _ {\n-                ty::fold_regions_and_ty(\n-                    self.infcx.tcx, typ,\n-                    |r| self.resolve_region(r),\n-                    |t| self.resolve_if_deep(t),\n-                    |t| self.resolve_if_deep(t))\n+                if !self.should(resolve_rvar) &&\n+                    !self.should(resolve_nested_tvar) {\n+                    // shortcircuit for efficiency\n+                    typ\n+                } else {\n+                    ty::fold_regions_and_ty(\n+                        self.infcx.tcx, typ,\n+                        |r| self.resolve_region(r),\n+                        |t| self.resolve_nested_tvar(t),\n+                        |t| self.resolve_nested_tvar(t))\n+                }\n               }\n             }\n         })\n     }\n \n-    fn resolve_if_deep(typ: ty::t) -> ty::t {\n+    fn resolve_nested_tvar(typ: ty::t) -> ty::t {\n         #debug(\"Resolve_if_deep(%s)\", typ.to_str(self.infcx));\n-        if !self.deep {typ} else {self.resolve1(typ)}\n+        if !self.should(resolve_nested_tvar) {\n+            typ\n+        } else {\n+            self.resolve_type(typ)\n+        }\n     }\n \n     fn resolve_region(orig: ty::region) -> ty::region {\n@@ -1128,29 +1173,29 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_region_var(rid: region_vid) -> ty::region {\n-        if vec::contains(self.r_seen, rid) {\n-            self.err = some(cyclic_region(rid));\n-            ret ty::re_var(rid);\n-        } else {\n-            vec::push(self.r_seen, rid);\n-            let nde = self.infcx.get(self.infcx.rb, rid);\n-            let bounds = nde.possible_types;\n+        if !self.should(resolve_rvar) {\n+            ret ty::re_var(rid)\n+        }\n+        let nde = self.infcx.get(self.infcx.rb, rid);\n+        let bounds = nde.possible_types;\n+        alt bounds {\n+          { ub:_, lb:some(r) } => { self.assert_not_rvar(rid, r); r }\n+          { ub:some(r), lb:_ } => { self.assert_not_rvar(rid, r); r }\n+          { ub:none, lb:none } => {\n+            if self.should(force_rvar) {\n+                self.err = some(unresolved_region(rid));\n+            }\n+            ty::re_var(rid)\n+          }\n+        }\n+    }\n \n-            let r1 = alt bounds {\n-              { ub:_, lb:some(t) } { self.resolve_region(t) }\n-              { ub:some(t), lb:_ } { self.resolve_region(t) }\n-              { ub:none, lb:none } {\n-                alt self.force_vars {\n-                  force_all {\n-                    self.err = some(unresolved_region(rid));\n-                  }\n-                  _ { /* ok */ }\n-                }\n-                ty::re_var(rid)\n-              }\n-            };\n-            vec::pop(self.r_seen);\n-            ret r1;\n+    fn assert_not_rvar(rid: region_vid, r: ty::region) {\n+        alt r {\n+          ty::re_var(rid2) => {\n+            self.err = some(region_var_bound_by_region_var(rid, rid2));\n+          }\n+          _ => { }\n         }\n     }\n \n@@ -1172,15 +1217,12 @@ impl methods for resolve_state {\n             let bounds = nde.possible_types;\n \n             let t1 = alt bounds {\n-              { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve1(t) }\n-              { ub:some(t), lb:_ } { self.resolve1(t) }\n-              { ub:_, lb:some(t) } { self.resolve1(t) }\n+              { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve_type(t) }\n+              { ub:some(t), lb:_ } { self.resolve_type(t) }\n+              { ub:_, lb:some(t) } { self.resolve_type(t) }\n               { ub:none, lb:none } {\n-                alt self.force_vars {\n-                  force_ty_vars_only | force_all {\n+                if self.should(force_tvar) {\n                     self.err = some(unresolved_ty(vid));\n-                  }\n-                  force_none { /* ok */ }\n                 }\n                 ty::mk_var(tcx, vid)\n               }\n@@ -1191,6 +1233,10 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_ty_var_integral(vid: tvi_vid) -> ty::t {\n+        if !self.should(resolve_ivar) {\n+            ret ty::mk_var_integral(self.infcx.tcx, vid);\n+        }\n+\n         let nde = self.infcx.get(self.infcx.tvib, vid);\n         let pt = nde.possible_types;\n \n@@ -1199,8 +1245,7 @@ impl methods for resolve_state {\n         alt single_type_contained_in(self.infcx.tcx, pt) {\n           some(t) { t }\n           none {\n-            alt self.force_vars {\n-              force_all {\n+            if self.should(force_ivar) {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n@@ -1209,10 +1254,8 @@ impl methods for resolve_state {\n                                                            ty),\n                         nde.rank));\n                 ty\n-              }\n-              force_none | force_ty_vars_only {\n+            } else {\n                 ty::mk_var_integral(self.infcx.tcx, vid)\n-              }\n             }\n           }\n         }\n@@ -1393,15 +1436,22 @@ impl assignment for infer_ctxt {\n \n         do indent {\n             do self.sub_tys(a, nr_b).then {\n-                let r_a = ty::re_scope(anmnt.borrow_scope);\n+                // Create a fresh region variable `r_a` with the given\n+                // borrow bounds:\n+                let r_lb = ty::re_scope(anmnt.borrow_lb);\n+                let r_ub = ty::re_scope(anmnt.borrow_ub);\n+                let r_a = self.next_region_var({lb: some(r_lb),\n+                                                ub: some(r_ub)});\n+\n                 #debug[\"anmnt=%?\", anmnt];\n                 do sub(self).contraregions(r_a, r_b).chain |_r| {\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n-                    #debug[\"borrowing expression #%?\", anmnt];\n-                    let borrow = {scope_id: anmnt.borrow_scope,\n-                                  mutbl: m};\n-                    self.tcx.borrowings.insert(anmnt.expr_id, borrow);\n+                    #debug[\"borrowing expression #%?, scope=%?, m=%?\",\n+                           anmnt, r_a, m];\n+                    self.borrowings.push({expr_id: anmnt.expr_id,\n+                                          scope: r_a,\n+                                          mutbl: m});\n                     uok()\n                 }\n             }\n@@ -1921,7 +1971,7 @@ impl of combine for sub {\n                 // anything to do with the region variable that's created\n                 // for it.  The only thing we're doing with `br` here is\n                 // using it in the debug message.\n-                let rvar = self.infcx().next_region_var();\n+                let rvar = self.infcx().next_region_var_nb();\n                 #debug[\"Bound region %s maps to %s\",\n                        bound_region_to_str(self.tcx, br),\n                        region_to_str(self.tcx, rvar)];"}, {"sha": "cbcd4b31e53fc6a117e3c47fdfdc0f0fe7669064", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -43,7 +43,11 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n             #fmt(\"<alt at %s>\",\n                  codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n-          ast::expr_field(*) | ast::expr_unary(*) | ast::expr_binary(*) {\n+          ast::expr_assign_op(*) |\n+          ast::expr_field(*) |\n+          ast::expr_unary(*) |\n+          ast::expr_binary(*) |\n+          ast::expr_index(*) {\n             #fmt(\"<method at %s>\",\n                  codemap::span_to_str(expr.span, cx.sess.codemap))\n           }"}, {"sha": "5e893246cdc80ebdd8b5b712884dd7e66e753993", "filename": "src/test/compile-fail/regions-borrow.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -1,8 +0,0 @@\n-fn foo(x: &uint) -> &uint { x }\n-\n-fn main() {\n-    let p = @3u;\n-    let r = foo(p);\n-    //~^ ERROR reference is not valid\n-    assert *p == *r;\n-}"}, {"sha": "aeb864d92a7211a36652644bf4cc5d2320d92b89", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -0,0 +1,14 @@\n+type point = {x: int, y: int};\n+\n+fn x_coord(p: &point) -> &int {\n+    ret &p.x;\n+}\n+\n+fn foo(p: @point) -> &int {\n+    let xc = x_coord(p);\n+    assert *xc == 3;\n+    ret xc; //~ ERROR mismatched types: expected `&int` but found\n+}\n+\n+fn main() {}\n+"}, {"sha": "e89d801b3617885f8eab5ec786064ef3293ec4fe", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -0,0 +1,11 @@\n+fn borrow<T>(x: &T) -> &T {x}\n+\n+fn main() {\n+    let x = @3;\n+    let y: &int; //~ ERROR reference is not valid outside of its lifetime\n+    while true {\n+        y = borrow(x);\n+        assert *x == *y;\n+    }\n+    assert *x == *y;\n+}"}, {"sha": "8f71d9821fea96c27877acd79444a2abd5968104", "filename": "src/test/run-pass/regions-escape-into-other-fn.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-escape-into-other-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-escape-into-other-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-escape-into-other-fn.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -3,5 +3,5 @@ fn bar(x: &uint) -> uint { *x }\n \n fn main() {\n     let p = @3u;\n-    bar(foo(p)); //~ ERROR reference is not valid\n+    assert bar(foo(p)) == 3;\n }", "previous_filename": "src/test/compile-fail/regions-escape-into-other-fn.rs"}, {"sha": "4f3b668269a109ed61d37ad6a2988cc7f8514d08", "filename": "src/test/run-pass/regions-infer-borrow-scope-view.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -0,0 +1,9 @@\n+fn view<T>(x: &[T]) -> &[T] {x}\n+\n+fn main() {\n+    let v = ~[1, 2, 3];\n+    let x = view(v);\n+    let y = view(x);\n+    assert (v[0] == x[0]) && (v[0] == y[0]);\n+}\n+"}, {"sha": "bd51c4beca52da6f3323c27f5e002eedbd346f9c", "filename": "src/test/run-pass/regions-infer-borrow-scope-within-loop-ok.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -0,0 +1,10 @@\n+fn borrow<T>(x: &T) -> &T {x}\n+\n+fn main() {\n+    let x = @3;\n+    loop {\n+        let y = borrow(x);\n+        assert *x == *y;\n+\tbreak;\n+    }\n+}"}, {"sha": "0f099672f40b055b3a54d0ce057d51e0e965822d", "filename": "src/test/run-pass/regions-infer-borrow-scope.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef7ff8b892aa2ad7e821d8858c349e22d1197ba/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope.rs?ref=3ef7ff8b892aa2ad7e821d8858c349e22d1197ba", "patch": "@@ -0,0 +1,12 @@\n+type point = {x: int, y: int};\n+\n+fn x_coord(p: &point) -> &int {\n+    ret &p.x;\n+}\n+\n+fn main() {\n+    let p = @{x: 3, y: 4};\n+    let xc = x_coord(p);\n+    assert *xc == 3;\n+}\n+"}]}