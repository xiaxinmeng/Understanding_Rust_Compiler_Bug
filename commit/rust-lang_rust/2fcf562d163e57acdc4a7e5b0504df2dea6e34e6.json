{"sha": "2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmY2Y1NjJkMTYzZTU3YWNkYzRhN2U1YjA1MDRkZjJkZWE2ZTM0ZTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-07T00:29:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-07T23:29:38Z"}, "message": "Add an auto-slice-and-ref step to method lookup. Allows ~[T] to work with explicit self", "tree": {"sha": "7d37d4c87f9dac6b182db56745d110ea989e5687", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d37d4c87f9dac6b182db56745d110ea989e5687"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "html_url": "https://github.com/rust-lang/rust/commit/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e71081ec0368729aec8d2c077192f026f128dc81", "url": "https://api.github.com/repos/rust-lang/rust/commits/e71081ec0368729aec8d2c077192f026f128dc81", "html_url": "https://github.com/rust-lang/rust/commit/e71081ec0368729aec8d2c077192f026f128dc81"}], "stats": {"total": 118, "additions": 111, "deletions": 7}, "files": [{"sha": "a6dd65e4dc7b95fe770c720b700cf9260ccf4280", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "patch": "@@ -295,7 +295,7 @@ impl gather_loan_ctxt {\n                                              autoref.mutbl,\n                                              autoref.region)\n                     }\n-                    ty::AutoBorrowVec => {\n+                    ty::AutoBorrowVec | ty::AutoBorrowVecRef => {\n                         let cmt_index = mcx.cat_index(expr, cmt);\n                         self.guarantee_valid(cmt_index,\n                                              autoref.mutbl,"}, {"sha": "55f7dfbf956b1f13c548c2bf22e81ccedcdb3e9f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "patch": "@@ -119,7 +119,7 @@ use base::*;\n use syntax::print::pprust::{expr_to_str};\n use util::ppaux::ty_to_str;\n use util::common::indenter;\n-use ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n+use ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use callee::{AutorefArg, DoAutorefArg, DontAutorefArg};\n use middle::ty::MoveValue;\n \n@@ -202,6 +202,9 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                         AutoBorrowVec => {\n                             unpack_datum!(bcx, auto_slice(bcx, datum))\n                         }\n+                        AutoBorrowVecRef => {\n+                            unpack_datum!(bcx, auto_slice_and_ref(bcx, datum))\n+                        }\n                         AutoBorrowFn => {\n                             // currently, all closure types are\n                             // represented precisely the same, so no\n@@ -243,6 +246,11 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n+\n+    fn auto_slice_and_ref(bcx: block, datum: Datum) -> DatumBlock {\n+        let DatumBlock { bcx, datum } = auto_slice(bcx, datum);\n+        auto_ref(bcx, datum)\n+    }\n }\n \n fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {"}, {"sha": "c3500fb309ee8ae6b148d63a4145c81615bd8383", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "patch": "@@ -218,7 +218,7 @@ export DerivedMethodInfo;\n export DerivedFieldInfo;\n export AutoAdjustment;\n export AutoRef;\n-export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowFn;\n+export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn;\n export iter_bound_traits_and_supertraits;\n export count_traits_and_supertraits;\n \n@@ -352,6 +352,9 @@ enum AutoRefKind {\n     /// Convert from @[]/~[] to &[] (or str)\n     AutoBorrowVec,\n \n+    /// Convert from @[]/~[] to &&[] (or str)\n+    AutoBorrowVecRef,\n+\n     /// Convert from @fn()/~fn() to &fn()\n     AutoBorrowFn,\n }"}, {"sha": "560281765cf64ac31e9d6b4ba3a3853494658af0", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "patch": "@@ -707,19 +707,46 @@ impl LookupContext {\n             ty_evec(mt, vstore_box) |\n             ty_evec(mt, vstore_uniq) |\n             ty_evec(mt, vstore_fixed(_)) => {\n-                self.search_for_some_kind_of_autorefd_method(\n+                // First try to borrow to a slice\n+                let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_evec(tcx,\n                                       {ty:mt.ty, mutbl:m},\n-                                      vstore_slice(r)))\n+                                      vstore_slice(r)));\n+\n+                if entry.is_some() { return entry; }\n+\n+                // Then try to borrow to a slice *and* borrow a pointer.\n+                self.search_for_some_kind_of_autorefd_method(\n+                    AutoBorrowVecRef, autoderefs, [m_const, m_imm, m_mutbl],\n+                    |m,r| {\n+                        let slice_ty = ty::mk_evec(tcx,\n+                                                   {ty:mt.ty, mutbl:m},\n+                                                   vstore_slice(r));\n+                        // NB: we do not try to autoref to a mutable\n+                        // pointer. That would be creating a pointer\n+                        // to a temporary pointer (the borrowed\n+                        // slice), so any update the callee makes to\n+                        // it can't be observed.\n+                        ty::mk_rptr(tcx, r, {ty:slice_ty, mutbl:m_imm})\n+                    })\n             }\n \n             ty_estr(vstore_box) |\n             ty_estr(vstore_uniq) |\n             ty_estr(vstore_fixed(_)) => {\n-                self.search_for_some_kind_of_autorefd_method(\n+                let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [m_imm],\n-                    |_m,r| ty::mk_estr(tcx, vstore_slice(r)))\n+                    |_m,r| ty::mk_estr(tcx, vstore_slice(r)));\n+\n+                if entry.is_some() { return entry; }\n+\n+                self.search_for_some_kind_of_autorefd_method(\n+                    AutoBorrowVecRef, autoderefs, [m_imm],\n+                    |m,r| {\n+                        let slice_ty = ty::mk_estr(tcx, vstore_slice(r));\n+                        ty::mk_rptr(tcx, r, {ty:slice_ty, mutbl:m})\n+                    })\n             }\n \n             ty_trait(*) | ty_fn(*) => {"}, {"sha": "bd90f9ff0e896626d75ba9c87ae89bb4f8a6d99a", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "patch": "@@ -0,0 +1,18 @@\n+fn main() {\n+\n+    // Testing that method lookup does not automatically borrow\n+    // vectors to slices then automatically create a &mut self\n+    // reference.  That would allow creating a mutable pointer to a\n+    // temporary, which would be a source of confusion\n+\n+    let mut a = @[0];\n+    a.test_mut(); //~ ERROR type `@[int]` does not implement any method in scope named `test_mut`\n+}\n+\n+trait MyIter {\n+    pure fn test_mut(&mut self);\n+}\n+\n+impl &[int]: MyIter {\n+    pure fn test_mut(&mut self) { }\n+}"}, {"sha": "deb057f7898dcad326930a5274e5f10513c93d46", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcf562d163e57acdc4a7e5b0504df2dea6e34e6/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=2fcf562d163e57acdc4a7e5b0504df2dea6e34e6", "patch": "@@ -0,0 +1,48 @@\n+// Testing that method lookup automatically both borrows vectors to slices\n+// and also references them to create the &self pointer\n+\n+trait MyIter {\n+    pure fn test_imm(&self);\n+    pure fn test_const(&const self);\n+}\n+\n+impl &[int]: MyIter {\n+    pure fn test_imm(&self) { assert self[0] == 1 }\n+    pure fn test_const(&const self) { assert self[0] == 1 }\n+}\n+\n+impl &str: MyIter {\n+    pure fn test_imm(&self) { assert *self == \"test\" }\n+    pure fn test_const(&const self) { assert *self == \"test\" }\n+}\n+\n+fn main() {\n+    // NB: Associativity of ~, etc. in this context is surprising. These must be parenthesized\n+\n+    ([1]).test_imm();\n+    (~[1]).test_imm();\n+    (@[1]).test_imm();\n+    (&[1]).test_imm();\n+    (\"test\").test_imm();\n+    (~\"test\").test_imm();\n+    (@\"test\").test_imm();\n+    (&\"test\").test_imm();\n+\n+    // XXX: Other types of mutable vecs don't currently exist\n+    (@mut [1]).test_imm();\n+\n+    ([1]).test_const();\n+    (~[1]).test_const();\n+    (@[1]).test_const();\n+    (&[1]).test_const();\n+    (\"test\").test_const();\n+    (~\"test\").test_const();\n+    (@\"test\").test_const();\n+    (&\"test\").test_const();\n+\n+    (@mut [1]).test_const();\n+\n+    // NB: We don't do this double autoreffing for &mut self because that would\n+    // allow creating a mutable pointer to a temporary, which would be a source\n+    // of confusion\n+}"}]}