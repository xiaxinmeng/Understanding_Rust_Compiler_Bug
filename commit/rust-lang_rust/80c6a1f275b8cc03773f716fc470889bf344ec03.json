{"sha": "80c6a1f275b8cc03773f716fc470889bf344ec03", "node_id": "C_kwDOAAsO6NoAKDgwYzZhMWYyNzViOGNjMDM3NzNmNzE2ZmM0NzA4ODliZjM0NGVjMDM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-05T15:31:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-18T14:58:18Z"}, "message": "Rustfmt resolve_implementation.", "tree": {"sha": "ed677438d49932d93d56d90ab5ccf9e8245ce979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed677438d49932d93d56d90ab5ccf9e8245ce979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80c6a1f275b8cc03773f716fc470889bf344ec03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80c6a1f275b8cc03773f716fc470889bf344ec03", "html_url": "https://github.com/rust-lang/rust/commit/80c6a1f275b8cc03773f716fc470889bf344ec03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80c6a1f275b8cc03773f716fc470889bf344ec03/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "228def7e2077cbd34931f48006dbb809304ff708", "url": "https://api.github.com/repos/rust-lang/rust/commits/228def7e2077cbd34931f48006dbb809304ff708", "html_url": "https://github.com/rust-lang/rust/commit/228def7e2077cbd34931f48006dbb809304ff708"}], "stats": {"total": 96, "additions": 57, "deletions": 39}, "files": [{"sha": "8d454aeff99efafb1b01b1904a1a89cb3d4ddd08", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 57, "deletions": 39, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/80c6a1f275b8cc03773f716fc470889bf344ec03/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6a1f275b8cc03773f716fc470889bf344ec03/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=80c6a1f275b8cc03773f716fc470889bf344ec03", "patch": "@@ -2112,50 +2112,68 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, binder: item_id, kind: LifetimeBinderKind::ImplBlock }, |this| {\n-            // Dummy self type for better errors if `Self` is used in the trait path.\n-            this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n-                this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter(item_id), |this| {\n-                    // Resolve the trait reference, if necessary.\n-                    this.with_optional_trait_ref(opt_trait_reference.as_ref(), self_type, |this, trait_id| {\n-                        let item_def_id = this.r.local_def_id(item_id);\n-\n-                        // Register the trait definitions from here.\n-                        if let Some(trait_id) = trait_id {\n-                            this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n-                        }\n-\n-                        let item_def_id = item_def_id.to_def_id();\n-                        let res =\n-                            Res::SelfTy { trait_: trait_id, alias_to: Some((item_def_id, false)) };\n-                        this.with_self_rib(res, |this| {\n-                            if let Some(trait_ref) = opt_trait_reference.as_ref() {\n-                                // Resolve type arguments in the trait path.\n-                                visit::walk_trait_ref(this, trait_ref);\n-                            }\n-                            // Resolve the self type.\n-                            this.visit_ty(self_type);\n-                            // Resolve the generic parameters.\n-                            this.visit_generics(generics);\n+        self.with_generic_param_rib(\n+            &generics.params,\n+            ItemRibKind(HasGenericParams::Yes),\n+            LifetimeRibKind::Generics {\n+                span: generics.span,\n+                binder: item_id,\n+                kind: LifetimeBinderKind::ImplBlock\n+            },\n+            |this| {\n+                // Dummy self type for better errors if `Self` is used in the trait path.\n+                this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousCreateParameter(item_id),\n+                        |this| {\n+                            // Resolve the trait reference, if necessary.\n+                            this.with_optional_trait_ref(\n+                                opt_trait_reference.as_ref(),\n+                                self_type,\n+                                |this, trait_id| {\n+                                    let item_def_id = this.r.local_def_id(item_id);\n+\n+                                    // Register the trait definitions from here.\n+                                    if let Some(trait_id) = trait_id {\n+                                        this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n+                                    }\n \n-                            // Resolve the items within the impl.\n-                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id,false),\n-                                |this| {\n-                                    this.with_current_self_type(self_type, |this| {\n-                                        this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n-                                            debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                            for item in impl_items {\n-                                                this.resolve_impl_item(&**item);\n-                                            }\n-                                        });\n+                                    let item_def_id = item_def_id.to_def_id();\n+                                    let res = Res::SelfTy {\n+                                        trait_: trait_id,\n+                                        alias_to: Some((item_def_id, false)),\n+                                    };\n+                                    this.with_self_rib(res, |this| {\n+                                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                                            // Resolve type arguments in the trait path.\n+                                            visit::walk_trait_ref(this, trait_ref);\n+                                        }\n+                                        // Resolve the self type.\n+                                        this.visit_ty(self_type);\n+                                        // Resolve the generic parameters.\n+                                        this.visit_generics(generics);\n+\n+                                        // Resolve the items within the impl.\n+                                        this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id,false),\n+                                            |this| {\n+                                                this.with_current_self_type(self_type, |this| {\n+                                                    this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                                        debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n+                                                        for item in impl_items {\n+                                                            this.resolve_impl_item(&**item);\n+                                                        }\n+                                                    });\n+                                                });\n+                                            },\n+                                        );\n                                     });\n                                 },\n                             );\n-                        });\n-                    });\n+                        },\n+                    );\n                 });\n-            });\n-        });\n+            },\n+        );\n     }\n \n     fn resolve_impl_item(&mut self, item: &'ast AssocItem) {"}]}