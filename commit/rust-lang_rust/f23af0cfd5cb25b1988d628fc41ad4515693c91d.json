{"sha": "f23af0cfd5cb25b1988d628fc41ad4515693c91d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyM2FmMGNmZDVjYjI1YjE5ODhkNjI4ZmM0MWFkNDUxNTY5M2M5MWQ=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-14T15:14:54Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-14T15:14:54Z"}, "message": "changed const to consts to avoid  keyword, added test, fixed a lot of bugs", "tree": {"sha": "9989391e76c1c86732f2a45b8cb49122e8585265", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9989391e76c1c86732f2a45b8cb49122e8585265"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23af0cfd5cb25b1988d628fc41ad4515693c91d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23af0cfd5cb25b1988d628fc41ad4515693c91d", "html_url": "https://github.com/rust-lang/rust/commit/f23af0cfd5cb25b1988d628fc41ad4515693c91d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23af0cfd5cb25b1988d628fc41ad4515693c91d/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6aa36e9deb9191ae8414b433d49c71ac37475cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa36e9deb9191ae8414b433d49c71ac37475cea", "html_url": "https://github.com/rust-lang/rust/commit/6aa36e9deb9191ae8414b433d49c71ac37475cea"}], "stats": {"total": 214, "additions": 133, "deletions": 81}, "files": [{"sha": "c8d5262abab7a995004aabaed8d095d7481851c0", "filename": "src/consts.rs", "status": "renamed", "additions": 121, "deletions": 81, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f23af0cfd5cb25b1988d628fc41ad4515693c91d/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23af0cfd5cb25b1988d628fc41ad4515693c91d/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=f23af0cfd5cb25b1988d628fc41ad4515693c91d", "patch": "@@ -1,8 +1,21 @@\n+#[cfg(test)]\n use rustc::lint::Context;\n+\n use rustc::middle::const_eval::lookup_const_by_id;\n+use rustc::middle::def::PathResolution;\n+use rustc::middle::def::Def::*;\n use syntax::ast::*;\n+use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use std::rc::Rc;\n+use std::ops::Deref;\n+use self::ConstantVariant::*;\n+use self::FloatWidth::*;\n+\n+#[cfg(not(test))]\n+pub struct Context;\n \n+#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n pub enum FloatWidth {\n     Fw32,\n     Fw64,\n@@ -25,20 +38,31 @@ pub struct Constant {\n }\n \n impl Constant {\n-    fn new(variant: ConstantVariant) -> Constant {\n+    pub fn new(variant: ConstantVariant) -> Constant {\n         Constant { constant: variant, needed_resolution: false }\n     }\n \n-    fn new_resolved(variant: ConstantVariant) -> Constant {\n+    pub fn new_resolved(variant: ConstantVariant) -> Constant {\n         Constant { constant: variant, needed_resolution: true }\n     }\n+\n+    // convert this constant to a f64, if possible\n+    pub fn as_float(&self) -> Option<f64> {\n+        match &self.constant {\n+            &ConstantByte(b) => Some(b as f64),\n+            &ConstantFloat(ref s, _) => s.parse().ok(),\n+            &ConstantInt(i, ty) => Some(if is_negative(ty) {\n+                -(i as f64) } else { i as f64 }),\n+            _ => None\n+        }\n+    }\n }\n \n /// a Lit_-like enum to fold constant `Expr`s into\n #[derive(PartialEq, Eq, Debug, Clone)]\n pub enum ConstantVariant {\n     /// a String \"abc\"\n-    ConstantStr(&'static str, StrStyle),\n+    ConstantStr(String, StrStyle),\n     /// a Binary String b\"abc\"\n     ConstantBinary(Rc<Vec<u8>>),\n     /// a single byte b'a'\n@@ -48,15 +72,15 @@ pub enum ConstantVariant {\n     /// an integer\n     ConstantInt(u64, LitIntType),\n     /// a float with given type\n-    ConstantFloat(Cow<'static, str>, FloatWidth),\n+    ConstantFloat(String, FloatWidth),\n     /// true or false\n     ConstantBool(bool),\n     /// an array of constants\n-    ConstantVec(Vec<Constant>),\n+    ConstantVec(Box<Vec<Constant>>),\n     /// also an array, but with only one constant, repeated N times\n-    ConstantRepeat(Constant, usize),\n+    ConstantRepeat(Box<ConstantVariant>, usize),\n     /// a tuple of constants\n-    ConstantTuple(Vec<Constant>),\n+    ConstantTuple(Box<Vec<Constant>>),\n }\n \n impl ConstantVariant {\n@@ -76,132 +100,142 @@ impl ConstantVariant {\n \n /// simple constant folding: Insert an expression, get a constant or none.\n pub fn constant(cx: &Context, e: &Expr) -> Option<Constant> {\n-    match e {\n+    match &e.node {\n         &ExprParen(ref inner) => constant(cx, inner),\n         &ExprPath(_, _) => fetch_path(cx, e),\n-        &ExprBlock(ref block) => constant_block(cx, inner),\n+        &ExprBlock(ref block) => constant_block(cx, block),\n         &ExprIf(ref cond, ref then, ref otherwise) =>\n-            constant_if(cx, cond, then, otherwise),\n-        &ExprLit(ref lit) => Some(lit_to_constant(lit)),\n-        &ExprVec(ref vec) => constant_vec(cx, vec),\n-        &ExprTup(ref tup) => constant_tup(cx, tup),\n+            constant_if(cx, &*cond, &*then, &*otherwise),\n+        &ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+        &ExprVec(ref vec) => constant_vec(cx, &vec[..]),\n+        &ExprTup(ref tup) => constant_tup(cx, &tup[..]),\n         &ExprRepeat(ref value, ref number) =>\n-            constant_binop_apply(cx, value, number,|v, n| Constant {\n-                constant: ConstantRepeat(v, n.constant.as_u64()),\n-                needed_resolution: v.needed_resolution || n.needed_resolution\n-            }),\n+            constant_binop_apply(cx, value, number,|v, n|\n+                Some(ConstantRepeat(Box::new(v), n.as_u64() as usize))),\n         &ExprUnary(op, ref operand) => constant(cx, operand).and_then(\n             |o| match op {\n                 UnNot =>\n-                    if let ConstantBool(b) = o.variant {\n+                    if let ConstantBool(b) = o.constant {\n                         Some(Constant{\n                             needed_resolution: o.needed_resolution,\n                             constant: ConstantBool(!b),\n                         })\n                     } else { None },\n                 UnNeg => constant_negate(o),\n-                UnUniq | UnDeref => o,\n+                UnUniq | UnDeref => Some(o),\n             }),\n         &ExprBinary(op, ref left, ref right) =>\n-            constant_binop(op, left, right),\n+            constant_binop(cx, op, left, right),\n         //TODO: add other expressions\n         _ => None,\n     }\n }\n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match lit {\n-        &LitStr(ref is, style) => Constant::new(ConstantStr(&*is, style)),\n+        &LitStr(ref is, style) =>\n+            Constant::new(ConstantStr(is.to_string(), style)),\n         &LitBinary(ref blob) => Constant::new(ConstantBinary(blob.clone())),\n         &LitByte(b) => Constant::new(ConstantByte(b)),\n         &LitChar(c) => Constant::new(ConstantChar(c)),\n         &LitInt(value, ty) => Constant::new(ConstantInt(value, ty)),\n-        &LitFloat(ref is, ty) =>\n-            Constant::new(ConstantFloat(Cow::Borrowed(&*is), ty.into())),\n-        &LitFloatUnsuffixed(InternedString) =>\n-            Constant::new(ConstantFloat(Cow::Borrowed(&*is), FwAny)),\n+        &LitFloat(ref is, ty) => {\n+            Constant::new(ConstantFloat(is.to_string(), ty.into()))\n+        },\n+        &LitFloatUnsuffixed(ref is) => {\n+            Constant::new(ConstantFloat(is.to_string(), FwAny))\n+        },\n         &LitBool(b) => Constant::new(ConstantBool(b)),\n     }\n }\n \n /// create `Some(ConstantVec(..))` of all constants, unless there is any\n /// non-constant part\n-fn constant_vec(cx: &Context, vec: &[&Expr]) -> Option<Constant> {\n+fn constant_vec<E: Deref<Target=Expr> + Sized>(cx: &Context, vec: &[E]) -> Option<Constant> {\n     let mut parts = Vec::new();\n     let mut resolved = false;\n-    for opt_part in vec {\n+    for opt_part in vec.iter() {\n         match constant(cx, opt_part) {\n-            Some(ref p) => {\n-                resolved |= p.needed_resolution;\n+            Some(p) => {\n+                resolved |= (&p).needed_resolution;\n                 parts.push(p)\n             },\n             None => { return None; },\n         }\n     }\n     Some(Constant {\n-        constant: ConstantVec(parts),\n+        constant: ConstantVec(Box::new(parts)),\n         needed_resolution: resolved\n     })\n }\n \n-fn constant_tup(cx: &Context, tup: &[&Expr]) -> Option<Constant> {\n+fn constant_tup<E: Deref<Target=Expr> + Sized>(cx: &Context, tup: &[E]) -> Option<Constant> {\n     let mut parts = Vec::new();\n     let mut resolved = false;\n-    for opt_part in vec {\n+    for opt_part in tup.iter() {\n         match constant(cx, opt_part) {\n-            Some(ref p) => {\n-                resolved |= p.needed_resolution;\n+            Some(p) => {\n+                resolved |= (&p).needed_resolution;\n                 parts.push(p)\n             },\n             None => { return None; },\n         }\n     }\n     Some(Constant {\n-        constant: ConstantTuple(parts),\n+        constant: ConstantTuple(Box::new(parts)),\n         needed_resolution: resolved\n     })\n }\n \n+#[cfg(test)]\n+fn fetch_path(_cx: &Context, _expr: &Expr) -> Option<Constant> { None }\n+\n /// lookup a possibly constant expression from a ExprPath\n+#[cfg(not(test))]\n fn fetch_path(cx: &Context, e: &Expr) -> Option<Constant> {\n     if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n             cx.tcx.def_map.borrow().get(&e.id) {\n-        lookup_const_by_id(cx.tcx, id, None).map(\n-            |l| Constant::new_resolved(constant(cx, l).constant))\n+        lookup_const_by_id(cx.tcx, id, None).and_then(\n+            |l| constant(cx, l).map(|c| Constant::new_resolved(c.constant)))\n     } else { None }\n }\n \n /// A block can only yield a constant if it only has one constant expression\n fn constant_block(cx: &Context, block: &Block) -> Option<Constant> {\n     if block.stmts.is_empty() {\n-        block.expr.map(|b| constant(cx, b))\n+        block.expr.as_ref().and_then(|b| constant(cx, &*b))\n     } else { None }\n }\n \n-fn constant_if(cx: &Context, cond: &Expr, then: &Expr, otherwise: &Expr) ->\n-        Option<Constant> {\n+fn constant_if(cx: &Context, cond: &Expr, then: &Block, otherwise:\n+        &Option<P<Expr>>) -> Option<Constant> {\n     if let Some(Constant{ constant: ConstantBool(b), needed_resolution: res }) =\n             constant(cx, cond) {\n-        let part = constant(cx, if b { then } else { otherwise });\n-        Some(Constant {\n-            constant: part.constant,\n-            needed_resolution: res || part.needed_resolution,\n-        })\n+        if b {\n+            constant_block(cx, then)\n+        } else {\n+            otherwise.as_ref().and_then(|expr| constant(cx, &*expr))\n+        }.map(|part|\n+            Constant {\n+                constant: part.constant,\n+                needed_resolution: res || part.needed_resolution,\n+            })\n     } else { None }\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n     Some(Constant{\n         needed_resolution: o.needed_resolution,\n         constant: match o.constant {\n-            &ConstantInt(value, ty) =>\n+            ConstantInt(value, ty) =>\n                 ConstantInt(value, match ty {\n                     SignedIntLit(ity, sign) =>\n                         SignedIntLit(ity, neg_sign(sign)),\n                     UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n                     _ => { return None; },\n                 }),\n-            &LitFloat(ref is, ref ty) => ConstantFloat(neg_float_str(is), ty),\n+            ConstantFloat(ref is, ty) =>\n+                ConstantFloat(neg_float_str(is.to_string()), ty),\n             _ => { return None; },\n         }\n     })\n@@ -214,11 +248,11 @@ fn neg_sign(s: Sign) -> Sign {\n     }\n }\n \n-fn neg_float_str(s: &InternedString) -> Cow<'static, str> {\n-    if s.startsWith('-') {\n-        Cow::Borrowed(s[1..])\n+fn neg_float_str(s: String) -> String {\n+    if s.starts_with('-') {\n+        s[1..].to_owned()\n     } else {\n-        Cow::Owned(format!(\"-{}\", &*s))\n+        format!(\"-{}\", &*s)\n     }\n }\n \n@@ -229,19 +263,19 @@ fn is_negative(ty: LitIntType) -> bool {\n     }\n }\n \n-fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option(LitIntType) {\n+fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n     match (l, r) {\n         (SignedIntLit(lty, _), SignedIntLit(rty, _)) => if lty == rty {\n             Some(SignedIntLit(lty, s)) } else { None },\n         (UnsignedIntLit(lty), UnsignedIntLit(rty)) =>\n-            if Sign == Plus && lty == rty {\n+            if s == Plus && lty == rty {\n                 Some(UnsignedIntLit(lty))\n             } else { None },\n-        (UnsuffixedIntLit(_), UnsuffixedIntLit(_)) => UnsuffixedIntLit(s),\n-        (SignedIntLit(lty, _), UnsuffixedIntLit(_)) => SignedIntLit(lty, s),\n+        (UnsuffixedIntLit(_), UnsuffixedIntLit(_)) => Some(UnsuffixedIntLit(s)),\n+        (SignedIntLit(lty, _), UnsuffixedIntLit(_)) => Some(SignedIntLit(lty, s)),\n         (UnsignedIntLit(lty), UnsuffixedIntLit(rs)) => if rs == Plus {\n             Some(UnsignedIntLit(lty)) } else { None },\n-        (UnsuffixedIntLit(_), SignedIntLit(rty, _)) => SignedIntLit(rty, s),\n+        (UnsuffixedIntLit(_), SignedIntLit(rty, _)) => Some(SignedIntLit(rty, s)),\n         (UnsuffixedIntLit(ls), UnsignedIntLit(rty)) => if ls == Plus {\n             Some(UnsignedIntLit(rty)) } else { None },\n         _ => None,\n@@ -312,45 +346,51 @@ fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr)\n }\n \n fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) ->\n-        Some(Constant) {\n+        Option<ConstantVariant> {\n     if neg > pos {\n         unify_int_type(nty, pty, Minus).map(|ty| ConstantInt(neg - pos, ty))\n     } else {\n         unify_int_type(nty, pty, Plus).map(|ty| ConstantInt(pos - neg, ty))\n     }\n }\n \n-fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: Bool) ->\n-        Option<Constant> {\n+fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) ->\n+        Option<ConstantVariant> {\n      unify_int_type(lty, rty, if neg { Minus } else { Plus }).and_then(\n-        |ty| l64.checked_sub(r64).map(|v| ConstantInt(v, ty)))\n+        |ty| l.checked_sub(r).map(|v| ConstantInt(v, ty)))\n }\n \n fn constant_binop_apply<F>(cx: &Context, left: &Expr, right: &Expr, op: F)\n         -> Option<Constant>\n-where F: FnMut(ConstantVariant, ConstantVariant) -> Option<ConstantVariant> {\n-    constant(cx, left).and_then(|l| constant(cx, right).and_then(\n-        |r| Constant {\n-            needed_resolution: l.needed_resolution || r.needed_resolution,\n-            constant: op(l.constant, r.constant)\n-        }))\n+where F: Fn(ConstantVariant, ConstantVariant) -> Option<ConstantVariant> {\n+    if let (Some(Constant { constant: lc, needed_resolution: ln }),\n+            Some(Constant { constant: rc, needed_resolution: rn })) =\n+            (constant(cx, left), constant(cx, right)) {\n+        op(lc, rc).map(|c|\n+            Constant {\n+                needed_resolution: ln || rn,\n+                constant: c,\n+            })\n+    } else { None }\n }\n \n fn constant_short_circuit(cx: &Context, left: &Expr, right: &Expr, b: bool) ->\n         Option<Constant> {\n-    let leftconst = constant(cx, left);\n-    if let ConstantBool(lbool) = leftconst.constant {\n-        if l == b {\n-            Some(leftconst)\n-        } else {\n-            let rightconst = constant(cx, right);\n-            if let ConstantBool(rbool) = rightconst.constant {\n-                Some(Constant {\n-                    constant: rightconst.constant,\n-                    needed_resolution: leftconst.needed_resolution ||\n-                                       rightconst.needed_resolution,\n-                })\n-            } else { None }\n-        }\n-    } else { None }\n+    constant(cx, left).and_then(|left|\n+        if let &ConstantBool(lbool) = &left.constant {\n+            if lbool == b {\n+                Some(left)\n+            } else {\n+                constant(cx, right).and_then(|right|\n+                    if let ConstantBool(_) = right.constant {\n+                        Some(Constant {\n+                            constant: right.constant,\n+                            needed_resolution: left.needed_resolution ||\n+                                               right.needed_resolution,\n+                        })\n+                    } else { None }\n+                )\n+            }\n+        } else { None }\n+    )\n }", "previous_filename": "src/const.rs"}, {"sha": "8e7cc096c5efd49ce2dee5b8796832a1c76b43d3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f23af0cfd5cb25b1988d628fc41ad4515693c91d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23af0cfd5cb25b1988d628fc41ad4515693c91d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f23af0cfd5cb25b1988d628fc41ad4515693c91d", "patch": "@@ -15,6 +15,7 @@ use rustc::lint::LintPassObject;\n \n #[macro_use]\n pub mod utils;\n+pub mod consts;\n pub mod types;\n pub mod misc;\n pub mod eq_op;"}, {"sha": "edbbfa1e2dbc6c4c0fdc8bffad43a6173fd5bd9b", "filename": "tests/consts.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f23af0cfd5cb25b1988d628fc41ad4515693c91d/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23af0cfd5cb25b1988d628fc41ad4515693c91d/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=f23af0cfd5cb25b1988d628fc41ad4515693c91d", "patch": "@@ -0,0 +1,11 @@\n+\n+extern crate clippy;\n+\n+use clippy::consts;\n+use syntax::ast::*;\n+\n+#[test]\n+fn test_lit() {\n+    assert_eq!(ConstantBool(true), constant(&Context,\n+        Expr{ node_id: 1, node: ExprLit(LitBool(true)), span: default() }));\n+}"}]}