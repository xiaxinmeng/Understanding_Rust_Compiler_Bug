{"sha": "dbb9c99911a72bcfdb590472493126c4f1924a1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYjljOTk5MTFhNzJiY2ZkYjU5MDQ3MjQ5MzEyNmM0ZjE5MjRhMWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:29:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:55:59Z"}, "message": "rollup merge of #18544 : whataloadofwhat/json", "tree": {"sha": "17c419ddee12e36b9fc1d43959c4b8e723cced85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17c419ddee12e36b9fc1d43959c4b8e723cced85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbb9c99911a72bcfdb590472493126c4f1924a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb9c99911a72bcfdb590472493126c4f1924a1d", "html_url": "https://github.com/rust-lang/rust/commit/dbb9c99911a72bcfdb590472493126c4f1924a1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbb9c99911a72bcfdb590472493126c4f1924a1d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee5d2383894944dcbb3b72a130ed0abaef0e8951", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee5d2383894944dcbb3b72a130ed0abaef0e8951", "html_url": "https://github.com/rust-lang/rust/commit/ee5d2383894944dcbb3b72a130ed0abaef0e8951"}, {"sha": "ab9a1b7d60495ba3652f770305888d6f166c39fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9a1b7d60495ba3652f770305888d6f166c39fe", "html_url": "https://github.com/rust-lang/rust/commit/ab9a1b7d60495ba3652f770305888d6f166c39fe"}], "stats": {"total": 56, "additions": 39, "deletions": 17}, "files": [{"sha": "e0d436f5e0eb60bc82b56b603a1371bcf12df676", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dbb9c99911a72bcfdb590472493126c4f1924a1d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb9c99911a72bcfdb590472493126c4f1924a1d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=dbb9c99911a72bcfdb590472493126c4f1924a1d", "patch": "@@ -203,6 +203,7 @@ use std::num::{FPNaN, FPInfinite};\n use std::str::ScalarValue;\n use std::string;\n use std::vec::Vec;\n+use std::ops;\n \n use Encodable;\n \n@@ -889,17 +890,17 @@ impl Json {\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &string::String) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n-            &Object(ref map) => map.find(key),\n+            &Object(ref map) => map.find_with(|s| key.cmp(&s.as_slice())),\n             _ => None\n         }\n     }\n \n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&string::String]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -913,20 +914,19 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &string::String) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n-                match map.find(key) {\n+                match map.find_with(|s| key.cmp(&s.as_slice())) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n-                        let mut value : Option<&'a Json> = None;\n                         for (_, v) in map.iter() {\n-                            value = v.search(key);\n-                            if value.is_some() {\n-                                break;\n+                            match v.search(key) {\n+                                x if x.is_some() => return x,\n+                                _ => ()\n                             }\n                         }\n-                        value\n+                        None\n                     }\n                 }\n             },\n@@ -1068,6 +1068,21 @@ impl Json {\n     }\n }\n \n+impl<'a> ops::Index<&'a str, Json>  for Json {\n+    fn index<'a>(&'a self, idx: & &str) -> &'a Json {\n+        self.find(*idx).unwrap()\n+    }\n+}\n+\n+impl ops::Index<uint, Json> for Json {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n+        match self {\n+            &List(ref v) => v.index(idx),\n+            _ => panic!(\"can only index Json with uint if it is a list\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[deriving(PartialEq, Clone, Show)]\n pub enum JsonEvent {\n@@ -3089,26 +3104,33 @@ mod tests {\n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&\"dog\".to_string());\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cat\");\n+        let found_str = json_value.find(\"dog\");\n+        assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&\"dog\".to_string(),\n-                                             &\"cat\".to_string(), &\"mouse\".to_string()]);\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cheese\");\n+        let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n+        assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&\"mouse\".to_string()).and_then(|j| j.as_string());\n-        assert!(found_str.is_some());\n+        let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n         assert!(found_str.unwrap() == \"cheese\");\n     }\n \n+    #[test]\n+    fn test_index(){\n+        let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n+        let ref list = json_value[\"animals\"];\n+        assert_eq!(list[0].as_string().unwrap(), \"dog\");\n+        assert_eq!(list[1].as_string().unwrap(), \"cat\");\n+        assert_eq!(list[2].as_string().unwrap(), \"mouse\");\n+    }\n+\n     #[test]\n     fn test_is_object(){\n         let json_value = from_str(\"{}\").unwrap();"}]}