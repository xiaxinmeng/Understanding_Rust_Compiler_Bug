{"sha": "6438ef9aa3eec59f413e89278519df38646baeb0", "node_id": "C_kwDOAAsO6NoAKDY0MzhlZjlhYTNlZWM1OWY0MTNlODkyNzg1MTlkZjM4NjQ2YmFlYjA", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-13T11:34:07Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-13T11:51:10Z"}, "message": "internal: Bring back JodChild into flychecking for cancellation", "tree": {"sha": "8ec49e6d26da0a9021c9f431fa264d535f75e3ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ec49e6d26da0a9021c9f431fa264d535f75e3ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6438ef9aa3eec59f413e89278519df38646baeb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6438ef9aa3eec59f413e89278519df38646baeb0", "html_url": "https://github.com/rust-lang/rust/commit/6438ef9aa3eec59f413e89278519df38646baeb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6438ef9aa3eec59f413e89278519df38646baeb0/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7db73875ac0d9280ae93b14232249d9c1496583a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db73875ac0d9280ae93b14232249d9c1496583a", "html_url": "https://github.com/rust-lang/rust/commit/7db73875ac0d9280ae93b14232249d9c1496583a"}], "stats": {"total": 175, "additions": 114, "deletions": 61}, "files": [{"sha": "4ff49cc80539663ab70ab3d742d2bb77ac92eea0", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=6438ef9aa3eec59f413e89278519df38646baeb0", "patch": "@@ -2,12 +2,16 @@\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n \n-use std::{fmt, io, process::Command, time::Duration};\n+use std::{\n+    fmt, io,\n+    process::{ChildStderr, ChildStdout, Command, Stdio},\n+    time::Duration,\n+};\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n use serde::Deserialize;\n-use stdx::process::streaming_output;\n+use stdx::{process::streaming_output, JodChild};\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n@@ -117,7 +121,7 @@ struct FlycheckActor {\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n     workspace_root: AbsPathBuf,\n-    /// WatchThread exists to wrap around the communication needed to be able to\n+    /// CargoHandle exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n@@ -153,14 +157,24 @@ impl FlycheckActor {\n         while let Some(event) = self.next_event(&inbox) {\n             match event {\n                 Event::Restart(Restart) => {\n+                    // Drop and cancel the previously spawned process\n+                    self.cargo_handle.take();\n                     while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n \n                     self.cancel_check_process();\n \n                     let command = self.check_command();\n-                    tracing::info!(\"restart flycheck {:?}\", command);\n-                    self.cargo_handle = Some(CargoHandle::spawn(command));\n-                    self.progress(Progress::DidStart);\n+                    let command_f = format!(\"restart flycheck {command:?}\");\n+                    match CargoHandle::spawn(command) {\n+                        Ok(cargo_handle) => {\n+                            tracing::info!(\"{}\", command_f);\n+                            self.cargo_handle = Some(cargo_handle);\n+                            self.progress(Progress::DidStart);\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\"{command_f} failed: {e:?}\",);\n+                        }\n+                    }\n                 }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n@@ -249,37 +263,58 @@ impl FlycheckActor {\n     }\n }\n \n+/// A handle to a cargo process used for fly-checking.\n struct CargoHandle {\n-    thread: jod_thread::JoinHandle<io::Result<()>>,\n+    /// The handle to the actual cargo process. As we cannot cancel directly from with\n+    /// a read syscall dropping and therefor terminating the process is our best option.\n+    child: JodChild,\n+    thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n impl CargoHandle {\n-    fn spawn(command: Command) -> CargoHandle {\n+    fn spawn(mut command: Command) -> std::io::Result<CargoHandle> {\n+        command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n+        let mut child = JodChild::spawn(command)?;\n+\n+        let stdout = child.stdout.take().unwrap();\n+        let stderr = child.stderr.take().unwrap();\n+\n         let (sender, receiver) = unbounded();\n-        let actor = CargoActor::new(sender);\n+        let actor = CargoActor::new(sender, stdout, stderr);\n         let thread = jod_thread::Builder::new()\n             .name(\"CargoHandle\".to_owned())\n-            .spawn(move || actor.run(command))\n+            .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");\n-        CargoHandle { thread, receiver }\n+        Ok(CargoHandle { child, thread, receiver })\n     }\n \n     fn join(self) -> io::Result<()> {\n-        self.thread.join()\n+        let exit_status = self.child.wait()?;\n+        let (read_at_least_one_message, error) = self.thread.join()?;\n+        if read_at_least_one_message || exit_status.success() {\n+            Ok(())\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::Other, format!(\n+                \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n+                exit_status, error\n+            )))\n+        }\n     }\n }\n \n struct CargoActor {\n     sender: Sender<CargoMessage>,\n+    stdout: ChildStdout,\n+    stderr: ChildStderr,\n }\n \n impl CargoActor {\n-    fn new(sender: Sender<CargoMessage>) -> CargoActor {\n-        CargoActor { sender }\n+    fn new(sender: Sender<CargoMessage>, stdout: ChildStdout, stderr: ChildStderr) -> CargoActor {\n+        CargoActor { sender, stdout, stderr }\n     }\n \n-    fn run(self, command: Command) -> io::Result<()> {\n+    fn run(self) -> io::Result<(bool, String)> {\n         // We manually read a line at a time, instead of using serde's\n         // stream deserializers, because the deserializer cannot recover\n         // from an error, resulting in it getting stuck, because we try to\n@@ -292,7 +327,8 @@ impl CargoActor {\n         let mut error = String::new();\n         let mut read_at_least_one_message = false;\n         let output = streaming_output(\n-            command,\n+            self.stdout,\n+            self.stderr,\n             &mut |line| {\n                 read_at_least_one_message = true;\n \n@@ -325,14 +361,7 @@ impl CargoActor {\n             },\n         );\n         match output {\n-            Ok(_) if read_at_least_one_message => Ok(()),\n-            Ok(output) if output.status.success() => Ok(()),\n-            Ok(output)  => {\n-                Err(io::Error::new(io::ErrorKind::Other, format!(\n-                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n-                    output.status, error\n-                )))\n-            }\n+            Ok(_) => Ok((read_at_least_one_message, error)),\n             Err(e) => Err(io::Error::new(e.kind(), format!(\"{:?}: {}\", e, error))),\n         }\n     }"}, {"sha": "ee7f8339a76a1f3f73f990c91e6de37db9f80988", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=6438ef9aa3eec59f413e89278519df38646baeb0", "patch": "@@ -110,7 +110,7 @@ impl WorkspaceBuildScripts {\n         };\n \n         tracing::info!(\"Running build scripts: {:?}\", cmd);\n-        let output = stdx::process::streaming_output(\n+        let output = stdx::process::spawn_with_streaming_output(\n             cmd,\n             &mut |line| {\n                 // Copy-pasted from existing cargo_metadata. It seems like we"}, {"sha": "c52601898d787233bd7b3a1f4e7c7219afe995cf", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=6438ef9aa3eec59f413e89278519df38646baeb0", "patch": "@@ -1,5 +1,6 @@\n //! Missing batteries for standard libraries.\n use std::iter;\n+use std::process::Command;\n use std::{cmp::Ordering, ops, time::Instant};\n \n mod macros;\n@@ -132,6 +133,7 @@ pub fn defer<F: FnOnce()>(f: F) -> impl Drop {\n     D(Some(f))\n }\n \n+/// A [`std::process::Child`] wrapper that will kill the child on drop.\n #[cfg_attr(not(target_arch = \"wasm32\"), repr(transparent))]\n #[derive(Debug)]\n pub struct JodChild(pub std::process::Child);\n@@ -157,6 +159,16 @@ impl Drop for JodChild {\n }\n \n impl JodChild {\n+    pub fn spawn(mut command: Command) -> std::io::Result<Self> {\n+        command.spawn().map(Self)\n+    }\n+\n+    pub fn wait(self) -> std::io::Result<std::process::ExitStatus> {\n+        let mut inner = self.into_inner();\n+        let _ = inner.kill();\n+        inner.wait()\n+    }\n+\n     pub fn into_inner(self) -> std::process::Child {\n         if cfg!(target_arch = \"wasm32\") {\n             panic!(\"no processes on wasm\");"}, {"sha": "e5aa3436518762d393fab6a601da6d06c996813a", "filename": "crates/stdx/src/process.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fstdx%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6438ef9aa3eec59f413e89278519df38646baeb0/crates%2Fstdx%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fprocess.rs?ref=6438ef9aa3eec59f413e89278519df38646baeb0", "patch": "@@ -5,54 +5,66 @@\n \n use std::{\n     io,\n-    process::{Command, Output, Stdio},\n+    process::{ChildStderr, ChildStdout, Command, Output, Stdio},\n };\n \n+use crate::JodChild;\n+\n pub fn streaming_output(\n-    mut cmd: Command,\n+    out: ChildStdout,\n+    err: ChildStderr,\n     on_stdout_line: &mut dyn FnMut(&str),\n     on_stderr_line: &mut dyn FnMut(&str),\n-) -> io::Result<Output> {\n+) -> io::Result<(Vec<u8>, Vec<u8>)> {\n     let mut stdout = Vec::new();\n     let mut stderr = Vec::new();\n \n-    let cmd = cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n-\n-    let status = {\n-        let mut child = cmd.spawn()?;\n-        let out = child.stdout.take().unwrap();\n-        let err = child.stderr.take().unwrap();\n-        imp::read2(out, err, &mut |is_out, data, eof| {\n-            let idx = if eof {\n-                data.len()\n-            } else {\n-                match data.iter().rposition(|b| *b == b'\\n') {\n-                    Some(i) => i + 1,\n-                    None => return,\n-                }\n+    imp::read2(out, err, &mut |is_out, data, eof| {\n+        let idx = if eof {\n+            data.len()\n+        } else {\n+            match data.iter().rposition(|b| *b == b'\\n') {\n+                Some(i) => i + 1,\n+                None => return,\n+            }\n+        };\n+        {\n+            // scope for new_lines\n+            let new_lines = {\n+                let dst = if is_out { &mut stdout } else { &mut stderr };\n+                let start = dst.len();\n+                let data = data.drain(..idx);\n+                dst.extend(data);\n+                &dst[start..]\n             };\n-            {\n-                // scope for new_lines\n-                let new_lines = {\n-                    let dst = if is_out { &mut stdout } else { &mut stderr };\n-                    let start = dst.len();\n-                    let data = data.drain(..idx);\n-                    dst.extend(data);\n-                    &dst[start..]\n-                };\n-                for line in String::from_utf8_lossy(new_lines).lines() {\n-                    if is_out {\n-                        on_stdout_line(line);\n-                    } else {\n-                        on_stderr_line(line);\n-                    }\n+            for line in String::from_utf8_lossy(new_lines).lines() {\n+                if is_out {\n+                    on_stdout_line(line);\n+                } else {\n+                    on_stderr_line(line);\n                 }\n             }\n-        })?;\n-        let _ = child.kill();\n-        child.wait()?\n-    };\n+        }\n+    })?;\n+\n+    Ok((stdout, stderr))\n+}\n+\n+pub fn spawn_with_streaming_output(\n+    mut cmd: Command,\n+    on_stdout_line: &mut dyn FnMut(&str),\n+    on_stderr_line: &mut dyn FnMut(&str),\n+) -> io::Result<Output> {\n+    let cmd = cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n \n+    let mut child = JodChild(cmd.spawn()?);\n+    let (stdout, stderr) = streaming_output(\n+        child.stdout.take().unwrap(),\n+        child.stderr.take().unwrap(),\n+        on_stdout_line,\n+        on_stderr_line,\n+    )?;\n+    let status = child.wait()?;\n     Ok(Output { status, stdout, stderr })\n }\n "}]}