{"sha": "c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MjNiM2Y5NTQ5OGNmMzVhMmYxYTZiYjhjMDcxMzk0Y2E0YTYxNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-04T07:48:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-04T07:48:07Z"}, "message": "Auto merge of #43403 - RalfJung:mir-validate, r=nikomatsakis\n\nAdd MIR Validate statement\n\nThis adds statements to MIR that express when types are to be validated (following [Types as Contracts](https://internals.rust-lang.org/t/types-as-contracts/5562)). Obviously nothing is stabilized, and in fact a `-Z` flag has to be passed for behavior to even change at all.\n\nThis is meant to make experimentation with Types as Contracts in miri possible. The design is definitely not final.\n\nCc @nikomatsakis @aturon", "tree": {"sha": "d4fd7c4406267b6b403da4708e5d0eeda4168604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4fd7c4406267b6b403da4708e5d0eeda4168604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "html_url": "https://github.com/rust-lang/rust/commit/c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5431f423aac345e023815d3f10b8cb840711d756", "url": "https://api.github.com/repos/rust-lang/rust/commits/5431f423aac345e023815d3f10b8cb840711d756", "html_url": "https://github.com/rust-lang/rust/commit/5431f423aac345e023815d3f10b8cb840711d756"}, {"sha": "7d8dc7a979975ab6d8aab29cfa0b69e8a64f1280", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8dc7a979975ab6d8aab29cfa0b69e8a64f1280", "html_url": "https://github.com/rust-lang/rust/commit/7d8dc7a979975ab6d8aab29cfa0b69e8a64f1280"}], "stats": {"total": 871, "additions": 840, "deletions": 31}, "files": [{"sha": "1b7eb1585671e392b14cd0f32c3fd86cca59f640", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -192,6 +192,18 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n+    pub fn unsafety(self) -> ast::Unsafety {\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, unsafety, ..) => {\n+                unsafety\n+            }\n+            FnKind::Method(_, m, ..) => {\n+                m.unsafety\n+            }\n+            _ => ast::Unsafety::Normal\n+        }\n+    }\n+\n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)"}, {"sha": "efe0504aa18c4525236bbc453f6cd504673a3ec2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -48,7 +48,7 @@ use rustc_data_structures::indexed_vec;\n use std::collections::BTreeMap;\n use std::fmt;\n \n-/// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n+/// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n /// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n /// of `Vec` to avoid keeping extra capacity.\n@@ -75,14 +75,14 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n-/// A HirId uniquely identifies a node in the HIR of then current crate. It is\n+/// A HirId uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the DefIndex of the directly enclosing\n /// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n /// around within the source code, or add or remove stuff before it, without\n-/// the local_id part of the HirId changing, which is a very useful property\n+/// the local_id part of the HirId changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n@@ -701,6 +701,16 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n+impl Mutability {\n+    /// Return MutMutable only if both arguments are mutable.\n+    pub fn and(self, other: Self) -> Self {\n+        match self {\n+            MutMutable => other,\n+            MutImmutable => MutImmutable,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n     /// The `+` operator (addition)"}, {"sha": "c20864183f47a0cf774efa72fa78d875f142a83f", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -226,8 +226,12 @@ for mir::StatementKind<'tcx> {\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 lvalue.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::EndRegion(ref extents) => {\n-                extents.hash_stable(hcx, hasher);\n+            mir::StatementKind::EndRegion(ref extent) => {\n+                extent.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::Validate(ref op, ref lvalues) => {\n+                op.hash_stable(hcx, hasher);\n+                lvalues.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n@@ -239,6 +243,23 @@ for mir::StatementKind<'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    for mir::ValidationOperand<'tcx, T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>)\n+    {\n+        self.lval.hash_stable(hcx, hasher);\n+        self.ty.hash_stable(hcx, hasher);\n+        self.re.hash_stable(hcx, hasher);\n+        self.mutbl.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(extent) });\n+\n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,"}, {"sha": "1e8dda0addf4cb8a42f0caec95668a758c766393", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -25,7 +25,7 @@ use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n use rustc_back::slice;\n-use hir::InlineAsm;\n+use hir::{self, InlineAsm};\n use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n@@ -818,12 +818,18 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Lvalue<'tcx>),\n \n+    /// Execute a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n         outputs: Vec<Lvalue<'tcx>>,\n         inputs: Vec<Operand<'tcx>>\n     },\n \n+    /// Assert the given lvalues to be valid inhabitants of their type.  These statements are\n+    /// currently only interpreted by miri and only generated when \"-Z mir-emit-validate\" is passed.\n+    /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n+    Validate(ValidationOp, Vec<ValidationOperand<'tcx, Lvalue<'tcx>>>),\n+\n     /// Mark one terminating point of an extent (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(CodeExtent),\n@@ -832,13 +838,65 @@ pub enum StatementKind<'tcx> {\n     Nop,\n }\n \n+/// The `ValidationOp` describes what happens with each of the operands of a\n+/// `Validate` statement.\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq)]\n+pub enum ValidationOp {\n+    /// Recursively traverse the lvalue following the type and validate that all type\n+    /// invariants are maintained.  Furthermore, acquire exclusive/read-only access to the\n+    /// memory reachable from the lvalue.\n+    Acquire,\n+    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n+    /// access.\n+    Release,\n+    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n+    /// access *until* the given region ends.  Then, access will be recovered.\n+    Suspend(CodeExtent),\n+}\n+\n+impl Debug for ValidationOp {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+        use self::ValidationOp::*;\n+        match *self {\n+            Acquire => write!(fmt, \"Acquire\"),\n+            Release => write!(fmt, \"Release\"),\n+            // (reuse lifetime rendering policy from ppaux.)\n+            Suspend(ref ce) => write!(fmt, \"Suspend({})\", ty::ReScope(*ce)),\n+        }\n+    }\n+}\n+\n+// This is generic so that it can be reused by miri\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub struct ValidationOperand<'tcx, T> {\n+    pub lval: T,\n+    pub ty: Ty<'tcx>,\n+    pub re: Option<CodeExtent>,\n+    pub mutbl: hir::Mutability,\n+}\n+\n+impl<'tcx, T: Debug> Debug for ValidationOperand<'tcx, T> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}: {:?}\", self.lval, self.ty)?;\n+        if let Some(ce) = self.re {\n+            // (reuse lifetime rendering policy from ppaux.)\n+            write!(fmt, \"/{}\", ty::ReScope(ce))?;\n+        }\n+        if let hir::MutImmutable = self.mutbl {\n+            write!(fmt, \" (imm)\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n             // (reuse lifetime rendering policy from ppaux.)\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n+            Validate(ref op, ref lvalues) => write!(fmt, \"Validate({:?}, {:?})\", op, lvalues),\n             StorageLive(ref lv) => write!(fmt, \"StorageLive({:?})\", lv),\n             StorageDead(ref lv) => write!(fmt, \"StorageDead({:?})\", lv),\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n@@ -1481,6 +1539,21 @@ impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Lvalue<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ValidationOperand {\n+            lval: self.lval.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+            re: self.re,\n+            mutbl: self.mutbl,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.lval.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use mir::StatementKind::*;\n@@ -1505,6 +1578,10 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             // trait with a `fn fold_extent`.\n             EndRegion(ref extent) => EndRegion(extent.clone()),\n \n+            Validate(ref op, ref lvals) =>\n+                Validate(op.clone(),\n+                         lvals.iter().map(|operand| operand.fold_with(folder)).collect()),\n+\n             Nop => Nop,\n         };\n         Statement {\n@@ -1530,6 +1607,9 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             // trait with a `fn visit_extent`.\n             EndRegion(ref _extent) => false,\n \n+            Validate(ref _op, ref lvalues) =>\n+                lvalues.iter().any(|ty_and_lvalue| ty_and_lvalue.visit_with(visitor)),\n+\n             Nop => false,\n         }\n     }"}, {"sha": "5e860c632852cba9c28f53ef90078596dc90e9eb", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -338,6 +338,13 @@ macro_rules! make_mir_visitor {\n                         self.visit_assign(block, lvalue, rvalue, location);\n                     }\n                     StatementKind::EndRegion(_) => {}\n+                    StatementKind::Validate(_, ref $($mutability)* lvalues) => {\n+                        for operand in lvalues {\n+                            self.visit_lvalue(& $($mutability)* operand.lval,\n+                                              LvalueContext::Validate, location);\n+                            self.visit_ty(& $($mutability)* operand.ty, Lookup::Loc(location));\n+                        }\n+                    }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n                         self.visit_lvalue(lvalue, LvalueContext::Store, location);\n                     }\n@@ -789,6 +796,9 @@ pub enum LvalueContext<'tcx> {\n     // Starting and ending a storage live range\n     StorageLive,\n     StorageDead,\n+\n+    // Validation command\n+    Validate,\n }\n \n impl<'tcx> LvalueContext<'tcx> {\n@@ -835,7 +845,8 @@ impl<'tcx> LvalueContext<'tcx> {\n             LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n             LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n             LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume |\n-            LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+            LvalueContext::StorageLive | LvalueContext::StorageDead |\n+            LvalueContext::Validate => false,\n         }\n     }\n \n@@ -847,7 +858,8 @@ impl<'tcx> LvalueContext<'tcx> {\n             LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume => true,\n             LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n             LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n-            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead |\n+            LvalueContext::Validate => false,\n         }\n     }\n "}, {"sha": "6995f0996774fbbb5dde1570a2d7e58e49e789b7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -1025,6 +1025,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"the directory the MIR is dumped into\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n           \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n+    mir_emit_validate: usize = (0, parse_uint, [TRACKED],\n+          \"emit Validate MIR statements, interpreted e.g. by miri (0: do not emit; 1: if function \\\n+           contains unsafe block, only validate arguments; 2: always emit full validation)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "12cb556afdabcb20cd7366b2ffcb90545edd4488", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -929,25 +929,32 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_CONST, mir::transform::type_check::TypeckMir);\n     passes.push_pass(MIR_CONST, mir::transform::rustc_peek::SanityCheck);\n \n+    // We compute \"constant qualifications\" betwen MIR_CONST and MIR_VALIDATED.\n+\n     // What we need to run borrowck etc.\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n     passes.push_pass(MIR_VALIDATED,\n                      mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::nll::NLL);\n \n-    // Optimizations begin.\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n+    // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n \n-    // From here on out, regions are gone.\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n+    // These next passes must be executed together\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::elaborate_drops::ElaborateDrops);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n-\n     // No lifetime analysis based on borrowing can be done from here on out.\n+\n+    // AddValidation needs to run after ElaborateDrops and before EraseRegions.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_validation::AddValidation);\n+\n+    // From here on out, regions are gone.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n+\n+    // Optimizations begin.\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::inline::Inline);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::instcombine::InstCombine);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);"}, {"sha": "24d5aa9e46bf232767ee2d41da9bf17117b03482", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -289,6 +289,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => {}\n         },\n         None => {"}, {"sha": "d5bdc71a705c5da5954ea8eb2f5a9ae1ede27759", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -486,6 +486,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "c2945d4659271432c034048731664621f5fc6ecf", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -416,6 +416,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             StatementKind::InlineAsm { .. } |\n             StatementKind::EndRegion(_) |\n+            StatementKind::Validate(..) |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "52c2eaa7cb6325f2e64a6c012d50efd966778adf", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -0,0 +1,390 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate.\n+//! It has to be run really early, before transformations like inlining, because\n+//! introducing these calls *adds* UB -- so, conceptually, this pass is actually part\n+//! of MIR building, and only after this pass we think of the program has having the\n+//! normal MIR semantics.\n+\n+use rustc::ty::{self, TyCtxt, RegionKind};\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::mir::transform::{MirPass, MirSource};\n+use rustc::middle::region::CodeExtent;\n+\n+pub struct AddValidation;\n+\n+/// Determine the \"context\" of the lval: Mutability and region.\n+fn lval_context<'a, 'tcx, D>(\n+    lval: &Lvalue<'tcx>,\n+    local_decls: &D,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+) -> (Option<CodeExtent>, hir::Mutability)\n+    where D: HasLocalDecls<'tcx>\n+{\n+    use rustc::mir::Lvalue::*;\n+\n+    match *lval {\n+        Local { .. } => (None, hir::MutMutable),\n+        Static(_) => (None, hir::MutImmutable),\n+        Projection(ref proj) => {\n+            match proj.elem {\n+                ProjectionElem::Deref => {\n+                    // Computing the inside the recursion makes this quadratic.\n+                    // We don't expect deep paths though.\n+                    let ty = proj.base.ty(local_decls, tcx).to_ty(tcx);\n+                    // A Deref projection may restrict the context, this depends on the type\n+                    // being deref'd.\n+                    let context = match ty.sty {\n+                        ty::TyRef(re, tam) => {\n+                            let re = match re {\n+                                &RegionKind::ReScope(ce) => Some(ce),\n+                                &RegionKind::ReErased =>\n+                                    bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                                _ => None\n+                            };\n+                            (re, tam.mutbl)\n+                        }\n+                        ty::TyRawPtr(_) =>\n+                            // There is no guarantee behind even a mutable raw pointer,\n+                            // no write locks are acquired there, so we also don't want to\n+                            // release any.\n+                            (None, hir::MutImmutable),\n+                        ty::TyAdt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n+                        _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n+                    };\n+                    // \"Intersect\" this restriction with proj.base.\n+                    if let (Some(_), hir::MutImmutable) = context {\n+                        // This is already as restricted as it gets, no need to even recurse\n+                        context\n+                    } else {\n+                        let base_context = lval_context(&proj.base, local_decls, tcx);\n+                        // The region of the outermost Deref is always most restrictive.\n+                        let re = context.0.or(base_context.0);\n+                        let mutbl = context.1.and(base_context.1);\n+                        (re, mutbl)\n+                    }\n+\n+                }\n+                _ => lval_context(&proj.base, local_decls, tcx),\n+            }\n+        }\n+    }\n+}\n+\n+/// Check if this function contains an unsafe block or is an unsafe function.\n+fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n+    use rustc::hir::intravisit::{self, Visitor, FnKind};\n+    use rustc::hir::map::blocks::FnLikeNode;\n+    use rustc::hir::map::Node;\n+\n+    /// Decide if this is an unsafe block\n+    fn block_is_unsafe(block: &hir::Block) -> bool {\n+        use rustc::hir::BlockCheckMode::*;\n+\n+        match block.rules {\n+            UnsafeBlock(_) | PushUnsafeBlock(_) => true,\n+            // For PopUnsafeBlock, we don't actually know -- but we will always also check all\n+            // parent blocks, so we can safely declare the PopUnsafeBlock to not be unsafe.\n+            DefaultBlock | PopUnsafeBlock(_) => false,\n+        }\n+    }\n+\n+    /// Decide if this FnLike is a closure\n+    fn fn_is_closure<'a>(fn_like: FnLikeNode<'a>) -> bool {\n+        match fn_like.kind() {\n+            FnKind::Closure(_) => true,\n+            FnKind::Method(..) | FnKind::ItemFn(..) => false,\n+        }\n+    }\n+\n+    let fn_like = match src {\n+        MirSource::Fn(node_id) => {\n+            match FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+                Some(fn_like) => fn_like,\n+                None => return false, // e.g. struct ctor shims -- such auto-generated code cannot\n+                                      // contain unsafe.\n+            }\n+        },\n+        _ => return false, // only functions can have unsafe\n+    };\n+\n+    // Test if the function is marked unsafe.\n+    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n+        return true;\n+    }\n+\n+    // For closures, we need to walk up the parents and see if we are inside an unsafe fn or\n+    // unsafe block.\n+    if fn_is_closure(fn_like) {\n+        let mut cur = fn_like.id();\n+        loop {\n+            // Go further upwards.\n+            cur = tcx.hir.get_parent_node(cur);\n+            let node = tcx.hir.get(cur);\n+            // Check if this is an unsafe function\n+            if let Some(fn_like) = FnLikeNode::from_node(node) {\n+                if !fn_is_closure(fn_like) {\n+                    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n+                        return true;\n+                    }\n+                }\n+            }\n+            // Check if this is an unsafe block, or an item\n+            match node {\n+                Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block), ..}) => {\n+                    if block_is_unsafe(&*block) {\n+                        // Found an unsafe block, we can bail out here.\n+                        return true;\n+                    }\n+                }\n+                Node::NodeItem(..) => {\n+                    // No walking up beyond items.  This makes sure the loop always terminates.\n+                    break;\n+                }\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    // Visit the entire body of the function and check for unsafe blocks in there\n+    struct FindUnsafe {\n+        found_unsafe: bool,\n+    }\n+    let mut finder = FindUnsafe { found_unsafe: false };\n+    // Run the visitor on the NodeId we got.  Seems like there is no uniform way to do that.\n+    finder.visit_body(tcx.hir.body(fn_like.body()));\n+\n+    impl<'tcx> Visitor<'tcx> for FindUnsafe {\n+        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_block(&mut self, b: &'tcx hir::Block) {\n+            if self.found_unsafe { return; } // short-circuit\n+\n+            if block_is_unsafe(b) {\n+                // We found an unsafe block.  We can stop searching.\n+                self.found_unsafe = true;\n+            } else {\n+                // No unsafe block here, go on searching.\n+                intravisit::walk_block(self, b);\n+            }\n+        }\n+    }\n+\n+    finder.found_unsafe\n+}\n+\n+impl MirPass for AddValidation {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n+    {\n+        let emit_validate = tcx.sess.opts.debugging_opts.mir_emit_validate;\n+        if emit_validate == 0 {\n+            return;\n+        }\n+        let restricted_validation = emit_validate == 1 && fn_contains_unsafe(tcx, src);\n+        let local_decls = mir.local_decls.clone(); // FIXME: Find a way to get rid of this clone.\n+\n+        // Convert an lvalue to a validation operand.\n+        let lval_to_operand = |lval: Lvalue<'tcx>| -> ValidationOperand<'tcx, Lvalue<'tcx>> {\n+            let (re, mutbl) = lval_context(&lval, &local_decls, tcx);\n+            let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n+            ValidationOperand { lval, ty, re, mutbl }\n+        };\n+\n+        // Emit an Acquire at the beginning of the given block.  If we are in restricted emission\n+        // mode (mir_emit_validate=1), also emit a Release immediately after the Acquire.\n+        let emit_acquire = |block: &mut BasicBlockData<'tcx>, source_info, operands: Vec<_>| {\n+            if operands.len() == 0 {\n+                return; // Nothing to do\n+            }\n+            // Emit the release first, to avoid cloning if we do not emit it\n+            if restricted_validation {\n+                let release_stmt = Statement {\n+                    source_info,\n+                    kind: StatementKind::Validate(ValidationOp::Release, operands.clone()),\n+                };\n+                block.statements.insert(0, release_stmt);\n+            }\n+            // Now, the acquire\n+            let acquire_stmt = Statement {\n+                source_info,\n+                kind: StatementKind::Validate(ValidationOp::Acquire, operands),\n+            };\n+            block.statements.insert(0, acquire_stmt);\n+        };\n+\n+        // PART 1\n+        // Add an AcquireValid at the beginning of the start block.\n+        {\n+            let source_info = SourceInfo {\n+                scope: ARGUMENT_VISIBILITY_SCOPE,\n+                span: mir.span, // FIXME: Consider using just the span covering the function\n+                                // argument declaration.\n+            };\n+            // Gather all arguments, skip return value.\n+            let operands = mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n+                    .map(|(local, _)| lval_to_operand(Lvalue::Local(local))).collect();\n+            emit_acquire(&mut mir.basic_blocks_mut()[START_BLOCK], source_info, operands);\n+        }\n+\n+        // PART 2\n+        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor\n+        // because we need to access the block that a Call jumps to.\n+        let mut returns : Vec<(SourceInfo, Lvalue<'tcx>, BasicBlock)> = Vec::new();\n+        for block_data in mir.basic_blocks_mut() {\n+            match block_data.terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n+                                  source_info }) => {\n+                    // Before the call: Release all arguments *and* the return value.\n+                    // The callee may write into the return value!  Note that this relies\n+                    // on \"release of uninitialized\" to be a NOP.\n+                    if !restricted_validation {\n+                        let release_stmt = Statement {\n+                            source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                destination.iter().map(|dest| lval_to_operand(dest.0.clone()))\n+                                .chain(\n+                                    args.iter().filter_map(|op| {\n+                                        match op {\n+                                            &Operand::Consume(ref lval) =>\n+                                                Some(lval_to_operand(lval.clone())),\n+                                            &Operand::Constant(..) => { None },\n+                                        }\n+                                    })\n+                                ).collect())\n+                        };\n+                        block_data.statements.push(release_stmt);\n+                    }\n+                    // Remember the return destination for later\n+                    if let &Some(ref destination) = destination {\n+                        returns.push((source_info, destination.0.clone(), destination.1));\n+                    }\n+                }\n+                Some(Terminator { kind: TerminatorKind::Drop { location: ref lval, .. },\n+                                  source_info }) |\n+                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref lval, .. },\n+                                  source_info }) => {\n+                    // Before the call: Release all arguments\n+                    if !restricted_validation {\n+                        let release_stmt = Statement {\n+                            source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                    vec![lval_to_operand(lval.clone())]),\n+                        };\n+                        block_data.statements.push(release_stmt);\n+                    }\n+                    // drop doesn't return anything, so we need no acquire.\n+                }\n+                _ => {\n+                    // Not a block ending in a Call -> ignore.\n+                }\n+            }\n+        }\n+        // Now we go over the returns we collected to acquire the return values.\n+        for (source_info, dest_lval, dest_block) in returns {\n+            emit_acquire(\n+                &mut mir.basic_blocks_mut()[dest_block],\n+                source_info,\n+                vec![lval_to_operand(dest_lval)]\n+            );\n+        }\n+\n+        if restricted_validation {\n+            // No part 3 for us.\n+            return;\n+        }\n+\n+        // PART 3\n+        // Add ReleaseValid/AcquireValid around Ref and Cast.  Again an iterator does not seem very\n+        // suited as we need to add new statements before and after each Ref.\n+        for block_data in mir.basic_blocks_mut() {\n+            // We want to insert statements around Ref commands as we iterate.  To this end, we\n+            // iterate backwards using indices.\n+            for i in (0..block_data.statements.len()).rev() {\n+                match block_data.statements[i].kind {\n+                    // When the borrow of this ref expires, we need to recover validation.\n+                    StatementKind::Assign(_, Rvalue::Ref(_, _, _)) => {\n+                        // Due to a lack of NLL; we can't capture anything directly here.\n+                        // Instead, we have to re-match and clone there.\n+                        let (dest_lval, re, src_lval) = match block_data.statements[i].kind {\n+                            StatementKind::Assign(ref dest_lval,\n+                                                  Rvalue::Ref(re, _, ref src_lval)) => {\n+                                (dest_lval.clone(), re, src_lval.clone())\n+                            },\n+                            _ => bug!(\"We already matched this.\"),\n+                        };\n+                        // So this is a ref, and we got all the data we wanted.\n+                        // Do an acquire of the result -- but only what it points to, so add a Deref\n+                        // projection.\n+                        let dest_lval = Projection { base: dest_lval, elem: ProjectionElem::Deref };\n+                        let dest_lval = Lvalue::Projection(Box::new(dest_lval));\n+                        let acquire_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Acquire,\n+                                    vec![lval_to_operand(dest_lval)]),\n+                        };\n+                        block_data.statements.insert(i+1, acquire_stmt);\n+\n+                        // The source is released until the region of the borrow ends.\n+                        let op = match re {\n+                            &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n+                            &RegionKind::ReErased =>\n+                                bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                            _ => ValidationOp::Release,\n+                        };\n+                        let release_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(op, vec![lval_to_operand(src_lval)]),\n+                        };\n+                        block_data.statements.insert(i, release_stmt);\n+                    }\n+                    // Casts can change what validation does (e.g. unsizing)\n+                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Consume(_), _))\n+                        if kind != CastKind::Misc =>\n+                    {\n+                        // Due to a lack of NLL; we can't capture anything directly here.\n+                        // Instead, we have to re-match and clone there.\n+                        let (dest_lval, src_lval) = match block_data.statements[i].kind {\n+                            StatementKind::Assign(ref dest_lval,\n+                                    Rvalue::Cast(_, Operand::Consume(ref src_lval), _)) =>\n+                            {\n+                                (dest_lval.clone(), src_lval.clone())\n+                            },\n+                            _ => bug!(\"We already matched this.\"),\n+                        };\n+\n+                        // Acquire of the result\n+                        let acquire_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Acquire,\n+                                    vec![lval_to_operand(dest_lval)]),\n+                        };\n+                        block_data.statements.insert(i+1, acquire_stmt);\n+\n+                        // Release of the input\n+                        let release_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                                            vec![lval_to_operand(src_lval)]),\n+                        };\n+                        block_data.statements.insert(i, release_stmt);\n+                    }\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "f06b88551d11d267967bac3c32f4ba708f7a3b1a", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -24,8 +24,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc::middle::region::CodeExtent;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::{BasicBlock, Location, Mir, Rvalue, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Visitor};\n-use rustc::ty::{RegionKind, TyCtxt};\n+use rustc::mir::visit::{MutVisitor, Visitor, Lookup};\n+use rustc::ty::{Ty, RegionKind, TyCtxt};\n \n pub struct CleanEndRegions;\n \n@@ -42,7 +42,9 @@ impl MirPass for CleanEndRegions {\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut gather = GatherBorrowedRegions { seen_regions: FxHashSet() };\n+        let mut gather = GatherBorrowedRegions {\n+            seen_regions: FxHashSet()\n+        };\n         gather.visit_mir(mir);\n \n         let mut delete = DeleteTrivialEndRegions { seen_regions: &mut gather.seen_regions };\n@@ -54,13 +56,25 @@ impl<'tcx> Visitor<'tcx> for GatherBorrowedRegions {\n     fn visit_rvalue(&mut self,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n+        // Gather regions that are used for borrows\n         if let Rvalue::Ref(r, _, _) = *rvalue {\n             if let RegionKind::ReScope(ce) = *r {\n                 self.seen_regions.insert(ce);\n             }\n         }\n         self.super_rvalue(rvalue, location);\n     }\n+\n+    fn visit_ty(&mut self, ty: &Ty<'tcx>, _: Lookup) {\n+        // Gather regions that occur in types\n+        for re in ty.walk().flat_map(|t| t.regions()) {\n+            match *re {\n+                RegionKind::ReScope(ce) => { self.seen_regions.insert(ce); }\n+                _ => {},\n+            }\n+        }\n+        self.super_ty(ty);\n+    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for DeleteTrivialEndRegions<'a> {"}, {"sha": "baf0522896c9c8c8120ff7e1d1531c0a8cd1d7c1", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -11,6 +11,8 @@\n //! This pass erases all early-bound regions from the types occuring in the MIR.\n //! We want to do this once just before trans, so trans does not have to take\n //! care erasing regions all over the place.\n+//! NOTE:  We do NOT erase regions of statements that are relevant for\n+//! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n@@ -20,20 +22,24 @@ use rustc::mir::transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    in_validation_statement: bool,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n-            tcx: tcx\n+            tcx: tcx,\n+            in_validation_statement: false,\n         }\n     }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n-        let old_ty = *ty;\n-        *ty = self.tcx.erase_regions(&old_ty);\n+        if !self.in_validation_statement {\n+            *ty = self.tcx.erase_regions(&{*ty});\n+        }\n+        self.super_ty(ty);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n@@ -71,10 +77,20 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if let StatementKind::EndRegion(_) = statement.kind {\n-            statement.kind = StatementKind::Nop;\n+        // Do NOT delete EndRegion if validation statements are emitted.\n+        // Validation needs EndRegion.\n+        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n+            if let StatementKind::EndRegion(_) = statement.kind {\n+                statement.kind = StatementKind::Nop;\n+            }\n         }\n+\n+        self.in_validation_statement = match statement.kind {\n+            StatementKind::Validate(..) => true,\n+            _ => false,\n+        };\n         self.super_statement(block, statement, location);\n+        self.in_validation_statement = false;\n     }\n }\n "}, {"sha": "a247ce2231e769195ec4b13a10b1a60a8086d4f0", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax_pos::{DUMMY_SP, Span};\n use transform;\n \n+pub mod add_validation;\n pub mod clean_end_regions;\n pub mod simplify_branches;\n pub mod simplify;"}, {"sha": "9d01f8294e4fa0ec9ae8e604887cda6cd2d4eabc", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -908,6 +908,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::StorageDead(_) |\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n+                StatementKind::Validate(..) |\n                 StatementKind::Nop => {}\n             }\n         });"}, {"sha": "268e7a4c185b00cd8eae1559064b164619d79e1d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -161,6 +161,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,"}, {"sha": "1c7899a46d1d760eb2d854a79c0ce31af6cbdd31", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -414,6 +414,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::InlineAsm { .. } |\n             StatementKind::EndRegion(_) |\n+            StatementKind::Validate(..) |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "d5e477ff0c784d218d958dddff7ca883e12f9bd8", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -126,6 +126,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(match statement.kind {\n             StatementKind::Assign(..) => \"StatementKind::Assign\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n+            StatementKind::Validate(..) => \"StatementKind::Validate\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\","}, {"sha": "598af1cda91d4940fdc7e703d1eaa56bd6d64694", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -158,6 +158,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n                 LvalueContext::StorageLive |\n                 LvalueContext::StorageDead |\n+                LvalueContext::Validate |\n                 LvalueContext::Inspect |\n                 LvalueContext::Consume => {}\n "}, {"sha": "cbe0e259b4a48fb769c82ba7b2ab2ee5da6c0c59", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -293,6 +293,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     mir::StatementKind::StorageLive(_) |\n                     mir::StatementKind::StorageDead(_) |\n+                    mir::StatementKind::Validate(..) |\n                     mir::StatementKind::EndRegion(_) |\n                     mir::StatementKind::Nop => {}\n                     mir::StatementKind::InlineAsm { .. } |"}, {"sha": "52dfc8dc4de5cac1d10f0d408ab504c3dd6cb91b", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -87,6 +87,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => bcx,\n         }\n     }"}, {"sha": "d999ff97551606478161d6e6ff85150cba695ce7", "filename": "src/test/mir-opt/README.md", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2FREADME.md?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -57,13 +57,6 @@ the lines being too long.\n \n compiletest handles dumping the MIR before and after every pass for you.  The\n test writer only has to specify the file names of the dumped files (not the\n-full path to the file) and what lines to expect.  I added an option to rustc\n+full path to the file) and what lines to expect.  There is an option to rustc\n that tells it to dump the mir into some directly (rather then always dumping to\n-the current directory).  \n-\n-Lines match ignoring whitespace, and the prefix \"//\" is removed of course.\n-\n-It also currently strips trailing comments -- partly because the full file path\n-in \"scope comments\" is unpredictable and partly because tidy complains about\n-the lines being too long.\n-\n+the current directory)."}, {"sha": "9ac76a5f4ea614fd2af8480ff4b6ad1ffc316286", "filename": "src/test/mir-opt/validate_1.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+struct Test(i32);\n+\n+impl Test {\n+    // Make sure we run the pass on a method, not just on bare functions.\n+    fn foo(&self, _x: &mut i32) {}\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    Test(0).foo(&mut x);\n+\n+    // Also test closures\n+    let c = |x: &mut i32| { let y = &*x; *y };\n+    c(&mut x);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it has validation.  Unfortunately,\n+// the interesting lines of code also contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node12.EraseRegions.after.mir\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(5) => validate_1/8cd878b::{{impl}}[0]::foo[0] }, BrAnon(0)) Test, _2: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(5) => validate_1/8cd878b::{{impl}}[0]::foo[0] }, BrAnon(1)) mut i32]);\n+//         return;\n+//     }\n+// END rustc.node12.EraseRegions.after.mir\n+// START rustc.node23.EraseRegions.after.mir\n+// fn main() -> () {\n+//     bb0: {\n+//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [_1: i32]);\n+//         _6 = &ReErased mut _1;\n+//         Validate(Acquire, [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         _5 = &ReErased mut (*_6);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Misc(NodeId(34))) Test, _5: &ReScope(Misc(NodeId(34))) mut i32]);\n+//         _2 = const Test::foo(_3, _5) -> bb1;\n+//     }\n+//\n+//     bb1: {\n+//         Validate(Acquire, [_2: ()]);\n+//         EndRegion(ReScope(Misc(NodeId(34))));\n+//         return;\n+//     }\n+// }\n+// END rustc.node23.EraseRegions.after.mir"}, {"sha": "37ebd720d52da567aecf5f8974d2912d025bbf5e", "filename": "src/test/mir-opt/validate_2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+fn main() {\n+    let _x : Box<[i32]> = Box::new([1, 2, 3]);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.EraseRegions.after.mir\n+// fn main() -> () {\n+//     bb1: {\n+//         Validate(Release, [_2: std::boxed::Box<[i32; 3]>]);\n+//         _1 = _2 as std::boxed::Box<[i32]> (Unsize);\n+//         Validate(Acquire, [_1: std::boxed::Box<[i32]>]);\n+//     }\n+// }\n+// END rustc.node4.EraseRegions.after.mir"}, {"sha": "9140cf5768f5918db6a91f2f7ba1f2edc2defa62", "filename": "src/test/mir-opt/validate_3.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+struct Test {\n+    x: i32\n+}\n+\n+fn foo(_x: &i32) {}\n+\n+fn main() {\n+    // These internal unsafe functions should have no effect on the code generation.\n+    unsafe fn _unused1() {}\n+    fn _unused2(x: *const i32) -> i32 { unsafe { *x }}\n+\n+    let t = Test { x: 0 };\n+    let t = &t;\n+    foo(&t.x);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node16.EraseRegions.after.mir\n+// fn main() -> () {\n+//     let mut _5: &ReErased i32;\n+//     bb0: {\n+//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })) (imm)]);\n+//         _5 = &ReErased ((*_2).0: i32);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         _4 = &ReErased (*_5);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Misc(NodeId(46))) i32]);\n+//         _3 = const foo(_4) -> bb1;\n+//     }\n+//     bb1: {\n+//         EndRegion(ReScope(Misc(NodeId(46))));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })));\n+//         return;\n+//     }\n+// }\n+// END rustc.node16.EraseRegions.after.mir"}, {"sha": "591de975740f9fd572883f2156ad82ff75987706", "filename": "src/test/mir-opt/validate_4.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+// Make sure unsafe fns and fns with an unsafe block only get restricted validation.\n+\n+unsafe fn write_42(x: *mut i32) -> bool {\n+    let test_closure = |x: *mut i32| *x = 23;\n+    test_closure(x);\n+    *x = 42;\n+    true\n+}\n+\n+fn test(x: &mut i32) {\n+    unsafe { write_42(x) };\n+}\n+\n+fn main() {\n+    test(&mut 0);\n+\n+    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n+    test_closure(&mut 0);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it only does restricted validation\n+// because it is entirely inside an unsafe block.  Unfortunately, the interesting lines of code also\n+// contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node4.EraseRegions.after.mir\n+// fn write_42(_1: *mut i32) -> bool {\n+//     bb0: {\n+//         Validate(Acquire, [_1: *mut i32]);\n+//         Validate(Release, [_1: *mut i32]);\n+//         return;\n+//     }\n+// }\n+// END rustc.node4.EraseRegions.after.mir\n+// START rustc.node31.EraseRegions.after.mir\n+// fn test(_1: &ReErased mut i32) -> () {\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_4/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_4/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         _3 = const write_42(_4) -> bb1;\n+//     }\n+//     bb1: {\n+//         Validate(Acquire, [_3: bool]);\n+//         Validate(Release, [_3: bool]);\n+//     }\n+// }\n+// END rustc.node31.EraseRegions.after.mir"}, {"sha": "e9919af9fd3a6fec243a75c3979d7002836d6073", "filename": "src/test/mir-opt/validate_5.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523b3f95498cf35a2f1a6bb8c071394ca4a6143/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=2\n+\n+// Make sure unsafe fns and fns with an unsafe block only get full validation.\n+\n+unsafe fn write_42(x: *mut i32) -> bool {\n+    *x = 42;\n+    true\n+}\n+\n+fn test(x: &mut i32) {\n+    unsafe { write_42(x) };\n+}\n+\n+fn main() {\n+    test(&mut 0);\n+\n+    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n+    test_closure(&mut 0);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it has validation.  Unfortunately,\n+// the interesting lines of code also contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node17.EraseRegions.after.mir\n+// fn test(_1: &ReErased mut i32) -> () {\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_5/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_3: bool, _4: *mut i32]);\n+//         _3 = const write_42(_4) -> bb1;\n+//     }\n+// }\n+// END rustc.node17.EraseRegions.after.mir"}]}