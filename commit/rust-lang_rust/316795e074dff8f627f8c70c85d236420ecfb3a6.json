{"sha": "316795e074dff8f627f8c70c85d236420ecfb3a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNjc5NWUwNzRkZmY4ZjYyN2Y4YzcwYzg1ZDIzNjQyMGVjZmIzYTY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-12-24T00:19:09Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-01-26T22:16:29Z"}, "message": "Initial auto import action implementation", "tree": {"sha": "da6e266139563ef314d0563a01723ae2264609d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da6e266139563ef314d0563a01723ae2264609d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/316795e074dff8f627f8c70c85d236420ecfb3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/316795e074dff8f627f8c70c85d236420ecfb3a6", "html_url": "https://github.com/rust-lang/rust/commit/316795e074dff8f627f8c70c85d236420ecfb3a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/316795e074dff8f627f8c70c85d236420ecfb3a6/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1330a4a65f0113c687716a5a679239af4df9c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1330a4a65f0113c687716a5a679239af4df9c11", "html_url": "https://github.com/rust-lang/rust/commit/d1330a4a65f0113c687716a5a679239af4df9c11"}], "stats": {"total": 457, "additions": 438, "deletions": 19}, "files": [{"sha": "2ab65ab99a63cd2871a6f5a9bf79f20413ef4061", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -101,7 +101,6 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         Some(assist)\n     }\n \n-    #[allow(dead_code)] // will be used for auto import assist with multiple actions\n     pub(crate) fn add_assist_group(\n         self,\n         id: AssistId,\n@@ -168,7 +167,6 @@ pub(crate) struct ActionBuilder {\n }\n \n impl ActionBuilder {\n-    #[allow(dead_code)]\n     /// Adds a custom label to the action, if it needs to be different from the assist label\n     pub(crate) fn label(&mut self, label: impl Into<String>) {\n         self.label = Some(label.into())"}, {"sha": "fe226521e41b3db313797c94c06cc3593172b8f2", "filename": "crates/ra_assists/src/assists/auto_import.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -0,0 +1,181 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SmolStr, SyntaxElement,\n+    SyntaxKind::{NAME_REF, USE_ITEM},\n+    SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_ctx::{ActionBuilder, Assist, AssistCtx},\n+    auto_import_text_edit, AssistId, ImportsLocator,\n+};\n+\n+// Assist: auto_import\n+//\n+// If the name is unresolved, provides all possible imports for it.\n+//\n+// ```\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// ```\n+// ->\n+// ```\n+// use std::collections::HashMap;\n+//\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// ```\n+pub(crate) fn auto_import<'a, F: ImportsLocator<'a>>(\n+    ctx: AssistCtx<impl HirDatabase>,\n+    imports_locator: &mut F,\n+) -> Option<Assist> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let module = path.syntax().ancestors().find_map(ast::Module::cast);\n+    let position = match module.and_then(|it| it.item_list()) {\n+        Some(item_list) => item_list.syntax().clone(),\n+        None => {\n+            let current_file = path.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n+            current_file.syntax().clone()\n+        }\n+    };\n+\n+    let module_with_name_to_import = ctx.source_analyzer(&position, None).module()?;\n+    let name_to_import = hir::InFile {\n+        file_id: ctx.frange.file_id.into(),\n+        value: &find_applicable_name_ref(ctx.covering_element())?,\n+    };\n+\n+    let proposed_imports =\n+        imports_locator.find_imports(name_to_import, module_with_name_to_import)?;\n+    if proposed_imports.is_empty() {\n+        return None;\n+    }\n+\n+    ctx.add_assist_group(AssistId(\"auto_import\"), \"auto import\", || {\n+        proposed_imports\n+            .into_iter()\n+            .map(|import| import_to_action(import.to_string(), &position, &path))\n+            .collect()\n+    })\n+}\n+\n+fn find_applicable_name_ref(element: SyntaxElement) -> Option<ast::NameRef> {\n+    if element.ancestors().find(|ancestor| ancestor.kind() == USE_ITEM).is_some() {\n+        None\n+    } else if element.kind() == NAME_REF {\n+        Some(element.as_node().cloned().and_then(ast::NameRef::cast)?)\n+    } else {\n+        let parent = element.parent()?;\n+        if parent.kind() == NAME_REF {\n+            Some(ast::NameRef::cast(parent)?)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn import_to_action(import: String, position: &SyntaxNode, path: &ast::Path) -> ActionBuilder {\n+    let mut action_builder = ActionBuilder::default();\n+    action_builder.label(format!(\"Import `{}`\", &import));\n+    auto_import_text_edit(\n+        position,\n+        &path.syntax().clone(),\n+        &[SmolStr::new(import)],\n+        action_builder.text_edit_builder(),\n+    );\n+    action_builder\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{\n+        check_assist_with_imports_locator, check_assist_with_imports_locator_not_applicable,\n+    };\n+    use hir::Name;\n+\n+    #[derive(Clone)]\n+    struct TestImportsLocator<'a> {\n+        import_path: &'a [Name],\n+    }\n+\n+    impl<'a> TestImportsLocator<'a> {\n+        fn new(import_path: &'a [Name]) -> Self {\n+            TestImportsLocator { import_path }\n+        }\n+    }\n+\n+    impl<'a> ImportsLocator<'_> for TestImportsLocator<'_> {\n+        fn find_imports(\n+            &mut self,\n+            _: hir::InFile<&ast::NameRef>,\n+            _: hir::Module,\n+        ) -> Option<Vec<hir::ModPath>> {\n+            if self.import_path.is_empty() {\n+                None\n+            } else {\n+                Some(vec![hir::ModPath {\n+                    kind: hir::PathKind::Plain,\n+                    segments: self.import_path.to_owned(),\n+                }])\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_an_import() {\n+        let import_path = &[hir::name::known::std, hir::name::known::ops, hir::name::known::Debug];\n+        let mut imports_locator = TestImportsLocator::new(import_path);\n+        check_assist_with_imports_locator(\n+            auto_import,\n+            &mut imports_locator,\n+            \"\n+            fn main() {\n+            }\n+\n+            Debug<|>\",\n+            &format!(\n+                \"\n+            use {};\n+\n+            fn main() {{\n+            }}\n+\n+            Debug<|>\",\n+                import_path\n+                    .into_iter()\n+                    .map(|name| name.to_string())\n+                    .collect::<Vec<String>>()\n+                    .join(\"::\")\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_no_imports_found() {\n+        let mut imports_locator = TestImportsLocator::new(&[]);\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            &mut imports_locator,\n+            \"\n+            fn main() {\n+            }\n+\n+            Debug<|>\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_import_statements() {\n+        let import_path = &[hir::name::known::std, hir::name::known::ops, hir::name::known::Debug];\n+        let mut imports_locator = TestImportsLocator::new(import_path);\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            &mut imports_locator,\n+            \"use Debug<|>;\",\n+        );\n+    }\n+}"}, {"sha": "65d51428bb19a29b69d261a401996ea07480ee6d", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -11,6 +11,10 @@ use test_utils::{assert_eq_text, extract_range_or_offset};\n use crate::test_db::TestDB;\n \n fn check(assist_id: &str, before: &str, after: &str) {\n+    // FIXME we cannot get the imports search functionality here yet, but still need to generate a test and a doc for an assist\n+    if assist_id == \"auto_import\" {\n+        return;\n+    }\n     let (selection, before) = extract_range_or_offset(before);\n     let (db, file_id) = TestDB::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };"}, {"sha": "ec4587ce7c7a935600009ac9d46e53bde53ffee3", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -214,6 +214,25 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_auto_import() {\n+    check(\n+        \"auto_import\",\n+        r#####\"\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+\"#####,\n+        r#####\"\n+use std::collections::HashMap;\n+\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_change_visibility() {\n     check("}, {"sha": "4029962f766f7d5284f44a2613699179aafe2a67", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 113, "deletions": 13, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -14,9 +14,9 @@ mod test_db;\n pub mod ast_transform;\n \n use either::Either;\n-use hir::db::HirDatabase;\n+use hir::{db::HirDatabase, InFile, ModPath, Module};\n use ra_db::FileRange;\n-use ra_syntax::{TextRange, TextUnit};\n+use ra_syntax::{ast::NameRef, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n \n pub(crate) use crate::assist_ctx::{Assist, AssistCtx};\n@@ -77,6 +77,55 @@ where\n     })\n }\n \n+/// A functionality for locating imports for the given name.\n+///\n+/// Currently has to be a trait with the real implementation provided by the ra_ide_api crate,\n+/// due to the search functionality located there.\n+/// Later, this trait should be removed completely and the search functionality moved to a separate crate,\n+/// accessible from the ra_assists crate.\n+pub trait ImportsLocator<'a> {\n+    /// Finds all imports for the given name and the module that contains this name.\n+    fn find_imports(\n+        &mut self,\n+        name_to_import: InFile<&NameRef>,\n+        module_with_name_to_import: Module,\n+    ) -> Option<Vec<ModPath>>;\n+}\n+\n+/// Return all the assists applicable at the given position\n+/// and additional assists that need the imports locator functionality to work.\n+///\n+/// Assists are returned in the \"resolved\" state, that is with edit fully\n+/// computed.\n+pub fn assists_with_imports_locator<'a, H, F: 'a>(\n+    db: &H,\n+    range: FileRange,\n+    mut imports_locator: F,\n+) -> Vec<ResolvedAssist>\n+where\n+    H: HirDatabase + 'static,\n+    F: ImportsLocator<'a>,\n+{\n+    AssistCtx::with_ctx(db, range, true, |ctx| {\n+        let mut assists = assists::all()\n+            .iter()\n+            .map(|f| f(ctx.clone()))\n+            .chain(\n+                assists::all_with_imports_locator()\n+                    .iter()\n+                    .map(|f| f(ctx.clone(), &mut imports_locator)),\n+            )\n+            .filter_map(std::convert::identity)\n+            .map(|a| match a {\n+                Assist::Resolved { assist } => assist,\n+                Assist::Unresolved { .. } => unreachable!(),\n+            })\n+            .collect();\n+        sort_assists(&mut assists);\n+        assists\n+    })\n+}\n+\n /// Return all the assists applicable at the given position.\n ///\n /// Assists are returned in the \"resolved\" state, that is with edit fully\n@@ -85,8 +134,6 @@ pub fn assists<H>(db: &H, range: FileRange) -> Vec<ResolvedAssist>\n where\n     H: HirDatabase + 'static,\n {\n-    use std::cmp::Ordering;\n-\n     AssistCtx::with_ctx(db, range, true, |ctx| {\n         let mut a = assists::all()\n             .iter()\n@@ -95,19 +142,24 @@ where\n                 Assist::Resolved { assist } => assist,\n                 Assist::Unresolved { .. } => unreachable!(),\n             })\n-            .collect::<Vec<_>>();\n-        a.sort_by(|a, b| match (a.get_first_action().target, b.get_first_action().target) {\n-            (Some(a), Some(b)) => a.len().cmp(&b.len()),\n-            (Some(_), None) => Ordering::Less,\n-            (None, Some(_)) => Ordering::Greater,\n-            (None, None) => Ordering::Equal,\n-        });\n+            .collect();\n+        sort_assists(&mut a);\n         a\n     })\n }\n \n+fn sort_assists(assists: &mut Vec<ResolvedAssist>) {\n+    use std::cmp::Ordering;\n+    assists.sort_by(|a, b| match (a.get_first_action().target, b.get_first_action().target) {\n+        (Some(a), Some(b)) => a.len().cmp(&b.len()),\n+        (Some(_), None) => Ordering::Less,\n+        (None, Some(_)) => Ordering::Greater,\n+        (None, None) => Ordering::Equal,\n+    });\n+}\n+\n mod assists {\n-    use crate::{Assist, AssistCtx};\n+    use crate::{Assist, AssistCtx, ImportsLocator};\n     use hir::db::HirDatabase;\n \n     mod add_derive;\n@@ -116,6 +168,7 @@ mod assists {\n     mod add_custom_impl;\n     mod add_new;\n     mod apply_demorgan;\n+    mod auto_import;\n     mod invert_if;\n     mod flip_comma;\n     mod flip_binexpr;\n@@ -168,6 +221,11 @@ mod assists {\n             early_return::convert_to_guarded_return,\n         ]\n     }\n+\n+    pub(crate) fn all_with_imports_locator<'a, DB: HirDatabase, F: ImportsLocator<'a>>(\n+    ) -> &'a [fn(AssistCtx<DB>, &mut F) -> Option<Assist>] {\n+        &[auto_import::auto_import]\n+    }\n }\n \n #[cfg(test)]\n@@ -176,7 +234,7 @@ mod helpers {\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n-    use crate::{test_db::TestDB, Assist, AssistCtx};\n+    use crate::{test_db::TestDB, Assist, AssistCtx, ImportsLocator};\n \n     pub(crate) fn check_assist(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n@@ -206,6 +264,35 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n+    pub(crate) fn check_assist_with_imports_locator<'a, F: ImportsLocator<'a>>(\n+        assist: fn(AssistCtx<TestDB>, &mut F) -> Option<Assist>,\n+        imports_locator: &mut F,\n+        before: &str,\n+        after: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assist = AssistCtx::with_ctx(&db, frange, true, |ctx| assist(ctx, imports_locator))\n+            .expect(\"code action is not applicable\");\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { assist } => assist.get_first_action(),\n+        };\n+\n+        let actual = action.edit.apply(&before);\n+        let actual_cursor_pos = match action.cursor_position {\n+            None => action\n+                .edit\n+                .apply_to_offset(before_cursor_pos)\n+                .expect(\"cursor position is affected by the edit\"),\n+            Some(off) => off,\n+        };\n+        let actual = add_cursor(&actual, actual_cursor_pos);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n     pub(crate) fn check_assist_range(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n@@ -279,6 +366,19 @@ mod helpers {\n         assert!(assist.is_none());\n     }\n \n+    pub(crate) fn check_assist_with_imports_locator_not_applicable<'a, F: ImportsLocator<'a>>(\n+        assist: fn(AssistCtx<TestDB>, &mut F) -> Option<Assist>,\n+        imports_locator: &mut F,\n+        before: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assist = AssistCtx::with_ctx(&db, frange, true, |ctx| assist(ctx, imports_locator));\n+        assert!(assist.is_none());\n+    }\n+\n     pub(crate) fn check_assist_range_not_applicable(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,"}, {"sha": "be6dced538566ad7231be9ccecd52a2590f11c1e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -58,6 +58,6 @@ pub use hir_def::{\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n+    name, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n };\n pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "c43c45c654a8c54f1300c1794ca1e01afa1947a2", "filename": "crates/ra_ide/src/assists.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -2,8 +2,9 @@\n \n use ra_db::{FilePosition, FileRange};\n \n-use crate::{db::RootDatabase, FileId, SourceChange, SourceFileEdit};\n-\n+use crate::{\n+    db::RootDatabase, imports_locator::ImportsLocatorIde, FileId, SourceChange, SourceFileEdit,\n+};\n use either::Either;\n pub use ra_assists::AssistId;\n use ra_assists::{AssistAction, AssistLabel};\n@@ -16,7 +17,7 @@ pub struct Assist {\n }\n \n pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n-    ra_assists::assists(db, frange)\n+    ra_assists::assists_with_imports_locator(db, frange, ImportsLocatorIde::new(db))\n         .into_iter()\n         .map(|assist| {\n             let file_id = frange.file_id;"}, {"sha": "23391ac3b6e07c2b29fbcf6aff84c6f1002d97e6", "filename": "crates/ra_ide/src/imports_locator.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -0,0 +1,97 @@\n+//! This module contains an import search funcionality that is provided to the ra_assists module.\n+//! Later, this should be moved away to a separate crate that is accessible from the ra_assists module.\n+\n+use crate::{\n+    db::RootDatabase,\n+    references::{classify_name, classify_name_ref, NameDefinition, NameKind},\n+    symbol_index::{self, FileSymbol},\n+    Query,\n+};\n+use ast::NameRef;\n+use hir::{db::HirDatabase, InFile, ModPath, Module, SourceBinder};\n+use itertools::Itertools;\n+use ra_assists::ImportsLocator;\n+use ra_prof::profile;\n+use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n+\n+pub(crate) struct ImportsLocatorIde<'a> {\n+    source_binder: SourceBinder<'a, RootDatabase>,\n+}\n+\n+impl<'a> ImportsLocatorIde<'a> {\n+    pub(crate) fn new(db: &'a RootDatabase) -> Self {\n+        Self { source_binder: SourceBinder::new(db) }\n+    }\n+\n+    fn search_for_imports(\n+        &mut self,\n+        name_to_import: &ast::NameRef,\n+        module_with_name_to_import: Module,\n+    ) -> Vec<ModPath> {\n+        let _p = profile(\"search_for_imports\");\n+        let db = self.source_binder.db;\n+        let name_to_import = name_to_import.text();\n+\n+        let project_results = {\n+            let mut query = Query::new(name_to_import.to_string());\n+            query.exact();\n+            query.limit(10);\n+            symbol_index::world_symbols(db, query)\n+        };\n+        let lib_results = {\n+            let mut query = Query::new(name_to_import.to_string());\n+            query.libs();\n+            query.exact();\n+            query.limit(10);\n+            symbol_index::world_symbols(db, query)\n+        };\n+\n+        project_results\n+            .into_iter()\n+            .chain(lib_results.into_iter())\n+            .filter_map(|import_candidate| self.get_name_definition(db, &import_candidate))\n+            .filter_map(|name_definition_to_import| {\n+                if let NameKind::Def(module_def) = name_definition_to_import.kind {\n+                    module_with_name_to_import.find_use_path(db, module_def)\n+                } else {\n+                    None\n+                }\n+            })\n+            .filter(|use_path| !use_path.segments.is_empty())\n+            .unique()\n+            .collect()\n+    }\n+\n+    fn get_name_definition(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        import_candidate: &FileSymbol,\n+    ) -> Option<NameDefinition> {\n+        let _p = profile(\"get_name_definition\");\n+        let file_id = import_candidate.file_id.into();\n+        let candidate_node = import_candidate.ptr.to_node(&db.parse_or_expand(file_id)?);\n+        let candidate_name_node = if candidate_node.kind() != NAME {\n+            candidate_node.children().find(|it| it.kind() == NAME)?\n+        } else {\n+            candidate_node\n+        };\n+        classify_name(\n+            &mut self.source_binder,\n+            hir::InFile { file_id, value: &ast::Name::cast(candidate_name_node)? },\n+        )\n+    }\n+}\n+\n+impl<'a> ImportsLocator<'a> for ImportsLocatorIde<'a> {\n+    fn find_imports(\n+        &mut self,\n+        name_to_import: InFile<&NameRef>,\n+        module_with_name_to_import: Module,\n+    ) -> Option<Vec<ModPath>> {\n+        if classify_name_ref(&mut self.source_binder, name_to_import).is_none() {\n+            Some(self.search_for_imports(name_to_import.value, module_with_name_to_import))\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "03ad6b2c13c89a3f4ec59beb636c65fd1cb729bb", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -30,6 +30,7 @@ mod syntax_highlighting;\n mod parent_module;\n mod references;\n mod impls;\n+mod imports_locator;\n mod assists;\n mod diagnostics;\n mod syntax_tree;"}, {"sha": "c36c5df6a23c1e7adb8c89362e97c391b69c3623", "filename": "docs/user/assists.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/316795e074dff8f627f8c70c85d236420ecfb3a6/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/316795e074dff8f627f8c70c85d236420ecfb3a6/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=316795e074dff8f627f8c70c85d236420ecfb3a6", "patch": "@@ -209,6 +209,24 @@ fn main() {\n }\n ```\n \n+## `auto_import`\n+\n+If the name is unresolved, provides all possible imports for it.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    let map = HashMap\u2503::new();\n+}\n+\n+// AFTER\n+use std::collections::HashMap;\n+\n+fn main() {\n+    let map = HashMap\u2503::new();\n+}\n+```\n+\n ## `change_visibility`\n \n Adds or changes existing visibility specifier."}]}