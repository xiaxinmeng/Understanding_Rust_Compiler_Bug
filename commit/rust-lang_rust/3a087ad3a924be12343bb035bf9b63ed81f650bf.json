{"sha": "3a087ad3a924be12343bb035bf9b63ed81f650bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMDg3YWQzYTkyNGJlMTIzNDNiYjAzNWJmOWI2M2VkODFmNjUwYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-28T00:18:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-28T00:18:59Z"}, "message": "Auto merge of #67670 - oli-obk:rollup-2dp08sd, r=oli-obk\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #65244 (add IntoFuture trait and support for await)\n - #67576 (reuse `capacity` variable in slice::repeat)\n - #67588 (Use NonNull in slice::Iter and slice::IterMut.)\n - #67594 (Update libc to 0.2.66)\n - #67602 (Use issue = \"none\" instead of \"0\" in intrinsics)\n - #67604 (Add Scalar::to_(u|i)16 methods)\n - #67617 (Remove `compiler_builtins_lib` documentation)\n - #67621 (Use the correct type for static qualifs)\n - #67629 (Remove redundant link texts)\n - #67632 (Convert collapsed to shortcut reference links)\n - #67633 (Update .mailmap)\n - #67635 (Document safety of Path casting)\n - #67654 (Add regression test for old NLL ICE)\n - #67659 (Stabilize the `matches!` macro)\n - #67664 (Fix some mailmap entries)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "280371e5569301f96fa6ed0a2498625a90795e28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/280371e5569301f96fa6ed0a2498625a90795e28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a087ad3a924be12343bb035bf9b63ed81f650bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a087ad3a924be12343bb035bf9b63ed81f650bf", "html_url": "https://github.com/rust-lang/rust/commit/3a087ad3a924be12343bb035bf9b63ed81f650bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a087ad3a924be12343bb035bf9b63ed81f650bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74c4e6a981d3150db8444c8d250e50bbe6b93b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/74c4e6a981d3150db8444c8d250e50bbe6b93b6b", "html_url": "https://github.com/rust-lang/rust/commit/74c4e6a981d3150db8444c8d250e50bbe6b93b6b"}, {"sha": "65bbcf0e13d0ce81f443b2fcfc5548b589c8462e", "url": "https://api.github.com/repos/rust-lang/rust/commits/65bbcf0e13d0ce81f443b2fcfc5548b589c8462e", "html_url": "https://github.com/rust-lang/rust/commit/65bbcf0e13d0ce81f443b2fcfc5548b589c8462e"}], "stats": {"total": 441, "additions": 267, "deletions": 174}, "files": [{"sha": "3e512377d03771dcdd31734eefdbabacfa475223", "filename": ".mailmap", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -54,9 +54,10 @@ Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccer\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n-Christian Poveda <christianpoveda@protonmail.com> <cn.poveda.ruiz@gmail.com>\n-Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n-Christian Poveda <christianpoveda@protonmail.com> <cpovedar@fnal.gov>\n+Christian Poveda <git@christianpoveda.xyz> <christianpoveda@protonmail.com>\n+Christian Poveda <git@christianpoveda.xyz> <cn.poveda.ruiz@gmail.com>\n+Christian Poveda <git@christianpoveda.xyz> <z1mvader@protonmail.com>\n+Christian Poveda <git@christianpoveda.xyz> <cpovedar@fnal.gov>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n@@ -154,6 +155,7 @@ Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>\n Luqman Aden <me@luqman.ca> <laden@csclub.uwaterloo.ca>\n Luqman Aden <me@luqman.ca> <laden@mozilla.com>\n+Manish Goregaokar <manishsmail@gmail.com>\n Marcell Pardavi <marcell.pardavi@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n Mark Rousskov <mark.simulacrum@gmail.com>\n@@ -185,6 +187,7 @@ Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nick Platt <platt.nicholas@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n+Nika Layzell <michael@thelayzells.com>\n Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>\n Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n@@ -204,7 +207,6 @@ Paul Faria <paul_faria@ultimatesoftware.com> Paul Faria <Nashenas88@gmail.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com> parir <peer.aramillo.irizar@gmail.com>\n Peter Elmers <peter.elmers@yahoo.com> <peter.elmers@rice.edu>\n Peter Liniker <peter.liniker+github@gmail.com>\n-Peter Zotov <whitequark@whitequark.org>\n Phil Dawes <phil@phildawes.net> Phil Dawes <pdawes@drw.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <blei42@gmail.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <bruphili@student.ethz.ch>\n@@ -255,6 +257,7 @@ Ulrik Sverdrup <bluss@users.noreply.github.com> Ulrik Sverdrup <root@localhost>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com> petrochenkov <vadim.petrochenkov@gmail.com>\n Vitali Haravy <HumaneProgrammer@gmail.com> Vitali Haravy <humaneprogrammer@gmail.com>\n+whitequark <whitequark@whitequark.org>\n William Ting <io@williamting.com> <william.h.ting@gmail.com>\n Xuefeng Wu <benewu@gmail.com> Xuefeng Wu <xfwu@thoughtworks.com>\n Xuefeng Wu <benewu@gmail.com> XuefengWu <benewu@gmail.com>"}, {"sha": "fc8ca5d07b21280c575477457b8e4e3e953b26b4", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -367,7 +367,7 @@ labels to triage issues:\n   to fix the issue.\n \n * The dark blue **final-comment-period** label marks bugs that are using the\n-  RFC signoff functionality of [rfcbot][rfcbot] and are currently in the final\n+  RFC signoff functionality of [rfcbot] and are currently in the final\n   comment period.\n \n * Red, **I**-prefixed labels indicate the **importance** of the issue. The\n@@ -385,7 +385,7 @@ labels to triage issues:\n   label.\n \n * The gray **proposed-final-comment-period** label marks bugs that are using\n-  the RFC signoff functionality of [rfcbot][rfcbot] and are currently awaiting\n+  the RFC signoff functionality of [rfcbot] and are currently awaiting\n   signoff of all team members in order to enter the final comment period.\n \n * Pink, **regression**-prefixed labels track regressions from stable to the"}, {"sha": "847a406985d76bde682db58e3a1f44ce6edddd55", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -1773,9 +1773,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.64\"\n+version = \"0.2.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74dfca3d9957906e8d1e6a0b641dc9a59848e793f1da2165889fd4f62d10d79c\"\n+checksum = \"d515b1f41455adea1313a4a2ac8a8a477634fbae63cc6100e3aebb207ce61558\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "e3597473f62fd17d9ace1d62f7ad9bfd345e2043", "filename": "RELEASES.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -4951,10 +4951,10 @@ Stabilized APIs\n ---------------\n \n * [`std::panic`]\n-* [`std::panic::catch_unwind`][] (renamed from `recover`)\n-* [`std::panic::resume_unwind`][] (renamed from `propagate`)\n-* [`std::panic::AssertUnwindSafe`][] (renamed from `AssertRecoverSafe`)\n-* [`std::panic::UnwindSafe`][] (renamed from `RecoverSafe`)\n+* [`std::panic::catch_unwind`] (renamed from `recover`)\n+* [`std::panic::resume_unwind`] (renamed from `propagate`)\n+* [`std::panic::AssertUnwindSafe`] (renamed from `AssertRecoverSafe`)\n+* [`std::panic::UnwindSafe`] (renamed from `RecoverSafe`)\n * [`str::is_char_boundary`]\n * [`<*const T>::as_ref`]\n * [`<*mut T>::as_ref`]\n@@ -5234,18 +5234,18 @@ Libraries\n ---------\n \n * Stabilized APIs:\n-  * [`str::encode_utf16`][] (renamed from `utf16_units`)\n-  * [`str::EncodeUtf16`][] (renamed from `Utf16Units`)\n+  * [`str::encode_utf16`] (renamed from `utf16_units`)\n+  * [`str::EncodeUtf16`] (renamed from `Utf16Units`)\n   * [`Ref::map`]\n   * [`RefMut::map`]\n   * [`ptr::drop_in_place`]\n   * [`time::Instant`]\n   * [`time::SystemTime`]\n   * [`Instant::now`]\n-  * [`Instant::duration_since`][] (renamed from `duration_from_earlier`)\n+  * [`Instant::duration_since`] (renamed from `duration_from_earlier`)\n   * [`Instant::elapsed`]\n   * [`SystemTime::now`]\n-  * [`SystemTime::duration_since`][] (renamed from `duration_from_earlier`)\n+  * [`SystemTime::duration_since`] (renamed from `duration_from_earlier`)\n   * [`SystemTime::elapsed`]\n   * Various `Add`/`Sub` impls for `Time` and `SystemTime`\n   * [`SystemTimeError`]\n@@ -5432,8 +5432,8 @@ Libraries\n \n * Stabilized APIs\n   * `Path`\n-    * [`Path::strip_prefix`][] (renamed from relative_from)\n-    * [`path::StripPrefixError`][] (new error type returned from strip_prefix)\n+    * [`Path::strip_prefix`] (renamed from relative_from)\n+    * [`path::StripPrefixError`] (new error type returned from strip_prefix)\n   * `Ipv4Addr`\n     * [`Ipv4Addr::is_loopback`]\n     * [`Ipv4Addr::is_private`]\n@@ -5646,7 +5646,7 @@ Libraries\n \n * Stabilized APIs:\n   [`Read::read_exact`],\n-  [`ErrorKind::UnexpectedEof`][] (renamed from `UnexpectedEOF`),\n+  [`ErrorKind::UnexpectedEof`] (renamed from `UnexpectedEOF`),\n   [`fs::DirBuilder`], [`fs::DirBuilder::new`],\n   [`fs::DirBuilder::recursive`], [`fs::DirBuilder::create`],\n   [`os::unix::fs::DirBuilderExt`],\n@@ -5659,11 +5659,11 @@ Libraries\n   [`collections::hash_set::HashSet::drain`],\n   [`collections::binary_heap::Drain`],\n   [`collections::binary_heap::BinaryHeap::drain`],\n-  [`Vec::extend_from_slice`][] (renamed from `push_all`),\n+  [`Vec::extend_from_slice`] (renamed from `push_all`),\n   [`Mutex::get_mut`], [`Mutex::into_inner`], [`RwLock::get_mut`],\n   [`RwLock::into_inner`],\n-  [`Iterator::min_by_key`][] (renamed from `min_by`),\n-  [`Iterator::max_by_key`][] (renamed from `max_by`).\n+  [`Iterator::min_by_key`] (renamed from `min_by`),\n+  [`Iterator::max_by_key`] (renamed from `max_by`).\n * The [core library][1.6co] is stable, as are most of its APIs.\n * [The `assert_eq!` macro supports arguments that don't implement\n   `Sized`][1.6ae], such as arrays. In this way it behaves more like"}, {"sha": "6f096e582f575864f24668bfc52e4d79d05241a8", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -188,11 +188,7 @@ pub extern fn rust_begin_panic(info: &PanicInfo) -> ! {\n \n In many cases, you may need to manually link to the `compiler_builtins` crate\n when building a `no_std` binary. You may observe this via linker error messages\n-such as \"```undefined reference to `__rust_probestack'```\". Using this crate\n-also requires enabling the library feature `compiler_builtins_lib`. You can read\n-more about this [here][compiler-builtins-lib].\n-\n-[compiler-builtins-lib]: ../library-features/compiler-builtins-lib.md\n+such as \"```undefined reference to `__rust_probestack'```\".\n \n ## More about the language items\n "}, {"sha": "6c71c3f2ce1917af1a8943b0d31735e99d3baa35", "filename": "src/doc/unstable-book/src/library-features/compiler-builtins-lib.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/74c4e6a981d3150db8444c8d250e50bbe6b93b6b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md", "raw_url": "https://github.com/rust-lang/rust/raw/74c4e6a981d3150db8444c8d250e50bbe6b93b6b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md?ref=74c4e6a981d3150db8444c8d250e50bbe6b93b6b", "patch": "@@ -1,35 +0,0 @@\n-# `compiler_builtins_lib`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-\n-This feature is required to link to the `compiler_builtins` crate which contains\n-\"compiler intrinsics\". Compiler intrinsics are software implementations of basic\n-operations like multiplication of `u64`s. These intrinsics are only required on\n-platforms where these operations don't directly map to a hardware instruction.\n-\n-You should never need to explicitly link to the `compiler_builtins` crate when\n-building \"std\" programs as `compiler_builtins` is already in the dependency\n-graph of `std`. But you may need it when building `no_std` **binary** crates. If\n-you get a *linker* error like:\n-\n-``` text\n-$PWD/src/main.rs:11: undefined reference to `__aeabi_lmul'\n-$PWD/src/main.rs:11: undefined reference to `__aeabi_uldivmod'\n-```\n-\n-That means that you need to link to this crate.\n-\n-When you link to this crate, make sure it only appears once in your crate\n-dependency graph. Also, it doesn't matter where in the dependency graph you\n-place the `compiler_builtins` crate.\n-\n-<!-- NOTE(ignore) doctests don't support `no_std` binaries -->\n-\n-``` rust,ignore\n-#![feature(compiler_builtins_lib)]\n-#![no_std]\n-\n-extern crate compiler_builtins;\n-```"}, {"sha": "c527b378f7465622033bbdec317876af5dbbbea3", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -1094,7 +1094,7 @@ impl<T> FusedIterator for Iter<'_, T> {}\n \n /// An owning iterator over the elements of a `BinaryHeap`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`BinaryHeap`][`BinaryHeap`]\n+/// This `struct` is created by the [`into_iter`] method on [`BinaryHeap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.BinaryHeap.html#method.into_iter"}, {"sha": "fa8aae04011ed4a5d0f492ba79e9c5bacdc5de68", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -283,7 +283,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n \n /// An owning iterator over the entries of a `BTreeMap`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`BTreeMap`][`BTreeMap`]\n+/// This `struct` is created by the [`into_iter`] method on [`BTreeMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.BTreeMap.html#method.into_iter"}, {"sha": "f5487426814a5d0b12b11ff000f91d072bdd6512", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -83,7 +83,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n \n /// An owning iterator over the items of a `BTreeSet`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`BTreeSet`][`BTreeSet`]\n+/// This `struct` is created by the [`into_iter`] method on [`BTreeSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`BTreeSet`]: struct.BTreeSet.html"}, {"sha": "29bf2fdb30cf74d4447f4d09d42dc82d212bb3bc", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -105,7 +105,7 @@ impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n \n /// An owning iterator over the elements of a `LinkedList`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`LinkedList`][`LinkedList`]\n+/// This `struct` is created by the [`into_iter`] method on [`LinkedList`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.LinkedList.html#method.into_iter"}, {"sha": "2cc450bb68a2032c410c0df840b7a4a9aa4405e5", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -2474,7 +2474,7 @@ impl<T> FusedIterator for IterMut<'_, T> {}\n \n /// An owning iterator over the elements of a `VecDeque`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`VecDeque`][`VecDeque`]\n+/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.VecDeque.html#method.into_iter"}, {"sha": "e6162e0f571e2aaa2fa4cf7f4ec982c6829095d9", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -330,7 +330,7 @@\n //!\n //! Additionally, the return value of this function is [`fmt::Result`] which is a\n //! type alias of [`Result`]`<(), `[`std::fmt::Error`]`>`. Formatting implementations\n-//! should ensure that they propagate errors from the [`Formatter`][`Formatter`] (e.g., when\n+//! should ensure that they propagate errors from the [`Formatter`] (e.g., when\n //! calling [`write!`]). However, they should never return errors spuriously. That\n //! is, a formatting implementation must and may only return an error if the\n //! passed-in [`Formatter`] returns an error. This is because, contrary to what"}, {"sha": "7b83658fca60d03ad6e54c63ed6665adc5c262ec", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -450,7 +450,8 @@ impl<T> [T] {\n         // and `rem` is the remaining part of `n`.\n \n         // Using `Vec` to access `set_len()`.\n-        let mut buf = Vec::with_capacity(self.len().checked_mul(n).expect(\"capacity overflow\"));\n+        let capacity = self.len().checked_mul(n).expect(\"capacity overflow\");\n+        let mut buf = Vec::with_capacity(capacity);\n \n         // `2^expn` repetition is done by doubling `buf` `expn`-times.\n         buf.extend(self);\n@@ -476,7 +477,7 @@ impl<T> [T] {\n \n         // `rem` (`= n - 2^expn`) repetition is done by copying\n         // first `rem` repetitions from `buf` itself.\n-        let rem_len = self.len() * n - buf.len(); // `self.len() * rem`\n+        let rem_len = capacity - buf.len(); // `self.len() * rem`\n         if rem_len > 0 {\n             // `buf.extend(buf[0 .. rem_len])`:\n             unsafe {\n@@ -487,8 +488,7 @@ impl<T> [T] {\n                     rem_len,\n                 );\n                 // `buf.len() + rem_len` equals to `buf.capacity()` (`= self.len() * n`).\n-                let buf_cap = buf.capacity();\n-                buf.set_len(buf_cap);\n+                buf.set_len(capacity);\n             }\n         }\n         buf"}, {"sha": "93a51ccb20737e1184cca5e3ce465e77287a836f", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -242,7 +242,7 @@ use crate::raw_vec::RawVec;\n /// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n /// and then filling it back up to the same [`len`] should incur no calls to\n /// the allocator. If you wish to free up unused memory, use\n-/// [`shrink_to_fit`][`shrink_to_fit`].\n+/// [`shrink_to_fit`].\n ///\n /// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n /// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n@@ -2461,7 +2461,7 @@ where\n \n /// An iterator that moves out of a vector.\n ///\n-/// This `struct` is created by the `into_iter` method on [`Vec`][`Vec`] (provided\n+/// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n /// by the [`IntoIterator`] trait).\n ///\n /// [`Vec`]: struct.Vec.html"}, {"sha": "dcb819f9381a487e12ee32307429b7f31840dec6", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -99,6 +99,21 @@ pub trait Future {\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n }\n \n+/// Conversion into a `Future`.\n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+pub trait IntoFuture {\n+    /// The output that the future will produce on completion.\n+    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    type Output;\n+    /// Which kind of future are we turning this into?\n+    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    type Future: Future<Output = Self::Output>;\n+\n+    /// Creates a future from a value.\n+    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    fn into_future(self) -> Self::Future;\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: ?Sized + Future + Unpin> Future for &mut F {\n     type Output = F::Output;\n@@ -119,3 +134,13 @@ where\n         Pin::get_mut(self).as_mut().poll(cx)\n     }\n }\n+\n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+impl<F: Future> IntoFuture for F {\n+    type Output = F::Output;\n+    type Future = F;\n+\n+    fn into_future(self) -> Self::Future {\n+        self\n+    }\n+}"}, {"sha": "aecd57b9ce71a7260315fca5425ec5d4544bdd5b", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -5,3 +5,6 @@\n mod future;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n+\n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+pub use self::future::IntoFuture;"}, {"sha": "416c73f50bd89661bab7cfa0d0609563dbd91bd8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -697,7 +697,7 @@ extern \"rust-intrinsic\" {\n \n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n-    #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"0\")]\n+    #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n     pub fn pref_align_of<T>() -> usize;\n \n     /// The size of the referenced value in bytes.\n@@ -708,13 +708,13 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n-    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"0\")]\n+    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"none\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n-    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"0\")]\n+    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"none\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n@@ -1222,7 +1222,7 @@ extern \"rust-intrinsic\" {\n     /// let num_leading = unsafe { ctlz_nonzero(x) };\n     /// assert_eq!(num_leading, 3);\n     /// ```\n-    #[rustc_const_unstable(feature = \"constctlz\", issue = \"0\")]\n+    #[rustc_const_unstable(feature = \"constctlz\", issue = \"none\")]\n     pub fn ctlz_nonzero<T>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n@@ -1267,7 +1267,7 @@ extern \"rust-intrinsic\" {\n     /// let num_trailing = unsafe { cttz_nonzero(x) };\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_cttz\", issue = \"0\")]\n+    #[rustc_const_unstable(feature = \"const_cttz\", issue = \"none\")]\n     pub fn cttz_nonzero<T>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n@@ -1396,7 +1396,7 @@ extern \"rust-intrinsic\" {\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n-    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"none\")]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal hook used by Miri to implement unwinding."}, {"sha": "9a52823a45474a13a7c0aadb2eaaa80babd08158", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -252,16 +252,14 @@ macro_rules! debug_assert_ne {\n /// # Examples\n ///\n /// ```\n-/// #![feature(matches_macro)]\n-///\n /// let foo = 'f';\n /// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n ///\n /// let bar = Some(4);\n /// assert!(matches!(bar, Some(x) if x > 2));\n /// ```\n #[macro_export]\n-#[unstable(feature = \"matches_macro\", issue = \"65721\")]\n+#[stable(feature = \"matches_macro\", since = \"1.42.0\")]\n macro_rules! matches {\n     ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) => {\n         match $expression {"}, {"sha": "3b98bc1c272f01b396b2666fb732434ffbdfe0b0", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -142,7 +142,7 @@ pub trait Unsize<T: ?Sized> {\n /// In either of the two scenarios above, we reject usage of such a constant in\n /// a pattern match.\n ///\n-/// See also the [structural match RFC][RFC1445], and [issue 63438][] which\n+/// See also the [structural match RFC][RFC1445], and [issue 63438] which\n /// motivated migrating from attribute-based design to this trait.\n ///\n /// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md"}, {"sha": "f1f1bb13f0f24338c9af9bbee3f8e91621306cfb", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -226,7 +226,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n+    /// [subnormal], or `NaN`.\n     ///\n     /// ```\n     /// use std::f32;"}, {"sha": "5f9dc541b7d9141b0a8aa1fd42355af74648f70c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -226,7 +226,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n+    /// [subnormal], or `NaN`.\n     ///\n     /// ```\n     /// use std::f64;"}, {"sha": "04c7789fa4ff498bad2e56e6aca49116f4137a31", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -2,12 +2,12 @@\n ///\n /// Instances of `Fn` can be called repeatedly without mutating state.\n ///\n-/// *This trait (`Fn`) is not to be confused with [function pointers][]\n+/// *This trait (`Fn`) is not to be confused with [function pointers]\n /// (`fn`).*\n ///\n /// `Fn` is implemented automatically by closures which only take immutable\n /// references to captured variables or don't capture anything at all, as well\n-/// as (safe) [function pointers][] (with some caveats, see their documentation\n+/// as (safe) [function pointers] (with some caveats, see their documentation\n /// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n /// implements `Fn`, too.\n ///\n@@ -78,7 +78,7 @@ pub trait Fn<Args>: FnMut<Args> {\n ///\n /// `FnMut` is implemented automatically by closures which take mutable\n /// references to captured variables, as well as all types that implement\n-/// [`Fn`], e.g., (safe) [function pointers][] (since `FnMut` is a supertrait of\n+/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n /// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n /// implements `FnMut`, too.\n ///\n@@ -162,7 +162,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n ///\n /// `FnOnce` is implemented automatically by closure that might consume captured\n /// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n-/// [function pointers][] (since `FnOnce` is a supertrait of [`FnMut`]).\n+/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n ///\n /// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n /// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected."}, {"sha": "5628658c5bdf54dda54e6005a2e6092d190eda87", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -1370,7 +1370,7 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n /// The iterator yields one value if the result is [`Ok`], otherwise none.\n ///\n /// This struct is created by the [`into_iter`] method on\n-/// [`Result`][`Result`] (provided by the [`IntoIterator`] trait).\n+/// [`Result`] (provided by the [`IntoIterator`] trait).\n ///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html"}, {"sha": "9b4d201573238379000589ce7a39e6ac4382e1a1", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -34,7 +34,7 @@ use crate::mem;\n use crate::ops::{self, FnMut, Range};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n-use crate::ptr;\n+use crate::ptr::{self, NonNull};\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n \n@@ -628,7 +628,7 @@ impl<T> [T] {\n                 ptr.add(self.len())\n             };\n \n-            Iter { ptr, end, _marker: marker::PhantomData }\n+            Iter { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: marker::PhantomData }\n         }\n     }\n \n@@ -656,7 +656,7 @@ impl<T> [T] {\n                 ptr.add(self.len())\n             };\n \n-            IterMut { ptr, end, _marker: marker::PhantomData }\n+            IterMut { ptr: NonNull::new_unchecked(ptr), end, _marker: marker::PhantomData }\n         }\n     }\n \n@@ -3095,7 +3095,7 @@ macro_rules! is_empty {\n     // The way we encode the length of a ZST iterator, this works both for ZST\n     // and non-ZST.\n     ($self: ident) => {\n-        $self.ptr == $self.end\n+        $self.ptr.as_ptr() as *const T == $self.end\n     };\n }\n // To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n@@ -3105,17 +3105,17 @@ macro_rules! len {\n         #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n \n         let start = $self.ptr;\n-        let size = size_from_ptr(start);\n+        let size = size_from_ptr(start.as_ptr());\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            ($self.end as usize).wrapping_sub(start as usize)\n+            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n-            let diff = unsafe { unchecked_sub($self.end as usize, start as usize) };\n+            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n             // By also telling LLVM that the pointers are apart by an exact\n             // multiple of the type size, it can optimize `len() == 0` down to\n             // `start == end` instead of `(end - start) < size`.\n@@ -3161,7 +3161,7 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n-                unsafe { from_raw_parts(self.ptr, len!(self)) }\n+                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n             }\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n@@ -3171,10 +3171,10 @@ macro_rules! iterator {\n             unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     zst_shrink!(self, offset);\n-                    self.ptr\n+                    self.ptr.as_ptr()\n                 } else {\n-                    let old = self.ptr;\n-                    self.ptr = self.ptr.offset(offset);\n+                    let old = self.ptr.as_ptr();\n+                    self.ptr = NonNull::new_unchecked(self.ptr.as_ptr().offset(offset));\n                     old\n                 }\n             }\n@@ -3186,7 +3186,7 @@ macro_rules! iterator {\n             unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     zst_shrink!(self, offset);\n-                    self.ptr\n+                    self.ptr.as_ptr()\n                 } else {\n                     self.end = self.end.offset(-offset);\n                     self.end\n@@ -3215,7 +3215,7 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n-                    assume(!self.ptr.is_null());\n+                    assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n                         assume(!self.end.is_null());\n                     }\n@@ -3245,9 +3245,12 @@ macro_rules! iterator {\n                     if mem::size_of::<T>() == 0 {\n                         // We have to do it this way as `ptr` may never be 0, but `end`\n                         // could be (due to wrapping).\n-                        self.end = self.ptr;\n+                        self.end = self.ptr.as_ptr();\n                     } else {\n-                        self.ptr = self.end;\n+                        unsafe {\n+                            // End can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n+                            self.ptr = NonNull::new_unchecked(self.end as *mut T);\n+                        }\n                     }\n                     return None;\n                 }\n@@ -3308,7 +3311,7 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n-                    assume(!self.ptr.is_null());\n+                    assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n                         assume(!self.end.is_null());\n                     }\n@@ -3324,7 +3327,7 @@ macro_rules! iterator {\n             fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n-                    self.end = self.ptr;\n+                    self.end = self.ptr.as_ptr();\n                     return None;\n                 }\n                 // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n@@ -3365,7 +3368,7 @@ macro_rules! iterator {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    ptr: *const T,\n+    ptr: NonNull<T>,\n     end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n@@ -3467,7 +3470,7 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    ptr: *mut T,\n+    ptr: NonNull<T>,\n     end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n@@ -3522,7 +3525,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n+        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n     }\n \n     /// Views the underlying data as a subslice of the original data.\n@@ -5682,7 +5685,7 @@ impl_marker_for!(BytewiseEquality,\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        &*self.ptr.add(i)\n+        &*self.ptr.as_ptr().add(i)\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5692,7 +5695,7 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        &mut *self.ptr.add(i)\n+        &mut *self.ptr.as_ptr().add(i)\n     }\n     fn may_have_side_effect() -> bool {\n         false"}, {"sha": "5fca5f061caf2896fd82ed0db20bcb3d63e72426", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -168,6 +168,7 @@ pub struct LoweringContext<'a, 'hir: 'a> {\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n+    allow_into_future: Option<Lrc<[Symbol]>>,\n }\n \n pub trait Resolver {\n@@ -300,6 +301,7 @@ pub fn lower_crate<'a, 'hir>(\n         in_scope_lifetimes: Vec::new(),\n         allow_try_trait: Some([sym::try_trait][..].into()),\n         allow_gen_future: Some([sym::gen_future][..].into()),\n+        allow_into_future: Some([sym::into_future][..].into()),\n     }\n     .lower_crate(krate)\n }"}, {"sha": "dbfa351b918b248619c238735cace4ba5032effd", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -529,7 +529,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     /// Desugar `<expr>.await` into:\n     /// ```rust\n-    /// match <expr> {\n+    /// match ::std::future::IntoFuture::into_future(<expr>) {\n     ///     mut pinned => loop {\n     ///         match ::std::future::poll_with_tls_context(unsafe {\n     ///             <::std::pin::Pin>::new_unchecked(&mut pinned)\n@@ -653,11 +653,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // mut pinned => loop { ... }\n         let pinned_arm = self.arm(pinned_pat, loop_expr);\n \n-        // match <expr> {\n+        // `match ::std::future::IntoFuture::into_future(<expr>) { ... }`\n+        let into_future_span = self.mark_span_with_reason(\n+            DesugaringKind::Await,\n+            await_span,\n+            self.allow_into_future.clone(),\n+        );\n+        let expr = self.lower_expr_mut(expr);\n+        let into_future_expr = self.expr_call_std_path(\n+            into_future_span,\n+            &[sym::future, sym::IntoFuture, sym::into_future],\n+            arena_vec![self; expr],\n+        );\n+\n+        // match <into_future_expr> {\n         //     mut pinned => loop { .. }\n         // }\n-        let expr = self.lower_expr(expr);\n-        hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n+        hir::ExprKind::Match(\n+            into_future_expr,\n+            arena_vec![self; pinned_arm],\n+            hir::MatchSource::AwaitDesugar,\n+        )\n     }\n \n     fn lower_expr_closure("}, {"sha": "2be36ad418a5b5dfdd2785838787aaf0f725b1e2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -416,48 +416,62 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline]\n+    fn to_unsigned_with_bit_width(self, bits: u64) -> InterpResult<'static, u128> {\n+        let sz = Size::from_bits(bits);\n+        self.to_bits(sz)\n+    }\n+\n+    /// Converts the scalar to produce an `u8`. Fails if the scalar is a pointer.\n     pub fn to_u8(self) -> InterpResult<'static, u8> {\n-        let sz = Size::from_bits(8);\n-        let b = self.to_bits(sz)?;\n-        Ok(b as u8)\n+        self.to_unsigned_with_bit_width(8).map(|v| v as u8)\n+    }\n+\n+    /// Converts the scalar to produce an `u16`. Fails if the scalar is a pointer.\n+    pub fn to_u16(self) -> InterpResult<'static, u16> {\n+        self.to_unsigned_with_bit_width(16).map(|v| v as u16)\n     }\n \n+    /// Converts the scalar to produce an `u32`. Fails if the scalar is a pointer.\n     pub fn to_u32(self) -> InterpResult<'static, u32> {\n-        let sz = Size::from_bits(32);\n-        let b = self.to_bits(sz)?;\n-        Ok(b as u32)\n+        self.to_unsigned_with_bit_width(32).map(|v| v as u32)\n     }\n \n+    /// Converts the scalar to produce an `u64`. Fails if the scalar is a pointer.\n     pub fn to_u64(self) -> InterpResult<'static, u64> {\n-        let sz = Size::from_bits(64);\n-        let b = self.to_bits(sz)?;\n-        Ok(b as u64)\n+        self.to_unsigned_with_bit_width(64).map(|v| v as u64)\n     }\n \n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         Ok(b as u64)\n     }\n \n-    pub fn to_i8(self) -> InterpResult<'static, i8> {\n-        let sz = Size::from_bits(8);\n+    #[inline]\n+    fn to_signed_with_bit_width(self, bits: u64) -> InterpResult<'static, i128> {\n+        let sz = Size::from_bits(bits);\n         let b = self.to_bits(sz)?;\n-        let b = sign_extend(b, sz) as i128;\n-        Ok(b as i8)\n+        Ok(sign_extend(b, sz) as i128)\n+    }\n+\n+    /// Converts the scalar to produce an `i8`. Fails if the scalar is a pointer.\n+    pub fn to_i8(self) -> InterpResult<'static, i8> {\n+        self.to_signed_with_bit_width(8).map(|v| v as i8)\n+    }\n+\n+    /// Converts the scalar to produce an `i16`. Fails if the scalar is a pointer.\n+    pub fn to_i16(self) -> InterpResult<'static, i16> {\n+        self.to_signed_with_bit_width(16).map(|v| v as i16)\n     }\n \n+    /// Converts the scalar to produce an `i32`. Fails if the scalar is a pointer.\n     pub fn to_i32(self) -> InterpResult<'static, i32> {\n-        let sz = Size::from_bits(32);\n-        let b = self.to_bits(sz)?;\n-        let b = sign_extend(b, sz) as i128;\n-        Ok(b as i32)\n+        self.to_signed_with_bit_width(32).map(|v| v as i32)\n     }\n \n+    /// Converts the scalar to produce an `i64`. Fails if the scalar is a pointer.\n     pub fn to_i64(self) -> InterpResult<'static, i64> {\n-        let sz = Size::from_bits(64);\n-        let b = self.to_bits(sz)?;\n-        let b = sign_extend(b, sz) as i128;\n-        Ok(b as i64)\n+        self.to_signed_with_bit_width(64).map(|v| v as i64)\n     }\n \n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {"}, {"sha": "d9d4c7e321fb58f73d92ecbd2d73b080ec2204f4", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -101,14 +101,14 @@ pub enum ControlFlow<T> {\n pub enum NodeStatus {\n     /// This node has been examined by the depth-first search but is not yet `Settled`.\n     ///\n-    /// Also referred to as \"gray\" or \"discovered\" nodes in [CLR][].\n+    /// Also referred to as \"gray\" or \"discovered\" nodes in [CLR].\n     ///\n     /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n     Visited,\n \n     /// This node and all nodes reachable from it have been examined by the depth-first search.\n     ///\n-    /// Also referred to as \"black\" or \"finished\" nodes in [CLR][].\n+    /// Also referred to as \"black\" or \"finished\" nodes in [CLR].\n     ///\n     /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n     Settled,\n@@ -122,13 +122,13 @@ struct Event<N> {\n /// A depth-first search that also tracks when all successors of a node have been examined.\n ///\n /// This is based on the DFS described in [Introduction to Algorithms (1st ed.)][CLR], hereby\n-/// referred to as **CLR**. However, we use the terminology in [`NodeStatus`][] above instead of\n+/// referred to as **CLR**. However, we use the terminology in [`NodeStatus`] above instead of\n /// \"discovered\"/\"finished\" or \"white\"/\"grey\"/\"black\". Each node begins the search with no status,\n /// becomes `Visited` when it is first examined by the DFS and is `Settled` when all nodes\n /// reachable from it have been examined. This allows us to differentiate between \"tree\", \"back\"\n /// and \"forward\" edges (see [`TriColorVisitor::node_examined`]).\n ///\n-/// Unlike the pseudocode in [CLR][], this implementation is iterative and does not use timestamps.\n+/// Unlike the pseudocode in [CLR], this implementation is iterative and does not use timestamps.\n /// We accomplish this by storing `Event`s on the stack that result in a (possible) state change\n /// for each node. A `Visited` event signifies that we should examine this node if it has not yet\n /// been `Visited` or `Settled`. When a node is examined for the first time, we mark it as\n@@ -246,7 +246,7 @@ where\n     /// By checking the value of `prior_status`, this visitor can determine whether the edge\n     /// leading to this node was a tree edge (`None`), forward edge (`Some(Settled)`) or back edge\n     /// (`Some(Visited)`). For a full explanation of each edge type, see the \"Depth-first Search\"\n-    /// chapter in [CLR][] or [wikipedia][].\n+    /// chapter in [CLR] or [wikipedia].\n     ///\n     /// If you want to know *both* nodes linked by each edge, you'll need to modify\n     /// `TriColorDepthFirstSearch` to store a `source` node for each `Visited` event."}, {"sha": "617e56ffe3674106eca7983d329fd09a310c8cc9", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -15,7 +15,6 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]\n-#![feature(matches_macro)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7eb6f5cc073df331b1dfd4ff0e9f067b9a25648e", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -10,7 +10,7 @@\n //! interface, but make `Engine` and `ResultsCursor` the canonical way to perform and inspect a\n //! dataflow analysis. This requires porting the graphviz debugging logic to this module, deciding\n //! on a way to handle the `before` methods in `BitDenotation` and creating an adapter so that\n-//! gen-kill problems can still be evaluated efficiently. See the discussion in [#64566][] for more\n+//! gen-kill problems can still be evaluated efficiently. See the discussion in [#64566] for more\n //! information.\n //!\n //! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems"}, {"sha": "32b35c4139dad1b321657a23e4c62fca038c7f70", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -29,7 +29,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n #![feature(trait_alias)]\n-#![feature(matches_macro)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "bd895171e358e9b89971669a1d1ced34647aa68f", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -1,6 +1,5 @@\n //! A copy of the `Qualif` trait in `qualify_consts.rs` that is suitable for the new validator.\n \n-use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n use syntax_pos::DUMMY_SP;\n@@ -33,12 +32,6 @@ pub trait Qualif {\n     /// of the type.\n     fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n \n-    fn in_static(cx: &ConstCx<'_, 'tcx>, def_id: DefId) -> bool {\n-        // `mir_const_qualif` does return the qualifs in the final value of a `static`, so we could\n-        // use value-based qualification here, but we shouldn't do this without a good reason.\n-        Self::in_any_value_of_ty(cx, cx.tcx.type_of(def_id))\n-    }\n-\n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n         per_local: &impl Fn(Local) -> bool,\n@@ -101,8 +94,14 @@ pub trait Qualif {\n             }\n \n             Operand::Constant(ref constant) => {\n-                if let Some(static_) = constant.check_static_ptr(cx.tcx) {\n-                    Self::in_static(cx, static_)\n+                if constant.check_static_ptr(cx.tcx).is_some() {\n+                    // `mir_const_qualif` does return the qualifs in the final value of a `static`,\n+                    // so we could use value-based qualification here, but we shouldn't do this\n+                    // without a good reason.\n+                    //\n+                    // Note: this uses `constant.literal.ty` which is a reference or pointer to the\n+                    // type of the actual `static` item.\n+                    Self::in_any_value_of_ty(cx, constant.literal.ty)\n                 } else if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n                     if cx.tcx.trait_of_item(def_id).is_some() {"}, {"sha": "fdc587ba5dacf4f9453f9f671cacdd9cddfa8c25", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -1076,7 +1076,7 @@ impl<'a, K, V> IterMut<'a, K, V> {\n \n /// An owning iterator over the entries of a `HashMap`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`HashMap`][`HashMap`]\n+/// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.HashMap.html#method.into_iter"}, {"sha": "566e5146cf8576f38874c77bd187e4adcbac35f5", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -1101,7 +1101,7 @@ pub struct Iter<'a, K: 'a> {\n \n /// An owning iterator over the items of a `HashSet`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`HashSet`][`HashSet`]\n+/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`HashSet`]: struct.HashSet.html"}, {"sha": "908736c63931bcb2a6b6bb453eb4ba699116e3f9", "filename": "src/libstd/future.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -10,7 +10,11 @@ use core::task::{Context, Poll};\n \n #[doc(inline)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-pub use core::future::*;\n+pub use core::future::Future;\n+\n+#[doc(inline)]\n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+pub use core::future::IntoFuture;\n \n /// Wrap a generator in a future.\n ///"}, {"sha": "930bf397bc45b067e09ec451b0b96ac794e42ec7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -269,14 +269,14 @@\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(int_error_matching)]\n+#![feature(into_future)]\n #![feature(integer_atomics)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(log_syntax)]\n #![feature(manually_drop_take)]\n-#![feature(matches_macro)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(needs_panic_runtime)]"}, {"sha": "f308d511cf85041fe343ce995c7c2e4fb5887b79", "filename": "src/libstd/path.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -2,7 +2,7 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n+//! This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`]\n //! and [`str`]), for working with paths abstractly. These types are thin wrappers\n //! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax.\n@@ -296,6 +296,13 @@ where\n }\n \n // See note at the top of this module to understand why these are used:\n+//\n+// These casts are safe as OsStr is internally a wrapper around [u8] on all\n+// platforms.\n+//\n+// Note that currently this relies on the special knowledge that libstd has;\n+// these types are single-element structs but are not marked repr(transparent)\n+// or repr(C) which would make these casts allowable outside std.\n fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n     unsafe { &*(s as *const OsStr as *const [u8]) }\n }"}, {"sha": "e70204d6839fc99113bb3cdde825c745dcfb71d1", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -286,7 +286,7 @@ mod sync;\n \n mod cache_aligned;\n \n-/// The receiving half of Rust's [`channel`][] (or [`sync_channel`]) type.\n+/// The receiving half of Rust's [`channel`] (or [`sync_channel`]) type.\n /// This half can only be owned by one thread.\n ///\n /// Messages sent to the channel can be retrieved using [`recv`].\n@@ -558,7 +558,7 @@ pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n /// An error returned from the [`recv`] function on a [`Receiver`].\n ///\n /// The [`recv`] operation can only fail if the sending half of a\n-/// [`channel`][`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n+/// [`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n /// messages will ever be received.\n ///\n /// [`recv`]: struct.Receiver.html#method.recv\n@@ -1108,7 +1108,7 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`][] (or [`SyncSender`]), then this\n+    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n     /// receiver will wake up and return that message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n@@ -1194,7 +1194,7 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`][] (or [`SyncSender`]), then this\n+    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n     /// receiver will wake up and return that message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n@@ -1295,7 +1295,7 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`][] (or [`SyncSender`]), then this\n+    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n     /// receiver will wake up and return that message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while"}, {"sha": "fdd29af8581856c50b70499514247835822287f5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -25,7 +25,7 @@ use crate::sys_common::rwlock as sys;\n /// The type parameter `T` represents the data that this lock protects. It is\n /// required that `T` satisfies [`Send`] to be shared across threads and\n /// [`Sync`] to allow concurrent access through readers. The RAII guards\n-/// returned from the locking methods implement [`Deref`][] (and [`DerefMut`]\n+/// returned from the locking methods implement [`Deref`] (and [`DerefMut`]\n /// for the `write` methods) to allow access to the content of the lock.\n ///\n /// # Poisoning"}, {"sha": "7b8819377e67ce95b29368ac027db5904a1748bb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -11,7 +11,6 @@\n #![feature(const_transmute)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n-#![feature(matches_macro)]\n #![feature(nll)]\n #![feature(try_trait)]\n #![feature(slice_patterns)]"}, {"sha": "7ae037faf151d260dd7a59c87b3fe277b5c7d607", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -379,6 +379,8 @@ symbols! {\n         infer_static_outlives_requirements,\n         inline,\n         intel,\n+        into_future,\n+        IntoFuture,\n         into_iter,\n         IntoIterator,\n         into_result,"}, {"sha": "f2469de7394b065eb71edc91ed9ebc5ec5454329", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -112,7 +112,7 @@ async fn mixed_sizes() {\n fn main() {\n     assert_eq!(1028, std::mem::size_of_val(&single()));\n     assert_eq!(1032, std::mem::size_of_val(&single_with_noop()));\n-    assert_eq!(3084, std::mem::size_of_val(&joined()));\n-    assert_eq!(3084, std::mem::size_of_val(&joined_with_noop()));\n-    assert_eq!(7188, std::mem::size_of_val(&mixed_sizes()));\n+    assert_eq!(3080, std::mem::size_of_val(&joined()));\n+    assert_eq!(3080, std::mem::size_of_val(&joined_with_noop()));\n+    assert_eq!(6164, std::mem::size_of_val(&mixed_sizes()));\n }"}, {"sha": "d5ff0eb304937e3de6b8acbdd19cf0fc1f25ff6e", "filename": "src/test/ui/async-await/await-into-future.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+// edition:2018\n+\n+#![feature(into_future)]\n+\n+use std::{future::{Future, IntoFuture}, pin::Pin};\n+\n+struct AwaitMe;\n+\n+impl IntoFuture for AwaitMe {\n+    type Output = i32;\n+    type Future = Pin<Box<dyn Future<Output = i32>>>;\n+\n+    fn into_future(self) -> Self::Future {\n+        Box::pin(me())\n+    }\n+}\n+\n+async fn me() -> i32 {\n+    41\n+}\n+\n+async fn run() {\n+    assert_eq!(AwaitMe.await, 41);\n+}\n+\n+fn main() {}"}, {"sha": "e31904b6c1f7bd8f4682667e33a6f2f15631b1d1", "filename": "src/test/ui/async-await/issues/issue-62009-1.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -32,11 +32,8 @@ error[E0277]: the trait bound `[closure@$DIR/issue-62009-1.rs:13:5: 13:15]: std:\n    |\n LL |     (|_| 2333).await;\n    |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:13:5: 13:15]`\n-   | \n-  ::: $SRC_DIR/libstd/future.rs:LL:COL\n    |\n-LL |     F: Future,\n-   |        ------ required by this bound in `std::future::poll_with_tls_context`\n+   = note: required by `std::future::IntoFuture::into_future`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "d3c663c53e90593ab49081261934991de4d179c9", "filename": "src/test/ui/consts/const-eval/promote-static.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromote-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromote-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromote-static.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -0,0 +1,14 @@\n+// regression test for #67609.\n+\n+// check-pass\n+\n+static NONE: Option<String> = None;\n+\n+static NONE_REF_REF: &&Option<String> = {\n+    let x = &&NONE;\n+    x\n+};\n+\n+fn main() {\n+    println!(\"{:?}\", NONE_REF_REF);\n+}"}, {"sha": "bcb37a5f4ff5d9dc1a7551a23a644dada97d5a7b", "filename": "src/test/ui/issues/issue-51770.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fissues%2Fissue-51770.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a087ad3a924be12343bb035bf9b63ed81f650bf/src%2Ftest%2Fui%2Fissues%2Fissue-51770.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51770.rs?ref=3a087ad3a924be12343bb035bf9b63ed81f650bf", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![crate_type = \"lib\"]\n+\n+// In an older version, when NLL was still a feature, the following previously did not compile\n+// #![feature(nll)]\n+\n+use std::ops::Index;\n+\n+pub struct Test<T> {\n+    a: T,\n+}\n+\n+impl<T> Index<usize> for Test<T> {\n+    type Output = T;\n+\n+    fn index(&self, _index: usize) -> &Self::Output {\n+        &self.a\n+    }\n+}"}]}