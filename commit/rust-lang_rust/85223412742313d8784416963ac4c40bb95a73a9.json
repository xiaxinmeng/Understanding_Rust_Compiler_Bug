{"sha": "85223412742313d8784416963ac4c40bb95a73a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MjIzNDEyNzQyMzEzZDg3ODQ0MTY5NjNhYzRjNDBiYjk1YTczYTk=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-15T05:27:32Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-15T12:29:16Z"}, "message": "Remove {uint,int,u64,i64,...}::from_str,from_str_radix\n\nRemove these in favor of the two traits themselves and the wrapper\nfunction std::from_str::from_str.\n\nAdd the function std::num::from_str_radix in the corresponding role for\nthe FromStrRadix trait.", "tree": {"sha": "3f4ae690087cb210dd5b1547cd33d36391627e64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f4ae690087cb210dd5b1547cd33d36391627e64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85223412742313d8784416963ac4c40bb95a73a9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85223412742313d8784416963ac4c40bb95a73a9", "html_url": "https://github.com/rust-lang/rust/commit/85223412742313d8784416963ac4c40bb95a73a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85223412742313d8784416963ac4c40bb95a73a9/comments", "author": null, "committer": null, "parents": [{"sha": "4ecb0a372d4b246f694bf780d50809dc0fb32018", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecb0a372d4b246f694bf780d50809dc0fb32018", "html_url": "https://github.com/rust-lang/rust/commit/4ecb0a372d4b246f694bf780d50809dc0fb32018"}], "stats": {"total": 290, "additions": 132, "deletions": 158}, "files": [{"sha": "bdf3c6089f8855655fabccf734bbef98f347350e", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -91,7 +91,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n             [a, b] => {\n \n                 // 5. Try parsing both fields as ints.\n-                match (int::from_str(a), int::from_str(b)) {\n+                match (from_str::<int>(a), from_str::<int>(b)) {\n \n                     // 6. If parsing succeeded for both, push both.\n                     (Some(a), Some(b)) => pairs.push((a,b)),\n@@ -124,7 +124,7 @@ for conveying a value of type `T`, represented as `Some(T)`\n _or_ the sentinel `None`, to indicate the absence of a `T` value.\n For simple APIs, it may be sufficient to encode errors as `Option<T>`,\n returning `Some(T)` on success and `None` on error.\n-In the example program, the call to `int::from_str` returns `Option<int>`\n+In the example program, the call to `from_str::<int>` returns `Option<int>`\n with the understanding that \"all parse errors\" result in `None`.\n The resulting `Option<int>` values are matched against the pattern `(Some(a), Some(b))`\n in steps 5 and 6 in the example program,\n@@ -161,7 +161,7 @@ This second mechanism for indicating an error is called a `Result`.\n The type `std::result::Result<T,E>` is another simple `enum` type with two forms, `Ok(T)` and `Err(E)`.\n The `Result` type is not substantially different from the `Option` type in terms of its ergonomics.\n Its main advantage is that the error constructor `Err(E)` can convey _more detail_ about the error.\n-For example, the `int::from_str` API could be reformed\n+For example, the `from_str` API could be reformed\n to return a `Result` carrying an informative description of a parse error,\n like this:\n \n@@ -172,7 +172,7 @@ enum IntParseErr {\n      BadChar(char)\n }\n \n-fn int::from_str(&str) -> Result<int,IntParseErr> {\n+fn from_str(&str) -> Result<int,IntParseErr> {\n   // ...\n }\n ~~~~\n@@ -297,8 +297,8 @@ fn read_int_pairs() -> ~[(int,int)] {\n         let line = fi.read_line();\n         let fields = line.word_iter().to_owned_vec();\n         match fields {\n-            [a, b] => pairs.push((int::from_str(a).unwrap(),\n-                                  int::from_str(b).unwrap())),\n+            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n+                                  from_str::<int>(b).unwrap())),\n \n             // Explicitly fail on malformed lines.\n             _ => fail!()\n@@ -398,8 +398,8 @@ fn read_int_pairs() -> ~[(int,int)] {\n         let line = fi.read_line();\n         let fields = line.word_iter().to_owned_vec();\n         match fields {\n-            [a, b] => pairs.push((int::from_str(a).unwrap(),\n-                                  int::from_str(b).unwrap())),\n+            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n+                                  from_str::<int>(b).unwrap())),\n \n             // On malformed lines, call the condition handler and\n             // push whatever the condition handler returns.\n@@ -475,8 +475,8 @@ fn read_int_pairs() -> ~[(int,int)] {\n         let line = fi.read_line();\n         let fields = line.word_iter().to_owned_vec();\n         match fields {\n-            [a, b] => pairs.push((int::from_str(a).unwrap(),\n-                                  int::from_str(b).unwrap())),\n+            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n+                                  from_str::<int>(b).unwrap())),\n             _ => pairs.push(malformed_line::cond.raise(line.clone()))\n         }\n     }\n@@ -553,8 +553,8 @@ fn read_int_pairs() -> ~[(int,int)] {\n         let line = fi.read_line();\n         let fields = line.word_iter().to_owned_vec();\n         match fields {\n-            [a, b] => pairs.push((int::from_str(a).unwrap(),\n-                                  int::from_str(b).unwrap())),\n+            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n+                                  from_str::<int>(b).unwrap())),\n \n             // On malformed lines, call the condition handler and\n             // either ignore the line (if the handler returns `None`)\n@@ -649,8 +649,8 @@ fn read_int_pairs() -> ~[(int,int)] {\n         let line = fi.read_line();\n         let fields = line.word_iter().to_owned_vec();\n         match fields {\n-            [a, b] => pairs.push((int::from_str(a).unwrap(),\n-                                  int::from_str(b).unwrap())),\n+            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n+                                  from_str::<int>(b).unwrap())),\n \n             // On malformed lines, call the condition handler and\n             // take action appropriate to the enum value returned.\n@@ -776,7 +776,7 @@ fn main() {\n // Parse an int; if parsing fails, call the condition handler and\n // return whatever it returns.\n fn parse_int(x: &str) -> int {\n-    match int::from_str(x) {\n+    match from_str::<int>(x) {\n         Some(v) => v,\n         None => malformed_int::cond.raise(x.to_owned())\n     }\n@@ -833,8 +833,8 @@ There are three other things to note in this variant of the example program:\n     so long as the `raise` occurs within a callee (of any depth) of the logic protected by the `trap` call,\n     it will invoke the handler.\n \n-  - This variant insulates callers from a design choice in the `int` library:\n-    the `int::from_str` function was designed to return an `Option<int>`,\n+  - This variant insulates callers from a design choice in the library:\n+    the `from_str` function was designed to return an `Option<int>`,\n     but this program insulates callers from that choice,\n     routing all `None` values that arise from parsing integers in this file into the condition.\n \n@@ -873,4 +873,4 @@ To compensate for this risk, correct C++ and Java code must program in an extrem\n or else risk introducing silent and very difficult-to-debug errors due to control resuming in a corrupted heap after a caught exception.\n These errors are frequently memory-safety errors, which Rust strives to eliminate,\n and so Rust unwinding is unrecoverable within a single task:\n-once unwinding starts, the entire local heap of a task is destroyed and the task is terminated.\n\\ No newline at end of file\n+once unwinding starts, the entire local heap of a task is destroyed and the task is terminated."}, {"sha": "020da792ed7f3c9c29b495eb4e050c449b10d4e4", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -538,8 +538,8 @@ mod test {\n \n         do input_vec_state(filenames) |line, state| {\n             let nums: ~[&str] = line.split_iter(' ').collect();\n-            let file_num = uint::from_str(nums[0]).unwrap();\n-            let line_num = uint::from_str(nums[1]).unwrap();\n+            let file_num = from_str::<uint>(nums[0]).unwrap();\n+            let line_num = from_str::<uint>(nums[1]).unwrap();\n             assert_eq!(line_num, state.line_num_file);\n             assert_eq!(file_num * 3 + line_num, state.line_num);\n             true"}, {"sha": "9dabf17162d2bf810654b5bbed916c0df3de417e", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -19,7 +19,6 @@ use std::io::{ReaderUtil};\n use std::io;\n use std::option::{Option, Some, None};\n use std::to_str::ToStr;\n-use std::uint;\n \n #[deriving(Clone, Eq)]\n pub enum Identifier {\n@@ -140,7 +139,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n \n fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n     let (s, ch) = take_nonempty_prefix(rdr, ch, char::is_digit);\n-    match uint::from_str(s) {\n+    match from_str::<uint>(s) {\n         None => { bad_parse::cond.raise(()); (0, ch) },\n         Some(i) => (i, ch)\n     }\n@@ -149,7 +148,7 @@ fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n     let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n     if s.iter().all(char::is_digit) {\n-        match uint::from_str(s) {\n+        match from_str::<uint>(s) {\n             None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n             Some(i) => (Numeric(i), ch)\n         }"}, {"sha": "4dcb48d27516e6661d368cb563f333506e6f3e28", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -37,7 +37,6 @@ use std::task;\n use std::to_str::ToStr;\n use std::f64;\n use std::os;\n-use std::uint;\n \n \n // The name of a test. By convention this follows the rules for rust\n@@ -253,7 +252,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let ratchet_metrics = ratchet_metrics.map_move(|s| Path(s));\n \n     let ratchet_noise_percent = getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map_move(|s| f64::from_str(s).unwrap());\n+    let ratchet_noise_percent = ratchet_noise_percent.map_move(|s| from_str::<f64>(s).unwrap());\n \n     let save_metrics = getopts::opt_maybe_str(&matches, \"save-metrics\");\n     let save_metrics = save_metrics.map_move(|s| Path(s));\n@@ -281,7 +280,7 @@ pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n         None => None,\n         Some(s) => {\n             match s.split_iter('.').to_owned_vec() {\n-                [a, b] => match (uint::from_str(a), uint::from_str(b)) {\n+                [a, b] => match (from_str::<uint>(a), from_str::<uint>(b)) {\n                     (Some(a), Some(b)) => Some((a,b)),\n                     _ => None\n                 },"}, {"sha": "3a43c3364c67bfe478ae70f514aed16d7c41d0b1", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -383,20 +383,6 @@ impl Primitive for $T {\n \n // String conversion functions and impl str -> num\n \n-/// Parse a string as a number in base 10.\n-#[inline]\n-pub fn from_str(s: &str) -> Option<$T> {\n-    strconv::from_str_common(s, 10u, true, false, false,\n-                         strconv::ExpNone, false, false)\n-}\n-\n-/// Parse a string as a number in the given base.\n-#[inline]\n-pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-    strconv::from_str_common(s, radix, true, false, false,\n-                         strconv::ExpNone, false, false)\n-}\n-\n /// Parse a byte slice as a number in the given base.\n #[inline]\n pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n@@ -407,14 +393,16 @@ pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        from_str(s)\n+        strconv::from_str_common(s, 10u, true, false, false,\n+                             strconv::ExpNone, false, false)\n     }\n }\n \n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        from_str_radix(s, radix)\n+        strconv::from_str_common(s, radix, true, false, false,\n+                             strconv::ExpNone, false, false)\n     }\n }\n \n@@ -462,10 +450,7 @@ mod tests {\n     use super::*;\n \n     use int;\n-    use i16;\n     use i32;\n-    use i64;\n-    use i8;\n     use num;\n     use sys;\n \n@@ -670,20 +655,20 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-        assert_eq!(from_str(\"0\"), Some(0 as $T));\n-        assert_eq!(from_str(\"3\"), Some(3 as $T));\n-        assert_eq!(from_str(\"10\"), Some(10 as $T));\n-        assert_eq!(i32::from_str(\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str(\"00100\"), Some(100 as $T));\n+        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n+        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n+        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n+        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n \n-        assert_eq!(from_str(\"-1\"), Some(-1 as $T));\n-        assert_eq!(from_str(\"-3\"), Some(-3 as $T));\n-        assert_eq!(from_str(\"-10\"), Some(-10 as $T));\n-        assert_eq!(i32::from_str(\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str(\"-00100\"), Some(-100 as $T));\n+        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n+        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n+        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n+        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n \n-        assert!(from_str(\" \").is_none());\n-        assert!(from_str(\"x\").is_none());\n+        assert!(from_str::<$T>(\" \").is_none());\n+        assert!(from_str::<$T>(\"x\").is_none());\n     }\n \n     #[test]\n@@ -751,36 +736,36 @@ mod tests {\n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8::from_str(\"127\"), Some(i8_val));\n-        assert!(i8::from_str(\"128\").is_none());\n+        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n+        assert!(from_str::<i8>(\"128\").is_none());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8::from_str(\"-128\"), Some(i8_val));\n-        assert!(i8::from_str(\"-129\").is_none());\n+        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n+        assert!(from_str::<i8>(\"-129\").is_none());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16::from_str(\"32767\"), Some(i16_val));\n-        assert!(i16::from_str(\"32768\").is_none());\n+        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n+        assert!(from_str::<i16>(\"32768\").is_none());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16::from_str(\"-32768\"), Some(i16_val));\n-        assert!(i16::from_str(\"-32769\").is_none());\n+        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n+        assert!(from_str::<i16>(\"-32769\").is_none());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32::from_str(\"2147483647\"), Some(i32_val));\n-        assert!(i32::from_str(\"2147483648\").is_none());\n+        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n+        assert!(from_str::<i32>(\"2147483648\").is_none());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32::from_str(\"-2147483648\"), Some(i32_val));\n-        assert!(i32::from_str(\"-2147483649\").is_none());\n+        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n+        assert!(from_str::<i32>(\"-2147483649\").is_none());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64::from_str(\"9223372036854775807\"), Some(i64_val));\n-        assert!(i64::from_str(\"9223372036854775808\").is_none());\n+        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n+        assert!(from_str::<i64>(\"9223372036854775808\").is_none());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64::from_str(\"-9223372036854775808\"), Some(i64_val));\n-        assert!(i64::from_str(\"-9223372036854775809\").is_none());\n+        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n+        assert!(from_str::<i64>(\"-9223372036854775809\").is_none());\n     }\n \n     #[test]"}, {"sha": "f0efeb762cce125f90c285a3144875da2e0196f7", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -439,6 +439,11 @@ pub trait FromStrRadix {\n     fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n+/// A utility function that just calls FromStrRadix::from_str_radix\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n+    FromStrRadix::from_str_radix(str, radix)\n+}\n+\n /// Calculates a power to a given radix, optimized for uint `pow` and `radix`.\n ///\n /// Returns `radix^pow` as `T`."}, {"sha": "0a9c912a6e2acbe0bbc142dd820190adafea86ec", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -238,20 +238,6 @@ impl Int for $T {}\n \n // String conversion functions and impl str -> num\n \n-/// Parse a string as a number in base 10.\n-#[inline]\n-pub fn from_str(s: &str) -> Option<$T> {\n-    strconv::from_str_common(s, 10u, false, false, false,\n-                             strconv::ExpNone, false, false)\n-}\n-\n-/// Parse a string as a number in the given base.\n-#[inline]\n-pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-    strconv::from_str_common(s, radix, false, false, false,\n-                             strconv::ExpNone, false, false)\n-}\n-\n /// Parse a byte slice as a number in the given base.\n #[inline]\n pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n@@ -262,14 +248,16 @@ pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        from_str(s)\n+        strconv::from_str_common(s, 10u, false, false, false,\n+                                 strconv::ExpNone, false, false)\n     }\n }\n \n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        from_str_radix(s, radix)\n+        strconv::from_str_common(s, radix, false, false, false,\n+                                 strconv::ExpNone, false, false)\n     }\n }\n \n@@ -347,9 +335,6 @@ mod tests {\n     use num;\n     use sys;\n     use u16;\n-    use u32;\n-    use u64;\n-    use u8;\n \n     #[test]\n     fn test_num() {\n@@ -459,15 +444,15 @@ mod tests {\n \n     #[test]\n     pub fn test_from_str() {\n-        assert_eq!(from_str(\"0\"), Some(0u as $T));\n-        assert_eq!(from_str(\"3\"), Some(3u as $T));\n-        assert_eq!(from_str(\"10\"), Some(10u as $T));\n-        assert_eq!(u32::from_str(\"123456789\"), Some(123456789 as u32));\n-        assert_eq!(from_str(\"00100\"), Some(100u as $T));\n+        assert_eq!(from_str::<$T>(\"0\"), Some(0u as $T));\n+        assert_eq!(from_str::<$T>(\"3\"), Some(3u as $T));\n+        assert_eq!(from_str::<$T>(\"10\"), Some(10u as $T));\n+        assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n+        assert_eq!(from_str::<$T>(\"00100\"), Some(100u as $T));\n \n-        assert!(from_str(\"\").is_none());\n-        assert!(from_str(\" \").is_none());\n-        assert!(from_str(\"x\").is_none());\n+        assert!(from_str::<$T>(\"\").is_none());\n+        assert!(from_str::<$T>(\" \").is_none());\n+        assert!(from_str::<$T>(\"x\").is_none());\n     }\n \n     #[test]\n@@ -514,36 +499,36 @@ mod tests {\n     #[test]\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8::from_str(\"255\"), Some(u8_val));\n-        assert!(u8::from_str(\"256\").is_none());\n+        assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n+        assert!(from_str::<u8>(\"256\").is_none());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8::from_str(\"0\"), Some(u8_val));\n-        assert!(u8::from_str(\"-1\").is_none());\n+        assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n+        assert!(from_str::<u8>(\"-1\").is_none());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16::from_str(\"65535\"), Some(u16_val));\n-        assert!(u16::from_str(\"65536\").is_none());\n+        assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n+        assert!(from_str::<u16>(\"65536\").is_none());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16::from_str(\"0\"), Some(u16_val));\n-        assert!(u16::from_str(\"-1\").is_none());\n+        assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n+        assert!(from_str::<u16>(\"-1\").is_none());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32::from_str(\"4294967295\"), Some(u32_val));\n-        assert!(u32::from_str(\"4294967296\").is_none());\n+        assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n+        assert!(from_str::<u32>(\"4294967296\").is_none());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32::from_str(\"0\"), Some(u32_val));\n-        assert!(u32::from_str(\"-1\").is_none());\n+        assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n+        assert!(from_str::<u32>(\"-1\").is_none());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64::from_str(\"18446744073709551615\"), Some(u64_val));\n-        assert!(u64::from_str(\"18446744073709551616\").is_none());\n+        assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n+        assert!(from_str::<u64>(\"18446744073709551616\").is_none());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64::from_str(\"0\"), Some(u64_val));\n-        assert!(u64::from_str(\"-1\").is_none());\n+        assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n+        assert!(from_str::<u64>(\"-1\").is_none());\n     }\n \n     #[test]"}, {"sha": "54084bb14c08aa6164d4864e87e4340c039d3255", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+use from_str::from_str;\n use libc::{uintptr_t, exit, STDERR_FILENO};\n use option::{Some, None, Option};\n use rt::util::dumb_println;\n@@ -28,7 +29,7 @@ static log_level_names : &'static[&'static str] = &'static[\"error\", \"warn\", \"inf\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    let num = u32::from_str(level);\n+    let num = from_str::<u32>(level);\n     let mut log_level;\n     match num {\n         Some(num) => {"}, {"sha": "e92accd283b7eb21dd27020d4a75a98e2fb6f0f8", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use libc;\n-use uint;\n use option::{Some, None};\n use cell::Cell;\n use clone::Clone;\n@@ -382,9 +381,10 @@ fn base_port() -> uint {\n /// stress tests. Default 1.\n pub fn stress_factor() -> uint {\n     use os::getenv;\n+    use from_str::from_str;\n \n     match getenv(\"RUST_RT_STRESS\") {\n-        Some(val) => uint::from_str(val).unwrap(),\n+        Some(val) => from_str::<uint>(val).unwrap(),\n         None => 1\n     }\n }"}, {"sha": "c267a673fcedfababfb57c1f2cbeb7a0a75e42b2", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -20,7 +20,7 @@ use parse::token::{str_to_ident};\n use std::cast::transmute;\n use std::char;\n use std::either;\n-use std::u64;\n+use std::num::from_str_radix;\n use std::util;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n@@ -444,7 +444,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         if num_str.len() == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = match u64::from_str_radix(num_str, base as uint) {\n+        let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n             None => rdr.fatal(~\"int literal is too large\")\n         };\n@@ -509,7 +509,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         if num_str.len() == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = match u64::from_str_radix(num_str, base as uint) {\n+        let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n             None => rdr.fatal(~\"int literal is too large\")\n         };"}, {"sha": "6978b9209d8bcc97db065ecb7acb31d15b839480", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -21,7 +21,7 @@ pub trait read {\n \n impl read for int {\n     fn readMaybe(s: ~str) -> Option<int> {\n-        int::from_str(s)\n+        from_str::<int>(s)\n     }\n }\n "}, {"sha": "7077cee80e946df8e6679b515304d1dd154615ee", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -97,7 +97,7 @@ fn main() {\n     let args = os::args();\n     let n_keys = {\n         if args.len() == 2 {\n-            uint::from_str(args[1]).unwrap()\n+            from_str::<uint>(args[1]).unwrap()\n         } else {\n             1000000\n         }"}, {"sha": "ead1128e99437882917f17ce4e478c272d827569", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -157,7 +157,7 @@ fn main() {\n     let args = os::args();\n     let num_keys = {\n         if args.len() == 2 {\n-            uint::from_str(args[1]).unwrap()\n+            from_str::<uint>(args[1]).unwrap()\n         } else {\n             100 // woefully inadequate for any real measurement\n         }"}, {"sha": "6b1319aa0c90f75beb13c3457879ded2b274020c", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         args\n     };\n \n-    let n = uint::from_str(args[1]).unwrap();\n+    let n = from_str::<uint>(args[1]).unwrap();\n \n     for i in range(0u, n) {\n         let x = i.to_str();"}, {"sha": "ff66fd121d98cb899c4d5ad3acf758ddb20e5b12", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -418,8 +418,8 @@ fn main() {\n         args\n     };\n \n-    let scale = uint::from_str(args[1]).unwrap();\n-    let num_keys = uint::from_str(args[2]).unwrap();\n+    let scale = from_str::<uint>(args[1]).unwrap();\n+    let num_keys = from_str::<uint>(args[2]).unwrap();\n     let do_validate = false;\n     let do_sequential = true;\n "}, {"sha": "af15acc15357999cfb4a0423038a4846c0533913", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -59,8 +59,8 @@ fn run(args: &[~str]) {\n \n     let to_child = SharedChan::new(to_child);\n \n-    let size = uint::from_str(args[1]).unwrap();\n-    let workers = uint::from_str(args[2]).unwrap();\n+    let size = from_str::<uint>(args[1]).unwrap();\n+    let workers = from_str::<uint>(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "3b095650b7ed9e094f255eed8425553a002cdf99", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -53,8 +53,8 @@ fn run(args: &[~str]) {\n     let (from_parent, to_child) = stream();\n     let to_child = SharedChan::new(to_child);\n \n-    let size = uint::from_str(args[1]).unwrap();\n-    let workers = uint::from_str(args[2]).unwrap();\n+    let size = from_str::<uint>(args[1]).unwrap();\n+    let workers = from_str::<uint>(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "dd56d550e61c29e0bd32a673473d7e1bb06469e9", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -78,8 +78,8 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).unwrap();\n-    let msg_per_task = uint::from_str(args[2]).unwrap();\n+    let num_tasks = from_str::<uint>(args[1]).unwrap();\n+    let msg_per_task = from_str::<uint>(args[2]).unwrap();\n \n     let (num_chan, num_port) = init();\n     let num_chan = Cell::new(num_chan);"}, {"sha": "130bd4e7d16a11f81de9354f140a57b6a503b00d", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -74,8 +74,8 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).unwrap();\n-    let msg_per_task = uint::from_str(args[2]).unwrap();\n+    let num_tasks = from_str::<uint>(args[1]).unwrap();\n+    let msg_per_task = from_str::<uint>(args[2]).unwrap();\n \n     let (num_chan, num_port) = init();\n     let num_chan = Cell::new(num_chan);"}, {"sha": "ec796713c21d180b6b80578a2283ab1ba1001cb4", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -65,13 +65,13 @@ fn main() {\n \n     let args = os::args();\n     let n = if args.len() == 3 {\n-        uint::from_str(args[1]).unwrap()\n+        from_str::<uint>(args[1]).unwrap()\n     } else {\n         10000\n     };\n \n     let m = if args.len() == 3 {\n-        uint::from_str(args[2]).unwrap()\n+        from_str::<uint>(args[2]).unwrap()\n     } else {\n         4\n     };"}, {"sha": "3c981611e503912a1a58346df7f81830cfbe134e", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -38,7 +38,7 @@ fn main() {\n \n     let args = os::args();\n     let n = if args.len() == 2 {\n-        uint::from_str(args[1]).unwrap()\n+        from_str::<uint>(args[1]).unwrap()\n     } else {\n         10\n     };"}, {"sha": "6693e2e19853327426f7b8f0afbc549bd61b0665", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -21,7 +21,7 @@ fn main() {\n \n     let args = os::args();\n     let n = if args.len() == 2 {\n-        uint::from_str(args[1]).unwrap()\n+        from_str::<uint>(args[1]).unwrap()\n     } else {\n         100000\n     };"}, {"sha": "3e7feb01c4acf39730576e809c39e4c7f87103cd", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -34,6 +34,6 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = int::from_str(args[1]).unwrap();\n+    let n = from_str::<int>(args[1]).unwrap();\n     printfln!(\"Ack(3,%d): %d\\n\", n, ack(3, n));\n }"}, {"sha": "e956beedaabe1d6d2a7f63e972052ac3d13814e3", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -48,7 +48,7 @@ fn main() {\n         args\n     };\n \n-    let n = int::from_str(args[1]).unwrap();\n+    let n = from_str::<int>(args[1]).unwrap();\n     let min_depth = 4;\n     let mut max_depth;\n     if min_depth + 2 > n {"}, {"sha": "e4f395e5eca1ba90d092bbce849f55aebece6a55", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -212,7 +212,7 @@ fn main() {\n         args\n     };\n \n-    let nn = uint::from_str(args[1]).unwrap();\n+    let nn = from_str::<uint>(args[1]).unwrap();\n \n     print_complements();\n     io::println(\"\");"}, {"sha": "402b3be9542f80c7e3eb937a8b218b515ce88ec1", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -128,7 +128,7 @@ fn main() {\n         io::stdout()\n     };\n \n-    let n = int::from_str(args[1]).unwrap();\n+    let n = from_str::<int>(args[1]).unwrap();\n \n     let iub: ~[AminoAcids] =\n         make_cumulative(~[acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),"}, {"sha": "f902a8b533903c72a70aefc0077ee7acca377a5d", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -30,6 +30,6 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = int::from_str(args[1]).unwrap();\n+    let n = from_str::<int>(args[1]).unwrap();\n     printfln!(\"%d\\n\", fib(n));\n }"}, {"sha": "6940c97d76e34e06d1471ab59c9f402066227f54", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -39,8 +39,8 @@ fn main() {\n     } else {\n         args\n     };\n-    let max = uint::from_str(args[1]).unwrap();\n-    let rep = uint::from_str(args[2]).unwrap();\n+    let max = from_str::<uint>(args[1]).unwrap();\n+    let rep = from_str::<uint>(args[2]).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "2c5b434a4760f1fa21765ae9039e9e0a46e51b43", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -74,9 +74,9 @@ impl Sudoku {\n             let comps: ~[&str] = line.trim().split_iter(',').collect();\n \n             if comps.len() == 3u {\n-                let row     = uint::from_str(comps[0]).unwrap() as u8;\n-                let col     = uint::from_str(comps[1]).unwrap() as u8;\n-                g[row][col] = uint::from_str(comps[2]).unwrap() as u8;\n+                let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n+                let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n+                g[row][col] = from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n                 fail!(\"Invalid sudoku file\");"}, {"sha": "0827f7d34475b28aa683582dcdb335c7ab76e1d8", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -52,7 +52,7 @@ fn main() {\n     };\n \n     let (p,c) = comm::stream();\n-    child_generation(uint::from_str(args[1]).unwrap(), c);\n+    child_generation(from_str::<uint>(args[1]).unwrap(), c);\n     if p.try_recv().is_none() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "5aeba3f415da35263e54e080dfe49c8971bc5124", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -74,7 +74,7 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).unwrap();\n+    let num_tasks = from_str::<uint>(args[1]).unwrap();\n \n     // Main group #0 waits for unsupervised group #1.\n     // Grandparent group #1 waits for middle group #2, then fails, killing #3."}, {"sha": "9e04ad65eb239142309dab9a9a7272513f1d3d96", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -56,7 +56,7 @@ fn main() {\n         args\n     };\n \n-    let children = uint::from_str(args[1]).get();\n+    let children = from_str::<uint>(args[1]).get();\n     let (wait_port, wait_chan) = stream();\n     do task::spawn {\n         calc(children, &wait_chan);"}, {"sha": "80217da60f98ec739e906d7609e26abddc421bed", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = uint::from_str(args[1]).unwrap();\n+    let n = from_str::<uint>(args[1]).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(|| f(n) ); i += 1u; }\n }"}, {"sha": "6df859d938b54f5f6566a224261d83d45f191fcc", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -62,7 +62,7 @@ priv fn chop(s: ~str) -> ~str {\n }\n \n priv fn parse_bulk(io: @io::Reader) -> Result {\n-    match int::from_str(chop(io.read_line())) {\n+    match from_str::<int>(chop(io.read_line())) {\n     None => fail!(),\n     Some(-1) => Nil,\n     Some(len) if len >= 0 => parse_data(len as uint, io),\n@@ -71,7 +71,7 @@ priv fn parse_bulk(io: @io::Reader) -> Result {\n }\n \n priv fn parse_multi(io: @io::Reader) -> Result {\n-    match int::from_str(chop(io.read_line())) {\n+    match from_str::<int>(chop(io.read_line())) {\n     None => fail!(),\n     Some(-1) => Nil,\n     Some(0) => List(~[]),\n@@ -81,7 +81,7 @@ priv fn parse_multi(io: @io::Reader) -> Result {\n }\n \n priv fn parse_int(io: @io::Reader) -> Result {\n-    match int::from_str(chop(io.read_line())) {\n+    match from_str::<int>(chop(io.read_line())) {\n     None => fail!(),\n     Some(i) => Int(i)\n     }"}, {"sha": "1d9d8fa219fc33eb0167349a7912adf13b245817", "filename": "src/test/run-pass/match-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85223412742313d8784416963ac4c40bb95a73a9/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs?ref=85223412742313d8784416963ac4c40bb95a73a9", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     // sometimes we have had trouble finding\n     // the right type for f, as we unified\n     // bot and u32 here\n-    let f = match uint::from_str(\"1234\") {\n+    let f = match from_str::<uint>(\"1234\") {\n         None => return (),\n         Some(num) => num as u32\n     };"}]}