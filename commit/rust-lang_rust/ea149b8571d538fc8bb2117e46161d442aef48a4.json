{"sha": "ea149b8571d538fc8bb2117e46161d442aef48a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMTQ5Yjg1NzFkNTM4ZmM4YmIyMTE3ZTQ2MTYxZDQ0MmFlZjQ4YTQ=", "commit": {"author": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2017-06-12T17:07:54Z"}, "committer": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2017-06-15T19:42:35Z"}, "message": "Utf8Lossy type with chunks iterator and impl Display and Debug", "tree": {"sha": "3ba3ef157bf2a05918fc5b6f108cd54cf3e24199", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ba3ef157bf2a05918fc5b6f108cd54cf3e24199"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea149b8571d538fc8bb2117e46161d442aef48a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea149b8571d538fc8bb2117e46161d442aef48a4", "html_url": "https://github.com/rust-lang/rust/commit/ea149b8571d538fc8bb2117e46161d442aef48a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea149b8571d538fc8bb2117e46161d442aef48a4/comments", "author": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "url": "https://api.github.com/repos/rust-lang/rust/commits/258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "html_url": "https://github.com/rust-lang/rust/commit/258ae6dd9b1a8ac97986852fc9f00f7687004ccb"}], "stats": {"total": 432, "additions": 333, "deletions": 99}, "files": [{"sha": "2cb81029f95e2a1ea89d9fb4aad1ca5111456057", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 22, "deletions": 99, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=ea149b8571d538fc8bb2117e46161d442aef48a4", "patch": "@@ -61,8 +61,8 @@ use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n-use core::str as core_str;\n use core::str::pattern::Pattern;\n+use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n@@ -533,111 +533,34 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n-        let mut i;\n-        match str::from_utf8(v) {\n-            Ok(s) => return Cow::Borrowed(s),\n-            Err(e) => i = e.valid_up_to(),\n-        }\n+        let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n \n-        const TAG_CONT_U8: u8 = 128;\n-        const REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n-        let total = v.len();\n-        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n-            unsafe { *xs.get_unchecked(i) }\n-        }\n-        fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n-            if i >= total { 0 } else { unsafe_get(xs, i) }\n-        }\n+        let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n+            let lossy::Utf8LossyChunk { valid, broken } = chunk;\n+            if valid.len() == v.len() {\n+                debug_assert!(broken.is_empty());\n+                return Cow::Borrowed(valid);\n+            }\n+            (valid, broken)\n+        } else {\n+            return Cow::Borrowed(\"\");\n+        };\n \n-        let mut res = String::with_capacity(total);\n+        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n \n-        if i > 0 {\n-            unsafe { res.as_mut_vec().extend_from_slice(&v[..i]) };\n+        let mut res = String::with_capacity(v.len());\n+        res.push_str(first_valid);\n+        if !first_broken.is_empty() {\n+            res.push_str(REPLACEMENT);\n         }\n \n-        // subseqidx is the index of the first byte of the subsequence we're\n-        // looking at.  It's used to copy a bunch of contiguous good codepoints\n-        // at once instead of copying them one by one.\n-        let mut subseqidx = i;\n-\n-        while i < total {\n-            let i_ = i;\n-            let byte = unsafe_get(v, i);\n-            i += 1;\n-\n-            macro_rules! error { () => ({\n-                unsafe {\n-                    if subseqidx != i_ {\n-                        res.as_mut_vec().extend_from_slice(&v[subseqidx..i_]);\n-                    }\n-                    subseqidx = i;\n-                    res.as_mut_vec().extend_from_slice(REPLACEMENT);\n-                }\n-            })}\n-\n-            if byte < 128 {\n-                // subseqidx handles this\n-            } else {\n-                let w = core_str::utf8_char_width(byte);\n-\n-                match w {\n-                    2 => {\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    3 => {\n-                        match (byte, safe_get(v, i, total)) {\n-                            (0xE0, 0xA0...0xBF) => (),\n-                            (0xE1...0xEC, 0x80...0xBF) => (),\n-                            (0xED, 0x80...0x9F) => (),\n-                            (0xEE...0xEF, 0x80...0xBF) => (),\n-                            _ => {\n-                                error!();\n-                                continue;\n-                            }\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    4 => {\n-                        match (byte, safe_get(v, i, total)) {\n-                            (0xF0, 0x90...0xBF) => (),\n-                            (0xF1...0xF3, 0x80...0xBF) => (),\n-                            (0xF4, 0x80...0x8F) => (),\n-                            _ => {\n-                                error!();\n-                                continue;\n-                            }\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    _ => {\n-                        error!();\n-                        continue;\n-                    }\n-                }\n+        for lossy::Utf8LossyChunk { valid, broken } in iter {\n+            res.push_str(valid);\n+            if !broken.is_empty() {\n+                res.push_str(REPLACEMENT);\n             }\n         }\n-        if subseqidx < total {\n-            unsafe { res.as_mut_vec().extend_from_slice(&v[subseqidx..total]) };\n-        }\n+\n         Cow::Owned(res)\n     }\n "}, {"sha": "b3346dbe2fb1240ddd1033907e169134b2ad4442", "filename": "src/libstd_unicode/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2FCargo.toml?ref=ea149b8571d538fc8bb2117e46161d442aef48a4", "patch": "@@ -9,5 +9,9 @@ path = \"lib.rs\"\n test = false\n bench = false\n \n+[[test]]\n+name = \"std_unicode_tests\"\n+path = \"tests/lib.rs\"\n+\n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "98624800b4c6c15c2529fb97496b32efe40006b1", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=ea149b8571d538fc8bb2117e46161d442aef48a4", "patch": "@@ -34,6 +34,8 @@\n \n #![feature(char_escape_debug)]\n #![feature(core_char_ext)]\n+#![feature(str_internals)]\n+#![feature(core_intrinsics)]\n #![feature(decode_utf8)]\n #![feature(fused)]\n #![feature(fn_traits)]\n@@ -45,6 +47,7 @@\n mod tables;\n mod u_str;\n pub mod char;\n+pub mod lossy;\n \n #[allow(deprecated)]\n pub mod str {"}, {"sha": "b914cbcf4b85f8a7bf15941610300bfd5b30743c", "filename": "src/libstd_unicode/lossy.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flossy.rs?ref=ea149b8571d538fc8bb2117e46161d442aef48a4", "patch": "@@ -0,0 +1,198 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::str as core_str;\n+use core::fmt;\n+use core::fmt::Write;\n+use char;\n+use core::intrinsics;\n+\n+\n+/// Lossy UTF-8 string.\n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+pub struct Utf8Lossy {\n+    bytes: [u8]\n+}\n+\n+impl Utf8Lossy {\n+    pub fn from_str(s: &str) -> &Utf8Lossy {\n+        Utf8Lossy::from_bytes(s.as_bytes())\n+    }\n+\n+    pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n+        unsafe { intrinsics::transmute(bytes) }\n+    }\n+\n+    pub fn chunks(&self) -> Utf8LossyChunksIter {\n+        Utf8LossyChunksIter { source: &self.bytes }\n+    }\n+}\n+\n+\n+/// Iterator over lossy UTF-8 string\n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+pub struct Utf8LossyChunksIter<'a> {\n+    source: &'a [u8],\n+}\n+\n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct Utf8LossyChunk<'a> {\n+    /// Sequence of valid chars.\n+    /// Can be empty between broken UTF-8 chars.\n+    pub valid: &'a str,\n+    /// Single broken char, empty if none.\n+    /// Empty iff iterator item is last.\n+    pub broken: &'a [u8],\n+}\n+\n+impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n+    type Item = Utf8LossyChunk<'a>;\n+\n+    fn next(&mut self) -> Option<Utf8LossyChunk<'a>> {\n+        if self.source.len() == 0 {\n+            return None;\n+        }\n+\n+        const TAG_CONT_U8: u8 = 128;\n+        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n+            unsafe { *xs.get_unchecked(i) }\n+        }\n+        fn safe_get(xs: &[u8], i: usize) -> u8 {\n+            if i >= xs.len() { 0 } else { unsafe_get(xs, i) }\n+        }\n+\n+        let mut i = 0;\n+        while i < self.source.len() {\n+            let i_ = i;\n+\n+            let byte = unsafe_get(self.source, i);\n+            i += 1;\n+\n+            if byte < 128 {\n+\n+            } else {\n+                let w = core_str::utf8_char_width(byte);\n+\n+                macro_rules! error { () => ({\n+                    unsafe {\n+                        let r = Utf8LossyChunk {\n+                            valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n+                            broken: &self.source[i_..i],\n+                        };\n+                        self.source = &self.source[i..];\n+                        return Some(r);\n+                    }\n+                })}\n+\n+                match w {\n+                    2 => {\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                    }\n+                    3 => {\n+                        match (byte, safe_get(self.source, i)) {\n+                            (0xE0, 0xA0 ... 0xBF) => (),\n+                            (0xE1 ... 0xEC, 0x80 ... 0xBF) => (),\n+                            (0xED, 0x80 ... 0x9F) => (),\n+                            (0xEE ... 0xEF, 0x80 ... 0xBF) => (),\n+                            _ => {\n+                                error!();\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                    }\n+                    4 => {\n+                        match (byte, safe_get(self.source, i)) {\n+                            (0xF0, 0x90 ... 0xBF) => (),\n+                            (0xF1 ... 0xF3, 0x80 ... 0xBF) => (),\n+                            (0xF4, 0x80 ... 0x8F) => (),\n+                            _ => {\n+                                error!();\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                    }\n+                    _ => {\n+                        error!();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let r = Utf8LossyChunk {\n+            valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n+            broken: &[],\n+        };\n+        self.source = &[];\n+        return Some(r);\n+    }\n+}\n+\n+\n+impl fmt::Display for Utf8Lossy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for Utf8LossyChunk { valid, broken } in self.chunks() {\n+            f.write_str(valid)?;\n+            if !broken.is_empty() {\n+                f.write_char(char::REPLACEMENT_CHARACTER)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Debug for Utf8Lossy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_char('\"')?;\n+\n+        for Utf8LossyChunk { valid, broken } in self.chunks() {\n+\n+            // Valid part.\n+            // Here we partially parse UTF-8 again which is suboptimal.\n+            {\n+                let mut from = 0;\n+                for (i, c) in valid.char_indices() {\n+                    let esc = c.escape_debug();\n+                    // If char needs escaping, flush backlog so far and write, else skip\n+                    if esc.len() != 1 {\n+                        f.write_str(&valid[from..i])?;\n+                        for c in esc {\n+                            f.write_char(c)?;\n+                        }\n+                        from = i + c.len_utf8();\n+                    }\n+                }\n+                f.write_str(&valid[from..])?;\n+            }\n+\n+            // Broken parts of string as hex escape.\n+            for &b in broken {\n+                write!(f, \"\\\\x{:02x}\", b)?;\n+            }\n+        }\n+\n+        f.write_char('\"')\n+    }\n+}"}, {"sha": "9535ec18763e663e4cbc4f5b674571d24bb29170", "filename": "src/libstd_unicode/tests/lib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftests%2Flib.rs?ref=ea149b8571d538fc8bb2117e46161d442aef48a4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(str_internals, unicode)]\n+\n+extern crate std_unicode;\n+\n+mod lossy;"}, {"sha": "e05d06685563557857049463af15e816ec447514", "filename": "src/libstd_unicode/tests/lossy.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Ftests%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea149b8571d538fc8bb2117e46161d442aef48a4/src%2Flibstd_unicode%2Ftests%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftests%2Flossy.rs?ref=ea149b8571d538fc8bb2117e46161d442aef48a4", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std_unicode::lossy::*;\n+\n+#[test]\n+fn chunks() {\n+    let mut iter = Utf8Lossy::from_bytes(b\"hello\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"hello\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes()).chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC2 There\\xFF Goodbye\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC2\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xFF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC0\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xE6\\x83\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF5foo\\xF5\\x80bar\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF5\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF5\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF1\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF1\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF1\\x80\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF4\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF4\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF4\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF0\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\\u{10000}bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    // surrogates\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xED\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xA0\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xED\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+}\n+\n+#[test]\n+fn display() {\n+    assert_eq!(\n+        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n+        &format!(\"{}\", Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\")));\n+}\n+\n+#[test]\n+fn debug() {\n+    assert_eq!(\n+        \"\\\"Hello\\\\xc0\\\\x80 There\\\\xe6\\\\x83 Goodbye\\\\u{10d4ea}\\\"\",\n+        &format!(\"{:?}\", Utf8Lossy::from_bytes(\n+            b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\")));\n+}"}]}