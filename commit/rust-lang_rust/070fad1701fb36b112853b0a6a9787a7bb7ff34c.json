{"sha": "070fad1701fb36b112853b0a6a9787a7bb7ff34c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MGZhZDE3MDFmYjM2YjExMjg1M2IwYTZhOTc4N2E3YmI3ZmYzNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-01T02:52:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-01T02:52:09Z"}, "message": "Auto merge of #37573 - ruuda:faster-cursor, r=alexcrichton\n\nAdd small-copy optimization for copy_from_slice\n\n## Summary\n\nDuring benchmarking, I found that one of my programs spent between 5 and 10 percent of the time doing memmoves. Ultimately I tracked these down to single-byte slices being copied with a memcopy. Doing a manual copy if the slice contains only one element can speed things up significantly. For my program, this reduced the running time by 20%.\n\n## Background\n\nI am optimizing a program that relies heavily on reading a single byte at a time. To avoid IO overhead, I read all data into a vector once, and then I use a `Cursor` around that vector to read from. During profiling, I noticed that `__memmove_avx_unaligned_erms` was hot, taking up 7.3% of the running time. It turns out that these were caused by calls to `Cursor::read()`, which calls `<&[u8] as Read>::read()`, which calls `&[T]::copy_from_slice()`, which calls `ptr::copy_nonoverlapping()`. This one is implemented as a memcopy. Copying a single byte with a memcopy is very wasteful, because (at least on my platform) it involves calling `memcpy` in libc. This is an indirect call when libc is linked dynamically, and furthermore `memcpy` is optimized for copying large amounts of data at the cost of a bit of overhead for small copies.\n\n## Benchmarks\n\nBefore I made this change, `perf` reported the following for my program. I only included the relevant functions, and how they rank. (This is on a different machine than where I ran the original benchmarks. It has an older CPU, so `__memmove_sse2_unaligned_erms` is called instead of `__memmove_avx_unaligned_erms`.)\n\n```\n#3   5.47%  bench_decode  libc-2.24.so      [.] __memmove_sse2_unaligned_erms\n#5   1.67%  bench_decode  libc-2.24.so      [.] memcpy@GLIBC_2.2.5\n#6   1.51%  bench_decode  bench_decode      [.] memcpy@plt\n```\n\n`memcpy` is eating up 8.65% of the total running time, and the overhead of dispatching to a specialized fast copy function (`memcpy@GLIBC` showing up) is clearly visible. The price of dynamic linking (`memcpy@plt` showing up) is visible too.\n\nAfter this change, this is what `perf` reports:\n\n```\n#5   0.33%  bench_decode  libc-2.24.so      [.] __memmove_sse2_unaligned_erms\n#14  0.01%  bench_decode  libc-2.24.so      [.] memcpy@GLIBC_2.2.5\n```\n\nNow only 0.34% of the running time is spent on memcopies. The dynamic linking overhead is not significant at all any more.\n\nTo add some more data, my program generates timing results for the operation in its main loop. These are the timings before and after the change:\n\n| Time before   | Time after    | After/Before |\n|---------------|---------------|--------------|\n| 29.8 \u00b1 0.8 ns | 23.6 \u00b1 0.5 ns |  0.79 \u00b1 0.03 |\n\nThe time is basically the total running time divided by a constant; the actual numbers are not important. This change reduced the total running time by 21% (much more than the original 9% spent on memmoves, likely because the CPU is stalling a lot less because data dependencies are more transparent). Of course YMMV and for most programs this will not matter at all. But when it does, the gains can be significant!\n\n## Alternatives\n\n* At first I implemented this in `io::Cursor`. I moved it to `&[T]::copy_from_slice()` instead, but this might be too intrusive, especially because it applies to all `T`, not just `u8`. To restrict this to `io::Read`, `<&[u8] as Read>::read()` is probably the best place.\n* I tried copying bytes in a loop up to 64 or 8 bytes before calling `Read::read`, but both resulted in about a 20% slowdown instead of speedup.", "tree": {"sha": "0e7c4ca0c94d5ebd07f53ac4481c0571481e649c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e7c4ca0c94d5ebd07f53ac4481c0571481e649c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/070fad1701fb36b112853b0a6a9787a7bb7ff34c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/070fad1701fb36b112853b0a6a9787a7bb7ff34c", "html_url": "https://github.com/rust-lang/rust/commit/070fad1701fb36b112853b0a6a9787a7bb7ff34c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/070fad1701fb36b112853b0a6a9787a7bb7ff34c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc81742b1869001e1926f130623eb5b8cf16e7a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc81742b1869001e1926f130623eb5b8cf16e7a9", "html_url": "https://github.com/rust-lang/rust/commit/dc81742b1869001e1926f130623eb5b8cf16e7a9"}, {"sha": "3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "html_url": "https://github.com/rust-lang/rust/commit/3be2c3b3092e934bdc2db67d5bdcabd611deca9c"}], "stats": {"total": 22, "additions": 20, "deletions": 2}, "files": [{"sha": "f691289811bc6514d57262cf753f778e6a5af0ae", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/070fad1701fb36b112853b0a6a9787a7bb7ff34c/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070fad1701fb36b112853b0a6a9787a7bb7ff34c/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=070fad1701fb36b112853b0a6a9787a7bb7ff34c", "patch": "@@ -157,7 +157,16 @@ impl<'a> Read for &'a [u8] {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let amt = cmp::min(buf.len(), self.len());\n         let (a, b) = self.split_at(amt);\n-        buf[..amt].copy_from_slice(a);\n+\n+        // First check if the amount of bytes we want to read is small:\n+        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n+        // for a single byte the overhead is significant.\n+        if amt == 1 {\n+            buf[0] = a[0];\n+        } else {\n+            buf[..amt].copy_from_slice(a);\n+        }\n+\n         *self = b;\n         Ok(amt)\n     }\n@@ -169,7 +178,16 @@ impl<'a> Read for &'a [u8] {\n                                   \"failed to fill whole buffer\"));\n         }\n         let (a, b) = self.split_at(buf.len());\n-        buf.copy_from_slice(a);\n+\n+        // First check if the amount of bytes we want to read is small:\n+        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n+        // for a single byte the overhead is significant.\n+        if buf.len() == 1 {\n+            buf[0] = a[0];\n+        } else {\n+            buf.copy_from_slice(a);\n+        }\n+\n         *self = b;\n         Ok(())\n     }"}]}