{"sha": "c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NGJhNjM4MmQyNzRkNWIxY2U5ZWY5YTgzOTJlYzczNTFhNDcxNGI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-11T18:08:26Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-28T20:34:42Z"}, "message": "Rename `OpportunisticTypeResolver` to `OpportunisticVarResolver`", "tree": {"sha": "5be13428abe2e5a04539ea1575f19837cda12258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5be13428abe2e5a04539ea1575f19837cda12258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "html_url": "https://github.com/rust-lang/rust/commit/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55dcc20f9a605e19d3c34bfc7f84380f079350fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/55dcc20f9a605e19d3c34bfc7f84380f079350fb", "html_url": "https://github.com/rust-lang/rust/commit/55dcc20f9a605e19d3c34bfc7f84380f079350fb"}], "stats": {"total": 224, "additions": 111, "deletions": 113}, "files": [{"sha": "f87c6977f33d0261ea99cd3339b5184aa5c4a1ad", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -652,7 +652,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         for sp in prior_arms {\n                             err.span_label(*sp, format!(\n                                 \"this is found to be of type `{}`\",\n-                                self.resolve_type_vars_if_possible(&last_ty),\n+                                self.resolve_vars_if_possible(&last_ty),\n                             ));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {\n@@ -1278,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n@@ -1291,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }"}, {"sha": "972ffbe1820a5569ee59ae336b4f89652e4dcce2", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n         });\n         match ty_opt {\n             Some(ty) => {\n-                let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                let ty = self.infcx.resolve_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n                         (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n@@ -94,7 +94,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>\n     ) -> DiagnosticBuilder<'gcx> {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n@@ -166,7 +166,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>\n     ) -> DiagnosticBuilder<'gcx> {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err = struct_span_err!(self.tcx.sess,"}, {"sha": "1dd391950254dd55db1ea4b198d84138489ef6f7", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -210,11 +210,11 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             _ => (),\n         }\n \n-        let expected_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n+        let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n         });\n-        let actual_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n+        let actual_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: actual_substs,\n         });"}, {"sha": "7461d8bc72860ec7ffbe44a23004bf1d0c84095c", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let (mut fudger, value) = self.probe(|snapshot| {\n             match f() {\n                 Ok(value) => {\n-                    let value = self.resolve_type_vars_if_possible(&value);\n+                    let value = self.resolve_vars_if_possible(&value);\n \n                     // At this point, `value` could in principle refer\n                     // to inference variables that have been created during"}, {"sha": "a4a7efdbc9e3e204d9687b9afeffba6b46dae0fa", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -1174,7 +1174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Process the region constraints and report any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_type_vars_if_possible` as well as `fully_resolve`.\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n     pub fn resolve_regions_and_report_errors(\n         &self,\n         region_context: DefId,\n@@ -1262,7 +1262,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(&t).to_string()\n+        self.resolve_vars_if_possible(&t).to_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -1271,7 +1271,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(t).to_string()\n+        self.resolve_vars_if_possible(t).to_string()\n     }\n \n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n@@ -1297,28 +1297,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.type_variables.borrow_mut().root_var(var)\n     }\n \n-    /// Where possible, replaces type/int/float variables in\n+    /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n-    /// are unaffected. If a type variable has not been unified, it\n+    /// are unaffected. If a type/const variable has not been unified, it\n     /// is left as is. This is an idempotent operation that does\n     /// not affect inference state in any way and so you can do it\n     /// at will.\n-    pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n             return value.clone(); // avoid duplicated subst-folding\n         }\n-        let mut r = resolve::OpportunisticTypeResolver::new(self);\n+        let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n     /// Returns first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n-    /// `resolve_type_vars_if_possible()`.\n+    /// `resolve_vars_if_possible()`.\n     pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -1389,7 +1389,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     where\n         M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n-        let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n+        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is `Error`.\n@@ -1446,7 +1446,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> bool {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n \n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only."}, {"sha": "3f114595597f742c0f13e0478cd257608c89d89d", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -284,9 +284,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_opaque_type: def_id={:?}\", def_id);\n         debug!(\"constrain_opaque_type: opaque_defn={:#?}\", opaque_defn);\n \n-        let tcx = self.tcx;\n-\n-        let concrete_ty = self.resolve_type_vars_if_possible(&opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(&opaque_defn.concrete_ty);\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n "}, {"sha": "3e626999200fea98900e671761c1feea6d703efc", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         debug!(\"add_implied_bounds()\");\n \n         for &ty in fn_sig_tys {\n-            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            let ty = infcx.resolve_vars_if_possible(&ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n             let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n             self.add_outlives_bounds(Some(infcx), implied_bounds)"}, {"sha": "90b3be213854c93e0b0059f24e323c2c40569409", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -177,7 +177,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 sup_type, sub_region, origin\n             );\n \n-            let sup_type = self.resolve_type_vars_if_possible(&sup_type);\n+            let sup_type = self.resolve_vars_if_possible(&sup_type);\n \n             if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n                 let outlives = &mut TypeOutlives::new(\n@@ -215,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             implicit_region_bound,\n             param_env,\n         );\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n }"}, {"sha": "98f63c803ca0385bdcd211a740a8715251797e11", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -4,25 +4,25 @@ use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst, TypeFlags};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n-// OPPORTUNISTIC TYPE RESOLVER\n+// OPPORTUNISTIC KIND RESOLVER\n \n-/// The opportunistic type resolver can be used at any time. It simply replaces\n-/// type variables that have been unified with the things they have\n+/// The opportunistic kind resolver can be used at any time. It simply replaces\n+/// type/const variables that have been unified with the things they have\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct OpportunisticVarResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        OpportunisticTypeResolver { infcx }\n+        OpportunisticVarResolver { infcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }"}, {"sha": "8d7c6f18a854f23913db941643cdeabcdd977a70", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -458,10 +458,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             .unwrap_or(true)\n     }\n \n-    fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+    fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.infcx.map(|infcx| infcx.resolve_type_vars_if_possible(value))\n+        self.infcx.map(|infcx| infcx.resolve_vars_if_possible(value))\n             .unwrap_or_else(|| value.clone())\n     }\n \n@@ -475,7 +475,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                   -> McResult<Ty<'tcx>> {\n         match ty {\n             Some(ty) => {\n-                let ty = self.resolve_type_vars_if_possible(&ty);\n+                let ty = self.resolve_vars_if_possible(&ty);\n                 if ty.references_error() || ty.is_ty_var() {\n                     debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n                     Err(())\n@@ -602,7 +602,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         where F: FnOnce() -> McResult<cmt_<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.resolve_type_vars_if_possible(&adjustment.target);\n+        let target = self.resolve_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar."}, {"sha": "7505b3c1be8444b1995938f93b80c259bb4e2716", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -307,9 +307,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 continue;\n             }\n \n-            // Call infcx.resolve_type_vars_if_possible to see if we can\n+            // Call infcx.resolve_vars_if_possible to see if we can\n             // get rid of any inference variables.\n-            let obligation = infcx.resolve_type_vars_if_possible(\n+            let obligation = infcx.resolve_vars_if_possible(\n                 &Obligation::new(dummy_cause.clone(), new_env, pred)\n             );\n             let result = select.select(&obligation);\n@@ -642,7 +642,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n+            predicate = select.infcx().resolve_vars_if_possible(&predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain"}, {"sha": "a7b5e6cf41b779981a49d74ff4f09b1fa0c0775d", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -33,7 +33,7 @@ fn in_environment(\n     obligation: PredicateObligation<'tcx>\n ) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n     assert!(!infcx.is_in_snapshot());\n-    let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+    let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n     let environment = match obligation.param_env.def_id {\n         Some(def_id) => infcx.tcx.environment(def_id),"}, {"sha": "591557eb2bea5785efbea87f5f0883a0f498d7d7", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n         }\n \n-        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.resolve_vars_if_possible(result);\n         let result = self.tcx.erase_regions(&result);\n \n         self.tcx.lift_to_global(&result).unwrap_or_else(||"}, {"sha": "c6521a931bb29b0876e5f003ad40ece17beecabd", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -155,7 +155,7 @@ fn overlap_within_probe(\n         a_impl_header.predicates\n                      .iter()\n                      .chain(&b_impl_header.predicates)\n-                     .map(|p| infcx.resolve_type_vars_if_possible(p))\n+                     .map(|p| infcx.resolve_vars_if_possible(p))\n                      .map(|p| Obligation { cause: ObligationCause::dummy(),\n                                            param_env,\n                                            recursion_depth: 0,\n@@ -171,7 +171,7 @@ fn overlap_within_probe(\n         return None\n     }\n \n-    let impl_header = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n+    let impl_header = selcx.infcx().resolve_vars_if_possible(&a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n "}, {"sha": "5a2bf07b065f8747ea20c2898718afa7da71a5a2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                error: &MismatchedProjectionTypes<'tcx>)\n     {\n         let predicate =\n-            self.resolve_type_vars_if_possible(&obligation.predicate);\n+            self.resolve_vars_if_possible(&obligation.predicate);\n \n         if predicate.references_error() {\n             return\n@@ -531,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         where T: fmt::Display + TypeFoldable<'tcx>\n     {\n         let predicate =\n-            self.resolve_type_vars_if_possible(&obligation.predicate);\n+            self.resolve_vars_if_possible(&obligation.predicate);\n         let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n                                        \"overflow evaluating the requirement `{}`\",\n                                        predicate);\n@@ -553,7 +553,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n     pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_type_vars_if_possible(&cycle.to_owned());\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n         assert!(cycle.len() > 0);\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n@@ -589,7 +589,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(\n+                let parent_trait_ref = self.resolve_vars_if_possible(\n                     &data.parent_trait_ref);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n@@ -625,7 +625,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 match obligation.predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n                         let trait_predicate =\n-                            self.resolve_type_vars_if_possible(trait_predicate);\n+                            self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -749,7 +749,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self.region_outlives_predicate(&obligation.cause,\n                                                                  &predicate).err().unwrap();\n                         struct_span_err!(\n@@ -761,7 +761,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                         let predicate =\n-                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                            self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(self.tcx.sess, span, E0280,\n                             \"the requirement `{}` is not satisfied\",\n                             predicate)\n@@ -852,8 +852,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n \n                 if expected_trait_ref.self_ty().references_error() {\n                     return;\n@@ -1345,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // ambiguous impls. The latter *ought* to be a\n         // coherence violation, so we don't report it here.\n \n-        let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n         let span = obligation.cause.span;\n \n         debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n@@ -1617,7 +1617,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n@@ -1631,7 +1631,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 err.note(\n                     &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                              parent_trait_ref,\n@@ -1672,7 +1672,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n                                cause_code: &ObligationCauseCode<'tcx>) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n \n             if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n                 return true;"}, {"sha": "c7943d16885bd018e134b4d4e48051dc5305e22d", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -178,7 +178,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n-        let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+        let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n@@ -261,7 +261,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }) {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()\n-                           .resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                           .resolve_vars_if_possible(&pending_obligation.obligation),\n                        pending_obligation.stalled_on);\n                 return ProcessResult::Unchanged;\n             }\n@@ -272,7 +272,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n \n         if obligation.predicate.has_infer_types() {\n             obligation.predicate =\n-                self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+                self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n         debug!(\"process_obligation: obligation = {:?}\", obligation);\n@@ -318,7 +318,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref());\n \n                         debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                               self.selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                               self.selcx.infcx().resolve_vars_if_possible(obligation),\n                                pending_obligation.stalled_on);\n \n                         ProcessResult::Unchanged\n@@ -519,7 +519,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n+     .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n      .filter(|t| match t.sty { ty::Infer(_) => true, _ => false })"}, {"sha": "c135b0b759c6f2d3574917667d4e8db90c41a72a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -927,7 +927,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n     debug!(\"fully_normalize: select_all_or_error start\");\n     fulfill_cx.select_all_or_error(infcx)?;\n     debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n     debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }"}, {"sha": "88bb3172c5e79f84edea0de30cca5d111c2b0653", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn fold<T:TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n-        let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n+        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n         if !value.has_projections() {\n             value\n@@ -508,7 +508,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n {\n     let infcx = selcx.infcx();\n \n-    let projection_ty = infcx.resolve_type_vars_if_possible(&projection_ty);\n+    let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n     let cache_key = ProjectionCacheKey { ty: projection_ty };\n \n     debug!(\"opt_normalize_projection_type(\\\n@@ -1614,7 +1614,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n                 // from a specific call to `opt_normalize_projection_type` - if\n                 // there's no precise match, the original cache entry is \"stranded\"\n                 // anyway.\n-                ty: infcx.resolve_type_vars_if_possible(&predicate.projection_ty)\n+                ty: infcx.resolve_vars_if_possible(&predicate.projection_ty)\n             })\n     }\n }"}, {"sha": "c4aa14d2b7ebcb69472d82ab5d0db1e3db695668", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -54,7 +54,7 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n                     &orig_values,\n                     result)\n                 {\n-                    let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                    let ty = self.infcx.resolve_vars_if_possible(&ty);\n                     let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n                     return InferOk {\n                         value: kinds,"}, {"sha": "5933d2366e81c337a16652a2a5faa0e935d11a59", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -97,7 +97,7 @@ fn scrape_region_constraints<'gcx, 'tcx, R>(\n         region_obligations\n             .iter()\n             .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_type_vars_if_possible(&ty), r)),\n+            .map(|(ty, r)| (infcx.resolve_vars_if_possible(&ty), r)),\n         &region_constraint_data,\n     );\n "}, {"sha": "ba96233b85328191b0491c8e5c0793f410313b62", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -1463,7 +1463,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let obligation = &stack.obligation;\n         let predicate = self.infcx()\n-            .resolve_type_vars_if_possible(&obligation.predicate);\n+            .resolve_vars_if_possible(&obligation.predicate);\n \n         // OK to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1621,7 +1621,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n             predicate: self.infcx()\n-                .resolve_type_vars_if_possible(&obligation.predicate),\n+                .resolve_vars_if_possible(&obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -1737,7 +1737,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx()\n-            .resolve_type_vars_if_possible(&obligation.predicate);\n+            .resolve_vars_if_possible(&obligation.predicate);\n         let (placeholder_trait_predicate, placeholder_map) = self.infcx()\n             .replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!("}, {"sha": "b5d45d040fb99e25382a9876e1f2d34bb85b4f5b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -278,7 +278,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n                 // Now resolve the *substitution* we built for the target earlier, replacing\n                 // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+                Ok(infcx.resolve_vars_if_possible(&target_substs))\n             }\n         }\n     })"}, {"sha": "20b7f7eef0a16d4f06b3d433d799971f4ae98b66", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -1263,7 +1263,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n                             opaque_decl.concrete_ty,\n-                            infcx.resolve_type_vars_if_possible(&opaque_decl.concrete_ty),\n+                            infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n                             opaque_defn_ty\n                         );\n                         obligations.add(infcx"}, {"sha": "96c647ca31e6fca339194abb83faba601471d514", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -411,7 +411,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n \n     fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {\n-        let string = format!(\"{:?}\", self.infcx.resolve_type_vars_if_possible(value));\n+        let string = format!(\"{:?}\", self.infcx.resolve_vars_if_possible(value));\n         Box::new(string)\n     }\n "}, {"sha": "c1f14cd3f8ed51e182382e2fc33ede2103625ca7", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -57,7 +57,7 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n         use rustc::traits::WhereClause::*;\n         use rustc::infer::canonical::OriginalQueryValues;\n \n-        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n+        let goal = self.infcx.resolve_vars_if_possible(goal);\n \n         debug!(\"program_clauses(goal = {:?})\", goal);\n "}, {"sha": "f1b8588790b72a4fe3fbbdb3c2399b17c95e6594", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -111,8 +111,8 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     ) -> Fallible<ChalkExClause<'tcx>> {\n         debug!(\n             \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n-            self.infcx.resolve_type_vars_if_possible(&ex_clause),\n-            self.infcx.resolve_type_vars_if_possible(selected_goal)\n+            self.infcx.resolve_vars_if_possible(&ex_clause),\n+            self.infcx.resolve_vars_if_possible(selected_goal)\n         );\n \n         let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars("}, {"sha": "73bb3fb5b9a2de6972ccf3e3b86f1a0d4091b250", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -121,7 +121,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                        let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n                         let mut components = smallvec![];\n                         tcx.push_outlives_components(ty_a, &mut components);\n                         implied_bounds_from_components(r_b, components)"}, {"sha": "24fa5e97752a67e84e526e67219402bdb473876f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -36,7 +36,7 @@ fn normalize_ty_after_erasing_regions<'tcx>(\n                     None,\n                 );\n \n-                let normalized_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+                let normalized_value = infcx.resolve_vars_if_possible(&normalized_value);\n                 let normalized_value = infcx.tcx.erase_regions(&normalized_value);\n                 tcx.lift_to_global(&normalized_value).unwrap()\n             }"}, {"sha": "5a84e0cb85a6ec0643c7153be6ee40daf9731ffc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // Now that we know the types can be unified we find the unified type and use\n                 // it to type the entire expression.\n-                let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n+                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);"}, {"sha": "38c3ee776369aa49c750803067fef773a4e08f46", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             body_id,\n             param_env,\n             steps: vec![],\n-            cur_ty: infcx.resolve_type_vars_if_possible(&base_ty),\n+            cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n             obligations: vec![],\n             at_start: true,\n             include_raw_pointers: false,\n@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                ty, normalized_ty, obligations);\n         self.obligations.extend(obligations);\n \n-        Some(self.infcx.resolve_type_vars_if_possible(&normalized_ty))\n+        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an\n@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     /// Returns the final type we ended up with, which may well be an\n     /// inference variable (we will resolve it first, if possible).\n     pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.infcx.resolve_type_vars_if_possible(&self.cur_ty)\n+        self.infcx.resolve_vars_if_possible(&self.cur_ty)\n     }\n \n     pub fn step_count(&self) -> usize {"}, {"sha": "f8cad733ca1c87abcc292ab32d8998dc58d3f52f", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"pointer_kind({:?}, {:?})\", t, span);\n \n-        let t = self.resolve_type_vars_if_possible(&t);\n+        let t = self.resolve_vars_if_possible(&t);\n \n         if t.references_error() {\n             return Err(ErrorReported);\n@@ -334,7 +334,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0620,\n                                          \"cast to unsized type: `{}` as `{}`\",\n-                                         fcx.resolve_type_vars_if_possible(&self.expr_ty),\n+                                         fcx.resolve_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n             ty::Ref(_, _, mt) => {"}, {"sha": "419f61b0ee2c061444fcedd18eeb585f45eb9a7b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let input_tys = if is_fn {\n             let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n-            let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n+            let arg_param_ty = self.resolve_vars_if_possible(&arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n             match arg_param_ty.sty {\n@@ -295,7 +295,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n-        let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n+        let ret_param_ty = self.resolve_vars_if_possible(&ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n         let sig = self.tcx.mk_fn_sig("}, {"sha": "d64be24f7538f548fbb0eedc44b8110bf1a623bf", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -575,7 +575,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {\n                     if trait_ref.def_id() == unsize_did {\n-                        let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                        let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n                         let self_ty = trait_ref.skip_binder().self_ty();\n                         let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);"}, {"sha": "3785c3c8684b4961ba835a0636c8e9fcb1e0cf8c", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n         });\n \n         if let Some(yield_span) = live_across_yield {\n-            let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n+            let ty = self.fcx.resolve_vars_if_possible(&ty);\n \n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                    expr, scope, ty, self.expr_count, yield_span);"}, {"sha": "493486321ac2fed0e8dacfb92024984370e0617a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n+        let base_ty = self.resolve_vars_if_possible(&base_ty);\n \n         // Need to deref because overloaded place ops take self by-reference.\n         let base_ty = base_ty.builtin_deref(false)"}, {"sha": "213d53cf48254a38ca10619e1c8d2e6a0f10cc13", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     scope: ProbeScope)\n                     -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        let self_ty = self.resolve_vars_if_possible(&self_ty);\n         self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n                             self_ty, call_expr.hir_id, scope)\n     }"}, {"sha": "d78e013708277f15f2a1260df49e8b3f28a2dce5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -1338,7 +1338,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             // and point at it rather than reporting the entire\n                             // trait-ref?\n                             result = ProbeResult::NoMatch;\n-                            let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                            let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n                             possibly_unsatisfied_predicates.push(trait_ref);\n                         }\n                     }\n@@ -1351,7 +1351,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             // Evaluate those obligations to see if they might possibly hold.\n             for o in candidate_obligations.into_iter().chain(sub_obligations) {\n-                let o = self.resolve_type_vars_if_possible(&o);\n+                let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n@@ -1364,7 +1364,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if let (Some(return_ty), Some(xform_ret_ty)) =\n                     (self.return_type, probe.xform_ret_ty)\n                 {\n-                    let xform_ret_ty = self.resolve_type_vars_if_possible(&xform_ret_ty);\n+                    let xform_ret_ty = self.resolve_vars_if_possible(&xform_ret_ty);\n                     debug!(\"comparing return_ty {:?} with xform ret ty {:?}\",\n                            return_ty,\n                            probe.xform_ret_ty);"}, {"sha": "d2fcb987bc2d853958a187c9b1778a64bb4735d9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_type_vars_if_possible(&rcvr_ty);\n+                let actual = self.resolve_vars_if_possible(&rcvr_ty);\n                 let ty_str = self.ty_to_string(actual);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {"}, {"sha": "8701d751f2d91aefb234162a2282496254aab30a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -330,13 +330,13 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) => {\n-                ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectCastableToType(fcx.resolve_vars_if_possible(&t))\n             }\n             ExpectHasType(t) => {\n-                ExpectHasType(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectHasType(fcx.resolve_vars_if_possible(&t))\n             }\n             ExpectRvalueLikeUnsized(t) => {\n-                ExpectRvalueLikeUnsized(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(&t))\n             }\n         }\n     }\n@@ -2067,7 +2067,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n-    /// version (resolve_type_vars_if_possible), this version will\n+    /// version (resolve_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n     /// to get more type information.\n     fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2080,7 +2080,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n-        ty = self.resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(&ty);\n         if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n@@ -2091,7 +2091,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         self.select_obligations_where_possible(false);\n-        ty = self.resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(&ty);\n \n         debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n         ty\n@@ -2127,7 +2127,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n-               id, self.resolve_type_vars_if_possible(&ty), self.tag());\n+               id, self.resolve_vars_if_possible(&ty), self.tag());\n         self.tables.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n@@ -2950,9 +2950,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // is the missing argument of type `()`?\n             let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&expected_arg_tys[0]).is_unit()\n+                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n             } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&fn_inputs[0]).is_unit()\n+                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n             } else {\n                 false\n             };\n@@ -3063,7 +3063,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::FnDef(..) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n+                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n                     }\n                     _ => {}\n@@ -3253,7 +3253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Record all the argument types, with the substitutions\n             // produced from the above subtyping unification.\n             Ok(formal_args.iter().map(|ty| {\n-                self.resolve_type_vars_if_possible(ty)\n+                self.resolve_vars_if_possible(ty)\n             }).collect())\n         }).unwrap_or_default();\n         debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n@@ -4333,9 +4333,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty_saving_user_provided_ty(t);\n-                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n                 let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n \n                 // Eagerly check for some obvious errors.\n                 if t_expr.references_error() || t_cast.references_error() {"}, {"sha": "0bab63582aaa1830dad70f7819b96036a1192b79", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 method.sig.output()\n             }\n             Err(()) => {\n-                let actual = self.resolve_type_vars_if_possible(&operand_ty);\n+                let actual = self.resolve_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n                     let mut err = struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\","}, {"sha": "62c9c7c8b1c37d9446dd2c565d5f79e620a9a2e1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_type_vars_if_possible(&unresolved_ty)\n+        self.resolve_vars_if_possible(&unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node."}, {"sha": "a856013b719fea3708e40c6f5d60454fadb7f950", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94ba6382d274d5b1ce9ef9a8392ec7351a4714b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c94ba6382d274d5b1ce9ef9a8392ec7351a4714b", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n-                let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n+                let inner_ty = self.fcx.resolve_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n@@ -149,10 +149,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n             | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n-                let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n+                let lhs_ty = self.fcx.resolve_vars_if_possible(&lhs_ty);\n \n                 let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n-                let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n+                let rhs_ty = self.fcx.resolve_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n@@ -192,7 +192,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             // All valid indexing looks like this; might encounter non-valid indexes at this point\n             if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).sty {\n                 let index_ty = tables.expr_ty_adjusted(&index);\n-                let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n+                let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n \n                 if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                     // Remove the method call record"}]}