{"sha": "195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NWYxZDc3YmQ2YmRkODk4OGQ1Y2JkMTA3Y2IwYzRjZmE0Njk0Y2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T14:34:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:47:57Z"}, "message": "Rename and modernize region enum names", "tree": {"sha": "783e7787cc9ca4d4efbf3e3cb24e568cadac9ce7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/783e7787cc9ca4d4efbf3e3cb24e568cadac9ce7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "html_url": "https://github.com/rust-lang/rust/commit/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e54a7323dc3cc8b121de313b9af2d16424b086e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e54a7323dc3cc8b121de313b9af2d16424b086e", "html_url": "https://github.com/rust-lang/rust/commit/5e54a7323dc3cc8b121de313b9af2d16424b086e"}], "stats": {"total": 624, "additions": 316, "deletions": 308}, "files": [{"sha": "18447e6cbc8cd65a9ba3f8e3ab25399f36b9edd8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -228,22 +228,22 @@ fn parse_region_substs(st: &mut PState, conv: conv_did) -> ty::RegionSubsts {\n     }\n }\n \n-fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::bound_region {\n+fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n     match next(st) {\n         'a' => {\n             let id = parse_uint(st);\n             assert_eq!(next(st), '|');\n-            ty::br_anon(id)\n+            ty::BrAnon(id)\n         }\n         '[' => {\n             let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n             let ident = st.tcx.sess.ident_of(parse_str(st, ']'));\n-            ty::br_named(def, ident)\n+            ty::BrNamed(def, ident)\n         }\n         'f' => {\n             let id = parse_uint(st);\n             assert_eq!(next(st), '|');\n-            ty::br_fresh(id)\n+            ty::BrFresh(id)\n         }\n         _ => fail!(\"parse_bound_region: bad input\")\n     }\n@@ -257,7 +257,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        ty::re_fn_bound(id, br)\n+        ty::ReLateBound(id, br)\n       }\n       'B' => {\n         assert_eq!(next(st), '[');\n@@ -266,27 +266,27 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n         let nm = st.tcx.sess.ident_of(parse_str(st, ']'));\n-        ty::re_type_bound(node_id, index, nm)\n+        ty::ReEarlyBound(node_id, index, nm)\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n         let id = parse_uint(st) as int;\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        ty::re_free(ty::FreeRegion {scope_id: id,\n+        ty::ReFree(ty::FreeRegion {scope_id: id,\n                                     bound_region: br})\n       }\n       's' => {\n         let id = parse_uint(st) as int;\n         assert_eq!(next(st), '|');\n-        ty::re_scope(id)\n+        ty::ReScope(id)\n       }\n       't' => {\n-        ty::re_static\n+        ty::ReStatic\n       }\n       'e' => {\n-        ty::re_static\n+        ty::ReStatic\n       }\n       _ => fail!(\"parse_region: bad input\")\n     }"}, {"sha": "d304db0935ac5452902eb8addc75765bd0fe341e", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -155,49 +155,49 @@ fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n \n fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n-        ty::re_fn_bound(id, br) => {\n+        ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id);\n             enc_bound_region(w, cx, br);\n             mywrite!(w, \"]\");\n         }\n-        ty::re_type_bound(node_id, index, ident) => {\n+        ty::ReEarlyBound(node_id, index, ident) => {\n             mywrite!(w, \"B[{}|{}|{}]\",\n                      node_id,\n                      index,\n                      cx.tcx.sess.str_of(ident));\n         }\n-        ty::re_free(ref fr) => {\n+        ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[{}|\", fr.scope_id);\n             enc_bound_region(w, cx, fr.bound_region);\n             mywrite!(w, \"]\");\n         }\n-        ty::re_scope(nid) => {\n+        ty::ReScope(nid) => {\n             mywrite!(w, \"s{}|\", nid);\n         }\n-        ty::re_static => {\n+        ty::ReStatic => {\n             mywrite!(w, \"t\");\n         }\n-        ty::re_empty => {\n+        ty::ReEmpty => {\n             mywrite!(w, \"e\");\n         }\n-        ty::re_infer(_) => {\n+        ty::ReInfer(_) => {\n             // these should not crop up after typeck\n             cx.diag.handler().bug(\"Cannot encode region variables\");\n         }\n     }\n }\n \n-fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::bound_region) {\n+fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     match br {\n-        ty::br_anon(idx) => {\n+        ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n         }\n-        ty::br_named(d, s) => {\n+        ty::BrNamed(d, s) => {\n             mywrite!(w, \"[{}|{}]\",\n                      (cx.ds)(d),\n                      cx.tcx.sess.str_of(s));\n         }\n-        ty::br_fresh(id) => {\n+        ty::BrFresh(id) => {\n             mywrite!(w, \"f{}|\", id);\n         }\n     }"}, {"sha": "09c0951b9e3c5b44aada56b1d8ef217da969d3a3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -476,27 +476,27 @@ impl tr for ty::AutoRef {\n impl tr for ty::Region {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n         match *self {\n-            ty::re_fn_bound(id, br) => ty::re_fn_bound(xcx.tr_id(id),\n+            ty::ReLateBound(id, br) => ty::ReLateBound(xcx.tr_id(id),\n                                                        br.tr(xcx)),\n-            ty::re_type_bound(id, index, ident) => ty::re_type_bound(xcx.tr_id(id),\n+            ty::ReEarlyBound(id, index, ident) => ty::ReEarlyBound(xcx.tr_id(id),\n                                                                      index,\n                                                                      ident),\n-            ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n-            ty::re_empty | ty::re_static | ty::re_infer(*) => *self,\n-            ty::re_free(ref fr) => {\n-                ty::re_free(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n+            ty::ReScope(id) => ty::ReScope(xcx.tr_id(id)),\n+            ty::ReEmpty | ty::ReStatic | ty::ReInfer(*) => *self,\n+            ty::ReFree(ref fr) => {\n+                ty::ReFree(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n                                             bound_region: fr.bound_region.tr(xcx)})\n             }\n         }\n     }\n }\n \n-impl tr for ty::bound_region {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::bound_region {\n+impl tr for ty::BoundRegion {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::BoundRegion {\n         match *self {\n-            ty::br_anon(_) |\n-            ty::br_fresh(_) => *self,\n-            ty::br_named(id, ident) => ty::br_named(xcx.tr_def_id(id),\n+            ty::BrAnon(_) |\n+            ty::BrFresh(_) => *self,\n+            ty::BrNamed(id, ident) => ty::BrNamed(xcx.tr_def_id(id),\n                                                     ident),\n         }\n     }"}, {"sha": "a5f1709058c4645456a94835e21d312e80f41f7e", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -199,7 +199,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n \n         // Make sure that the loan does not exceed the maximum time\n         // that we can root the value, dynamically.\n-        let root_region = ty::re_scope(self.root_scope_id);\n+        let root_region = ty::ReScope(self.root_scope_id);\n         if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n             self.report_error(\n                 err_out_of_root_scope(root_region, self.loan_region));\n@@ -208,9 +208,9 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n \n         // Extract the scope id that indicates how long the rooting is required\n         let root_scope = match self.loan_region {\n-            ty::re_scope(id) => id,\n+            ty::ReScope(id) => id,\n             _ => {\n-                // the check above should fail for anything is not re_scope\n+                // the check above should fail for anything is not ReScope\n                 self.bccx.tcx.sess.span_bug(\n                     cmt_base.span,\n                     format!(\"Cannot issue root for scope region: {:?}\",\n@@ -260,12 +260,12 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 note_and_explain_region(\n                     self.bccx.tcx,\n                     \"managed value only needs to be frozen for \",\n-                    ty::re_scope(root_scope),\n+                    ty::ReScope(root_scope),\n                     \"...\");\n                 note_and_explain_region(\n                     self.bccx.tcx,\n                     \"...but due to Issue #6248, it will be frozen for \",\n-                    ty::re_scope(cleanup_scope),\n+                    ty::ReScope(cleanup_scope),\n                     \"\");\n             }\n \n@@ -324,21 +324,21 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n \n         match cmt.cat {\n             mc::cat_rvalue(cleanup_scope_id) => {\n-                ty::re_scope(cleanup_scope_id)\n+                ty::ReScope(cleanup_scope_id)\n             }\n             mc::cat_copied_upvar(_) => {\n-                ty::re_scope(self.item_scope_id)\n+                ty::ReScope(self.item_scope_id)\n             }\n             mc::cat_static_item => {\n-                ty::re_static\n+                ty::ReStatic\n             }\n             mc::cat_local(local_id) |\n             mc::cat_arg(local_id) |\n             mc::cat_self(local_id) => {\n                 self.bccx.tcx.region_maps.encl_region(local_id)\n             }\n             mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n-                ty::re_static\n+                ty::ReStatic\n             }\n             mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n                 r"}, {"sha": "56c3417852299811b44c69689168502b25e242c7", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -277,7 +277,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           // Currently these do not use adjustments, so we have to\n           // hardcode this check here (note that the receiver DOES use\n           // adjustments).\n-          let scope_r = ty::re_scope(ex.id);\n+          let scope_r = ty::ReScope(ex.id);\n           let arg_cmt = this.bccx.cat_expr(arg);\n           this.guarantee_valid(arg.id,\n                                arg.span,\n@@ -441,7 +441,7 @@ impl<'self> GatherLoanCtxt<'self> {\n \n         // a loan for the empty region can never be dereferenced, so\n         // it is always safe\n-        if loan_region == ty::re_empty {\n+        if loan_region == ty::ReEmpty {\n             return;\n         }\n \n@@ -470,10 +470,10 @@ impl<'self> GatherLoanCtxt<'self> {\n \n             restrictions::SafeIf(loan_path, restrictions) => {\n                 let loan_scope = match loan_region {\n-                    ty::re_scope(id) => id,\n-                    ty::re_free(ref fr) => fr.scope_id,\n+                    ty::ReScope(id) => id,\n+                    ty::ReFree(ref fr) => fr.scope_id,\n \n-                    ty::re_static => {\n+                    ty::ReStatic => {\n                         // If we get here, an error must have been\n                         // reported in\n                         // `lifetime::guarantee_lifetime()`, because\n@@ -485,10 +485,10 @@ impl<'self> GatherLoanCtxt<'self> {\n                         return;\n                     }\n \n-                    ty::re_empty |\n-                    ty::re_fn_bound(*) |\n-                    ty::re_type_bound(*) |\n-                    ty::re_infer(*) => {\n+                    ty::ReEmpty |\n+                    ty::ReLateBound(*) |\n+                    ty::ReEarlyBound(*) |\n+                    ty::ReInfer(*) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             format!(\"Invalid borrow lifetime: {:?}\", loan_region));\n@@ -715,7 +715,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                     let cmt_discr = match arm_match_ids {\n                         None => cmt,\n                         Some((arm_id, match_id)) => {\n-                            let arm_scope = ty::re_scope(arm_id);\n+                            let arm_scope = ty::ReScope(arm_id);\n                             if self.bccx.is_subregion_of(scope_r, arm_scope) {\n                                 self.bccx.cat_discr(cmt, match_id)\n                             } else {"}, {"sha": "a570160ce95720051f7853c46b48b32ad7897520", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -545,7 +545,7 @@ pub fn check_cast_for_escaping_regions(\n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item).\n-    if target_regions.iter().any(|r| is_re_scope(*r)) {\n+    if target_regions.iter().any(|r| is_ReScope(*r)) {\n         return; /* case (1) */\n     }\n \n@@ -584,9 +584,9 @@ pub fn check_cast_for_escaping_regions(\n             }\n         });\n \n-    fn is_re_scope(r: ty::Region) -> bool {\n+    fn is_ReScope(r: ty::Region) -> bool {\n         match r {\n-            ty::re_scope(*) => true,\n+            ty::ReScope(*) => true,\n             _ => false\n         }\n     }"}, {"sha": "32ac6ff549213ba06eda1bfcb7dbc854ef23ed67", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -137,7 +137,7 @@ impl RegionMaps {\n     pub fn encl_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the narrowest scope region that encloses `id`, if any.\n \n-        ty::re_scope(self.encl_scope(id))\n+        ty::ReScope(self.encl_scope(id))\n     }\n \n     pub fn scopes_intersect(&self, scope1: ast::NodeId, scope2: ast::NodeId)\n@@ -227,19 +227,19 @@ impl RegionMaps {\n \n         sub_region == super_region || {\n             match (sub_region, super_region) {\n-                (_, ty::re_static) => {\n+                (_, ty::ReStatic) => {\n                     true\n                 }\n \n-                (ty::re_scope(sub_scope), ty::re_scope(super_scope)) => {\n+                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) => {\n                     self.is_subscope_of(sub_scope, super_scope)\n                 }\n \n-                (ty::re_scope(sub_scope), ty::re_free(ref fr)) => {\n+                (ty::ReScope(sub_scope), ty::ReFree(ref fr)) => {\n                     self.is_subscope_of(sub_scope, fr.scope_id)\n                 }\n \n-                (ty::re_free(sub_fr), ty::re_free(super_fr)) => {\n+                (ty::ReFree(sub_fr), ty::ReFree(super_fr)) => {\n                     self.sub_free_region(sub_fr, super_fr)\n                 }\n "}, {"sha": "b21720f2e30a0ae6c5eab26dbfe0b8c79580bc80", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -176,7 +176,7 @@ impl LifetimeContext {\n                 ItemScope(lifetimes) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((index, decl_id)) => {\n-                            let def = ast::DefTypeBoundRegion(index, decl_id);\n+                            let def = ast::DefEarlyBoundRegion(index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -189,7 +189,7 @@ impl LifetimeContext {\n                 FnScope(id, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, decl_id)) => {\n-                            let def = ast::DefFnBoundRegion(id, depth, decl_id);\n+                            let def = ast::DefLateBoundRegion(id, depth, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }"}, {"sha": "c9abf71e2b6ecf8911ef32c74e6ffed90d1af87f", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -193,9 +193,9 @@ impl Subst for ty::Region {\n         // the specialized routine\n         // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n         match self {\n-            &ty::re_type_bound(_, i, _) => {\n+            &ty::ReEarlyBound(_, i, _) => {\n                 match substs.regions {\n-                    ty::ErasedRegions => ty::re_static,\n+                    ty::ErasedRegions => ty::ReStatic,\n                     ty::NonerasedRegions(ref regions) => *regions.get(i),\n                 }\n             }"}, {"sha": "9dddf96e34d576580b5e2d3c69fa09f1a1b26ac8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -1048,7 +1048,7 @@ fn extract_vec_elems(bcx: @mut Block,\n         let slice_len = Sub(bcx, len, slice_len_offset);\n         let slice_ty = ty::mk_evec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n-            ty::vstore_slice(ty::re_static)\n+            ty::vstore_slice(ty::ReStatic)\n         );\n         let scratch = scratch_datum(bcx, slice_ty, \"\", false);\n         Store(bcx, slice_begin,\n@@ -1697,7 +1697,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                   let t = node_id_type(bcx, pat_id);\n                   let Result {bcx: after_cx, val: matches} = {\n                       do with_scope_result(bcx, None,\n-                                           \"compare_scope\") |bcx| {\n+                                           \"compaReScope\") |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {"}, {"sha": "06fe4717f58e194c47cc703ed01629f228823c10", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -181,7 +181,7 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n     let adjustment = cx.tcx.adjustments.find_copy(&e.id);\n     match adjustment {\n         None => { }\n-        Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n+        Some(@ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil)) => {\n             llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())], false)\n         }\n         Some(@ty::AutoAddEnv(ref r, ref s)) => {\n@@ -211,11 +211,11 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                     };\n                     match *autoref {\n                         ty::AutoUnsafe(m) |\n-                        ty::AutoPtr(ty::re_static, m) => {\n+                        ty::AutoPtr(ty::ReStatic, m) => {\n                             assert!(m != ast::MutMutable);\n                             llconst = llptr;\n                         }\n-                        ty::AutoBorrowVec(ty::re_static, m) => {\n+                        ty::AutoBorrowVec(ty::ReStatic, m) => {\n                             assert!(m != ast::MutMutable);\n                             assert_eq!(abi::slice_elt_base, 0);\n                             assert_eq!(abi::slice_elt_len, 1);"}, {"sha": "01cf102275023a0b3eb94f04cd1e200e7f88b733", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -588,7 +588,7 @@ impl Datum {\n         // result (which will be by-value).  Note that it is not\n         // significant *which* region we pick here.\n         let llval = self.to_ref_llval(bcx);\n-        let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::re_static,\n+        let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic,\n                                       self.ty);\n         Datum {val: llval, ty: rptr_ty, mode: ByValue}\n     }"}, {"sha": "ddf9354ad3835cf0e129e61c1ca56a17001e8379", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -271,7 +271,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         // real one, but it will have the same runtime representation\n         let slice_ty = ty::mk_evec(tcx,\n                                    ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n-                                   ty::vstore_slice(ty::re_static));\n+                                   ty::vstore_slice(ty::ReStatic));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n "}, {"sha": "0993d3322f1e650b849d5d79a62c7af5e0353bfe", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -339,7 +339,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n-                                                                     ty::re_static) {\n+                                                                     ty::ReStatic) {\n             Ok(pair) => pair,\n             Err(s) => {\n                 bcx.tcx().sess.fatal(s);"}, {"sha": "0781f724d48c3c30fd20d4c860a70c6b465ace59", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -59,7 +59,7 @@ impl Reflector {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n-        let str_vstore = ty::vstore_slice(ty::re_static);\n+        let str_vstore = ty::vstore_slice(ty::ReStatic);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, \"\", false);\n         let len = C_uint(bcx.ccx(), s.len());"}, {"sha": "390c651ea797757b8af3414f9f19fd3b640a93c5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -470,43 +470,45 @@ pub struct param_ty {\n /// Representation of regions:\n #[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum Region {\n-    // Region bound in a type declaration (type/enum/struct/trait),\n-    // which will be substituted when an instance of the type is accessed\n-    re_type_bound(/* param id */ ast::NodeId, /*index*/ uint, ast::Ident),\n+    // Region bound in a type or fn declaration which will be\n+    // substituted 'early' -- that is, at the same time when type\n+    // parameters are substituted.\n+    ReEarlyBound(/* param id */ ast::NodeId, /*index*/ uint, ast::Ident),\n \n-    // Region bound in a fn scope, which will be substituted when the\n-    // fn is called.\n-    re_fn_bound(/* binder_id */ ast::NodeId, bound_region),\n+    // Region bound in a function scope, which will be substituted when the\n+    // function is called. The first argument must be the `binder_id` of\n+    // some enclosing function signature.\n+    ReLateBound(/* binder_id */ ast::NodeId, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    re_free(FreeRegion),\n+    ReFree(FreeRegion),\n \n     /// A concrete region naming some expression within the current function.\n-    re_scope(NodeId),\n+    ReScope(NodeId),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n-    re_static,\n+    ReStatic,\n \n     /// A region variable.  Should not exist after typeck.\n-    re_infer(InferRegion),\n+    ReInfer(InferRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n-    /// Bottom in the region lattice. We treat re_empty somewhat\n+    /// Bottom in the region lattice. We treat ReEmpty somewhat\n     /// specially; at least right now, we do not generate instances of\n     /// it during the GLB computations, but rather\n     /// generate an error instead. This is to improve error messages.\n-    /// The only way to get an instance of re_empty is to have a region\n+    /// The only way to get an instance of ReEmpty is to have a region\n     /// variable with no constraints.\n-    re_empty,\n+    ReEmpty,\n }\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match self {\n-            &ty::re_type_bound(*) => true,\n-            &ty::re_fn_bound(*) => true,\n+            &ty::ReEarlyBound(*) => true,\n+            &ty::ReLateBound(*) => true,\n             _ => false\n         }\n     }\n@@ -515,28 +517,28 @@ impl Region {\n #[deriving(Clone, Eq, TotalOrd, TotalEq, IterBytes, Encodable, Decodable, ToStr)]\n pub struct FreeRegion {\n     scope_id: NodeId,\n-    bound_region: bound_region\n+    bound_region: BoundRegion\n }\n \n #[deriving(Clone, Eq, TotalEq, TotalOrd, IterBytes, Encodable, Decodable, ToStr)]\n-pub enum bound_region {\n+pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n-    br_anon(uint),\n+    BrAnon(uint),\n \n     /// Named region parameters for functions (a in &'a T)\n     ///\n     /// The def-id is needed to distinguish free regions in\n     /// the event of shadowing.\n-    br_named(ast::DefId, ast::Ident),\n+    BrNamed(ast::DefId, ast::Ident),\n \n     /// Fresh bound identifiers created during GLB computations.\n-    br_fresh(uint),\n+    BrFresh(uint),\n }\n \n /**\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n- * trans, and all region parameters will be replaced with `ty::re_static`. */\n+ * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n #[deriving(Clone, Eq, IterBytes)]\n pub enum RegionSubsts {\n     ErasedRegions,\n@@ -701,8 +703,8 @@ pub enum type_err {\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n     terr_regions_no_overlap(Region, Region),\n-    terr_regions_insufficiently_polymorphic(bound_region, Region),\n-    terr_regions_overly_polymorphic(bound_region, Region),\n+    terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n+    terr_regions_overly_polymorphic(BoundRegion, Region),\n     terr_vstores_differ(terr_vstore_kind, expected_found<vstore>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_in_field(@type_err, ast::Ident),\n@@ -778,7 +780,7 @@ pub enum InferTy {\n #[deriving(Clone, Encodable, Decodable, IterBytes, ToStr)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n-    ReSkolemized(uint, bound_region)\n+    ReSkolemized(uint, BoundRegion)\n }\n \n impl cmp::Eq for InferRegion {\n@@ -1043,7 +1045,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n     fn rflags(r: Region) -> uint {\n         (has_regions as uint) | {\n             match r {\n-              ty::re_infer(_) => needs_infer as uint,\n+              ty::ReInfer(_) => needs_infer as uint,\n               _ => 0u\n             }\n         }\n@@ -2148,7 +2150,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ast::MutMutable => TC::ReachesMutable | TC::OwnsAffine,\n             ast::MutImmutable => TC::None,\n         };\n-        b | (TC::ReachesBorrowed).when(region != ty::re_static)\n+        b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n     }\n \n     fn closure_contents(cx: ctxt, cty: &ClosureTy) -> TypeContents {\n@@ -4220,12 +4222,12 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n         fn fold_vstore(&mut self, vstore: vstore) -> vstore {\n             match vstore {\n                 vstore_fixed(*) | vstore_uniq | vstore_box => vstore,\n-                vstore_slice(_) => vstore_slice(re_static)\n+                vstore_slice(_) => vstore_slice(ReStatic)\n             }\n         }\n \n         fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n-            ty::re_static\n+            ty::ReStatic\n         }\n \n         fn fold_substs(&mut self,\n@@ -4564,10 +4566,16 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n     let mut hash = SipState::new(0, 0);\n     let region = |_hash: &mut SipState, r: Region| {\n         match r {\n-            re_static => {}\n-\n-            re_empty | re_bound(*) | re_free(*) | re_scope(*) | re_infer(*) =>\n+            ReStatic => {}\n+\n+            ReEmpty |\n+            ReEarlyBound(*) |\n+            ReLateBound(*) |\n+            ReFree(*) |\n+            ReStatic(*) |\n+            ReInfer(*) => {\n                 tcx.sess.bug(\"non-static region found when hashing a type\")\n+            }\n         }\n     };\n     let vstore = |hash: &mut SipState, v: vstore| {\n@@ -4751,9 +4759,9 @@ pub fn construct_parameter_environment(\n \n     // map bound 'a => free 'a\n     let region_params = item_region_params.iter().\n-        map(|r| ty::re_free(ty::FreeRegion {\n+        map(|r| ty::ReFree(ty::FreeRegion {\n                 scope_id: free_id,\n-                bound_region: ty::br_named(r.def_id, r.ident)})).\n+                bound_region: ty::BrNamed(r.def_id, r.ident)})).\n         collect();\n \n     let free_substs = substs {"}, {"sha": "5040c19158e0bbbbb45c48286cfb58a7f86fc096", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -87,23 +87,23 @@ pub fn ast_region_to_region(\n         }\n \n         Some(&ast::DefStaticRegion) => {\n-            ty::re_static\n+            ty::ReStatic\n         }\n \n-        Some(&ast::DefFnBoundRegion(binder_id, _, id)) => {\n-            ty::re_fn_bound(binder_id, ty::br_named(ast_util::local_def(id),\n-                                                    lifetime.ident))\n+        Some(&ast::DefLateBoundRegion(binder_id, _, id)) => {\n+            ty::ReLateBound(binder_id, ty::BrNamed(ast_util::local_def(id),\n+                                                   lifetime.ident))\n         }\n \n-        Some(&ast::DefTypeBoundRegion(index, id)) => {\n-            ty::re_type_bound(id, index, lifetime.ident)\n+        Some(&ast::DefEarlyBoundRegion(index, id)) => {\n+            ty::ReEarlyBound(id, index, lifetime.ident)\n         }\n \n         Some(&ast::DefFreeRegion(scope_id, id)) => {\n-            ty::re_free(ty::FreeRegion {\n+            ty::ReFree(ty::FreeRegion {\n                     scope_id: scope_id,\n-                    bound_region: ty::br_named(ast_util::local_def(id),\n-                                               lifetime.ident)\n+                    bound_region: ty::BrNamed(ast_util::local_def(id),\n+                                              lifetime.ident)\n                 })\n         }\n     };\n@@ -133,7 +133,7 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n                     debug!(\"optional region in illegal location\");\n                     this.tcx().sess.span_err(\n                         default_span, \"missing lifetime specifier\");\n-                    ty::re_static\n+                    ty::ReStatic\n                 }\n \n                 Some(rs) => {\n@@ -190,7 +190,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         match anon_regions {\n             Some(v) => opt_vec::from(v),\n             None => opt_vec::from(vec::from_fn(expected_num_region_params,\n-                                               |_| ty::re_static)) // hokey\n+                                               |_| ty::ReStatic)) // hokey\n         }\n     };\n \n@@ -431,7 +431,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n               // Use corresponding trait store to figure out default bounds\n               // if none were specified.\n-              ast::BorrowedSigil => ty::RegionTraitStore(ty::re_empty), // dummy region\n+              ast::BorrowedSigil => ty::RegionTraitStore(ty::ReEmpty), // dummy region\n               ast::OwnedSigil    => ty::UniqTraitStore,\n               ast::ManagedSigil  => ty::BoxTraitStore,\n           });\n@@ -713,7 +713,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n                 ast::OwnedSigil | ast::ManagedSigil => {\n                     // @fn(), ~fn() default to static as the bound\n                     // on their upvars:\n-                    ty::re_static\n+                    ty::ReStatic\n                 }\n                 ast::BorrowedSigil => {\n                     // &fn() defaults as normal for an omitted lifetime:\n@@ -803,7 +803,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n         // @Trait is sugar for @Trait:'static.\n         // &'static Trait is sugar for &'static Trait:'static.\n         (&None, ty::BoxTraitStore) |\n-        (&None, ty::RegionTraitStore(ty::re_static)) => {\n+        (&None, ty::RegionTraitStore(ty::ReStatic)) => {\n             let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n         }\n         // &'r Trait is sugar for &'r Trait:<no-bounds>."}, {"sha": "ebe3c828262c269e6afe7a5310f80e8a0f457a63", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -438,7 +438,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         let (_, opt_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 tcx, opt_self_ty, fn_sig,\n-                |br| ty::re_free(ty::FreeRegion {scope_id: body.id,\n+                |br| ty::ReFree(ty::FreeRegion {scope_id: body.id,\n                                                  bound_region: br}));\n         let opt_self_info =\n             opt_self_info.map(\n@@ -931,9 +931,9 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         collect();\n     let dummy_impl_regions: OptVec<ty::Region> =\n         impl_generics.region_param_defs.iter().\n-        map(|l| ty::re_free(ty::FreeRegion {\n+        map(|l| ty::ReFree(ty::FreeRegion {\n                 scope_id: impl_m_body_id,\n-                bound_region: ty::br_named(l.def_id, l.ident)})).\n+                bound_region: ty::BrNamed(l.def_id, l.ident)})).\n         collect();\n     let dummy_substs = ty::substs {\n         tps: vec::append(dummy_impl_tps, dummy_method_tps),\n@@ -1090,7 +1090,7 @@ impl FnCtxt {\n     }\n \n     pub fn block_region(&self) -> ty::Region {\n-        ty::re_scope(self.region_lb)\n+        ty::ReScope(self.region_lb)\n     }\n \n     #[inline]\n@@ -1357,10 +1357,10 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-      ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::re_static)),\n+      ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n       ast::lit_binary(*) => {\n           ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n-                      ty::vstore_slice(ty::re_static))\n+                      ty::vstore_slice(ty::ReStatic))\n       }\n       ast::lit_char(_) => ty::mk_char(),\n       ast::lit_int(_, t) => ty::mk_mach_int(t),\n@@ -3925,27 +3925,27 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         //We only care about the operation here\n         match split[1] {\n             \"cxchg\" => (0, ~[ty::mk_mut_rptr(tcx,\n-                                             ty::re_fn_bound(it.id, ty::br_anon(0)),\n+                                             ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                              ty::mk_int()),\n                         ty::mk_int(),\n                         ty::mk_int()\n                         ], ty::mk_int()),\n             \"load\" => (0,\n                ~[\n-                  ty::mk_imm_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), ty::mk_int())\n+                  ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int())\n                ],\n               ty::mk_int()),\n             \"store\" => (0,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int()),\n                   ty::mk_int()\n                ],\n                ty::mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\"   | \"xor\"  | \"max\"  |\n             \"min\"  | \"umax\" | \"umin\" => {\n                 (0, ~[ty::mk_mut_rptr(tcx,\n-                                      ty::re_fn_bound(it.id, ty::br_anon(0)),\n+                                      ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                       ty::mk_int()), ty::mk_int() ], ty::mk_int())\n             }\n             \"fence\" => {\n@@ -3971,7 +3971,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"move_val\" | \"move_val_init\" => {\n                 (1u,\n                  ~[\n-                    ty::mk_mut_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), param(ccx, 0)),\n+                    ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n                   ],\n                ty::mk_nil())\n@@ -3983,7 +3983,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n               (0,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int()),\n                   ty::mk_int()\n                ],\n                ty::mk_int())\n@@ -4006,7 +4006,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                   Ok(t) => t,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n               };\n-              let region = ty::re_fn_bound(it.id, ty::br_anon(0));\n+              let region = ty::ReLateBound(it.id, ty::BrAnon(0));\n               let visitor_object_ty = match ty::visitor_object_ty(tcx, region) {\n                   Ok((_, vot)) => vot,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }"}, {"sha": "b21d36777c293e8515772dad4f2455fec1439d71", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -29,7 +29,7 @@ this point a bit better.\n \n \n use middle::freevars::get_freevars;\n-use middle::ty::{re_scope};\n+use middle::ty::{ReScope};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip::relate_nested_regions;\n@@ -64,7 +64,7 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n         DefUpvar(_, subdef, closure_id, body_id) => {\n             match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n                 BorrowedSigil => encl_region_of_def(fcx, *subdef),\n-                ManagedSigil | OwnedSigil => re_scope(body_id)\n+                ManagedSigil | OwnedSigil => ReScope(body_id)\n             }\n         }\n         _ => {\n@@ -317,7 +317,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n                         //\n                         // FIXME(#6268) remove to support nested method calls\n                         constrain_regions_in_type_of_node(\n-                            rcx, expr.id, ty::re_scope(expr.id),\n+                            rcx, expr.id, ty::ReScope(expr.id),\n                             infer::AutoBorrow(expr.span));\n                     }\n                 }\n@@ -416,7 +416,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n+            constrain_regions_in_type(rcx, ty::ReScope(expr.id),\n                                       infer::AddrOf(expr.span), ty0);\n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -474,7 +474,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                         // (since otherwise that would require\n                         // infinite stack).\n                         constrain_free_variables(rcx, region, expr);\n-                        let repeating_scope = ty::re_scope(rcx.repeating_scope);\n+                        let repeating_scope = ty::ReScope(rcx.repeating_scope);\n                         rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n                                         region, repeating_scope);\n                     }\n@@ -500,7 +500,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     call_expr: @ast::Expr,\n                     callee_expr: @ast::Expr)\n {\n-    let call_region = ty::re_scope(call_expr.id);\n+    let call_region = ty::ReScope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n     match ty::get(callee_ty).sty {\n@@ -555,7 +555,7 @@ fn constrain_call(rcx: &mut Rcx,\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n     let callee_scope = call_expr.id;\n-    let callee_region = ty::re_scope(callee_scope);\n+    let callee_region = ty::ReScope(callee_scope);\n \n     for &arg_expr in arg_exprs.iter() {\n         debug!(\"Argument\");\n@@ -604,7 +604,7 @@ fn constrain_derefs(rcx: &mut Rcx,\n      * the deref expr.\n      */\n     let tcx = rcx.fcx.tcx();\n-    let r_deref_expr = ty::re_scope(deref_expr.id);\n+    let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n         debug!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n@@ -650,7 +650,7 @@ fn constrain_index(rcx: &mut Rcx,\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n-    let r_index_expr = ty::re_scope(index_expr.id);\n+    let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n         ty::ty_estr(ty::vstore_slice(r_ptr)) |\n         ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n@@ -912,7 +912,7 @@ pub mod guarantor {\n         let expr_cat = categorize(rcx, expr);\n         debug!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n                expr.id, callee_scope, expr_cat);\n-        let minimum_lifetime = ty::re_scope(callee_scope);\n+        let minimum_lifetime = ty::ReScope(callee_scope);\n         for guarantor in expr_cat.guarantor.iter() {\n             mk_subregion_due_to_derefence(rcx, expr.span,\n                                           minimum_lifetime, *guarantor);"}, {"sha": "a73aa46fbec2b6f8733e14318de30595073a92b3", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -23,8 +23,8 @@ pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n     opt_self_ty: Option<ty::t>,\n     fn_sig: &ty::FnSig,\n-    mapf: &fn(ty::bound_region) -> ty::Region)\n-    -> (HashMap<ty::bound_region,ty::Region>, Option<ty::t>, ty::FnSig)\n+    mapf: &fn(ty::BoundRegion) -> ty::Region)\n+    -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig)\n {\n     debug!(\"replace_bound_regions_in_fn_sig(self_ty={}, fn_sig={})\",\n             opt_self_ty.repr(tcx),\n@@ -35,7 +35,7 @@ pub fn replace_bound_regions_in_fn_sig(\n         let mut f = ty_fold::RegionFolder::regions(tcx, |r| {\n                 debug!(\"region r={}\", r.to_str());\n                 match r {\n-                ty::re_fn_bound(s, br) if s == fn_sig.binder_id => {\n+                ty::ReLateBound(s, br) if s == fn_sig.binder_id => {\n                     *map.find_or_insert_with(br, |_| mapf(br))\n                 }\n                 _ => r\n@@ -175,7 +175,7 @@ pub fn relate_free_regions(\n         debug!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {\n-                (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n+                (&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n                     tcx.region_maps.relate_free_regions(free_a, free_b);\n                 }\n                 _ => {}"}, {"sha": "996157df2e29981ca5bdef4c3b3298b55a219d35", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -480,7 +480,7 @@ fn fixup_substs(vcx: &VtableContext,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n-                         ty::RegionTraitStore(ty::re_static),\n+                         ty::RegionTraitStore(ty::ReStatic),\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {"}, {"sha": "e55005d62e912f24415e28c68bfe62bc5458ff27", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -282,8 +282,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         // Convert the regions 'a, 'b, 'c defined on the trait into\n         // bound regions on the fn.\n         let rps_from_trait = trait_ty_generics.region_param_defs.iter().map(|d| {\n-            ty::re_fn_bound(m.fty.sig.binder_id,\n-                            ty::br_named(d.def_id, d.ident))\n+            ty::ReLateBound(m.fty.sig.binder_id,\n+                            ty::BrNamed(d.def_id, d.ident))\n         }).collect();\n \n         // build up the substitution from\n@@ -964,7 +964,7 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n \n     let regions: OptVec<ty::Region> =\n         ty_generics.region_param_defs.iter().enumerate().map(\n-            |(i, l)| ty::re_type_bound(l.def_id.node, i, l.ident)).collect();\n+            |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.ident)).collect();\n \n     substs {regions: ty::NonerasedRegions(regions),\n             self_ty: self_ty,"}, {"sha": "9febef1c7c3997f91df0f6a6c1f3f30daafeafe4", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -161,7 +161,7 @@ impl Combine for Glb {\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n                              new_binder_id: NodeId,\n-                             a_map: &HashMap<ty::bound_region, ty::Region>,\n+                             a_map: &HashMap<ty::BoundRegion, ty::Region>,\n                              a_vars: &[RegionVid],\n                              b_vars: &[RegionVid],\n                              r0: ty::Region) -> ty::Region {\n@@ -228,13 +228,13 @@ impl Combine for Glb {\n         }\n \n         fn rev_lookup(this: &Glb,\n-                      a_map: &HashMap<ty::bound_region, ty::Region>,\n+                      a_map: &HashMap<ty::BoundRegion, ty::Region>,\n                       new_binder_id: NodeId,\n                       r: ty::Region) -> ty::Region\n         {\n             for (a_br, a_r) in a_map.iter() {\n                 if *a_r == r {\n-                    return ty::re_fn_bound(new_binder_id, *a_br);\n+                    return ty::ReLateBound(new_binder_id, *a_br);\n                 }\n             }\n             this.infcx.tcx.sess.span_bug("}, {"sha": "04bf5fda7258dab00abc2f51c30be8efd681262f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -522,10 +522,10 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n // fn types\n \n pub fn var_ids<T:Combine>(this: &T,\n-                          map: &HashMap<ty::bound_region, ty::Region>)\n+                          map: &HashMap<ty::BoundRegion, ty::Region>)\n                           -> ~[RegionVid] {\n     map.iter().map(|(_, r)| match *r {\n-            ty::re_infer(ty::ReVar(r)) => { r }\n+            ty::ReInfer(ty::ReVar(r)) => { r }\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n@@ -536,7 +536,7 @@ pub fn var_ids<T:Combine>(this: &T,\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n     match r {\n-        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n+        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n }"}, {"sha": "b826310df7bff7e78560a40f5c9cfefdb524d4c8", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -149,7 +149,7 @@ impl Combine for Lub {\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n                              new_scope: NodeId,\n-                             a_map: &HashMap<ty::bound_region, ty::Region>,\n+                             a_map: &HashMap<ty::BoundRegion, ty::Region>,\n                              r0: ty::Region)\n                              -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -182,7 +182,7 @@ impl Combine for Lub {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n                            r0, *a_br, tainted);\n-                    return ty::re_fn_bound(new_scope, *a_br);\n+                    return ty::ReLateBound(new_scope, *a_br);\n                 }\n             }\n "}, {"sha": "eafc7e262f191ed67800485f6b715cc1f2f0bc76", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -216,11 +216,11 @@ pub enum RegionVariableOrigin {\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n-    BoundRegionInFnCall(Span, ty::bound_region),\n+    BoundRegionInFnCall(Span, ty::BoundRegion),\n \n     // Region variables created for bound regions\n     // when doing subtyping/lub/glb computations\n-    BoundRegionInFnType(Span, ty::bound_region),\n+    BoundRegionInFnType(Span, ty::BoundRegion),\n \n     BoundRegionInTypeOrImpl(Span),\n \n@@ -638,7 +638,7 @@ impl InferCtxt {\n     }\n \n     pub fn next_region_var(&mut self, origin: RegionVariableOrigin) -> ty::Region {\n-        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(origin)))\n+        ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n     pub fn next_region_vars(&mut self,\n@@ -798,7 +798,7 @@ impl InferCtxt {\n                                                     trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n                                                     -> (ty::FnSig,\n-                                                        HashMap<ty::bound_region,\n+                                                        HashMap<ty::BoundRegion,\n                                                                 ty::Region>) {\n         let (map, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(self.tcx, None, fsig, |br| {\n@@ -933,13 +933,13 @@ impl Repr for RegionVariableOrigin {\n             AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n             Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n-            BoundRegionInFnCall(a, b) => format!(\"BoundRegionInFnCall({},{})\",\n+            BoundRegionInFnCall(a, b) => format!(\"bound_regionInFnCall({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInFnType(a, b) => format!(\"BoundRegionInFnType({},{})\",\n+            BoundRegionInFnType(a, b) => format!(\"bound_regionInFnType({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInTypeOrImpl(a) => format!(\"BoundRegionInTypeOrImpl({})\",\n+            BoundRegionInTypeOrImpl(a) => format!(\"bound_regionInTypeOrImpl({})\",\n                                                a.repr(tcx)),\n-            BoundRegionInCoherence => format!(\"BoundRegionInCoherence\"),\n+            BoundRegionInCoherence => format!(\"bound_regionInCoherence\"),\n         }\n     }\n }"}, {"sha": "e613aa4ba28de865aed15593e95e0313fd748032", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -13,9 +13,9 @@\n \n use middle::ty;\n use middle::ty::{FreeRegion, Region, RegionVid};\n-use middle::ty::{re_empty, re_static, re_infer, re_free, re_type_bound,\n-                 re_fn_bound};\n-use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n+use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound,\n+                 ReLateBound};\n+use middle::ty::{ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n use middle::typeck::infer;\n@@ -187,10 +187,10 @@ impl RegionVarBindings {\n         return vid;\n     }\n \n-    pub fn new_skolemized(&mut self, br: ty::bound_region) -> Region {\n+    pub fn new_skolemized(&mut self, br: ty::BoundRegion) -> Region {\n         let sc = self.skolemization_count;\n         self.skolemization_count += 1;\n-        re_infer(ReSkolemized(sc, br))\n+        ReInfer(ReSkolemized(sc, br))\n     }\n \n     pub fn new_bound(&mut self, binder_id: ast::NodeId) -> Region {\n@@ -219,7 +219,7 @@ impl RegionVarBindings {\n             self.tcx.sess.bug(\"Rollover in RegionInference new_bound()\");\n         }\n \n-        re_fn_bound(binder_id, br_fresh(sc))\n+        ReLateBound(binder_id, BrFresh(sc))\n     }\n \n     pub fn add_constraint(&mut self,\n@@ -246,23 +246,23 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n-          (re_type_bound(*), _) |\n-          (re_fn_bound(*), _) |\n-          (_, re_type_bound(*)) |\n-          (_, re_fn_bound(*)) => {\n+          (ReEarlyBound(*), _) |\n+          (ReLateBound(*), _) |\n+          (_, ReEarlyBound(*)) |\n+          (_, ReLateBound(*)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n                 format!(\"Cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n                         sup.repr(self.tcx)));\n           }\n-          (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n+          (ReInfer(ReVar(sub_id)), ReInfer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n           }\n-          (r, re_infer(ReVar(sup_id))) => {\n+          (r, ReInfer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n           }\n-          (re_infer(ReVar(sub_id)), r) => {\n+          (ReInfer(ReVar(sub_id)), r) => {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n           _ => {\n@@ -281,8 +281,8 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (re_static, _) | (_, re_static) => {\n-                re_static // nothing lives longer than static\n+            (ReStatic, _) | (_, ReStatic) => {\n+                ReStatic // nothing lives longer than static\n             }\n \n             _ => {\n@@ -304,7 +304,7 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (re_static, r) | (r, re_static) => {\n+            (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n                 r\n             }\n@@ -333,13 +333,13 @@ impl RegionVarBindings {\n             Value(r) => r,\n \n             NoValue => {\n-                // No constraints, return ty::re_empty\n-                re_empty\n+                // No constraints, return ty::ReEmpty\n+                ReEmpty\n             }\n \n             ErrorValue => {\n                 // An error that has previously been reported.\n-                re_static\n+                ReStatic\n             }\n         }\n     }\n@@ -366,7 +366,7 @@ impl RegionVarBindings {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).find(&vars) {\n             Some(&c) => {\n-                return re_infer(ReVar(c));\n+                return ReInfer(ReVar(c));\n             }\n             None => {}\n         }\n@@ -375,10 +375,10 @@ impl RegionVarBindings {\n         if self.in_snapshot() {\n             self.undo_log.push(AddCombination(t, vars));\n         }\n-        relate(self, a, re_infer(ReVar(c)));\n-        relate(self, b, re_infer(ReVar(c)));\n+        relate(self, a, ReInfer(ReVar(c)));\n+        relate(self, b, ReInfer(ReVar(c)));\n         debug!(\"combine_vars() c={:?}\", c);\n-        re_infer(ReVar(c))\n+        ReInfer(ReVar(c))\n     }\n \n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n@@ -421,14 +421,14 @@ impl RegionVarBindings {\n                 // nb: can't use uint::range() here as we move result_set\n                 let regs = match self.undo_log[undo_index] {\n                     AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                        Some((re_infer(ReVar(*a)),\n-                              re_infer(ReVar(*b))))\n+                        Some((ReInfer(ReVar(*a)),\n+                              ReInfer(ReVar(*b))))\n                     }\n                     AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n-                        Some((*a, re_infer(ReVar(*b))))\n+                        Some((*a, ReInfer(ReVar(*b))))\n                     }\n                     AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n-                        Some((re_infer(ReVar(*a)), *b))\n+                        Some((ReInfer(ReVar(*a)), *b))\n                     }\n                     AddConstraint(ConstrainRegSubReg(a, b)) => {\n                         Some((a, b))\n@@ -495,33 +495,33 @@ impl RegionVarBindings {\n \n     fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n         match (a, b) {\n-          (re_fn_bound(*), _) |\n-          (_, re_fn_bound(*)) |\n-          (re_type_bound(*), _) |\n-          (_, re_type_bound(*)) => {\n+          (ReLateBound(*), _) |\n+          (_, ReLateBound(*)) |\n+          (ReEarlyBound(*), _) |\n+          (_, ReEarlyBound(*)) => {\n             self.tcx.sess.bug(\n                 format!(\"Cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n                         b.repr(self.tcx)));\n           }\n \n-          (re_static, _) | (_, re_static) => {\n-            re_static // nothing lives longer than static\n+          (ReStatic, _) | (_, ReStatic) => {\n+            ReStatic // nothing lives longer than static\n           }\n \n-          (re_empty, r) | (r, re_empty) => {\n+          (ReEmpty, r) | (r, ReEmpty) => {\n             r // everything lives longer than empty\n           }\n \n-          (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n+          (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_origins[v_id.to_uint()].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: {:?}, {:?}\", a, b));\n           }\n \n-          (f @ re_free(ref fr), re_scope(s_id)) |\n-          (re_scope(s_id), f @ re_free(ref fr)) => {\n+          (f @ ReFree(ref fr), ReScope(s_id)) |\n+          (ReScope(s_id), f @ ReFree(ref fr)) => {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n@@ -534,30 +534,30 @@ impl RegionVarBindings {\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n-              _ => re_static\n+              _ => ReStatic\n             }\n           }\n \n-          (re_scope(a_id), re_scope(b_id)) => {\n+          (ReScope(a_id), ReScope(b_id)) => {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n             let rm = self.tcx.region_maps;\n             match rm.nearest_common_ancestor(a_id, b_id) {\n-              Some(r_id) => re_scope(r_id),\n-              _ => re_static\n+              Some(r_id) => ReScope(r_id),\n+              _ => ReStatic\n             }\n           }\n \n-          (re_free(ref a_fr), re_free(ref b_fr)) => {\n+          (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n              self.lub_free_regions(a_fr, b_fr)\n           }\n \n           // For these types, we cannot define any additional\n           // relationship:\n-          (re_infer(ReSkolemized(*)), _) |\n-          (_, re_infer(ReSkolemized(*))) => {\n-            if a == b {a} else {re_static}\n+          (ReInfer(ReSkolemized(*)), _) |\n+          (_, ReInfer(ReSkolemized(*))) => {\n+            if a == b {a} else {ReStatic}\n           }\n         }\n     }\n@@ -575,7 +575,7 @@ impl RegionVarBindings {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n             Greater => helper(self, b, a),\n-            Equal => ty::re_free(*a)\n+            Equal => ty::ReFree(*a)\n         };\n \n         fn helper(this: &RegionVarBindings,\n@@ -584,11 +584,11 @@ impl RegionVarBindings {\n         {\n             let rm = this.tcx.region_maps;\n             if rm.sub_free_region(*a, *b) {\n-                ty::re_free(*b)\n+                ty::ReFree(*b)\n             } else if rm.sub_free_region(*b, *a) {\n-                ty::re_free(*a)\n+                ty::ReFree(*a)\n             } else {\n-                ty::re_static\n+                ty::ReStatic\n             }\n         }\n     }\n@@ -599,36 +599,36 @@ impl RegionVarBindings {\n                          -> cres<Region> {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (re_fn_bound(*), _) |\n-            (_, re_fn_bound(*)) |\n-            (re_type_bound(*), _) |\n-            (_, re_type_bound(*)) => {\n+            (ReLateBound(*), _) |\n+            (_, ReLateBound(*)) |\n+            (ReEarlyBound(*), _) |\n+            (_, ReEarlyBound(*)) => {\n               self.tcx.sess.bug(\n                   format!(\"Cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n                           b.repr(self.tcx)));\n             }\n \n-            (re_static, r) | (r, re_static) => {\n+            (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n                 Ok(r)\n             }\n \n-            (re_empty, _) | (_, re_empty) => {\n+            (ReEmpty, _) | (_, ReEmpty) => {\n                 // nothing lives shorter than everything else\n-                Ok(re_empty)\n+                Ok(ReEmpty)\n             }\n \n-            (re_infer(ReVar(v_id)), _) |\n-            (_, re_infer(ReVar(v_id))) => {\n+            (ReInfer(ReVar(v_id)), _) |\n+            (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n                     self.var_origins[v_id.to_uint()].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: {:?}, {:?}\", a, b));\n             }\n \n-            (re_free(ref fr), s @ re_scope(s_id)) |\n-            (s @ re_scope(s_id), re_free(ref fr)) => {\n+            (ReFree(ref fr), s @ ReScope(s_id)) |\n+            (s @ ReScope(s_id), ReFree(ref fr)) => {\n                 // Free region is something \"at least as big as\n                 // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger\n                 // than the scope `s_id`, then we can say that the GLB\n@@ -641,18 +641,18 @@ impl RegionVarBindings {\n                 }\n             }\n \n-            (re_scope(a_id), re_scope(b_id)) => {\n+            (ReScope(a_id), ReScope(b_id)) => {\n                 self.intersect_scopes(a, b, a_id, b_id)\n             }\n \n-            (re_free(ref a_fr), re_free(ref b_fr)) => {\n+            (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n                 self.glb_free_regions(a_fr, b_fr)\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (re_infer(ReSkolemized(*)), _) |\n-            (_, re_infer(ReSkolemized(*))) => {\n+            (ReInfer(ReSkolemized(*)), _) |\n+            (_, ReInfer(ReSkolemized(*))) => {\n                 if a == b {\n                     Ok(a)\n                 } else {\n@@ -675,7 +675,7 @@ impl RegionVarBindings {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n             Greater => helper(self, b, a),\n-            Equal => Ok(ty::re_free(*a))\n+            Equal => Ok(ty::ReFree(*a))\n         };\n \n         fn helper(this: &RegionVarBindings,\n@@ -684,11 +684,11 @@ impl RegionVarBindings {\n         {\n             let rm = this.tcx.region_maps;\n             if rm.sub_free_region(*a, *b) {\n-                Ok(ty::re_free(*a))\n+                Ok(ty::ReFree(*a))\n             } else if rm.sub_free_region(*b, *a) {\n-                Ok(ty::re_free(*b))\n+                Ok(ty::ReFree(*b))\n             } else {\n-                this.intersect_scopes(ty::re_free(*a), ty::re_free(*b),\n+                this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n                                       a.scope_id, b.scope_id)\n             }\n         }\n@@ -715,8 +715,8 @@ impl RegionVarBindings {\n                scope_a, scope_b, region_a, region_b);\n         let rm = self.tcx.region_maps;\n         match rm.nearest_common_ancestor(scope_a, scope_b) {\n-            Some(r_id) if scope_a == r_id => Ok(re_scope(scope_b)),\n-            Some(r_id) if scope_b == r_id => Ok(re_scope(scope_a)),\n+            Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n+            Some(r_id) if scope_b == r_id => Ok(ReScope(scope_a)),\n             _ => Err(ty::terr_regions_no_overlap(region_a, region_b))\n         }\n     }"}, {"sha": "168d8a57c7fecbecab90ebc2d683bfae59ca3cc1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -192,21 +192,21 @@ impl ResolveState {\n     pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n         debug!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n         match orig {\n-          ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n+          ty::ReInfer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n     pub fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n-            return ty::re_infer(ty::ReVar(rid));\n+            return ty::ReInfer(ty::ReVar(rid));\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n     pub fn assert_not_rvar(&mut self, rid: RegionVid, r: ty::Region) {\n         match r {\n-          ty::re_infer(ty::ReVar(rid2)) => {\n+          ty::ReInfer(ty::ReVar(rid2)) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n           }\n           _ => { }"}, {"sha": "117b100005a01b90bd0b8636c647795b82b09ac3", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -192,7 +192,7 @@ impl Combine for Sub {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {\n-                    ty::re_infer(ty::ReVar(ref vid)) => {\n+                    ty::ReInfer(ty::ReVar(ref vid)) => {\n                         if new_vars.iter().any(|x| x == vid) { continue; }\n                     }\n                     _ => {"}, {"sha": "7c56594d26755a653a9914a34c13b1fb087748f3", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -188,7 +188,7 @@ impl Env {\n             meta: FnMeta {purity: ast::impure_fn,\n                           proto: ast::ProtoBare,\n                           onceness: ast::Many,\n-                          region: ty::re_static,\n+                          region: ty::ReStatic,\n                           bounds: @~[]},\n             sig: FnSig {\n                 inputs: inputs,\n@@ -203,22 +203,22 @@ impl Env {\n     }\n \n     pub fn t_rptr_bound(&self, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::br_anon(id)), self.t_int())\n+        ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::BrAnon(id)), self.t_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::node_id) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_scope(id), self.t_int())\n+        ty::mk_imm_rptr(self.tcx, ty::ReScope(id), self.t_int())\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n         ty::mk_imm_rptr(self.tcx,\n-                        ty::re_free(ty::FreeRegion {scope_id: nid,\n-                                                    bound_region: ty::br_anon(id)}),\n+                        ty::ReFree(ty::FreeRegion {scope_id: nid,\n+                                                    bound_region: ty::BrAnon(id)}),\n                         self.t_int())\n     }\n \n     pub fn t_rptr_static(&self) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_static, self.t_int())\n+        ty::mk_imm_rptr(self.tcx, ty::ReStatic, self.t_int())\n     }\n \n     pub fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }"}, {"sha": "63ddc9addc55edd00d90846f98c656b563ed45eb", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -317,19 +317,19 @@ pub fn require_same_types(\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::Region\n-pub type isr_alist = @List<(ty::bound_region, ty::Region)>;\n+pub type isr_alist = @List<(ty::BoundRegion, ty::Region)>;\n \n trait get_and_find_region {\n-    fn get(&self, br: ty::bound_region) -> ty::Region;\n-    fn find(&self, br: ty::bound_region) -> Option<ty::Region>;\n+    fn get(&self, br: ty::BoundRegion) -> ty::Region;\n+    fn find(&self, br: ty::BoundRegion) -> Option<ty::Region>;\n }\n \n impl get_and_find_region for isr_alist {\n-    fn get(&self, br: ty::bound_region) -> ty::Region {\n+    fn get(&self, br: ty::BoundRegion) -> ty::Region {\n         self.find(br).unwrap()\n     }\n \n-    fn find(&self, br: ty::bound_region) -> Option<ty::Region> {\n+    fn find(&self, br: ty::BoundRegion) -> Option<ty::Region> {\n         let mut ret = None;\n         do list::each(*self) |isr| {\n             let (isr_br, isr_r) = *isr;"}, {"sha": "3d095d1e8a5e88bbf41105fb3de74db274578c13", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -56,14 +56,14 @@ impl RegionScope for BindingRscope {\n                     -> Option<~[ty::Region]> {\n         let idx = *self.anon_bindings;\n         *self.anon_bindings += count;\n-        Some(vec::from_fn(count, |i| ty::re_fn_bound(self.binder_id,\n-                                                     ty::br_anon(idx + i))))\n+        Some(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n+                                                     ty::BrAnon(idx + i))))\n     }\n }\n \n pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n                           -> OptVec<ty::Region> {\n     assert!(defs.iter().all(|def| def.def_id.crate == ast::LOCAL_CRATE));\n     defs.iter().enumerate().map(\n-        |(i, def)| ty::re_type_bound(def.def_id.node, i, def.ident)).collect()\n+        |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.ident)).collect()\n }"}, {"sha": "4e8f0a9468c8d1ede368bd34a033c3564844caea", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -613,20 +613,20 @@ impl<'self> ConstraintContext<'self> {\n                                    region: ty::Region,\n                                    variance: VarianceTermPtr<'self>) {\n         match region {\n-            ty::re_type_bound(param_id, _, _) => {\n+            ty::ReEarlyBound(param_id, _, _) => {\n                 let index = self.inferred_index(param_id);\n                 self.add_constraint(index, variance);\n             }\n \n-            ty::re_static => { }\n+            ty::ReStatic => { }\n \n-            ty::re_fn_bound(*) => {\n+            ty::ReLateBound(*) => {\n                 // We do not infer variance for region parameters on\n                 // methods or in fn types.\n             }\n \n-            ty::re_free(*) | ty::re_scope(*) | ty::re_infer(*) |\n-            ty::re_empty => {\n+            ty::ReFree(*) | ty::ReScope(*) | ty::ReInfer(*) |\n+            ty::ReEmpty => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n                 self.tcx().sess.bug(format!(\"Unexpected region encountered in \\"}, {"sha": "c5d7db465e6a1104553c0632b1bdf6f5b54ddc03", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -11,11 +11,11 @@\n \n use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n-use middle::ty::{bound_region, br_anon, br_named};\n-use middle::ty::{br_fresh, ctxt, field};\n+use middle::ty::{BoundRegion, BrAnon, BrNamed};\n+use middle::ty::{BrFresh, ctxt, field};\n use middle::ty::{mt, t, param_ty};\n-use middle::ty::{re_free, re_scope, re_infer, re_static, Region,\n-                 re_empty};\n+use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n+                 ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n@@ -71,7 +71,7 @@ pub fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n-      re_scope(node_id) => {\n+      ReScope(node_id) => {\n         match cx.items.find(&node_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n@@ -104,11 +104,11 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         }\n       }\n \n-      re_free(ref fr) => {\n+      ReFree(ref fr) => {\n         let prefix = match fr.bound_region {\n-          br_anon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n+          BrAnon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n                                idx + 1),\n-          br_fresh(_) => format!(\"an anonymous lifetime defined on\"),\n+          BrFresh(_) => format!(\"an anonymous lifetime defined on\"),\n           _ => format!(\"the lifetime {} as defined on\",\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n@@ -130,13 +130,13 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         }\n       }\n \n-      re_static => { (~\"the static lifetime\", None) }\n+      ReStatic => { (~\"the static lifetime\", None) }\n \n-      re_empty => { (~\"the empty lifetime\", None) }\n+      ReEmpty => { (~\"the empty lifetime\", None) }\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n-      ty::re_infer(_) | ty::re_type_bound(*) | ty::re_fn_bound(*) => {\n+      ty::ReInfer(_) | ty::ReEarlyBound(*) | ty::ReLateBound(*) => {\n         (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n@@ -150,28 +150,28 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: ctxt, br: bound_region) -> ~str {\n+pub fn bound_region_ptr_to_str(cx: ctxt, br: BoundRegion) -> ~str {\n     bound_region_to_str(cx, \"&\", true, br)\n }\n \n pub fn bound_region_to_str(cx: ctxt,\n                            prefix: &str, space: bool,\n-                           br: bound_region) -> ~str {\n+                           br: BoundRegion) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n         return format!(\"{}{}{}\", prefix, br.repr(cx), space_str);\n     }\n \n     match br {\n-      br_named(_, ident)   => format!(\"{}'{}{}\", prefix,\n+      BrNamed(_, ident)   => format!(\"{}'{}{}\", prefix,\n                                       cx.sess.str_of(ident), space_str),\n-      br_anon(_)           => prefix.to_str(),\n-      br_fresh(_)          => prefix.to_str(),\n+      BrAnon(_)           => prefix.to_str(),\n+      BrFresh(_)          => prefix.to_str(),\n     }\n }\n \n-pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n+pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n         format!(\"<block at {}>\",\n@@ -204,7 +204,7 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n         format!(\"<unknown-{}>\", node_id)\n       }\n       _ => { cx.sess.bug(\n-          format!(\"re_scope refers to {}\",\n+          format!(\"ReScope refers to {}\",\n                ast_map::node_id_to_str(cx.items, node_id,\n                                        token::get_ident_interner()))) }\n     }\n@@ -229,16 +229,16 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-        ty::re_scope(_) => prefix.to_str(),\n-        ty::re_type_bound(_, _, ident) => cx.sess.str_of(ident).to_owned(),\n-        ty::re_fn_bound(_, br) => bound_region_to_str(cx, prefix, space, br),\n-        ty::re_free(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n-        ty::re_infer(ReSkolemized(_, br)) => {\n+        ty::ReScope(_) => prefix.to_str(),\n+        ty::ReEarlyBound(_, _, ident) => cx.sess.str_of(ident).to_owned(),\n+        ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n+        ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n+        ty::ReInfer(ReSkolemized(_, br)) => {\n             bound_region_to_str(cx, prefix, space, br)\n         }\n-        ty::re_infer(ReVar(_)) => prefix.to_str(),\n-        ty::re_static => format!(\"{}'static{}\", prefix, space_str),\n-        ty::re_empty => format!(\"{}'<empty>{}\", prefix, space_str)\n+        ty::ReInfer(ReVar(_)) => prefix.to_str(),\n+        ty::ReStatic => format!(\"{}'static{}\", prefix, space_str),\n+        ty::ReEmpty => format!(\"{}'<empty>{}\", prefix, space_str)\n     }\n }\n \n@@ -356,8 +356,8 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         };\n \n         match (cty.sigil, cty.region) {\n-            (ast::ManagedSigil, ty::re_static) |\n-            (ast::OwnedSigil, ty::re_static) => {}\n+            (ast::ManagedSigil, ty::ReStatic) |\n+            (ast::OwnedSigil, ty::ReStatic) => {}\n \n             (_, region) => {\n                 s.push_str(region_to_str(cx, \"\", true, region));\n@@ -689,56 +689,56 @@ impl Repr for ast::Pat {\n     }\n }\n \n-impl Repr for ty::bound_region {\n+impl Repr for ty::BoundRegion {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n-            ty::br_anon(id) => format!(\"br_anon({})\", id),\n-            ty::br_named(id, ident) => format!(\"br_named({}, {})\",\n+            ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n+            ty::BrNamed(id, ident) => format!(\"BrNamed({}, {})\",\n                                                id.repr(tcx),\n                                                ident.repr(tcx)),\n-            ty::br_fresh(id) => format!(\"br_fresh({})\", id),\n+            ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n         }\n     }\n }\n \n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n-            ty::re_type_bound(id, index, ident) => {\n-                format!(\"re_type_bound({}, {}, {})\",\n+            ty::ReEarlyBound(id, index, ident) => {\n+                format!(\"ReEarlyBound({}, {}, {})\",\n                         id, index, ident.repr(tcx))\n             }\n \n-            ty::re_fn_bound(binder_id, ref bound_region) => {\n-                format!(\"re_fn_bound({}, {})\",\n+            ty::ReLateBound(binder_id, ref bound_region) => {\n+                format!(\"ReLateBound({}, {})\",\n                         binder_id, bound_region.repr(tcx))\n             }\n \n-            ty::re_free(ref fr) => {\n-                format!(\"re_free({}, {})\",\n+            ty::ReFree(ref fr) => {\n+                format!(\"ReFree({}, {})\",\n                         fr.scope_id,\n                         fr.bound_region.repr(tcx))\n             }\n \n-            ty::re_scope(id) => {\n-                format!(\"re_scope({})\", id)\n+            ty::ReScope(id) => {\n+                format!(\"ReScope({})\", id)\n             }\n \n-            ty::re_static => {\n-                format!(\"re_static\")\n+            ty::ReStatic => {\n+                format!(\"ReStatic\")\n             }\n \n-            ty::re_infer(ReVar(ref vid)) => {\n-                format!(\"re_infer({})\", vid.id)\n+            ty::ReInfer(ReVar(ref vid)) => {\n+                format!(\"ReInfer({})\", vid.id)\n             }\n \n-            ty::re_infer(ReSkolemized(id, ref bound_region)) => {\n+            ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n                 format!(\"re_skolemized({}, {})\",\n                         id, bound_region.repr(tcx))\n             }\n \n-            ty::re_empty => {\n-                format!(\"re_empty\")\n+            ty::ReEmpty => {\n+                format!(\"ReEmpty\")\n             }\n         }\n     }"}, {"sha": "df9ab083bf25ffe6cb5975bfaf34fe62be2886bb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=195f1d77bd6bdd8988d5cbd107cb0c4cfa4694cc", "patch": "@@ -254,8 +254,8 @@ pub enum Def {\n #[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum DefRegion {\n     DefStaticRegion,\n-    DefTypeBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n-    DefFnBoundRegion(/* binder_id */ NodeId, /* depth */ uint, /* lifetime decl */ NodeId),\n+    DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n+    DefLateBoundRegion(/* binder_id */ NodeId, /* depth */ uint, /* lifetime decl */ NodeId),\n     DefFreeRegion(/* block scope */ NodeId, /* lifetime decl */ NodeId),\n }\n "}]}