{"sha": "2743c13de071a637c28fc22fba34947aa29bcc17", "node_id": "C_kwDOAAsO6NoAKDI3NDNjMTNkZTA3MWE2MzdjMjhmYzIyZmJhMzQ5NDdhYTI5YmNjMTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-12T21:16:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T21:16:56Z"}, "message": "Rollup merge of #95405 - cjgillot:probe, r=petrochenkov\n\nMove name resolution logic to a dedicated file\n\nThe code resolution logic from an Ident is scattered between several files.\n\nThe first commits creates `rustc_resolve::probe` module to hold the different mutually recursive functions together. Just a move, no code change.\nThe following commits attempt to make the logic a bit more readable.\n\nThe two fields `last_import_segment` and `unusable_binding` are replaced by function parameters.\nIn order to manage the fallout, `maybe_` variants of the function are added, dedicated to speculative resolution.\n\nr? `@petrochenkov`", "tree": {"sha": "e2836c8926ffb59bf8703937f12bf590844d35de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2836c8926ffb59bf8703937f12bf590844d35de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2743c13de071a637c28fc22fba34947aa29bcc17", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVexICRBK7hj4Ov3rIwAABXQIAEmTacIjiO90WDWIVSYFqR3H\ngcCXio7aAYG6LOinyKG8wDKPowWv6sRqQncgSa3syribvIwCWuGYGm4fSZP3YQOl\nUUo+AO/d9L61Xbzb0fgObuHqxcKvNgAfYTobORZMWJNvSkfBMBlw72Tm/LL3t959\nq76212Opczt8aTNX4F0RSiyclikB1LgBJdews3WwyllsbDtr9rW48H/iuXKBq5/K\nMou78u0DBU/orLRrVGw92yatupNWxeaYtovLFQLdxt8Em+7q713gSZRNGf9Ep63W\n2yLLwUSqVBDw9IZjNHdBFVECJu1HWfyj3yEkmvU3EFgtW+cofG2p2HfGSNLhv/I=\n=umeT\n-----END PGP SIGNATURE-----\n", "payload": "tree e2836c8926ffb59bf8703937f12bf590844d35de\nparent 0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe\nparent 276b94601025152a2cf5668a53a96fae94f37731\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649798216 +0200\ncommitter GitHub <noreply@github.com> 1649798216 +0200\n\nRollup merge of #95405 - cjgillot:probe, r=petrochenkov\n\nMove name resolution logic to a dedicated file\n\nThe code resolution logic from an Ident is scattered between several files.\n\nThe first commits creates `rustc_resolve::probe` module to hold the different mutually recursive functions together. Just a move, no code change.\nThe following commits attempt to make the logic a bit more readable.\n\nThe two fields `last_import_segment` and `unusable_binding` are replaced by function parameters.\nIn order to manage the fallout, `maybe_` variants of the function are added, dedicated to speculative resolution.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2743c13de071a637c28fc22fba34947aa29bcc17", "html_url": "https://github.com/rust-lang/rust/commit/2743c13de071a637c28fc22fba34947aa29bcc17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2743c13de071a637c28fc22fba34947aa29bcc17/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "html_url": "https://github.com/rust-lang/rust/commit/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe"}, {"sha": "276b94601025152a2cf5668a53a96fae94f37731", "url": "https://api.github.com/repos/rust-lang/rust/commits/276b94601025152a2cf5668a53a96fae94f37731", "html_url": "https://github.com/rust-lang/rust/commit/276b94601025152a2cf5668a53a96fae94f37731"}], "stats": {"total": 4528, "additions": 2337, "deletions": 2191}, "files": [{"sha": "54e8c03156d558448b64e58721c885d99457b7bd", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -297,6 +297,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     Some(TypeNS),\n                     parent_scope,\n                     if finalize { Finalize::SimplePath(id, path.span) } else { Finalize::No },\n+                    None,\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n@@ -1124,12 +1125,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n-                let result = self.r.resolve_ident_in_module(\n+                let result = self.r.maybe_resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n                     &self.parent_scope,\n-                    None,\n                 );\n                 if let Ok(binding) = result {\n                     let import = macro_use_import(self, ident.span);"}, {"sha": "d979311171be66c657192e895dc88a8e3a442dd4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 660, "deletions": 18, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -1,19 +1,24 @@\n use std::ptr;\n \n-use rustc_ast::{self as ast, Path};\n+use rustc_ast::ptr::P;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::{self as ast, Crate, ItemKind, ModKind, NodeId, Path, CRATE_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n-};\n+use rustc_errors::struct_span_err;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty::DefIdTree;\n+use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n+use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::Session;\n+use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n@@ -22,11 +27,13 @@ use rustc_span::{BytePos, Span};\n use tracing::debug;\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n+use crate::late::Rib;\n use crate::path_names_to_string;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n-use crate::{Finalize, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n-use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n+use crate::{HasGenericParams, MacroRulesScope, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{LexicalScopeBinding, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n+use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet};\n+use crate::{Segment, UseError};\n \n type Res = def::Res<ast::NodeId>;\n \n@@ -82,6 +89,390 @@ fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n }\n \n impl<'a> Resolver<'a> {\n+    crate fn report_errors(&mut self, krate: &Crate) {\n+        self.report_with_use_injections(krate);\n+\n+        for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n+            let msg = \"macro-expanded `macro_export` macros from the current crate \\\n+                       cannot be referred to by absolute paths\";\n+            self.lint_buffer.buffer_lint_with_diagnostic(\n+                MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n+                CRATE_NODE_ID,\n+                span_use,\n+                msg,\n+                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def),\n+            );\n+        }\n+\n+        for ambiguity_error in &self.ambiguity_errors {\n+            self.report_ambiguity_error(ambiguity_error);\n+        }\n+\n+        let mut reported_spans = FxHashSet::default();\n+        for error in &self.privacy_errors {\n+            if reported_spans.insert(error.dedup_span) {\n+                self.report_privacy_error(error);\n+            }\n+        }\n+    }\n+\n+    fn report_with_use_injections(&mut self, krate: &Crate) {\n+        for UseError { mut err, candidates, def_id, instead, suggestion } in\n+            self.use_injections.drain(..)\n+        {\n+            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n+                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n+            } else {\n+                (None, false)\n+            };\n+            if !candidates.is_empty() {\n+                show_candidates(\n+                    &self.definitions,\n+                    self.session,\n+                    &mut err,\n+                    span,\n+                    &candidates,\n+                    instead,\n+                    found_use,\n+                );\n+            } else if let Some((span, msg, sugg, appl)) = suggestion {\n+                err.span_suggestion(span, msg, sugg, appl);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn report_conflict<'b>(\n+        &mut self,\n+        parent: Module<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        new_binding: &NameBinding<'b>,\n+        old_binding: &NameBinding<'b>,\n+    ) {\n+        // Error on the second of two conflicting names\n+        if old_binding.span.lo() > new_binding.span.lo() {\n+            return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n+        }\n+\n+        let container = match parent.kind {\n+            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n+            ModuleKind::Block(..) => \"block\",\n+        };\n+\n+        let old_noun = match old_binding.is_import() {\n+            true => \"import\",\n+            false => \"definition\",\n+        };\n+\n+        let new_participle = match new_binding.is_import() {\n+            true => \"imported\",\n+            false => \"defined\",\n+        };\n+\n+        let (name, span) =\n+            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n+\n+        if let Some(s) = self.name_already_seen.get(&name) {\n+            if s == &span {\n+                return;\n+            }\n+        }\n+\n+        let old_kind = match (ns, old_binding.module()) {\n+            (ValueNS, _) => \"value\",\n+            (MacroNS, _) => \"macro\",\n+            (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n+            (TypeNS, Some(module)) if module.is_normal() => \"module\",\n+            (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n+            (TypeNS, _) => \"type\",\n+        };\n+\n+        let msg = format!(\"the name `{}` is defined multiple times\", name);\n+\n+        let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n+            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n+                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+            },\n+            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+            },\n+        };\n+\n+        err.note(&format!(\n+            \"`{}` must be defined only once in the {} namespace of this {}\",\n+            name,\n+            ns.descr(),\n+            container\n+        ));\n+\n+        err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n+        err.span_label(\n+            self.session.source_map().guess_head_span(old_binding.span),\n+            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n+        );\n+\n+        // See https://github.com/rust-lang/rust/issues/32354\n+        use NameBindingKind::Import;\n+        let import = match (&new_binding.kind, &old_binding.kind) {\n+            // If there are two imports where one or both have attributes then prefer removing the\n+            // import without attributes.\n+            (Import { import: new, .. }, Import { import: old, .. })\n+                if {\n+                    !new_binding.span.is_dummy()\n+                        && !old_binding.span.is_dummy()\n+                        && (new.has_attributes || old.has_attributes)\n+                } =>\n+            {\n+                if old.has_attributes {\n+                    Some((new, new_binding.span, true))\n+                } else {\n+                    Some((old, old_binding.span, true))\n+                }\n+            }\n+            // Otherwise prioritize the new binding.\n+            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+                Some((import, new_binding.span, other.is_import()))\n+            }\n+            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+                Some((import, old_binding.span, other.is_import()))\n+            }\n+            _ => None,\n+        };\n+\n+        // Check if the target of the use for both bindings is the same.\n+        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n+        let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n+        let from_item =\n+            self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n+        // Only suggest removing an import if both bindings are to the same def, if both spans\n+        // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n+        // been introduced by an item.\n+        let should_remove_import = duplicate\n+            && !has_dummy_span\n+            && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n+\n+        match import {\n+            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n+                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n+            }\n+            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n+                // Simple case - remove the entire import. Due to the above match arm, this can\n+                // only be a single use so just remove it entirely.\n+                err.tool_only_span_suggestion(\n+                    import.use_span_with_attributes,\n+                    \"remove unnecessary import\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            Some((import, span, _)) => {\n+                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n+            }\n+            _ => {}\n+        }\n+\n+        err.emit();\n+        self.name_already_seen.insert(name, span);\n+    }\n+\n+    /// This function adds a suggestion to change the binding name of a new import that conflicts\n+    /// with an existing import.\n+    ///\n+    /// ```text,ignore (diagnostic)\n+    /// help: you can use `as` to change the binding name of the import\n+    ///    |\n+    /// LL | use foo::bar as other_bar;\n+    ///    |     ^^^^^^^^^^^^^^^^^^^^^\n+    /// ```\n+    fn add_suggestion_for_rename_of_use(\n+        &self,\n+        err: &mut Diagnostic,\n+        name: Symbol,\n+        import: &Import<'_>,\n+        binding_span: Span,\n+    ) {\n+        let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n+            format!(\"Other{}\", name)\n+        } else {\n+            format!(\"other_{}\", name)\n+        };\n+\n+        let mut suggestion = None;\n+        match import.kind {\n+            ImportKind::Single { type_ns_only: true, .. } => {\n+                suggestion = Some(format!(\"self as {}\", suggested_name))\n+            }\n+            ImportKind::Single { source, .. } => {\n+                if let Some(pos) =\n+                    source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n+                {\n+                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n+                        if pos <= snippet.len() {\n+                            suggestion = Some(format!(\n+                                \"{} as {}{}\",\n+                                &snippet[..pos],\n+                                suggested_name,\n+                                if snippet.ends_with(';') { \";\" } else { \"\" }\n+                            ))\n+                        }\n+                    }\n+                }\n+            }\n+            ImportKind::ExternCrate { source, target } => {\n+                suggestion = Some(format!(\n+                    \"extern crate {} as {};\",\n+                    source.unwrap_or(target.name),\n+                    suggested_name,\n+                ))\n+            }\n+            _ => unreachable!(),\n+        }\n+\n+        let rename_msg = \"you can use `as` to change the binding name of the import\";\n+        if let Some(suggestion) = suggestion {\n+            err.span_suggestion(\n+                binding_span,\n+                rename_msg,\n+                suggestion,\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(binding_span, rename_msg);\n+        }\n+    }\n+\n+    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n+    /// nested. In the following example, this function will be invoked to remove the `a` binding\n+    /// in the second use statement:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// use issue_52891::a;\n+    /// use issue_52891::{d, a, e};\n+    /// ```\n+    ///\n+    /// The following suggestion will be added:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// use issue_52891::{d, a, e};\n+    ///                      ^-- help: remove unnecessary import\n+    /// ```\n+    ///\n+    /// If the nested use contains only one import then the suggestion will remove the entire\n+    /// line.\n+    ///\n+    /// It is expected that the provided import is nested - this isn't checked by the\n+    /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n+    /// as characters expected by span manipulations won't be present.\n+    fn add_suggestion_for_duplicate_nested_use(\n+        &self,\n+        err: &mut Diagnostic,\n+        import: &Import<'_>,\n+        binding_span: Span,\n+    ) {\n+        assert!(import.is_nested());\n+        let message = \"remove unnecessary import\";\n+\n+        // Two examples will be used to illustrate the span manipulations we're doing:\n+        //\n+        // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n+        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n+        // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n+        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n+\n+        let (found_closing_brace, span) =\n+            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n+\n+        // If there was a closing brace then identify the span to remove any trailing commas from\n+        // previous imports.\n+        if found_closing_brace {\n+            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+                err.tool_only_span_suggestion(\n+                    span,\n+                    message,\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                // Remove the entire line if we cannot extend the span back, this indicates an\n+                // `issue_52891::{self}` case.\n+                err.span_suggestion(\n+                    import.use_span_with_attributes,\n+                    message,\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            return;\n+        }\n+\n+        err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n+    }\n+\n+    crate fn lint_if_path_starts_with_module(\n+        &mut self,\n+        finalize: Finalize,\n+        path: &[Segment],\n+        second_binding: Option<&NameBinding<'_>>,\n+    ) {\n+        let (diag_id, diag_span) = match finalize {\n+            Finalize::No => return,\n+            Finalize::SimplePath(id, path_span) => (id, path_span),\n+            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n+            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n+        };\n+\n+        let first_name = match path.get(0) {\n+            // In the 2018 edition this lint is a hard error, so nothing to do\n+            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n+            _ => return,\n+        };\n+\n+        // We're only interested in `use` paths which should start with\n+        // `{{root}}` currently.\n+        if first_name != kw::PathRoot {\n+            return;\n+        }\n+\n+        match path.get(1) {\n+            // If this import looks like `crate::...` it's already good\n+            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n+            // Otherwise go below to see if it's an extern crate\n+            Some(_) => {}\n+            // If the path has length one (and it's `PathRoot` most likely)\n+            // then we don't know whether we're gonna be importing a crate or an\n+            // item in our crate. Defer this lint to elsewhere\n+            None => return,\n+        }\n+\n+        // If the first element of our path was actually resolved to an\n+        // `ExternCrate` (also used for `crate::...`) then no need to issue a\n+        // warning, this looks all good!\n+        if let Some(binding) = second_binding {\n+            if let NameBindingKind::Import { import, .. } = binding.kind {\n+                // Careful: we still want to rewrite paths from renamed extern crates.\n+                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n+        self.lint_buffer.buffer_lint_with_diagnostic(\n+            ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n+            diag_id,\n+            diag_span,\n+            \"absolute paths must start with `self`, `super`, \\\n+             `crate`, or an external crate name in the 2018 edition\",\n+            diag,\n+        );\n+    }\n+\n     crate fn add_module_candidates(\n         &mut self,\n         module: Module<'a>,\n@@ -1076,6 +1467,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 None,\n                 false,\n+                false,\n+                None,\n             ) {\n                 let desc = match binding.res() {\n                     Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n@@ -1223,7 +1616,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n+    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n         let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n         let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n             // We have to print the span-less alternative first, otherwise formatting looks bad.\n@@ -1289,7 +1682,7 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+    fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n         let PrivacyError { ident, binding, .. } = *privacy_error;\n \n         let res = binding.res();\n@@ -1375,6 +1768,188 @@ impl<'a> Resolver<'a> {\n             sugg => sugg,\n         }\n     }\n+\n+    crate fn report_path_resolution_error(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+        module: Option<ModuleOrUniformRoot<'a>>,\n+        i: usize,\n+        ident: Ident,\n+    ) -> (String, Option<Suggestion>) {\n+        let is_last = i == path.len() - 1;\n+        let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+        let module_res = match module {\n+            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n+            _ => None,\n+        };\n+        if module_res == self.graph_root.res() {\n+            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n+            let mut candidates = self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n+            candidates\n+                .sort_by_cached_key(|c| (c.path.segments.len(), pprust::path_to_string(&c.path)));\n+            if let Some(candidate) = candidates.get(0) {\n+                (\n+                    String::from(\"unresolved import\"),\n+                    Some((\n+                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n+                        String::from(\"a similar path exists\"),\n+                        Applicability::MaybeIncorrect,\n+                    )),\n+                )\n+            } else if self.session.edition() == Edition::Edition2015 {\n+                (format!(\"maybe a missing crate `{}`?\", ident), None)\n+            } else {\n+                (format!(\"could not find `{}` in the crate root\", ident), None)\n+            }\n+        } else if i > 0 {\n+            let parent = path[i - 1].ident.name;\n+            let parent = match parent {\n+                // ::foo is mounted at the crate root for 2015, and is the extern\n+                // prelude for 2018+\n+                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                    \"the list of imported crates\".to_owned()\n+                }\n+                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n+                _ => format!(\"`{}`\", parent),\n+            };\n+\n+            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n+            if ns == TypeNS || ns == ValueNS {\n+                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                let binding = if let Some(module) = module {\n+                    self.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns_to_try,\n+                        parent_scope,\n+                        None,\n+                        false,\n+                        unusable_binding,\n+                    ).ok()\n+                } else if let Some(ribs) = ribs\n+                    && let Some(TypeNS | ValueNS) = opt_ns\n+                {\n+                    match self.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns_to_try,\n+                        parent_scope,\n+                        Finalize::No,\n+                        &ribs[ns_to_try],\n+                        unusable_binding,\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Some(binding),\n+                        _ => None,\n+                    }\n+                } else {\n+                    let scopes = ScopeSet::All(ns_to_try, opt_ns.is_none());\n+                    self.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        None,\n+                        false,\n+                        false,\n+                        unusable_binding,\n+                    ).ok()\n+                };\n+                if let Some(binding) = binding {\n+                    let mut found = |what| {\n+                        msg = format!(\n+                            \"expected {}, found {} `{}` in {}\",\n+                            ns.descr(),\n+                            what,\n+                            ident,\n+                            parent\n+                        )\n+                    };\n+                    if binding.module().is_some() {\n+                        found(\"module\")\n+                    } else {\n+                        match binding.res() {\n+                            Res::Def(kind, id) => found(kind.descr(id)),\n+                            _ => found(ns_to_try.descr()),\n+                        }\n+                    }\n+                };\n+            }\n+            (msg, None)\n+        } else if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n+            // Check whether the name refers to an item in the value namespace.\n+            let binding = if let Some(ribs) = ribs {\n+                self.resolve_ident_in_lexical_scope(\n+                    ident,\n+                    ValueNS,\n+                    parent_scope,\n+                    Finalize::No,\n+                    &ribs[ValueNS],\n+                    unusable_binding,\n+                )\n+            } else {\n+                None\n+            };\n+            let match_span = match binding {\n+                // Name matches a local variable. For example:\n+                // ```\n+                // fn f() {\n+                //     let Foo: &str = \"\";\n+                //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                //                               // variable `Foo`.\n+                // }\n+                // ```\n+                Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                    Some(*self.pat_span_map.get(&id).unwrap())\n+                }\n+                // Name matches item from a local name binding\n+                // created by `use` declaration. For example:\n+                // ```\n+                // pub Foo: &str = \"\";\n+                //\n+                // mod submod {\n+                //     use super::Foo;\n+                //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                //                               // binding `Foo`.\n+                // }\n+                // ```\n+                Some(LexicalScopeBinding::Item(name_binding)) => Some(name_binding.span),\n+                _ => None,\n+            };\n+            let suggestion = if let Some(span) = match_span {\n+                Some((\n+                    vec![(span, String::from(\"\"))],\n+                    format!(\"`{}` is defined here, but is not a type\", ident),\n+                    Applicability::MaybeIncorrect,\n+                ))\n+            } else {\n+                None\n+            };\n+\n+            (format!(\"use of undeclared type `{}`\", ident), suggestion)\n+        } else {\n+            let suggestion = if ident.name == sym::alloc {\n+                Some((\n+                    vec![],\n+                    String::from(\"add `extern crate alloc` to use the `alloc` crate\"),\n+                    Applicability::MaybeIncorrect,\n+                ))\n+            } else {\n+                self.find_similarly_named_module_or_crate(ident.name, &parent_scope.module).map(\n+                    |sugg| {\n+                        (\n+                            vec![(ident.span, sugg.to_string())],\n+                            String::from(\"there is a crate or module with a similar name\"),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                    },\n+                )\n+            };\n+            (format!(\"use of undeclared crate or module `{}`\", ident), suggestion)\n+        }\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {\n@@ -1422,7 +1997,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1441,7 +2016,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1472,7 +2047,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1506,7 +2081,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+            let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result\n@@ -1673,7 +2248,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n /// use foo::{a, b, c};\n ///              ^^^\n /// ```\n-pub(crate) fn find_span_of_binding_until_next_binding(\n+fn find_span_of_binding_until_next_binding(\n     sess: &Session,\n     binding_span: Span,\n     use_span: Span,\n@@ -1724,7 +2299,7 @@ pub(crate) fn find_span_of_binding_until_next_binding(\n /// use foo::{a, b, c};\n ///           --- binding span\n /// ```\n-pub(crate) fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n+fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n     let source_map = sess.source_map();\n \n     // `prev_source` will contain all of the source that came before the span.\n@@ -1812,7 +2387,7 @@ fn find_span_immediately_after_crate_name(\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n-crate fn show_candidates(\n+fn show_candidates(\n     definitions: &rustc_hir::definitions::Definitions,\n     session: &Session,\n     err: &mut Diagnostic,\n@@ -1947,3 +2522,70 @@ crate fn show_candidates(\n         }\n     }\n }\n+\n+#[derive(Debug)]\n+struct UsePlacementFinder {\n+    target_module: NodeId,\n+    first_legal_span: Option<Span>,\n+    first_use_span: Option<Span>,\n+}\n+\n+impl UsePlacementFinder {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+        let mut finder =\n+            UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n+        finder.visit_crate(krate);\n+        if let Some(use_span) = finder.first_use_span {\n+            (Some(use_span), true)\n+        } else {\n+            (finder.first_legal_span, false)\n+        }\n+    }\n+}\n+\n+impl<'tcx> visit::Visitor<'tcx> for UsePlacementFinder {\n+    fn visit_crate(&mut self, c: &Crate) {\n+        if self.target_module == CRATE_NODE_ID {\n+            let inject = c.spans.inject_use_span;\n+            if is_span_suitable_for_use_injection(inject) {\n+                self.first_legal_span = Some(inject);\n+            }\n+            self.first_use_span = search_for_any_use_in_items(&c.items);\n+            return;\n+        } else {\n+            visit::walk_crate(self, c);\n+        }\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx ast::Item) {\n+        if self.target_module == item.id {\n+            if let ItemKind::Mod(_, ModKind::Loaded(items, _inline, mod_spans)) = &item.kind {\n+                let inject = mod_spans.inject_use_span;\n+                if is_span_suitable_for_use_injection(inject) {\n+                    self.first_legal_span = Some(inject);\n+                }\n+                self.first_use_span = search_for_any_use_in_items(items);\n+                return;\n+            }\n+        } else {\n+            visit::walk_item(self, item);\n+        }\n+    }\n+}\n+\n+fn search_for_any_use_in_items(items: &[P<ast::Item>]) -> Option<Span> {\n+    for item in items {\n+        if let ItemKind::Use(..) = item.kind {\n+            if is_span_suitable_for_use_injection(item.span) {\n+                return Some(item.span.shrink_to_lo());\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+fn is_span_suitable_for_use_injection(s: Span) -> bool {\n+    // don't suggest placing a use before the prelude\n+    // import or other generated ones\n+    !s.from_expansion()\n+}"}, {"sha": "25ab3f7dacf905aa7bf48680616d1ee19cd55620", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "added", "additions": 1582, "deletions": 0, "changes": 1582, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -0,0 +1,1582 @@\n+use rustc_ast::{self as ast, NodeId};\n+use rustc_feature::is_builtin_attr_name;\n+use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n+use rustc_hir::PrimTy;\n+use rustc_middle::bug;\n+use rustc_middle::ty;\n+use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::edition::Edition;\n+use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n+use rustc_span::symbol::{kw, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::ptr;\n+\n+use crate::late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind};\n+use crate::macros::{sub_namespace_match, MacroRulesScope};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n+use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n+use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n+\n+use Determinacy::*;\n+use Namespace::*;\n+use RibKind::*;\n+\n+impl<'a> Resolver<'a> {\n+    /// A generic scope visitor.\n+    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n+    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n+    crate fn visit_scopes<T>(\n+        &mut self,\n+        scope_set: ScopeSet<'a>,\n+        parent_scope: &ParentScope<'a>,\n+        ctxt: SyntaxContext,\n+        mut visitor: impl FnMut(\n+            &mut Self,\n+            Scope<'a>,\n+            /*use_prelude*/ bool,\n+            SyntaxContext,\n+        ) -> Option<T>,\n+    ) -> Option<T> {\n+        // General principles:\n+        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n+        //    built into the language or standard library. This way we can add new names into the\n+        //    language or standard library without breaking user code.\n+        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n+        // Places to search (in order of decreasing priority):\n+        // (Type NS)\n+        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n+        // 4. Tool modules (closed, controlled right now, but not in the future).\n+        // 5. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude (closed, controlled).\n+        // (Value NS)\n+        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Standard library prelude (de-facto closed, controlled).\n+        // (Macro NS)\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n+        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n+        //    (open, the open part is from macro expansions, not controlled).\n+        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n+        // 4c. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+\n+        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n+        let (ns, macro_kind, is_absolute_path) = match scope_set {\n+            ScopeSet::All(ns, _) => (ns, None, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+        let module = match scope_set {\n+            // Start with the specified module.\n+            ScopeSet::Late(_, module, _) => module,\n+            // Jump out of trait or enum modules, they do not act as scopes.\n+            _ => parent_scope.module.nearest_item_scope(),\n+        };\n+        let mut scope = match ns {\n+            _ if is_absolute_path => Scope::CrateRoot,\n+            TypeNS | ValueNS => Scope::Module(module, None),\n+            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n+        };\n+        let mut ctxt = ctxt.normalize_to_macros_2_0();\n+        let mut use_prelude = !module.no_implicit_prelude;\n+\n+        loop {\n+            let visit = match scope {\n+                // Derive helpers are not in scope when resolving derives in the same container.\n+                Scope::DeriveHelpers(expn_id) => {\n+                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n+                }\n+                Scope::DeriveHelpersCompat => true,\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n+                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n+                    // As another consequence of this optimization visitors never observe invocation\n+                    // scopes for macros that were already expanded.\n+                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n+                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n+                            macro_rules_scope.set(next_scope.get());\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    true\n+                }\n+                Scope::CrateRoot => true,\n+                Scope::Module(..) => true,\n+                Scope::RegisteredAttrs => use_prelude,\n+                Scope::MacroUsePrelude => use_prelude || rust_2015,\n+                Scope::BuiltinAttrs => true,\n+                Scope::ExternPrelude => use_prelude || is_absolute_path,\n+                Scope::ToolPrelude => use_prelude,\n+                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n+                Scope::BuiltinTypes => true,\n+            };\n+\n+            if visit {\n+                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n+                    return break_result;\n+                }\n+            }\n+\n+            scope = match scope {\n+                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n+                Scope::DeriveHelpers(expn_id) => {\n+                    // Derive helpers are not visible to code generated by bang or derive macros.\n+                    let expn_data = expn_id.expn_data();\n+                    match expn_data.kind {\n+                        ExpnKind::Root\n+                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n+                            Scope::DeriveHelpersCompat\n+                        }\n+                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n+                    }\n+                }\n+                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n+                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n+                    MacroRulesScope::Binding(binding) => {\n+                        Scope::MacroRules(binding.parent_macro_rules_scope)\n+                    }\n+                    MacroRulesScope::Invocation(invoc_id) => {\n+                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n+                    }\n+                    MacroRulesScope::Empty => Scope::Module(module, None),\n+                },\n+                Scope::CrateRoot => match ns {\n+                    TypeNS => {\n+                        ctxt.adjust(ExpnId::root());\n+                        Scope::ExternPrelude\n+                    }\n+                    ValueNS | MacroNS => break,\n+                },\n+                Scope::Module(module, prev_lint_id) => {\n+                    use_prelude = !module.no_implicit_prelude;\n+                    let derive_fallback_lint_id = match scope_set {\n+                        ScopeSet::Late(.., lint_id) => lint_id,\n+                        _ => None,\n+                    };\n+                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n+                        Some((parent_module, lint_id)) => {\n+                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n+                        }\n+                        None => {\n+                            ctxt.adjust(ExpnId::root());\n+                            match ns {\n+                                TypeNS => Scope::ExternPrelude,\n+                                ValueNS => Scope::StdLibPrelude,\n+                                MacroNS => Scope::RegisteredAttrs,\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n+                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n+                Scope::BuiltinAttrs => break, // nowhere else to search\n+                Scope::ExternPrelude if is_absolute_path => break,\n+                Scope::ExternPrelude => Scope::ToolPrelude,\n+                Scope::ToolPrelude => Scope::StdLibPrelude,\n+                Scope::StdLibPrelude => match ns {\n+                    TypeNS => Scope::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => Scope::BuiltinAttrs,\n+                },\n+                Scope::BuiltinTypes => break, // nowhere else to search\n+            };\n+        }\n+\n+        None\n+    }\n+\n+    fn hygienic_lexical_parent(\n+        &mut self,\n+        module: Module<'a>,\n+        ctxt: &mut SyntaxContext,\n+        derive_fallback_lint_id: Option<NodeId>,\n+    ) -> Option<(Module<'a>, Option<NodeId>)> {\n+        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n+            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n+        }\n+\n+        if let ModuleKind::Block(..) = module.kind {\n+            return Some((module.parent.unwrap().nearest_item_scope(), None));\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if derive_fallback_lint_id.is_some() {\n+            if let Some(parent) = module.parent {\n+                // Inner module is inside the macro, parent module is outside of the macro.\n+                if module.expansion != parent.expansion\n+                    && module.expansion.is_descendant_of(parent.expansion)\n+                {\n+                    // The macro is a proc macro derive\n+                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n+                        let ext = self.get_macro_by_def_id(def_id);\n+                        if ext.builtin_name.is_none()\n+                            && ext.macro_kind() == MacroKind::Derive\n+                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n+                        {\n+                            return Some((parent, derive_fallback_lint_id));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n+    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n+    /// `ident` in the first scope that defines it (or None if no scopes define it).\n+    ///\n+    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n+    /// the items are defined in the block. For example,\n+    /// ```rust\n+    /// fn f() {\n+    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n+    ///    let g = || {};\n+    ///    fn g() {}\n+    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n+    /// }\n+    /// ```\n+    ///\n+    /// Invariant: This must only be called during main resolution, not during\n+    /// import resolution.\n+    #[tracing::instrument(level = \"debug\", skip(self, ribs))]\n+    crate fn resolve_ident_in_lexical_scope(\n+        &mut self,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: &[Rib<'a>],\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        let orig_ident = ident;\n+        if ident.name == kw::Empty {\n+            return Some(LexicalScopeBinding::Res(Res::Err));\n+        }\n+        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n+            // FIXME(jseyfried) improve `Self` hygiene\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n+            (empty_span, empty_span)\n+        } else if ns == TypeNS {\n+            let normalized_span = ident.span.normalize_to_macros_2_0();\n+            (normalized_span, normalized_span)\n+        } else {\n+            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n+        };\n+        ident.span = general_span;\n+        let normalized_ident = Ident { span: normalized_span, ..ident };\n+\n+        // Walk backwards up the ribs in scope.\n+        let finalize = finalize_full.path_span();\n+        let mut module = self.graph_root;\n+        for i in (0..ribs.len()).rev() {\n+            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n+            // Use the rib kind to determine whether we are resolving parameters\n+            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n+            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n+            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n+            {\n+                // The ident resolves to a type parameter or local variable.\n+                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n+                    i,\n+                    rib_ident,\n+                    *res,\n+                    finalize,\n+                    *original_rib_ident_def,\n+                    ribs,\n+                )));\n+            }\n+\n+            module = match ribs[i].kind {\n+                ModuleRibKind(module) => module,\n+                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    ident.span.remove_mark();\n+                    continue;\n+                }\n+                _ => continue,\n+            };\n+\n+            match module.kind {\n+                ModuleKind::Block(..) => {} // We can see through blocks\n+                _ => break,\n+            }\n+\n+            let item = self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                parent_scope,\n+                finalize,\n+                false,\n+                unusable_binding,\n+            );\n+            if let Ok(binding) = item {\n+                // The ident resolves to an item.\n+                return Some(LexicalScopeBinding::Item(binding));\n+            }\n+        }\n+        self.early_resolve_ident_in_lexical_scope(\n+            orig_ident,\n+            ScopeSet::Late(ns, module, finalize_full.node_id()),\n+            parent_scope,\n+            finalize,\n+            finalize.is_some(),\n+            false,\n+            unusable_binding,\n+        )\n+        .ok()\n+        .map(LexicalScopeBinding::Item)\n+    }\n+\n+    /// Resolve an identifier in lexical scope.\n+    /// This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n+    /// expansion and import resolution (perhaps they can be merged in the future).\n+    /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n+    /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n+    #[tracing::instrument(level = \"debug\", skip(self, scope_set))]\n+    crate fn early_resolve_ident_in_lexical_scope(\n+        &mut self,\n+        orig_ident: Ident,\n+        scope_set: ScopeSet<'a>,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        force: bool,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        bitflags::bitflags! {\n+            struct Flags: u8 {\n+                const MACRO_RULES          = 1 << 0;\n+                const MODULE               = 1 << 1;\n+                const MISC_SUGGEST_CRATE   = 1 << 2;\n+                const MISC_SUGGEST_SELF    = 1 << 3;\n+                const MISC_FROM_PRELUDE    = 1 << 4;\n+            }\n+        }\n+\n+        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n+\n+        // Make sure `self`, `super` etc produce an error when passed to here.\n+        if orig_ident.is_path_segment_keyword() {\n+            return Err(Determinacy::Determined);\n+        }\n+\n+        let (ns, macro_kind, is_import) = match scope_set {\n+            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+\n+        // This is *the* result, resolution from the scope closest to the resolved identifier.\n+        // However, sometimes this result is \"weak\" because it comes from a glob import or\n+        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n+        // mod m { ... } // solution in outer scope\n+        // {\n+        //     use prefix::*; // imports another `m` - innermost solution\n+        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n+        //     m::mac!();\n+        // }\n+        // So we have to save the innermost solution and continue searching in outer scopes\n+        // to detect potential ambiguities.\n+        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n+        let mut determinacy = Determinacy::Determined;\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let break_result = self.visit_scopes(\n+            scope_set,\n+            parent_scope,\n+            orig_ident.span.ctxt(),\n+            |this, scope, use_prelude, ctxt| {\n+                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n+                let ok = |res, span, arenas| {\n+                    Ok((\n+                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n+                            .to_name_binding(arenas),\n+                        Flags::empty(),\n+                    ))\n+                };\n+                let result = match scope {\n+                    Scope::DeriveHelpers(expn_id) => {\n+                        if let Some(attr) = this\n+                            .helper_attrs\n+                            .get(&expn_id)\n+                            .and_then(|attrs| attrs.iter().rfind(|i| ident == **i))\n+                        {\n+                            let binding = (\n+                                Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                ty::Visibility::Public,\n+                                attr.span,\n+                                expn_id,\n+                            )\n+                                .to_name_binding(this.arenas);\n+                            Ok((binding, Flags::empty()))\n+                        } else {\n+                            Err(Determinacy::Determined)\n+                        }\n+                    }\n+                    Scope::DeriveHelpersCompat => {\n+                        let mut result = Err(Determinacy::Determined);\n+                        for derive in parent_scope.derives {\n+                            let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n+                            match this.resolve_macro_path(\n+                                derive,\n+                                Some(MacroKind::Derive),\n+                                parent_scope,\n+                                true,\n+                                force,\n+                            ) {\n+                                Ok((Some(ext), _)) => {\n+                                    if ext.helper_attrs.contains(&ident.name) {\n+                                        result = ok(\n+                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n+                                            derive.span,\n+                                            this.arenas,\n+                                        );\n+                                        break;\n+                                    }\n+                                }\n+                                Ok(_) | Err(Determinacy::Determined) => {}\n+                                Err(Determinacy::Undetermined) => {\n+                                    result = Err(Determinacy::Undetermined)\n+                                }\n+                            }\n+                        }\n+                        result\n+                    }\n+                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n+                        MacroRulesScope::Binding(macro_rules_binding)\n+                            if ident == macro_rules_binding.ident =>\n+                        {\n+                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n+                        }\n+                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n+                        _ => Err(Determinacy::Determined),\n+                    },\n+                    Scope::CrateRoot => {\n+                        let root_ident = Ident::new(kw::PathRoot, ident.span);\n+                        let root_module = this.resolve_crate_root(root_ident);\n+                        let binding = this.resolve_ident_in_module_ext(\n+                            ModuleOrUniformRoot::Module(root_module),\n+                            ident,\n+                            ns,\n+                            parent_scope,\n+                            finalize,\n+                            last_import_segment,\n+                            unusable_binding,\n+                        );\n+                        match binding {\n+                            Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n+                            Err((Determinacy::Undetermined, Weak::No)) => {\n+                                return Some(Err(Determinacy::determined(force)));\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n+                                Err(Determinacy::Undetermined)\n+                            }\n+                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                        }\n+                    }\n+                    Scope::Module(module, derive_fallback_lint_id) => {\n+                        let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n+                        let binding = this.resolve_ident_in_module_unadjusted_ext(\n+                            ModuleOrUniformRoot::Module(module),\n+                            ident,\n+                            ns,\n+                            adjusted_parent_scope,\n+                            !matches!(scope_set, ScopeSet::Late(..)),\n+                            finalize,\n+                            last_import_segment,\n+                            unusable_binding,\n+                        );\n+                        match binding {\n+                            Ok(binding) => {\n+                                if let Some(lint_id) = derive_fallback_lint_id {\n+                                    this.lint_buffer.buffer_lint_with_diagnostic(\n+                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                                        lint_id,\n+                                        orig_ident.span,\n+                                        &format!(\n+                                            \"cannot find {} `{}` in this scope\",\n+                                            ns.descr(),\n+                                            ident\n+                                        ),\n+                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n+                                            orig_ident.span,\n+                                        ),\n+                                    );\n+                                }\n+                                let misc_flags = if ptr::eq(module, this.graph_root) {\n+                                    Flags::MISC_SUGGEST_CRATE\n+                                } else if module.is_normal() {\n+                                    Flags::MISC_SUGGEST_SELF\n+                                } else {\n+                                    Flags::empty()\n+                                };\n+                                Ok((binding, Flags::MODULE | misc_flags))\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::No)) => {\n+                                return Some(Err(Determinacy::determined(force)));\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n+                                Err(Determinacy::Undetermined)\n+                            }\n+                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                        }\n+                    }\n+                    Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n+                        Some(ident) => ok(\n+                            Res::NonMacroAttr(NonMacroAttrKind::Registered),\n+                            ident.span,\n+                            this.arenas,\n+                        ),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                    Scope::MacroUsePrelude => {\n+                        match this.macro_use_prelude.get(&ident.name).cloned() {\n+                            Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n+                    Scope::BuiltinAttrs => {\n+                        if is_builtin_attr_name(ident.name) {\n+                            ok(\n+                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n+                                DUMMY_SP,\n+                                this.arenas,\n+                            )\n+                        } else {\n+                            Err(Determinacy::Determined)\n+                        }\n+                    }\n+                    Scope::ExternPrelude => {\n+                        match this.extern_prelude_get(ident, finalize.is_some()) {\n+                            Some(binding) => Ok((binding, Flags::empty())),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n+                    Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n+                        Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                    Scope::StdLibPrelude => {\n+                        let mut result = Err(Determinacy::Determined);\n+                        if let Some(prelude) = this.prelude {\n+                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n+                                ModuleOrUniformRoot::Module(prelude),\n+                                ident,\n+                                ns,\n+                                parent_scope,\n+                                None,\n+                                last_import_segment,\n+                                unusable_binding,\n+                            ) {\n+                                if use_prelude || this.is_builtin_macro(binding.res()) {\n+                                    result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n+                                }\n+                            }\n+                        }\n+                        result\n+                    }\n+                    Scope::BuiltinTypes => match PrimTy::from_name(ident.name) {\n+                        Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                };\n+\n+                match result {\n+                    Ok((binding, flags))\n+                        if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n+                    {\n+                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n+                            return Some(Ok(binding));\n+                        }\n+\n+                        if let Some((innermost_binding, innermost_flags)) = innermost_result {\n+                            // Found another solution, if the first one was \"weak\", report an error.\n+                            let (res, innermost_res) = (binding.res(), innermost_binding.res());\n+                            if res != innermost_res {\n+                                let is_builtin = |res| {\n+                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n+                                };\n+                                let derive_helper =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                                let derive_helper_compat =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n+\n+                                let ambiguity_error_kind = if is_import {\n+                                    Some(AmbiguityKind::Import)\n+                                } else if is_builtin(innermost_res) || is_builtin(res) {\n+                                    Some(AmbiguityKind::BuiltinAttr)\n+                                } else if innermost_res == derive_helper_compat\n+                                    || res == derive_helper_compat && innermost_res != derive_helper\n+                                {\n+                                    Some(AmbiguityKind::DeriveHelper)\n+                                } else if innermost_flags.contains(Flags::MACRO_RULES)\n+                                    && flags.contains(Flags::MODULE)\n+                                    && !this.disambiguate_macro_rules_vs_modularized(\n+                                        innermost_binding,\n+                                        binding,\n+                                    )\n+                                    || flags.contains(Flags::MACRO_RULES)\n+                                        && innermost_flags.contains(Flags::MODULE)\n+                                        && !this.disambiguate_macro_rules_vs_modularized(\n+                                            binding,\n+                                            innermost_binding,\n+                                        )\n+                                {\n+                                    Some(AmbiguityKind::MacroRulesVsModularized)\n+                                } else if innermost_binding.is_glob_import() {\n+                                    Some(AmbiguityKind::GlobVsOuter)\n+                                } else if innermost_binding\n+                                    .may_appear_after(parent_scope.expansion, binding)\n+                                {\n+                                    Some(AmbiguityKind::MoreExpandedVsOuter)\n+                                } else {\n+                                    None\n+                                };\n+                                if let Some(kind) = ambiguity_error_kind {\n+                                    let misc = |f: Flags| {\n+                                        if f.contains(Flags::MISC_SUGGEST_CRATE) {\n+                                            AmbiguityErrorMisc::SuggestCrate\n+                                        } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n+                                            AmbiguityErrorMisc::SuggestSelf\n+                                        } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n+                                            AmbiguityErrorMisc::FromPrelude\n+                                        } else {\n+                                            AmbiguityErrorMisc::None\n+                                        }\n+                                    };\n+                                    this.ambiguity_errors.push(AmbiguityError {\n+                                        kind,\n+                                        ident: orig_ident,\n+                                        b1: innermost_binding,\n+                                        b2: binding,\n+                                        misc1: misc(innermost_flags),\n+                                        misc2: misc(flags),\n+                                    });\n+                                    return Some(Ok(innermost_binding));\n+                                }\n+                            }\n+                        } else {\n+                            // Found the first solution.\n+                            innermost_result = Some((binding, flags));\n+                        }\n+                    }\n+                    Ok(..) | Err(Determinacy::Determined) => {}\n+                    Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n+                }\n+\n+                None\n+            },\n+        );\n+\n+        if let Some(break_result) = break_result {\n+            return break_result;\n+        }\n+\n+        // The first found solution was the only one, return it.\n+        if let Some((binding, _)) = innermost_result {\n+            return Ok(binding);\n+        }\n+\n+        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn maybe_resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, None, false, None)\n+            .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        // We are resolving a last import segment during import validation.\n+        last_import_segment: bool,\n+        // This binding should be ignored during in-module resolution, so that we don't get\n+        // \"self-confirming\" import resolutions during import validation.\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_ext(\n+            module,\n+            ident,\n+            ns,\n+            parent_scope,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+        .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_ident_in_module_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n+        let tmp_parent_scope;\n+        let mut adjusted_parent_scope = parent_scope;\n+        match module {\n+            ModuleOrUniformRoot::Module(m) => {\n+                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n+            }\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n+                // No adjustments\n+            }\n+        }\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module,\n+            ident,\n+            ns,\n+            adjusted_parent_scope,\n+            false,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_ident_in_module_unadjusted(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module,\n+            ident,\n+            ns,\n+            parent_scope,\n+            false,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+        .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n+    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_ident_in_module_unadjusted_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        restricted_shadowing: bool,\n+        finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n+        let module = match module {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident,\n+                    ScopeSet::AbsolutePath(ns),\n+                    parent_scope,\n+                    finalize,\n+                    finalize.is_some(),\n+                    last_import_segment,\n+                    unusable_binding,\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                return if ns != TypeNS {\n+                    Err((Determined, Weak::No))\n+                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n+                    Ok(binding)\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n+                    // Macro-expanded `extern crate` items can add names to extern prelude.\n+                    Err((Undetermined, Weak::No))\n+                } else {\n+                    Err((Determined, Weak::No))\n+                };\n+            }\n+            ModuleOrUniformRoot::CurrentScope => {\n+                assert!(!restricted_shadowing);\n+                if ns == TypeNS {\n+                    if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n+                        let module = self.resolve_crate_root(ident);\n+                        let binding =\n+                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n+                                .to_name_binding(self.arenas);\n+                        return Ok(binding);\n+                    } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n+                        // FIXME: Implement these with renaming requirements so that e.g.\n+                        // `use super;` doesn't work, but `use super as name;` does.\n+                        // Fall through here to get an error from `early_resolve_...`.\n+                    }\n+                }\n+\n+                let scopes = ScopeSet::All(ns, true);\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident,\n+                    scopes,\n+                    parent_scope,\n+                    finalize,\n+                    finalize.is_some(),\n+                    last_import_segment,\n+                    unusable_binding,\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+        };\n+\n+        let key = self.new_key(ident, ns);\n+        let resolution =\n+            self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n+\n+        if let Some(path_span) = finalize {\n+            // If the primary binding is unusable, search further and return the shadowed glob\n+            // binding if it exists. What we really want here is having two separate scopes in\n+            // a module - one for non-globs and one for globs, but until that's done use this\n+            // hack to avoid inconsistent resolution ICEs during import validation.\n+            let binding = [resolution.binding, resolution.shadowed_glob]\n+                .into_iter()\n+                .filter_map(|binding| match (binding, unusable_binding) {\n+                    (Some(binding), Some(unusable_binding))\n+                        if ptr::eq(binding, unusable_binding) =>\n+                    {\n+                        None\n+                    }\n+                    _ => binding,\n+                })\n+                .next();\n+            let Some(binding) = binding else {\n+                return Err((Determined, Weak::No));\n+            };\n+\n+            if !self.is_accessible_from(binding.vis, parent_scope.module) {\n+                if last_import_segment {\n+                    return Err((Determined, Weak::No));\n+                } else {\n+                    self.privacy_errors.push(PrivacyError {\n+                        ident,\n+                        binding,\n+                        dedup_span: path_span,\n+                    });\n+                }\n+            }\n+\n+            // Forbid expanded shadowing to avoid time travel.\n+            if let Some(shadowed_glob) = resolution.shadowed_glob\n+                && restricted_shadowing\n+                && binding.expansion != LocalExpnId::ROOT\n+                && binding.res() != shadowed_glob.res()\n+            {\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    kind: AmbiguityKind::GlobVsExpanded,\n+                    ident,\n+                    b1: binding,\n+                    b2: shadowed_glob,\n+                    misc1: AmbiguityErrorMisc::None,\n+                    misc2: AmbiguityErrorMisc::None,\n+                });\n+            }\n+\n+            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n+                if let NameBindingKind::Res(_, true) = binding.kind {\n+                    self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n+                }\n+            }\n+\n+            self.record_use(ident, binding, restricted_shadowing);\n+            return Ok(binding);\n+        }\n+\n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            if let Some(unusable_binding) = unusable_binding {\n+                if ptr::eq(binding, unusable_binding) {\n+                    return Err((Determined, Weak::No));\n+                }\n+            }\n+            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n+            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n+        };\n+\n+        // Items and single imports are not shadowable, if we have one, then it's determined.\n+        if let Some(binding) = resolution.binding {\n+            if !binding.is_glob_import() {\n+                return check_usable(self, binding);\n+            }\n+        }\n+\n+        // --- From now on we either have a glob resolution or no resolution. ---\n+\n+        // Check if one of single imports can still define the name,\n+        // if it can then our result is not determined and can be invalidated.\n+        for single_import in &resolution.single_imports {\n+            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n+                continue;\n+            }\n+            let Some(module) = single_import.imported_module.get() else {\n+                return Err((Undetermined, Weak::No));\n+            };\n+            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n+                unreachable!();\n+            };\n+            match self.resolve_ident_in_module(\n+                module,\n+                ident,\n+                ns,\n+                &single_import.parent_scope,\n+                None,\n+                last_import_segment,\n+                unusable_binding,\n+            ) {\n+                Err(Determined) => continue,\n+                Ok(binding)\n+                    if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n+                {\n+                    continue;\n+                }\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n+            }\n+        }\n+\n+        // So we have a resolution that's from a glob import. This resolution is determined\n+        // if it cannot be shadowed by some new item/import expanded from a macro.\n+        // This happens either if there are no unexpanded macros, or expanded names cannot\n+        // shadow globs (that happens in macro namespace or with restricted shadowing).\n+        //\n+        // Additionally, any macro in any module can plant names in the root module if it creates\n+        // `macro_export` macros, so the root module effectively has unresolved invocations if any\n+        // module has unresolved invocations.\n+        // However, it causes resolution/expansion to stuck too often (#53144), so, to make\n+        // progress, we have to ignore those potential unresolved invocations from other modules\n+        // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n+        // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n+        if let Some(binding) = resolution.binding {\n+            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n+                return check_usable(self, binding);\n+            } else {\n+                return Err((Undetermined, Weak::No));\n+            }\n+        }\n+\n+        // --- From now on we have no resolution. ---\n+\n+        // Now we are in situation when new item/import can appear only from a glob or a macro\n+        // expansion. With restricted shadowing names from globs and macro expansions cannot\n+        // shadow names from outer scopes, so we can freely fallback from module search to search\n+        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n+        // scopes we return `Undetermined` with `Weak::Yes`.\n+\n+        // Check if one of unexpanded macros can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        if unexpanded_macros {\n+            return Err((Undetermined, Weak::Yes));\n+        }\n+\n+        // Check if one of glob imports can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        for glob_import in module.globs.borrow().iter() {\n+            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n+                continue;\n+            }\n+            let module = match glob_import.imported_module.get() {\n+                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                Some(_) => continue,\n+                None => return Err((Undetermined, Weak::Yes)),\n+            };\n+            let tmp_parent_scope;\n+            let (mut adjusted_parent_scope, mut ident) =\n+                (parent_scope, ident.normalize_to_macros_2_0());\n+            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n+                Some(Some(def)) => {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n+                Some(None) => {}\n+                None => continue,\n+            };\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                adjusted_parent_scope,\n+                None,\n+                last_import_segment,\n+                unusable_binding,\n+            );\n+\n+            match result {\n+                Err(Determined) => continue,\n+                Ok(binding)\n+                    if !self.is_accessible_from(binding.vis, glob_import.parent_scope.module) =>\n+                {\n+                    continue;\n+                }\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n+            }\n+        }\n+\n+        // No resolution and no one else can define the name - determinate error.\n+        Err((Determined, Weak::No))\n+    }\n+\n+    /// Validate a local resolution (from ribs).\n+    #[tracing::instrument(level = \"debug\", skip(self, all_ribs))]\n+    fn validate_res_from_ribs(\n+        &mut self,\n+        rib_index: usize,\n+        rib_ident: Ident,\n+        mut res: Res,\n+        finalize: Option<Span>,\n+        original_rib_ident_def: Ident,\n+        all_ribs: &[Rib<'a>],\n+    ) -> Res {\n+        const CG_BUG_STR: &str = \"min_const_generics resolve check didn't stop compilation\";\n+        debug!(\"validate_res_from_ribs({:?})\", res);\n+        let ribs = &all_ribs[rib_index + 1..];\n+\n+        // An invalid forward use of a generic parameter from a previous default.\n+        if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n+            if let Some(span) = finalize {\n+                let res_error = if rib_ident.name == kw::SelfUpper {\n+                    ResolutionError::SelfInGenericParamDefault\n+                } else {\n+                    ResolutionError::ForwardDeclaredGenericParam\n+                };\n+                self.report_error(span, res_error);\n+            }\n+            assert_eq!(res, Res::Err);\n+            return Res::Err;\n+        }\n+\n+        match res {\n+            Res::Local(_) => {\n+                use ResolutionError::*;\n+                let mut res_err = None;\n+\n+                for rib in ribs {\n+                    match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n+                            if let Some(span) = finalize {\n+                                // We don't immediately trigger a resolve error, because\n+                                // we want certain other resolution errors (namely those\n+                                // emitted for `ConstantItemRibKind` below) to take\n+                                // precedence.\n+                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n+                            }\n+                        }\n+                        ConstantItemRibKind(_, item) => {\n+                            // Still doesn't deal with upvars\n+                            if let Some(span) = finalize {\n+                                let (span, resolution_error) =\n+                                    if let Some((ident, constant_item_kind)) = item {\n+                                        let kind_str = match constant_item_kind {\n+                                            ConstantItemKind::Const => \"const\",\n+                                            ConstantItemKind::Static => \"static\",\n+                                        };\n+                                        (\n+                                            span,\n+                                            AttemptToUseNonConstantValueInConstant(\n+                                                ident, \"let\", kind_str,\n+                                            ),\n+                                        )\n+                                    } else {\n+                                        (\n+                                            rib_ident.span,\n+                                            AttemptToUseNonConstantValueInConstant(\n+                                                original_rib_ident_def,\n+                                                \"const\",\n+                                                \"let\",\n+                                            ),\n+                                        )\n+                                    };\n+                                self.report_error(span, resolution_error);\n+                            }\n+                            return Res::Err;\n+                        }\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n+                            }\n+                            return Res::Err;\n+                        }\n+                    }\n+                }\n+                if let Some((span, res_err)) = res_err {\n+                    self.report_error(span, res_err);\n+                    return Res::Err;\n+                }\n+            }\n+            Res::Def(DefKind::TyParam, _) | Res::SelfTy { .. } => {\n+                for rib in ribs {\n+                    let has_generic_params: HasGenericParams = match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | AssocItemRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => {\n+                            // Nothing to do. Continue.\n+                            continue;\n+                        }\n+\n+                        ConstantItemRibKind(trivial, _) => {\n+                            let features = self.session.features_untracked();\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !(trivial || features.generic_const_exprs) {\n+                                // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n+                                // we can't easily tell if it's generic at this stage, so we instead remember\n+                                // this and then enforce the self type to be concrete later on.\n+                                if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n+                                    res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n+                                } else {\n+                                    if let Some(span) = finalize {\n+                                        self.report_error(\n+                                            span,\n+                                            ResolutionError::ParamInNonTrivialAnonConst {\n+                                                name: rib_ident.name,\n+                                                is_type: true,\n+                                            },\n+                                        );\n+                                        self.session.delay_span_bug(span, CG_BUG_STR);\n+                                    }\n+\n+                                    return Res::Err;\n+                                }\n+                            }\n+\n+                            continue;\n+                        }\n+\n+                        // This was an attempt to use a type parameter outside its scope.\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(\n+                                    span,\n+                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                );\n+                            }\n+                            return Res::Err;\n+                        }\n+                    };\n+\n+                    if let Some(span) = finalize {\n+                        self.report_error(\n+                            span,\n+                            ResolutionError::GenericParamsFromOuterFunction(\n+                                res,\n+                                has_generic_params,\n+                            ),\n+                        );\n+                    }\n+                    return Res::Err;\n+                }\n+            }\n+            Res::Def(DefKind::ConstParam, _) => {\n+                let mut ribs = ribs.iter().peekable();\n+                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n+                    // When declaring const parameters inside function signatures, the first rib\n+                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n+                    // (spuriously) conflicting with the const param.\n+                    ribs.next();\n+                }\n+\n+                for rib in ribs {\n+                    let has_generic_params = match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | AssocItemRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => continue,\n+\n+                        ConstantItemRibKind(trivial, _) => {\n+                            let features = self.session.features_untracked();\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !(trivial || features.generic_const_exprs) {\n+                                if let Some(span) = finalize {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst {\n+                                            name: rib_ident.name,\n+                                            is_type: false,\n+                                        },\n+                                    );\n+                                    self.session.delay_span_bug(span, CG_BUG_STR);\n+                                }\n+\n+                                return Res::Err;\n+                            }\n+\n+                            continue;\n+                        }\n+\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(\n+                                    span,\n+                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                );\n+                            }\n+                            return Res::Err;\n+                        }\n+                    };\n+\n+                    // This was an attempt to use a const parameter outside its scope.\n+                    if let Some(span) = finalize {\n+                        self.report_error(\n+                            span,\n+                            ResolutionError::GenericParamsFromOuterFunction(\n+                                res,\n+                                has_generic_params,\n+                            ),\n+                        );\n+                    }\n+                    return Res::Err;\n+                }\n+            }\n+            _ => {}\n+        }\n+        res\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn maybe_resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, Finalize::No, None, None)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Finalize,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, unusable_binding)\n+    }\n+\n+    crate fn resolve_path_with_ribs(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> PathResult<'a> {\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n+\n+        let finalize = finalize_full.path_span();\n+        let mut module = None;\n+        let mut allow_super = true;\n+        let mut second_binding = None;\n+\n+        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n+            let record_segment_res = |this: &mut Self, res| {\n+                if finalize.is_some() {\n+                    if let Some(id) = id {\n+                        if !this.partial_res_map.contains_key(&id) {\n+                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                            this.record_partial_res(id, PartialRes::new(res));\n+                        }\n+                    }\n+                }\n+            };\n+\n+            let is_last = i == path.len() - 1;\n+            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+            let name = ident.name;\n+\n+            allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);\n+\n+            if ns == TypeNS {\n+                if allow_super && name == kw::Super {\n+                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n+                    let self_module = match i {\n+                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n+                        _ => match module {\n+                            Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n+                            _ => None,\n+                        },\n+                    };\n+                    if let Some(self_module) = self_module {\n+                        if let Some(parent) = self_module.parent {\n+                            module = Some(ModuleOrUniformRoot::Module(\n+                                self.resolve_self(&mut ctxt, parent),\n+                            ));\n+                            continue;\n+                        }\n+                    }\n+                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                        (\"there are too many leading `super` keywords\".to_string(), None)\n+                    });\n+                }\n+                if i == 0 {\n+                    if name == kw::SelfLower {\n+                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n+                        module = Some(ModuleOrUniformRoot::Module(\n+                            self.resolve_self(&mut ctxt, parent_scope.module),\n+                        ));\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot && ident.span.rust_2018() {\n+                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n+                        // `::a::b` from 2015 macro on 2018 global edition\n+                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {\n+                        // `::a::b`, `crate::a::b` or `$crate::a::b`\n+                        module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Report special messages for path segment keywords in wrong positions.\n+            if ident.is_path_segment_keyword() && i != 0 {\n+                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                    let name_str = if name == kw::PathRoot {\n+                        \"crate root\".to_string()\n+                    } else {\n+                        format!(\"`{}`\", name)\n+                    };\n+                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n+                        format!(\"global paths cannot start with {}\", name_str)\n+                    } else {\n+                        format!(\"{} in paths can only be used in start position\", name_str)\n+                    };\n+                    (label, None)\n+                });\n+            }\n+\n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                Res(Res),\n+            }\n+            let find_binding_in_ns = |this: &mut Self, ns| {\n+                let binding = if let Some(module) = module {\n+                    this.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        finalize,\n+                        false,\n+                        unusable_binding,\n+                    )\n+                } else if let Some(ribs) = ribs\n+                    && let Some(TypeNS | ValueNS) = opt_ns\n+                {\n+                    match this.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        finalize_full,\n+                        &ribs[ns],\n+                        unusable_binding,\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res)) => return FindBindingResult::Res(res),\n+                        _ => Err(Determinacy::determined(finalize.is_some())),\n+                    }\n+                } else {\n+                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n+                    this.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        finalize,\n+                        finalize.is_some(),\n+                        false,\n+                        unusable_binding,\n+                    )\n+                };\n+                FindBindingResult::Binding(binding)\n+            };\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::Res(res) => {\n+                    record_segment_res(self, res);\n+                    return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                        res,\n+                        path.len() - 1,\n+                    ));\n+                }\n+                FindBindingResult::Binding(binding) => binding,\n+            };\n+            match binding {\n+                Ok(binding) => {\n+                    if i == 1 {\n+                        second_binding = Some(binding);\n+                    }\n+                    let res = binding.res();\n+                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n+                    if let Some(next_module) = binding.module() {\n+                        module = Some(ModuleOrUniformRoot::Module(next_module));\n+                        record_segment_res(self, res);\n+                    } else if res == Res::ToolMod && i + 1 != path.len() {\n+                        if binding.is_import() {\n+                            self.session\n+                                .struct_span_err(\n+                                    ident.span,\n+                                    \"cannot use a tool module through an import\",\n+                                )\n+                                .span_note(binding.span, \"the tool module imported here\")\n+                                .emit();\n+                        }\n+                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                        return PathResult::NonModule(PartialRes::new(res));\n+                    } else if res == Res::Err {\n+                        return PathResult::NonModule(PartialRes::new(Res::Err));\n+                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n+                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                            res,\n+                            path.len() - i - 1,\n+                        ));\n+                    } else {\n+                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                            let label = format!(\n+                                \"`{ident}` is {} {}, not a module\",\n+                                res.article(),\n+                                res.descr()\n+                            );\n+                            (label, None)\n+                        });\n+                    }\n+                }\n+                Err(Undetermined) => return PathResult::Indeterminate,\n+                Err(Determined) => {\n+                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n+                        if opt_ns.is_some() && !module.is_normal() {\n+                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                                module.res().unwrap(),\n+                                path.len() - i,\n+                            ));\n+                        }\n+                    }\n+\n+                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                        self.report_path_resolution_error(\n+                            path,\n+                            opt_ns,\n+                            parent_scope,\n+                            ribs,\n+                            unusable_binding,\n+                            module,\n+                            i,\n+                            ident,\n+                        )\n+                    });\n+                }\n+            }\n+        }\n+\n+        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+\n+        PathResult::Module(match module {\n+            Some(module) => module,\n+            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n+            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n+        })\n+    }\n+}"}, {"sha": "aab0c1f97717c79b6fe3117c2543838181858dbf", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 26, "deletions": 301, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -2,12 +2,11 @@\n \n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n-use crate::Namespace::{self, MacroNS, TypeNS};\n+use crate::Namespace::{MacroNS, TypeNS};\n use crate::{module_to_string, names_to_string};\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n-use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n-use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n+use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n+use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n+use crate::{NameBinding, NameBindingKind, PathResult};\n \n use rustc_ast::NodeId;\n use rustc_data_structures::fx::FxHashSet;\n@@ -125,15 +124,15 @@ impl<'a> Import<'a> {\n     }\n }\n \n-#[derive(Clone, Default, Debug)]\n /// Records information about the resolution of a name in a namespace of a module.\n-pub struct NameResolution<'a> {\n+#[derive(Clone, Default, Debug)]\n+crate struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n+    pub single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n-    shadowed_glob: Option<&'a NameBinding<'a>>,\n+    pub shadowed_glob: Option<&'a NameBinding<'a>>,\n }\n \n impl<'a> NameResolution<'a> {\n@@ -169,278 +168,6 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolve_ident_in_module_unadjusted(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_unadjusted_ext(\n-            module,\n-            ident,\n-            ns,\n-            parent_scope,\n-            false,\n-            finalize,\n-        )\n-        .map_err(|(determinacy, _)| determinacy)\n-    }\n-\n-    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n-    crate fn resolve_ident_in_module_unadjusted_ext(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        restricted_shadowing: bool,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let module = match module {\n-            ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n-                assert!(!restricted_shadowing);\n-                let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    ScopeSet::AbsolutePath(ns),\n-                    parent_scope,\n-                    finalize,\n-                    finalize.is_some(),\n-                );\n-                return binding.map_err(|determinacy| (determinacy, Weak::No));\n-            }\n-            ModuleOrUniformRoot::ExternPrelude => {\n-                assert!(!restricted_shadowing);\n-                return if ns != TypeNS {\n-                    Err((Determined, Weak::No))\n-                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n-                    Ok(binding)\n-                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n-                    // Macro-expanded `extern crate` items can add names to extern prelude.\n-                    Err((Undetermined, Weak::No))\n-                } else {\n-                    Err((Determined, Weak::No))\n-                };\n-            }\n-            ModuleOrUniformRoot::CurrentScope => {\n-                assert!(!restricted_shadowing);\n-                if ns == TypeNS {\n-                    if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n-                        let module = self.resolve_crate_root(ident);\n-                        let binding =\n-                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n-                                .to_name_binding(self.arenas);\n-                        return Ok(binding);\n-                    } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n-                        // FIXME: Implement these with renaming requirements so that e.g.\n-                        // `use super;` doesn't work, but `use super as name;` does.\n-                        // Fall through here to get an error from `early_resolve_...`.\n-                    }\n-                }\n-\n-                let scopes = ScopeSet::All(ns, true);\n-                let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    scopes,\n-                    parent_scope,\n-                    finalize,\n-                    finalize.is_some(),\n-                );\n-                return binding.map_err(|determinacy| (determinacy, Weak::No));\n-            }\n-        };\n-\n-        let key = self.new_key(ident, ns);\n-        let resolution =\n-            self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n-\n-        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n-            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n-                    self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n-                }\n-            }\n-        }\n-\n-        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            if let Some(unusable_binding) = this.unusable_binding {\n-                if ptr::eq(binding, unusable_binding) {\n-                    return Err((Determined, Weak::No));\n-                }\n-            }\n-            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n-            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n-        };\n-\n-        if let Some(path_span) = finalize {\n-            return resolution\n-                .binding\n-                .and_then(|binding| {\n-                    // If the primary binding is unusable, search further and return the shadowed glob\n-                    // binding if it exists. What we really want here is having two separate scopes in\n-                    // a module - one for non-globs and one for globs, but until that's done use this\n-                    // hack to avoid inconsistent resolution ICEs during import validation.\n-                    if let Some(unusable_binding) = self.unusable_binding {\n-                        if ptr::eq(binding, unusable_binding) {\n-                            return resolution.shadowed_glob;\n-                        }\n-                    }\n-                    Some(binding)\n-                })\n-                .ok_or((Determined, Weak::No))\n-                .and_then(|binding| {\n-                    if self.last_import_segment && check_usable(self, binding).is_err() {\n-                        Err((Determined, Weak::No))\n-                    } else {\n-                        self.record_use(ident, binding, restricted_shadowing);\n-\n-                        if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                            // Forbid expanded shadowing to avoid time travel.\n-                            if restricted_shadowing\n-                                && binding.expansion != LocalExpnId::ROOT\n-                                && binding.res() != shadowed_glob.res()\n-                            {\n-                                self.ambiguity_errors.push(AmbiguityError {\n-                                    kind: AmbiguityKind::GlobVsExpanded,\n-                                    ident,\n-                                    b1: binding,\n-                                    b2: shadowed_glob,\n-                                    misc1: AmbiguityErrorMisc::None,\n-                                    misc2: AmbiguityErrorMisc::None,\n-                                });\n-                            }\n-                        }\n-\n-                        if !self.is_accessible_from(binding.vis, parent_scope.module) {\n-                            self.privacy_errors.push(PrivacyError {\n-                                ident,\n-                                binding,\n-                                dedup_span: path_span,\n-                            });\n-                        }\n-\n-                        Ok(binding)\n-                    }\n-                });\n-        }\n-\n-        // Items and single imports are not shadowable, if we have one, then it's determined.\n-        if let Some(binding) = resolution.binding {\n-            if !binding.is_glob_import() {\n-                return check_usable(self, binding);\n-            }\n-        }\n-\n-        // --- From now on we either have a glob resolution or no resolution. ---\n-\n-        // Check if one of single imports can still define the name,\n-        // if it can then our result is not determined and can be invalidated.\n-        for single_import in &resolution.single_imports {\n-            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n-                continue;\n-            }\n-            let Some(module) = single_import.imported_module.get() else {\n-                return Err((Undetermined, Weak::No));\n-            };\n-            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n-                unreachable!();\n-            };\n-            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n-            {\n-                Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n-                {\n-                    continue;\n-                }\n-                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n-            }\n-        }\n-\n-        // So we have a resolution that's from a glob import. This resolution is determined\n-        // if it cannot be shadowed by some new item/import expanded from a macro.\n-        // This happens either if there are no unexpanded macros, or expanded names cannot\n-        // shadow globs (that happens in macro namespace or with restricted shadowing).\n-        //\n-        // Additionally, any macro in any module can plant names in the root module if it creates\n-        // `macro_export` macros, so the root module effectively has unresolved invocations if any\n-        // module has unresolved invocations.\n-        // However, it causes resolution/expansion to stuck too often (#53144), so, to make\n-        // progress, we have to ignore those potential unresolved invocations from other modules\n-        // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n-        // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n-        if let Some(binding) = resolution.binding {\n-            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n-                return check_usable(self, binding);\n-            } else {\n-                return Err((Undetermined, Weak::No));\n-            }\n-        }\n-\n-        // --- From now on we have no resolution. ---\n-\n-        // Now we are in situation when new item/import can appear only from a glob or a macro\n-        // expansion. With restricted shadowing names from globs and macro expansions cannot\n-        // shadow names from outer scopes, so we can freely fallback from module search to search\n-        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n-        // scopes we return `Undetermined` with `Weak::Yes`.\n-\n-        // Check if one of unexpanded macros can still define the name,\n-        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n-        if unexpanded_macros {\n-            return Err((Undetermined, Weak::Yes));\n-        }\n-\n-        // Check if one of glob imports can still define the name,\n-        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n-        for glob_import in module.globs.borrow().iter() {\n-            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n-                continue;\n-            }\n-            let module = match glob_import.imported_module.get() {\n-                Some(ModuleOrUniformRoot::Module(module)) => module,\n-                Some(_) => continue,\n-                None => return Err((Undetermined, Weak::Yes)),\n-            };\n-            let tmp_parent_scope;\n-            let (mut adjusted_parent_scope, mut ident) =\n-                (parent_scope, ident.normalize_to_macros_2_0());\n-            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n-                Some(Some(def)) => {\n-                    tmp_parent_scope =\n-                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n-                    adjusted_parent_scope = &tmp_parent_scope;\n-                }\n-                Some(None) => {}\n-                None => continue,\n-            };\n-            let result = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                adjusted_parent_scope,\n-                None,\n-            );\n-\n-            match result {\n-                Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, glob_import.parent_scope.module) =>\n-                {\n-                    continue;\n-                }\n-                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n-            }\n-        }\n-\n-        // No resolution and no one else can define the name - determinate error.\n-        Err((Determined, Weak::No))\n-    }\n-\n     // Given a binding and an import that resolves to it,\n     // return the corresponding binding defined by the import.\n     crate fn import(\n@@ -772,7 +499,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res =\n-                self.r.resolve_path(&import.module_path, None, &import.parent_scope, Finalize::No);\n+                self.r.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -812,6 +539,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         None,\n+                        false,\n+                        None,\n                     );\n                     import.vis.set(orig_vis);\n                     source_bindings[ns].set(binding);\n@@ -857,10 +586,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-        let orig_unusable_binding = match &import.kind {\n-            ImportKind::Single { target_bindings, .. } => {\n-                Some(mem::replace(&mut self.r.unusable_binding, target_bindings[TypeNS].get()))\n-            }\n+        let unusable_binding = match &import.kind {\n+            ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n@@ -869,12 +596,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             root_span: import.root_span,\n             path_span: import.span,\n         };\n-        let path_res =\n-            self.r.resolve_path(&import.module_path, None, &import.parent_scope, finalize);\n+        let path_res = self.r.resolve_path(\n+            &import.module_path,\n+            None,\n+            &import.parent_scope,\n+            finalize,\n+            unusable_binding,\n+        );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        if let Some(orig_unusable_binding) = orig_unusable_binding {\n-            self.r.unusable_binding = orig_unusable_binding;\n-        }\n         import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n@@ -987,18 +716,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-                let orig_unusable_binding =\n-                    mem::replace(&mut this.unusable_binding, target_bindings[ns].get());\n-                let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n                     ns,\n                     &import.parent_scope,\n                     Some(import.span),\n+                    true,\n+                    target_bindings[ns].get(),\n                 );\n-                this.last_import_segment = orig_last_import_segment;\n-                this.unusable_binding = orig_unusable_binding;\n                 import.vis.set(orig_vis);\n \n                 match binding {\n@@ -1057,6 +783,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         Some(import.span),\n+                        false,\n+                        None,\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1271,15 +999,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     return;\n                 }\n \n-                let orig_unusable_binding =\n-                    mem::replace(&mut this.unusable_binding, target_bindings[ns].get());\n-\n                 match this.early_resolve_ident_in_lexical_scope(\n                     target,\n                     ScopeSet::All(ns, false),\n                     &import.parent_scope,\n                     None,\n                     false,\n+                    false,\n+                    target_bindings[ns].get(),\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some(\n@@ -1289,8 +1016,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     }\n                     Err(_) => is_redundant[ns] = Some(false),\n                 }\n-\n-                this.unusable_binding = orig_unusable_binding;\n             }\n         });\n "}, {"sha": "9084e659ae4958dec4cdfc0bb4ff7e284d710b2a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -8,7 +8,7 @@\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use rustc_ast::ptr::P;\n@@ -487,6 +487,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         self_ty,\n                         TypeNS,\n                         Finalize::SimplePath(ty.id, ty.span),\n+                        None,\n                     )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -676,12 +677,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     // checking.\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() {\n                         let mut check_ns = |ns| {\n-                            self.resolve_ident_in_lexical_scope(\n-                                path.segments[0].ident,\n-                                ns,\n-                                Finalize::No,\n-                            )\n-                            .is_some()\n+                            self.maybe_resolve_ident_in_lexical_scope(path.segments[0].ident, ns)\n+                                .is_some()\n                         };\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n@@ -750,18 +747,35 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n+    fn maybe_resolve_ident_in_lexical_scope(\n+        &mut self,\n+        ident: Ident,\n+        ns: Namespace,\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        self.r.resolve_ident_in_lexical_scope(\n+            ident,\n+            ns,\n+            &self.parent_scope,\n+            Finalize::No,\n+            &self.ribs[ns],\n+            None,\n+        )\n+    }\n+\n     fn resolve_ident_in_lexical_scope(\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n         finalize: Finalize,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n             finalize,\n             &self.ribs[ns],\n+            unusable_binding,\n         )\n     }\n \n@@ -771,7 +785,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.r.resolve_path_with_ribs(path, opt_ns, &self.parent_scope, finalize, Some(&self.ribs))\n+        self.r.resolve_path_with_ribs(\n+            path,\n+            opt_ns,\n+            &self.parent_scope,\n+            finalize,\n+            Some(&self.ribs),\n+            None,\n+        )\n     }\n \n     // AST resolution\n@@ -934,19 +955,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No) {\n+                match self.maybe_resolve_ident_in_lexical_scope(ident, ns) {\n                     Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n-                        let orig_unusable_binding =\n-                            replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) =\n-                            self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No)\n+                        if let Some(LexicalScopeBinding::Res(..)) = self\n+                            .resolve_ident_in_lexical_scope(ident, ns, Finalize::No, Some(binding))\n                         {\n                             report_error(self, ns);\n                         }\n-                        self.r.unusable_binding = orig_unusable_binding;\n                     }\n                     None => {}\n                 }\n@@ -1802,7 +1820,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No)?;\n+        let ls_binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS)?;\n         let (res, binding) = match ls_binding {\n             LexicalScopeBinding::Item(binding)\n                 if is_syntactic_ambiguity && binding.is_ambiguity() =>\n@@ -2071,17 +2089,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn self_type_is_available(&mut self) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_dummy_span(kw::SelfUpper),\n-            TypeNS,\n-            Finalize::No,\n-        );\n+        let binding = self\n+            .maybe_resolve_ident_in_lexical_scope(Ident::with_dummy_span(kw::SelfUpper), TypeNS);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No);\n+        let binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n "}, {"sha": "0926f24ae70efb44f497a1a654e1d72c1d597423", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -1271,12 +1271,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.r.resolve_ident_in_module(\n+            if let Ok(binding) = self.r.maybe_resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n                 &self.parent_scope,\n-                None,\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {"}, {"sha": "b2c7a4d18de386c42a18ce55e126ee724c5bbd5e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1483, "changes": 1494, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! This crate is responsible for the part of name resolution that doesn't require type checker.\n //!\n //! Module structure of the crate is built here.\n@@ -26,27 +24,18 @@ extern crate tracing;\n \n pub use rustc_hir::def::{Namespace, PerNS};\n \n-use Determinacy::*;\n-\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::ptr::P;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n-use rustc_ast::{Crate, CRATE_NODE_ID};\n-use rustc_ast::{Expr, ExprKind, LitKind};\n-use rustc_ast::{ItemKind, ModKind, Path};\n+use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n+use rustc_ast::{Crate, Expr, ExprKind, LitKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n-use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n@@ -55,16 +44,14 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n-use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n-use rustc_session::lint;\n-use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n+use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n-use rustc_span::edition::Edition;\n-use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n+use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -75,10 +62,9 @@ use std::collections::BTreeSet;\n use std::{cmp, fmt, mem, ptr};\n use tracing::debug;\n \n-use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n-use late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind::*};\n+use late::{HasGenericParams, PathSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n use crate::access_levels::AccessLevelsVisitor;\n@@ -90,6 +76,7 @@ mod build_reduced_graph;\n mod check_unused;\n mod def_collector;\n mod diagnostics;\n+mod ident;\n mod imports;\n mod late;\n mod macros;\n@@ -315,73 +302,6 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-#[derive(Debug)]\n-struct UsePlacementFinder {\n-    target_module: NodeId,\n-    first_legal_span: Option<Span>,\n-    first_use_span: Option<Span>,\n-}\n-\n-impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n-        let mut finder =\n-            UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n-        finder.visit_crate(krate);\n-        if let Some(use_span) = finder.first_use_span {\n-            (Some(use_span), true)\n-        } else {\n-            (finder.first_legal_span, false)\n-        }\n-    }\n-}\n-\n-fn is_span_suitable_for_use_injection(s: Span) -> bool {\n-    // don't suggest placing a use before the prelude\n-    // import or other generated ones\n-    !s.from_expansion()\n-}\n-\n-fn search_for_any_use_in_items(items: &[P<ast::Item>]) -> Option<Span> {\n-    for item in items {\n-        if let ItemKind::Use(..) = item.kind {\n-            if is_span_suitable_for_use_injection(item.span) {\n-                return Some(item.span.shrink_to_lo());\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n-    fn visit_crate(&mut self, c: &Crate) {\n-        if self.target_module == CRATE_NODE_ID {\n-            let inject = c.spans.inject_use_span;\n-            if is_span_suitable_for_use_injection(inject) {\n-                self.first_legal_span = Some(inject);\n-            }\n-            self.first_use_span = search_for_any_use_in_items(&c.items);\n-            return;\n-        } else {\n-            visit::walk_crate(self, c);\n-        }\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx ast::Item) {\n-        if self.target_module == item.id {\n-            if let ItemKind::Mod(_, ModKind::Loaded(items, _inline, mod_spans)) = &item.kind {\n-                let inject = mod_spans.inject_use_span;\n-                if is_span_suitable_for_use_injection(inject) {\n-                    self.first_legal_span = Some(inject);\n-                }\n-                self.first_use_span = search_for_any_use_in_items(items);\n-                return;\n-            }\n-        } else {\n-            visit::walk_item(self, item);\n-        }\n-    }\n-}\n-\n /// An intermediate resolution result.\n ///\n /// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n@@ -928,13 +848,6 @@ pub struct Resolver<'a> {\n     /// All non-determined imports.\n     indeterminate_imports: Vec<&'a Import<'a>>,\n \n-    /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n-    /// We are resolving a last import segment during import validation.\n-    last_import_segment: bool,\n-    /// This binding should be ignored during in-module resolution, so that we don't get\n-    /// \"self-confirming\" import resolutions during import validation.\n-    unusable_binding: Option<&'a NameBinding<'a>>,\n-\n     // Spans for local variables found during pattern resolution.\n     // Used for suggestions during error reporting.\n     pat_span_map: NodeMap<Span>,\n@@ -1342,9 +1255,6 @@ impl<'a> Resolver<'a> {\n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n \n-            last_import_segment: false,\n-            unusable_binding: None,\n-\n             pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n@@ -1731,387 +1641,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// A generic scope visitor.\n-    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n-    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n-    fn visit_scopes<T>(\n-        &mut self,\n-        scope_set: ScopeSet<'a>,\n-        parent_scope: &ParentScope<'a>,\n-        ctxt: SyntaxContext,\n-        mut visitor: impl FnMut(\n-            &mut Self,\n-            Scope<'a>,\n-            /*use_prelude*/ bool,\n-            SyntaxContext,\n-        ) -> Option<T>,\n-    ) -> Option<T> {\n-        // General principles:\n-        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n-        //    built into the language or standard library. This way we can add new names into the\n-        //    language or standard library without breaking user code.\n-        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n-        // Places to search (in order of decreasing priority):\n-        // (Type NS)\n-        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n-        // 4. Tool modules (closed, controlled right now, but not in the future).\n-        // 5. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude (closed, controlled).\n-        // (Value NS)\n-        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Standard library prelude (de-facto closed, controlled).\n-        // (Macro NS)\n-        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and probably even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n-        //    priority than prelude macros, but create ambiguities with macros in modules.\n-        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled). Have higher priority than prelude macros, but create\n-        //    ambiguities with `macro_rules`.\n-        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 4a. User-defined prelude from macro-use\n-        //    (open, the open part is from macro expansions, not controlled).\n-        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n-        // 4c. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude: builtin attributes (closed, controlled).\n-\n-        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n-        let (ns, macro_kind, is_absolute_path) = match scope_set {\n-            ScopeSet::All(ns, _) => (ns, None, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Late(ns, ..) => (ns, None, false),\n-        };\n-        let module = match scope_set {\n-            // Start with the specified module.\n-            ScopeSet::Late(_, module, _) => module,\n-            // Jump out of trait or enum modules, they do not act as scopes.\n-            _ => parent_scope.module.nearest_item_scope(),\n-        };\n-        let mut scope = match ns {\n-            _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module, None),\n-            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n-        };\n-        let mut ctxt = ctxt.normalize_to_macros_2_0();\n-        let mut use_prelude = !module.no_implicit_prelude;\n-\n-        loop {\n-            let visit = match scope {\n-                // Derive helpers are not in scope when resolving derives in the same container.\n-                Scope::DeriveHelpers(expn_id) => {\n-                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n-                }\n-                Scope::DeriveHelpersCompat => true,\n-                Scope::MacroRules(macro_rules_scope) => {\n-                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n-                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n-                    // As another consequence of this optimization visitors never observe invocation\n-                    // scopes for macros that were already expanded.\n-                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n-                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n-                            macro_rules_scope.set(next_scope.get());\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-                    true\n-                }\n-                Scope::CrateRoot => true,\n-                Scope::Module(..) => true,\n-                Scope::RegisteredAttrs => use_prelude,\n-                Scope::MacroUsePrelude => use_prelude || rust_2015,\n-                Scope::BuiltinAttrs => true,\n-                Scope::ExternPrelude => use_prelude || is_absolute_path,\n-                Scope::ToolPrelude => use_prelude,\n-                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n-                Scope::BuiltinTypes => true,\n-            };\n-\n-            if visit {\n-                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n-                    return break_result;\n-                }\n-            }\n-\n-            scope = match scope {\n-                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n-                Scope::DeriveHelpers(expn_id) => {\n-                    // Derive helpers are not visible to code generated by bang or derive macros.\n-                    let expn_data = expn_id.expn_data();\n-                    match expn_data.kind {\n-                        ExpnKind::Root\n-                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n-                            Scope::DeriveHelpersCompat\n-                        }\n-                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n-                    }\n-                }\n-                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n-                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n-                    MacroRulesScope::Binding(binding) => {\n-                        Scope::MacroRules(binding.parent_macro_rules_scope)\n-                    }\n-                    MacroRulesScope::Invocation(invoc_id) => {\n-                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n-                    }\n-                    MacroRulesScope::Empty => Scope::Module(module, None),\n-                },\n-                Scope::CrateRoot => match ns {\n-                    TypeNS => {\n-                        ctxt.adjust(ExpnId::root());\n-                        Scope::ExternPrelude\n-                    }\n-                    ValueNS | MacroNS => break,\n-                },\n-                Scope::Module(module, prev_lint_id) => {\n-                    use_prelude = !module.no_implicit_prelude;\n-                    let derive_fallback_lint_id = match scope_set {\n-                        ScopeSet::Late(.., lint_id) => lint_id,\n-                        _ => None,\n-                    };\n-                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n-                        Some((parent_module, lint_id)) => {\n-                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n-                        }\n-                        None => {\n-                            ctxt.adjust(ExpnId::root());\n-                            match ns {\n-                                TypeNS => Scope::ExternPrelude,\n-                                ValueNS => Scope::StdLibPrelude,\n-                                MacroNS => Scope::RegisteredAttrs,\n-                            }\n-                        }\n-                    }\n-                }\n-                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n-                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n-                Scope::BuiltinAttrs => break, // nowhere else to search\n-                Scope::ExternPrelude if is_absolute_path => break,\n-                Scope::ExternPrelude => Scope::ToolPrelude,\n-                Scope::ToolPrelude => Scope::StdLibPrelude,\n-                Scope::StdLibPrelude => match ns {\n-                    TypeNS => Scope::BuiltinTypes,\n-                    ValueNS => break, // nowhere else to search\n-                    MacroNS => Scope::BuiltinAttrs,\n-                },\n-                Scope::BuiltinTypes => break, // nowhere else to search\n-            };\n-        }\n-\n-        None\n-    }\n-\n-    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n-    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n-    /// `ident` in the first scope that defines it (or None if no scopes define it).\n-    ///\n-    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n-    /// the items are defined in the block. For example,\n-    /// ```rust\n-    /// fn f() {\n-    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n-    ///    let g = || {};\n-    ///    fn g() {}\n-    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n-    /// }\n-    /// ```\n-    ///\n-    /// Invariant: This must only be called during main resolution, not during\n-    /// import resolution.\n-    fn resolve_ident_in_lexical_scope(\n-        &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n-        ribs: &[Rib<'a>],\n-    ) -> Option<LexicalScopeBinding<'a>> {\n-        assert!(ns == TypeNS || ns == ValueNS);\n-        let orig_ident = ident;\n-        if ident.name == kw::Empty {\n-            return Some(LexicalScopeBinding::Res(Res::Err));\n-        }\n-        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n-            // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n-            (empty_span, empty_span)\n-        } else if ns == TypeNS {\n-            let normalized_span = ident.span.normalize_to_macros_2_0();\n-            (normalized_span, normalized_span)\n-        } else {\n-            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n-        };\n-        ident.span = general_span;\n-        let normalized_ident = Ident { span: normalized_span, ..ident };\n-\n-        // Walk backwards up the ribs in scope.\n-        let finalize = finalize_full.path_span();\n-        let mut module = self.graph_root;\n-        for i in (0..ribs.len()).rev() {\n-            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n-            // Use the rib kind to determine whether we are resolving parameters\n-            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n-            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n-            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n-            {\n-                // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n-                    i,\n-                    rib_ident,\n-                    *res,\n-                    finalize,\n-                    *original_rib_ident_def,\n-                    ribs,\n-                )));\n-            }\n-\n-            module = match ribs[i].kind {\n-                ModuleRibKind(module) => module,\n-                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n-                    // If an invocation of this macro created `ident`, give up on `ident`\n-                    // and switch to `ident`'s source from the macro definition.\n-                    ident.span.remove_mark();\n-                    continue;\n-                }\n-                _ => continue,\n-            };\n-\n-            match module.kind {\n-                ModuleKind::Block(..) => {} // We can see through blocks\n-                _ => break,\n-            }\n-\n-            let item = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                parent_scope,\n-                finalize,\n-            );\n-            if let Ok(binding) = item {\n-                // The ident resolves to an item.\n-                return Some(LexicalScopeBinding::Item(binding));\n-            }\n-        }\n-        self.early_resolve_ident_in_lexical_scope(\n-            orig_ident,\n-            ScopeSet::Late(ns, module, finalize_full.node_id()),\n-            parent_scope,\n-            finalize,\n-            finalize.is_some(),\n-        )\n-        .ok()\n-        .map(LexicalScopeBinding::Item)\n-    }\n-\n-    fn hygienic_lexical_parent(\n-        &mut self,\n-        module: Module<'a>,\n-        ctxt: &mut SyntaxContext,\n-        derive_fallback_lint_id: Option<NodeId>,\n-    ) -> Option<(Module<'a>, Option<NodeId>)> {\n-        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n-        }\n-\n-        if let ModuleKind::Block(..) = module.kind {\n-            return Some((module.parent.unwrap().nearest_item_scope(), None));\n-        }\n-\n-        // We need to support the next case under a deprecation warning\n-        // ```\n-        // struct MyStruct;\n-        // ---- begin: this comes from a proc macro derive\n-        // mod implementation_details {\n-        //     // Note that `MyStruct` is not in scope here.\n-        //     impl SomeTrait for MyStruct { ... }\n-        // }\n-        // ---- end\n-        // ```\n-        // So we have to fall back to the module's parent during lexical resolution in this case.\n-        if derive_fallback_lint_id.is_some() {\n-            if let Some(parent) = module.parent {\n-                // Inner module is inside the macro, parent module is outside of the macro.\n-                if module.expansion != parent.expansion\n-                    && module.expansion.is_descendant_of(parent.expansion)\n-                {\n-                    // The macro is a proc macro derive\n-                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                        let ext = self.get_macro_by_def_id(def_id);\n-                        if ext.builtin_name.is_none()\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n-                        {\n-                            return Some((parent, derive_fallback_lint_id));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_ident_in_module(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n-            .map_err(|(determinacy, _)| determinacy)\n-    }\n-\n-    fn resolve_ident_in_module_ext(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let tmp_parent_scope;\n-        let mut adjusted_parent_scope = parent_scope;\n-        match module {\n-            ModuleOrUniformRoot::Module(m) => {\n-                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n-                    tmp_parent_scope =\n-                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n-                    adjusted_parent_scope = &tmp_parent_scope;\n-                }\n-            }\n-            ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n-            }\n-            ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n-                // No adjustments\n-            }\n-        }\n-        self.resolve_ident_in_module_unadjusted_ext(\n-            module,\n-            ident,\n-            ns,\n-            adjusted_parent_scope,\n-            false,\n-            finalize,\n-        )\n-    }\n-\n     fn resolve_crate_root(&mut self, ident: Ident) -> Module<'a> {\n         debug!(\"resolve_crate_root({:?})\", ident);\n         let mut ctxt = ident.span.ctxt();\n@@ -2194,676 +1723,6 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    fn resolve_path(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Finalize,\n-    ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n-    }\n-\n-    fn resolve_path_with_ribs(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n-        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n-    ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n-\n-        let finalize = finalize_full.path_span();\n-        let mut module = None;\n-        let mut allow_super = true;\n-        let mut second_binding = None;\n-\n-        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n-            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n-            let record_segment_res = |this: &mut Self, res| {\n-                if finalize.is_some() {\n-                    if let Some(id) = id {\n-                        if !this.partial_res_map.contains_key(&id) {\n-                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_partial_res(id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-            };\n-\n-            let is_last = i == path.len() - 1;\n-            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n-            let name = ident.name;\n-\n-            allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);\n-\n-            if ns == TypeNS {\n-                if allow_super && name == kw::Super {\n-                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                    let self_module = match i {\n-                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n-                        _ => match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n-                            _ => None,\n-                        },\n-                    };\n-                    if let Some(self_module) = self_module {\n-                        if let Some(parent) = self_module.parent {\n-                            module = Some(ModuleOrUniformRoot::Module(\n-                                self.resolve_self(&mut ctxt, parent),\n-                            ));\n-                            continue;\n-                        }\n-                    }\n-                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                        (\"there are too many leading `super` keywords\".to_string(), None)\n-                    });\n-                }\n-                if i == 0 {\n-                    if name == kw::SelfLower {\n-                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                        module = Some(ModuleOrUniformRoot::Module(\n-                            self.resolve_self(&mut ctxt, parent_scope.module),\n-                        ));\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot && ident.span.rust_2018() {\n-                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n-                        // `::a::b` from 2015 macro on 2018 global edition\n-                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {\n-                        // `::a::b`, `crate::a::b` or `$crate::a::b`\n-                        module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));\n-                        continue;\n-                    }\n-                }\n-            }\n-\n-            // Report special messages for path segment keywords in wrong positions.\n-            if ident.is_path_segment_keyword() && i != 0 {\n-                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                    let name_str = if name == kw::PathRoot {\n-                        \"crate root\".to_string()\n-                    } else {\n-                        format!(\"`{}`\", name)\n-                    };\n-                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n-                        format!(\"global paths cannot start with {}\", name_str)\n-                    } else {\n-                        format!(\"{} in paths can only be used in start position\", name_str)\n-                    };\n-                    (label, None)\n-                });\n-            }\n-\n-            enum FindBindingResult<'a> {\n-                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n-                PathResult(PathResult<'a>),\n-            }\n-            let find_binding_in_ns = |this: &mut Self, ns| {\n-                let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n-                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n-                    this.early_resolve_ident_in_lexical_scope(\n-                        ident,\n-                        scopes,\n-                        parent_scope,\n-                        finalize,\n-                        finalize.is_some(),\n-                    )\n-                } else {\n-                    match this.resolve_ident_in_lexical_scope(\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        finalize_full,\n-                        &ribs.unwrap()[ns],\n-                    ) {\n-                        // we found a locally-imported or available item/module\n-                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                        // we found a local variable or type param\n-                        Some(LexicalScopeBinding::Res(res))\n-                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                        {\n-                            record_segment_res(this, res);\n-                            return FindBindingResult::PathResult(PathResult::NonModule(\n-                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n-                            ));\n-                        }\n-                        _ => Err(Determinacy::determined(finalize.is_some())),\n-                    }\n-                };\n-                FindBindingResult::Binding(binding)\n-            };\n-            let binding = match find_binding_in_ns(self, ns) {\n-                FindBindingResult::PathResult(x) => return x,\n-                FindBindingResult::Binding(binding) => binding,\n-            };\n-            match binding {\n-                Ok(binding) => {\n-                    if i == 1 {\n-                        second_binding = Some(binding);\n-                    }\n-                    let res = binding.res();\n-                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n-                    if let Some(next_module) = binding.module() {\n-                        module = Some(ModuleOrUniformRoot::Module(next_module));\n-                        record_segment_res(self, res);\n-                    } else if res == Res::ToolMod && i + 1 != path.len() {\n-                        if binding.is_import() {\n-                            self.session\n-                                .struct_span_err(\n-                                    ident.span,\n-                                    \"cannot use a tool module through an import\",\n-                                )\n-                                .span_note(binding.span, \"the tool module imported here\")\n-                                .emit();\n-                        }\n-                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        return PathResult::NonModule(PartialRes::new(res));\n-                    } else if res == Res::Err {\n-                        return PathResult::NonModule(PartialRes::new(Res::Err));\n-                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n-                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                            res,\n-                            path.len() - i - 1,\n-                        ));\n-                    } else {\n-                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                            let label = format!(\n-                                \"`{ident}` is {} {}, not a module\",\n-                                res.article(),\n-                                res.descr()\n-                            );\n-                            (label, None)\n-                        });\n-                    }\n-                }\n-                Err(Undetermined) => return PathResult::Indeterminate,\n-                Err(Determined) => {\n-                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n-                        if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                                module.res().unwrap(),\n-                                path.len() - i,\n-                            ));\n-                        }\n-                    }\n-\n-                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                        let module_res = match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                            _ => None,\n-                        };\n-                        if module_res == self.graph_root.res() {\n-                            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n-                            let mut candidates =\n-                                self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n-                            candidates.sort_by_cached_key(|c| {\n-                                (c.path.segments.len(), pprust::path_to_string(&c.path))\n-                            });\n-                            if let Some(candidate) = candidates.get(0) {\n-                                (\n-                                    String::from(\"unresolved import\"),\n-                                    Some((\n-                                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n-                                        String::from(\"a similar path exists\"),\n-                                        Applicability::MaybeIncorrect,\n-                                    )),\n-                                )\n-                            } else if self.session.edition() == Edition::Edition2015 {\n-                                (format!(\"maybe a missing crate `{}`?\", ident), None)\n-                            } else {\n-                                (format!(\"could not find `{}` in the crate root\", ident), None)\n-                            }\n-                        } else if i == 0 {\n-                            if ident\n-                                .name\n-                                .as_str()\n-                                .chars()\n-                                .next()\n-                                .map_or(false, |c| c.is_ascii_uppercase())\n-                            {\n-                                // Check whether the name refers to an item in the value namespace.\n-                                let suggestion = if ribs.is_some() {\n-                                    let match_span = match self.resolve_ident_in_lexical_scope(\n-                                        ident,\n-                                        ValueNS,\n-                                        parent_scope,\n-                                        Finalize::No,\n-                                        &ribs.unwrap()[ValueNS],\n-                                    ) {\n-                                        // Name matches a local variable. For example:\n-                                        // ```\n-                                        // fn f() {\n-                                        //     let Foo: &str = \"\";\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // variable `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                                            Some(*self.pat_span_map.get(&id).unwrap())\n-                                        }\n-\n-                                        // Name matches item from a local name binding\n-                                        // created by `use` declaration. For example:\n-                                        // ```\n-                                        // pub Foo: &str = \"\";\n-                                        //\n-                                        // mod submod {\n-                                        //     use super::Foo;\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // binding `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Item(name_binding)) => {\n-                                            Some(name_binding.span)\n-                                        }\n-                                        _ => None,\n-                                    };\n-\n-                                    if let Some(span) = match_span {\n-                                        Some((\n-                                            vec![(span, String::from(\"\"))],\n-                                            format!(\n-                                                \"`{}` is defined here, but is not a type\",\n-                                                ident\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        None\n-                                    }\n-                                } else {\n-                                    None\n-                                };\n-\n-                                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n-                            } else {\n-                                (\n-                                    format!(\"use of undeclared crate or module `{}`\", ident),\n-                                    if ident.name == sym::alloc {\n-                                        Some((\n-                                            vec![],\n-                                            String::from(\n-                                                \"add `extern crate alloc` to use the `alloc` crate\",\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        self.find_similarly_named_module_or_crate(\n-                                            ident.name,\n-                                            &parent_scope.module,\n-                                        )\n-                                        .map(|sugg| {\n-                                            (\n-                                                vec![(ident.span, sugg.to_string())],\n-                                                String::from(\n-                                                    \"there is a crate or module with a similar name\",\n-                                                ),\n-                                                Applicability::MaybeIncorrect,\n-                                            )\n-                                        })\n-                                    },\n-                                )\n-                            }\n-                        } else {\n-                            let parent = path[i - 1].ident.name;\n-                            let parent = match parent {\n-                                // ::foo is mounted at the crate root for 2015, and is the extern\n-                                // prelude for 2018+\n-                                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n-                                    \"the list of imported crates\".to_owned()\n-                                }\n-                                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                                _ => {\n-                                    format!(\"`{}`\", parent)\n-                                }\n-                            };\n-\n-                            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n-                            if ns == TypeNS || ns == ValueNS {\n-                                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                                if let FindBindingResult::Binding(Ok(binding)) =\n-                                    find_binding_in_ns(self, ns_to_try)\n-                                {\n-                                    let mut found = |what| {\n-                                        msg = format!(\n-                                            \"expected {}, found {} `{}` in {}\",\n-                                            ns.descr(),\n-                                            what,\n-                                            ident,\n-                                            parent\n-                                        )\n-                                    };\n-                                    if binding.module().is_some() {\n-                                        found(\"module\")\n-                                    } else {\n-                                        match binding.res() {\n-                                            def::Res::<NodeId>::Def(kind, id) => {\n-                                                found(kind.descr(id))\n-                                            }\n-                                            _ => found(ns_to_try.descr()),\n-                                        }\n-                                    }\n-                                };\n-                            }\n-                            (msg, None)\n-                        }\n-                    });\n-                }\n-            }\n-        }\n-\n-        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n-\n-        PathResult::Module(match module {\n-            Some(module) => module,\n-            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n-            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n-        })\n-    }\n-\n-    fn lint_if_path_starts_with_module(\n-        &mut self,\n-        finalize: Finalize,\n-        path: &[Segment],\n-        second_binding: Option<&NameBinding<'_>>,\n-    ) {\n-        let (diag_id, diag_span) = match finalize {\n-            Finalize::No => return,\n-            Finalize::SimplePath(id, path_span) => (id, path_span),\n-            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n-            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n-        };\n-\n-        let first_name = match path.get(0) {\n-            // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n-            _ => return,\n-        };\n-\n-        // We're only interested in `use` paths which should start with\n-        // `{{root}}` currently.\n-        if first_name != kw::PathRoot {\n-            return;\n-        }\n-\n-        match path.get(1) {\n-            // If this import looks like `crate::...` it's already good\n-            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n-            // Otherwise go below to see if it's an extern crate\n-            Some(_) => {}\n-            // If the path has length one (and it's `PathRoot` most likely)\n-            // then we don't know whether we're gonna be importing a crate or an\n-            // item in our crate. Defer this lint to elsewhere\n-            None => return,\n-        }\n-\n-        // If the first element of our path was actually resolved to an\n-        // `ExternCrate` (also used for `crate::...`) then no need to issue a\n-        // warning, this looks all good!\n-        if let Some(binding) = second_binding {\n-            if let NameBindingKind::Import { import, .. } = binding.kind {\n-                // Careful: we still want to rewrite paths from renamed extern crates.\n-                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n-        self.lint_buffer.buffer_lint_with_diagnostic(\n-            lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            diag_id,\n-            diag_span,\n-            \"absolute paths must start with `self`, `super`, \\\n-             `crate`, or an external crate name in the 2018 edition\",\n-            diag,\n-        );\n-    }\n-\n-    // Validate a local resolution (from ribs).\n-    fn validate_res_from_ribs(\n-        &mut self,\n-        rib_index: usize,\n-        rib_ident: Ident,\n-        mut res: Res,\n-        finalize: Option<Span>,\n-        original_rib_ident_def: Ident,\n-        all_ribs: &[Rib<'a>],\n-    ) -> Res {\n-        const CG_BUG_STR: &str = \"min_const_generics resolve check didn't stop compilation\";\n-        debug!(\"validate_res_from_ribs({:?})\", res);\n-        let ribs = &all_ribs[rib_index + 1..];\n-\n-        // An invalid forward use of a generic parameter from a previous default.\n-        if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n-            if let Some(span) = finalize {\n-                let res_error = if rib_ident.name == kw::SelfUpper {\n-                    ResolutionError::SelfInGenericParamDefault\n-                } else {\n-                    ResolutionError::ForwardDeclaredGenericParam\n-                };\n-                self.report_error(span, res_error);\n-            }\n-            assert_eq!(res, Res::Err);\n-            return Res::Err;\n-        }\n-\n-        match res {\n-            Res::Local(_) => {\n-                use ResolutionError::*;\n-                let mut res_err = None;\n-\n-                for rib in ribs {\n-                    match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => {\n-                            // Nothing to do. Continue.\n-                        }\n-                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n-                            // This was an attempt to access an upvar inside a\n-                            // named function item. This is not allowed, so we\n-                            // report an error.\n-                            if let Some(span) = finalize {\n-                                // We don't immediately trigger a resolve error, because\n-                                // we want certain other resolution errors (namely those\n-                                // emitted for `ConstantItemRibKind` below) to take\n-                                // precedence.\n-                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n-                            }\n-                        }\n-                        ConstantItemRibKind(_, item) => {\n-                            // Still doesn't deal with upvars\n-                            if let Some(span) = finalize {\n-                                let (span, resolution_error) =\n-                                    if let Some((ident, constant_item_kind)) = item {\n-                                        let kind_str = match constant_item_kind {\n-                                            ConstantItemKind::Const => \"const\",\n-                                            ConstantItemKind::Static => \"static\",\n-                                        };\n-                                        (\n-                                            span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                ident, \"let\", kind_str,\n-                                            ),\n-                                        )\n-                                    } else {\n-                                        (\n-                                            rib_ident.span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                original_rib_ident_def,\n-                                                \"const\",\n-                                                \"let\",\n-                                            ),\n-                                        )\n-                                    };\n-                                self.report_error(span, resolution_error);\n-                            }\n-                            return Res::Err;\n-                        }\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n-                            }\n-                            return Res::Err;\n-                        }\n-                    }\n-                }\n-                if let Some((span, res_err)) = res_err {\n-                    self.report_error(span, res_err);\n-                    return Res::Err;\n-                }\n-            }\n-            Res::Def(DefKind::TyParam, _) | Res::SelfTy { .. } => {\n-                for rib in ribs {\n-                    let has_generic_params: HasGenericParams = match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => {\n-                            // Nothing to do. Continue.\n-                            continue;\n-                        }\n-\n-                        ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial || features.generic_const_exprs) {\n-                                // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n-                                // we can't easily tell if it's generic at this stage, so we instead remember\n-                                // this and then enforce the self type to be concrete later on.\n-                                if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n-                                    res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n-                                } else {\n-                                    if let Some(span) = finalize {\n-                                        self.report_error(\n-                                            span,\n-                                            ResolutionError::ParamInNonTrivialAnonConst {\n-                                                name: rib_ident.name,\n-                                                is_type: true,\n-                                            },\n-                                        );\n-                                        self.session.delay_span_bug(span, CG_BUG_STR);\n-                                    }\n-\n-                                    return Res::Err;\n-                                }\n-                            }\n-\n-                            continue;\n-                        }\n-\n-                        // This was an attempt to use a type parameter outside its scope.\n-                        ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(\n-                                    span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n-                    };\n-\n-                    if let Some(span) = finalize {\n-                        self.report_error(\n-                            span,\n-                            ResolutionError::GenericParamsFromOuterFunction(\n-                                res,\n-                                has_generic_params,\n-                            ),\n-                        );\n-                    }\n-                    return Res::Err;\n-                }\n-            }\n-            Res::Def(DefKind::ConstParam, _) => {\n-                let mut ribs = ribs.iter().peekable();\n-                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n-                    // When declaring const parameters inside function signatures, the first rib\n-                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n-                    // (spuriously) conflicting with the const param.\n-                    ribs.next();\n-                }\n-\n-                for rib in ribs {\n-                    let has_generic_params = match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => continue,\n-\n-                        ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial || features.generic_const_exprs) {\n-                                if let Some(span) = finalize {\n-                                    self.report_error(\n-                                        span,\n-                                        ResolutionError::ParamInNonTrivialAnonConst {\n-                                            name: rib_ident.name,\n-                                            is_type: false,\n-                                        },\n-                                    );\n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n-                                }\n-\n-                                return Res::Err;\n-                            }\n-\n-                            continue;\n-                        }\n-\n-                        ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(\n-                                    span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n-                    };\n-\n-                    // This was an attempt to use a const parameter outside its scope.\n-                    if let Some(span) = finalize {\n-                        self.report_error(\n-                            span,\n-                            ResolutionError::GenericParamsFromOuterFunction(\n-                                res,\n-                                has_generic_params,\n-                            ),\n-                        );\n-                    }\n-                    return Res::Err;\n-                }\n-            }\n-            _ => {}\n-        }\n-        res\n-    }\n-\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n@@ -2910,331 +1769,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn report_errors(&mut self, krate: &Crate) {\n-        self.report_with_use_injections(krate);\n-\n-        for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n-            let msg = \"macro-expanded `macro_export` macros from the current crate \\\n-                       cannot be referred to by absolute paths\";\n-            self.lint_buffer.buffer_lint_with_diagnostic(\n-                lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n-                CRATE_NODE_ID,\n-                span_use,\n-                msg,\n-                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def),\n-            );\n-        }\n-\n-        for ambiguity_error in &self.ambiguity_errors {\n-            self.report_ambiguity_error(ambiguity_error);\n-        }\n-\n-        let mut reported_spans = FxHashSet::default();\n-        for error in &self.privacy_errors {\n-            if reported_spans.insert(error.dedup_span) {\n-                self.report_privacy_error(error);\n-            }\n-        }\n-    }\n-\n-    fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, def_id, instead, suggestion } in\n-            self.use_injections.drain(..)\n-        {\n-            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n-                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n-            } else {\n-                (None, false)\n-            };\n-            if !candidates.is_empty() {\n-                diagnostics::show_candidates(\n-                    &self.definitions,\n-                    self.session,\n-                    &mut err,\n-                    span,\n-                    &candidates,\n-                    instead,\n-                    found_use,\n-                );\n-            } else if let Some((span, msg, sugg, appl)) = suggestion {\n-                err.span_suggestion(span, msg, sugg, appl);\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    fn report_conflict<'b>(\n-        &mut self,\n-        parent: Module<'_>,\n-        ident: Ident,\n-        ns: Namespace,\n-        new_binding: &NameBinding<'b>,\n-        old_binding: &NameBinding<'b>,\n-    ) {\n-        // Error on the second of two conflicting names\n-        if old_binding.span.lo() > new_binding.span.lo() {\n-            return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n-        }\n-\n-        let container = match parent.kind {\n-            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n-            ModuleKind::Block(..) => \"block\",\n-        };\n-\n-        let old_noun = match old_binding.is_import() {\n-            true => \"import\",\n-            false => \"definition\",\n-        };\n-\n-        let new_participle = match new_binding.is_import() {\n-            true => \"imported\",\n-            false => \"defined\",\n-        };\n-\n-        let (name, span) =\n-            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n-\n-        if let Some(s) = self.name_already_seen.get(&name) {\n-            if s == &span {\n-                return;\n-            }\n-        }\n-\n-        let old_kind = match (ns, old_binding.module()) {\n-            (ValueNS, _) => \"value\",\n-            (MacroNS, _) => \"macro\",\n-            (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n-            (TypeNS, Some(module)) if module.is_normal() => \"module\",\n-            (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n-            (TypeNS, _) => \"type\",\n-        };\n-\n-        let msg = format!(\"the name `{}` is defined multiple times\", name);\n-\n-        let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n-            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n-            (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n-                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n-                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n-            },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n-                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n-                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n-            },\n-        };\n-\n-        err.note(&format!(\n-            \"`{}` must be defined only once in the {} namespace of this {}\",\n-            name,\n-            ns.descr(),\n-            container\n-        ));\n-\n-        err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        err.span_label(\n-            self.session.source_map().guess_head_span(old_binding.span),\n-            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n-        );\n-\n-        // See https://github.com/rust-lang/rust/issues/32354\n-        use NameBindingKind::Import;\n-        let import = match (&new_binding.kind, &old_binding.kind) {\n-            // If there are two imports where one or both have attributes then prefer removing the\n-            // import without attributes.\n-            (Import { import: new, .. }, Import { import: old, .. })\n-                if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n-                } =>\n-            {\n-                if old.has_attributes {\n-                    Some((new, new_binding.span, true))\n-                } else {\n-                    Some((old, old_binding.span, true))\n-                }\n-            }\n-            // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n-                Some((import, new_binding.span, other.is_import()))\n-            }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n-                Some((import, old_binding.span, other.is_import()))\n-            }\n-            _ => None,\n-        };\n-\n-        // Check if the target of the use for both bindings is the same.\n-        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n-        let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n-        let from_item =\n-            self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n-        // Only suggest removing an import if both bindings are to the same def, if both spans\n-        // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n-        // been introduced by an item.\n-        let should_remove_import = duplicate\n-            && !has_dummy_span\n-            && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n-\n-        match import {\n-            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n-                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n-            }\n-            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n-                // Simple case - remove the entire import. Due to the above match arm, this can\n-                // only be a single use so just remove it entirely.\n-                err.tool_only_span_suggestion(\n-                    import.use_span_with_attributes,\n-                    \"remove unnecessary import\",\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            Some((import, span, _)) => {\n-                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n-            }\n-            _ => {}\n-        }\n-\n-        err.emit();\n-        self.name_already_seen.insert(name, span);\n-    }\n-\n-    /// This function adds a suggestion to change the binding name of a new import that conflicts\n-    /// with an existing import.\n-    ///\n-    /// ```text,ignore (diagnostic)\n-    /// help: you can use `as` to change the binding name of the import\n-    ///    |\n-    /// LL | use foo::bar as other_bar;\n-    ///    |     ^^^^^^^^^^^^^^^^^^^^^\n-    /// ```\n-    fn add_suggestion_for_rename_of_use(\n-        &self,\n-        err: &mut Diagnostic,\n-        name: Symbol,\n-        import: &Import<'_>,\n-        binding_span: Span,\n-    ) {\n-        let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n-            format!(\"Other{}\", name)\n-        } else {\n-            format!(\"other_{}\", name)\n-        };\n-\n-        let mut suggestion = None;\n-        match import.kind {\n-            ImportKind::Single { type_ns_only: true, .. } => {\n-                suggestion = Some(format!(\"self as {}\", suggested_name))\n-            }\n-            ImportKind::Single { source, .. } => {\n-                if let Some(pos) =\n-                    source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n-                {\n-                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n-                        if pos <= snippet.len() {\n-                            suggestion = Some(format!(\n-                                \"{} as {}{}\",\n-                                &snippet[..pos],\n-                                suggested_name,\n-                                if snippet.ends_with(';') { \";\" } else { \"\" }\n-                            ))\n-                        }\n-                    }\n-                }\n-            }\n-            ImportKind::ExternCrate { source, target } => {\n-                suggestion = Some(format!(\n-                    \"extern crate {} as {};\",\n-                    source.unwrap_or(target.name),\n-                    suggested_name,\n-                ))\n-            }\n-            _ => unreachable!(),\n-        }\n-\n-        let rename_msg = \"you can use `as` to change the binding name of the import\";\n-        if let Some(suggestion) = suggestion {\n-            err.span_suggestion(\n-                binding_span,\n-                rename_msg,\n-                suggestion,\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            err.span_label(binding_span, rename_msg);\n-        }\n-    }\n-\n-    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n-    /// nested. In the following example, this function will be invoked to remove the `a` binding\n-    /// in the second use statement:\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// use issue_52891::a;\n-    /// use issue_52891::{d, a, e};\n-    /// ```\n-    ///\n-    /// The following suggestion will be added:\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// use issue_52891::{d, a, e};\n-    ///                      ^-- help: remove unnecessary import\n-    /// ```\n-    ///\n-    /// If the nested use contains only one import then the suggestion will remove the entire\n-    /// line.\n-    ///\n-    /// It is expected that the provided import is nested - this isn't checked by the\n-    /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n-    /// as characters expected by span manipulations won't be present.\n-    fn add_suggestion_for_duplicate_nested_use(\n-        &self,\n-        err: &mut Diagnostic,\n-        import: &Import<'_>,\n-        binding_span: Span,\n-    ) {\n-        assert!(import.is_nested());\n-        let message = \"remove unnecessary import\";\n-\n-        // Two examples will be used to illustrate the span manipulations we're doing:\n-        //\n-        // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n-        // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n-\n-        let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n-\n-        // If there was a closing brace then identify the span to remove any trailing commas from\n-        // previous imports.\n-        if found_closing_brace {\n-            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n-                err.tool_only_span_suggestion(\n-                    span,\n-                    message,\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                // Remove the entire line if we cannot extend the span back, this indicates an\n-                // `issue_52891::{self}` case.\n-                err.span_suggestion(\n-                    import.use_span_with_attributes,\n-                    message,\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            return;\n-        }\n-\n-        err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n-    }\n-\n     fn extern_prelude_get(&mut self, ident: Ident, finalize: bool) -> Option<&'a NameBinding<'a>> {\n         if ident.is_path_segment_keyword() {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n@@ -3289,12 +1823,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let module = self.expect_module(module_id);\n-        match self.resolve_path(\n-            &segments,\n-            Some(ns),\n-            &ParentScope::module(module, self),\n-            Finalize::No,\n-        ) {\n+        match self.maybe_resolve_path(&segments, Some(ns), &ParentScope::module(module, self)) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                 Some(path_res.base_res())\n@@ -3384,12 +1913,11 @@ impl<'a> Resolver<'a> {\n         let ident = Ident::with_dummy_span(sym::main);\n         let parent_scope = &ParentScope::module(module, self);\n \n-        let Ok(name_binding) = self.resolve_ident_in_module(\n+        let Ok(name_binding) = self.maybe_resolve_ident_in_module(\n             ModuleOrUniformRoot::Module(module),\n             ident,\n             ValueNS,\n             parent_scope,\n-            None\n         ) else {\n             return;\n         };"}, {"sha": "01f0b11f1ac3beb0030649a55e360f50bb7d09c9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 19, "deletions": 364, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2743c13de071a637c28fc22fba34947aa29bcc17/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=2743c13de071a637c28fc22fba34947aa29bcc17", "patch": "@@ -3,9 +3,9 @@\n \n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n-use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n-use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{BuiltinMacroState, Determinacy};\n+use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n+use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n@@ -18,14 +18,11 @@ use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, Resolver\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, Invocation, InvocationKind, SupportsMacroExpansion};\n-use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n-use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::{self, RegisteredTools};\n-use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, PROC_MACRO_DERIVE_RESOLUTION_FALLBACK};\n-use rustc_session::lint::builtin::{SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_middle::ty::RegisteredTools;\n+use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE, UNUSED_MACROS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -35,7 +32,7 @@ use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n-use std::{mem, ptr};\n+use std::mem;\n \n type Res = def::Res<NodeId>;\n \n@@ -73,10 +70,10 @@ pub enum MacroRulesScope<'a> {\n /// in a module (including derives) and hurt performance.\n pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>;\n \n-// Macro namespace is separated into two sub-namespaces, one for bang macros and\n-// one for attribute-like macros (attributes, derives).\n-// We ignore resolutions from one sub-namespace when searching names in scope for another.\n-fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n+/// Macro namespace is separated into two sub-namespaces, one for bang macros and\n+/// one for attribute-like macros (attributes, derives).\n+/// We ignore resolutions from one sub-namespace when searching names in scope for another.\n+crate fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS {\n         Bang,\n@@ -415,7 +412,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         let mut indeterminate = false;\n         for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n-            match self.resolve_path(path, Some(ns), &parent_scope, Finalize::No) {\n+            match self.maybe_resolve_path(path, Some(ns), &parent_scope) {\n                 PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n                 PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n                     return Ok(true);\n@@ -575,7 +572,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let res = if path.len() > 1 {\n-            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, Finalize::No) {\n+            let res = match self.maybe_resolve_path(&path, Some(MacroNS), parent_scope) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     Ok(path_res.base_res())\n                 }\n@@ -607,6 +604,8 @@ impl<'a> Resolver<'a> {\n                 parent_scope,\n                 None,\n                 force,\n+                false,\n+                None,\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n                 return Err(Determinacy::Undetermined);\n@@ -630,355 +629,6 @@ impl<'a> Resolver<'a> {\n         res.map(|res| (self.get_macro(res), res))\n     }\n \n-    // Resolve an identifier in lexical scope.\n-    // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n-    // expansion and import resolution (perhaps they can be merged in the future).\n-    // The function is used for resolving initial segments of macro paths (e.g., `foo` in\n-    // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n-    crate fn early_resolve_ident_in_lexical_scope(\n-        &mut self,\n-        orig_ident: Ident,\n-        scope_set: ScopeSet<'a>,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-        force: bool,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        bitflags::bitflags! {\n-            struct Flags: u8 {\n-                const MACRO_RULES          = 1 << 0;\n-                const MODULE               = 1 << 1;\n-                const MISC_SUGGEST_CRATE   = 1 << 2;\n-                const MISC_SUGGEST_SELF    = 1 << 3;\n-                const MISC_FROM_PRELUDE    = 1 << 4;\n-            }\n-        }\n-\n-        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n-\n-        // Make sure `self`, `super` etc produce an error when passed to here.\n-        if orig_ident.is_path_segment_keyword() {\n-            return Err(Determinacy::Determined);\n-        }\n-\n-        let (ns, macro_kind, is_import) = match scope_set {\n-            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Late(ns, ..) => (ns, None, false),\n-        };\n-\n-        // This is *the* result, resolution from the scope closest to the resolved identifier.\n-        // However, sometimes this result is \"weak\" because it comes from a glob import or\n-        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n-        // mod m { ... } // solution in outer scope\n-        // {\n-        //     use prefix::*; // imports another `m` - innermost solution\n-        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n-        //     m::mac!();\n-        // }\n-        // So we have to save the innermost solution and continue searching in outer scopes\n-        // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n-        let mut determinacy = Determinacy::Determined;\n-\n-        // Go through all the scopes and try to resolve the name.\n-        let break_result = self.visit_scopes(\n-            scope_set,\n-            parent_scope,\n-            orig_ident.span.ctxt(),\n-            |this, scope, use_prelude, ctxt| {\n-                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n-                let ok = |res, span, arenas| {\n-                    Ok((\n-                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n-                            .to_name_binding(arenas),\n-                        Flags::empty(),\n-                    ))\n-                };\n-                let result = match scope {\n-                    Scope::DeriveHelpers(expn_id) => {\n-                        if let Some(attr) = this\n-                            .helper_attrs\n-                            .get(&expn_id)\n-                            .and_then(|attrs| attrs.iter().rfind(|i| ident == **i))\n-                        {\n-                            let binding = (\n-                                Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                ty::Visibility::Public,\n-                                attr.span,\n-                                expn_id,\n-                            )\n-                                .to_name_binding(this.arenas);\n-                            Ok((binding, Flags::empty()))\n-                        } else {\n-                            Err(Determinacy::Determined)\n-                        }\n-                    }\n-                    Scope::DeriveHelpersCompat => {\n-                        let mut result = Err(Determinacy::Determined);\n-                        for derive in parent_scope.derives {\n-                            let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n-                            match this.resolve_macro_path(\n-                                derive,\n-                                Some(MacroKind::Derive),\n-                                parent_scope,\n-                                true,\n-                                force,\n-                            ) {\n-                                Ok((Some(ext), _)) => {\n-                                    if ext.helper_attrs.contains(&ident.name) {\n-                                        result = ok(\n-                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n-                                            derive.span,\n-                                            this.arenas,\n-                                        );\n-                                        break;\n-                                    }\n-                                }\n-                                Ok(_) | Err(Determinacy::Determined) => {}\n-                                Err(Determinacy::Undetermined) => {\n-                                    result = Err(Determinacy::Undetermined)\n-                                }\n-                            }\n-                        }\n-                        result\n-                    }\n-                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n-                        MacroRulesScope::Binding(macro_rules_binding)\n-                            if ident == macro_rules_binding.ident =>\n-                        {\n-                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n-                        }\n-                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n-                        _ => Err(Determinacy::Determined),\n-                    },\n-                    Scope::CrateRoot => {\n-                        let root_ident = Ident::new(kw::PathRoot, ident.span);\n-                        let root_module = this.resolve_crate_root(root_ident);\n-                        let binding = this.resolve_ident_in_module_ext(\n-                            ModuleOrUniformRoot::Module(root_module),\n-                            ident,\n-                            ns,\n-                            parent_scope,\n-                            finalize,\n-                        );\n-                        match binding {\n-                            Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n-                            Err((Determinacy::Undetermined, Weak::No)) => {\n-                                return Some(Err(Determinacy::determined(force)));\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n-                                Err(Determinacy::Undetermined)\n-                            }\n-                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n-                        }\n-                    }\n-                    Scope::Module(module, derive_fallback_lint_id) => {\n-                        let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n-                        let binding = this.resolve_ident_in_module_unadjusted_ext(\n-                            ModuleOrUniformRoot::Module(module),\n-                            ident,\n-                            ns,\n-                            adjusted_parent_scope,\n-                            !matches!(scope_set, ScopeSet::Late(..)),\n-                            finalize,\n-                        );\n-                        match binding {\n-                            Ok(binding) => {\n-                                if let Some(lint_id) = derive_fallback_lint_id {\n-                                    this.lint_buffer.buffer_lint_with_diagnostic(\n-                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                                        lint_id,\n-                                        orig_ident.span,\n-                                        &format!(\n-                                            \"cannot find {} `{}` in this scope\",\n-                                            ns.descr(),\n-                                            ident\n-                                        ),\n-                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n-                                            orig_ident.span,\n-                                        ),\n-                                    );\n-                                }\n-                                let misc_flags = if ptr::eq(module, this.graph_root) {\n-                                    Flags::MISC_SUGGEST_CRATE\n-                                } else if module.is_normal() {\n-                                    Flags::MISC_SUGGEST_SELF\n-                                } else {\n-                                    Flags::empty()\n-                                };\n-                                Ok((binding, Flags::MODULE | misc_flags))\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::No)) => {\n-                                return Some(Err(Determinacy::determined(force)));\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n-                                Err(Determinacy::Undetermined)\n-                            }\n-                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n-                        }\n-                    }\n-                    Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n-                        Some(ident) => ok(\n-                            Res::NonMacroAttr(NonMacroAttrKind::Registered),\n-                            ident.span,\n-                            this.arenas,\n-                        ),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                    Scope::MacroUsePrelude => {\n-                        match this.macro_use_prelude.get(&ident.name).cloned() {\n-                            Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                            )),\n-                        }\n-                    }\n-                    Scope::BuiltinAttrs => {\n-                        if is_builtin_attr_name(ident.name) {\n-                            ok(\n-                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n-                                DUMMY_SP,\n-                                this.arenas,\n-                            )\n-                        } else {\n-                            Err(Determinacy::Determined)\n-                        }\n-                    }\n-                    Scope::ExternPrelude => {\n-                        match this.extern_prelude_get(ident, finalize.is_some()) {\n-                            Some(binding) => Ok((binding, Flags::empty())),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                            )),\n-                        }\n-                    }\n-                    Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n-                        Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                    Scope::StdLibPrelude => {\n-                        let mut result = Err(Determinacy::Determined);\n-                        if let Some(prelude) = this.prelude {\n-                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n-                                ModuleOrUniformRoot::Module(prelude),\n-                                ident,\n-                                ns,\n-                                parent_scope,\n-                                None,\n-                            ) {\n-                                if use_prelude || this.is_builtin_macro(binding.res()) {\n-                                    result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n-                                }\n-                            }\n-                        }\n-                        result\n-                    }\n-                    Scope::BuiltinTypes => match PrimTy::from_name(ident.name) {\n-                        Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                };\n-\n-                match result {\n-                    Ok((binding, flags))\n-                        if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n-                    {\n-                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n-                            return Some(Ok(binding));\n-                        }\n-\n-                        if let Some((innermost_binding, innermost_flags)) = innermost_result {\n-                            // Found another solution, if the first one was \"weak\", report an error.\n-                            let (res, innermost_res) = (binding.res(), innermost_binding.res());\n-                            if res != innermost_res {\n-                                let is_builtin = |res| {\n-                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n-                                };\n-                                let derive_helper =\n-                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n-                                let derive_helper_compat =\n-                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n-\n-                                let ambiguity_error_kind = if is_import {\n-                                    Some(AmbiguityKind::Import)\n-                                } else if is_builtin(innermost_res) || is_builtin(res) {\n-                                    Some(AmbiguityKind::BuiltinAttr)\n-                                } else if innermost_res == derive_helper_compat\n-                                    || res == derive_helper_compat && innermost_res != derive_helper\n-                                {\n-                                    Some(AmbiguityKind::DeriveHelper)\n-                                } else if innermost_flags.contains(Flags::MACRO_RULES)\n-                                    && flags.contains(Flags::MODULE)\n-                                    && !this.disambiguate_macro_rules_vs_modularized(\n-                                        innermost_binding,\n-                                        binding,\n-                                    )\n-                                    || flags.contains(Flags::MACRO_RULES)\n-                                        && innermost_flags.contains(Flags::MODULE)\n-                                        && !this.disambiguate_macro_rules_vs_modularized(\n-                                            binding,\n-                                            innermost_binding,\n-                                        )\n-                                {\n-                                    Some(AmbiguityKind::MacroRulesVsModularized)\n-                                } else if innermost_binding.is_glob_import() {\n-                                    Some(AmbiguityKind::GlobVsOuter)\n-                                } else if innermost_binding\n-                                    .may_appear_after(parent_scope.expansion, binding)\n-                                {\n-                                    Some(AmbiguityKind::MoreExpandedVsOuter)\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(kind) = ambiguity_error_kind {\n-                                    let misc = |f: Flags| {\n-                                        if f.contains(Flags::MISC_SUGGEST_CRATE) {\n-                                            AmbiguityErrorMisc::SuggestCrate\n-                                        } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n-                                            AmbiguityErrorMisc::SuggestSelf\n-                                        } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n-                                            AmbiguityErrorMisc::FromPrelude\n-                                        } else {\n-                                            AmbiguityErrorMisc::None\n-                                        }\n-                                    };\n-                                    this.ambiguity_errors.push(AmbiguityError {\n-                                        kind,\n-                                        ident: orig_ident,\n-                                        b1: innermost_binding,\n-                                        b2: binding,\n-                                        misc1: misc(innermost_flags),\n-                                        misc2: misc(flags),\n-                                    });\n-                                    return Some(Ok(innermost_binding));\n-                                }\n-                            }\n-                        } else {\n-                            // Found the first solution.\n-                            innermost_result = Some((binding, flags));\n-                        }\n-                    }\n-                    Ok(..) | Err(Determinacy::Determined) => {}\n-                    Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n-                }\n-\n-                None\n-            },\n-        );\n-\n-        if let Some(break_result) = break_result {\n-            return break_result;\n-        }\n-\n-        // The first found solution was the only one, return it.\n-        if let Some((binding, _)) = innermost_result {\n-            return Ok(binding);\n-        }\n-\n-        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n-    }\n-\n     crate fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self,\n                                  path: &[Segment],\n@@ -1024,6 +674,7 @@ impl<'a> Resolver<'a> {\n                 Some(MacroNS),\n                 &parent_scope,\n                 Finalize::SimplePath(ast::CRATE_NODE_ID, path_span),\n+                None,\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n@@ -1059,6 +710,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 Some(ident.span),\n                 true,\n+                false,\n+                None,\n             ) {\n                 Ok(binding) => {\n                     let initial_res = initial_binding.map(|initial_binding| {\n@@ -1100,6 +753,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 Some(ident.span),\n                 true,\n+                false,\n+                None,\n             );\n         }\n     }"}]}