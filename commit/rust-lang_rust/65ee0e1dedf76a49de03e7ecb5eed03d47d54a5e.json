{"sha": "65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZWUwZTFkZWRmNzZhNDlkZTAzZTdlY2I1ZWVkMDNkNDdkNTRhNWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-25T19:35:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-25T19:35:29Z"}, "message": "Merge pull request #3858 from pcwalton/struct-like-typeck\n\nrustc: Typecheck, privacy check, and borrow check struct-like enum variants. r=tjc", "tree": {"sha": "bae43c245cf5ef71b82c8928023d26ca2155e713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae43c245cf5ef71b82c8928023d26ca2155e713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "html_url": "https://github.com/rust-lang/rust/commit/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75947b311ae79c2a2113fb7f797c68ffb3d357b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75947b311ae79c2a2113fb7f797c68ffb3d357b3", "html_url": "https://github.com/rust-lang/rust/commit/75947b311ae79c2a2113fb7f797c68ffb3d357b3"}, {"sha": "588ea599927d62a04c12ccca87196ca415b86274", "url": "https://api.github.com/repos/rust-lang/rust/commits/588ea599927d62a04c12ccca87196ca415b86274", "html_url": "https://github.com/rust-lang/rust/commit/588ea599927d62a04c12ccca87196ca415b86274"}], "stats": {"total": 274, "additions": 197, "deletions": 77}, "files": [{"sha": "8ee9adc4e2f3b7aca97c0ba708a3759319a04997", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "patch": "@@ -464,7 +464,7 @@ impl &mem_categorization_ctxt {\n             }\n \n             let base_cmt = self.cat_expr(base);\n-            self.cat_field(expr, base_cmt, f_name)\n+            self.cat_field(expr, base_cmt, f_name, expr.id)\n           }\n \n           ast::expr_index(base, _) => {\n@@ -632,9 +632,14 @@ impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n-                             f_name: ast::ident) -> cmt {\n-        let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty, f_name) {\n+    /// The `field_id` parameter is the ID of the enclosing expression or\n+    /// pattern. It is used to determine which variant of an enum is in use.\n+    fn cat_field<N:ast_node>(node: N,\n+                             base_cmt: cmt,\n+                             f_name: ast::ident,\n+                             field_id: ast::node_id) -> cmt {\n+        let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty, f_name,\n+                                        field_id) {\n           Some(f_mutbl) => f_mutbl,\n           None => {\n             self.tcx.sess.span_bug(\n@@ -851,15 +856,15 @@ impl &mem_categorization_ctxt {\n           ast::pat_rec(field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n-                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident);\n+                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident, pat.id);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n             }\n           }\n \n           ast::pat_struct(_, field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n-                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident);\n+                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident, pat.id);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n             }\n           }\n@@ -998,9 +1003,13 @@ impl &mem_categorization_ctxt {\n     }\n }\n \n+/// The node_id here is the node of the expression that references the field.\n+/// This function looks it up in the def map in case the type happens to be\n+/// an enum to determine which variant is in use.\n fn field_mutbl(tcx: ty::ctxt,\n                base_ty: ty::t,\n-               f_name: ast::ident) -> Option<ast::mutability> {\n+               f_name: ast::ident,\n+               node_id: ast::node_id) -> Option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n     match ty::get(base_ty).sty {\n       ty::ty_rec(fields) => {\n@@ -1021,6 +1030,22 @@ fn field_mutbl(tcx: ty::ctxt,\n             }\n         }\n       }\n+      ty::ty_enum(*) => {\n+        match tcx.def_map.get(node_id) {\n+          ast::def_variant(_, variant_id) => {\n+            for ty::lookup_class_fields(tcx, variant_id).each |fld| {\n+                if fld.ident == f_name {\n+                    let m = match fld.mutability {\n+                      ast::class_mutable => ast::m_mutbl,\n+                      ast::class_immutable => ast::m_imm\n+                    };\n+                    return Some(m);\n+                }\n+            }\n+          }\n+          _ => {}\n+        }\n+      }\n       _ => { }\n     }\n "}, {"sha": "dfdd3541169127841dc070e1214c126573c3a132", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "patch": "@@ -239,6 +239,31 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                                 }\n                             }\n                         }\n+                        ty_enum(enum_id, _) => {\n+                            if enum_id.crate != local_crate ||\n+                                    !privileged_items.contains(\n+                                        &enum_id.node) {\n+                                match tcx.def_map.find(pattern.id) {\n+                                    Some(def_variant(_, variant_id)) => {\n+                                        for fields.each |field| {\n+                                            debug!(\"(privacy checking) \\\n+                                                    checking field in \\\n+                                                    struct variant pattern\");\n+                                            check_field(pattern.span,\n+                                                        variant_id,\n+                                                        field.ident);\n+                                        }\n+                                    }\n+                                    _ => {\n+                                        tcx.sess.span_bug(pattern.span,\n+                                                          ~\"resolve didn't \\\n+                                                            map enum struct \\\n+                                                            pattern to a \\\n+                                                            variant def\");\n+                                    }\n+                                }\n+                            }\n+                        }\n                         _ => {\n                             tcx.sess.span_bug(pattern.span,\n                                               ~\"struct pattern didn't have \\"}, {"sha": "a8308bb1b3c241495908e482e7b703009e69a4ee", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 140, "deletions": 70, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "patch": "@@ -186,6 +186,139 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n     }\n }\n \n+/// `path` is the AST path item naming the type of this struct.\n+/// `fields` is the field patterns of the struct pattern.\n+/// `class_fields` describes the type of each field of the struct.\n+/// `class_id` is the ID of the struct.\n+/// `substitutions` are the type substitutions applied to this struct type\n+/// (e.g. K,V in HashMap<K,V>).\n+/// `etc` is true if the pattern said '...' and false otherwise.\n+fn check_struct_pat_fields(pcx: pat_ctxt,\n+                           span: span,\n+                           path: @ast::path,\n+                           fields: ~[ast::field_pat],\n+                           class_fields: ~[ty::field_ty],\n+                           class_id: ast::def_id,\n+                           substitutions: &ty::substs,\n+                           etc: bool) {\n+    let tcx = pcx.fcx.ccx.tcx;\n+\n+    // Index the class fields.\n+    let field_map = std::map::HashMap();\n+    for class_fields.eachi |i, class_field| {\n+        field_map.insert(class_field.ident, i);\n+    }\n+\n+    // Typecheck each field.\n+    let found_fields = std::map::HashMap();\n+    for fields.each |field| {\n+        match field_map.find(field.ident) {\n+            Some(index) => {\n+                let class_field = class_fields[index];\n+                let field_type = ty::lookup_field_type(tcx,\n+                                                       class_id,\n+                                                       class_field.id,\n+                                                       substitutions);\n+                check_pat(pcx, field.pat, field_type);\n+                found_fields.insert(index, ());\n+            }\n+            None => {\n+                let name = pprust::path_to_str(path, tcx.sess.intr());\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"struct `%s` does not have a field\n+                                        named `%s`\", name,\n+                                       tcx.sess.str_of(field.ident)));\n+            }\n+        }\n+    }\n+\n+    // Report an error if not all the fields were specified.\n+    if !etc {\n+        for class_fields.eachi |i, field| {\n+            if found_fields.contains_key(i) {\n+                loop;\n+            }\n+            tcx.sess.span_err(span,\n+                              fmt!(\"pattern does not mention field `%s`\",\n+                                   tcx.sess.str_of(field.ident)));\n+        }\n+    }\n+}\n+\n+fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n+                    expected: ty::t, path: @ast::path,\n+                    fields: ~[ast::field_pat], etc: bool,\n+                    class_id: ast::def_id, substitutions: &ty::substs) {\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+\n+    let class_fields = ty::lookup_class_fields(tcx, class_id);\n+\n+    // Check to ensure that the struct is the one specified.\n+    match tcx.def_map.find(pat_id) {\n+        Some(ast::def_class(supplied_def_id))\n+                if supplied_def_id == class_id => {\n+            // OK.\n+        }\n+        Some(ast::def_class(*)) | Some(ast::def_variant(*)) => {\n+            let name = pprust::path_to_str(path, tcx.sess.intr());\n+            tcx.sess.span_err(span,\n+                              fmt!(\"mismatched types: expected `%s` but \\\n+                                    found `%s`\",\n+                                   fcx.infcx().ty_to_str(expected),\n+                                   name));\n+        }\n+        _ => {\n+            tcx.sess.span_bug(span, ~\"resolve didn't write in class\");\n+        }\n+    }\n+\n+    // Forbid pattern-matching structs with destructors.\n+    if ty::has_dtor(tcx, class_id) {\n+        tcx.sess.span_err(span, ~\"deconstructing struct not allowed in \\\n+                                  pattern (it has a destructor)\");\n+    }\n+\n+    check_struct_pat_fields(pcx, span, path, fields, class_fields, class_id,\n+                            substitutions, etc);\n+}\n+\n+fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n+                                      pat_id: ast::node_id,\n+                                      span: span,\n+                                      expected: ty::t,\n+                                      path: @ast::path,\n+                                      fields: ~[ast::field_pat],\n+                                      etc: bool,\n+                                      enum_id: ast::def_id,\n+                                      substitutions: &ty::substs) {\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+\n+    // Find the variant that was specified.\n+    match tcx.def_map.find(pat_id) {\n+        Some(ast::def_variant(found_enum_id, variant_id))\n+                if found_enum_id == enum_id => {\n+            // Get the struct fields from this struct-like enum variant.\n+            let class_fields = ty::lookup_class_fields(tcx, variant_id);\n+\n+            check_struct_pat_fields(pcx, span, path, fields, class_fields,\n+                                    variant_id, substitutions, etc);\n+        }\n+        Some(ast::def_class(*)) | Some(ast::def_variant(*)) => {\n+            let name = pprust::path_to_str(path, tcx.sess.intr());\n+            tcx.sess.span_err(span,\n+                              fmt!(\"mismatched types: expected `%s` but \\\n+                                    found `%s`\",\n+                                   fcx.infcx().ty_to_str(expected),\n+                                   name));\n+        }\n+        _ => {\n+            tcx.sess.span_bug(span, ~\"resolve didn't write in variant\");\n+        }\n+    }\n+}\n+\n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n@@ -306,13 +439,16 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_struct(path, fields, etc) => {\n         // Grab the class data that we care about.\n-        let class_fields, class_id, substitutions;\n         let structure = structure_of(fcx, pat.span, expected);\n         match structure {\n             ty::ty_class(cid, ref substs) => {\n-                class_id = cid;\n-                substitutions = substs;\n-                class_fields = ty::lookup_class_fields(tcx, class_id);\n+                check_struct_pat(pcx, pat.id, pat.span, expected, path,\n+                                 fields, etc, cid, substs);\n+            }\n+            ty::ty_enum(eid, ref substs) => {\n+                check_struct_like_enum_variant_pat(\n+                    pcx, pat.id, pat.span, expected, path, fields, etc, eid,\n+                    substs);\n             }\n             _ => {\n                 // XXX: This should not be fatal.\n@@ -323,72 +459,6 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n         }\n \n-        // Check to ensure that the struct is the one specified.\n-        match tcx.def_map.get(pat.id) {\n-            ast::def_class(supplied_def_id)\n-                    if supplied_def_id == class_id => {\n-                // OK.\n-            }\n-            ast::def_class(*) => {\n-                let name = pprust::path_to_str(path, tcx.sess.intr());\n-                tcx.sess.span_err(pat.span,\n-                                  fmt!(\"mismatched types: expected `%s` but \\\n-                                        found `%s`\",\n-                                       fcx.infcx().ty_to_str(expected),\n-                                       name));\n-            }\n-            _ => {\n-                tcx.sess.span_bug(pat.span, ~\"resolve didn't write in class\");\n-            }\n-        }\n-\n-        // Forbid pattern-matching structs with destructors.\n-        if ty::has_dtor(tcx, class_id) {\n-            tcx.sess.span_err(pat.span, ~\"deconstructing struct not allowed \\\n-                                          in pattern (it has a destructor)\");\n-        }\n-\n-        // Index the class fields.\n-        let field_map = std::map::HashMap();\n-        for class_fields.eachi |i, class_field| {\n-            field_map.insert(class_field.ident, i);\n-        }\n-\n-        // Typecheck each field.\n-        let found_fields = std::map::HashMap();\n-        for fields.each |field| {\n-            match field_map.find(field.ident) {\n-                Some(index) => {\n-                    let class_field = class_fields[index];\n-                    let field_type = ty::lookup_field_type(tcx,\n-                                                           class_id,\n-                                                           class_field.id,\n-                                                           substitutions);\n-                    check_pat(pcx, field.pat, field_type);\n-                    found_fields.insert(index, ());\n-                }\n-                None => {\n-                    let name = pprust::path_to_str(path, tcx.sess.intr());\n-                    tcx.sess.span_err(pat.span,\n-                                      fmt!(\"struct `%s` does not have a field\n-                                            named `%s`\", name,\n-                                           tcx.sess.str_of(field.ident)));\n-                }\n-            }\n-        }\n-\n-        // Report an error if not all the fields were specified.\n-        if !etc {\n-            for class_fields.eachi |i, field| {\n-                if found_fields.contains_key(i) {\n-                    loop;\n-                }\n-                tcx.sess.span_err(pat.span,\n-                                  fmt!(\"pattern does not mention field `%s`\",\n-                                       tcx.sess.str_of(field.ident)));\n-            }\n-        }\n-\n         // Finally, write in the type.\n         fcx.write_ty(pat.id, expected);\n       }"}]}