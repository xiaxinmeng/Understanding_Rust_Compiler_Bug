{"sha": "64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YTZlZTQ1MzUxYTcxY2RlYjFkMWRkZGM4ZmM3NDZhYmRjZmYwN2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-09T11:44:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-09T11:44:01Z"}, "message": "Shorten frequent names", "tree": {"sha": "1bcbd575286076950bf71719f8944e2d4322f939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bcbd575286076950bf71719f8944e2d4322f939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "html_url": "https://github.com/rust-lang/rust/commit/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fb52af521ab8ca2fdd3ea7cfa95eaebd0cba1fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb52af521ab8ca2fdd3ea7cfa95eaebd0cba1fc", "html_url": "https://github.com/rust-lang/rust/commit/6fb52af521ab8ca2fdd3ea7cfa95eaebd0cba1fc"}], "stats": {"total": 468, "additions": 222, "deletions": 246}, "files": [{"sha": "674c72c23e4050db570e49290cdb30ac23bbc708", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -76,7 +76,7 @@ pub use crate::{\n     references::{rename::RenameError, Declaration, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n     syntax_highlighting::{\n-        tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag},\n+        tags::{Highlight, HlMod, HlMods, HlTag},\n         HighlightedRange,\n     },\n };"}, {"sha": "d73ddf35b2056f5b126e2eb4c87c62aa6af9b30f", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 110, "deletions": 129, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -26,7 +26,7 @@ use crate::{\n     syntax_highlighting::{\n         format::FormatStringHighlighter, macro_rules::MacroRulesHighlighter, tags::Highlight,\n     },\n-    FileId, HighlightModifier, HighlightTag, SymbolKind,\n+    FileId, HlMod, HlTag, SymbolKind,\n };\n \n pub(crate) use html::highlight_as_html;\n@@ -98,7 +98,7 @@ pub(crate) fn highlight(\n                 if let Some(range) = macro_call_range(&mc) {\n                     stack.add(HighlightedRange {\n                         range,\n-                        highlight: HighlightTag::Symbol(SymbolKind::Macro).into(),\n+                        highlight: HlTag::Symbol(SymbolKind::Macro).into(),\n                         binding_hash: None,\n                     });\n                 }\n@@ -192,7 +192,7 @@ pub(crate) fn highlight(\n             element_to_highlight.clone(),\n         ) {\n             if inside_attribute {\n-                highlight = highlight | HighlightModifier::Attribute;\n+                highlight = highlight | HlMod::Attribute;\n             }\n \n             if macro_rules_highlighter.highlight(element_to_highlight.clone()).is_none() {\n@@ -209,7 +209,7 @@ pub(crate) fn highlight(\n                         if string.text()[piece_range.start().into()..].starts_with('\\\\') {\n                             stack.add(HighlightedRange {\n                                 range: piece_range + range.start(),\n-                                highlight: HighlightTag::EscapeSequence.into(),\n+                                highlight: HlTag::EscapeSequence.into(),\n                                 binding_hash: None,\n                             });\n                         }\n@@ -292,39 +292,35 @@ fn highlight_element(\n             };\n \n             match name_kind {\n-                Some(NameClass::ExternCrate(_)) => HighlightTag::Symbol(SymbolKind::Module).into(),\n-                Some(NameClass::Definition(def)) => {\n-                    highlight_def(db, def) | HighlightModifier::Definition\n-                }\n+                Some(NameClass::ExternCrate(_)) => HlTag::Symbol(SymbolKind::Module).into(),\n+                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n                 Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n                 Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n-                    let mut h = HighlightTag::Symbol(SymbolKind::Field).into();\n+                    let mut h = HlTag::Symbol(SymbolKind::Field).into();\n                     if let Definition::Field(field) = field_ref {\n                         if let VariantDef::Union(_) = field.parent_def(db) {\n-                            h |= HighlightModifier::Unsafe;\n+                            h |= HlMod::Unsafe;\n                         }\n                     }\n \n                     h\n                 }\n-                None => highlight_name_by_syntax(name) | HighlightModifier::Definition,\n+                None => highlight_name_by_syntax(name) | HlMod::Definition,\n             }\n         }\n \n         // Highlight references like the definitions they resolve to\n         NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n             // even though we track whether we are in an attribute or not we still need this special case\n             // as otherwise we would emit unresolved references for name refs inside attributes\n-            Highlight::from(HighlightTag::Symbol(SymbolKind::Function))\n+            Highlight::from(HlTag::Symbol(SymbolKind::Function))\n         }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n                 match NameRefClass::classify(sema, &name_ref) {\n                     Some(name_kind) => match name_kind {\n-                        NameRefClass::ExternCrate(_) => {\n-                            HighlightTag::Symbol(SymbolKind::Module).into()\n-                        }\n+                        NameRefClass::ExternCrate(_) => HlTag::Symbol(SymbolKind::Module).into(),\n                         NameRefClass::Definition(def) => {\n                             if let Definition::Local(local) = &def {\n                                 if let Some(name) = local.name(db) {\n@@ -338,15 +334,15 @@ fn highlight_element(\n \n                             if let Definition::Local(local) = &def {\n                                 if is_consumed_lvalue(name_ref.syntax().clone().into(), local, db) {\n-                                    h |= HighlightModifier::Consuming;\n+                                    h |= HlMod::Consuming;\n                                 }\n                             }\n \n                             if let Some(parent) = name_ref.syntax().parent() {\n                                 if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n                                     if let Definition::Field(field) = def {\n                                         if let VariantDef::Union(_) = field.parent_def(db) {\n-                                            h |= HighlightModifier::Unsafe;\n+                                            h |= HlMod::Unsafe;\n                                         }\n                                     }\n                                 }\n@@ -355,121 +351,106 @@ fn highlight_element(\n                             h\n                         }\n                         NameRefClass::FieldShorthand { .. } => {\n-                            HighlightTag::Symbol(SymbolKind::Field).into()\n+                            HlTag::Symbol(SymbolKind::Field).into()\n                         }\n                     },\n                     None if syntactic_name_ref_highlighting => {\n                         highlight_name_ref_by_syntax(name_ref, sema)\n                     }\n-                    None => HighlightTag::UnresolvedReference.into(),\n+                    None => HlTag::UnresolvedReference.into(),\n                 }\n             })\n         }\n \n         // Simple token-based highlighting\n         COMMENT => {\n             let comment = element.into_token().and_then(ast::Comment::cast)?;\n-            let h = HighlightTag::Comment;\n+            let h = HlTag::Comment;\n             match comment.kind().doc {\n-                Some(_) => h | HighlightModifier::Documentation,\n+                Some(_) => h | HlMod::Documentation,\n                 None => h.into(),\n             }\n         }\n-        STRING | BYTE_STRING => HighlightTag::StringLiteral.into(),\n-        ATTR => HighlightTag::Attribute.into(),\n-        INT_NUMBER | FLOAT_NUMBER => HighlightTag::NumericLiteral.into(),\n-        BYTE => HighlightTag::ByteLiteral.into(),\n-        CHAR => HighlightTag::CharLiteral.into(),\n-        QUESTION => Highlight::new(HighlightTag::Operator) | HighlightModifier::ControlFlow,\n+        STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n+        ATTR => HlTag::Attribute.into(),\n+        INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n+        BYTE => HlTag::ByteLiteral.into(),\n+        CHAR => HlTag::CharLiteral.into(),\n+        QUESTION => Highlight::new(HlTag::Operator) | HlMod::ControlFlow,\n         LIFETIME => {\n             let lifetime = element.into_node().and_then(ast::Lifetime::cast).unwrap();\n \n             match NameClass::classify_lifetime(sema, &lifetime) {\n-                Some(NameClass::Definition(def)) => {\n-                    highlight_def(db, def) | HighlightModifier::Definition\n-                }\n+                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n                 None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n                     Some(NameRefClass::Definition(def)) => highlight_def(db, def),\n-                    _ => Highlight::new(HighlightTag::Symbol(SymbolKind::LifetimeParam)),\n+                    _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)),\n                 },\n-                _ => {\n-                    Highlight::new(HighlightTag::Symbol(SymbolKind::LifetimeParam))\n-                        | HighlightModifier::Definition\n-                }\n+                _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)) | HlMod::Definition,\n             }\n         }\n         p if p.is_punct() => match p {\n             T![&] => {\n-                let h = HighlightTag::Operator.into();\n+                let h = HlTag::Operator.into();\n                 let is_unsafe = element\n                     .parent()\n                     .and_then(ast::RefExpr::cast)\n                     .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n                     .unwrap_or(false);\n                 if is_unsafe {\n-                    h | HighlightModifier::Unsafe\n+                    h | HlMod::Unsafe\n                 } else {\n                     h\n                 }\n             }\n-            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => {\n-                HighlightTag::Operator.into()\n-            }\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => HlTag::Operator.into(),\n             T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n-                HighlightTag::Symbol(SymbolKind::Macro).into()\n+                HlTag::Symbol(SymbolKind::Macro).into()\n             }\n             T![!] if element.parent().and_then(ast::NeverType::cast).is_some() => {\n-                HighlightTag::BuiltinType.into()\n+                HlTag::BuiltinType.into()\n             }\n             T![*] if element.parent().and_then(ast::PtrType::cast).is_some() => {\n-                HighlightTag::Keyword.into()\n+                HlTag::Keyword.into()\n             }\n             T![*] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n                 let ty = sema.type_of_expr(&expr)?;\n                 if ty.is_raw_ptr() {\n-                    HighlightTag::Operator | HighlightModifier::Unsafe\n+                    HlTag::Operator | HlMod::Unsafe\n                 } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n-                    HighlightTag::Operator.into()\n+                    HlTag::Operator.into()\n                 } else {\n-                    HighlightTag::Punctuation.into()\n+                    HlTag::Punctuation.into()\n                 }\n             }\n             T![-] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n                 match expr {\n-                    ast::Expr::Literal(_) => HighlightTag::NumericLiteral,\n-                    _ => HighlightTag::Operator,\n+                    ast::Expr::Literal(_) => HlTag::NumericLiteral,\n+                    _ => HlTag::Operator,\n                 }\n                 .into()\n             }\n             _ if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => {\n-                HighlightTag::Operator.into()\n+                HlTag::Operator.into()\n             }\n+            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => HlTag::Operator.into(),\n             _ if element.parent().and_then(ast::RangeExpr::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::RangePat::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::RestPat::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::Attr::cast).is_some() => {\n-                HighlightTag::Attribute.into()\n+                HlTag::Operator.into()\n             }\n-            _ => HighlightTag::Punctuation.into(),\n+            _ if element.parent().and_then(ast::RangePat::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::RestPat::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::Attr::cast).is_some() => HlTag::Attribute.into(),\n+            _ => HlTag::Punctuation.into(),\n         },\n \n         k if k.is_keyword() => {\n-            let h = Highlight::new(HighlightTag::Keyword);\n+            let h = Highlight::new(HlTag::Keyword);\n             match k {\n                 T![break]\n                 | T![continue]\n@@ -479,10 +460,10 @@ fn highlight_element(\n                 | T![match]\n                 | T![return]\n                 | T![while]\n-                | T![in] => h | HighlightModifier::ControlFlow,\n-                T![for] if !is_child_of_impl(&element) => h | HighlightModifier::ControlFlow,\n-                T![unsafe] => h | HighlightModifier::Unsafe,\n-                T![true] | T![false] => HighlightTag::BoolLiteral.into(),\n+                | T![in] => h | HlMod::ControlFlow,\n+                T![for] if !is_child_of_impl(&element) => h | HlMod::ControlFlow,\n+                T![unsafe] => h | HlMod::Unsafe,\n+                T![true] | T![false] => HlTag::BoolLiteral.into(),\n                 T![self] => {\n                     let self_param_is_mut = element\n                         .parent()\n@@ -495,20 +476,20 @@ fn highlight_element(\n                         .and_then(SyntaxNode::parent)\n                         .and_then(ast::Path::cast)\n                         .and_then(|p| sema.resolve_path(&p));\n-                    let mut h = HighlightTag::Symbol(SymbolKind::SelfParam).into();\n+                    let mut h = HlTag::Symbol(SymbolKind::SelfParam).into();\n                     if self_param_is_mut\n                         || matches!(self_path,\n                             Some(hir::PathResolution::Local(local))\n                                 if local.is_self(db)\n                                     && (local.is_mut(db) || local.ty(db).is_mutable_reference())\n                         )\n                     {\n-                        h |= HighlightModifier::Mutable\n+                        h |= HlMod::Mutable\n                     }\n \n                     if let Some(hir::PathResolution::Local(local)) = self_path {\n                         if is_consumed_lvalue(element, &local, db) {\n-                            h |= HighlightModifier::Consuming;\n+                            h |= HlMod::Consuming;\n                         }\n                     }\n \n@@ -519,7 +500,7 @@ fn highlight_element(\n                     .and_then(ast::IdentPat::cast)\n                     .and_then(|ident_pat| {\n                         if sema.is_unsafe_ident_pat(&ident_pat) {\n-                            Some(HighlightModifier::Unsafe)\n+                            Some(HlMod::Unsafe)\n                         } else {\n                             None\n                         }\n@@ -568,21 +549,21 @@ fn highlight_method_call(\n     method_call: &ast::MethodCallExpr,\n ) -> Option<Highlight> {\n     let func = sema.resolve_method_call(&method_call)?;\n-    let mut h = HighlightTag::Symbol(SymbolKind::Function).into();\n-    h |= HighlightModifier::Associated;\n+    let mut h = HlTag::Symbol(SymbolKind::Function).into();\n+    h |= HlMod::Associated;\n     if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n-        h |= HighlightModifier::Unsafe;\n+        h |= HlMod::Unsafe;\n     }\n     if let Some(self_param) = func.self_param(sema.db) {\n         match self_param.access(sema.db) {\n             hir::Access::Shared => (),\n-            hir::Access::Exclusive => h |= HighlightModifier::Mutable,\n+            hir::Access::Exclusive => h |= HlMod::Mutable,\n             hir::Access::Owned => {\n                 if let Some(receiver_ty) =\n                     method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n                 {\n                     if !receiver_ty.is_copy(sema.db) {\n-                        h |= HighlightModifier::Consuming\n+                        h |= HlMod::Consuming\n                     }\n                 }\n             }\n@@ -593,106 +574,106 @@ fn highlight_method_call(\n \n fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n     match def {\n-        Definition::Macro(_) => HighlightTag::Symbol(SymbolKind::Macro),\n-        Definition::Field(_) => HighlightTag::Symbol(SymbolKind::Field),\n+        Definition::Macro(_) => HlTag::Symbol(SymbolKind::Macro),\n+        Definition::Field(_) => HlTag::Symbol(SymbolKind::Field),\n         Definition::ModuleDef(def) => match def {\n-            hir::ModuleDef::Module(_) => HighlightTag::Symbol(SymbolKind::Module),\n+            hir::ModuleDef::Module(_) => HlTag::Symbol(SymbolKind::Module),\n             hir::ModuleDef::Function(func) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::Function));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Function));\n                 if func.as_assoc_item(db).is_some() {\n-                    h |= HighlightModifier::Associated;\n+                    h |= HlMod::Associated;\n                     if func.self_param(db).is_none() {\n-                        h |= HighlightModifier::Static\n+                        h |= HlMod::Static\n                     }\n                 }\n                 if func.is_unsafe(db) {\n-                    h |= HighlightModifier::Unsafe;\n+                    h |= HlMod::Unsafe;\n                 }\n                 return h;\n             }\n-            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Symbol(SymbolKind::Struct),\n-            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HighlightTag::Symbol(SymbolKind::Enum),\n-            hir::ModuleDef::Adt(hir::Adt::Union(_)) => HighlightTag::Symbol(SymbolKind::Union),\n-            hir::ModuleDef::Variant(_) => HighlightTag::Symbol(SymbolKind::Variant),\n+            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HlTag::Symbol(SymbolKind::Struct),\n+            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HlTag::Symbol(SymbolKind::Enum),\n+            hir::ModuleDef::Adt(hir::Adt::Union(_)) => HlTag::Symbol(SymbolKind::Union),\n+            hir::ModuleDef::Variant(_) => HlTag::Symbol(SymbolKind::Variant),\n             hir::ModuleDef::Const(konst) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::Const));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Const));\n                 if konst.as_assoc_item(db).is_some() {\n-                    h |= HighlightModifier::Associated\n+                    h |= HlMod::Associated\n                 }\n                 return h;\n             }\n-            hir::ModuleDef::Trait(_) => HighlightTag::Symbol(SymbolKind::Trait),\n+            hir::ModuleDef::Trait(_) => HlTag::Symbol(SymbolKind::Trait),\n             hir::ModuleDef::TypeAlias(type_) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::TypeAlias));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n                 if type_.as_assoc_item(db).is_some() {\n-                    h |= HighlightModifier::Associated\n+                    h |= HlMod::Associated\n                 }\n                 return h;\n             }\n-            hir::ModuleDef::BuiltinType(_) => HighlightTag::BuiltinType,\n+            hir::ModuleDef::BuiltinType(_) => HlTag::BuiltinType,\n             hir::ModuleDef::Static(s) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::Static));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Static));\n                 if s.is_mut(db) {\n-                    h |= HighlightModifier::Mutable;\n-                    h |= HighlightModifier::Unsafe;\n+                    h |= HlMod::Mutable;\n+                    h |= HlMod::Unsafe;\n                 }\n                 return h;\n             }\n         },\n-        Definition::SelfType(_) => HighlightTag::Symbol(SymbolKind::Impl),\n-        Definition::TypeParam(_) => HighlightTag::Symbol(SymbolKind::TypeParam),\n-        Definition::ConstParam(_) => HighlightTag::Symbol(SymbolKind::ConstParam),\n+        Definition::SelfType(_) => HlTag::Symbol(SymbolKind::Impl),\n+        Definition::TypeParam(_) => HlTag::Symbol(SymbolKind::TypeParam),\n+        Definition::ConstParam(_) => HlTag::Symbol(SymbolKind::ConstParam),\n         Definition::Local(local) => {\n             let tag = if local.is_param(db) {\n-                HighlightTag::Symbol(SymbolKind::ValueParam)\n+                HlTag::Symbol(SymbolKind::ValueParam)\n             } else {\n-                HighlightTag::Symbol(SymbolKind::Local)\n+                HlTag::Symbol(SymbolKind::Local)\n             };\n             let mut h = Highlight::new(tag);\n             if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n-                h |= HighlightModifier::Mutable;\n+                h |= HlMod::Mutable;\n             }\n             if local.ty(db).as_callable(db).is_some() || local.ty(db).impls_fnonce(db) {\n-                h |= HighlightModifier::Callable;\n+                h |= HlMod::Callable;\n             }\n             return h;\n         }\n-        Definition::LifetimeParam(_) => HighlightTag::Symbol(SymbolKind::LifetimeParam),\n-        Definition::Label(_) => HighlightTag::Symbol(SymbolKind::Label),\n+        Definition::LifetimeParam(_) => HlTag::Symbol(SymbolKind::LifetimeParam),\n+        Definition::Label(_) => HlTag::Symbol(SymbolKind::Label),\n     }\n     .into()\n }\n \n fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n-    let default = HighlightTag::UnresolvedReference;\n+    let default = HlTag::UnresolvedReference;\n \n     let parent = match name.syntax().parent() {\n         Some(it) => it,\n         _ => return default.into(),\n     };\n \n     let tag = match parent.kind() {\n-        STRUCT => HighlightTag::Symbol(SymbolKind::Struct),\n-        ENUM => HighlightTag::Symbol(SymbolKind::Enum),\n-        VARIANT => HighlightTag::Symbol(SymbolKind::Variant),\n-        UNION => HighlightTag::Symbol(SymbolKind::Union),\n-        TRAIT => HighlightTag::Symbol(SymbolKind::Trait),\n-        TYPE_ALIAS => HighlightTag::Symbol(SymbolKind::TypeAlias),\n-        TYPE_PARAM => HighlightTag::Symbol(SymbolKind::TypeParam),\n-        RECORD_FIELD => HighlightTag::Symbol(SymbolKind::Field),\n-        MODULE => HighlightTag::Symbol(SymbolKind::Module),\n-        FN => HighlightTag::Symbol(SymbolKind::Function),\n-        CONST => HighlightTag::Symbol(SymbolKind::Const),\n-        STATIC => HighlightTag::Symbol(SymbolKind::Static),\n-        IDENT_PAT => HighlightTag::Symbol(SymbolKind::Local),\n+        STRUCT => HlTag::Symbol(SymbolKind::Struct),\n+        ENUM => HlTag::Symbol(SymbolKind::Enum),\n+        VARIANT => HlTag::Symbol(SymbolKind::Variant),\n+        UNION => HlTag::Symbol(SymbolKind::Union),\n+        TRAIT => HlTag::Symbol(SymbolKind::Trait),\n+        TYPE_ALIAS => HlTag::Symbol(SymbolKind::TypeAlias),\n+        TYPE_PARAM => HlTag::Symbol(SymbolKind::TypeParam),\n+        RECORD_FIELD => HlTag::Symbol(SymbolKind::Field),\n+        MODULE => HlTag::Symbol(SymbolKind::Module),\n+        FN => HlTag::Symbol(SymbolKind::Function),\n+        CONST => HlTag::Symbol(SymbolKind::Const),\n+        STATIC => HlTag::Symbol(SymbolKind::Static),\n+        IDENT_PAT => HlTag::Symbol(SymbolKind::Local),\n         _ => default,\n     };\n \n     tag.into()\n }\n \n fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabase>) -> Highlight {\n-    let default = HighlightTag::UnresolvedReference;\n+    let default = HlTag::UnresolvedReference;\n \n     let parent = match name.syntax().parent() {\n         Some(it) => it,\n@@ -703,10 +684,10 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         METHOD_CALL_EXPR => {\n             return ast::MethodCallExpr::cast(parent)\n                 .and_then(|method_call| highlight_method_call(sema, &method_call))\n-                .unwrap_or_else(|| HighlightTag::Symbol(SymbolKind::Function).into());\n+                .unwrap_or_else(|| HlTag::Symbol(SymbolKind::Function).into());\n         }\n         FIELD_EXPR => {\n-            let h = HighlightTag::Symbol(SymbolKind::Field);\n+            let h = HlTag::Symbol(SymbolKind::Field);\n             let is_union = ast::FieldExpr::cast(parent)\n                 .and_then(|field_expr| {\n                     let field = sema.resolve_field(&field_expr)?;\n@@ -718,7 +699,7 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                 })\n                 .unwrap_or(false);\n             if is_union {\n-                h | HighlightModifier::Unsafe\n+                h | HlMod::Unsafe\n             } else {\n                 h.into()\n             }\n@@ -733,9 +714,9 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                 _ => {\n                     // within path, decide whether it is module or adt by checking for uppercase name\n                     return if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HighlightTag::Symbol(SymbolKind::Struct)\n+                        HlTag::Symbol(SymbolKind::Struct)\n                     } else {\n-                        HighlightTag::Symbol(SymbolKind::Module)\n+                        HlTag::Symbol(SymbolKind::Module)\n                     }\n                     .into();\n                 }\n@@ -746,11 +727,11 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n             };\n \n             match parent.kind() {\n-                CALL_EXPR => HighlightTag::Symbol(SymbolKind::Function).into(),\n+                CALL_EXPR => HlTag::Symbol(SymbolKind::Function).into(),\n                 _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                    HighlightTag::Symbol(SymbolKind::Struct)\n+                    HlTag::Symbol(SymbolKind::Struct)\n                 } else {\n-                    HighlightTag::Symbol(SymbolKind::Const)\n+                    HlTag::Symbol(SymbolKind::Const)\n                 }\n                 .into(),\n             }"}, {"sha": "94cecd97f5c6202720081733f6cd49da9f0485f2", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -4,7 +4,7 @@ use syntax::{\n     AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n \n-use crate::{HighlightTag, HighlightedRange, SymbolKind};\n+use crate::{HighlightedRange, HlTag, SymbolKind};\n \n use super::highlights::Highlights;\n \n@@ -57,7 +57,7 @@ impl FormatStringHighlighter {\n     }\n }\n \n-fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n+fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HlTag> {\n     Some(match kind {\n         FormatSpecifier::Open\n         | FormatSpecifier::Close\n@@ -69,8 +69,8 @@ fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n         | FormatSpecifier::DollarSign\n         | FormatSpecifier::Dot\n         | FormatSpecifier::Asterisk\n-        | FormatSpecifier::QuestionMark => HighlightTag::FormatSpecifier,\n-        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n-        FormatSpecifier::Identifier => HighlightTag::Symbol(SymbolKind::Local),\n+        | FormatSpecifier::QuestionMark => HlTag::FormatSpecifier,\n+        FormatSpecifier::Integer | FormatSpecifier::Zero => HlTag::NumericLiteral,\n+        FormatSpecifier::Identifier => HlTag::Symbol(SymbolKind::Local),\n     })\n }"}, {"sha": "f52076509a98e392583a70ea1d58299727850ae6", "filename": "crates/ide/src/syntax_highlighting/highlights.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -4,7 +4,7 @@ use std::{cmp::Ordering, iter};\n use stdx::equal_range_by;\n use syntax::TextRange;\n \n-use crate::{HighlightTag, HighlightedRange};\n+use crate::{HighlightedRange, HlTag};\n \n pub(super) struct Highlights {\n     root: Node,\n@@ -20,7 +20,7 @@ impl Highlights {\n         Highlights {\n             root: Node::new(HighlightedRange {\n                 range,\n-                highlight: HighlightTag::None.into(),\n+                highlight: HlTag::None.into(),\n                 binding_hash: None,\n             }),\n         }"}, {"sha": "a6941234e343553992a1c124e82c0dba0633636b", "filename": "crates/ide/src/syntax_highlighting/injection.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -7,7 +7,7 @@ use ide_db::call_info::ActiveParameter;\n use itertools::Itertools;\n use syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n \n-use crate::{Analysis, HighlightModifier, HighlightTag, HighlightedRange, RootDatabase};\n+use crate::{Analysis, HighlightedRange, HlMod, HlTag, RootDatabase};\n \n use super::{highlights::Highlights, injector::Injector};\n \n@@ -28,7 +28,7 @@ pub(super) fn highlight_injection(\n     if let Some(range) = literal.open_quote_text_range() {\n         acc.add(HighlightedRange {\n             range,\n-            highlight: HighlightTag::StringLiteral.into(),\n+            highlight: HlTag::StringLiteral.into(),\n             binding_hash: None,\n         })\n     }\n@@ -44,7 +44,7 @@ pub(super) fn highlight_injection(\n     if let Some(range) = literal.close_quote_text_range() {\n         acc.add(HighlightedRange {\n             range,\n-            highlight: HighlightTag::StringLiteral.into(),\n+            highlight: HlTag::StringLiteral.into(),\n             binding_hash: None,\n         })\n     }\n@@ -171,7 +171,7 @@ pub(super) fn extract_doc_comments(node: &SyntaxNode) -> Option<(Vec<Highlighted\n                     range.start(),\n                     range.start() + TextSize::try_from(pos).unwrap(),\n                 ),\n-                highlight: HighlightTag::Comment | HighlightModifier::Documentation,\n+                highlight: HlTag::Comment | HlMod::Documentation,\n                 binding_hash: None,\n             });\n             line_start += range.len() - TextSize::try_from(pos).unwrap();\n@@ -209,7 +209,7 @@ pub(super) fn highlight_doc_comment(\n         for r in inj.map_range_up(h.range) {\n             stack.add(HighlightedRange {\n                 range: r,\n-                highlight: h.highlight | HighlightModifier::Injected,\n+                highlight: h.highlight | HlMod::Injected,\n                 binding_hash: h.binding_hash,\n             });\n         }"}, {"sha": "71dd1ccc5135be98e076ae0ac1ee96cdb3edfb61", "filename": "crates/ide/src/syntax_highlighting/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -1,7 +1,7 @@\n //! Syntax highlighting for macro_rules!.\n use syntax::{SyntaxElement, SyntaxKind, SyntaxToken, TextRange, T};\n \n-use crate::{HighlightTag, HighlightedRange};\n+use crate::{HighlightedRange, HlTag};\n \n #[derive(Default)]\n pub(super) struct MacroRulesHighlighter {\n@@ -25,7 +25,7 @@ impl MacroRulesHighlighter {\n                 if let Some(range) = is_metavariable(element) {\n                     return Some(HighlightedRange {\n                         range,\n-                        highlight: HighlightTag::UnresolvedReference.into(),\n+                        highlight: HlTag::UnresolvedReference.into(),\n                         binding_hash: None,\n                     });\n                 }"}, {"sha": "2f39bcc8e2f4e7c069be0b1bf908c2fec00e7011", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -7,15 +7,15 @@ use crate::SymbolKind;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct Highlight {\n-    pub tag: HighlightTag,\n-    pub modifiers: HighlightModifiers,\n+    pub tag: HlTag,\n+    pub mods: HlMods,\n }\n \n #[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct HighlightModifiers(u32);\n+pub struct HlMods(u32);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub enum HighlightTag {\n+pub enum HlTag {\n     Symbol(SymbolKind),\n \n     BoolLiteral,\n@@ -39,7 +39,7 @@ pub enum HighlightTag {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n #[repr(u8)]\n-pub enum HighlightModifier {\n+pub enum HlMod {\n     /// Used to differentiate individual elements within attributes.\n     Attribute = 0,\n     /// Used with keywords like `if` and `break`.\n@@ -61,10 +61,10 @@ pub enum HighlightModifier {\n     Unsafe,\n }\n \n-impl HighlightTag {\n+impl HlTag {\n     fn as_str(self) -> &'static str {\n         match self {\n-            HighlightTag::Symbol(symbol) => match symbol {\n+            HlTag::Symbol(symbol) => match symbol {\n                 SymbolKind::Const => \"constant\",\n                 SymbolKind::Static => \"static\",\n                 SymbolKind::Enum => \"enum\",\n@@ -86,59 +86,59 @@ impl HighlightTag {\n                 SymbolKind::SelfParam => \"self_keyword\",\n                 SymbolKind::Impl => \"self_type\",\n             },\n-            HighlightTag::Attribute => \"attribute\",\n-            HighlightTag::BoolLiteral => \"bool_literal\",\n-            HighlightTag::BuiltinType => \"builtin_type\",\n-            HighlightTag::ByteLiteral => \"byte_literal\",\n-            HighlightTag::CharLiteral => \"char_literal\",\n-            HighlightTag::Comment => \"comment\",\n-            HighlightTag::EscapeSequence => \"escape_sequence\",\n-            HighlightTag::FormatSpecifier => \"format_specifier\",\n-            HighlightTag::Keyword => \"keyword\",\n-            HighlightTag::Punctuation => \"punctuation\",\n-            HighlightTag::NumericLiteral => \"numeric_literal\",\n-            HighlightTag::Operator => \"operator\",\n-            HighlightTag::StringLiteral => \"string_literal\",\n-            HighlightTag::UnresolvedReference => \"unresolved_reference\",\n-            HighlightTag::None => \"none\",\n+            HlTag::Attribute => \"attribute\",\n+            HlTag::BoolLiteral => \"bool_literal\",\n+            HlTag::BuiltinType => \"builtin_type\",\n+            HlTag::ByteLiteral => \"byte_literal\",\n+            HlTag::CharLiteral => \"char_literal\",\n+            HlTag::Comment => \"comment\",\n+            HlTag::EscapeSequence => \"escape_sequence\",\n+            HlTag::FormatSpecifier => \"format_specifier\",\n+            HlTag::Keyword => \"keyword\",\n+            HlTag::Punctuation => \"punctuation\",\n+            HlTag::NumericLiteral => \"numeric_literal\",\n+            HlTag::Operator => \"operator\",\n+            HlTag::StringLiteral => \"string_literal\",\n+            HlTag::UnresolvedReference => \"unresolved_reference\",\n+            HlTag::None => \"none\",\n         }\n     }\n }\n \n-impl fmt::Display for HighlightTag {\n+impl fmt::Display for HlTag {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self.as_str(), f)\n     }\n }\n \n-impl HighlightModifier {\n-    const ALL: &'static [HighlightModifier; HighlightModifier::Unsafe as u8 as usize + 1] = &[\n-        HighlightModifier::Attribute,\n-        HighlightModifier::ControlFlow,\n-        HighlightModifier::Definition,\n-        HighlightModifier::Documentation,\n-        HighlightModifier::Injected,\n-        HighlightModifier::Mutable,\n-        HighlightModifier::Consuming,\n-        HighlightModifier::Callable,\n-        HighlightModifier::Static,\n-        HighlightModifier::Associated,\n-        HighlightModifier::Unsafe,\n+impl HlMod {\n+    const ALL: &'static [HlMod; HlMod::Unsafe as u8 as usize + 1] = &[\n+        HlMod::Attribute,\n+        HlMod::ControlFlow,\n+        HlMod::Definition,\n+        HlMod::Documentation,\n+        HlMod::Injected,\n+        HlMod::Mutable,\n+        HlMod::Consuming,\n+        HlMod::Callable,\n+        HlMod::Static,\n+        HlMod::Associated,\n+        HlMod::Unsafe,\n     ];\n \n     fn as_str(self) -> &'static str {\n         match self {\n-            HighlightModifier::Attribute => \"attribute\",\n-            HighlightModifier::ControlFlow => \"control\",\n-            HighlightModifier::Definition => \"declaration\",\n-            HighlightModifier::Documentation => \"documentation\",\n-            HighlightModifier::Injected => \"injected\",\n-            HighlightModifier::Mutable => \"mutable\",\n-            HighlightModifier::Consuming => \"consuming\",\n-            HighlightModifier::Unsafe => \"unsafe\",\n-            HighlightModifier::Callable => \"callable\",\n-            HighlightModifier::Static => \"static\",\n-            HighlightModifier::Associated => \"associated\",\n+            HlMod::Attribute => \"attribute\",\n+            HlMod::ControlFlow => \"control\",\n+            HlMod::Definition => \"declaration\",\n+            HlMod::Documentation => \"documentation\",\n+            HlMod::Injected => \"injected\",\n+            HlMod::Mutable => \"mutable\",\n+            HlMod::Consuming => \"consuming\",\n+            HlMod::Unsafe => \"unsafe\",\n+            HlMod::Callable => \"callable\",\n+            HlMod::Static => \"static\",\n+            HlMod::Associated => \"associated\",\n         }\n     }\n \n@@ -147,7 +147,7 @@ impl HighlightModifier {\n     }\n }\n \n-impl fmt::Display for HighlightModifier {\n+impl fmt::Display for HlMod {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self.as_str(), f)\n     }\n@@ -156,63 +156,63 @@ impl fmt::Display for HighlightModifier {\n impl fmt::Display for Highlight {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.tag)?;\n-        for modifier in self.modifiers.iter() {\n+        for modifier in self.mods.iter() {\n             write!(f, \".{}\", modifier)?\n         }\n         Ok(())\n     }\n }\n \n-impl From<HighlightTag> for Highlight {\n-    fn from(tag: HighlightTag) -> Highlight {\n+impl From<HlTag> for Highlight {\n+    fn from(tag: HlTag) -> Highlight {\n         Highlight::new(tag)\n     }\n }\n \n impl Highlight {\n-    pub(crate) fn new(tag: HighlightTag) -> Highlight {\n-        Highlight { tag, modifiers: HighlightModifiers::default() }\n+    pub(crate) fn new(tag: HlTag) -> Highlight {\n+        Highlight { tag, mods: HlMods::default() }\n     }\n     pub fn is_empty(&self) -> bool {\n-        self.tag == HighlightTag::None && self.modifiers == HighlightModifiers::default()\n+        self.tag == HlTag::None && self.mods == HlMods::default()\n     }\n }\n \n-impl ops::BitOr<HighlightModifier> for HighlightTag {\n+impl ops::BitOr<HlMod> for HlTag {\n     type Output = Highlight;\n \n-    fn bitor(self, rhs: HighlightModifier) -> Highlight {\n+    fn bitor(self, rhs: HlMod) -> Highlight {\n         Highlight::new(self) | rhs\n     }\n }\n \n-impl ops::BitOrAssign<HighlightModifier> for HighlightModifiers {\n-    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n+impl ops::BitOrAssign<HlMod> for HlMods {\n+    fn bitor_assign(&mut self, rhs: HlMod) {\n         self.0 |= rhs.mask();\n     }\n }\n \n-impl ops::BitOrAssign<HighlightModifier> for Highlight {\n-    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n-        self.modifiers |= rhs;\n+impl ops::BitOrAssign<HlMod> for Highlight {\n+    fn bitor_assign(&mut self, rhs: HlMod) {\n+        self.mods |= rhs;\n     }\n }\n \n-impl ops::BitOr<HighlightModifier> for Highlight {\n+impl ops::BitOr<HlMod> for Highlight {\n     type Output = Highlight;\n \n-    fn bitor(mut self, rhs: HighlightModifier) -> Highlight {\n+    fn bitor(mut self, rhs: HlMod) -> Highlight {\n         self |= rhs;\n         self\n     }\n }\n \n-impl HighlightModifiers {\n-    pub fn contains(self, m: HighlightModifier) -> bool {\n+impl HlMods {\n+    pub fn contains(self, m: HlMod) -> bool {\n         self.0 & m.mask() == m.mask()\n     }\n \n-    pub fn iter(self) -> impl Iterator<Item = HighlightModifier> {\n-        HighlightModifier::ALL.iter().copied().filter(move |it| self.0 & it.mask() == it.mask())\n+    pub fn iter(self) -> impl Iterator<Item = HlMod> {\n+        HlMod::ALL.iter().copied().filter(move |it| self.0 & it.mask() == it.mask())\n     }\n }"}, {"sha": "0c31a9fedb0915bb4f82dcecc2a3f9b1ddfdd593", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a6ee45351a71cdeb1d1dddc8fc746abdcff07b/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=64a6ee45351a71cdeb1d1dddc8fc746abdcff07b", "patch": "@@ -6,10 +6,9 @@ use std::{\n \n use ide::{\n     Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation, FileId,\n-    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n-    HighlightedRange, Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup,\n-    NavigationTarget, ReferenceAccess, Runnable, Severity, SourceChange, SourceFileEdit,\n-    SymbolKind, TextEdit, TextRange, TextSize,\n+    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightedRange, HlMod, HlTag, Indel,\n+    InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget, ReferenceAccess,\n+    Runnable, Severity, SourceChange, SourceFileEdit, SymbolKind, TextEdit, TextRange, TextSize,\n };\n use itertools::Itertools;\n \n@@ -377,7 +376,7 @@ fn semantic_token_type_and_modifiers(\n ) -> (lsp_types::SemanticTokenType, semantic_tokens::ModifierSet) {\n     let mut mods = semantic_tokens::ModifierSet::default();\n     let type_ = match highlight.tag {\n-        HighlightTag::Symbol(symbol) => match symbol {\n+        HlTag::Symbol(symbol) => match symbol {\n             SymbolKind::Module => lsp_types::SemanticTokenType::NAMESPACE,\n             SymbolKind::Impl => lsp_types::SemanticTokenType::TYPE,\n             SymbolKind::Field => lsp_types::SemanticTokenType::PROPERTY,\n@@ -389,7 +388,7 @@ fn semantic_token_type_and_modifiers(\n             SymbolKind::SelfParam => semantic_tokens::SELF_KEYWORD,\n             SymbolKind::Local => lsp_types::SemanticTokenType::VARIABLE,\n             SymbolKind::Function => {\n-                if highlight.modifiers.contains(HighlightModifier::Associated) {\n+                if highlight.mods.contains(HlMod::Associated) {\n                     lsp_types::SemanticTokenType::METHOD\n                 } else {\n                     lsp_types::SemanticTokenType::FUNCTION\n@@ -412,38 +411,34 @@ fn semantic_token_type_and_modifiers(\n             SymbolKind::Trait => lsp_types::SemanticTokenType::INTERFACE,\n             SymbolKind::Macro => lsp_types::SemanticTokenType::MACRO,\n         },\n-        HighlightTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n-        HighlightTag::None => semantic_tokens::GENERIC,\n-        HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => {\n-            lsp_types::SemanticTokenType::NUMBER\n-        }\n-        HighlightTag::BoolLiteral => semantic_tokens::BOOLEAN,\n-        HighlightTag::CharLiteral | HighlightTag::StringLiteral => {\n-            lsp_types::SemanticTokenType::STRING\n-        }\n-        HighlightTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n-        HighlightTag::Attribute => semantic_tokens::ATTRIBUTE,\n-        HighlightTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n-        HighlightTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n-        HighlightTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n-        HighlightTag::Operator => lsp_types::SemanticTokenType::OPERATOR,\n-        HighlightTag::EscapeSequence => semantic_tokens::ESCAPE_SEQUENCE,\n-        HighlightTag::Punctuation => semantic_tokens::PUNCTUATION,\n+        HlTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n+        HlTag::None => semantic_tokens::GENERIC,\n+        HlTag::ByteLiteral | HlTag::NumericLiteral => lsp_types::SemanticTokenType::NUMBER,\n+        HlTag::BoolLiteral => semantic_tokens::BOOLEAN,\n+        HlTag::CharLiteral | HlTag::StringLiteral => lsp_types::SemanticTokenType::STRING,\n+        HlTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n+        HlTag::Attribute => semantic_tokens::ATTRIBUTE,\n+        HlTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n+        HlTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n+        HlTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n+        HlTag::Operator => lsp_types::SemanticTokenType::OPERATOR,\n+        HlTag::EscapeSequence => semantic_tokens::ESCAPE_SEQUENCE,\n+        HlTag::Punctuation => semantic_tokens::PUNCTUATION,\n     };\n \n-    for modifier in highlight.modifiers.iter() {\n+    for modifier in highlight.mods.iter() {\n         let modifier = match modifier {\n-            HighlightModifier::Attribute => semantic_tokens::ATTRIBUTE_MODIFIER,\n-            HighlightModifier::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n-            HighlightModifier::Documentation => lsp_types::SemanticTokenModifier::DOCUMENTATION,\n-            HighlightModifier::Injected => semantic_tokens::INJECTED,\n-            HighlightModifier::ControlFlow => semantic_tokens::CONTROL_FLOW,\n-            HighlightModifier::Mutable => semantic_tokens::MUTABLE,\n-            HighlightModifier::Consuming => semantic_tokens::CONSUMING,\n-            HighlightModifier::Unsafe => semantic_tokens::UNSAFE,\n-            HighlightModifier::Callable => semantic_tokens::CALLABLE,\n-            HighlightModifier::Static => lsp_types::SemanticTokenModifier::STATIC,\n-            HighlightModifier::Associated => continue,\n+            HlMod::Attribute => semantic_tokens::ATTRIBUTE_MODIFIER,\n+            HlMod::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n+            HlMod::Documentation => lsp_types::SemanticTokenModifier::DOCUMENTATION,\n+            HlMod::Injected => semantic_tokens::INJECTED,\n+            HlMod::ControlFlow => semantic_tokens::CONTROL_FLOW,\n+            HlMod::Mutable => semantic_tokens::MUTABLE,\n+            HlMod::Consuming => semantic_tokens::CONSUMING,\n+            HlMod::Unsafe => semantic_tokens::UNSAFE,\n+            HlMod::Callable => semantic_tokens::CALLABLE,\n+            HlMod::Static => lsp_types::SemanticTokenModifier::STATIC,\n+            HlMod::Associated => continue,\n         };\n         mods |= modifier;\n     }"}]}