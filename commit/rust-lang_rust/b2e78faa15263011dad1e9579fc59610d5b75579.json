{"sha": "b2e78faa15263011dad1e9579fc59610d5b75579", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZTc4ZmFhMTUyNjMwMTFkYWQxZTk1NzlmYzU5NjEwZDViNzU1Nzk=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-02T01:11:33Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:49:01Z"}, "message": "Move more work into `decorate` functions.", "tree": {"sha": "e2213a2e65c7fb718eb0398b6c4319d1a4140faa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2213a2e65c7fb718eb0398b6c4319d1a4140faa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2e78faa15263011dad1e9579fc59610d5b75579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e78faa15263011dad1e9579fc59610d5b75579", "html_url": "https://github.com/rust-lang/rust/commit/b2e78faa15263011dad1e9579fc59610d5b75579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2e78faa15263011dad1e9579fc59610d5b75579/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "html_url": "https://github.com/rust-lang/rust/commit/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd"}], "stats": {"total": 60, "additions": 28, "deletions": 32}, "files": [{"sha": "d45ea10dfbf587225f71a66eef35f457b5d405e4", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2e78faa15263011dad1e9579fc59610d5b75579/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e78faa15263011dad1e9579fc59610d5b75579/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=b2e78faa15263011dad1e9579fc59610d5b75579", "patch": "@@ -107,8 +107,8 @@ impl NonCamelCaseTypes {\n         let name = &ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n             cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, |lint| {\n+                let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n                 lint.build(&msg)\n                     .span_suggestion(\n                         ident.span,\n@@ -227,8 +227,8 @@ impl NonSnakeCase {\n         if !is_snake_case(name) {\n             let sc = NonSnakeCase::to_snake_case(name);\n \n-            let msg = format!(\"{} `{}` should have a snake case name\", sort, name);\n             cx.struct_span_lint(NON_SNAKE_CASE, ident.span, |lint| {\n+                let msg = format!(\"{} `{}` should have a snake case name\", sort, name);\n                 let mut err = lint.build(&msg);\n                 // We have a valid span in almost all cases, but we don't have one when linting a crate\n                 // name provided via the command line.\n@@ -389,11 +389,9 @@ declare_lint_pass!(NonUpperCaseGlobals => [NON_UPPER_CASE_GLOBALS]);\n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n         let name = &ident.name.as_str();\n-\n         if name.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-\n             cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n+                let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n                 lint.build(&format!(\"{} `{}` should have an upper case name\", sort, name))\n                     .span_suggestion(\n                         ident.span,"}, {"sha": "d1982e9162e59ff4f08cbd3e95caac0c97b709b6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2e78faa15263011dad1e9579fc59610d5b75579/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e78faa15263011dad1e9579fc59610d5b75579/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b2e78faa15263011dad1e9579fc59610d5b75579", "patch": "@@ -151,17 +151,17 @@ fn report_bin_hex_error(\n     negative: bool,\n ) {\n     let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n-    let (t, actually) = match ty {\n-        attr::IntType::SignedInt(t) => {\n-            let actually = sign_extend(val, size) as i128;\n-            (t.name_str(), actually.to_string())\n-        }\n-        attr::IntType::UnsignedInt(t) => {\n-            let actually = truncate(val, size);\n-            (t.name_str(), actually.to_string())\n-        }\n-    };\n     cx.struct_span_lint(OVERFLOWING_LITERALS, expr.span, |lint| {\n+        let (t, actually) = match ty {\n+            attr::IntType::SignedInt(t) => {\n+                let actually = sign_extend(val, size) as i128;\n+                (t.name_str(), actually.to_string())\n+            }\n+            attr::IntType::UnsignedInt(t) => {\n+                let actually = truncate(val, size);\n+                (t.name_str(), actually.to_string())\n+            }\n+        };\n         let mut err = lint.build(&format!(\"literal out of range for {}\", t));\n         err.note(&format!(\n             \"the literal `{}` (decimal `{}`) does not fit into \\"}, {"sha": "dd833d9751cb90e483f7d921fd74fe4aa547c75c", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2e78faa15263011dad1e9579fc59610d5b75579/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e78faa15263011dad1e9579fc59610d5b75579/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=b2e78faa15263011dad1e9579fc59610d5b75579", "patch": "@@ -123,17 +123,15 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         // We do this in any edition.\n         if extern_crate.warn_if_unused {\n             if let Some(&span) = unused_extern_crates.get(&extern_crate.def_id) {\n-                let msg = \"unused extern crate\";\n-\n-                // Removal suggestion span needs to include attributes (Issue #54400)\n-                let span_with_attrs = tcx\n-                    .get_attrs(extern_crate.def_id)\n-                    .iter()\n-                    .map(|attr| attr.span)\n-                    .fold(span, |acc, attr_span| acc.to(attr_span));\n-\n                 tcx.struct_span_lint_hir(lint, id, span, |lint| {\n-                    lint.build(msg)\n+                    // Removal suggestion span needs to include attributes (Issue #54400)\n+                    let span_with_attrs = tcx\n+                        .get_attrs(extern_crate.def_id)\n+                        .iter()\n+                        .map(|attr| attr.span)\n+                        .fold(span, |acc, attr_span| acc.to(attr_span));\n+\n+                    lint.build(\"unused extern crate\")\n                         .span_suggestion_short(\n                             span_with_attrs,\n                             \"remove it\",\n@@ -172,14 +170,14 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         if !tcx.get_attrs(extern_crate.def_id).is_empty() {\n             continue;\n         }\n-\n-        // Otherwise, we can convert it into a `use` of some kind.\n-        let base_replacement = match extern_crate.orig_name {\n-            Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n-            None => format!(\"use {};\", item.ident.name),\n-        };\n-        let replacement = visibility_qualified(&item.vis, base_replacement);\n         tcx.struct_span_lint_hir(lint, id, extern_crate.span, |lint| {\n+            // Otherwise, we can convert it into a `use` of some kind.\n+            let base_replacement = match extern_crate.orig_name {\n+                Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n+                None => format!(\"use {};\", item.ident.name),\n+            };\n+\n+            let replacement = visibility_qualified(&item.vis, base_replacement);\n             let msg = \"`extern crate` is not idiomatic in the new edition\";\n             let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n "}]}