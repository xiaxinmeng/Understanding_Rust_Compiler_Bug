{"sha": "59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MTcxZjhlYzhkY2UxMTMyOWVkOWJmYWE3M2Q1YmJjZjg4ZjlhMDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:11Z"}, "message": "rollup merge of #24651: tamird/old-references\n\nr? @alexcrichton", "tree": {"sha": "4bcf93654923db52a4f421cabf533ea33d02c877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bcf93654923db52a4f421cabf533ea33d02c877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "html_url": "https://github.com/rust-lang/rust/commit/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a", "html_url": "https://github.com/rust-lang/rust/commit/1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a"}, {"sha": "71bc70ea1b99f9eac5460b8560f90d1baac6385f", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bc70ea1b99f9eac5460b8560f90d1baac6385f", "html_url": "https://github.com/rust-lang/rust/commit/71bc70ea1b99f9eac5460b8560f90d1baac6385f"}], "stats": {"total": 1057, "additions": 12, "deletions": 1045}, "files": [{"sha": "4a276abaf7a2d7413cc718df0d895c18026e3326", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -260,7 +260,6 @@\n //! Example usage is:\n //!\n //! ```\n-//! # #![feature(old_io)]\n //! # #![allow(unused_must_use)]\n //! use std::io::Write;\n //! let mut w = Vec::new();\n@@ -288,7 +287,6 @@\n //! off, some example usage is:\n //!\n //! ```\n-//! # #![feature(old_io)]\n //! use std::fmt;\n //! use std::io::{self, Write};\n //!"}, {"sha": "d042ef79233227aa55bfa2a0d5962201c3bd6272", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -2059,7 +2059,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n     }\n }\n \n-/// Decodes a json value from an `&mut old_io::Reader`\n+/// Decodes a json value from an `&mut io::Read`\n pub fn from_reader(rdr: &mut Read) -> Result<Json, BuilderError> {\n     let mut contents = Vec::new();\n     match rdr.read_to_end(&mut contents) {"}, {"sha": "11b057d0094ae1d0674b22db405f03307eb35a47", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -19,7 +19,6 @@ use rt::{backtrace, unwind};\n use sys::stdio::Stderr;\n use thread;\n \n-// Defined in this module instead of old_io::stdio so that the unwinding\n thread_local! {\n     pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n         RefCell::new(None)"}, {"sha": "fc21effb45a8da06cf01b0c57534325bbd2c1d06", "filename": "src/libstd/sys/common/net.rs", "status": "removed", "additions": 0, "deletions": 971, "changes": 971, "blob_url": "https://github.com/rust-lang/rust/blob/1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a", "patch": "@@ -1,971 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-use self::SocketStatus::*;\n-use self::InAddr::*;\n-\n-use ffi::{CString, CStr};\n-use old_io::net::addrinfo;\n-use old_io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n-use old_io::{IoResult, IoError};\n-use libc::{self, c_char, c_int};\n-use mem;\n-use num::Int;\n-use ptr::{self, null, null_mut};\n-use str;\n-use sys::{self, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n-          wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n-          decode_error_detailed};\n-use sync::{Arc, Mutex};\n-#[cfg(not(target_os = \"linux\"))]\n-use sync::MutexGuard;\n-use sys_common::{self, keep_going, short_write, timeout};\n-use cmp;\n-use old_io;\n-\n-// FIXME: move uses of Arc and deadline tracking to std::io\n-\n-#[derive(Debug)]\n-pub enum SocketStatus {\n-    Readable,\n-    Writable,\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// sockaddr and misc bindings\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub fn htons(u: u16) -> u16 {\n-    u.to_be()\n-}\n-pub fn ntohs(u: u16) -> u16 {\n-    Int::from_be(u)\n-}\n-\n-pub enum InAddr {\n-    In4Addr(libc::in_addr),\n-    In6Addr(libc::in6_addr),\n-}\n-\n-pub fn ip_to_inaddr(ip: IpAddr) -> InAddr {\n-    match ip {\n-        Ipv4Addr(a, b, c, d) => {\n-            let ip = ((a as u32) << 24) |\n-                     ((b as u32) << 16) |\n-                     ((c as u32) <<  8) |\n-                     ((d as u32) <<  0);\n-            In4Addr(libc::in_addr {\n-                s_addr: Int::from_be(ip)\n-            })\n-        }\n-        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            In6Addr(libc::in6_addr {\n-                s6_addr: [\n-                    htons(a),\n-                    htons(b),\n-                    htons(c),\n-                    htons(d),\n-                    htons(e),\n-                    htons(f),\n-                    htons(g),\n-                    htons(h),\n-                ]\n-            })\n-        }\n-    }\n-}\n-\n-pub fn addr_to_sockaddr(addr: SocketAddr,\n-                    storage: &mut libc::sockaddr_storage)\n-                    -> libc::socklen_t {\n-    unsafe {\n-        let len = match ip_to_inaddr(addr.ip) {\n-            In4Addr(inaddr) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in;\n-                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n-                (*storage).sin_port = htons(addr.port);\n-                (*storage).sin_addr = inaddr;\n-                mem::size_of::<libc::sockaddr_in>()\n-            }\n-            In6Addr(inaddr) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in6;\n-                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n-                (*storage).sin6_port = htons(addr.port);\n-                (*storage).sin6_addr = inaddr;\n-                mem::size_of::<libc::sockaddr_in6>()\n-            }\n-        };\n-        return len as libc::socklen_t;\n-    }\n-}\n-\n-pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n-    unsafe {\n-        let fam = match addr.ip {\n-            Ipv4Addr(..) => libc::AF_INET,\n-            Ipv6Addr(..) => libc::AF_INET6,\n-        };\n-        match libc::socket(fam, ty, 0) as i32 {\n-            -1 => Err(last_net_error()),\n-            fd => Ok(fd as sock_t),\n-        }\n-    }\n-}\n-\n-pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n-                 payload: T) -> IoResult<()> {\n-    unsafe {\n-        let payload = &payload as *const T as *const libc::c_void;\n-        let ret = libc::setsockopt(fd, opt, val,\n-                                   payload,\n-                                   mem::size_of::<T>() as libc::socklen_t);\n-        if ret != 0 {\n-            Err(last_net_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n-                           val: libc::c_int) -> IoResult<T> {\n-    unsafe {\n-        let mut slot: T = mem::zeroed();\n-        let mut len = mem::size_of::<T>() as libc::socklen_t;\n-        let ret = c::getsockopt(fd, opt, val,\n-                                &mut slot as *mut _ as *mut _,\n-                                &mut len);\n-        if ret != 0 {\n-            Err(last_net_error())\n-        } else {\n-            assert!(len as usize == mem::size_of::<T>());\n-            Ok(slot)\n-        }\n-    }\n-}\n-\n-pub fn sockname(fd: sock_t,\n-            f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n-                                         *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<SocketAddr>\n-{\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-    unsafe {\n-        let storage = &mut storage as *mut libc::sockaddr_storage;\n-        let ret = f(fd,\n-                    storage as *mut libc::sockaddr,\n-                    &mut len as *mut libc::socklen_t);\n-        if ret != 0 {\n-            return Err(last_net_error())\n-        }\n-    }\n-    return sockaddr_to_addr(&storage, len as usize);\n-}\n-\n-pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: usize) -> IoResult<SocketAddr> {\n-    match storage.ss_family as libc::c_int {\n-        libc::AF_INET => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n-            let storage: &libc::sockaddr_in = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let ip = (storage.sin_addr.s_addr as u32).to_be();\n-            let a = (ip >> 24) as u8;\n-            let b = (ip >> 16) as u8;\n-            let c = (ip >>  8) as u8;\n-            let d = (ip >>  0) as u8;\n-            Ok(SocketAddr {\n-                ip: Ipv4Addr(a, b, c, d),\n-                port: ntohs(storage.sin_port),\n-            })\n-        }\n-        libc::AF_INET6 => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n-            let storage: &libc::sockaddr_in6 = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n-            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n-            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n-            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n-            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n-            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n-            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n-            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(SocketAddr {\n-                ip: Ipv6Addr(a, b, c, d, e, f, g, h),\n-                port: ntohs(storage.sin6_port),\n-            })\n-        }\n-        _ => {\n-            Err(IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"invalid argument\",\n-                detail: None,\n-            })\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// get_host_addresses\n-////////////////////////////////////////////////////////////////////////////////\n-\n-extern \"system\" {\n-    fn getaddrinfo(node: *const c_char, service: *const c_char,\n-                   hints: *const libc::addrinfo,\n-                   res: *mut *mut libc::addrinfo) -> c_int;\n-    fn freeaddrinfo(res: *mut libc::addrinfo);\n-}\n-\n-pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<addrinfo::Hint>)\n-                          -> Result<Vec<addrinfo::Info>, IoError>\n-{\n-    sys::init_net();\n-\n-    assert!(host.is_some() || servname.is_some());\n-\n-    let c_host = match host {\n-        Some(x) => Some(try!(CString::new(x))),\n-        None => None,\n-    };\n-    let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-    let c_serv = match servname {\n-        Some(x) => Some(try!(CString::new(x))),\n-        None => None,\n-    };\n-    let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-\n-    let hint = hint.map(|hint| {\n-        libc::addrinfo {\n-            ai_flags: hint.flags as c_int,\n-            ai_family: hint.family as c_int,\n-            ai_socktype: 0,\n-            ai_protocol: 0,\n-            ai_addrlen: 0,\n-            ai_canonname: null_mut(),\n-            ai_addr: null_mut(),\n-            ai_next: null_mut()\n-        }\n-    });\n-\n-    let hint_ptr = hint.as_ref().map_or(null(), |x| {\n-        x as *const libc::addrinfo\n-    });\n-    let mut res = null_mut();\n-\n-    // Make the call\n-    let s = unsafe {\n-        getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n-    };\n-\n-    // Error?\n-    if s != 0 {\n-        return Err(last_gai_error(s));\n-    }\n-\n-    // Collect all the results we found\n-    let mut addrs = Vec::new();\n-    let mut rp = res;\n-    while !rp.is_null() {\n-        unsafe {\n-            let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                             (*rp).ai_addrlen as usize));\n-            addrs.push(addrinfo::Info {\n-                address: addr,\n-                family: (*rp).ai_family as usize,\n-                socktype: None,\n-                protocol: None,\n-                flags: (*rp).ai_flags as usize\n-            });\n-\n-            rp = (*rp).ai_next as *mut libc::addrinfo;\n-        }\n-    }\n-\n-    unsafe { freeaddrinfo(res); }\n-\n-    Ok(addrs)\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// get_address_name\n-////////////////////////////////////////////////////////////////////////////////\n-\n-extern \"system\" {\n-    fn getnameinfo(sa: *const libc::sockaddr, salen: libc::socklen_t,\n-        host: *mut c_char, hostlen: libc::size_t,\n-        serv: *mut c_char, servlen: libc::size_t,\n-        flags: c_int) -> c_int;\n-}\n-\n-const NI_MAXHOST: usize = 1025;\n-\n-pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n-    let addr = SocketAddr{ip: addr, port: 0};\n-\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let len = addr_to_sockaddr(addr, &mut storage);\n-\n-    let mut hostbuf = [0 as c_char; NI_MAXHOST];\n-\n-    let res = unsafe {\n-        getnameinfo(&storage as *const _ as *const libc::sockaddr, len,\n-            hostbuf.as_mut_ptr(), NI_MAXHOST as libc::size_t,\n-            ptr::null_mut(), 0,\n-            0)\n-    };\n-\n-    if res != 0 {\n-        return Err(last_gai_error(res));\n-    }\n-\n-    unsafe {\n-        let data = CStr::from_ptr(hostbuf.as_ptr());\n-        Ok(str::from_utf8(data.to_bytes()).unwrap().to_string())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Timeout helpers\n-//\n-// The read/write functions below are the helpers for reading/writing a socket\n-// with a possible deadline specified. This is generally viewed as a timed out\n-// I/O operation.\n-//\n-// From the application's perspective, timeouts apply to the I/O object, not to\n-// the underlying file descriptor (it's one timeout per object). This means that\n-// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n-//\n-// The next idea to implement timeouts would be to use nonblocking I/O. An\n-// invocation of select() would wait (with a timeout) for a socket to be ready.\n-// Once its ready, we can perform the operation. Note that the operation *must*\n-// be nonblocking, even though select() says the socket is ready. This is\n-// because some other thread could have come and stolen our data (handles can be\n-// cloned).\n-//\n-// To implement nonblocking I/O, the first option we have is to use the\n-// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n-// I/O objects, so this was initially viewed as unwise.\n-//\n-// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n-// send/recv, but the niftiness wears off once you realize it only works well on\n-// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n-// operation on Linux (no flag fiddling, no affecting other objects), but not on\n-// other platforms.\n-//\n-// To work around this constraint on other platforms, we end up using the\n-// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n-// could cause other objects' blocking operations to suddenly become\n-// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n-// falls back to using the same code path as nonblocking operations, but with an\n-// infinite timeout (select + send/recv). This helps emulate blocking\n-// reads/writes despite the underlying descriptor being nonblocking, as well as\n-// optimizing the fast path of just hitting one syscall in the good case.\n-//\n-// As a final caveat, this implementation uses a mutex so only one thread is\n-// doing a nonblocking operation at at time. This is the operation that comes\n-// after the select() (at which point we think the socket is ready). This is\n-// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n-// expect (wouldn't want someone turning it on when it should be off!). All\n-// operations performed in the lock are *nonblocking* to avoid holding the mutex\n-// forever.\n-//\n-// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n-// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n-// reads/writes are still blocking.\n-//\n-// Fun, fun!\n-//\n-// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n-// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n-\n-pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<usize> where\n-    L: FnMut() -> T,\n-    R: FnMut(bool) -> libc::c_int,\n-{\n-    let mut ret = -1;\n-    if deadline == 0 {\n-        ret = retry(|| read(false));\n-    }\n-\n-    if deadline != 0 || (ret == -1 && wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        loop {\n-            // With a timeout, first we wait for the socket to become\n-            // readable using select(), specifying the relevant timeout for\n-            // our previously set deadline.\n-            try!(await(&[fd], deadline, Readable));\n-\n-            // At this point, we're still within the timeout, and we've\n-            // determined that the socket is readable (as returned by\n-            // select). We must still read the socket in *nonblocking* mode\n-            // because some other thread could come steal our data. If we\n-            // fail to read some data, we retry (hence the outer loop) and\n-            // wait for the socket to become readable again.\n-            let _guard = lock();\n-            match retry(|| read(deadline.is_some())) {\n-                -1 if wouldblock() => {}\n-                -1 => return Err(last_net_error()),\n-               n => { ret = n; break }\n-            }\n-        }\n-    }\n-\n-    match ret {\n-        0 => Err(sys_common::eof()),\n-        n if n < 0 => Err(last_net_error()),\n-        n => Ok(n as usize)\n-    }\n-}\n-\n-pub fn write<T, L, W>(fd: sock_t,\n-                      deadline: u64,\n-                      buf: &[u8],\n-                      write_everything: bool,\n-                      mut lock: L,\n-                      mut write: W) -> IoResult<usize> where\n-    L: FnMut() -> T,\n-    W: FnMut(bool, *const u8, usize) -> i64,\n-{\n-    let mut ret = -1;\n-    let mut written = 0;\n-    if deadline == 0 {\n-        if write_everything {\n-            ret = keep_going(buf, |inner, len| {\n-                written = buf.len() - len;\n-                write(false, inner, len)\n-            });\n-        } else {\n-            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as usize; }\n-        }\n-    }\n-\n-    if deadline != 0 || (ret == -1 && wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        while written < buf.len() && (write_everything || written == 0) {\n-            // As with read(), first wait for the socket to be ready for\n-            // the I/O operation.\n-            match await(&[fd], deadline, Writable) {\n-                Err(ref e) if e.kind == old_io::EndOfFile && written > 0 => {\n-                    assert!(deadline.is_some());\n-                    return Err(short_write(written, \"short write\"))\n-                }\n-                Err(e) => return Err(e),\n-                Ok(()) => {}\n-            }\n-\n-            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforeseen circumstances.\n-            let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n-            let len = buf.len() - written;\n-            match retry(|| write(deadline.is_some(), ptr, len)) {\n-                -1 if wouldblock() => {}\n-                -1 => return Err(last_net_error()),\n-                n => { written += n as usize; }\n-            }\n-        }\n-        ret = 0;\n-    }\n-    if ret < 0 {\n-        Err(last_net_error())\n-    } else {\n-        Ok(written)\n-    }\n-}\n-\n-// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n-// derived from.\n-pub fn connect_timeout(fd: sock_t,\n-                       addrp: *const libc::sockaddr,\n-                       len: libc::socklen_t,\n-                       timeout_ms: u64) -> IoResult<()> {\n-    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n-    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n-    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n-    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n-\n-    // Make sure the call to connect() doesn't block\n-    set_nonblocking(fd, true);\n-\n-    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n-        // If the connection is in progress, then we need to wait for it to\n-        // finish (with a timeout). The current strategy for doing this is\n-        // to use select() with a timeout.\n-        -1 if os::errno() as isize == INPROGRESS as isize ||\n-              os::errno() as isize == WOULDBLOCK as isize => {\n-            let mut set: c::fd_set = unsafe { mem::zeroed() };\n-            c::fd_set(&mut set, fd);\n-            match await(fd, &mut set, timeout_ms) {\n-                0 => Err(timeout(\"connection timed out\")),\n-                -1 => Err(last_net_error()),\n-                _ => {\n-                    let err: libc::c_int = try!(\n-                        getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n-                    if err == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(decode_error_detailed(err))\n-                    }\n-                }\n-            }\n-        }\n-\n-        -1 => Err(last_net_error()),\n-        _ => Ok(()),\n-    };\n-\n-    // be sure to turn blocking I/O back on\n-    set_nonblocking(fd, false);\n-    return ret;\n-\n-    #[cfg(unix)]\n-    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-        let start = timer::now();\n-        retry(|| unsafe {\n-            // Recalculate the timeout each iteration (it is generally\n-            // undefined what the value of the 'tv' is after select\n-            // returns EINTR).\n-            let mut tv = ms_to_timeval(timeout - (timer::now() - start));\n-            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n-                      ptr::null_mut(), &mut tv)\n-        })\n-    }\n-    #[cfg(windows)]\n-    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-        let mut tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n-    }\n-}\n-\n-pub fn await(fds: &[sock_t], deadline: Option<u64>,\n-             status: SocketStatus) -> IoResult<()> {\n-    let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    let mut max = 0;\n-    for &fd in fds {\n-        c::fd_set(&mut set, fd);\n-        max = cmp::max(max, fd + 1);\n-    }\n-    if cfg!(windows) {\n-        max = fds.len() as sock_t;\n-    }\n-\n-    let (read, write) = match status {\n-        Readable => (&mut set as *mut _, ptr::null_mut()),\n-        Writable => (ptr::null_mut(), &mut set as *mut _),\n-    };\n-    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n-\n-    match retry(|| {\n-        let now = timer::now();\n-        let tvp = match deadline {\n-            None => ptr::null_mut(),\n-            Some(deadline) => {\n-                // If we're past the deadline, then pass a 0 timeout to\n-                // select() so we can poll the status\n-                let ms = if deadline < now {0} else {deadline - now};\n-                tv = ms_to_timeval(ms);\n-                &mut tv as *mut _\n-            }\n-        };\n-        let r = unsafe {\n-            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n-        };\n-        r\n-    }) {\n-        -1 => Err(last_net_error()),\n-        0 => Err(timeout(\"timed out\")),\n-        _ => Ok(()),\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Basic socket representation\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct Inner {\n-    fd: sock_t,\n-\n-    // Unused on Linux, where this lock is not necessary.\n-    #[allow(dead_code)]\n-    lock: Mutex<()>,\n-}\n-\n-impl Inner {\n-    fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: Mutex::new(()) }\n-    }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-pub struct Guard<'a> {\n-    pub fd: sock_t,\n-    pub guard: MutexGuard<'a, ()>,\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-#[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n-    fn drop(&mut self) {\n-        set_nonblocking(self.fd, false);\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// TCP streams\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct TcpStream {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl TcpStream {\n-    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> {\n-        sys::init_net();\n-\n-        let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpStream::new(fd);\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        match timeout {\n-            Some(timeout) => {\n-                try!(connect_timeout(fd, addrp, len, timeout));\n-                Ok(ret)\n-            },\n-            None => {\n-                match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn new(fd: sock_t) -> TcpStream {\n-        TcpStream {\n-            inner: Arc::new(Inner::new(fd)),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_NODELAY,\n-                   nodelay as libc::c_int)\n-    }\n-\n-    pub fn set_keepalive(&mut self, seconds: Option<usize>) -> IoResult<()> {\n-        let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n-                             seconds.is_some() as libc::c_int);\n-        match seconds {\n-            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n-            None => ret,\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(target_os = \"openbsd\")]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::SO_KEEPALIVE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(not(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"freebsd\",\n-                  target_os = \"dragonfly\",\n-                  target_os = \"openbsd\")))]\n-    fn set_tcp_keepalive(&mut self, _seconds: usize) -> IoResult<()> {\n-        Ok(())\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recv(fd,\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as wrlen,\n-                       flags) as libc::c_int\n-        };\n-        read(fd, self.read_deadline, dolock, doread)\n-    }\n-\n-    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::send(fd,\n-                       buf as *const _,\n-                       len as wrlen,\n-                       flags) as i64\n-        };\n-        write(fd, self.write_deadline, buf, true, dolock, dowrite).map(|_| ())\n-    }\n-    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getpeername)\n-    }\n-\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n-    }\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-impl Clone for TcpStream {\n-    fn clone(&self) -> TcpStream {\n-        TcpStream {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// UDP\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UdpSocket {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl UdpSocket {\n-    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n-        sys::init_net();\n-\n-        let fd = try!(socket(addr, libc::SOCK_DGRAM));\n-        let ret = UdpSocket {\n-            inner: Arc::new(Inner::new(fd)),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        };\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n-            _ => Ok(ret),\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_BROADCAST,\n-                   on as libc::c_int)\n-    }\n-\n-    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP,\n-                   on as libc::c_int)\n-    }\n-\n-    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> {\n-        match ip_to_inaddr(addr) {\n-            In4Addr(addr) => {\n-                let mreq = libc::ip_mreq {\n-                    imr_multiaddr: addr,\n-                    // interface == INADDR_ANY\n-                    imr_interface: libc::in_addr { s_addr: 0x0 },\n-                };\n-                setsockopt(self.fd(), libc::IPPROTO_IP, opt, mreq)\n-            }\n-            In6Addr(addr) => {\n-                let mreq = libc::ip6_mreq {\n-                    ipv6mr_multiaddr: addr,\n-                    ipv6mr_interface: 0,\n-                };\n-                setsockopt(self.fd(), libc::IPPROTO_IPV6, opt, mreq)\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n-        let fd = self.fd();\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n-        let mut addrlen: libc::socklen_t =\n-                mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-\n-        let dolock = || self.lock_nonblocking();\n-        let n = try!(read(fd, self.read_deadline, dolock, |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recvfrom(fd,\n-                           buf.as_mut_ptr() as *mut libc::c_void,\n-                           buf.len() as msglen_t,\n-                           flags,\n-                           storagep,\n-                           &mut addrlen) as libc::c_int\n-        }));\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize).unwrap()))\n-    }\n-\n-    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        let mut storage = unsafe { mem::zeroed() };\n-        let dstlen = addr_to_sockaddr(dst, &mut storage);\n-        let dstp = &storage as *const _ as *const libc::sockaddr;\n-\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::sendto(fd,\n-                         buf as *const libc::c_void,\n-                         len as msglen_t,\n-                         flags,\n-                         dstp,\n-                         dstlen) as i64\n-        };\n-\n-        let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n-        assert!(n == buf.len(), \"UDP packet not completely written.\");\n-        Ok(())\n-    }\n-\n-    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        match multi {\n-            Ipv4Addr(..) => {\n-                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n-            }\n-            Ipv6Addr(..) => {\n-                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n-            }\n-        }\n-    }\n-    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        match multi {\n-            Ipv4Addr(..) => {\n-                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n-            }\n-            Ipv6Addr(..) => {\n-                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n-            }\n-        }\n-    }\n-\n-    pub fn multicast_time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n-                   ttl as libc::c_int)\n-    }\n-    pub fn time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-}\n-\n-impl Clone for UdpSocket {\n-    fn clone(&self) -> UdpSocket {\n-        UdpSocket {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-}"}, {"sha": "fe0ede80fc663cbda1451a8cfffecb65aaecb178", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=1ec7ccb53c4ef00eff1e13ff50ec18f54400de4a", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use libc;\n-use sys::os;\n-\n-use sys::fs::FileDesc;\n-\n-pub type signal = libc::c_int;\n-\n-pub fn new() -> (signal, signal) {\n-    let (a, b) = unsafe { os::pipe().unwrap() };\n-    (a.unwrap(), b.unwrap())\n-}\n-\n-pub fn signal(fd: libc::c_int) {\n-    FileDesc::new(fd, false).write(&[0]).unwrap();\n-}\n-\n-pub fn close(fd: libc::c_int) {\n-    let _fd = FileDesc::new(fd, true);\n-}"}, {"sha": "3de99088da47b3c653b9dcd6a8de63093b733df6", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -355,11 +355,4 @@ mod test {\n         assert_eq!(numfnames.len(), numnames.len());\n         assert_eq!(stringfnames.len(), stringnames.len());\n     }\n-\n-    #[test]\n-    #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n-    fn test_parse() {\n-        // FIXME #6870: Distribute a compiled file in src/tests and test there\n-        // parse(old_io::fs_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n-    }\n }"}, {"sha": "4f350b909caa7fc5b2a913b2b7770b3acac4b6db", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -43,7 +43,6 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(set_stdio)]\n-#![cfg_attr(test, feature(old_io))]\n \n extern crate getopts;\n extern crate serialize;"}, {"sha": "6cc2d427c25dcc6a41cdb3362e94147ad42a483c", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, old_path)]\n+#![feature(std_misc)]\n \n use std::dynamic_lib::DynamicLibrary;\n "}, {"sha": "67975d02b19f06f1a037091612338475d11b47fd", "filename": "src/test/debuginfo/issue13213.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue13213.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:issue13213aux.rs\n \n-#![feature(old_io)]\n-\n extern crate issue13213aux;\n \n // compile-flags:-g"}, {"sha": "fd69d2786b8d0800adb74bc000a7b73b638e1c0f", "filename": "src/test/run-make/cannot-read-embedded-idents/create_and_compile.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(old_io, old_path)]\n-\n use std::env;\n use std::fs::File;\n use std::process::Command;"}, {"sha": "244f32b8ee5fc323feaf63457562faf436f95bb2", "filename": "src/test/run-make/extern-fn-reachable/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, old_path, os)]\n+#![feature(std_misc)]\n \n use std::dynamic_lib::DynamicLibrary;\n-use std::os;\n use std::path::Path;\n \n pub fn main() {"}, {"sha": "0fa67e873f89c4bb866383c6c44f759716066d29", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -11,9 +11,7 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n-#![feature(unboxed_closures, old_io)]\n-\n-use std::mem;\n+#![feature(unboxed_closures)]\n \n fn call_it<F>(f: F)\n     where F : FnOnce(String) -> String"}, {"sha": "c81e16ebb7c60f3c62b4303112783fec5c03efc1", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -12,8 +12,6 @@\n // Make sure that if a process doesn't have its stdio/stderr descriptors set up\n // that we don't die in a large ball of fire\n \n-#![feature(old_io)]\n-\n use std::env;\n use std::process::{Command, Stdio};\n "}, {"sha": "9da04f723553105d1f6226892e4f526afc3a7db1", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(rustc_private, old_io)]\n+#![feature(rustc_private)]\n \n extern crate rbml;\n extern crate serialize;"}, {"sha": "ba6815d5b7c6973e0a8588be3ffcb10177bb1c4b", "filename": "src/test/run-pass/issue-14940.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14940.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(old_io, io)]\n-\n use std::env;\n use std::process::Command;\n use std::io::{self, Write};"}, {"sha": "74da4273b6ab0fb9b773425793bed9e05ae5df70", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -12,7 +12,7 @@\n // ignore-android: FIXME(#10379)\n // ignore-windows: std::dynamic_lib does not work on Windows well\n \n-#![feature(std_misc, old_path)]\n+#![feature(std_misc)]\n \n extern crate linkage_visibility as foo;\n "}, {"sha": "09759326afd911c69b942cddefb49a87c02332bc", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -12,7 +12,7 @@\n // exec-env:RUST_LOG=debug\n // compile-flags:-C debug-assertions=y\n \n-#![feature(old_io, rustc_private)]\n+#![feature(rustc_private)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "5eecf27db677bec2f0ec87f4add5a46ff439710e", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -13,9 +13,8 @@\n // temporary. Issue #19147.\n \n \n-#![feature(core, old_io)]\n+#![feature(core)]\n \n-use std::mem;\n use std::slice;\n \n pub type IoResult<T> = Result<T, ()>;"}, {"sha": "a155ee396b614bc917d1923cad9fe95b2ced0c9d", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -17,15 +17,13 @@\n // intact.\n \n // ignore-aarch64\n-#![feature(path, fs, os, io, old_path)]\n \n use std::io::prelude::*;\n use std::io;\n use std::fs;\n use std::process::Command;\n-use std::os;\n use std::env;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n fn main() {\n     let my_args = env::args().collect::<Vec<_>>();"}, {"sha": "db543116d17a5c3c040574a6c5a1a2937f2372d0", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -8,16 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(start, os, std_misc, old_io)]\n+#![feature(start, std_misc)]\n \n use std::ffi::CStr;\n use std::process::{Command, Output};\n-use std::os;\n use std::rt::unwind::try;\n-use std::rt;\n use std::str;\n-use std::thread::Thread;\n-use std::thunk::Thunk;\n \n #[start]\n fn start(argc: isize, argv: *const *const u8) -> isize {"}, {"sha": "542756d1c4ad9d2df02b47feb21a96acf4ec48cb", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -10,8 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, old_io, std_misc, io, set_panic, set_stdio)]\n+#![feature(box_syntax, set_stdio)]\n \n use std::io::prelude::*;\n use std::io;"}, {"sha": "d40d9c89f89dff05b683eecad1d7bd40621995c6", "filename": "src/test/run-pass/trait-coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=59171f8ec8dce11329ed9bfaa73d5bbcf88f9a09", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, old_io, io)]\n+#![feature(box_syntax)]\n \n use std::io::{self, Write};\n "}]}