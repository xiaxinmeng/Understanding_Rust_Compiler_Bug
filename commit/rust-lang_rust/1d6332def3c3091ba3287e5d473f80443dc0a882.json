{"sha": "1d6332def3c3091ba3287e5d473f80443dc0a882", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNjMzMmRlZjNjMzA5MWJhMzI4N2U1ZDQ3M2Y4MDQ0M2RjMGE4ODI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-06T01:08:43Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-14T11:36:51Z"}, "message": "rustc_mir: avoid having an Option around each local qualification in qualify_consts.", "tree": {"sha": "d605cf9affa7e7363eb68f774c48a8505dab2381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d605cf9affa7e7363eb68f774c48a8505dab2381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d6332def3c3091ba3287e5d473f80443dc0a882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6332def3c3091ba3287e5d473f80443dc0a882", "html_url": "https://github.com/rust-lang/rust/commit/1d6332def3c3091ba3287e5d473f80443dc0a882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d6332def3c3091ba3287e5d473f80443dc0a882/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2de5b389435d97fbb547c7393f400702f109594e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2de5b389435d97fbb547c7393f400702f109594e", "html_url": "https://github.com/rust-lang/rust/commit/2de5b389435d97fbb547c7393f400702f109594e"}], "stats": {"total": 107, "additions": 48, "deletions": 59}, "files": [{"sha": "25d201c3452d9be8af2142f32834760f944c9189", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1d6332def3c3091ba3287e5d473f80443dc0a882/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6332def3c3091ba3287e5d473f80443dc0a882/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=1d6332def3c3091ba3287e5d473f80443dc0a882", "patch": "@@ -117,8 +117,7 @@ struct Qualifier<'a, 'tcx> {\n     mode: Mode,\n     mir: &'a Mir<'tcx>,\n \n-    local_qualif: &'a IndexVec<Local, Option<Qualif>>,\n-    temp_promotion_state: &'a IndexVec<Local, TempState>,\n+    local_qualif: &'a IndexVec<Local, Qualif>,\n }\n \n impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n@@ -127,24 +126,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n     }\n \n     fn qualify_local(&self, local: Local) -> Qualif {\n-        let kind = self.mir.local_kind(local);\n-        match kind {\n-            LocalKind::ReturnPointer => Qualif::NOT_CONST,\n-            LocalKind::Var if self.mode == Mode::Fn => Qualif::NOT_CONST,\n-\n-            LocalKind::Var |\n-            LocalKind::Arg |\n-            LocalKind::Temp => {\n-                let mut qualif = self.local_qualif[local]\n-                    .unwrap_or(Qualif::NOT_CONST);\n-\n-                if !self.temp_promotion_state[local].is_promotable() {\n-                    qualif = qualif | Qualif::NOT_PROMOTABLE;\n-                }\n-\n-                qualif\n-            }\n-        }\n+        self.local_qualif[local]\n     }\n \n     fn qualify_projection_elem(&self, proj: &PlaceElem<'tcx>) -> Qualif {\n@@ -467,7 +449,7 @@ struct Checker<'a, 'tcx> {\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n \n-    local_qualif: IndexVec<Local, Option<Qualif>>,\n+    local_qualif: IndexVec<Local, Qualif>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>,\n }\n@@ -494,11 +476,22 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let param_env = tcx.param_env(def_id);\n \n-        let mut local_qualif = IndexVec::from_elem(None, &mir.local_decls);\n-        for arg in mir.args_iter() {\n-            let qualif = Qualif::any_value_of_ty(mir.local_decls[arg].ty, tcx, param_env);\n-            local_qualif[arg] = Some(Qualif::NOT_PROMOTABLE | qualif);\n-        }\n+        let local_qualif = mir.local_decls.iter_enumerated().map(|(local, decl)| {\n+            match mir.local_kind(local) {\n+                LocalKind::Arg => {\n+                    Qualif::any_value_of_ty(decl.ty, tcx, param_env) |\n+                        Qualif::NOT_PROMOTABLE\n+                }\n+\n+                LocalKind::Var if mode == Mode::Fn => Qualif::NOT_CONST,\n+\n+                LocalKind::Temp if !temps[local].is_promotable() => {\n+                    Qualif::NOT_PROMOTABLE\n+                }\n+\n+                _ => Qualif::empty(),\n+            }\n+        }).collect();\n \n         Checker {\n             mode,\n@@ -521,7 +514,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             mode: self.mode,\n             mir: self.mir,\n             local_qualif: &self.local_qualif,\n-            temp_promotion_state: &self.temp_promotion_state,\n         }\n     }\n \n@@ -559,10 +551,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 && self.temp_promotion_state[index].is_promotable() {\n                     debug!(\"store to promotable temp {:?} ({:?})\", index, qualif);\n                     let slot = &mut self.local_qualif[index];\n-                    if slot.is_some() {\n+                    if !slot.is_empty() {\n                         span_bug!(self.span, \"multiple assignments to {:?}\", dest);\n                     }\n-                    *slot = Some(qualif);\n+                    *slot = qualif;\n                 }\n             }\n             return;\n@@ -605,7 +597,18 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         // aggregates where we overwrite all fields via assignments, which would not get\n         // that feature.\n         let slot = &mut self.local_qualif[index];\n-        *slot = Some(slot.unwrap_or(Qualif::empty()) | qualif);\n+        *slot = *slot | qualif;\n+\n+        // Ensure we keep the `NOT_PROMOTABLE` flag is preserved.\n+        // NOTE(eddyb) this is actually unnecessary right now, as\n+        // we never replace the local's qualif (but we might in\n+        // the future) - also, if `NOT_PROMOTABLE` only matters\n+        // for `Mode::Fn`, then this is also pointless.\n+        if self.mir.local_kind(index) == LocalKind::Temp {\n+            if !self.temp_promotion_state[index].is_promotable() {\n+                *slot = *slot | Qualif::NOT_PROMOTABLE;\n+            }\n+        }\n     }\n \n     /// Check a whole const, static initializer or const fn.\n@@ -661,7 +664,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        let mut qualif = self.local_qualif[RETURN_PLACE].unwrap_or(Qualif::NOT_CONST);\n+        let mut qualif = self.local_qualif[RETURN_PLACE];\n \n         // Account for errors in consts by using the\n         // conservative type qualification instead.\n@@ -698,16 +701,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in `promotion_candidates`.\n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n-    fn visit_local(&mut self,\n-                   &local: &Local,\n-                   _: PlaceContext<'tcx>,\n-                   _: Location) {\n-        debug!(\"visit_local: local={:?}\", local);\n-        if self.local_qualif[local].is_none() {\n-            self.not_const();\n-        }\n-    }\n-\n     fn visit_place(&mut self,\n                     place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n@@ -833,9 +826,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n                 if let Place::Local(local) = *place {\n-                    self.local_qualif[local] = self.local_qualif[local].map(|q|\n-                        q - Qualif::NEEDS_DROP\n-                    );\n+                    let slot = &mut self.local_qualif[local];\n+                    *slot = *slot - Qualif::NEEDS_DROP;\n                 }\n             }\n             Operand::Copy(_) |\n@@ -1137,9 +1129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n-                    let local_needs_drop = self.local_qualif[local]\n-                        .map_or(true, |q| q.contains(Qualif::NEEDS_DROP));\n-                    if local_needs_drop {\n+                    if self.local_qualif[local].contains(Qualif::NEEDS_DROP) {\n                         Some(self.mir.local_decls[local].source_info.span)\n                     } else {\n                         None\n@@ -1223,18 +1213,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 if let Place::Local(local) = *place {\n                     if self.mir.local_kind(local) == LocalKind::Temp {\n                         debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                        if let Some(qualif) = self.local_qualif[local] {\n-                            // The borrowed place doesn't have `MUTABLE_INTERIOR`\n-                            // (from `qualify_rvalue`), so we can safely ignore\n-                            // `MUTABLE_INTERIOR` from the local's qualifications.\n-                            // This allows borrowing fields which don't have\n-                            // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n-                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                            debug!(\"qualify_consts: promotion candidate: qualif={:?}\", qualif);\n-                            if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n-                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                                self.promotion_candidates.push(candidate);\n-                            }\n+                        let qualif = self.local_qualif[local];\n+                        // The borrowed place doesn't have `MUTABLE_INTERIOR`\n+                        // (from `qualify_rvalue`), so we can safely ignore\n+                        // `MUTABLE_INTERIOR` from the local's qualifications.\n+                        // This allows borrowing fields which don't have\n+                        // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n+                        // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                        debug!(\"qualify_consts: promotion candidate: qualif={:?}\", qualif);\n+                        if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n+                            debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n+                            self.promotion_candidates.push(candidate);\n                         }\n                     }\n                 }"}]}