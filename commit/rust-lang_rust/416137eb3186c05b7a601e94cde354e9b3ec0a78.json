{"sha": "416137eb3186c05b7a601e94cde354e9b3ec0a78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNjEzN2ViMzE4NmMwNWI3YTYwMWU5NGNkZTM1NGU5YjNlYzBhNzg=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-02T22:44:21Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-06T02:21:14Z"}, "message": "Modernize macro_rules! invocations\n\nmacro_rules! is like an item that defines a macro.  Other items don't have a\ntrailing semicolon, or use a paren-delimited body.\n\nIf there's an argument for matching the invocation syntax, e.g. parentheses for\nan expr macro, then I think that applies more strongly to the *inner*\ndelimiters on the LHS, wrapping the individual argument patterns.", "tree": {"sha": "260833d9b39aeb89c395722fb43c8b51f8dcd3a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/260833d9b39aeb89c395722fb43c8b51f8dcd3a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/416137eb3186c05b7a601e94cde354e9b3ec0a78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/416137eb3186c05b7a601e94cde354e9b3ec0a78", "html_url": "https://github.com/rust-lang/rust/commit/416137eb3186c05b7a601e94cde354e9b3ec0a78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/416137eb3186c05b7a601e94cde354e9b3ec0a78/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9f0ff3813a662197e262e64edb8302d2b4a3e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f0ff3813a662197e262e64edb8302d2b4a3e75", "html_url": "https://github.com/rust-lang/rust/commit/c9f0ff3813a662197e262e64edb8302d2b4a3e75"}], "stats": {"total": 692, "additions": 361, "deletions": 331}, "files": [{"sha": "2e8bce3f5064b6d2c3e9180756c76bb756d1b579", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -268,7 +268,7 @@ fn main() {\n         assert!(rustc_tok.sp == antlr_tok.sp, \"{} and {} have different spans\", rustc_tok,\n                 antlr_tok);\n \n-        macro_rules! matches (\n+        macro_rules! matches {\n             ( $($x:pat),+ ) => (\n                 match rustc_tok.tok {\n                     $($x => match antlr_tok.tok {\n@@ -284,7 +284,7 @@ fn main() {\n                     ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n                 }\n             )\n-        );\n+        }\n \n         matches!(\n             token::Literal(token::Byte(..), _),"}, {"sha": "6a9abfbd22ee5ca4e51beeacc6625e05df245b87", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -2460,13 +2460,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        macro_rules! test_show_vec(\n+        macro_rules! test_show_vec {\n             ($x:expr, $x_str:expr) => ({\n                 let (x, x_str) = ($x, $x_str);\n                 assert_eq!(format!(\"{}\", x), x_str);\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n-        );\n+        }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1i], \"[1]\");\n@@ -2486,12 +2486,12 @@ mod tests {\n \n     #[test]\n     fn test_vec_default() {\n-        macro_rules! t (\n+        macro_rules! t {\n             ($ty:ty) => {{\n                 let v: $ty = Default::default();\n                 assert!(v.is_empty());\n             }}\n-        );\n+        }\n \n         t!(&[int]);\n         t!(Vec<int>);"}, {"sha": "69403ccd88be8b874770dd75c374c5f405f217fb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -1838,7 +1838,9 @@ mod tests {\n     #[test]\n     fn test_is_utf16() {\n         use unicode::str::is_utf16;\n-        macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n+        macro_rules! pos {\n+            ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } }\n+        }\n \n         // non-surrogates\n         pos!(&[0x0000],\n@@ -1858,7 +1860,9 @@ mod tests {\n              &[0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n \n         // negative tests\n-        macro_rules! neg ( ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } });\n+        macro_rules! neg {\n+            ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } }\n+        }\n \n         neg!(\n             // surrogate + regular unit"}, {"sha": "8fe636f8cd392d64d5053ae2825576ae3f8a35f3", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -182,15 +182,15 @@ impl String {\n             let byte = unsafe_get(v, i);\n             i += 1;\n \n-            macro_rules! error(() => ({\n+            macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n                         res.as_mut_vec().push_all(v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n                 }\n-            }));\n+            })}\n \n             if byte < 128u8 {\n                 // subseqidx handles this"}, {"sha": "3ed0116c28911271dbff4652546e7081da6e7473", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -220,9 +220,9 @@\n //!\n //! ```\n //! # #![feature(macro_rules)]\n-//! macro_rules! try(\n+//! macro_rules! try {\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-//! );\n+//! }\n //! # fn main() { }\n //! ```\n //!"}, {"sha": "02887024d00cb6aba14eaa3d4b57c84ed3ed1b98", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -948,17 +948,18 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         let old = *iter;\n \n         // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err (() => { {\n+        macro_rules! err { () => {{\n             *iter = old;\n             return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n-        } });\n-        macro_rules! next ( () => {\n+        }}}\n+\n+        macro_rules! next { () => {\n             match iter.next() {\n                 Some(a) => *a,\n                 // we needed data, but there was none: error!\n                 None => return Err(Utf8Error::TooShort),\n             }\n-        });\n+        }}\n \n         let first = match iter.next() {\n             Some(&b) => b,"}, {"sha": "b98432e26b215c739066af43918ea4f20ee76f8e", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! int_module (($T:ty, $T_i:ident) => (\n+macro_rules! int_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n@@ -203,4 +203,4 @@ mod tests {\n     }\n }\n \n-));\n+)}"}, {"sha": "04d8fb15cf5aa41715d3043adf44c0fc95805c23", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! uint_module (($T:ty, $T_i:ident) => (\n+macro_rules! uint_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n@@ -123,4 +123,5 @@ mod tests {\n         assert!(5u.checked_div(0) == None);\n     }\n }\n-));\n+\n+)}"}, {"sha": "2fdba8a6c4f960358a1c064d4d6ec7561cdb06ef", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -297,7 +297,7 @@ mod tests {\n         // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n         // 1, internally; modulo a modulo operation).\n \n-        macro_rules! t (\n+        macro_rules! t {\n             ($items:expr, $expected:expr) => {{\n                 let mut items = $items;\n                 let wc = WeightedChoice::new(items.as_mut_slice());\n@@ -309,7 +309,7 @@ mod tests {\n                     assert_eq!(wc.ind_sample(&mut rng), val)\n                 }\n             }}\n-        );\n+        }\n \n         t!(vec!(Weighted { weight: 1, item: 10i}), [10]);\n "}, {"sha": "1038009522d67313af1e85c46f03d166a2f9222e", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -182,7 +182,7 @@ mod tests {\n     #[test]\n     fn test_integers() {\n         let mut rng = ::test::rng();\n-        macro_rules! t (\n+        macro_rules! t {\n             ($($ty:ty),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0, 10),\n@@ -199,15 +199,15 @@ mod tests {\n                     }\n                  )*\n             }}\n-        );\n+        }\n         t!(i8, i16, i32, i64, int,\n            u8, u16, u32, u64, uint)\n     }\n \n     #[test]\n     fn test_floats() {\n         let mut rng = ::test::rng();\n-        macro_rules! t (\n+        macro_rules! t {\n             ($($ty:ty),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0.0, 100.0),\n@@ -225,7 +225,7 @@ mod tests {\n                     }\n                  )*\n             }}\n-        );\n+        }\n \n         t!(f32, f64)\n     }"}, {"sha": "698730302b9ca49888e92e0db3450c2dfaa01e67", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -69,7 +69,7 @@ impl IsaacRng {\n         let mut g = a;\n         let mut h = a;\n \n-        macro_rules! mix(\n+        macro_rules! mix {\n             () => {{\n                 a^=b<<11; d+=a; b+=c;\n                 b^=c>>2;  e+=b; c+=d;\n@@ -80,14 +80,14 @@ impl IsaacRng {\n                 g^=h<<8;  b+=g; h+=a;\n                 h^=a>>9;  c+=h; a+=b;\n             }}\n-        );\n+        }\n \n         for _ in range(0u, 4) {\n             mix!();\n         }\n \n         if use_rsl {\n-            macro_rules! memloop (\n+            macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range_step(0, RAND_SIZE as uint, 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n@@ -101,7 +101,7 @@ impl IsaacRng {\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n-            );\n+            }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n@@ -129,41 +129,42 @@ impl IsaacRng {\n \n         static MIDPOINT: uint = (RAND_SIZE / 2) as uint;\n \n-        macro_rules! ind (($x:expr) => {\n-            self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))]\n-        });\n+        macro_rules! ind {\n+            ($x:expr) => ( self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))] )\n+        }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for &(mr_offset, m2_offset) in r.iter() {\n \n-            macro_rules! rngstepp(\n+            macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n-                        let base = $j;\n-                        let mix = a << $shift as uint;\n+                    let base = $j;\n+                    let mix = a << $shift as uint;\n \n-                        let x = self.mem[base  + mr_offset];\n-                        a = (a ^ mix) + self.mem[base + m2_offset];\n-                        let y = ind!(x) + a + b;\n-                        self.mem[base + mr_offset] = y;\n+                    let x = self.mem[base  + mr_offset];\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                        self.rsl[base + mr_offset] = b;\n-                    }}\n-                );\n-            macro_rules! rngstepn(\n+                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    self.rsl[base + mr_offset] = b;\n+                }}\n+            }\n+\n+            macro_rules! rngstepn {\n                 ($j:expr, $shift:expr) => {{\n-                        let base = $j;\n-                        let mix = a >> $shift as uint;\n+                    let base = $j;\n+                    let mix = a >> $shift as uint;\n \n-                        let x = self.mem[base  + mr_offset];\n-                        a = (a ^ mix) + self.mem[base + m2_offset];\n-                        let y = ind!(x) + a + b;\n-                        self.mem[base + mr_offset] = y;\n+                    let x = self.mem[base  + mr_offset];\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                        self.rsl[base + mr_offset] = b;\n-                    }}\n-                );\n+                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    self.rsl[base + mr_offset] = b;\n+                }}\n+            }\n \n             for i in range_step(0u, MIDPOINT, 4) {\n                 rngstepp!(i + 0, 13);\n@@ -294,15 +295,15 @@ impl Isaac64Rng {\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n-        macro_rules! init (\n+        macro_rules! init {\n             ($var:ident) => (\n                 let mut $var = 0x9e3779b97f4a7c13;\n             )\n-        );\n+        }\n         init!(a); init!(b); init!(c); init!(d);\n         init!(e); init!(f); init!(g); init!(h);\n \n-        macro_rules! mix(\n+        macro_rules! mix {\n             () => {{\n                 a-=e; f^=h>>9;  h+=a;\n                 b-=f; g^=a<<9;  a+=b;\n@@ -313,14 +314,14 @@ impl Isaac64Rng {\n                 g-=c; d^=f>>17; f+=g;\n                 h-=d; e^=g<<14; g+=h;\n             }}\n-        );\n+        }\n \n         for _ in range(0u, 4) {\n             mix!();\n         }\n \n         if use_rsl {\n-            macro_rules! memloop (\n+            macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n@@ -334,7 +335,7 @@ impl Isaac64Rng {\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n-            );\n+            }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n@@ -359,49 +360,51 @@ impl Isaac64Rng {\n         let mut b = self.b + self.c;\n         const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n         const MP_VEC: [(uint, uint); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n-        macro_rules! ind (\n+        macro_rules! ind {\n             ($x:expr) => {\n                 *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n-        );\n+        }\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n             for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n \n-                macro_rules! rngstepp(\n+                macro_rules! rngstepp {\n                     ($j:expr, $shift:expr) => {{\n-                            let base = base + $j;\n-                            let mix = a ^ (a << $shift as uint);\n-                            let mix = if $j == 0 {!mix} else {mix};\n-\n-                            unsafe {\n-                                let x = *self.mem.get_unchecked(base + mr_offset);\n-                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                                let y = ind!(x) + a + b;\n-                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                            }\n-                        }}\n-                    );\n-                macro_rules! rngstepn(\n+                        let base = base + $j;\n+                        let mix = a ^ (a << $shift as uint);\n+                        let mix = if $j == 0 {!mix} else {mix};\n+\n+                        unsafe {\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                        }\n+                    }}\n+                }\n+\n+                macro_rules! rngstepn {\n                     ($j:expr, $shift:expr) => {{\n-                            let base = base + $j;\n-                            let mix = a ^ (a >> $shift as uint);\n-                            let mix = if $j == 0 {!mix} else {mix};\n-\n-                            unsafe {\n-                                let x = *self.mem.get_unchecked(base + mr_offset);\n-                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                                let y = ind!(x) + a + b;\n-                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                            }\n-                        }}\n-                    );\n+                        let base = base + $j;\n+                        let mix = a ^ (a >> $shift as uint);\n+                        let mix = if $j == 0 {!mix} else {mix};\n+\n+                        unsafe {\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                        }\n+                    }}\n+                }\n+\n                 rngstepp!(0u, 21);\n                 rngstepn!(1u, 5);\n                 rngstepp!(2u, 12);"}, {"sha": "c070bed2be23d2bdb7413daaa2c8e03fd24d1794", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -167,21 +167,27 @@ impl LintStore {\n     }\n \n     pub fn register_builtin(&mut self, sess: Option<&Session>) {\n-        macro_rules! add_builtin ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                self.register_pass($sess, false, box builtin::$name as LintPassObject);\n-            )*}\n-        ));\n-\n-        macro_rules! add_builtin_with_new ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n-            )*}\n-        ));\n-\n-        macro_rules! add_lint_group ( ( $sess:ident, $name:expr, $($lint:ident),* ) => (\n-            self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n-        ));\n+        macro_rules! add_builtin {\n+            ($sess:ident, $($name:ident),*,) => (\n+                {$(\n+                    self.register_pass($sess, false, box builtin::$name as LintPassObject);\n+                )*}\n+            )\n+        }\n+\n+        macro_rules! add_builtin_with_new {\n+            ($sess:ident, $($name:ident),*,) => (\n+                {$(\n+                    self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n+                )*}\n+            )\n+        }\n+\n+        macro_rules! add_lint_group {\n+            ($sess:ident, $name:expr, $($lint:ident),*) => (\n+                self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n+            )\n+        }\n \n         add_builtin!(sess,\n                      HardwiredLints,"}, {"sha": "f50d629dae7896191a030fd03a02dee3f69103e5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -503,7 +503,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                                         \"target type not found for const cast\")\n                 });\n \n-        macro_rules! define_casts(\n+        macro_rules! define_casts {\n             ($val:ident, {\n                 $($ty_pat:pat => (\n                     $intermediate_ty:ty,\n@@ -524,7 +524,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                 },)*\n                 _ => Err(\"can't cast this type\".to_string())\n             })\n-        );\n+        }\n \n         eval_const_expr_partial(tcx, &**base)\n             .and_then(|val| define_casts!(val, {"}, {"sha": "b1098c5d9f7a14d9ca3021a4eda79f6d7c000f04", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -6237,8 +6237,8 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n     return state.result();\n \n     fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n-        macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n-        macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n+        macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n+        macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n \n         let region = |&: state: &mut sip::SipState, r: Region| {\n             match r {"}, {"sha": "d606c5158d0f7d930ae003664e2ac4cee9f47f59", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -346,12 +346,12 @@ impl Engine256State {\n \n         // Sha-512 and Sha-256 use basically the same calculations which are implemented\n         // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n+        macro_rules! schedule_round { ($t:expr) => (\n                 w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n                 )\n-        );\n+        }\n \n-        macro_rules! sha2_round(\n+        macro_rules! sha2_round {\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n              $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n                 {\n@@ -360,7 +360,7 @@ impl Engine256State {\n                     $H += sum0($A) + maj($A, $B, $C);\n                 }\n              )\n-        );\n+        }\n \n         read_u32v_be(w.slice_mut(0, 16), data);\n "}, {"sha": "f14583bb9aa81b23282861f47019b9786790d6ce", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -239,7 +239,7 @@ impl Target {\n             options: Default::default(),\n         };\n \n-        macro_rules! key (\n+        macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 obj.find(name[]).map(|o| o.as_string()\n@@ -257,7 +257,7 @@ impl Target {\n                         )\n                     );\n             } );\n-        );\n+        }\n \n         key!(cpu);\n         key!(linker);\n@@ -305,7 +305,7 @@ impl Target {\n         }\n \n         // this would use a match if stringify! were allowed in pattern position\n-        macro_rules! load_specific (\n+        macro_rules! load_specific {\n             ( $($name:ident),+ ) => (\n                 {\n                     let target = target.replace(\"-\", \"_\");\n@@ -326,7 +326,7 @@ impl Target {\n                     }\n                 }\n             )\n-        );\n+        }\n \n         load_specific!(\n             x86_64_unknown_linux_gnu,"}, {"sha": "b121dbec011c9e5acc4551da001671027fc6fd5d", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -741,7 +741,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n-    macro_rules! ifn (\n+    macro_rules! ifn {\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(\n@@ -759,10 +759,10 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    );\n-    macro_rules! mk_struct (\n+    }\n+    macro_rules! mk_struct {\n         ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n-    );\n+    }\n \n     let i8p = Type::i8p(ccx);\n     let void = Type::void(ccx);\n@@ -883,7 +883,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n     // were introduced in LLVM 3.4, so we case on that.\n-    macro_rules! compatible_ifn (\n+    macro_rules! compatible_ifn {\n         ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n                 // The `if key == $name` is already in ifn!\n@@ -896,7 +896,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    );\n+    }\n \n     compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n     compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);"}, {"sha": "a78dfe3edceda825507f5bc5bf9dbee44d9f3f6e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -558,7 +558,7 @@ mod tests {\n         t!(b\"foo/\\xFFbar\", filename_display, \"\\u{FFFD}bar\");\n         t!(b\"/\", filename_display, \"\");\n \n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -573,7 +573,7 @@ mod tests {\n                     assert!(mo.as_slice() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"foo\", \"foo\");\n         t!(b\"foo\\x80\", \"foo\\u{FFFD}\");\n@@ -585,7 +585,7 @@ mod tests {\n \n     #[test]\n     fn test_display() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -595,7 +595,7 @@ mod tests {\n                     assert!(f == $expf);\n                 }\n             )\n-        );\n+        }\n \n         t!(b\"foo\", \"foo\", \"foo\");\n         t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n@@ -608,7 +608,7 @@ mod tests {\n \n     #[test]\n     fn test_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -629,7 +629,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n         t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n@@ -692,7 +692,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr) => (\n                 {\n                     let path = $path;\n@@ -703,7 +703,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"..\");\n         t!(s: \"/a/b/c\", \"d\");\n@@ -713,7 +713,7 @@ mod tests {\n \n     #[test]\n     fn test_push_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -722,7 +722,7 @@ mod tests {\n                     assert!(p.as_str() == Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -734,7 +734,7 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -749,7 +749,7 @@ mod tests {\n                     assert!(p.as_vec() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n@@ -762,7 +762,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -779,7 +779,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", b\"a/b\", true);\n         t!(b: b\"a\", b\".\", true);\n@@ -818,7 +818,7 @@ mod tests {\n \n     #[test]\n     fn test_join_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -827,7 +827,7 @@ mod tests {\n                     assert!(res.as_str() == Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"..\", \"a/b\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -839,7 +839,7 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -854,7 +854,7 @@ mod tests {\n                     assert!(res.as_vec() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n@@ -917,7 +917,7 @@ mod tests {\n \n     #[test]\n     fn test_setters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n@@ -938,7 +938,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n@@ -961,7 +961,7 @@ mod tests {\n \n     #[test]\n     fn test_getters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n@@ -992,7 +992,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n         t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n@@ -1031,15 +1031,15 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $abs:expr, $rel:expr) => (\n                 {\n                     let path = Path::new($path);\n                     assert_eq!(path.is_absolute(), $abs);\n                     assert_eq!(path.is_relative(), $rel);\n                 }\n             )\n-        );\n+        }\n         t!(s: \"a/b/c\", false, true);\n         t!(s: \"/a/b/c\", true, false);\n         t!(s: \"a\", false, true);\n@@ -1052,15 +1052,15 @@ mod tests {\n \n     #[test]\n     fn test_is_ancestor_of() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let dest = Path::new($dest);\n                     assert_eq!(path.is_ancestor_of(&dest), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"a/b/c/d\", true);\n         t!(s: \"a/b/c\", \"a/b/c\", true);\n@@ -1086,7 +1086,7 @@ mod tests {\n \n     #[test]\n     fn test_ends_with_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1101,7 +1101,7 @@ mod tests {\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"c\", true);\n         t!(s: \"a/b/c\", \"d\", false);\n@@ -1125,7 +1125,7 @@ mod tests {\n \n     #[test]\n     fn test_path_relative_from() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1134,7 +1134,7 @@ mod tests {\n                     assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n         t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n@@ -1170,7 +1170,7 @@ mod tests {\n \n     #[test]\n     fn test_components_iter() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1196,7 +1196,7 @@ mod tests {\n                     assert_eq!(comps, exp)\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n@@ -1216,7 +1216,7 @@ mod tests {\n \n     #[test]\n     fn test_str_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (b: $arg:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($arg);\n@@ -1228,7 +1228,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n         t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);"}, {"sha": "30ed07446a4004496f2f153c493da76d0c1ee9c6", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -1149,7 +1149,7 @@ mod tests {\n \n     #[test]\n     fn test_parse_prefix() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = $path;\n@@ -1159,7 +1159,7 @@ mod tests {\n                             \"parse_prefix(\\\"{}\\\"): expected {}, found {}\", path, exp, res);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"\\\\\\\\SERVER\\\\share\\\\foo\", Some(UNCPrefix(6,5)));\n         t!(\"\\\\\\\\\", None);\n@@ -1348,7 +1348,7 @@ mod tests {\n \n     #[test]\n     fn test_display() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1358,7 +1358,7 @@ mod tests {\n                     assert_eq!(f, $expf);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"foo\", \"foo\", \"foo\");\n         t!(\"foo\\\\bar\", \"foo\\\\bar\", \"bar\");\n@@ -1367,7 +1367,7 @@ mod tests {\n \n     #[test]\n     fn test_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = $path;\n@@ -1390,7 +1390,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n@@ -1490,7 +1490,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr) => (\n                 {\n                     let path = $path;\n@@ -1501,7 +1501,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"..\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n@@ -1525,7 +1525,7 @@ mod tests {\n \n     #[test]\n     fn test_push_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -1534,7 +1534,7 @@ mod tests {\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1577,7 +1577,7 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -1592,7 +1592,7 @@ mod tests {\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n@@ -1606,7 +1606,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let pstr = $path;\n@@ -1627,7 +1627,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", true);\n         t!(s: \"a\", \".\", true);\n@@ -1695,7 +1695,7 @@ mod tests {\n \n     #[test]\n     fn test_join_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1704,7 +1704,7 @@ mod tests {\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"..\", \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1718,7 +1718,7 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1733,7 +1733,7 @@ mod tests {\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n@@ -1746,7 +1746,7 @@ mod tests {\n \n     #[test]\n     fn test_with_helpers() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n                 {\n                     let pstr = $path;\n@@ -1759,7 +1759,7 @@ mod tests {\n                             pstr, stringify!($op), arg, exp, res.as_str().unwrap());\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n         t!(s: \".\", with_filename, \"foo\", \"foo\");\n@@ -1831,7 +1831,7 @@ mod tests {\n \n     #[test]\n     fn test_setters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n@@ -1852,7 +1852,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n@@ -1876,7 +1876,7 @@ mod tests {\n \n     #[test]\n     fn test_getters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n@@ -1907,7 +1907,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n@@ -1942,7 +1942,7 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1961,7 +1961,7 @@ mod tests {\n                             path.as_str().unwrap(), rel, b);\n                 }\n             )\n-        );\n+        }\n         t!(\"a\\\\b\\\\c\", false, false, false, true);\n         t!(\"\\\\a\\\\b\\\\c\", false, true, false, false);\n         t!(\"a\", false, false, false, true);\n@@ -1982,7 +1982,7 @@ mod tests {\n \n     #[test]\n     fn test_is_ancestor_of() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1994,7 +1994,7 @@ mod tests {\n                             path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", true);\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n@@ -2085,15 +2085,15 @@ mod tests {\n \n     #[test]\n     fn test_ends_with_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"c\", true);\n         t!(s: \"a\\\\b\\\\c\", \"d\", false);\n@@ -2117,7 +2117,7 @@ mod tests {\n \n     #[test]\n     fn test_path_relative_from() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2130,7 +2130,7 @@ mod tests {\n                             res.as_ref().and_then(|x| x.as_str()));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", Some(\"..\\\\c\"));\n@@ -2251,7 +2251,7 @@ mod tests {\n \n     #[test]\n     fn test_str_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2265,7 +2265,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n@@ -2309,7 +2309,7 @@ mod tests {\n \n     #[test]\n     fn test_components_iter() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2321,7 +2321,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(s: \".\", [b\".\"]);\n@@ -2330,7 +2330,7 @@ mod tests {\n \n     #[test]\n     fn test_make_non_verbatim() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2339,7 +2339,7 @@ mod tests {\n                     assert!(make_non_verbatim(&path) == exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(r\"\\a\\b\\c\", Some(r\"\\a\\b\\c\"));\n         t!(r\"a\\b\\c\", Some(r\"a\\b\\c\"));"}, {"sha": "1b1bc6d281a2f2f944c744d36d180dafb2241685", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -61,7 +61,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n             cx, span, substr)\n     }\n \n-    macro_rules! md (\n+    macro_rules! md {\n         ($name:expr, $f:ident) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n             let attrs = vec!(cx.attribute(span, inline));\n@@ -77,7 +77,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n                 })\n             }\n         } }\n-    );\n+    }\n \n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "7353ddc172015d22fc6288665d2743dfbff8ca37", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                               push: F) where\n     F: FnOnce(P<Item>),\n {\n-    macro_rules! md (\n+    macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n             let attrs = vec!(cx.attribute(span, inline));\n@@ -43,7 +43,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                 })\n             }\n         } }\n-    );\n+    }\n \n     let ordering_ty = Literal(Path::new(vec![\"std\", \"cmp\", \"Ordering\"]));\n     let ret_ty = Literal(Path::new_(vec![\"std\", \"option\", \"Option\"],"}, {"sha": "e72c83b67c89be435404aea043c5b9b6d0f54f62", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -71,9 +71,11 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                     MetaNameValue(ref tname, _) |\n                     MetaList(ref tname, _) |\n                     MetaWord(ref tname) => {\n-                        macro_rules! expand(($func:path) => ($func(cx, titem.span,\n-                                                                   &**titem, item,\n-                                                                   |i| push.call_mut((i,)))));\n+                        macro_rules! expand {\n+                            ($func:path) => ($func(cx, titem.span, &**titem, item,\n+                                                   |i| push.call_mut((i,))))\n+                        }\n+\n                         match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n "}, {"sha": "9837c8088fa4507a38f6ec9a523384009787d53c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -38,8 +38,8 @@ impl<'a> ParserAnyMacro<'a> {\n     /// Make sure we don't have any tokens left to parse, so we don't\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n     /// semicolons at the end of normal expressions aren't complained\n-    /// about e.g. the semicolon in `macro_rules! kapow( () => {\n-    /// panic!(); } )` doesn't get picked up by .parse_expr(), but it's\n+    /// about e.g. the semicolon in `macro_rules! kapow { () => {\n+    /// panic!(); } }` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();"}, {"sha": "5f0111c7d7a84de51191dff892f86531c099cc44", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -160,12 +160,12 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader, longnames: bool)\n              -> Result<Box<TermInfo>, String> {\n-    macro_rules! try( ($e:expr) => (\n+    macro_rules! try { ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n             Err(e) => return Err(format!(\"{}\", e))\n         }\n-    ) );\n+    ) }\n \n     let bnames;\n     let snames;"}, {"sha": "5eb6b0de3de94ad75f8fb29e6e2b72438ddc579d", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -180,16 +180,16 @@ pub struct FrozenTupleStruct(pub int);\n pub struct LockedTupleStruct(pub int);\n \n #[macro_export]\n-macro_rules! macro_test(\n+macro_rules! macro_test {\n     () => (deprecated());\n-);\n+}\n \n #[macro_export]\n-macro_rules! macro_test_arg(\n+macro_rules! macro_test_arg {\n     ($func:expr) => ($func);\n-);\n+}\n \n #[macro_export]\n-macro_rules! macro_test_arg_nested(\n+macro_rules! macro_test_arg_nested {\n     ($func:ident) => (macro_test_arg!($func()));\n-);\n+}"}, {"sha": "c323eb0c44624dc37bc82c8aedbf847dc8821aea", "filename": "src/test/auxiliary/macro_crate_def_only.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -11,6 +11,6 @@\n #![feature(macro_rules)]\n \n #[macro_export]\n-macro_rules! make_a_5(\n+macro_rules! make_a_5 {\n     () => (5)\n-);\n+}"}, {"sha": "418a7c6e538edbe8cb313e23c452863b3c7dbc4e", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -24,9 +24,9 @@ use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n #[macro_export]\n-macro_rules! exported_macro (() => (2i));\n+macro_rules! exported_macro { () => (2i) }\n \n-macro_rules! unexported_macro (() => (3i));\n+macro_rules! unexported_macro { () => (3i) }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "fb98637811d7239cd09f2082faed00638df35640", "filename": "src/test/auxiliary/macro_export_inner_module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,7 +12,7 @@\n \n pub mod inner {\n     #[macro_export]\n-    macro_rules! foo(\n+    macro_rules! foo {\n         () => (1)\n-    );\n+    }\n }"}, {"sha": "21e55384f46bf50fc5820bc8de0e2b1578d27c6d", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -28,11 +28,12 @@ fn main() {\n     let argv = os::args();\n     let _tests = argv.slice(1, argv.len());\n \n-    macro_rules! bench (\n+    macro_rules! bench {\n         ($id:ident) =>\n             (maybe_run_test(argv.as_slice(),\n                             stringify!($id).to_string(),\n-                            $id)));\n+                            $id))\n+    }\n \n     bench!(shift_push);\n     bench!(read_line);"}, {"sha": "dea0c60d91b7fe53da4b506af17ab152909b47ce", "filename": "src/test/compile-fail/gated-macro-rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fgated-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fgated-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-macro-rules.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! foo(() => ());\n+macro_rules! foo { () => () }\n //~^ ERROR: macro definitions are not stable enough for use\n \n fn main() {}"}, {"sha": "22011f192356bd01f2628f8cb50a506e181db68f", "filename": "src/test/compile-fail/infinite-macro-expansion.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,11 +10,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! recursive(\n-      () => (\n-                recursive!() //~ ERROR recursion limit reached while expanding the macro `recursive`\n-              )\n-      );\n+macro_rules! recursive {\n+    () => (recursive!()) //~ ERROR recursion limit reached while expanding the macro `recursive`\n+}\n \n fn main() {\n     recursive!()"}, {"sha": "cb1079197334027183c5991d4077209f5394c5be", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -17,7 +17,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! f(() => (n))\n+macro_rules! f { () => (n) }\n \n fn main() -> (){\n     for n in range(0i, 1) {"}, {"sha": "b237b4259184f9fa8c6e5462bbb8a52029392eef", "filename": "src/test/compile-fail/issue-6596.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,11 +12,11 @@\n \n // error-pattern: unexpected token\n \n-macro_rules! e(\n+macro_rules! e {\n     ($inp:ident) => (\n         $nonexistent\n     );\n-);\n+}\n \n fn main() {\n     e!(foo);"}, {"sha": "cdcb0859ed950bb915ec7822c3245c9490578617", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! test ( () => { fn foo() -> int { 1i; } } );\n+macro_rules! test { () => { fn foo() -> int { 1i; } } }\n                                              //~^ ERROR not all control paths return a value\n                                              //~^^ HELP consider removing this semicolon\n "}, {"sha": "8d2f49ecc7f53de2469886c51169f322f1bce6e7", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,9 +10,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! test ( ($nm:ident,\n+macro_rules! test { ($nm:ident,\n                      #[$a:meta],\n-                     $i:item) => (mod $nm { #![$a] $i }); );\n+                     $i:item) => (mod $nm { #![$a] $i }); }\n \n test!(a,\n       #[cfg(qux)],"}, {"sha": "8bfaac1770d96202a4149abcd3619554c12e4b26", "filename": "src/test/compile-fail/macro-match-nonterminal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! test ( ($a, $b) => (()); ); //~ ERROR Cannot transcribe\n+macro_rules! test { ($a, $b) => (()); } //~ ERROR Cannot transcribe\n \n fn main() {\n     test!()"}, {"sha": "4f2c097eca94f7934e0fc480d74302e0859092bd", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,9 +10,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! test ( ($nm:ident,\n+macro_rules! test { ($nm:ident,\n                      #[$a:meta],\n-                     $i:item) => (mod $nm { #[$a] $i }); );\n+                     $i:item) => (mod $nm { #[$a] $i }); }\n \n test!(a,\n       #[cfg(qux)],"}, {"sha": "314292085dfe61ab5ca34a90aeb5cb134ab28c56", "filename": "src/test/compile-fail/macros-no-semicolon-items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,4 +12,3 @@ macro_rules! foo()  //~ ERROR semicolon\n \n fn main() {\n }\n-"}, {"sha": "56087c79799f6dfe676995799edabe98cd8b6005", "filename": "src/test/compile-fail/method-macro-backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,9 +12,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! make_method ( ($name:ident) => (\n-    fn $name(&self) { }\n-));\n+macro_rules! make_method {\n+    ($name:ident) => ( fn $name(&self) { } )\n+}\n \n struct S;\n "}, {"sha": "64f810c1c95e75ef55286976378f0c5727b0e0bf", "filename": "src/test/compile-fail/pattern-macro-hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! foo ( () => ( x ) );\n+macro_rules! foo { () => ( x ) }\n \n fn main() {\n     let foo!() = 2;"}, {"sha": "bd42cc94a339309d18d7696d564aa473798a6623", "filename": "src/test/run-pass/borrowck-macro-interaction-issue-6304.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -24,12 +24,12 @@ pub enum Bar {\n \n impl Foo {\n   fn elaborate_stm(&mut self, s: Box<Bar>) -> Box<Bar> {\n-    macro_rules! declare(\n+    macro_rules! declare {\n       ($id:expr, $rest:expr) => ({\n         self.check_id($id);\n         box Bar::Bar2($id, $rest)\n       })\n-    );\n+    }\n     match s {\n       box Bar::Bar2(id, rest) => declare!(id, self.elaborate_stm(rest)),\n       _ => panic!()"}, {"sha": "fe74956fd1e40baa960fef0e86933048ea145e58", "filename": "src/test/run-pass/cleanup-rvalue-scopes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -61,7 +61,7 @@ impl Drop for AddFlags {\n     }\n }\n \n-macro_rules! end_of_block(\n+macro_rules! end_of_block {\n     ($pat:pat, $expr:expr) => (\n         {\n             println!(\"end_of_block({})\", stringify!({let $pat = $expr;}));\n@@ -74,9 +74,9 @@ macro_rules! end_of_block(\n             check_flags(1);\n         }\n     )\n-);\n+}\n \n-macro_rules! end_of_stmt(\n+macro_rules! end_of_stmt {\n     ($pat:pat, $expr:expr) => (\n         {\n             println!(\"end_of_stmt({})\", stringify!($expr));\n@@ -91,7 +91,7 @@ macro_rules! end_of_stmt(\n             check_flags(0);\n         }\n     )\n-);\n+}\n \n pub fn main() {\n "}, {"sha": "51647aebcf85d3c21c73a4aee33dce9183dce3d2", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,14 +10,14 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! assert_approx_eq(\n+macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-);\n+}\n \n static A: int = -4 + 3;\n static A2: uint = 3 + 3;"}, {"sha": "33564af2d7d207f095901c08488b3e91a558efad", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -26,9 +26,9 @@ use std::str;\n use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n-macro_rules! succeed( ($e:expr) => (\n+macro_rules! succeed { ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => panic!(\"panic: {}\", e) }\n-) );\n+) }\n \n fn test_destroy_once() {\n     let mut p = sleeper();"}, {"sha": "162de18f581ab1a97020b9f4db150f3c09e34cc4", "filename": "src/test/run-pass/deriving-in-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,14 +10,14 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! define_vec (\n+macro_rules! define_vec {\n     () => (\n         mod foo {\n             #[derive(PartialEq)]\n             pub struct bar;\n         }\n     )\n-);\n+}\n \n define_vec!();\n "}, {"sha": "6addbf693548f396e4b4621d950f9882618125ee", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -15,7 +15,9 @@ use std::num::strconv::SignificantDigits::DigMax;\n use std::num::strconv::SignFormat::{SignAll, SignNeg};\n use std::num::strconv::float_to_str_common as to_string;\n \n-macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } });\n+macro_rules! t {\n+    ($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } }\n+}\n \n pub fn main() {\n     // Basic usage"}, {"sha": "6f6a429db172e3ed3974f88538f0224fa3a0ead9", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -27,13 +27,13 @@ left.\n */\n use HTMLFragment::{tag, text};\n \n-macro_rules! html (\n+macro_rules! html {\n     ( $($body:tt)* ) => (\n         parse_node!( []; []; $($body)* )\n     )\n-);\n+}\n \n-macro_rules! parse_node (\n+macro_rules! parse_node {\n     (\n         [:$head:ident ($(:$head_nodes:expr),*)\n          $(:$tags:ident ($(:$tag_nodes:expr),*))*];\n@@ -85,7 +85,7 @@ macro_rules! parse_node (\n     );\n \n     ( []; [:$e:expr]; ) => ( $e );\n-);\n+}\n \n pub fn main() {\n     let _page = html! ("}, {"sha": "6f050e7db05f4c56c4860f805265f4c6105771bb", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -37,7 +37,9 @@ impl fmt::Show for C {\n     }\n }\n \n-macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) });\n+macro_rules! t {\n+    ($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) }\n+}\n \n pub fn main() {\n     // Various edge cases without formats"}, {"sha": "4c86cb0049af6c408287bf068bd3e0bd2f27424e", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -11,14 +11,14 @@\n \n #![feature(globs, macro_rules, intrinsics)]\n \n-macro_rules! assert_approx_eq(\n+macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-);\n+}\n \n mod rusti {\n     extern \"rust-intrinsic\" {"}, {"sha": "60083c254805dc7492a6af0805a3d6c6a1466f59", "filename": "src/test/run-pass/issue-15189.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15189.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,7 +12,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! third(($e:expr)=>({let x = 2; $e[x]}));\n+macro_rules! third {\n+    ($e:expr) => ({let x = 2; $e[x]})\n+}\n \n fn main() {\n     let x = vec!(10u,11u,12u,13u);"}, {"sha": "f778af7ebcf5113d7655c15ff896a6fa0f2107b5", "filename": "src/test/run-pass/issue-15221.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15221.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,11 +10,13 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! inner (\n-    ($e:pat ) => ($e));\n+macro_rules! inner {\n+    ($e:pat ) => ($e)\n+}\n \n-macro_rules! outer (\n-    ($e:pat ) => (inner!($e)));\n+macro_rules! outer {\n+    ($e:pat ) => (inner!($e))\n+}\n \n fn main() {\n     let outer!(g1) = 13i;"}, {"sha": "18ebe35dcdf7daf2ed7a78de87f8b98a61eba2a2", "filename": "src/test/run-pass/issue-5060.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5060.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! print_hd_tl (\n+macro_rules! print_hd_tl {\n     ($field_hd:ident, $($field_tl:ident),+) => ({\n         print!(\"{}\", stringify!($field_hd));\n         print!(\"::[\");\n@@ -21,7 +21,7 @@ macro_rules! print_hd_tl (\n         // FIXME: #9970\n         print!(\"{}\", \"]\\n\");\n     })\n-);\n+}\n \n pub fn main() {\n     print_hd_tl!(x, y, z, w)"}, {"sha": "8cc507d88558afa445da4db7e8f3715455b88f72", "filename": "src/test/run-pass/issue-7911.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7911.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -27,7 +27,7 @@ trait Test {\n     fn get_mut(&mut self) -> &mut FooBar;\n }\n \n-macro_rules! generate_test(($type_:path, $slf:ident, $field:expr) => (\n+macro_rules! generate_test { ($type_:path, $slf:ident, $field:expr) => (\n     impl Test for $type_ {\n         fn get_immut(&$slf) -> &FooBar {\n             &$field as &FooBar\n@@ -37,7 +37,7 @@ macro_rules! generate_test(($type_:path, $slf:ident, $field:expr) => (\n             &mut $field as &mut FooBar\n         }\n     }\n-));\n+)}\n \n generate_test!(Foo, self, self.bar);\n "}, {"sha": "4e7d42f6b0bd709f3a8af8f62c98ee3d27cd03c8", "filename": "src/test/run-pass/issue-8709.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-8709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-8709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8709.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,13 +10,13 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! sty(\n+macro_rules! sty {\n     ($t:ty) => (stringify!($t))\n-);\n+}\n \n-macro_rules! spath(\n+macro_rules! spath {\n     ($t:path) => (stringify!($t))\n-);\n+}\n \n fn main() {\n     assert_eq!(sty!(int), \"int\");"}, {"sha": "765e696cd55fdc3bb2b92f7a61141f419dfe597b", "filename": "src/test/run-pass/issue-8851.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8851.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -20,7 +20,7 @@ enum T {\n     B(uint)\n }\n \n-macro_rules! test(\n+macro_rules! test {\n     ($id:ident, $e:expr) => (\n         fn foo(t: T) -> int {\n             match t {\n@@ -29,7 +29,7 @@ macro_rules! test(\n             }\n         }\n     )\n-);\n+}\n \n test!(y, 10 + (y as int));\n "}, {"sha": "26390d8da7d57f10d26b92f9976e95eba1d22614", "filename": "src/test/run-pass/issue-9110.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-9110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-9110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9110.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,14 +10,14 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! silly_macro(\n+macro_rules! silly_macro {\n     () => (\n         pub mod Qux {\n             pub struct Foo { x : u8 }\n             pub fn bar(_foo : Foo) {}\n         }\n     );\n-);\n+}\n \n silly_macro!();\n "}, {"sha": "2ac1a42a24629a7a8d6fd1104a2d23f38573ac46", "filename": "src/test/run-pass/issue-9129.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9129.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -19,8 +19,8 @@ impl bomb for S { fn boom(&self, _: Ident) { } }\n \n pub struct Ident { name: uint }\n \n-// macro_rules! int3( () => ( unsafe { asm!( \"int3\" ); } ) )\n-macro_rules! int3( () => ( { } ) );\n+// macro_rules! int3 { () => ( unsafe { asm!( \"int3\" ); } ) }\n+macro_rules! int3 { () => ( { } ) }\n \n fn Ident_new() -> Ident {\n     int3!();"}, {"sha": "2bd251ca58750b842630935f8c39ddec57fa2f58", "filename": "src/test/run-pass/issue-9737.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-9737.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fissue-9737.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9737.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,7 +12,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! f((v: $x:expr) => ( println!(\"{}\", $x) ))\n+macro_rules! f {\n+    (v: $x:expr) => ( println!(\"{}\", $x) )\n+}\n \n fn main () {\n     let v = 5;"}, {"sha": "ebd3e3c6641ea01af9e843f0988f88bdf1163b54", "filename": "src/test/run-pass/lambda-var-hygiene.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Flambda-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Flambda-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-var-hygiene.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -13,7 +13,9 @@\n #![feature(macro_rules)]\n \n // shouldn't affect evaluation of $ex:\n-macro_rules! bad_macro (($ex:expr) => ({(|_x| { $ex }) (9) }))\n+macro_rules! bad_macro {\n+    ($ex:expr) => ({(|_x| { $ex }) (9) })\n+}\n \n fn takes_x(_x : int) {\n     assert_eq!(bad_macro!(_x),8);"}, {"sha": "e0388407571f95afa9dbcfdc40be5a96e62b5101", "filename": "src/test/run-pass/let-var-hygiene.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -11,7 +11,10 @@\n #![feature(macro_rules)]\n \n // shouldn't affect evaluation of $ex:\n-macro_rules! bad_macro (($ex:expr) => ({let _x = 9i; $ex}));\n+macro_rules! bad_macro {\n+    ($ex:expr) => ({let _x = 9i; $ex})\n+}\n+\n pub fn main() {\n     let _x = 8i;\n     assert_eq!(bad_macro!(_x),8i)"}, {"sha": "07667de4716f5dd5083f8451d09a7e7184f7726d", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -14,12 +14,12 @@\n \n pub fn main() {\n \n-    macro_rules! mylambda_tt(\n+    macro_rules! mylambda_tt {\n         ($x:ident, $body:expr) => ({\n             fn f($x: int) -> int { return $body; };\n             f\n         })\n-    );\n+    }\n \n     assert!(mylambda_tt!(y, y * 2)(8) == 16);\n }"}, {"sha": "e531eb9dbc44599a13809c97e23fe192006380fc", "filename": "src/test/run-pass/macro-interpolation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! overly_complicated (\n+macro_rules! overly_complicated {\n     ($fnname:ident, $arg:ident, $ty:ty, $body:block, $val:expr, $pat:pat, $res:path) =>\n     ({\n         fn $fnname($arg: $ty) -> Option<$ty> $body\n@@ -22,7 +22,7 @@ macro_rules! overly_complicated (\n         }\n     })\n \n-);\n+}\n \n pub fn main() {\n     assert!(overly_complicated!(f, x, Option<uint>, { return Some(x); },"}, {"sha": "5103c50f5cf57f176143d8117d0d688d8d39ce36", "filename": "src/test/run-pass/macro-invocation-in-count-expr-fixed-array-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,9 +10,9 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! four (\n+macro_rules! four {\n     () => (4)\n-);\n+}\n \n fn main() {\n     let _x: [u16; four!()];"}, {"sha": "40f41447aa85a776adad6c8d710452b7580274f8", "filename": "src/test/run-pass/macro-multiple-items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,15 +12,15 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! make_foo(\n+macro_rules! make_foo {\n     () => (\n         struct Foo;\n \n         impl Foo {\n             fn bar(&self) {}\n         }\n     )\n-);\n+}\n \n make_foo!();\n "}, {"sha": "91f0a3b607c3efe86e75616f2a7780f050b8ca76", "filename": "src/test/run-pass/macro-nt-list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,15 +10,15 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! list (\n+macro_rules! list {\n     ( ($($id:ident),*) ) => (());\n     ( [$($id:ident),*] ) => (());\n     ( {$($id:ident),*} ) => (());\n-);\n+}\n \n-macro_rules! tt_list (\n+macro_rules! tt_list {\n     ( ($($tt:tt),*) ) => (());\n-);\n+}\n \n pub fn main() {\n     list!( () );"}, {"sha": "a7c0ca56d60c81b2d85e223ee74f3d9a062b7306", "filename": "src/test/run-pass/macro-of-higher-order.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! higher_order (\n+macro_rules! higher_order {\n     (subst $lhs:tt => $rhs:tt) => ({\n-            macro_rules! anon ( $lhs => $rhs );\n+            macro_rules! anon { $lhs => $rhs }\n             anon!(1u, 2u, \"foo\")\n     });\n-);\n+}\n \n fn main() {\n     let val = higher_order!(subst ($x:expr, $y:expr, $foo:expr) => (($x + $y, $foo)));"}, {"sha": "d3e32923075861a6c35af13817b26648f89e03db", "filename": "src/test/run-pass/macro-pat.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pat.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,35 +10,35 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! mypat(\n+macro_rules! mypat {\n     () => (\n         Some('y')\n     )\n-);\n+}\n \n-macro_rules! char_x(\n+macro_rules! char_x {\n     () => (\n         'x'\n     )\n-);\n+}\n \n-macro_rules! some(\n+macro_rules! some {\n     ($x:pat) => (\n         Some($x)\n     )\n-);\n+}\n \n-macro_rules! indirect(\n+macro_rules! indirect {\n     () => (\n         some!(char_x!())\n     )\n-);\n+}\n \n-macro_rules! ident_pat(\n+macro_rules! ident_pat {\n     ($x:ident) => (\n         $x\n     )\n-);\n+}\n \n fn f(c: Option<char>) -> uint {\n     match c {"}, {"sha": "77d6b59f8bf4440efa7dd0f29ae387517fa14fff", "filename": "src/test/run-pass/macro-stmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,21 +12,21 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! myfn(\n+macro_rules! myfn {\n     ( $f:ident, ( $( $x:ident ),* ), $body:block ) => (\n         fn $f( $( $x : int),* ) -> int $body\n     )\n-);\n+}\n \n myfn!(add, (a,b), { return a+b; } );\n \n pub fn main() {\n \n-    macro_rules! mylet(\n+    macro_rules! mylet {\n         ($x:ident, $val:expr) => (\n             let $x = $val;\n         )\n-    );\n+    }\n \n     mylet!(y, 8i*2);\n     assert_eq!(y, 16i);\n@@ -35,9 +35,9 @@ pub fn main() {\n \n     assert_eq!(mult(2, add(4,4)), 16);\n \n-    macro_rules! actually_an_expr_macro (\n+    macro_rules! actually_an_expr_macro {\n         () => ( 16i )\n-    );\n+    }\n \n     assert_eq!({ actually_an_expr_macro!() }, 16i);\n "}, {"sha": "23a3a0374973daf85de9420ef9b7a850ddea18d2", "filename": "src/test/run-pass/macro-with-attrs1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -13,10 +13,10 @@\n #![feature(macro_rules)]\n \n #[cfg(foo)]\n-macro_rules! foo( () => (1i) );\n+macro_rules! foo { () => (1i) }\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2i) );\n+macro_rules! foo { () => (2i) }\n \n pub fn main() {\n     assert_eq!(foo!(), 1i);"}, {"sha": "038931551a88ce1faf982f5c11215951d5f8fd08", "filename": "src/test/run-pass/macro-with-attrs2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -11,10 +11,10 @@\n #![feature(macro_rules)]\n \n #[cfg(foo)]\n-macro_rules! foo( () => (1i) );\n+macro_rules! foo { () => (1i) }\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2i) );\n+macro_rules! foo { () => (2i) }\n \n pub fn main() {\n     assert_eq!(foo!(), 2i);"}, {"sha": "b4170c27ec288e9bc3b984635974b8e99758389d", "filename": "src/test/run-pass/macro-with-braces-in-expr-position.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -12,7 +12,7 @@\n \n use std::thread::Thread;\n \n-macro_rules! expr (($e: expr) => { $e });\n+macro_rules! expr { ($e: expr) => { $e } }\n \n macro_rules! spawn {\n     ($($code: tt)*) => {"}, {"sha": "7dde322ead620365336439e8492702a36bb3b78c", "filename": "src/test/run-pass/match-in-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -14,13 +14,13 @@ enum Foo {\n     B { b1: int, bb1: int},\n }\n \n-macro_rules! match_inside_expansion(\n+macro_rules! match_inside_expansion {\n     () => (\n         match (Foo::B { b1:29 , bb1: 100}) {\n             Foo::B { b1:b2 , bb1:bb2 } => b2+bb2\n         }\n     )\n-);\n+}\n \n pub fn main() {\n     assert_eq!(match_inside_expansion!(),129);"}, {"sha": "da15f911e8b52c196a77b31091cfd297eeae86c0", "filename": "src/test/run-pass/match-var-hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmatch-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fmatch-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-var-hygiene.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -13,9 +13,9 @@\n #![feature(macro_rules)]\n \n // shouldn't affect evaluation of $ex.\n-macro_rules! bad_macro (($ex:expr) => (\n+macro_rules! bad_macro { ($ex:expr) => (\n     {match 9 {_x => $ex}}\n-))\n+)}\n \n fn main() {\n     match 8 {"}, {"sha": "e4a3ac8cd9101d899f1ea4afb628c11c8f44f76f", "filename": "src/test/run-pass/non-built-in-quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! quote_tokens ( () => (()) );\n+macro_rules! quote_tokens { () => (()) }\n \n pub fn main() {\n     quote_tokens!();"}, {"sha": "939d20ddc27fde838c313b1af0d51e7041beb12b", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -21,7 +21,7 @@ pub mod m1 {\n     }\n }\n \n-macro_rules! indirect_line( () => ( line!() ) );\n+macro_rules! indirect_line { () => ( line!() ) }\n \n pub fn main() {\n     assert_eq!(line!(), 27);"}, {"sha": "ce6122aad00e0170eecb429385881c49b27a49cd", "filename": "src/test/run-pass/typeck-macro-interaction-issue-8852.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416137eb3186c05b7a601e94cde354e9b3ec0a78/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs?ref=416137eb3186c05b7a601e94cde354e9b3ec0a78", "patch": "@@ -20,7 +20,7 @@ enum T {\n // doesn't cause capture. Making this macro hygienic (as I've done)\n // could very well make this test case completely pointless....\n \n-macro_rules! test(\n+macro_rules! test {\n     ($id1:ident, $id2:ident, $e:expr) => (\n         fn foo(a:T, b:T) -> T {\n             match (a, b) {\n@@ -30,7 +30,7 @@ macro_rules! test(\n             }\n         }\n     )\n-);\n+}\n \n test!(x,y,x + y);\n "}]}