{"sha": "15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YTUwMDlhZjBkYmYxOWFmYTRjZDQxYTVlMzY1ZDEzMWRhMGU0ZmU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-24T15:01:47Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-29T17:19:41Z"}, "message": "Don't use llvm intrinsic names in cg_ssa", "tree": {"sha": "b0fbd88661c41e78c32cf7b49a122c3bd09e4368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0fbd88661c41e78c32cf7b49a122c3bd09e4368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "html_url": "https://github.com/rust-lang/rust/commit/15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8698f5c43d69a526eb54e8f1d80303c30080ce9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8698f5c43d69a526eb54e8f1d80303c30080ce9e", "html_url": "https://github.com/rust-lang/rust/commit/8698f5c43d69a526eb54e8f1d80303c30080ce9e"}], "stats": {"total": 221, "additions": 113, "deletions": 108}, "files": [{"sha": "80130411c2b99a74f1e0613e0e54f10656a4e035", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -470,8 +470,8 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n-    fn get_intrinsic(&self, key: &str) -> &'b Value {\n+impl CodegenCx<'b, 'tcx> {\n+    crate fn get_intrinsic(&self, key: &str) -> &'b Value {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }"}, {"sha": "c495a0d92d110783ab5af95515da68b07370b5a7", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -763,6 +763,95 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n         }\n     }\n+\n+    fn abort(&mut self) {\n+        let fnname = self.cx().get_intrinsic(&(\"llvm.trap\"));\n+        self.call(fnname, &[], None);\n+    }\n+\n+    fn assume(&mut self, val: Self::Value) {\n+        let assume_intrinsic = self.cx().get_intrinsic(\"llvm.assume\");\n+        self.call(assume_intrinsic, &[val], None);\n+    }\n+\n+    fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value {\n+        let expect = self.cx().get_intrinsic(&\"llvm.expect.i1\");\n+        self.call(expect, &[cond, self.cx().const_bool(expected)], None)\n+    }\n+\n+    fn call_overflow_intrinsic(\n+        &mut self,\n+        oop: OverflowOp,\n+        ty: Ty,\n+        lhs: Self::Value,\n+        rhs: Self::Value,\n+    ) -> (Self::Value, Self::Value) {\n+        use syntax::ast::IntTy::*;\n+        use syntax::ast::UintTy::*;\n+        use rustc::ty::{Int, Uint};\n+\n+        let new_sty = match ty.sty {\n+            Int(Isize) => Int(self.tcx().sess.target.isize_ty),\n+            Uint(Usize) => Uint(self.tcx().sess.target.usize_ty),\n+            ref t @ Uint(_) | ref t @ Int(_) => t.clone(),\n+            _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n+        };\n+\n+        let name = match oop {\n+            OverflowOp::Add => match new_sty {\n+                Int(I8) => \"llvm.sadd.with.overflow.i8\",\n+                Int(I16) => \"llvm.sadd.with.overflow.i16\",\n+                Int(I32) => \"llvm.sadd.with.overflow.i32\",\n+                Int(I64) => \"llvm.sadd.with.overflow.i64\",\n+                Int(I128) => \"llvm.sadd.with.overflow.i128\",\n+\n+                Uint(U8) => \"llvm.uadd.with.overflow.i8\",\n+                Uint(U16) => \"llvm.uadd.with.overflow.i16\",\n+                Uint(U32) => \"llvm.uadd.with.overflow.i32\",\n+                Uint(U64) => \"llvm.uadd.with.overflow.i64\",\n+                Uint(U128) => \"llvm.uadd.with.overflow.i128\",\n+\n+                _ => unreachable!(),\n+            },\n+            OverflowOp::Sub => match new_sty {\n+                Int(I8) => \"llvm.ssub.with.overflow.i8\",\n+                Int(I16) => \"llvm.ssub.with.overflow.i16\",\n+                Int(I32) => \"llvm.ssub.with.overflow.i32\",\n+                Int(I64) => \"llvm.ssub.with.overflow.i64\",\n+                Int(I128) => \"llvm.ssub.with.overflow.i128\",\n+\n+                Uint(U8) => \"llvm.usub.with.overflow.i8\",\n+                Uint(U16) => \"llvm.usub.with.overflow.i16\",\n+                Uint(U32) => \"llvm.usub.with.overflow.i32\",\n+                Uint(U64) => \"llvm.usub.with.overflow.i64\",\n+                Uint(U128) => \"llvm.usub.with.overflow.i128\",\n+\n+                _ => unreachable!(),\n+            },\n+            OverflowOp::Mul => match new_sty {\n+                Int(I8) => \"llvm.smul.with.overflow.i8\",\n+                Int(I16) => \"llvm.smul.with.overflow.i16\",\n+                Int(I32) => \"llvm.smul.with.overflow.i32\",\n+                Int(I64) => \"llvm.smul.with.overflow.i64\",\n+                Int(I128) => \"llvm.smul.with.overflow.i128\",\n+\n+                Uint(U8) => \"llvm.umul.with.overflow.i8\",\n+                Uint(U16) => \"llvm.umul.with.overflow.i16\",\n+                Uint(U32) => \"llvm.umul.with.overflow.i32\",\n+                Uint(U64) => \"llvm.umul.with.overflow.i64\",\n+                Uint(U128) => \"llvm.umul.with.overflow.i128\",\n+\n+                _ => unreachable!(),\n+            },\n+        };\n+\n+        let intrinsic = self.cx().get_intrinsic(&name);\n+        let res = self.call(intrinsic, &[lhs, rhs], None);\n+        (\n+            self.extract_value(res, 0),\n+            self.extract_value(res, 1),\n+        )\n+    }\n }\n \n fn copy_intrinsic("}, {"sha": "6425a19e4b61b91e75365256a88521aa6de9b000", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -366,14 +366,6 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn call_assume<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    val: Bx::Value\n-) {\n-    let assume_intrinsic = bx.cx().get_intrinsic(\"llvm.assume\");\n-    bx.call(assume_intrinsic, &[val], None);\n-}\n-\n pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value"}, {"sha": "992a44aa5bfc3c429a91f4b74a46f066005a7783", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -195,9 +195,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Abort => {\n-                // Call core::intrinsics::abort()\n-                let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n-                bx.call(fnname, &[], None);\n+                bx.abort();\n                 bx.unreachable();\n             }\n \n@@ -364,8 +362,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n \n                 // Pass the condition through llvm.expect for branch hinting.\n-                let expect = bx.cx().get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bx.call(expect, &[cond, bx.cx().const_bool(expected)], None);\n+                let cond = bx.expect(cond, expected);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);"}, {"sha": "a85e75936dedfe8c3d2eb493ca5f8d6def387094", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -484,8 +484,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         // Allow RalfJ to sleep soundly knowing that even refactorings that remove\n                         // the above error (or silence it under some conditions) will not cause UB\n-                        let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n-                        bx.call(fnname, &[], None);\n+                        bx.abort();\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n                         bx.load_operand(PlaceRef::new_sized("}, {"sha": "1406714f29366d73b6e99d09cf6d3fbe0ffd9b3d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -413,8 +413,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // and compile-time agree on values\n                         // With floats that won't always be true\n                         // so we generate an abort\n-                        let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n-                        bx.call(fnname, &[], None);\n+                        bx.abort();\n                         let llval = bx.cx().const_undef(\n                             bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n                         );"}, {"sha": "7c794c053ecd02cea2c153db034586fac4309fc8", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                         llval,\n                                         ll_t_in_const\n                                     );\n-                                    base::call_assume(&mut bx, cmp);\n+                                    bx.assume(cmp);\n                                 }\n                             }\n                         }\n@@ -693,11 +693,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::BinOp::Mul => OverflowOp::Mul,\n                     _ => unreachable!()\n                 };\n-                let intrinsic = get_overflow_intrinsic(oop, bx, input_ty);\n-                let res = bx.call(intrinsic, &[lhs, rhs], None);\n-\n-                (bx.extract_value(res, 0),\n-                 bx.extract_value(res, 1))\n+                bx.call_overflow_intrinsic(oop, input_ty, lhs, rhs)\n             }\n             mir::BinOp::Shl | mir::BinOp::Shr => {\n                 let lhs_llty = bx.cx().val_ty(lhs);\n@@ -744,80 +740,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum OverflowOp {\n-    Add, Sub, Mul\n-}\n-\n-fn get_overflow_intrinsic<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    oop: OverflowOp,\n-    bx: &mut Bx,\n-    ty: Ty\n-) -> Bx::Value {\n-    use syntax::ast::IntTy::*;\n-    use syntax::ast::UintTy::*;\n-    use rustc::ty::{Int, Uint};\n-\n-    let tcx = bx.tcx();\n-\n-    let new_sty = match ty.sty {\n-        Int(Isize) => Int(tcx.sess.target.isize_ty),\n-        Uint(Usize) => Uint(tcx.sess.target.usize_ty),\n-        ref t @ Uint(_) | ref t @ Int(_) => t.clone(),\n-        _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n-    };\n-\n-    let name = match oop {\n-        OverflowOp::Add => match new_sty {\n-            Int(I8) => \"llvm.sadd.with.overflow.i8\",\n-            Int(I16) => \"llvm.sadd.with.overflow.i16\",\n-            Int(I32) => \"llvm.sadd.with.overflow.i32\",\n-            Int(I64) => \"llvm.sadd.with.overflow.i64\",\n-            Int(I128) => \"llvm.sadd.with.overflow.i128\",\n-\n-            Uint(U8) => \"llvm.uadd.with.overflow.i8\",\n-            Uint(U16) => \"llvm.uadd.with.overflow.i16\",\n-            Uint(U32) => \"llvm.uadd.with.overflow.i32\",\n-            Uint(U64) => \"llvm.uadd.with.overflow.i64\",\n-            Uint(U128) => \"llvm.uadd.with.overflow.i128\",\n-\n-            _ => unreachable!(),\n-        },\n-        OverflowOp::Sub => match new_sty {\n-            Int(I8) => \"llvm.ssub.with.overflow.i8\",\n-            Int(I16) => \"llvm.ssub.with.overflow.i16\",\n-            Int(I32) => \"llvm.ssub.with.overflow.i32\",\n-            Int(I64) => \"llvm.ssub.with.overflow.i64\",\n-            Int(I128) => \"llvm.ssub.with.overflow.i128\",\n-\n-            Uint(U8) => \"llvm.usub.with.overflow.i8\",\n-            Uint(U16) => \"llvm.usub.with.overflow.i16\",\n-            Uint(U32) => \"llvm.usub.with.overflow.i32\",\n-            Uint(U64) => \"llvm.usub.with.overflow.i64\",\n-            Uint(U128) => \"llvm.usub.with.overflow.i128\",\n-\n-            _ => unreachable!(),\n-        },\n-        OverflowOp::Mul => match new_sty {\n-            Int(I8) => \"llvm.smul.with.overflow.i8\",\n-            Int(I16) => \"llvm.smul.with.overflow.i16\",\n-            Int(I32) => \"llvm.smul.with.overflow.i32\",\n-            Int(I64) => \"llvm.smul.with.overflow.i64\",\n-            Int(I128) => \"llvm.smul.with.overflow.i128\",\n-\n-            Uint(U8) => \"llvm.umul.with.overflow.i8\",\n-            Uint(U16) => \"llvm.umul.with.overflow.i16\",\n-            Uint(U32) => \"llvm.umul.with.overflow.i32\",\n-            Uint(U64) => \"llvm.umul.with.overflow.i64\",\n-            Uint(U128) => \"llvm.umul.with.overflow.i128\",\n-\n-            _ => unreachable!(),\n-        },\n-    };\n-\n-    bx.cx().get_intrinsic(&name)\n-}\n-\n fn cast_int_to_float<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     signed: bool,"}, {"sha": "a17587d3619743660af1d81209590b5a6298f4a9", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::Backend;\n use super::HasCodegen;\n use mir::operand::OperandRef;\n use rustc::ty::Ty;\n use rustc_target::abi::call::FnType;\n use syntax_pos::Span;\n \n+#[derive(Copy, Clone)]\n+pub enum OverflowOp {\n+    Add, Sub, Mul\n+}\n+\n pub trait IntrinsicCallMethods<'tcx>: HasCodegen<'tcx> {\n     /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n     /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n@@ -27,11 +31,16 @@ pub trait IntrinsicCallMethods<'tcx>: HasCodegen<'tcx> {\n         llresult: Self::Value,\n         span: Span,\n     );\n-}\n \n-pub trait IntrinsicDeclarationMethods<'tcx>: Backend<'tcx> {\n-    fn get_intrinsic(&self, key: &str) -> Self::Value;\n+    fn abort(&mut self);\n+    fn assume(&mut self, val: Self::Value);\n+    fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n \n-    /// Declare any llvm intrinsics that you might need\n-    fn declare_intrinsic(&self, key: &str) -> Option<Self::Value>;\n+    fn call_overflow_intrinsic(\n+        &mut self,\n+        oop: OverflowOp,\n+        ty: Ty,\n+        lhs: Self::Value,\n+        rhs: Self::Value,\n+    ) -> (Self::Value, Self::Value);\n }"}, {"sha": "61438195f38c6fed5cef229dcbe20f847dbe1ad7", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a5009af0dbf19afa4cd41a5e365d131da0e4fe/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=15a5009af0dbf19afa4cd41a5e365d131da0e4fe", "patch": "@@ -44,7 +44,7 @@ pub use self::builder::BuilderMethods;\n pub use self::consts::ConstMethods;\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n pub use self::declare::{DeclareMethods, PreDefineMethods};\n-pub use self::intrinsic::{IntrinsicCallMethods, IntrinsicDeclarationMethods};\n+pub use self::intrinsic::{IntrinsicCallMethods, OverflowOp};\n pub use self::misc::MiscMethods;\n pub use self::statics::StaticMethods;\n pub use self::type_::{\n@@ -65,7 +65,6 @@ pub trait CodegenMethods<'tcx>:\n     + StaticMethods\n     + DebugInfoMethods<'tcx>\n     + AbiMethods<'tcx>\n-    + IntrinsicDeclarationMethods<'tcx>\n     + DeclareMethods<'tcx>\n     + AsmMethods<'tcx>\n     + PreDefineMethods<'tcx>\n@@ -80,7 +79,6 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + StaticMethods\n         + DebugInfoMethods<'tcx>\n         + AbiMethods<'tcx>\n-        + IntrinsicDeclarationMethods<'tcx>\n         + DeclareMethods<'tcx>\n         + AsmMethods<'tcx>\n         + PreDefineMethods<'tcx>"}]}