{"sha": "3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOTdjYTY3OWZiMDE1NmM5ZjEwMmFiODIzNTRlMmJjZWY1ZjRkZDE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-02T12:04:22Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T17:28:10Z"}, "message": "Fix APIT some more", "tree": {"sha": "e61d0eba1a918b9e6802baf6dbeb99f3d92afd82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e61d0eba1a918b9e6802baf6dbeb99f3d92afd82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "html_url": "https://github.com/rust-lang/rust/commit/3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6654fd4a70ef149a842e42dc9ef86838148fbe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6654fd4a70ef149a842e42dc9ef86838148fbe7", "html_url": "https://github.com/rust-lang/rust/commit/c6654fd4a70ef149a842e42dc9ef86838148fbe7"}], "stats": {"total": 216, "additions": 115, "deletions": 101}, "files": [{"sha": "8d5b7c94328a86db7da1ea9343b1aeb7be05a8b6", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "patch": "@@ -479,8 +479,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn collect_fn(&mut self, data: &FunctionData) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in data.params.iter().zip(body.params.iter()) {\n-            let ty = self.make_ty_with_mode(type_ref, ImplTraitLoweringMode::Param);\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver).with_impl_trait_mode(ImplTraitLoweringMode::Param);\n+        let param_tys = data.params.iter().map(|type_ref| Ty::from_hir(&ctx, type_ref)).collect::<Vec<_>>();\n+        for (ty, pat) in param_tys.into_iter().zip(body.params.iter()) {\n+            let ty = self.insert_type_vars(ty);\n+            let ty = self.normalize_associated_types_in(ty);\n \n             self.infer_pat(*pat, &ty, BindingMode::default());\n         }"}, {"sha": "6eccd7fa843eb26e3150b34bab48bfba4d8cf9c2", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "patch": "@@ -44,11 +44,11 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n-    HasModule, Lookup, TraitId, TypeAliasId, TypeParamId, generics::TypeParamProvenance,\n+    expr::ExprId, generics::TypeParamProvenance, type_ref::Mutability, AdtId, AssocContainerId,\n+    DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n-use ra_db::{impl_intern_key, salsa, CrateId};\n use hir_expand::name::Name;\n+use ra_db::{impl_intern_key, salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n@@ -360,9 +360,7 @@ impl Substs {\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n     pub(crate) fn type_params(generic_params: &Generics) -> Substs {\n-        Substs(\n-            generic_params.iter().map(|(id, _)| Ty::Param(id)).collect(),\n-        )\n+        Substs(generic_params.iter().map(|(id, _)| Ty::Param(id)).collect())\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n@@ -448,7 +446,9 @@ pub struct Binders<T> {\n }\n \n impl<T> Binders<T> {\n-    pub fn new(num_binders: usize, value: T) -> Self { Self { num_binders, value } }\n+    pub fn new(num_binders: usize, value: T) -> Self {\n+        Self { num_binders, value }\n+    }\n }\n \n impl<T: TypeWalk> Binders<T> {\n@@ -906,8 +906,7 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n             TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def)\n-                    .subst(&self.parameters);\n+                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n                 let name = match def {\n                     CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n                     CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n@@ -1037,84 +1036,27 @@ impl HirDisplay for Ty {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Param(id) => {\n-                let generic_params = f.db.generic_params(id.parent);\n-                let param_data = &generic_params.types[id.local_id];\n+                let generics = generics(f.db, id.parent);\n+                let param_data = &generics.params.types[id.local_id];\n                 match param_data.provenance {\n                     TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n                         write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n                     }\n                     TypeParamProvenance::ArgumentImplTrait => {\n-                        write!(f, \"impl TODO\")?\n+                        let bounds = f.db.generic_predicates_for_param(*id);\n+                        write!(f, \"impl \")?;\n+                        write_bounds_like_dyn_trait(&bounds, f)?;\n                     }\n                 }\n-            },\n+            }\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 match self {\n                     Ty::Dyn(_) => write!(f, \"dyn \")?,\n                     Ty::Opaque(_) => write!(f, \"impl \")?,\n                     _ => unreachable!(),\n                 };\n-                // Note: This code is written to produce nice results (i.e.\n-                // corresponding to surface Rust) for types that can occur in\n-                // actual Rust. It will have weird results if the predicates\n-                // aren't as expected (i.e. self types = $0, projection\n-                // predicates for a certain trait come after the Implemented\n-                // predicate for that trait).\n-                let mut first = true;\n-                let mut angle_open = false;\n-                for p in predicates.iter() {\n-                    match p {\n-                        GenericPredicate::Implemented(trait_ref) => {\n-                            if angle_open {\n-                                write!(f, \">\")?;\n-                            }\n-                            if !first {\n-                                write!(f, \" + \")?;\n-                            }\n-                            // We assume that the self type is $0 (i.e. the\n-                            // existential) here, which is the only thing that's\n-                            // possible in actual Rust, and hence don't print it\n-                            write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n-                            if trait_ref.substs.len() > 1 {\n-                                write!(f, \"<\")?;\n-                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                                // there might be assoc type bindings, so we leave the angle brackets open\n-                                angle_open = true;\n-                            }\n-                        }\n-                        GenericPredicate::Projection(projection_pred) => {\n-                            // in types in actual Rust, these will always come\n-                            // after the corresponding Implemented predicate\n-                            if angle_open {\n-                                write!(f, \", \")?;\n-                            } else {\n-                                write!(f, \"<\")?;\n-                                angle_open = true;\n-                            }\n-                            let name =\n-                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n-                                    .name\n-                                    .clone();\n-                            write!(f, \"{} = \", name)?;\n-                            projection_pred.ty.hir_fmt(f)?;\n-                        }\n-                        GenericPredicate::Error => {\n-                            if angle_open {\n-                                // impl Trait<X, {error}>\n-                                write!(f, \", \")?;\n-                            } else if !first {\n-                                // impl Trait + {error}\n-                                write!(f, \" + \")?;\n-                            }\n-                            p.hir_fmt(f)?;\n-                        }\n-                    }\n-                    first = false;\n-                }\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n+                write_bounds_like_dyn_trait(&predicates, f)?;\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n@@ -1123,6 +1065,71 @@ impl HirDisplay for Ty {\n     }\n }\n \n+fn write_bounds_like_dyn_trait(\n+    predicates: &[GenericPredicate],\n+    f: &mut HirFormatter<impl HirDatabase>,\n+) -> fmt::Result {\n+    // Note: This code is written to produce nice results (i.e.\n+    // corresponding to surface Rust) for types that can occur in\n+    // actual Rust. It will have weird results if the predicates\n+    // aren't as expected (i.e. self types = $0, projection\n+    // predicates for a certain trait come after the Implemented\n+    // predicate for that trait).\n+    let mut first = true;\n+    let mut angle_open = false;\n+    for p in predicates.iter() {\n+        match p {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+                if !first {\n+                    write!(f, \" + \")?;\n+                }\n+                // We assume that the self type is $0 (i.e. the\n+                // existential) here, which is the only thing that's\n+                // possible in actual Rust, and hence don't print it\n+                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n+                if trait_ref.substs.len() > 1 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                    // there might be assoc type bindings, so we leave the angle brackets open\n+                    angle_open = true;\n+                }\n+            }\n+            GenericPredicate::Projection(projection_pred) => {\n+                // in types in actual Rust, these will always come\n+                // after the corresponding Implemented predicate\n+                if angle_open {\n+                    write!(f, \", \")?;\n+                } else {\n+                    write!(f, \"<\")?;\n+                    angle_open = true;\n+                }\n+                let name =\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n+                write!(f, \"{} = \", name)?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n+            GenericPredicate::Error => {\n+                if angle_open {\n+                    // impl Trait<X, {error}>\n+                    write!(f, \", \")?;\n+                } else if !first {\n+                    // impl Trait + {error}\n+                    write!(f, \" + \")?;\n+                }\n+                p.hir_fmt(f)?;\n+            }\n+        }\n+        first = false;\n+    }\n+    if angle_open {\n+        write!(f, \">\")?;\n+    }\n+    Ok(())\n+}\n+\n impl TraitRef {\n     fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n         if f.should_truncate() {"}, {"sha": "e375c48470ba490b1339272b0a13b0b26dc99b68", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "patch": "@@ -10,12 +10,13 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n-    generics::{WherePredicate, WherePredicateTarget},\n+    generics::{WherePredicate, WherePredicateTarget, TypeParamProvenance},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n     LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+    TypeParamId\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -30,8 +31,6 @@ use crate::{\n     Binders, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate, ProjectionTy, Substs,\n     TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n-use hir_def::TypeParamId;\n-use hir_def::generics::TypeParamProvenance;\n \n #[derive(Debug)]\n pub struct TyLoweringContext<'a, DB: HirDatabase> {"}, {"sha": "bae5eae0742476f807e34200665340454075a365", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3397ca679fb0156c9f102ab82354e2bcef5f4dd1/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=3397ca679fb0156c9f102ab82354e2bcef5f4dd1", "patch": "@@ -856,11 +856,11 @@ trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n }\n-fn bar(impl Trait<u64>) {}\n+fn bar(x: impl Trait<u16>) {}\n struct S<T>(T);\n impl<T> Trait<T> for S<T> {}\n \n-fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n+fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n     x;\n     y;\n     let z = S(1);\n@@ -876,27 +876,32 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n         @r###\"\n     [30; 34) 'self': &Self\n     [55; 59) 'self': &Self\n-    [99; 101) '{}': ()\n-    [111; 112) 'x': impl Trait<u64>\n-    [131; 132) 'y': &impl Trait<u64>\n-    [152; 269) '{     ...2(); }': ()\n-    [158; 159) 'x': impl Trait<u64>\n-    [165; 166) 'y': &impl Trait<u64>\n-    [176; 177) 'z': impl Trait<u64>\n-    [180; 183) 'bar': fn bar() -> impl Trait<u64>\n-    [180; 185) 'bar()': impl Trait<u64>\n-    [191; 192) 'x': impl Trait<u64>\n-    [191; 198) 'x.foo()': u64\n-    [204; 205) 'y': &impl Trait<u64>\n-    [204; 211) 'y.foo()': u64\n-    [217; 218) 'z': impl Trait<u64>\n-    [217; 224) 'z.foo()': u64\n-    [230; 231) 'x': impl Trait<u64>\n-    [230; 238) 'x.foo2()': i64\n-    [244; 245) 'y': &impl Trait<u64>\n-    [244; 252) 'y.foo2()': i64\n-    [258; 259) 'z': impl Trait<u64>\n-    [258; 266) 'z.foo2()': i64\n+    [78; 79) 'x': impl Trait<u16>\n+    [98; 100) '{}': ()\n+    [155; 156) 'x': impl Trait<u64>\n+    [175; 176) 'y': &impl Trait<u32>\n+    [196; 324) '{     ...2(); }': ()\n+    [202; 203) 'x': impl Trait<u64>\n+    [209; 210) 'y': &impl Trait<u32>\n+    [220; 221) 'z': S<u16>\n+    [224; 225) 'S': S<u16>(u16) -> S<u16>\n+    [224; 228) 'S(1)': S<u16>\n+    [226; 227) '1': u16\n+    [234; 237) 'bar': fn bar<S<u16>>(S<u16>) -> ()\n+    [234; 240) 'bar(z)': ()\n+    [238; 239) 'z': S<u16>\n+    [246; 247) 'x': impl Trait<u64>\n+    [246; 253) 'x.foo()': u64\n+    [259; 260) 'y': &impl Trait<u32>\n+    [259; 266) 'y.foo()': u32\n+    [272; 273) 'z': S<u16>\n+    [272; 279) 'z.foo()': u16\n+    [285; 286) 'x': impl Trait<u64>\n+    [285; 293) 'x.foo2()': i64\n+    [299; 300) 'y': &impl Trait<u32>\n+    [299; 307) 'y.foo2()': i64\n+    [313; 314) 'z': S<u16>\n+    [313; 321) 'z.foo2()': i64\n     \"###\n     );\n }"}]}