{"sha": "6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYjQ5ZDJhM2U4NmYwZDJmMjIwZjEyYzU5YzBlYmIyOTY1ZmYzOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-13T17:42:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-13T17:42:25Z"}, "message": "Auto merge of #45261 - kennytm:rollup, r=kennytm\n\nRollup of 14 pull requests\n\n- Successful merges: #44855, #45110, #45122, #45133, #45173, #45178, #45189, #45203, #45209, #45221, #45236, #45240, #45245, #45253\n- Failed merges:", "tree": {"sha": "601f0856be5a7da5d29c176fb415f7b803643670", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/601f0856be5a7da5d29c176fb415f7b803643670"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "html_url": "https://github.com/rust-lang/rust/commit/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "305e02281bf6e7a5398f93f86c901316074be0a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/305e02281bf6e7a5398f93f86c901316074be0a5", "html_url": "https://github.com/rust-lang/rust/commit/305e02281bf6e7a5398f93f86c901316074be0a5"}, {"sha": "8ea67902934728378acdd84a6050b9b4bed03ad5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea67902934728378acdd84a6050b9b4bed03ad5", "html_url": "https://github.com/rust-lang/rust/commit/8ea67902934728378acdd84a6050b9b4bed03ad5"}], "stats": {"total": 999, "additions": 819, "deletions": 180}, "files": [{"sha": "06edbd8e9eec3999067a49504c79f5cc6041a48a", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -246,8 +246,11 @@ impl Step for Rls {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rls/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -291,8 +294,11 @@ impl Step for Rustfmt {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rustfmt/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");"}, {"sha": "2c8e5004041da3480cdd8ae0e32bb0e60dda45a7", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -352,34 +352,51 @@ impl Step for Openssl {\n             // originally from https://www.openssl.org/source/...\n             let url = format!(\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/{}\",\n                               name);\n-            let mut ok = false;\n+            let mut last_error = None;\n             for _ in 0..3 {\n                 let status = Command::new(\"curl\")\n                                 .arg(\"-o\").arg(&tmp)\n+                                .arg(\"-f\")  // make curl fail if the URL does not return HTTP 200\n                                 .arg(&url)\n                                 .status()\n                                 .expect(\"failed to spawn curl\");\n-                if status.success() {\n-                    ok = true;\n-                    break\n+\n+                // Retry if download failed.\n+                if !status.success() {\n+                    last_error = Some(status.to_string());\n+                    continue;\n                 }\n+\n+                // Ensure the hash is correct.\n+                let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n+                    let mut cmd = Command::new(\"shasum\");\n+                    cmd.arg(\"-a\").arg(\"256\");\n+                    cmd\n+                } else {\n+                    Command::new(\"sha256sum\")\n+                };\n+                let output = output(&mut shasum.arg(&tmp));\n+                let found = output.split_whitespace().next().unwrap();\n+\n+                // If the hash is wrong, probably the download is incomplete or S3 served an error\n+                // page. In any case, retry.\n+                if found != OPENSSL_SHA256 {\n+                    last_error = Some(format!(\n+                        \"downloaded openssl sha256 different\\n\\\n+                         expected: {}\\n\\\n+                         found:    {}\\n\",\n+                        OPENSSL_SHA256,\n+                        found\n+                    ));\n+                    continue;\n+                }\n+\n+                // Everything is fine, so exit the retry loop.\n+                last_error = None;\n+                break;\n             }\n-            if !ok {\n-                panic!(\"failed to download openssl source\")\n-            }\n-            let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n-                let mut cmd = Command::new(\"shasum\");\n-                cmd.arg(\"-a\").arg(\"256\");\n-                cmd\n-            } else {\n-                Command::new(\"sha256sum\")\n-            };\n-            let output = output(&mut shasum.arg(&tmp));\n-            let found = output.split_whitespace().next().unwrap();\n-            if found != OPENSSL_SHA256 {\n-                panic!(\"downloaded openssl sha256 different\\n\\\n-                        expected: {}\\n\\\n-                        found:    {}\\n\", OPENSSL_SHA256, found);\n+            if let Some(error) = last_error {\n+                panic!(\"failed to download openssl source: {}\", error);\n             }\n             t!(fs::rename(&tmp, &tarball));\n         }"}, {"sha": "0cbfc9e9dacbb3f04d7f9f30f3c89e0d44d9bf4b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -121,6 +121,7 @@\n #![feature(unique)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n+#![feature(on_unimplemented)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "cf34e195dea76fe1d8262d412eab2823cb965e87", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -1543,6 +1543,7 @@ impl<T: Hash> Hash for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n@@ -1554,6 +1555,7 @@ impl<T> Index<usize> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> IndexMut<usize> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n@@ -1562,8 +1564,8 @@ impl<T> IndexMut<usize> for Vec<T> {\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1572,7 +1574,9 @@ impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1581,7 +1585,9 @@ impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1590,7 +1596,9 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n \n@@ -1599,7 +1607,9 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1608,7 +1618,9 @@ impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1619,41 +1631,52 @@ impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {"}, {"sha": "16d5fadc53620f60e243d017331c440d6086147a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -429,9 +429,11 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n \n /// Returns whether dropping values of type `T` matters.\n ///\n-/// This is purely an optimization hint, and may be implemented conservatively.\n-/// For instance, always returning `true` would be a valid implementation of\n-/// this function.\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n ///\n /// Low level implementations of things like collections, which need to manually\n /// drop their data, should use this function to avoid unnecessarily"}, {"sha": "bb6213cb5faaf20f07321a8d1f701798db29d916", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -336,6 +336,12 @@ struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        // Anything which has custom linkage gets thrown on the worklist no\n+        // matter where it is in the crate.\n+        if attr::contains_name(&item.attrs, \"linkage\") {\n+            self.worklist.push(item.id);\n+        }\n+\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {"}, {"sha": "0159a198bc64744db417eb1e329e0ef590434867", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -415,9 +415,11 @@ pub enum BorrowKind {\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n \n-newtype_index!(Local, \"_\");\n-\n-pub const RETURN_POINTER: Local = Local(0);\n+newtype_index!(Local\n+    {\n+        DEBUG_NAME = \"_\",\n+        const RETURN_POINTER = 0,\n+    });\n \n /// Classifies locals into categories. See `Mir::local_kind`.\n #[derive(PartialEq, Eq, Debug)]\n@@ -551,7 +553,7 @@ pub struct UpvarDecl {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n \n-newtype_index!(BasicBlock, \"bb\");\n+newtype_index!(BasicBlock { DEBUG_NAME = \"bb\" });\n \n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n@@ -1131,7 +1133,7 @@ pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Local, Ty<'tcx>\n /// and the index is a local.\n pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n-newtype_index!(Field, \"field\");\n+newtype_index!(Field { DEBUG_NAME = \"field\" });\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n@@ -1196,8 +1198,11 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-newtype_index!(VisibilityScope, \"scope\");\n-pub const ARGUMENT_VISIBILITY_SCOPE : VisibilityScope = VisibilityScope(0);\n+newtype_index!(VisibilityScope\n+    {\n+        DEBUG_NAME = \"scope\",\n+        const ARGUMENT_VISIBILITY_SCOPE = 0,\n+    });\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VisibilityScopeData {\n@@ -1522,7 +1527,7 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n-newtype_index!(Promoted, \"promoted\");\n+newtype_index!(Promoted { DEBUG_NAME = \"promoted\" });\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {"}, {"sha": "d6f7c2aa887f0a49a8174a9baff0d942e110df4d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -759,7 +759,21 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 let mut db = match err.cause {\n                     MutabilityViolation => {\n-                        self.cannot_assign(error_span, &descr, Origin::Ast)\n+                        let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n+                        if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n+                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                            let sp = self.tcx.hir.span(node_id);\n+                            match self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                Ok(snippet) => {\n+                                    let msg = &format!(\"consider making `{}` mutable\", snippet);\n+                                    db.span_suggestion(sp, msg, format!(\"mut {}\", snippet));\n+                                }\n+                                _ => {\n+                                    db.span_help(sp, \"consider making this binding mutable\");\n+                                }\n+                            }\n+                        }\n+                        db\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n                         struct_span_err!(self.tcx.sess, error_span, E0595,"}, {"sha": "6c5a37aa1e5750ffb9b39daf67d86d578c585bdf", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -40,39 +40,80 @@ impl Idx for u32 {\n \n #[macro_export]\n macro_rules! newtype_index {\n+    // ---- public rules ----\n+\n+    // Use default constants\n     ($name:ident) => (\n-        newtype_index!($name, unsafe { ::std::intrinsics::type_name::<$name>() });\n+        newtype_index!(\n+            @type[$name]\n+            @max[::std::u32::MAX]\n+            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]);\n+    );\n+\n+    // Define any constants\n+    ($name:ident { $($tokens:tt)+ }) => (\n+        newtype_index!(\n+            @type[$name]\n+            @max[::std::u32::MAX]\n+            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]\n+            $($tokens)+);\n     );\n \n-    ($name:ident, $debug_name:expr) => (\n+    // ---- private rules ----\n+\n+    // Base case, user-defined constants (if any) have already been defined\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]) => (\n         #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n-         RustcEncodable, RustcDecodable)]\n-        pub struct $name(u32);\n-\n-        impl $name {\n-            // HACK use for constants\n-            #[allow(unused)]\n-            const fn const_new(x: u32) -> Self {\n-                $name(x)\n-            }\n-        }\n+            RustcEncodable, RustcDecodable)]\n+        pub struct $type(u32);\n \n-        impl Idx for $name {\n+        impl Idx for $type {\n             fn new(value: usize) -> Self {\n-                assert!(value < (::std::u32::MAX) as usize);\n-                $name(value as u32)\n+                assert!(value < ($max) as usize);\n+                $type(value as u32)\n             }\n             fn index(self) -> usize {\n                 self.0 as usize\n             }\n         }\n \n-        impl ::std::fmt::Debug for $name {\n+        impl ::std::fmt::Debug for $type {\n             fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 write!(fmt, \"{}{}\", $debug_name, self.0)\n             }\n         }\n-    )\n+    );\n+\n+    // Rewrite final without comma to one that includes comma\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+            $name:ident = $constant:expr) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $name = $constant,);\n+    );\n+\n+    // Rewrite final const without comma to one that includes comma\n+    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+            const $name:ident = $constant:expr) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] const $name = $constant,);\n+    );\n+\n+    // Replace existing default for max\n+    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+            MAX = $max:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $(tokens)*);\n+    );\n+\n+    // Replace existing default for debug_name\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$_debug_name:expr]\n+            DEBUG_NAME = $debug_name:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n+\n+    // Assign a user-defined constant (as final param)\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+            const $name:ident = $constant:expr, $($tokens:tt)*) => (\n+        pub const $name: $type = $type($constant);\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n }\n \n #[derive(Clone, PartialEq, Eq)]"}, {"sha": "4aab43cbec701cfd0a87bcfb33e3d275172ea4c5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -137,7 +137,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0426: use of undeclared label\n-    UndeclaredLabel(&'a str),\n+    UndeclaredLabel(&'a str, Option<Name>),\n     /// error E0429: `self` imports are only allowed within a { } list\n     SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n@@ -263,13 +263,17 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(span, \"used in a pattern more than once\");\n             err\n         }\n-        ResolutionError::UndeclaredLabel(name) => {\n+        ResolutionError::UndeclaredLabel(name, lev_candidate) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0426,\n                                            \"use of undeclared label `{}`\",\n                                            name);\n-            err.span_label(span, format!(\"undeclared label `{}`\", name));\n+            if let Some(lev_candidate) = lev_candidate {\n+                err.span_label(span, format!(\"did you mean `{}`?\", lev_candidate));\n+            } else {\n+                err.span_label(span, format!(\"undeclared label `{}`\", name));\n+            }\n             err\n         }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n@@ -1790,9 +1794,13 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// Searches the current set of local scopes for labels.\n+    /// Searches the current set of local scopes for labels. Returns the first non-None label that\n+    /// is returned by the given predicate function\n+    ///\n     /// Stops after meeting a closure.\n-    fn search_label(&self, mut ident: Ident) -> Option<Def> {\n+    fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n+        where P: Fn(&Rib, Ident) -> Option<R>\n+    {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {}\n@@ -1808,9 +1816,9 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 }\n             }\n-            let result = rib.bindings.get(&ident).cloned();\n-            if result.is_some() {\n-                return result;\n+            let r = pred(rib, ident);\n+            if r.is_some() {\n+                return r;\n             }\n         }\n         None\n@@ -3202,12 +3210,20 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.node) {\n+                match self.search_label(label.node, |rib, id| rib.bindings.get(&id).cloned()) {\n                     None => {\n+                        // Search again for close matches...\n+                        // Picks the first label that is \"close enough\", which is not necessarily\n+                        // the closest match\n+                        let close_match = self.search_label(label.node, |rib, ident| {\n+                            let names = rib.bindings.iter().map(|(id, _)| &id.name);\n+                            find_best_match_for_name(names, &*ident.name.as_str(), None)\n+                        });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()));\n+                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str(),\n+                                                                       close_match));\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read."}, {"sha": "9e2798f1cf71abd0faff9dae5d6a9f5d1d1fa120", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -394,7 +394,7 @@ h4 > code, h3 > code, .invisible > code {\n \tpadding: 0;\n }\n \n-.content .item-list li { margin-bottom: 3px; }\n+.content .item-list li { margin-bottom: 1em; }\n \n .content .multi-column {\n \t-moz-column-count: 5;\n@@ -773,17 +773,19 @@ span.since {\n \t}\n \n \t.sidebar {\n-\t\theight: 40px;\n+\t\theight: 45px;\n \t\tmin-height: 40px;\n-\t\twidth: 100%;\n-\t\tmargin: 0px;\n-\t\tpadding: 0px;\n+\t\twidth: calc(100% + 30px);\n+\t\tmargin: 0;\n+\t\tmargin-left: -15px;\n+\t\tpadding: 0 15px;\n \t\tposition: static;\n \t}\n \n \t.sidebar .location {\n \t\tfloat: right;\n \t\tmargin: 0px;\n+\t\tmargin-top: 2px;\n \t\tpadding: 3px 10px 1px 10px;\n \t\tmin-height: 39px;\n \t\tbackground: inherit;\n@@ -798,7 +800,7 @@ span.since {\n \t.sidebar img {\n \t\twidth: 35px;\n \t\tmargin-top: 5px;\n-\t\tmargin-bottom: 0px;\n+\t\tmargin-bottom: 5px;\n \t\tfloat: left;\n \t}\n "}, {"sha": "b54603919427c33bb812fa4f56e55061cf05a001", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 186, "deletions": 65, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -23,19 +23,69 @@ use ptr;\n use slice;\n use str::{self, Utf8Error};\n \n-/// A type representing an owned C-compatible string.\n+/// A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n+/// middle.\n ///\n-/// This type serves the primary purpose of being able to safely generate a\n+/// This type serves the purpose of being able to safely generate a\n /// C-compatible string from a Rust byte slice or vector. An instance of this\n /// type is a static guarantee that the underlying bytes contain no interior 0\n-/// bytes and the final byte is 0.\n+/// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n ///\n-/// A `CString` is created from either a byte slice or a byte vector. A [`u8`]\n-/// slice can be obtained with the `as_bytes` method. Slices produced from a\n-/// `CString` do *not* contain the trailing nul terminator unless otherwise\n-/// specified.\n+/// `CString` is to [`CStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n ///\n+/// # Creating a `CString`\n+///\n+/// A `CString` is created from either a byte slice or a byte vector,\n+/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n+/// example, you can build a `CString` straight out of a [`String`] or\n+/// a [`&str`], since both implement that trait).\n+///\n+/// The [`new`] method will actually check that the provided `&[u8]`\n+/// does not have 0 bytes in the middle, and return an error if it\n+/// finds one.\n+///\n+/// # Extracting a raw pointer to the whole C string\n+///\n+/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// trait. This method will give you a `*const c_char` which you can\n+/// feed directly to extern functions that expect a nul-terminated\n+/// string, like C's `strdup()`.\n+///\n+/// # Extracting a slice of the whole C string\n+///\n+/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n+/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// way do *not* contain the trailing nul terminator. This is useful\n+/// when you will be calling an extern function that takes a `*const\n+/// u8` argument which is not necessarily nul-terminated, plus another\n+/// argument with the length of the string \u2014 like C's `strndup()`.\n+/// You can of course get the slice's length with its\n+/// [`len`][slice.len] method.\n+///\n+/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n+/// can use [`as_bytes_with_nul`] instead.\n+///\n+/// Once you have the kind of slice you need (with or without a nul\n+/// terminator), you can call the slice's own\n+/// [`as_ptr`][slice.as_ptr] method to get a raw pointer to pass to\n+/// extern functions. See the documentation for that function for a\n+/// discussion on ensuring the lifetime of the raw pointer.\n+///\n+/// [`Into`]: ../convert/trait.Into.html\n+/// [`Vec`]: ../vec/struct.Vec.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n /// [`u8`]: ../primitive.u8.html\n+/// [`new`]: #method.new\n+/// [`as_bytes`]: #method.as_bytes\n+/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+/// [`as_ptr`]: #method.as_ptr\n+/// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n+/// [slice.len]: ../primitive.slice.html#method.len\n+/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`CStr`]: struct.CStr.html\n ///\n /// # Examples\n ///\n@@ -48,6 +98,8 @@ use str::{self, Utf8Error};\n ///     fn my_printer(s: *const c_char);\n /// }\n ///\n+/// // We are certain that our string doesn't have 0 bytes in the middle,\n+/// // so we can .unwrap()\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n@@ -58,7 +110,7 @@ use str::{self, Utf8Error};\n /// # Safety\n ///\n /// `CString` is intended for working with traditional C-style strings\n-/// (a sequence of non-null bytes terminated by a single null byte); the\n+/// (a sequence of non-nul bytes terminated by a single nul byte); the\n /// primary use case for these kinds of strings is interoperating with C-like\n /// code. Often you will need to transfer ownership to/from that external\n /// code. It is strongly recommended that you thoroughly read through the\n@@ -77,17 +129,21 @@ pub struct CString {\n \n /// Representation of a borrowed C string.\n ///\n-/// This dynamically sized type is only safely constructed via a borrowed\n-/// version of an instance of `CString`. This type can be constructed from a raw\n-/// C string as well and represents a C string borrowed from another location.\n+/// This type represents a borrowed reference to a nul-terminated\n+/// array of bytes. It can be constructed safely from a `&[`[`u8`]`]`\n+/// slice, or unsafely from a raw `*const c_char`. It can then be\n+/// converted to a Rust [`&str`] by performing UTF-8 validation, or\n+/// into an owned [`CString`].\n+///\n+/// `CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n+/// in each pair are borrowed references; the latter are owned\n+/// strings.\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n-/// placed in the signatures of FFI functions. Instead safe wrappers of FFI\n+/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n /// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n /// interface to other consumers.\n ///\n-/// [`from_ptr`]: #method.from_ptr\n-///\n /// # Examples\n ///\n /// Inspecting a foreign C string:\n@@ -100,7 +156,7 @@ pub struct CString {\n ///\n /// unsafe {\n ///     let slice = CStr::from_ptr(my_string());\n-///     println!(\"string length: {}\", slice.to_bytes().len());\n+///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n /// }\n /// ```\n ///\n@@ -122,8 +178,6 @@ pub struct CString {\n ///\n /// Converting a foreign C string into a Rust [`String`]:\n ///\n-/// [`String`]: ../string/struct.String.html\n-///\n /// ```no_run\n /// use std::ffi::CStr;\n /// use std::os::raw::c_char;\n@@ -138,6 +192,12 @@ pub struct CString {\n ///\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n+///\n+/// [`u8`]: ../primitive.u8.html\n+/// [`&str`]: ../primitive.str.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`CString`]: struct.CString.html\n+/// [`from_ptr`]: #method.from_ptr\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n@@ -148,9 +208,15 @@ pub struct CStr {\n     inner: [c_char]\n }\n \n-/// An error returned from [`CString::new`] to indicate that a nul byte was found\n-/// in the vector provided.\n+/// An error indicating that an interior nul byte was found.\n+///\n+/// While Rust strings may contain nul bytes in the middle, C strings\n+/// can't, as that byte would effectively truncate the string.\n ///\n+/// This error is created by the [`new`][`CString::new`] method on\n+/// [`CString`]. See its documentation for more.\n+///\n+/// [`CString`]: struct.CString.html\n /// [`CString::new`]: struct.CString.html#method.new\n ///\n /// # Examples\n@@ -164,9 +230,16 @@ pub struct CStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// An error returned from [`CStr::from_bytes_with_nul`] to indicate that a nul\n-/// byte was found too early in the slice provided or one wasn't found at all.\n+/// An error indicating that a nul byte was not in the expected position.\n+///\n+/// The slice used to create a [`CStr`] must have one and only one nul\n+/// byte at the end of the slice.\n ///\n+/// This error is created by the\n+/// [`from_bytes_with_nul`][`CStr::from_bytes_with_nul`] method on\n+/// [`CStr`]. See its documentation for more.\n+///\n+/// [`CStr`]: struct.CStr.html\n /// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n ///\n /// # Examples\n@@ -201,9 +274,18 @@ impl FromBytesWithNulError {\n     }\n }\n \n-/// An error returned from [`CString::into_string`] to indicate that a UTF-8 error\n-/// was encountered during the conversion.\n+/// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n+///\n+/// `CString` is just a wrapper over a buffer of bytes with a nul\n+/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n+/// validation on those bytes and may return this error.\n+///\n+/// This `struct` is created by the\n+/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n+/// its documentation for more.\n ///\n+/// [`String`]: ../string/struct.String.html\n+/// [`CString`]: struct.CString.html\n /// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n@@ -215,8 +297,11 @@ pub struct IntoStringError {\n impl CString {\n     /// Creates a new C-compatible string from a container of bytes.\n     ///\n-    /// This method will consume the provided data and use the underlying bytes\n-    /// to construct a new string, ensuring that there is a trailing 0 byte.\n+    /// This function will consume the provided data and use the\n+    /// underlying bytes to construct a new string, ensuring that\n+    /// there is a trailing 0 byte. This trailing 0 byte will be\n+    /// appended by this function; the provided data should *not*\n+    /// contain any 0 bytes in it.\n     ///\n     /// # Examples\n     ///\n@@ -234,9 +319,11 @@ impl CString {\n     ///\n     /// # Errors\n     ///\n-    /// This function will return an error if the bytes yielded contain an\n-    /// internal 0 byte. The error returned will contain the bytes as well as\n+    /// This function will return an error if the supplied bytes contain an\n+    /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n+    ///\n+    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         Self::_new(t.into())\n@@ -249,8 +336,8 @@ impl CString {\n         }\n     }\n \n-    /// Creates a C-compatible string from a byte vector without checking for\n-    /// interior 0 bytes.\n+    /// Creates a C-compatible string by consuming a byte vector,\n+    /// without checking for interior 0 bytes.\n     ///\n     /// This method is equivalent to [`new`] except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n@@ -275,7 +362,7 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C.\n+    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n@@ -286,7 +373,14 @@ impl CString {\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n+    /// > **Note:** If you need to borrow a string that was allocated by\n+    /// > foreign code, use [`CStr`]. If you need to take ownership of\n+    /// > a string that was allocated by foreign code, you will need to\n+    /// > make your own provisions for freeing it appropriately, likely\n+    /// > with the foreign code's API to do that.\n+    ///\n     /// [`into_raw`]: #method.into_raw\n+    /// [`CStr`]: struct.CStr.html\n     ///\n     /// # Examples\n     ///\n@@ -315,11 +409,11 @@ impl CString {\n         CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n     }\n \n-    /// Transfers ownership of the string to a C caller.\n+    /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n-    /// The pointer must be returned to Rust and reconstituted using\n+    /// The pointer which this function returns must be returned to Rust and reconstituted using\n     /// [`from_raw`] to be properly deallocated. Specifically, one\n-    /// should *not* use the standard C `free` function to deallocate\n+    /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n     /// Failure to call [`from_raw`] will lead to a memory leak.\n@@ -351,11 +445,27 @@ impl CString {\n         Box::into_raw(self.into_inner()) as *mut c_char\n     }\n \n-    /// Converts the `CString` into a [`String`] if it contains valid Unicode data.\n+    /// Converts the `CString` into a [`String`] if it contains valid UTF-8 data.\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n     /// [`String`]: ../string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CString;\n+    ///\n+    /// let valid_utf8 = vec![b'f', b'o', b'o'];\n+    /// let cstring = CString::new(valid_utf8).unwrap();\n+    /// assert_eq!(cstring.into_string().unwrap(), \"foo\");\n+    ///\n+    /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n+    /// let cstring = CString::new(invalid_utf8).unwrap();\n+    /// let err = cstring.into_string().err().unwrap();\n+    /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n+    /// ```\n+\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes())\n@@ -365,10 +475,11 @@ impl CString {\n             })\n     }\n \n-    /// Returns the underlying byte buffer.\n+    /// Consumes the `CString` and returns the underlying byte buffer.\n     ///\n-    /// The returned buffer does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned buffer does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes.\n     ///\n     /// # Examples\n     ///\n@@ -388,7 +499,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`into_bytes`]: #method.into_bytes\n     ///\n@@ -408,8 +519,12 @@ impl CString {\n \n     /// Returns the contents of this `CString` as a slice of bytes.\n     ///\n-    /// The returned slice does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned slice does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes. If you need the nul terminator, use\n+    /// [`as_bytes_with_nul`] instead.\n+    ///\n+    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n     ///\n     /// # Examples\n     ///\n@@ -427,7 +542,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`as_bytes`]: #method.as_bytes\n     ///\n@@ -598,8 +713,8 @@ impl Default for Box<CStr> {\n }\n \n impl NulError {\n-    /// Returns the position of the nul byte in the slice that was provided to\n-    /// [`CString::new`].\n+    /// Returns the position of the nul byte in the slice that caused\n+    /// [`CString::new`] to fail.\n     ///\n     /// [`CString::new`]: struct.CString.html#method.new\n     ///\n@@ -711,9 +826,9 @@ impl fmt::Display for IntoStringError {\n }\n \n impl CStr {\n-    /// Casts a raw C string to a safe C string wrapper.\n+    /// Wraps a raw C string with a safe C string wrapper.\n     ///\n-    /// This function will cast the provided `ptr` to the `CStr` wrapper which\n+    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n     /// allows inspection and interoperation of non-owned C strings. This method\n     /// is unsafe for a number of reasons:\n     ///\n@@ -753,9 +868,9 @@ impl CStr {\n \n     /// Creates a C string wrapper from a byte slice.\n     ///\n-    /// This function will cast the provided `bytes` to a `CStr` wrapper after\n-    /// ensuring that it is null terminated and does not contain any interior\n-    /// nul bytes.\n+    /// This function will cast the provided `bytes` to a `CStr`\n+    /// wrapper after ensuring that the byte slice is nul-terminated\n+    /// and does not contain any interior nul bytes.\n     ///\n     /// # Examples\n     ///\n@@ -766,7 +881,7 @@ impl CStr {\n     /// assert!(cstr.is_ok());\n     /// ```\n     ///\n-    /// Creating a `CStr` without a trailing nul byte is an error:\n+    /// Creating a `CStr` without a trailing nul terminator is an error:\n     ///\n     /// ```\n     /// use std::ffi::CStr;\n@@ -800,7 +915,7 @@ impl CStr {\n     /// Unsafely creates a C string wrapper from a byte slice.\n     ///\n     /// This function will cast the provided `bytes` to a `CStr` wrapper without\n-    /// performing any sanity checks. The provided slice must be null terminated\n+    /// performing any sanity checks. The provided slice **must** be nul-terminated\n     /// and not contain any interior nul bytes.\n     ///\n     /// # Examples\n@@ -822,7 +937,7 @@ impl CStr {\n \n     /// Returns the inner pointer to this C string.\n     ///\n-    /// The returned pointer will be valid for as long as `self` is and points\n+    /// The returned pointer will be valid for as long as `self` is, and points\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     ///\n@@ -843,9 +958,9 @@ impl CStr {\n     /// ```\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n-    /// lifetime information and the string is deallocated immediately after\n+    /// lifetime information and the [`CString`] is deallocated immediately after\n     /// the `CString::new(\"Hello\").unwrap().as_ptr()` expression is evaluated.\n-    /// To fix the problem, bind the string to a local variable:\n+    /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n     /// use std::ffi::{CString};\n@@ -857,6 +972,11 @@ impl CStr {\n     ///     *ptr;\n     /// }\n     /// ```\n+    ///\n+    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// the lifetime of `ptr` and the `unsafe` block.\n+    ///\n+    /// [`CString`]: struct.CString.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ptr(&self) -> *const c_char {\n@@ -865,11 +985,7 @@ impl CStr {\n \n     /// Converts this C string to a byte slice.\n     ///\n-    /// This function will calculate the length of this string (which normally\n-    /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice of `u8` elements.\n-    ///\n-    /// The returned slice will **not** contain the trailing nul that this C\n+    /// The returned slice will **not** contain the trailing nul terminator that this C\n     /// string has.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n@@ -894,7 +1010,7 @@ impl CStr {\n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n     /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul instead of chopping it off.\n+    /// the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n@@ -918,8 +1034,9 @@ impl CStr {\n \n     /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n     ///\n-    /// This function will calculate the length of this string and check for\n-    /// UTF-8 validity, and then return the [`&str`] if it's valid.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return the corresponding [`&str`] slice. Otherwise,\n+    /// it will return an error with details of where UTF-8 validation failed.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n@@ -947,18 +1064,22 @@ impl CStr {\n \n     /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n     ///\n-    /// This function will calculate the length of this string (which normally\n-    /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice as a [`Cow`]`<`[`str`]`>`, replacing any invalid UTF-8 sequences\n-    /// with `U+FFFD REPLACEMENT CHARACTER`.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n+    /// with the the corresponding [`&str`] slice. Otherwise, it will\n+    /// replace any invalid UTF-8 sequences with `U+FFFD REPLACEMENT\n+    /// CHARACTER` and return a [`Cow`]`::`[`Owned`]`(`[`String`]`)`\n+    /// with the result.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n     /// > future to perform the length calculation in addition to the UTF-8\n     /// > check whenever this method is called.\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n+    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n     /// [`str`]: ../primitive.str.html\n+    /// [`String`]: ../string/struct.String.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "a75596351e4cf3ec073fa809c29847b2e179969e", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -9,6 +9,157 @@\n // except according to those terms.\n \n //! Utilities related to FFI bindings.\n+//!\n+//! This module provides utilities to handle data across non-Rust\n+//! interfaces, like other programming languages and the underlying\n+//! operating system. It is mainly of use for FFI (Foreign Function\n+//! Interface) bindings and code that needs to exchange C-like strings\n+//! with other languages.\n+//!\n+//! # Overview\n+//!\n+//! Rust represents owned strings with the [`String`] type, and\n+//! borrowed slices of strings with the [`str`] primitive. Both are\n+//! always in UTF-8 encoding, and may contain nul bytes in the middle,\n+//! i.e. if you look at the bytes that make up the string, there may\n+//! be a `\\0` among them. Both `String` and `str` store their length\n+//! explicitly; there are no nul terminators at the end of strings\n+//! like in C.\n+//!\n+//! C strings are different from Rust strings:\n+//!\n+//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n+//! other encodings. If you are using a string from C, you should\n+//! check its encoding explicitly, rather than just assuming that it\n+//! is UTF-8 like you can do in Rust.\n+//!\n+//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n+//! characters; please **note** that C's `char` is different from Rust's.\n+//! The C standard leaves the actual sizes of those types open to\n+//! interpretation, but defines different APIs for strings made up of\n+//! each character type. Rust strings are always UTF-8, so different\n+//! Unicode characters will be encoded in a variable number of bytes\n+//! each. The Rust type [`char`] represents a '[Unicode scalar\n+//! value]', which is similar to, but not the same as, a '[Unicode\n+//! code point]'.\n+//!\n+//! * **Nul terminators and implicit string lengths** - Often, C\n+//! strings are nul-terminated, i.e. they have a `\\0` character at the\n+//! end. The length of a string buffer is not stored, but has to be\n+//! calculated; to compute the length of a string, C code must\n+//! manually call a function like `strlen()` for `char`-based strings,\n+//! or `wcslen()` for `wchar_t`-based ones. Those functions return\n+//! the number of characters in the string excluding the nul\n+//! terminator, so the buffer length is really `len+1` characters.\n+//! Rust strings don't have a nul terminator; their length is always\n+//! stored and does not need to be calculated. While in Rust\n+//! accessing a string's length is a O(1) operation (becasue the\n+//! length is stored); in C it is an O(length) operation because the\n+//! length needs to be computed by scanning the string for the nul\n+//! terminator.\n+//!\n+//! * **Internal nul characters** - When C strings have a nul\n+//! terminator character, this usually means that they cannot have nul\n+//! characters in the middle \u2014 a nul character would essentially\n+//! truncate the string. Rust strings *can* have nul characters in\n+//! the middle, because nul does not have to mark the end of the\n+//! string in Rust.\n+//!\n+//! # Representations of non-Rust strings\n+//!\n+//! [`CString`] and [`CStr`] are useful when you need to transfer\n+//! UTF-8 strings to and from languages with a C ABI, like Python.\n+//!\n+//! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n+//! string: it is nul-terminated, and has no internal nul characters.\n+//! Rust code can create a `CString` out of a normal string (provided\n+//! that the string doesn't have nul characters in the middle), and\n+//! then use a variety of methods to obtain a raw `*mut u8` that can\n+//! then be passed as an argument to functions which use the C\n+//! conventions for strings.\n+//!\n+//! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n+//! is what you would use to wrap a raw `*const u8` that you got from\n+//! a C function. A `CStr` is guaranteed to be a nul-terminated array\n+//! of bytes. Once you have a `CStr`, you can convert it to a Rust\n+//! `&str` if it's valid UTF-8, or lossily convert it by adding\n+//! replacement characters.\n+//!\n+//! [`OsString`] and [`OsStr`] are useful when you need to transfer\n+//! strings to and from the operating system itself, or when capturing\n+//! the output of external commands. Conversions between `OsString`,\n+//! `OsStr` and Rust strings work similarly to those for [`CString`]\n+//! and [`CStr`].\n+//!\n+//! * [`OsString`] represents an owned string in whatever\n+//! representation the operating system prefers. In the Rust standard\n+//! library, various APIs that transfer strings to/from the operating\n+//! system use `OsString` instead of plain strings. For example,\n+//! [`env::var_os()`] is used to query environment variables; it\n+//! returns an `Option<OsString>`. If the environment variable exists\n+//! you will get a `Some(os_string)`, which you can *then* try to\n+//! convert to a Rust string. This yields a [`Result<>`], so that\n+//! your code can detect errors in case the environment variable did\n+//! not in fact contain valid Unicode data.\n+//!\n+//! * [`OsStr`] represents a borrowed reference to a string in a\n+//! format that can be passed to the operating system. It can be\n+//! converted into an UTF-8 Rust string slice in a similar way to\n+//! `OsString`.\n+//!\n+//! # Conversions\n+//!\n+//! ## On Unix\n+//!\n+//! On Unix, [`OsStr`] implements the\n+//! `std::os::unix:ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n+//! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n+//! These do inexpensive conversions from and to UTF-8 byte slices.\n+//!\n+//! Additionally, on Unix [`OsString`] implements the\n+//! `std::os::unix:ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n+//! which provides [`from_vec`] and [`into_vec`] methods that consume\n+//! their arguments, and take or produce vectors of [`u8`].\n+//!\n+//! ## On Windows\n+//!\n+//! On Windows, [`OsStr`] implements the\n+//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n+//! which provides an [`encode_wide`] method. This provides an\n+//! iterator that can be [`collect`]ed into a vector of [`u16`].\n+//!\n+//! Additionally, on Windows [`OsString`] implements the\n+//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n+//! trait, which provides a [`from_wide`] method. The result of this\n+//! method is an `OsString` which can be round-tripped to a Windows\n+//! string losslessly.\n+//!\n+//! [`String`]: ../string/struct.String.html\n+//! [`str`]: ../primitive.str.html\n+//! [`char`]: ../primitive.char.html\n+//! [`u8`]: ../primitive.u8.html\n+//! [`u16`]: ../primitive.u16.html\n+//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n+//! [`CString`]: struct.CString.html\n+//! [`CStr`]: struct.CStr.html\n+//! [`OsString`]: struct.OsString.html\n+//! [`OsStr`]: struct.OsStr.html\n+//! [`env::set_var()`]: ../env/fn.set_var.html\n+//! [`env::var_os()`]: ../env/fn.var_os.html\n+//! [`Result<>`]: ../result/enum.Result.html\n+//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n+//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n+//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n+//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n+//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n+//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n+//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n+//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n+//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n+//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n+//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n+//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a97075ff8d8cd7f966dbd9298202e8f79a8a7661", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -32,18 +32,65 @@ use sys_common::{AsInner, IntoInner, FromInner};\n ///\n /// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n /// and platform-native string values, and in particular allowing a Rust string\n-/// to be converted into an \"OS\" string with no cost.\n+/// to be converted into an \"OS\" string with no cost if possible.\n+///\n+/// `OsString` is to [`OsStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n+///\n+/// # Creating an `OsString`\n+///\n+/// **From a Rust string**: `OsString` implements\n+/// [`From`]`<`[`String`]`>`, so you can use `my_string.`[`from`] to\n+/// create an `OsString` from a normal Rust string.\n+///\n+/// **From slices:** Just like you can start with an empty Rust\n+/// [`String`] and then [`push_str`][String.push_str] `&str`\n+/// sub-string slices into it, you can create an empty `OsString` with\n+/// the [`new`] method and then push string slices into it with the\n+/// [`push`] method.\n+///\n+/// # Extracting a borrowed reference to the whole OS string\n+///\n+/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n+/// an `OsString`; this is effectively a borrowed reference to the\n+/// whole string.\n+///\n+/// # Conversions\n+///\n+/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n+/// the traits which `OsString` implements for conversions from/to native representations.\n ///\n /// [`OsStr`]: struct.OsStr.html\n+/// [`From`]: ../convert/trait.From.html\n+/// [`from`]: ../convert/trait.From.html#tymethod.from\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n+/// [`u8`]: ../primitive.u8.html\n+/// [`u16`]: ../primitive.u16.html\n+/// [String.push_str]: ../string/struct.String.html#method.push_str\n+/// [`new`]: #method.new\n+/// [`push`]: #method.push\n+/// [`as_os_str`]: #method.as_os_str\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsString {\n     inner: Buf\n }\n \n-/// Slices into OS strings (see [`OsString`]).\n+/// Borrowed reference to an OS string (see [`OsString`]).\n+///\n+/// This type represents a borrowed reference to a string in the operating system's preferred\n+/// representation.\n+///\n+/// `OsStr` is to [`OsString`] as [`String`] is to [`&str`]: the former in each pair are borrowed\n+/// references; the latter are owned strings.\n+///\n+/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n+/// the traits which `OsStr` implements for conversions from/to native representations.\n ///\n /// [`OsString`]: struct.OsString.html\n+/// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsStr {\n     inner: Slice"}, {"sha": "d6b8896ac096d2e8caf3594a9b6459dfae69e8cb", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -9,6 +9,62 @@\n // except according to those terms.\n \n //! Windows-specific extensions to the primitives in the `std::ffi` module.\n+//!\n+//! # Overview\n+//!\n+//! For historical reasons, the Windows API uses a form of potentially\n+//! ill-formed UTF-16 encoding for strings.  Specifically, the 16-bit\n+//! code units in Windows strings may contain [isolated surrogate code\n+//! points which are not paired together][ill-formed-utf-16].  The\n+//! Unicode standard requires that surrogate code points (those in the\n+//! range U+D800 to U+DFFF) always be *paired*, because in the UTF-16\n+//! encoding a *surrogate code unit pair* is used to encode a single\n+//! character.  For compatibility with code that does not enforce\n+//! these pairings, Windows does not enforce them, either.\n+//!\n+//! While it is not always possible to convert such a string losslessly into\n+//! a valid UTF-16 string (or even UTF-8), it is often desirable to be\n+//! able to round-trip such a string from and to Windows APIs\n+//! losslessly.  For example, some Rust code may be \"bridging\" some\n+//! Windows APIs together, just passing `WCHAR` strings among those\n+//! APIs without ever really looking into the strings.\n+//!\n+//! If Rust code *does* need to look into those strings, it can\n+//! convert them to valid UTF-8, possibly lossily, by substituting\n+//! invalid sequences with U+FFFD REPLACEMENT CHARACTER, as is\n+//! conventionally done in other Rust APIs that deal with string\n+//! encodings.\n+//!\n+//! # `OsStringExt` and `OsStrExt`\n+//!\n+//! [`OsString`] is the Rust wrapper for owned strings in the\n+//! preferred representation of the operating system.  On Windows,\n+//! this struct gets augmented with an implementation of the\n+//! [`OsStringExt`] trait, which has a [`from_wide`] method.  This\n+//! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n+//! you get such a slice out of a `WCHAR` Windows API.\n+//!\n+//! Similarly, [`OsStr`] is the Rust wrapper for borrowed strings from\n+//! preferred representation of the operating system.  On Windows, the\n+//! [`OsStrExt`] trait provides the [`encode_wide`] method, which\n+//! outputs an [`EncodeWide`] iterator.  You can [`collect`] this\n+//! iterator, for example, to obtain a `Vec<u16>`; you can later get a\n+//! pointer to this vector's contents and feed it to Windows APIs.\n+//!\n+//! These traits, along with [`OsString`] and [`OsStr`], work in\n+//! conjunction so that it is possible to **round-trip** strings from\n+//! Windows and back, with no loss of data, even if the strings are\n+//! ill-formed UTF-16.\n+//!\n+//! [ill-formed-utf-16]: https://simonsapin.github.io/wtf-8/#ill-formed-utf-16\n+//! [`OsString`]: ../../../ffi/struct.OsString.html\n+//! [`OsStr`]: ../../../ffi/struct.OsStr.html\n+//! [`OsStringExt`]: trait.OsStringExt.html\n+//! [`OsStrExt`]: trait.OsStrExt.html\n+//! [`EncodeWide`]: struct.EncodeWide.html\n+//! [`from_wide`]: trait.OsStringExt.html#tymethod.from_wide\n+//! [`encode_wide`]: trait.OsStrExt.html#tymethod.encode_wide\n+//! [`collect`]: ../../../iter/trait.Iterator.html#method.collect\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "04e6cdcfe5820fe0197f73b0c46d8c5dbe8b8996", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -2314,6 +2314,7 @@ impl<'a> Parser<'a> {\n \n         while self.token != token::CloseDelim(token::Brace) {\n             if self.eat(&token::DotDot) {\n+                let exp_span = self.prev_span;\n                 match self.parse_expr() {\n                     Ok(e) => {\n                         base = Some(e);\n@@ -2323,6 +2324,16 @@ impl<'a> Parser<'a> {\n                         self.recover_stmt();\n                     }\n                 }\n+                if self.token == token::Comma {\n+                    let mut err = self.sess.span_diagnostic.mut_span_err(\n+                        exp_span.to(self.prev_span),\n+                        \"cannot use a comma after the base struct\",\n+                    );\n+                    err.span_suggestion_short(self.span, \"remove this comma\", \"\".to_owned());\n+                    err.note(\"the base struct must always be the last field\");\n+                    err.emit();\n+                    self.recover_stmt();\n+                }\n                 break;\n             }\n \n@@ -2960,6 +2971,7 @@ impl<'a> Parser<'a> {\n                 {                                  //     Foo<Bar<Baz<Qux, ()>>>\n                     err.help(\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n+                    err.help(\"or use `(...)` if you meant to specify fn arguments\");\n                 }\n                 err.emit();\n             }"}, {"sha": "83b72cedfd7800ffc983d2855a85c5d06a545aa7", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -1 +1 @@\n-Subproject commit c7a16bd57c2a9c643a52f0cebecdaf0b6a996da1\n+Subproject commit 83b72cedfd7800ffc983d2855a85c5d06a545aa7"}, {"sha": "2d37fc79250357f9d1b0deab53e123c48103c5c3", "filename": "src/test/compile-fail/index-help.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fcompile-fail%2Findex-help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fcompile-fail%2Findex-help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex-help.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = vec![1];\n+    x[0i32]; //~ ERROR E0277\n+             //~| NOTE vector indices are of type `usize` or ranges of `usize`\n+}"}, {"sha": "1ee6996ce9c848f07f94aea5205a79bb0af1203b", "filename": "src/test/parse-fail/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fparse-fail%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fparse-fail%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frequire-parens-for-chained-comparison.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -21,5 +21,6 @@ fn main() {\n \n     f<X>();\n     //~^ ERROR: chained comparison operators require parentheses\n-    //~^^ HELP: use `::<...>` instead of `<...>`\n+    //~| HELP: use `::<...>` instead of `<...>`\n+    //~| HELP: or use `(...)`\n }"}, {"sha": "bcbd3fd3786ab4555da1b24961e880db5728d7b6", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/305e02281bf6e7a5398f93f86c901316074be0a5/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305e02281bf6e7a5398f93f86c901316074be0a5/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=305e02281bf6e7a5398f93f86c901316074be0a5", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Smallest \"hello world\" with a libc runtime\n-\n-// ignore-windows\n-// ignore-android\n-\n-#![feature(intrinsics, lang_items, start, no_core, alloc_system)]\n-#![feature(global_allocator, allocator_api)]\n-#![no_std]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static A: System = System;\n-\n-extern {\n-    fn puts(s: *const u8);\n-}\n-\n-#[no_mangle]\n-#[lang = \"eh_personality\"] pub extern fn rust_eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-\n-#[start]\n-fn main(_: isize, _: *const *const u8) -> isize {\n-    unsafe {\n-        puts(\"Hello!\\0\".as_ptr() as *const u8);\n-    }\n-    return 0\n-}"}, {"sha": "1c15da5469e527c463c85e78539c8ad20a5f4ec0", "filename": "src/test/run-pass/thin-lto-global-allocator.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Frun-pass%2Fthin-lto-global-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Frun-pass%2Fthin-lto-global-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthin-lto-global-allocator.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z thinlto -C codegen-units=2\n+// min-llvm-version 4.0\n+\n+#![feature(allocator_api, global_allocator)]\n+\n+#[global_allocator]\n+static A: std::heap::System = std::heap::System;\n+\n+fn main() {}"}, {"sha": "11279f5c6129ff2237503d61ffd987ce7d240af8", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -5,6 +5,7 @@ error: chained comparison operators require parentheses\n    |                                     ^^^^^^^^\n    |\n    = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n \n error: chained comparison operators require parentheses\n   --> $DIR/issue-40396.rs:16:25\n@@ -13,6 +14,7 @@ error: chained comparison operators require parentheses\n    |                         ^^^^^^^\n    |\n    = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n \n error: chained comparison operators require parentheses\n   --> $DIR/issue-40396.rs:20:37\n@@ -21,6 +23,7 @@ error: chained comparison operators require parentheses\n    |                                     ^^^^^^^^\n    |\n    = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n \n error: chained comparison operators require parentheses\n   --> $DIR/issue-40396.rs:20:41\n@@ -29,6 +32,7 @@ error: chained comparison operators require parentheses\n    |                                         ^^^^^^\n    |\n    = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n \n error: aborting due to 4 previous errors\n "}, {"sha": "8ea62fef9fad193bc7013e50b4febbff7841245f", "filename": "src/test/ui/struct-field-init-syntax.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fstruct-field-init-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fstruct-field-init-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-field-init-syntax.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// issue #41834\n+\n+fn main() {\n+    let foo = Foo {\n+        one: 111,\n+        ..Foo::default(),\n+        //~^ ERROR cannot use a comma after struct expansion\n+    };\n+\n+    let foo = Foo {\n+        ..Foo::default(),\n+        //~^ ERROR cannot use a comma after struct expansion\n+        one: 111,\n+    };\n+}"}, {"sha": "0bca3f83eb1a3ba40bbea0776fdd5c6d1e4d7265", "filename": "src/test/ui/struct-field-init-syntax.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fstruct-field-init-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fstruct-field-init-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-field-init-syntax.stderr?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,18 @@\n+error: cannot use a comma after the base struct\n+  --> $DIR/struct-field-init-syntax.rs:18:9\n+   |\n+18 |         ..Foo::default(),\n+   |         ^^^^^^^^^^^^^^^^- help: remove this comma\n+   |\n+   = note: the base struct must always be the last field\n+\n+error: cannot use a comma after the base struct\n+  --> $DIR/struct-field-init-syntax.rs:23:9\n+   |\n+23 |         ..Foo::default(),\n+   |         ^^^^^^^^^^^^^^^^- help: remove this comma\n+   |\n+   = note: the base struct must always be the last field\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "fe8e2bc6c8ed10046f0f45891af5dec585c8e67f", "filename": "src/test/ui/suggestions/closure-immutable-outer-variable.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Point at the captured immutable outer variable\n+\n+fn foo(mut f: Box<FnMut()>) {\n+    f();\n+}\n+\n+fn main() {\n+    let y = true;\n+    foo(Box::new(move || y = false) as Box<_>);\n+}"}, {"sha": "19f1cd071714e57961f072993083e4deb6669be9", "filename": "src/test/ui/suggestions/closure-immutable-outer-variable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.stderr?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,10 @@\n+error[E0594]: cannot assign to captured outer variable in an `FnMut` closure\n+  --> $DIR/closure-immutable-outer-variable.rs:19:26\n+   |\n+18 |     let y = true;\n+   |         - help: consider making `y` mutable: `mut y`\n+19 |     foo(Box::new(move || y = false) as Box<_>);\n+   |                          ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5bebce79eccbc2b3a1cd9961d8c851e6f134c232", "filename": "src/test/ui/suggestions/suggest-labels.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-labels.rs?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unreachable_code)]\n+fn main() {\n+    'foo: loop {\n+        break 'fo;\n+    }\n+\n+    'bar: loop {\n+        continue 'bor;\n+    }\n+\n+    'longlabel: loop {\n+        'longlabel1: loop {\n+            break 'longlable;\n+        }\n+    }\n+}"}, {"sha": "23aa18a3655fb1ec90214b2a2ec5c75de524a9bc", "filename": "src/test/ui/suggestions/suggest-labels.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-labels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-labels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-labels.stderr?ref=6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "patch": "@@ -0,0 +1,20 @@\n+error[E0426]: use of undeclared label `'fo`\n+  --> $DIR/suggest-labels.rs:14:15\n+   |\n+14 |         break 'fo;\n+   |               ^^^ did you mean `'foo`?\n+\n+error[E0426]: use of undeclared label `'bor`\n+  --> $DIR/suggest-labels.rs:18:18\n+   |\n+18 |         continue 'bor;\n+   |                  ^^^^ did you mean `'bar`?\n+\n+error[E0426]: use of undeclared label `'longlable`\n+  --> $DIR/suggest-labels.rs:23:19\n+   |\n+23 |             break 'longlable;\n+   |                   ^^^^^^^^^^ did you mean `'longlabel1`?\n+\n+error: aborting due to 3 previous errors\n+"}]}