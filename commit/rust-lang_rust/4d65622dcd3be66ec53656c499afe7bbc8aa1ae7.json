{"sha": "4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjU2MjJkY2QzYmU2NmVjNTM2NTZjNDk5YWZlN2JiYzhhYTFhZTc=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-02-16T07:28:59Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-02-18T20:28:44Z"}, "message": "Properly implement labeled breaks in while conditions", "tree": {"sha": "9cbc5fbf98ef9ce23444f41a75e17c1f71a792c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cbc5fbf98ef9ce23444f41a75e17c1f71a792c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "html_url": "https://github.com/rust-lang/rust/commit/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5205e2f8b8094a5f3d0205593820391dfe481808", "url": "https://api.github.com/repos/rust-lang/rust/commits/5205e2f8b8094a5f3d0205593820391dfe481808", "html_url": "https://github.com/rust-lang/rust/commit/5205e2f8b8094a5f3d0205593820391dfe481808"}], "stats": {"total": 305, "additions": 247, "deletions": 58}, "files": [{"sha": "fdb350ebaac976b8c0cb30cea7c44541a97ac9db", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -220,15 +220,24 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n-                // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let cond_exit = self.expr(&cond, loopback);             // 2\n-                let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n+\n+                // Create expr_exit without pred (cond_exit)\n+                let expr_exit = self.add_ast_node(expr.id, &[]);         // 3\n+\n+                // The LoopScope needs to be on the loop_scopes stack while evaluating the\n+                // condition and the body of the loop (both can break out of the loop)\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n+\n+                let cond_exit = self.expr(&cond, loopback);             // 2\n+\n+                // Add pred (cond_exit) to expr_exit\n+                self.add_contained_edge(cond_exit, expr_exit);\n+\n                 let body_exit = self.block(&body, cond_exit);          // 4\n                 self.add_contained_edge(body_exit, loopback);            // 5\n                 self.loop_scopes.pop();\n@@ -580,11 +589,17 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope(&self,\n                   expr: &hir::Expr,\n                   label: hir::Label) -> LoopScope {\n-        for l in &self.loop_scopes {\n-            if l.loop_id == label.loop_id {\n-                return *l;\n+\n+        match label.loop_id.into() {\n+            Ok(loop_id) => {\n+                for l in &self.loop_scopes {\n+                    if l.loop_id == loop_id {\n+                        return *l;\n+                    }\n+                }\n+                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n             }\n+            Err(err) => span_bug!(expr.span, \"loop scope error: {}\",  err)\n         }\n-        span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n     }\n }"}, {"sha": "fd6796ccc0bf2b0cd6b7957281a960c99322ff4c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -1008,14 +1008,18 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         }\n         ExprBreak(label, ref opt_expr) => {\n             label.ident.map(|ident| {\n-                visitor.visit_def_mention(Def::Label(label.loop_id));\n+                if let Ok(loop_id) = label.loop_id.into() {\n+                    visitor.visit_def_mention(Def::Label(loop_id));\n+                }\n                 visitor.visit_name(ident.span, ident.node.name);\n             });\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n         ExprAgain(label) => {\n             label.ident.map(|ident| {\n-                visitor.visit_def_mention(Def::Label(label.loop_id));\n+                if let Ok(loop_id) = label.loop_id.into() {\n+                    visitor.visit_def_mention(Def::Label(loop_id));\n+                }\n                 visitor.visit_name(ident.span, ident.node.name);\n             });\n         }"}, {"sha": "55226fa7605d3923aded83ea3273b11affd033d9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -81,6 +81,7 @@ pub struct LoweringContext<'a> {\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n \n     loop_scopes: Vec<NodeId>,\n+    is_in_loop_condition: bool,\n \n     type_def_lifetime_params: DefIdMap<usize>,\n }\n@@ -116,6 +117,7 @@ pub fn lower_crate(sess: &Session,\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n         loop_scopes: Vec::new(),\n+        is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n@@ -251,21 +253,49 @@ impl<'a> LoweringContext<'a> {\n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n+        // We're no longer in the base loop's condition; we're in another loop.\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n         let len = self.loop_scopes.len();\n         self.loop_scopes.push(loop_id);\n+\n         let result = f(self);\n         assert_eq!(len + 1, self.loop_scopes.len(),\n             \"Loop scopes should be added and removed in stack order\");\n+\n         self.loop_scopes.pop().unwrap();\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = true;\n+\n+        let result = f(self);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n         result\n     }\n \n     fn with_new_loop_scopes<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n         let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n         let result = f(self);\n         mem::replace(&mut self.loop_scopes, loop_scopes);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n         result\n     }\n \n@@ -300,17 +330,16 @@ impl<'a> LoweringContext<'a> {\n         match label {\n             Some((id, label_ident)) => hir::Label {\n                 ident: Some(label_ident),\n-                loop_id: match self.expect_full_def(id) {\n-                    Def::Label(loop_id) => loop_id,\n-                    _ => DUMMY_NODE_ID\n+                loop_id: if let Def::Label(loop_id) = self.expect_full_def(id) {\n+                    hir::LoopIdResult::Ok(loop_id)\n+                } else {\n+                    hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 }\n             },\n             None => hir::Label {\n                 ident: None,\n-                loop_id: match self.loop_scopes.last() {\n-                    Some(innermost_loop_id) => *innermost_loop_id,\n-                    _ => DUMMY_NODE_ID\n-                }\n+                loop_id: self.loop_scopes.last().map(|innermost_loop_id| Ok(*innermost_loop_id))\n+                            .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)).into()\n             }\n         }\n     }\n@@ -1597,7 +1626,7 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n                     self.with_loop_scope(e.id, |this|\n                         hir::ExprWhile(\n-                            P(this.lower_expr(cond)),\n+                            this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n                             this.lower_block(body),\n                             this.lower_opt_sp_ident(opt_ident)))\n                 }\n@@ -1699,13 +1728,29 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n+                    let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n+                        hir::Label {\n+                            ident: opt_ident,\n+                            loop_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                        }\n+                    } else {\n+                        self.lower_label(opt_ident.map(|ident| (e.id, ident)))\n+                    };\n                     hir::ExprBreak(\n-                        self.lower_label(opt_ident.map(|ident| (e.id, ident))),\n-                                   opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n+                            label_result,\n+                            opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n                 ExprKind::Continue(opt_ident) =>\n                     hir::ExprAgain(\n-                        self.lower_label(opt_ident.map(|ident| (e.id, ident)))),\n+                        if self.is_in_loop_condition && opt_ident.is_none() {\n+                            hir::Label {\n+                                ident: opt_ident,\n+                                loop_id: Err(\n+                                    hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                            }\n+                        } else {\n+                            self.lower_label(opt_ident.map( | ident| (e.id, ident)))\n+                        }),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1846,10 +1891,12 @@ impl<'a> LoweringContext<'a> {\n                     //     }\n                     //   }\n \n+                    // Note that the block AND the condition are evaluated in the loop scope.\n+                    // This is done to allow `break` from inside the condition of the loop.\n                     let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n                         this.lower_block(body),\n                         this.expr_break(e.span, ThinVec::new()),\n-                        P(this.lower_expr(sub_expr)),\n+                        this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n                     ));\n \n                     // `<pat> => <body>`"}, {"sha": "4e4187cbf8905c05bea89f9fe817499d985d20e0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -1030,11 +1030,56 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LoopIdError {\n+    OutsideLoopScope,\n+    UnlabeledCfInWhileCondition,\n+    UnresolvedLabel,\n+}\n+\n+impl fmt::Display for LoopIdError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(match *self {\n+            LoopIdError::OutsideLoopScope => \"not inside loop scope\",\n+            LoopIdError::UnlabeledCfInWhileCondition =>\n+                \"unlabeled control flow (break or continue) in while condition\",\n+            LoopIdError::UnresolvedLabel => \"label not found\",\n+        }, f)\n+    }\n+}\n+\n+// FIXME(cramertj) this should use `Result` once master compiles w/ a vesion of Rust where\n+// `Result` implements `Encodable`/`Decodable`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LoopIdResult {\n+    Ok(NodeId),\n+    Err(LoopIdError),\n+}\n+impl Into<Result<NodeId, LoopIdError>> for LoopIdResult {\n+    fn into(self) -> Result<NodeId, LoopIdError> {\n+        match self {\n+            LoopIdResult::Ok(ok) => Ok(ok),\n+            LoopIdResult::Err(err) => Err(err),\n+        }\n+    }\n+}\n+impl From<Result<NodeId, LoopIdError>> for LoopIdResult {\n+    fn from(res: Result<NodeId, LoopIdError>) -> Self {\n+        match res {\n+            Ok(ok) => LoopIdResult::Ok(ok),\n+            Err(err) => LoopIdResult::Err(err),\n+        }\n+    }\n+}\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Label {\n+    // This is `Some(_)` iff there is an explicit user-specified `label\n     pub ident: Option<Spanned<Ident>>,\n-    pub loop_id: NodeId\n+\n+    // These errors are caught and then reported during the diagnostics pass in\n+    // librustc_passes/loops.rs\n+    pub loop_id: LoopIdResult,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "b7f7c49d7b0e36bb2cc007b13103c927ab005d54", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -1003,7 +1003,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = label.loop_id;\n+              let sc = match label.loop_id.into() {\n+                  Ok(loop_id) => loop_id,\n+                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              };\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1016,7 +1019,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAgain(label) => {\n               // Find which label this expr continues to\n-              let sc = label.loop_id;\n+              let sc = match label.loop_id.into() {\n+                  Ok(loop_id) => loop_id,\n+                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              };\n+\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1280,12 +1287,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n-        let cond_ln = match kind {\n-            LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n-        };\n-        let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n-            this.propagate_through_block(body, cond_ln)\n+        let (cond_ln, body_ln) = self.with_loop_nodes(expr.id, succ, ln, |this| {\n+            let cond_ln = match kind {\n+                LoopLoop => ln,\n+                WhileLoop(ref cond) => this.propagate_through_expr(&cond, ln),\n+            };\n+            let body_ln = this.propagate_through_block(body, cond_ln);\n+            (cond_ln, body_ln)\n         });\n \n         // repeat until fixed point is reached:"}, {"sha": "282361fc13e27054f37a759ff1793de2004cead4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -389,9 +389,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                            -> &mut LoopScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.loop_scopes.iter_mut()\n-                   .rev()\n-                   .filter(|loop_scope| loop_scope.extent == label)\n-                   .next()\n+            .rev()\n+            .filter(|loop_scope| loop_scope.extent == label)\n+            .next()\n             .unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n "}, {"sha": "3a9ac143f783be4ff91377b5a7e36960647977b3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -605,14 +605,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n         hir::ExprBreak(label, ref value) => {\n-            ExprKind::Break {\n-                label: cx.tcx.region_maps.node_extent(label.loop_id),\n-                value: value.to_ref(),\n+            match label.loop_id.into() {\n+                Ok(loop_id) => ExprKind::Break {\n+                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                    value: value.to_ref(),\n+                },\n+                Err(err) => bug!(\"invalid loop id for break: {}\", err)\n             }\n+\n         }\n         hir::ExprAgain(label) => {\n-            ExprKind::Continue {\n-                label: cx.tcx.region_maps.node_extent(label.loop_id),\n+            match label.loop_id.into() {\n+                Ok(loop_id) => ExprKind::Continue {\n+                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                },\n+                Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n             }\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {"}, {"sha": "c576b35cb17b41db11f602c2482935469ce9c0ee", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -241,6 +241,22 @@ match 5u32 {\n }\n ```\n \"##,\n+\n+E0583: r##\"\n+`break` or `continue` must include a label when used in the condition of a\n+`while` loop.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+while break {}\n+```\n+\n+To fix this, add a label specifying which loop is being broken out of:\n+```\n+`foo: while break `foo {}\n+```\n+\"##\n }\n \n register_diagnostics! {"}, {"sha": "003142f349831e7a121e12e48878a7c0f70f7c0b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -87,11 +87,21 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n+                let loop_id = match label.loop_id.into() {\n+                    Ok(loop_id) => loop_id,\n+                    Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n+                    Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n+                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                        ast::DUMMY_NODE_ID\n+                    },\n+                    Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n+                };\n+\n                 if opt_expr.is_some() {\n-                    let loop_kind = if label.loop_id == ast::DUMMY_NODE_ID {\n+                    let loop_kind = if loop_id == ast::DUMMY_NODE_ID {\n                         None\n                     } else {\n-                        Some(match self.hir_map.expect_expr(label.loop_id).node {\n+                        Some(match self.hir_map.expect_expr(loop_id).node {\n                             hir::ExprWhile(..) => LoopKind::WhileLoop,\n                             hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n                             ref r => span_bug!(e.span,\n@@ -110,9 +120,15 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         }\n                     }\n                 }\n+\n                 self.require_loop(\"break\", e.span);\n             }\n-            hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n+            hir::ExprAgain(label) => {\n+                if let Err(hir::LoopIdError::UnlabeledCfInWhileCondition) = label.loop_id.into() {\n+                    self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                }\n+                self.require_loop(\"continue\", e.span)\n+            },\n             _ => intravisit::walk_expr(self, e),\n         }\n     }\n@@ -143,4 +159,12 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n             }\n         }\n     }\n+\n+    fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n+        struct_span_err!(self.sess, span, E0583,\n+                         \"`break` or `continue` with no label in the condition of a `while` loop\")\n+            .span_label(span,\n+                        &format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n+            .emit();\n+    }\n }"}, {"sha": "c254833be64729bf2fec2513d906d0cf78f37820", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -2770,18 +2770,24 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+    fn with_resolved_label<F>(&mut self, label: Option<SpannedIdent>, id: NodeId, f: F)\n+        where F: FnOnce(&mut Resolver)\n+    {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n                 this.label_ribs.last_mut().unwrap().bindings.insert(label.node, def);\n-                this.visit_block(block);\n+                f(this);\n             });\n         } else {\n-            self.visit_block(block);\n+            f(self);\n         }\n     }\n \n+    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+        self.with_resolved_label(label, id, |this| this.visit_block(block));\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2835,18 +2841,18 @@ impl<'a> Resolver<'a> {\n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n             ExprKind::While(ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.resolve_labeled_block(label, expr.id, &block);\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.visit_expr(subexpression);\n+                    this.visit_block(block);\n+                });\n             }\n \n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.visit_expr(subexpression);\n+                    this.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n+                    this.visit_block(block);\n+                });\n             }\n \n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {"}, {"sha": "f2c256ed7b158ea1e2a1814d372cec3540d44f59", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -425,8 +425,9 @@ pub struct EnclosingLoops<'gcx, 'tcx> {\n }\n \n impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n-    fn find_loop(&mut self, id: ast::NodeId) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n-        if let Some(ix) = self.by_id.get(&id).cloned() {\n+    fn find_loop(&mut self, id: hir::LoopIdResult) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n+        let id_res: Result<_,_> = id.into();\n+        if let Some(ix) = id_res.ok().and_then(|id| self.by_id.get(&id).cloned()) {\n             Some(&mut self.stack[ix])\n         } else {\n             None\n@@ -3592,10 +3593,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(label, ref expr_opt) => {\n-            let loop_id = label.loop_id;\n             let coerce_to = {\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+                enclosing_loops.find_loop(label.loop_id).map(|ctxt| ctxt.coerce_to)\n             };\n             if let Some(coerce_to) = coerce_to {\n                 let e_ty;\n@@ -3610,8 +3610,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     e_ty = tcx.mk_nil();\n                     cause = self.misc(expr.span);\n                 }\n+\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+                let ctxt = enclosing_loops.find_loop(label.loop_id).unwrap();\n \n                 let result = if let Some(ref e) = *expr_opt {\n                     // Special-case the first element, as it has no \"previous expressions\"."}, {"sha": "4906a8e71d7a4fad61a4d5b57bbedb7e4d5f7500", "filename": "src/test/run-pass/loop-break-value.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d65622dcd3be66ec53656c499afe7bbc8aa1ae7/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-break-value.rs?ref=4d65622dcd3be66ec53656c499afe7bbc8aa1ae7", "patch": "@@ -122,4 +122,20 @@ pub fn main() {\n         panic!();\n     };\n     assert_eq!(nested_break_value, \"hello\");\n+\n+    let break_from_while_cond = loop {\n+        'inner_loop: while break 'inner_loop {\n+            panic!();\n+        }\n+        break 123;\n+    };\n+    assert_eq!(break_from_while_cond, 123);\n+\n+    let break_from_while_to_outer = 'outer_loop: loop {\n+        while break 'outer_loop 567 {\n+            panic!(\"from_inner\");\n+        }\n+        panic!(\"from outer\");\n+    };\n+    assert_eq!(break_from_while_to_outer, 567);\n }"}]}