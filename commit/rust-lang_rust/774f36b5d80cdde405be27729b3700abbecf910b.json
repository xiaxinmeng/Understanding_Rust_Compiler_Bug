{"sha": "774f36b5d80cdde405be27729b3700abbecf910b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NGYzNmI1ZDgwY2RkZTQwNWJlMjc3MjliMzcwMGFiYmVjZjkxMGI=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-02T18:49:44Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-02T18:49:44Z"}, "message": "Remove further code duplication", "tree": {"sha": "cc52ef954a4ea6106470ad09523fcd9eaa787fd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc52ef954a4ea6106470ad09523fcd9eaa787fd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/774f36b5d80cdde405be27729b3700abbecf910b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/774f36b5d80cdde405be27729b3700abbecf910b", "html_url": "https://github.com/rust-lang/rust/commit/774f36b5d80cdde405be27729b3700abbecf910b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/774f36b5d80cdde405be27729b3700abbecf910b/comments", "author": null, "committer": null, "parents": [{"sha": "19e10e3a817336bf01dc13a15fedfb88116c61d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/19e10e3a817336bf01dc13a15fedfb88116c61d9", "html_url": "https://github.com/rust-lang/rust/commit/19e10e3a817336bf01dc13a15fedfb88116c61d9"}], "stats": {"total": 193, "additions": 56, "deletions": 137}, "files": [{"sha": "26bc845a15aa97b9f5dcad1c5e94db64760b6362", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 56, "deletions": 137, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/774f36b5d80cdde405be27729b3700abbecf910b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/774f36b5d80cdde405be27729b3700abbecf910b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=774f36b5d80cdde405be27729b3700abbecf910b", "patch": "@@ -409,24 +409,12 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _ => check_matrix_for_wild(cx, m),\n       },\n       ty::ty_enum(eid, _) => {\n-        let mut found = Vec::new();\n-        for r in m.iter() {\n-            let r = pat_ctor_id(cx, *r.get(0));\n-            for id in r.move_iter() {\n-                if !found.contains(&id) {\n-                    found.push(id);\n-                }\n-            }\n-        }\n+        let pat_ctors: Vec<ctor> = m\n+          .iter()\n+          .filter_map(|r| pat_ctor_id(cx, *r.get(0)))\n+          .collect();\n         let variants = ty::enum_variants(cx.tcx, eid);\n-        if found.len() != (*variants).len() {\n-            for v in (*variants).iter() {\n-                if !found.iter().any(|x| x == &(variant(v.id))) {\n-                    return Some(variant(v.id));\n-                }\n-            }\n-            fail!();\n-        } else { None }\n+        variants.iter().map(|v| variant(v.id)).find(|c| !pat_ctors.contains(c))\n       }\n       ty::ty_nil => None,\n       ty::ty_bool => {\n@@ -567,6 +555,21 @@ fn wild_multi() -> @Pat {\n     @Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n }\n \n+fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n+    let (c_from, c_to) = match *ctor_id {\n+        val(ref value)          => (value, value),\n+        range(ref from, ref to) => (from, to),\n+        single                  => return Some(true),\n+        _                       => unreachable!()\n+    };\n+    let cmp_from = compare_const_vals(c_from, from);\n+    let cmp_to = compare_const_vals(c_to, to);\n+    match (cmp_from, cmp_to) {\n+        (Some(val1), Some(val2)) => Some(val1 >= 0 && val2 <= 0),\n+        _ => None\n+    }\n+}\n+\n fn specialize(cx: &MatchCheckCtxt,\n                   r: &[@Pat],\n                   ctor_id: &ctor,\n@@ -592,41 +595,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                         }\n                     }\n                     Some(DefStatic(did, _)) => {\n-                        let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).unwrap();\n+                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match *ctor_id {\n-                            val(ref v) => {\n-                                match compare_const_vals(&e_v, v) {\n-                                    Some(val1) => (val1 == 0),\n-                                    None => {\n-                                        cx.tcx.sess.span_err(*pat_span,\n-                                            \"mismatched types between arms\");\n-                                        false\n-                                    }\n-                                }\n-                            },\n-                            range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v);\n-                                let m2 = compare_const_vals(c_hi, &e_v);\n-                                match (m1, m2) {\n-                                    (Some(val1), Some(val2)) => {\n-                                        (val1 >= 0 && val2 <= 0)\n-                                    }\n-                                    _ => {\n-                                        cx.tcx.sess.span_err(*pat_span,\n-                                            \"mismatched types between ranges\");\n-                                        false\n-                                    }\n-                                }\n-                            }\n-                            single => true,\n-                            _ => fail!(\"type error\")\n-                        };\n-                        if match_ {\n-                            Some(vec!())\n-                        } else {\n-                            None\n+                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                           Some(true) => Some(vec!()),\n+                           Some(false) => None,\n+                           None => {\n+                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                              None\n+                           }\n                         }\n                     }\n                     _ => {\n@@ -638,38 +615,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                 let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n                 match def {\n                     DefStatic(did, _) => {\n-                        let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).unwrap();\n+                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match *ctor_id {\n-                            val(ref v) =>\n-                                match compare_const_vals(&e_v, v) {\n-                                    Some(val1) => (val1 == 0),\n-                                    None => {\n-                                        cx.tcx.sess.span_err(*pat_span,\n-                                            \"mismatched types between arms\");\n-                                        false\n-                                    }\n-                                },\n-                            range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v);\n-                                let m2 = compare_const_vals(c_hi, &e_v);\n-                                match (m1, m2) {\n-                                    (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n-                                    _ => {\n-                                        cx.tcx.sess.span_err(*pat_span,\n-                                            \"mismatched types between ranges\");\n-                                        false\n-                                    }\n-                                }\n-                            }\n-                            single => true,\n-                            _ => fail!(\"type error\")\n-                        };\n-                        if match_ {\n-                            Some(vec!())\n-                        } else {\n-                            None\n+                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                           Some(true) => Some(vec!()),\n+                           Some(false) => None,\n+                           None => {\n+                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                              None\n+                           }\n                         }\n                     }\n                     DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n@@ -720,68 +674,33 @@ fn specialize(cx: &MatchCheckCtxt,\n \n             }\n             &PatTup(ref args) => {\n-                Some(args.iter().map(|x| *x).collect())\n+                Some(args.clone())\n             }\n             &PatBox(ref inner) | &PatRegion(ref inner) => {\n                 Some(vec!(inner.clone()))\n             }\n             &PatLit(ref expr) => {\n-                let e_v = eval_const_expr(cx.tcx, *expr);\n-                let match_ = match *ctor_id {\n-                    val(ref v) => {\n-                        match compare_const_vals(&e_v, v) {\n-                            Some(val1) => val1 == 0,\n-                            None => {\n-                                cx.tcx.sess.span_err(*pat_span,\n-                                    \"mismatched types between arms\");\n-                                false\n-                            }\n-                        }\n-                    },\n-                    range(ref c_lo, ref c_hi) => {\n-                        let m1 = compare_const_vals(c_lo, &e_v);\n-                        let m2 = compare_const_vals(c_hi, &e_v);\n-                        match (m1, m2) {\n-                            (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n-                            _ => {\n-                                cx.tcx.sess.span_err(*pat_span,\n-                                    \"mismatched types between ranges\");\n-                                false\n-                            }\n-                        }\n-                    }\n-                    single => true,\n-                    _ => fail!(\"type error\")\n-                };\n-                if match_ {\n-                    Some(vec!())\n-                } else {\n+              let expr_value = eval_const_expr(cx.tcx, *expr);\n+              match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n+                 Some(true) => Some(vec!()),\n+                 Some(false) => None,\n+                 None => {\n+                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                     None\n-                }\n+                 }\n+              }\n             }\n-            &PatRange(lo, hi) => {\n-                let (c_lo, c_hi) = match *ctor_id {\n-                    val(ref v) => (v, v),\n-                    range(ref lo, ref hi) => (lo, hi),\n-                    single => return Some(vec!()),\n-                    _ => fail!(\"type error\")\n-                };\n-                let v_lo = eval_const_expr(cx.tcx, lo);\n-                let v_hi = eval_const_expr(cx.tcx, hi);\n-\n-                let m1 = compare_const_vals(c_lo, &v_lo);\n-                let m2 = compare_const_vals(c_hi, &v_hi);\n-                match (m1, m2) {\n-                    (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(vec!())\n-                    },\n-                    (Some(_), Some(_)) => None,\n-                    _ => {\n-                        cx.tcx.sess.span_err(*pat_span,\n-                            \"mismatched types between ranges\");\n-                        None\n-                    }\n-                }\n+            &PatRange(ref from, ref to) => {\n+              let from_value = eval_const_expr(cx.tcx, *from);\n+              let to_value = eval_const_expr(cx.tcx, *to);\n+              match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n+                 Some(true) => Some(vec!()),\n+                 Some(false) => None,\n+                 None => {\n+                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                    None\n+                 }\n+              }\n             }\n             &PatVec(ref before, ref slice, ref after) => {\n                 match *ctor_id {"}]}