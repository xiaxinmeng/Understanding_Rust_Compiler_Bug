{"sha": "66d3924aa88091f3ccf43e4389cc75de21637c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZDM5MjRhYTg4MDkxZjNjY2Y0M2U0Mzg5Y2M3NWRlMjE2MzdjNWU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-08-07T03:07:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-07T03:07:23Z"}, "message": "Merge pull request #2899 from topecongiro/chain-with-comments\n\nFormat chains with comment", "tree": {"sha": "20b7fd3700b12506dcd11dd87256589aa31333a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20b7fd3700b12506dcd11dd87256589aa31333a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66d3924aa88091f3ccf43e4389cc75de21637c5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbaQzrCRBK7hj4Ov3rIwAAdHIIAFaaGyeJSqeZjcLrpaPjWeJ4\nWroSD3vMjpuEeywdm3dI1ShkNbCXHuP2qTB7sWN0qVmgRliNi5MkeF6g0UCtM7f6\ne/CXVkaR8tZh1cRRDWCT6NUY+Mf4YBZj/jni8V+3Zi3HoXfmKl4Mx3S/5furEtQA\nN+AKmiwrO+K7atBSLY3e8A3WedKxrsQYOwnh4kDkLy3udE3+Mofhspuyo9eM+Cd6\n1zs+4FuKU3KijZkPvo70ilnYFrf49+C7aFil2odwjf8RBP3zPhWVMH9Tt64x0FXU\njGXRnZopIFgiBlmTaSKlEDPMM9JlMv8Zn1Zh37UNKEKkkhHYzOftj0e/tFVgF1E=\n=8JFo\n-----END PGP SIGNATURE-----\n", "payload": "tree 20b7fd3700b12506dcd11dd87256589aa31333a1\nparent ff1cb7d9f7fc213666814c7299505e181dcdddbf\nparent 7bccc4473c818bf826f017875189c3d45b750b11\nauthor Nick Cameron <nrc@ncameron.org> 1533611243 +1200\ncommitter GitHub <noreply@github.com> 1533611243 +1200\n\nMerge pull request #2899 from topecongiro/chain-with-comments\n\nFormat chains with comment"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66d3924aa88091f3ccf43e4389cc75de21637c5e", "html_url": "https://github.com/rust-lang/rust/commit/66d3924aa88091f3ccf43e4389cc75de21637c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66d3924aa88091f3ccf43e4389cc75de21637c5e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff1cb7d9f7fc213666814c7299505e181dcdddbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1cb7d9f7fc213666814c7299505e181dcdddbf", "html_url": "https://github.com/rust-lang/rust/commit/ff1cb7d9f7fc213666814c7299505e181dcdddbf"}, {"sha": "7bccc4473c818bf826f017875189c3d45b750b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bccc4473c818bf826f017875189c3d45b750b11", "html_url": "https://github.com/rust-lang/rust/commit/7bccc4473c818bf826f017875189c3d45b750b11"}], "stats": {"total": 828, "additions": 615, "deletions": 213}, "files": [{"sha": "429b9ceb96142bb787c331ecc6847161545cfe5a", "filename": "src/chains.rs", "status": "modified", "additions": 255, "deletions": 94, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/66d3924aa88091f3ccf43e4389cc75de21637c5e/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d3924aa88091f3ccf43e4389cc75de21637c5e/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=66d3924aa88091f3ccf43e4389cc75de21637c5e", "patch": "@@ -65,12 +65,14 @@\n //!            .qux\n //! ```\n \n+use codemap::SpanUtils;\n+use comment::rewrite_comment;\n use config::IndentStyle;\n use expr::rewrite_call;\n+use lists::{extract_post_comment, extract_pre_comment, get_comment_end};\n use macros::convert_try_mac;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n-use spanned::Spanned;\n use utils::{\n     first_line_width, last_line_extendable, last_line_width, mk_sp, trimmed_last_line_width,\n     wrap_str,\n@@ -80,7 +82,7 @@ use std::borrow::Cow;\n use std::cmp::min;\n use std::iter;\n \n-use syntax::codemap::Span;\n+use syntax::codemap::{BytePos, Span};\n use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n@@ -96,71 +98,127 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     chain.rewrite(context, shape)\n }\n \n+#[derive(Debug)]\n+enum CommentPosition {\n+    Back,\n+    Top,\n+}\n+\n // An expression plus trailing `?`s to be formatted together.\n #[derive(Debug)]\n struct ChainItem {\n-    // FIXME: we can't use a reference here because to convert `try!` to `?` we\n-    // synthesise the AST node. However, I think we could use `Cow` and that\n-    // would remove a lot of cloning.\n-    expr: ast::Expr,\n+    kind: ChainItemKind,\n     tries: usize,\n+    span: Span,\n }\n \n-impl Rewrite for ChainItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let rewrite = self.expr.rewrite(context, shape.sub_width(self.tries)?)?;\n-        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n-    }\n+// FIXME: we can't use a reference here because to convert `try!` to `?` we\n+// synthesise the AST node. However, I think we could use `Cow` and that\n+// would remove a lot of cloning.\n+#[derive(Debug)]\n+enum ChainItemKind {\n+    Parent(ast::Expr),\n+    MethodCall(\n+        ast::PathSegment,\n+        Vec<ast::GenericArg>,\n+        Vec<ptr::P<ast::Expr>>,\n+    ),\n+    StructField(ast::Ident),\n+    TupleField(ast::Ident, bool),\n+    Comment(String, CommentPosition),\n }\n \n-impl ChainItem {\n-    // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n-    // `.c` and any trailing `?`s.\n-    fn rewrite_postfix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let shape = shape.sub_width(self.tries)?;\n-        let mut rewrite = match self.expr.node {\n+impl ChainItemKind {\n+    fn is_block_like(&self, context: &RewriteContext, reps: &str) -> bool {\n+        match self {\n+            ChainItemKind::Parent(ref expr) => is_block_expr(context, expr, reps),\n+            ChainItemKind::MethodCall(..) => reps.contains('\\n'),\n+            ChainItemKind::StructField(..)\n+            | ChainItemKind::TupleField(..)\n+            | ChainItemKind::Comment(..) => false,\n+        }\n+    }\n+\n+    fn is_tup_field_access(expr: &ast::Expr) -> bool {\n+        match expr.node {\n+            ast::ExprKind::Field(_, ref field) => {\n+                field.name.to_string().chars().all(|c| c.is_digit(10))\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn from_ast(context: &RewriteContext, expr: &ast::Expr) -> (ChainItemKind, Span) {\n+        let (kind, span) = match expr.node {\n             ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n-                let types = match segment.args {\n-                    Some(ref params) => match **params {\n-                        ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n-                        _ => &[],\n-                    },\n-                    _ => &[],\n+                let types = if let Some(ref generic_args) = segment.args {\n+                    if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n+                        data.args.clone()\n+                    } else {\n+                        vec![]\n+                    }\n+                } else {\n+                    vec![]\n                 };\n-                Self::rewrite_method_call(\n-                    segment.ident,\n-                    types,\n-                    expressions,\n-                    self.expr.span,\n-                    context,\n-                    shape,\n-                )?\n+                let span = mk_sp(expressions[0].span.hi(), expr.span.hi());\n+                let kind = ChainItemKind::MethodCall(segment.clone(), types, expressions.clone());\n+                (kind, span)\n             }\n-            ast::ExprKind::Field(ref nested, ref field) => {\n-                let space =\n-                    if Self::is_tup_field_access(&self.expr) && Self::is_tup_field_access(nested) {\n-                        \" \"\n-                    } else {\n-                        \"\"\n-                    };\n-                let result = format!(\"{}.{}\", space, field.name);\n-                if result.len() <= shape.width {\n-                    result\n+            ast::ExprKind::Field(ref nested, field) => {\n+                let kind = if Self::is_tup_field_access(expr) {\n+                    ChainItemKind::TupleField(field, Self::is_tup_field_access(nested))\n                 } else {\n-                    return None;\n-                }\n+                    ChainItemKind::StructField(field)\n+                };\n+                let span = mk_sp(nested.span.hi(), field.span.hi());\n+                (kind, span)\n             }\n-            _ => unreachable!(),\n+            _ => return (ChainItemKind::Parent(expr.clone()), expr.span),\n         };\n-        rewrite.push_str(&\"?\".repeat(self.tries));\n-        Some(rewrite)\n+\n+        // Remove comments from the span.\n+        let lo = context.snippet_provider.span_before(span, \".\");\n+        (kind, mk_sp(lo, span.hi()))\n     }\n+}\n \n-    fn is_tup_field_access(expr: &ast::Expr) -> bool {\n-        match expr.node {\n-            ast::ExprKind::Field(_, ref field) => {\n-                field.name.to_string().chars().all(|c| c.is_digit(10))\n+impl Rewrite for ChainItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let shape = shape.sub_width(self.tries)?;\n+        let rewrite = match self.kind {\n+            ChainItemKind::Parent(ref expr) => expr.rewrite(context, shape)?,\n+            ChainItemKind::MethodCall(ref segment, ref types, ref exprs) => {\n+                Self::rewrite_method_call(segment.ident, types, exprs, self.span, context, shape)?\n+            }\n+            ChainItemKind::StructField(ident) => format!(\".{}\", ident.name),\n+            ChainItemKind::TupleField(ident, nested) => {\n+                format!(\"{}.{}\", if nested { \" \" } else { \"\" }, ident.name)\n             }\n+            ChainItemKind::Comment(ref comment, _) => {\n+                rewrite_comment(comment, false, shape, context.config)?\n+            }\n+        };\n+        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n+    }\n+}\n+\n+impl ChainItem {\n+    fn new(context: &RewriteContext, expr: &ast::Expr, tries: usize) -> ChainItem {\n+        let (kind, span) = ChainItemKind::from_ast(context, expr);\n+        ChainItem { kind, tries, span }\n+    }\n+\n+    fn comment(span: Span, comment: String, pos: CommentPosition) -> ChainItem {\n+        ChainItem {\n+            kind: ChainItemKind::Comment(comment, pos),\n+            tries: 0,\n+            span,\n+        }\n+    }\n+\n+    fn is_comment(&self) -> bool {\n+        match self.kind {\n+            ChainItemKind::Comment(..) => true,\n             _ => false,\n         }\n     }\n@@ -173,22 +231,17 @@ impl ChainItem {\n         context: &RewriteContext,\n         shape: Shape,\n     ) -> Option<String> {\n-        let (lo, type_str) = if types.is_empty() {\n-            (args[0].span.hi(), String::new())\n+        let type_str = if types.is_empty() {\n+            String::new()\n         } else {\n             let type_list = types\n                 .iter()\n                 .map(|ty| ty.rewrite(context, shape))\n                 .collect::<Option<Vec<_>>>()?;\n \n-            let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n-\n-            (types.last().unwrap().span().hi(), type_str)\n+            format!(\"::<{}>\", type_list.join(\", \"))\n         };\n-\n         let callee_str = format!(\".{}{}\", method_name, type_str);\n-        let span = mk_sp(lo, span.hi());\n-\n         rewrite_call(context, &callee_str, &args[1..], span, shape)\n     }\n }\n@@ -204,25 +257,118 @@ impl Chain {\n         let subexpr_list = Self::make_subexpr_list(expr, context);\n \n         // Un-parse the expression tree into ChainItems\n-        let mut children = vec![];\n+        let mut rev_children = vec![];\n         let mut sub_tries = 0;\n-        for subexpr in subexpr_list {\n+        for subexpr in &subexpr_list {\n             match subexpr.node {\n                 ast::ExprKind::Try(_) => sub_tries += 1,\n                 _ => {\n-                    children.push(ChainItem {\n-                        expr: subexpr,\n-                        tries: sub_tries,\n-                    });\n+                    rev_children.push(ChainItem::new(context, subexpr, sub_tries));\n                     sub_tries = 0;\n                 }\n             }\n         }\n \n-        Chain {\n-            parent: children.pop().unwrap(),\n-            children,\n+        fn is_tries(s: &str) -> bool {\n+            s.chars().all(|c| c == '?')\n+        }\n+\n+        fn handle_post_comment(\n+            post_comment_span: Span,\n+            post_comment_snippet: &str,\n+            prev_span_end: &mut BytePos,\n+            children: &mut Vec<ChainItem>,\n+        ) {\n+            let white_spaces: &[_] = &[' ', '\\t'];\n+            if post_comment_snippet\n+                .trim_matches(white_spaces)\n+                .starts_with('\\n')\n+            {\n+                // No post comment.\n+                return;\n+            }\n+            // HACK: Treat `?`s as separators.\n+            let trimmed_snippet = post_comment_snippet.trim_matches('?');\n+            let comment_end = get_comment_end(trimmed_snippet, \"?\", \"\", false);\n+            let maybe_post_comment = extract_post_comment(trimmed_snippet, comment_end, \"?\")\n+                .and_then(|comment| {\n+                    if comment.is_empty() {\n+                        None\n+                    } else {\n+                        Some((comment, comment_end))\n+                    }\n+                });\n+\n+            if let Some((post_comment, comment_end)) = maybe_post_comment {\n+                children.push(ChainItem::comment(\n+                    post_comment_span,\n+                    post_comment,\n+                    CommentPosition::Back,\n+                ));\n+                *prev_span_end = *prev_span_end + BytePos(comment_end as u32);\n+            }\n         }\n+\n+        let parent = rev_children.pop().unwrap();\n+        let mut children = vec![];\n+        let mut prev_span_end = parent.span.hi();\n+        let mut iter = rev_children.into_iter().rev().peekable();\n+        if let Some(first_chain_item) = iter.peek() {\n+            let comment_span = mk_sp(prev_span_end, first_chain_item.span.lo());\n+            let comment_snippet = context.snippet(comment_span);\n+            if !is_tries(comment_snippet.trim()) {\n+                handle_post_comment(\n+                    comment_span,\n+                    comment_snippet,\n+                    &mut prev_span_end,\n+                    &mut children,\n+                );\n+            }\n+        }\n+        while let Some(chain_item) = iter.next() {\n+            let comment_snippet = context.snippet(chain_item.span);\n+            // FIXME: Figure out the way to get a correct span when converting `try!` to `?`.\n+            let handle_comment =\n+                !(context.config.use_try_shorthand() || is_tries(comment_snippet.trim()));\n+\n+            // Pre-comment\n+            if handle_comment {\n+                let pre_comment_span = mk_sp(prev_span_end, chain_item.span.lo());\n+                let pre_comment_snippet = context.snippet(pre_comment_span);\n+                let pre_comment_snippet = pre_comment_snippet.trim().trim_matches('?');\n+                let (pre_comment, _) = extract_pre_comment(pre_comment_snippet);\n+                match pre_comment {\n+                    Some(ref comment) if !comment.is_empty() => {\n+                        children.push(ChainItem::comment(\n+                            pre_comment_span,\n+                            comment.to_owned(),\n+                            CommentPosition::Top,\n+                        ));\n+                    }\n+                    _ => (),\n+                }\n+            }\n+\n+            prev_span_end = chain_item.span.hi();\n+            children.push(chain_item);\n+\n+            // Post-comment\n+            if !handle_comment || iter.peek().is_none() {\n+                continue;\n+            }\n+\n+            let next_lo = iter.peek().unwrap().span.lo();\n+            let post_comment_span = mk_sp(prev_span_end, next_lo);\n+            let post_comment_snippet = context.snippet(post_comment_span);\n+            handle_post_comment(\n+                post_comment_span,\n+                post_comment_snippet,\n+                &mut prev_span_end,\n+                &mut children,\n+            );\n+        }\n+\n+        Chain { parent, children }\n     }\n \n     // Returns a Vec of the prefixes of the chain.\n@@ -395,10 +541,9 @@ impl<'a> ChainFormatterShared<'a> {\n         shape: Shape,\n         child_shape: Shape,\n     ) -> Option<()> {\n-        let last = &self.children[0];\n-        let extendable =\n-            may_extend && last_line_extendable(&self.rewrites[self.rewrites.len() - 1]);\n-        let prev_last_line_width = last_line_width(&self.rewrites[self.rewrites.len() - 1]);\n+        let last = self.children.last()?;\n+        let extendable = may_extend && last_line_extendable(&self.rewrites[0]);\n+        let prev_last_line_width = last_line_width(&self.rewrites[0]);\n \n         // Total of all items excluding the last.\n         let almost_total = if extendable {\n@@ -412,8 +557,9 @@ impl<'a> ChainFormatterShared<'a> {\n             min(shape.width, context.config.width_heuristics().chain_width)\n         }.saturating_sub(almost_total);\n \n-        let all_in_one_line =\n-            self.rewrites.iter().all(|s| !s.contains('\\n')) && one_line_budget > 0;\n+        let all_in_one_line = !self.children.iter().any(ChainItem::is_comment)\n+            && self.rewrites.iter().all(|s| !s.contains('\\n'))\n+            && one_line_budget > 0;\n         let last_shape = if all_in_one_line {\n             shape.sub_width(last.tries)?\n         } else if extendable {\n@@ -427,7 +573,7 @@ impl<'a> ChainFormatterShared<'a> {\n             // First we try to 'overflow' the last child and see if it looks better than using\n             // vertical layout.\n             if let Some(one_line_shape) = last_shape.offset_left(almost_total) {\n-                if let Some(rw) = last.rewrite_postfix(context, one_line_shape) {\n+                if let Some(rw) = last.rewrite(context, one_line_shape) {\n                     // We allow overflowing here only if both of the following conditions match:\n                     // 1. The entire chain fits in a single line except the last child.\n                     // 2. `last_child_str.lines().count() >= 5`.\n@@ -443,7 +589,7 @@ impl<'a> ChainFormatterShared<'a> {\n                         // better.\n                         let last_shape = child_shape\n                             .sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n-                        match last.rewrite_postfix(context, last_shape) {\n+                        match last.rewrite(context, last_shape) {\n                             Some(ref new_rw) if !could_fit_single_line => {\n                                 last_subexpr_str = Some(new_rw.clone());\n                             }\n@@ -464,7 +610,7 @@ impl<'a> ChainFormatterShared<'a> {\n             }\n         }\n \n-        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite_postfix(context, last_shape));\n+        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite(context, last_shape));\n         self.rewrites.push(last_subexpr_str?);\n         Some(())\n     }\n@@ -488,10 +634,18 @@ impl<'a> ChainFormatterShared<'a> {\n \n         let mut rewrite_iter = self.rewrites.iter();\n         let mut result = rewrite_iter.next().unwrap().clone();\n+        let children_iter = self.children.iter();\n+        let iter = rewrite_iter.zip(block_like_iter).zip(children_iter);\n \n-        for (rewrite, prev_is_block_like) in rewrite_iter.zip(block_like_iter) {\n-            if !prev_is_block_like {\n-                result.push_str(&connector);\n+        for ((rewrite, prev_is_block_like), chain_item) in iter {\n+            match chain_item.kind {\n+                ChainItemKind::Comment(_, CommentPosition::Back) => result.push(' '),\n+                ChainItemKind::Comment(_, CommentPosition::Top) => result.push_str(&connector),\n+                _ => {\n+                    if !prev_is_block_like {\n+                        result.push_str(&connector);\n+                    }\n+                }\n             }\n             result.push_str(&rewrite);\n         }\n@@ -525,20 +679,23 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n     ) -> Option<()> {\n         let mut root_rewrite: String = parent.rewrite(context, shape)?;\n \n-        let mut root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n+        let mut root_ends_with_block = parent.kind.is_block_like(context, &root_rewrite);\n         let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n \n         while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n-            let item = &self.shared.children[self.shared.children.len() - 1];\n+            let item = &self.shared.children[0];\n+            if let ChainItemKind::Comment(..) = item.kind {\n+                break;\n+            }\n             let shape = shape.offset_left(root_rewrite.len())?;\n-            match &item.rewrite_postfix(context, shape) {\n+            match &item.rewrite(context, shape) {\n                 Some(rewrite) => root_rewrite.push_str(rewrite),\n                 None => break,\n             }\n \n-            root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n+            root_ends_with_block = item.kind.is_block_like(context, &root_rewrite);\n \n-            self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n+            self.shared.children = &self.shared.children[1..];\n             if self.shared.children.is_empty() {\n                 break;\n             }\n@@ -559,10 +716,10 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n-        for item in self.shared.children[1..].iter().rev() {\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+            let rewrite = item.rewrite(context, child_shape)?;\n             self.is_block_like\n-                .push(is_block_expr(context, &item.expr, &rewrite));\n+                .push(item.kind.is_block_like(context, &rewrite));\n             self.shared.rewrites.push(rewrite);\n         }\n         Some(())\n@@ -620,24 +777,28 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n             trimmed_last_line_width(&root_rewrite)\n         };\n \n-        if !multiline || is_block_expr(context, &parent.expr, &root_rewrite) {\n-            let item = &self.shared.children[self.shared.children.len() - 1];\n+        if !multiline || parent.kind.is_block_like(context, &root_rewrite) {\n+            let item = &self.shared.children[0];\n+            if let ChainItemKind::Comment(..) = item.kind {\n+                self.shared.rewrites.push(root_rewrite);\n+                return Some(());\n+            }\n             let child_shape = parent_shape\n                 .visual_indent(self.offset)\n                 .sub_width(self.offset)?;\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            let rewrite = item.rewrite(context, child_shape)?;\n             match wrap_str(rewrite, context.config.max_width(), shape) {\n                 Some(rewrite) => root_rewrite.push_str(&rewrite),\n                 None => {\n                     // We couldn't fit in at the visual indent, try the last\n                     // indent.\n-                    let rewrite = item.rewrite_postfix(context, parent_shape)?;\n+                    let rewrite = item.rewrite(context, parent_shape)?;\n                     root_rewrite.push_str(&rewrite);\n                     self.offset = 0;\n                 }\n             }\n \n-            self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n+            self.shared.children = &self.shared.children[1..];\n         }\n \n         self.shared.rewrites.push(root_rewrite);\n@@ -652,8 +813,8 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n-        for item in self.shared.children[1..].iter().rev() {\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+            let rewrite = item.rewrite(context, child_shape)?;\n             self.shared.rewrites.push(rewrite);\n         }\n         Some(())"}, {"sha": "2e73fdcec135be55af54024ed7a193634d191824", "filename": "src/codemap.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66d3924aa88091f3ccf43e4389cc75de21637c5e/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d3924aa88091f3ccf43e4389cc75de21637c5e/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=66d3924aa88091f3ccf43e4389cc75de21637c5e", "patch": "@@ -51,7 +51,11 @@ impl<'a> SpanUtils for SnippetProvider<'a> {\n     }\n \n     fn span_before(&self, original: Span, needle: &str) -> BytePos {\n-        self.opt_span_before(original, needle).expect(\"bad span\")\n+        self.opt_span_before(original, needle).expect(&format!(\n+            \"bad span: {}: {}\",\n+            needle,\n+            self.span_to_snippet(original).unwrap()\n+        ))\n     }\n \n     fn opt_span_after(&self, original: Span, needle: &str) -> Option<BytePos> {"}, {"sha": "49548cc26a318ffb8055f8cb4e6c791e31e3cd8d", "filename": "src/lists.rs", "status": "modified", "additions": 142, "deletions": 118, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/66d3924aa88091f3ccf43e4389cc75de21637c5e/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d3924aa88091f3ccf43e4389cc75de21637c5e/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=66d3924aa88091f3ccf43e4389cc75de21637c5e", "patch": "@@ -564,6 +564,139 @@ where\n     leave_last: bool,\n }\n \n+pub fn extract_pre_comment(pre_snippet: &str) -> (Option<String>, ListItemCommentStyle) {\n+    let trimmed_pre_snippet = pre_snippet.trim();\n+    let has_single_line_comment = trimmed_pre_snippet.starts_with(\"//\");\n+    let has_block_comment = trimmed_pre_snippet.starts_with(\"/*\");\n+    if has_single_line_comment {\n+        (\n+            Some(trimmed_pre_snippet.to_owned()),\n+            ListItemCommentStyle::DifferentLine,\n+        )\n+    } else if has_block_comment {\n+        let comment_end = pre_snippet.chars().rev().position(|c| c == '/').unwrap();\n+        if pre_snippet\n+            .chars()\n+            .rev()\n+            .take(comment_end + 1)\n+            .any(|c| c == '\\n')\n+        {\n+            (\n+                Some(trimmed_pre_snippet.to_owned()),\n+                ListItemCommentStyle::DifferentLine,\n+            )\n+        } else {\n+            (\n+                Some(trimmed_pre_snippet.to_owned()),\n+                ListItemCommentStyle::SameLine,\n+            )\n+        }\n+    } else {\n+        (None, ListItemCommentStyle::None)\n+    }\n+}\n+\n+pub fn extract_post_comment(\n+    post_snippet: &str,\n+    comment_end: usize,\n+    separator: &str,\n+) -> Option<String> {\n+    let white_space: &[_] = &[' ', '\\t'];\n+\n+    // Cleanup post-comment: strip separators and whitespace.\n+    let post_snippet = post_snippet[..comment_end].trim();\n+    let post_snippet_trimmed = if post_snippet.starts_with(|c| c == ',' || c == ':') {\n+        post_snippet[1..].trim_matches(white_space)\n+    } else if post_snippet.starts_with(separator) {\n+        post_snippet[separator.len()..].trim_matches(white_space)\n+    } else if post_snippet.ends_with(',') {\n+        post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+    } else {\n+        post_snippet\n+    };\n+\n+    if !post_snippet_trimmed.is_empty() {\n+        Some(post_snippet_trimmed.to_owned())\n+    } else {\n+        None\n+    }\n+}\n+\n+pub fn get_comment_end(\n+    post_snippet: &str,\n+    separator: &str,\n+    terminator: &str,\n+    is_last: bool,\n+) -> usize {\n+    if is_last {\n+        return post_snippet\n+            .find_uncommented(terminator)\n+            .unwrap_or_else(|| post_snippet.len());\n+    }\n+\n+    let mut block_open_index = post_snippet.find(\"/*\");\n+    // check if it really is a block comment (and not `//*` or a nested comment)\n+    if let Some(i) = block_open_index {\n+        match post_snippet.find('/') {\n+            Some(j) if j < i => block_open_index = None,\n+            _ if i > 0 && &post_snippet[i - 1..i] == \"/\" => block_open_index = None,\n+            _ => (),\n+        }\n+    }\n+    let newline_index = post_snippet.find('\\n');\n+    if let Some(separator_index) = post_snippet.find_uncommented(separator) {\n+        match (block_open_index, newline_index) {\n+            // Separator before comment, with the next item on same line.\n+            // Comment belongs to next item.\n+            (Some(i), None) if i > separator_index => separator_index + 1,\n+            // Block-style post-comment before the separator.\n+            (Some(i), None) => cmp::max(\n+                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                separator_index + 1,\n+            ),\n+            // Block-style post-comment. Either before or after the separator.\n+            (Some(i), Some(j)) if i < j => cmp::max(\n+                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                separator_index + 1,\n+            ),\n+            // Potential *single* line comment.\n+            (_, Some(j)) if j > separator_index => j + 1,\n+            _ => post_snippet.len(),\n+        }\n+    } else if let Some(newline_index) = newline_index {\n+        // Match arms may not have trailing comma. In any case, for match arms,\n+        // we will assume that the post comment belongs to the next arm if they\n+        // do not end with trailing comma.\n+        newline_index + 1\n+    } else {\n+        0\n+    }\n+}\n+\n+// Account for extra whitespace between items. This is fiddly\n+// because of the way we divide pre- and post- comments.\n+fn has_extra_newline(post_snippet: &str, comment_end: usize) -> bool {\n+    if post_snippet.is_empty() || comment_end == 0 {\n+        return false;\n+    }\n+\n+    // Everything from the separator to the next item.\n+    let test_snippet = &post_snippet[comment_end - 1..];\n+    let first_newline = test_snippet\n+        .find('\\n')\n+        .unwrap_or_else(|| test_snippet.len());\n+    // From the end of the first line of comments.\n+    let test_snippet = &test_snippet[first_newline..];\n+    let first = test_snippet\n+        .find(|c: char| !c.is_whitespace())\n+        .unwrap_or_else(|| test_snippet.len());\n+    // From the end of the first line of comments to the next non-whitespace char.\n+    let test_snippet = &test_snippet[..first];\n+\n+    // There were multiple line breaks which got trimmed to nothing.\n+    count_newlines(test_snippet) > 1\n+}\n+\n impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator<Item = T>,\n@@ -574,44 +707,13 @@ where\n     type Item = ListItem;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let white_space: &[_] = &[' ', '\\t'];\n-\n         self.inner.next().map(|item| {\n-            let mut new_lines = false;\n             // Pre-comment\n             let pre_snippet = self\n                 .snippet_provider\n                 .span_to_snippet(mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n                 .unwrap_or(\"\");\n-            let trimmed_pre_snippet = pre_snippet.trim();\n-            let has_single_line_comment = trimmed_pre_snippet.starts_with(\"//\");\n-            let has_block_comment = trimmed_pre_snippet.starts_with(\"/*\");\n-            let (pre_comment, pre_comment_style) = if has_single_line_comment {\n-                (\n-                    Some(trimmed_pre_snippet.to_owned()),\n-                    ListItemCommentStyle::DifferentLine,\n-                )\n-            } else if has_block_comment {\n-                let comment_end = pre_snippet.chars().rev().position(|c| c == '/').unwrap();\n-                if pre_snippet\n-                    .chars()\n-                    .rev()\n-                    .take(comment_end + 1)\n-                    .any(|c| c == '\\n')\n-                {\n-                    (\n-                        Some(trimmed_pre_snippet.to_owned()),\n-                        ListItemCommentStyle::DifferentLine,\n-                    )\n-                } else {\n-                    (\n-                        Some(trimmed_pre_snippet.to_owned()),\n-                        ListItemCommentStyle::SameLine,\n-                    )\n-                }\n-            } else {\n-                (None, ListItemCommentStyle::None)\n-            };\n+            let (pre_comment, pre_comment_style) = extract_pre_comment(pre_snippet);\n \n             // Post-comment\n             let next_start = match self.inner.peek() {\n@@ -622,94 +724,16 @@ where\n                 .snippet_provider\n                 .span_to_snippet(mk_sp((self.get_hi)(&item), next_start))\n                 .unwrap_or(\"\");\n+            let comment_end = get_comment_end(\n+                post_snippet,\n+                self.separator,\n+                self.terminator,\n+                self.inner.peek().is_none(),\n+            );\n+            let new_lines = has_extra_newline(post_snippet, comment_end);\n+            let post_comment = extract_post_comment(post_snippet, comment_end, self.separator);\n \n-            let comment_end = match self.inner.peek() {\n-                Some(..) => {\n-                    let mut block_open_index = post_snippet.find(\"/*\");\n-                    // check if it really is a block comment (and not `//*` or a nested comment)\n-                    if let Some(i) = block_open_index {\n-                        match post_snippet.find('/') {\n-                            Some(j) if j < i => block_open_index = None,\n-                            _ if i > 0 && &post_snippet[i - 1..i] == \"/\" => block_open_index = None,\n-                            _ => (),\n-                        }\n-                    }\n-                    let newline_index = post_snippet.find('\\n');\n-                    if let Some(separator_index) = post_snippet.find_uncommented(self.separator) {\n-                        match (block_open_index, newline_index) {\n-                            // Separator before comment, with the next item on same line.\n-                            // Comment belongs to next item.\n-                            (Some(i), None) if i > separator_index => separator_index + 1,\n-                            // Block-style post-comment before the separator.\n-                            (Some(i), None) => cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            ),\n-                            // Block-style post-comment. Either before or after the separator.\n-                            (Some(i), Some(j)) if i < j => cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            ),\n-                            // Potential *single* line comment.\n-                            (_, Some(j)) if j > separator_index => j + 1,\n-                            _ => post_snippet.len(),\n-                        }\n-                    } else if let Some(newline_index) = newline_index {\n-                        // Match arms may not have trailing comma. In any case, for match arms,\n-                        // we will assume that the post comment belongs to the next arm if they\n-                        // do not end with trailing comma.\n-                        newline_index + 1\n-                    } else {\n-                        0\n-                    }\n-                }\n-                None => post_snippet\n-                    .find_uncommented(self.terminator)\n-                    .unwrap_or_else(|| post_snippet.len()),\n-            };\n-\n-            if !post_snippet.is_empty() && comment_end > 0 {\n-                // Account for extra whitespace between items. This is fiddly\n-                // because of the way we divide pre- and post- comments.\n-\n-                // Everything from the separator to the next item.\n-                let test_snippet = &post_snippet[comment_end - 1..];\n-                let first_newline = test_snippet\n-                    .find('\\n')\n-                    .unwrap_or_else(|| test_snippet.len());\n-                // From the end of the first line of comments.\n-                let test_snippet = &test_snippet[first_newline..];\n-                let first = test_snippet\n-                    .find(|c: char| !c.is_whitespace())\n-                    .unwrap_or_else(|| test_snippet.len());\n-                // From the end of the first line of comments to the next non-whitespace char.\n-                let test_snippet = &test_snippet[..first];\n-\n-                if count_newlines(test_snippet) > 1 {\n-                    // There were multiple line breaks which got trimmed to nothing.\n-                    new_lines = true;\n-                }\n-            }\n-\n-            // Cleanup post-comment: strip separators and whitespace.\n             self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n-            let post_snippet = post_snippet[..comment_end].trim();\n-\n-            let post_snippet_trimmed = if post_snippet.starts_with(|c| c == ',' || c == ':') {\n-                post_snippet[1..].trim_matches(white_space)\n-            } else if post_snippet.starts_with(self.separator) {\n-                post_snippet[self.separator.len()..].trim_matches(white_space)\n-            } else if post_snippet.ends_with(',') {\n-                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n-            } else {\n-                post_snippet\n-            };\n-\n-            let post_comment = if !post_snippet_trimmed.is_empty() {\n-                Some(post_snippet_trimmed.to_owned())\n-            } else {\n-                None\n-            };\n \n             ListItem {\n                 pre_comment,"}, {"sha": "80c118d9eccbcf2af4a2742072eb659cb4b1459e", "filename": "tests/source/chains_with_comment.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/66d3924aa88091f3ccf43e4389cc75de21637c5e/tests%2Fsource%2Fchains_with_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d3924aa88091f3ccf43e4389cc75de21637c5e/tests%2Fsource%2Fchains_with_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains_with_comment.rs?ref=66d3924aa88091f3ccf43e4389cc75de21637c5e", "patch": "@@ -0,0 +1,95 @@\n+// Chains with comment.\n+\n+fn main() {\n+    let x = y // comment\n+        .z;\n+\n+    foo // foo\n+        // comment after parent\n+        .x\n+        .y\n+        // comment 1\n+        .bar() // comment after bar()\n+  // comment 2\n+        .foobar\n+  // comment after\n+        // comment 3\n+        .baz(x, y, z);\n+\n+    self.rev_dep_graph\n+        .iter()\n+       // Remove nodes that are not dirty\n+        .filter(|&(unit, _)| dirties.contains(&unit))\n+     // Retain only dirty dependencies of the ones that are dirty\n+       .map(|(k, deps)| {\n+            (\n+                k.clone(),\n+                deps.iter()\n+                .cloned()\n+               .filter(|d| dirties.contains(&d))\n+              .collect(),\n+            )\n+        });\n+\n+    let y = expr /* comment */.kaas()?\n+// comment\n+       .test();\n+    let loooooooooooooooooooooooooooooooooooooooooong = does_this?.look?.good?.should_we_break?.after_the_first_question_mark?;\n+    let zzzz = expr?   // comment after parent\n+// comment 0\n+.another??? // comment 1\n+.another????  // comment 2\n+.another? // comment 3\n+.another?;\n+\n+    let y = a.very .loooooooooooooooooooooooooooooooooooooong() /* comment */ .chain()\n+        .inside()  /* comment */        .weeeeeeeeeeeeeee()? .test()  .0\n+        .x;\n+\n+    parameterized(f,\n+                  substs,\n+                  def_id,\n+                  Ns::Value,\n+                  &[],\n+                  |tcx| tcx.lookup_item_type(def_id).generics)?;\n+    fooooooooooooooooooooooooooo()?.bar()?.baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz()?;\n+\n+    // #2559\n+    App::new(\"cargo-cache\")\n+.version(crate_version!())\n+.bin_name(\"cargo\")\n+.about(\"Manage cargo cache\")\n+.author(\"matthiaskrgr\")\n+.subcommand(\n+SubCommand::with_name(\"cache\")\n+.version(crate_version!())\n+.bin_name(\"cargo-cache\")\n+.about(\"Manage cargo cache\")\n+.author(\"matthiaskrgr\")\n+.arg(&list_dirs)\n+.arg(&remove_dir)\n+.arg(&gc_repos)\n+.arg(&info)\n+.arg(&keep_duplicate_crates)    .arg(&dry_run)\n+.arg(&auto_clean)\n+.arg(&auto_clean_expensive),\n+        ) // subcommand\n+        .arg(&list_dirs);\n+}\n+\n+// #2177\n+impl Foo {\n+    fn dirty_rev_dep_graph(\n+        &self,\n+        dirties: &HashSet<UnitKey>,\n+    ) -> HashMap<UnitKey, HashSet<UnitKey>> {\n+        let dirties = self.transitive_dirty_units(dirties);\n+        trace!(\"transitive_dirty_units: {:?}\", dirties);\n+\n+        self.rev_dep_graph.iter()\n+        // Remove nodes that are not dirty\n+            .filter(|&(unit, _)| dirties.contains(&unit))\n+        // Retain only dirty dependencies of the ones that are dirty\n+            .map(|(k, deps)| (k.clone(), deps.iter().cloned().filter(|d| dirties.contains(&d)).collect()))\n+    }\n+}"}, {"sha": "a1df2710234330d464bcc113c4ebcf19eee78ec4", "filename": "tests/target/chains_with_comment.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/66d3924aa88091f3ccf43e4389cc75de21637c5e/tests%2Ftarget%2Fchains_with_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d3924aa88091f3ccf43e4389cc75de21637c5e/tests%2Ftarget%2Fchains_with_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains_with_comment.rs?ref=66d3924aa88091f3ccf43e4389cc75de21637c5e", "patch": "@@ -0,0 +1,118 @@\n+// Chains with comment.\n+\n+fn main() {\n+    let x = y // comment\n+        .z;\n+\n+    foo // foo\n+        // comment after parent\n+        .x\n+        .y\n+        // comment 1\n+        .bar() // comment after bar()\n+        // comment 2\n+        .foobar\n+        // comment after\n+        // comment 3\n+        .baz(x, y, z);\n+\n+    self.rev_dep_graph\n+        .iter()\n+        // Remove nodes that are not dirty\n+        .filter(|&(unit, _)| dirties.contains(&unit))\n+        // Retain only dirty dependencies of the ones that are dirty\n+        .map(|(k, deps)| {\n+            (\n+                k.clone(),\n+                deps.iter()\n+                    .cloned()\n+                    .filter(|d| dirties.contains(&d))\n+                    .collect(),\n+            )\n+        });\n+\n+    let y = expr\n+        /* comment */\n+        .kaas()?\n+        // comment\n+        .test();\n+    let loooooooooooooooooooooooooooooooooooooooooong = does_this?\n+        .look?\n+        .good?\n+        .should_we_break?\n+        .after_the_first_question_mark?;\n+    let zzzz = expr? // comment after parent\n+        // comment 0\n+        .another??? // comment 1\n+        .another???? // comment 2\n+        .another? // comment 3\n+        .another?;\n+\n+    let y = a\n+        .very\n+        .loooooooooooooooooooooooooooooooooooooong()\n+        /* comment */\n+        .chain()\n+        .inside()\n+        /* comment */\n+        .weeeeeeeeeeeeeee()?\n+        .test()\n+        .0\n+        .x;\n+\n+    parameterized(f, substs, def_id, Ns::Value, &[], |tcx| {\n+        tcx.lookup_item_type(def_id).generics\n+    })?;\n+    fooooooooooooooooooooooooooo()?\n+        .bar()?\n+        .baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz()?;\n+\n+    // #2559\n+    App::new(\"cargo-cache\")\n+        .version(crate_version!())\n+        .bin_name(\"cargo\")\n+        .about(\"Manage cargo cache\")\n+        .author(\"matthiaskrgr\")\n+        .subcommand(\n+            SubCommand::with_name(\"cache\")\n+                .version(crate_version!())\n+                .bin_name(\"cargo-cache\")\n+                .about(\"Manage cargo cache\")\n+                .author(\"matthiaskrgr\")\n+                .arg(&list_dirs)\n+                .arg(&remove_dir)\n+                .arg(&gc_repos)\n+                .arg(&info)\n+                .arg(&keep_duplicate_crates)\n+                .arg(&dry_run)\n+                .arg(&auto_clean)\n+                .arg(&auto_clean_expensive),\n+        ) // subcommand\n+        .arg(&list_dirs);\n+}\n+\n+// #2177\n+impl Foo {\n+    fn dirty_rev_dep_graph(\n+        &self,\n+        dirties: &HashSet<UnitKey>,\n+    ) -> HashMap<UnitKey, HashSet<UnitKey>> {\n+        let dirties = self.transitive_dirty_units(dirties);\n+        trace!(\"transitive_dirty_units: {:?}\", dirties);\n+\n+        self.rev_dep_graph\n+            .iter()\n+            // Remove nodes that are not dirty\n+            .filter(|&(unit, _)| dirties.contains(&unit))\n+            // Retain only dirty dependencies of the ones that are dirty\n+            .map(|(k, deps)| {\n+                (\n+                    k.clone(),\n+                    deps.iter()\n+                        .cloned()\n+                        .filter(|d| dirties.contains(&d))\n+                        .collect(),\n+                )\n+            })\n+    }\n+}"}]}