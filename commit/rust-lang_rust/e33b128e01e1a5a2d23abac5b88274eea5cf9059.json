{"sha": "e33b128e01e1a5a2d23abac5b88274eea5cf9059", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzM2IxMjhlMDFlMWE1YTJkMjNhYmFjNWI4ODI3NGVlYTVjZjkwNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-21T09:59:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-21T09:59:18Z"}, "message": "Auto merge of #26816 - nrc:zero-codemap, r=@jroesch\n\nSee commits for details", "tree": {"sha": "d0da3b98226376b52150853f61b4faee90446dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0da3b98226376b52150853f61b4faee90446dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e33b128e01e1a5a2d23abac5b88274eea5cf9059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e33b128e01e1a5a2d23abac5b88274eea5cf9059", "html_url": "https://github.com/rust-lang/rust/commit/e33b128e01e1a5a2d23abac5b88274eea5cf9059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e33b128e01e1a5a2d23abac5b88274eea5cf9059/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "247a0d185446fb145e1e5843c44c97b9a564e135", "url": "https://api.github.com/repos/rust-lang/rust/commits/247a0d185446fb145e1e5843c44c97b9a564e135", "html_url": "https://github.com/rust-lang/rust/commit/247a0d185446fb145e1e5843c44c97b9a564e135"}, {"sha": "f47d20aecdcd7db34d41ad1666fd3eee095cc943", "url": "https://api.github.com/repos/rust-lang/rust/commits/f47d20aecdcd7db34d41ad1666fd3eee095cc943", "html_url": "https://github.com/rust-lang/rust/commit/f47d20aecdcd7db34d41ad1666fd3eee095cc943"}], "stats": {"total": 276, "additions": 163, "deletions": 113}, "files": [{"sha": "d4eeaa1de109c9ef91add8b229e2645bd528c8f3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -1947,6 +1947,10 @@ impl Span {\n \n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self, cx: &DocContext) -> Span {\n+        if *self == DUMMY_SP {\n+            return Span::empty();\n+        }\n+\n         let cm = cx.sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);"}, {"sha": "e6bc3218897d91f3ec907c86cc256a81a1504343", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 107, "deletions": 87, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -115,6 +115,10 @@ impl Sub for CharPos {\n /// are *absolute* positions from the beginning of the codemap, not positions\n /// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n /// to the original source.\n+/// You must be careful if the span crosses more than one file - you will not be\n+/// able to use many of the functions on spans in codemap and you cannot assume\n+/// that the length of the span = hi - lo; there may be space in the BytePos\n+/// range between files.\n #[derive(Clone, Copy, Hash)]\n pub struct Span {\n     pub lo: BytePos,\n@@ -339,7 +343,7 @@ pub struct MultiByteChar {\n     pub bytes: usize,\n }\n \n-/// A single source in the CodeMap\n+/// A single source in the CodeMap.\n pub struct FileMap {\n     /// The name of the file that the source came from, source that doesn't\n     /// originate from files has names between angle brackets by convention,\n@@ -508,6 +512,9 @@ impl FileMap {\n                 lines.get(line_number).map(|&line| {\n                     let begin: BytePos = line - self.start_pos;\n                     let begin = begin.to_usize();\n+                    // We can't use `lines.get(line_number+1)` because we might\n+                    // be parsing when we call this function and thus the current\n+                    // line is the last one we have line info for.\n                     let slice = &src[begin..];\n                     match slice.find('\\n') {\n                         Some(e) => &slice[..e],\n@@ -598,27 +605,27 @@ impl CodeMap {\n         Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n \n+    fn next_start_pos(&self) -> usize {\n+        let files = self.files.borrow();\n+        match files.last() {\n+            None => 0,\n+            // Add one so there is some space between files. This lets us distinguish\n+            // positions in the codemap, even in the presence of zero-length files.\n+            Some(last) => last.end_pos.to_usize() + 1,\n+        }\n+    }\n+\n+    /// Creates a new filemap without setting its line information. If you don't\n+    /// intend to set the line information yourself, you should use new_filemap_and_lines.\n     pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n+        let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n-        let start_pos = match files.last() {\n-            None => 0,\n-            Some(last) => last.end_pos.to_usize(),\n-        };\n \n         // Remove utf-8 BOM if any.\n         if src.starts_with(\"\\u{feff}\") {\n             src.drain(..3);\n         }\n \n-        // Append '\\n' in case it's not already there.\n-        // This is a workaround to prevent CodeMap.lookup_filemap_idx from\n-        // accidentally overflowing into the next filemap in case the last byte\n-        // of span is also the last byte of filemap, which leads to incorrect\n-        // results from CodeMap.span_to_*.\n-        if !src.is_empty() && !src.ends_with(\"\\n\") {\n-            src.push('\\n');\n-        }\n-\n         let end_pos = start_pos + src.len();\n \n         let filemap = Rc::new(FileMap {\n@@ -635,6 +642,21 @@ impl CodeMap {\n         filemap\n     }\n \n+    /// Creates a new filemap and sets its line information.\n+    pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n+        let fm = self.new_filemap(filename.to_string(), src.to_owned());\n+        let mut byte_pos: u32 = 0;\n+        for line in src.lines() {\n+            // register the start of this line\n+            fm.next_line(BytePos(byte_pos));\n+\n+            // update byte_pos to include this line and the \\n at the end\n+            byte_pos += line.len() as u32 + 1;\n+        }\n+        fm\n+    }\n+\n+\n     /// Allocates a new FileMap representing a source file from an external\n     /// crate. The source code of such an \"imported filemap\" is not available,\n     /// but we still know enough to generate accurate debuginfo location\n@@ -645,11 +667,8 @@ impl CodeMap {\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n                                 -> Rc<FileMap> {\n+        let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n-        let start_pos = match files.last() {\n-            None => 0,\n-            Some(last) => last.end_pos.to_usize(),\n-        };\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);\n@@ -686,39 +705,61 @@ impl CodeMap {\n \n     /// Lookup source information about a BytePos\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n-        let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let linebpos = (*f.lines.borrow())[a];\n-        let linechpos = self.bytepos_to_file_charpos(linebpos);\n-        debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n-               pos, linebpos);\n-        debug!(\"char pos {:?} is on the line at char pos {:?}\",\n-               chpos, linechpos);\n-        debug!(\"byte is on line: {}\", line);\n-        assert!(chpos >= linechpos);\n-        Loc {\n-            file: f,\n-            line: line,\n-            col: chpos - linechpos\n+        match self.lookup_line(pos) {\n+            Ok(FileMapAndLine { fm: f, line: a }) => {\n+                let line = a + 1; // Line numbers start at 1\n+                let linebpos = (*f.lines.borrow())[a];\n+                let linechpos = self.bytepos_to_file_charpos(linebpos);\n+                debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n+                       pos, linebpos);\n+                debug!(\"char pos {:?} is on the line at char pos {:?}\",\n+                       chpos, linechpos);\n+                debug!(\"byte is on line: {}\", line);\n+                assert!(chpos >= linechpos);\n+                Loc {\n+                    file: f,\n+                    line: line,\n+                    col: chpos - linechpos,\n+                }\n+            }\n+            Err(f) => {\n+                Loc {\n+                    file: f,\n+                    line: 0,\n+                    col: chpos,\n+                }\n+            }\n         }\n     }\n \n-    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n+    // If the relevant filemap is empty, we don't return a line number.\n+    fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Rc<FileMap>> {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n+\n+        let len = f.lines.borrow().len();\n+        if len == 0 {\n+            return Err(f);\n+        }\n+\n         let mut a = 0;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n             while b - a > 1 {\n                 let m = (a + b) / 2;\n-                if (*lines)[m] > pos { b = m; } else { a = m; }\n+                if (*lines)[m] > pos {\n+                    b = m;\n+                } else {\n+                    a = m;\n+                }\n             }\n+            assert!(a <= lines.len());\n         }\n-        FileMapAndLine {fm: f, line: a}\n+        Ok(FileMapAndLine { fm: f, line: a })\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n@@ -853,7 +894,7 @@ impl CodeMap {\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n \n-    /// Converts an absolute BytePos to a CharPos relative to the filemap and above.\n+    /// Converts an absolute BytePos to a CharPos relative to the filemap.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n@@ -880,12 +921,15 @@ impl CodeMap {\n         CharPos(bpos.to_usize() - map.start_pos.to_usize() - total_extra_bytes)\n     }\n \n+    // Return the index of the filemap (in self.files) which contains pos.\n     fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &*files;\n-        let len = files.len();\n+        let count = files.len();\n+\n+        // Binary search for the filemap.\n         let mut a = 0;\n-        let mut b = len;\n+        let mut b = count;\n         while b - a > 1 {\n             let m = (a + b) / 2;\n             if files[m].start_pos > pos {\n@@ -894,26 +938,8 @@ impl CodeMap {\n                 a = m;\n             }\n         }\n-        // There can be filemaps with length 0. These have the same start_pos as\n-        // the previous filemap, but are not the filemaps we want (because they\n-        // are length 0, they cannot contain what we are looking for). So,\n-        // rewind until we find a useful filemap.\n-        loop {\n-            let lines = files[a].lines.borrow();\n-            let lines = lines;\n-            if !lines.is_empty() {\n-                break;\n-            }\n-            if a == 0 {\n-                panic!(\"position {} does not resolve to a source location\",\n-                      pos.to_usize());\n-            }\n-            a -= 1;\n-        }\n-        if a >= len {\n-            panic!(\"position {} does not resolve to a source location\",\n-                  pos.to_usize())\n-        }\n+\n+        assert!(a < count, \"position {} does not resolve to a source location\", pos.to_usize());\n \n         return a;\n     }\n@@ -1027,10 +1053,13 @@ mod tests {\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n+        // Test we can get lines with partial line info.\n         assert_eq!(fm.get_line(0), Some(\"first line.\"));\n-        // TESTING BROKEN BEHAVIOR:\n+        // TESTING BROKEN BEHAVIOR: line break declared before actual line break.\n         fm.next_line(BytePos(10));\n         assert_eq!(fm.get_line(1), Some(\".\"));\n+        fm.next_line(BytePos(12));\n+        assert_eq!(fm.get_line(2), Some(\"second line\"));\n     }\n \n     #[test]\n@@ -1056,9 +1085,9 @@ mod tests {\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(12));\n-        fm2.next_line(BytePos(24));\n-        fm3.next_line(BytePos(24));\n-        fm3.next_line(BytePos(34));\n+        fm2.next_line(fm2.start_pos);\n+        fm3.next_line(fm3.start_pos);\n+        fm3.next_line(fm3.start_pos + BytePos(12));\n \n         cm\n     }\n@@ -1068,11 +1097,15 @@ mod tests {\n         // Test lookup_byte_offset\n         let cm = init_code_map();\n \n-        let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n+        let fmabp1 = cm.lookup_byte_offset(BytePos(23));\n         assert_eq!(fmabp1.fm.name, \"blork.rs\");\n-        assert_eq!(fmabp1.pos, BytePos(22));\n+        assert_eq!(fmabp1.pos, BytePos(23));\n+\n+        let fmabp1 = cm.lookup_byte_offset(BytePos(24));\n+        assert_eq!(fmabp1.fm.name, \"empty.rs\");\n+        assert_eq!(fmabp1.pos, BytePos(0));\n \n-        let fmabp2 = cm.lookup_byte_offset(BytePos(24));\n+        let fmabp2 = cm.lookup_byte_offset(BytePos(25));\n         assert_eq!(fmabp2.fm.name, \"blork2.rs\");\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n@@ -1085,7 +1118,7 @@ mod tests {\n         let cp1 = cm.bytepos_to_file_charpos(BytePos(22));\n         assert_eq!(cp1, CharPos(22));\n \n-        let cp2 = cm.bytepos_to_file_charpos(BytePos(24));\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(25));\n         assert_eq!(cp2, CharPos(0));\n     }\n \n@@ -1099,7 +1132,7 @@ mod tests {\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n-        let loc2 = cm.lookup_char_pos(BytePos(24));\n+        let loc2 = cm.lookup_char_pos(BytePos(25));\n         assert_eq!(loc2.file.name, \"blork2.rs\");\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n@@ -1115,18 +1148,18 @@ mod tests {\n                                  \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n-        fm1.next_line(BytePos(22));\n-        fm2.next_line(BytePos(40));\n-        fm2.next_line(BytePos(58));\n+        fm1.next_line(BytePos(28));\n+        fm2.next_line(fm2.start_pos);\n+        fm2.next_line(fm2.start_pos + BytePos(20));\n \n         fm1.record_multibyte_char(BytePos(3), 3);\n         fm1.record_multibyte_char(BytePos(9), 3);\n         fm1.record_multibyte_char(BytePos(12), 3);\n         fm1.record_multibyte_char(BytePos(15), 3);\n         fm1.record_multibyte_char(BytePos(18), 3);\n-        fm2.record_multibyte_char(BytePos(50), 3);\n-        fm2.record_multibyte_char(BytePos(53), 3);\n-        fm2.record_multibyte_char(BytePos(58), 3);\n+        fm2.record_multibyte_char(fm2.start_pos + BytePos(10), 3);\n+        fm2.record_multibyte_char(fm2.start_pos + BytePos(13), 3);\n+        fm2.record_multibyte_char(fm2.start_pos + BytePos(18), 3);\n \n         cm\n     }\n@@ -1172,27 +1205,14 @@ mod tests {\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n     }\n \n-    fn new_filemap_and_lines(cm: &CodeMap, filename: &str, input: &str) -> Rc<FileMap> {\n-        let fm = cm.new_filemap(filename.to_string(), input.to_string());\n-        let mut byte_pos: u32 = 0;\n-        for line in input.lines() {\n-            // register the start of this line\n-            fm.next_line(BytePos(byte_pos));\n-\n-            // update byte_pos to include this line and the \\n at the end\n-            byte_pos += line.len() as u32 + 1;\n-        }\n-        fm\n-    }\n-\n     /// Test span_to_snippet and span_to_lines for a span coverting 3\n     /// lines in the middle of a file.\n     #[test]\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n-        new_filemap_and_lines(&cm, \"blork.rs\", inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting"}, {"sha": "f1d748595d6f05aaafd04d44256d4f934dbf59ea", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -841,12 +841,7 @@ mod test {\n         tolv\n         dreizehn\n         \";\n-        let file = cm.new_filemap(\"dummy.txt\".to_string(), content.to_string());\n-        for (i, b) in content.bytes().enumerate() {\n-            if b == b'\\n' {\n-                file.next_line(BytePos(i as u32));\n-            }\n-        }\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n         let start = file.lines.borrow()[7];\n         let end = file.lines.borrow()[11];\n         let sp = mk_sp(start, end);\n@@ -858,11 +853,12 @@ mod test {\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;\n-        println!(\"{}\", from_utf8(vec).unwrap());\n-        assert_eq!(vec, \"dummy.txt: 8 \\n\\\n-                         dummy.txt: 9 \\n\\\n-                         dummy.txt:10 \\n\\\n-                         dummy.txt:11 \\n\\\n-                         dummy.txt:12 \\n\".as_bytes());\n+        let str = from_utf8(vec).unwrap();\n+        println!(\"{}\", str);\n+        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n+                         dummy.txt: 9         line9\\n\\\n+                         dummy.txt:10         line10\\n\\\n+                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n+                         dummy.txt:12         tolv\\n\");\n     }\n }"}, {"sha": "22517dc5f1bb5b4353f3a37534df095e331e2ed2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -156,7 +156,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n             let interned = token::intern_and_get_ident(&src[..]);\n-            cx.codemap().new_filemap(filename, src);\n+            cx.codemap().new_filemap_and_lines(&filename, &src);\n \n             base::MacEager::expr(cx.expr_str(sp, interned))\n         }\n@@ -187,7 +187,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n             let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap(filename, \"\".to_string());\n+            cx.codemap().new_filemap_and_lines(&filename, \"\");\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n         }"}, {"sha": "621335ecd979cf1ee5a97a03c09881ec280127cf", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -231,6 +231,7 @@ impl<'a> StringReader<'a> {\n             None => {\n                 if self.is_eof() {\n                     self.peek_tok = token::Eof;\n+                    self.peek_span = codemap::mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n                 } else {\n                     let start_bytepos = self.last_pos;\n                     self.peek_tok = self.next_token_inner();"}, {"sha": "34a63fc92feaa1bc00738f45c6652a192b780a3f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -11,7 +11,7 @@\n //! The main parser interface\n \n use ast;\n-use codemap::{Span, CodeMap, FileMap};\n+use codemap::{self, Span, CodeMap, FileMap};\n use diagnostic::{SpanHandler, Handler, Auto, FatalError};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n@@ -203,7 +203,14 @@ pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n                              filemap: Rc<FileMap>,\n                              cfg: ast::CrateConfig) -> Parser<'a> {\n-    tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg)\n+    let end_pos = filemap.end_pos;\n+    let mut parser = tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg);\n+\n+    if parser.token == token::Eof && parser.span == codemap::DUMMY_SP {\n+        parser.span = codemap::mk_sp(end_pos, end_pos);\n+    }\n+\n+    parser\n }\n \n // must preserve old name for now, because quote! from the *existing*"}, {"sha": "db1b2489f1d9e8f538ebc529a74c21390afd2ee6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -4824,8 +4824,14 @@ impl<'a> Parser<'a> {\n             return Err(self.fatal(&format!(\"expected item, found `{}`\", token_str)));\n         }\n \n+        let hi = if self.span == codemap::DUMMY_SP {\n+            inner_lo\n+        } else {\n+            self.span.lo\n+        };\n+\n         Ok(ast::Mod {\n-            inner: mk_sp(inner_lo, self.span.lo),\n+            inner: mk_sp(inner_lo, hi),\n             items: items\n         })\n     }\n@@ -4869,8 +4875,7 @@ impl<'a> Parser<'a> {\n \n     fn push_mod_path(&mut self, id: Ident, attrs: &[Attribute]) {\n         let default_path = self.id_to_interned_str(id);\n-        let file_path = match ::attr::first_attr_value_str_by_name(attrs,\n-                                                                   \"path\") {\n+        let file_path = match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n             Some(d) => d,\n             None => default_path,\n         };\n@@ -5003,13 +5008,12 @@ impl<'a> Parser<'a> {\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);\n \n-        let mut p0 =\n-            new_sub_parser_from_file(self.sess,\n-                                     self.cfg.clone(),\n-                                     &path,\n-                                     owns_directory,\n-                                     Some(name),\n-                                     id_sp);\n+        let mut p0 = new_sub_parser_from_file(self.sess,\n+                                              self.cfg.clone(),\n+                                              &path,\n+                                              owns_directory,\n+                                              Some(name),\n+                                              id_sp);\n         let mod_inner_lo = p0.span.lo;\n         let mod_attrs = p0.parse_inner_attributes();\n         let m0 = try!(p0.parse_mod_items(&token::Eof, mod_inner_lo));"}, {"sha": "4c27d57008d040c68584c1a82c93b01608094fd8", "filename": "src/test/compile-fail/cfg-empty-codemap.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Ftest%2Fcompile-fail%2Fcfg-empty-codemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33b128e01e1a5a2d23abac5b88274eea5cf9059/src%2Ftest%2Fcompile-fail%2Fcfg-empty-codemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcfg-empty-codemap.rs?ref=e33b128e01e1a5a2d23abac5b88274eea5cf9059", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that empty codemaps don't ICE (#23301)\n+\n+// compile-flags: --cfg \"\"\n+\n+// error-pattern: expected ident, found\n+\n+pub fn main() {\n+}"}]}