{"sha": "77efd6800c57ba83923dddbbabf03c7afa6a34a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZWZkNjgwMGM1N2JhODM5MjNkZGRiYmFiZjAzYzdhZmE2YTM0YTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-15T19:02:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-15T19:02:22Z"}, "message": "Auto merge of #46623 - eddyb:issue-46449, r=nagisa\n\nrustc_trans: approximate ABI alignment for padding/union fillers.\n\nBefore #45225 and after this PR, unions and enums are filled with integers of size and alignment matching their alignment (e.g. `Option<u32>` becomes `[u32; 2]`) instead of mere bytes.\nAlso, the alignment padding between struct fields gets this treatment after this PR.\n\nPartially helps with some reduced testcases in #46449, although it doesn't solve the bug itself.", "tree": {"sha": "3524f06aa28cea73cda2b2c151dc5d817ab80b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3524f06aa28cea73cda2b2c151dc5d817ab80b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77efd6800c57ba83923dddbbabf03c7afa6a34a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77efd6800c57ba83923dddbbabf03c7afa6a34a4", "html_url": "https://github.com/rust-lang/rust/commit/77efd6800c57ba83923dddbbabf03c7afa6a34a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77efd6800c57ba83923dddbbabf03c7afa6a34a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f6c3ece0ec738da48f8e77e6379a14bd02d1f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f6c3ece0ec738da48f8e77e6379a14bd02d1f4", "html_url": "https://github.com/rust-lang/rust/commit/50f6c3ece0ec738da48f8e77e6379a14bd02d1f4"}, {"sha": "8a26e0422dc55b82577de3027800ca29a4d522b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a26e0422dc55b82577de3027800ca29a4d522b7", "html_url": "https://github.com/rust-lang/rust/commit/8a26e0422dc55b82577de3027800ca29a4d522b7"}], "stats": {"total": 71, "additions": 58, "deletions": 13}, "files": [{"sha": "fe96cb083f5d7a01b940cffe4ee8c7f645690ed8", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=77efd6800c57ba83923dddbbabf03c7afa6a34a4", "patch": "@@ -489,14 +489,27 @@ impl<'a, 'tcx> Integer {\n \n         let wanted = align.abi();\n         for &candidate in &[I8, I16, I32, I64, I128] {\n-            let ty = Int(candidate, false);\n-            if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n+            if wanted == candidate.align(dl).abi() && wanted == candidate.size().bytes() {\n                 return Some(candidate);\n             }\n         }\n         None\n     }\n \n+    /// Find the largest integer with the given alignment or less.\n+    pub fn approximate_abi_align<C: HasDataLayout>(cx: C, align: Align) -> Integer {\n+        let dl = cx.data_layout();\n+\n+        let wanted = align.abi();\n+        // FIXME(eddyb) maybe include I128 in the future, when it works everywhere.\n+        for &candidate in &[I64, I32, I16] {\n+            if wanted >= candidate.align(dl).abi() && wanted >= candidate.size().bytes() {\n+                return candidate;\n+            }\n+        }\n+        I8\n+    }\n+\n     /// Get the Integer type from an attr::IntType.\n     pub fn from_attr<C: HasDataLayout>(cx: C, ity: attr::IntType) -> Integer {\n         let dl = cx.data_layout();"}, {"sha": "b9daaf5a4480876930f0b822d8132eaaedcbcfc5", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=77efd6800c57ba83923dddbbabf03c7afa6a34a4", "patch": "@@ -17,7 +17,7 @@ use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n use context::CrateContext;\n \n use syntax::ast;\n-use rustc::ty::layout::{self, Align};\n+use rustc::ty::layout::{self, Align, Size};\n \n use std::ffi::CString;\n use std::fmt;\n@@ -279,12 +279,19 @@ impl Type {\n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n     pub fn pointee_for_abi_align(ccx: &CrateContext, align: Align) -> Type {\n-        if let Some(ity) = layout::Integer::for_abi_align(ccx, align) {\n-            Type::from_integer(ccx, ity)\n-        } else {\n-            // FIXME(eddyb) We could find a better approximation here.\n-            Type::i8(ccx)\n-        }\n+        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n+        let ity = layout::Integer::approximate_abi_align(ccx, align);\n+        Type::from_integer(ccx, ity)\n+    }\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// and exactly the required size, as a best-effort padding array.\n+    pub fn padding_filler(ccx: &CrateContext, size: Size, align: Align) -> Type {\n+        let unit = layout::Integer::approximate_abi_align(ccx, align);\n+        let size = size.bytes();\n+        let unit_size = unit.size().bytes();\n+        assert_eq!(size % unit_size, 0);\n+        Type::array(&Type::from_integer(ccx, unit), size / unit_size)\n     }\n \n     pub fn x86_mmx(ccx: &CrateContext) -> Type {"}, {"sha": "e432cec3d5e61f30cedc743bddada3355df24159", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=77efd6800c57ba83923dddbbabf03c7afa6a34a4", "patch": "@@ -78,8 +78,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let size = layout.size.bytes();\n-            let fill = Type::array(&Type::i8(ccx), size);\n+            let fill = Type::padding_filler(ccx, layout.size, layout.align);\n             match name {\n                 None => {\n                     Type::struct_(ccx, &[fill], layout.is_packed())\n@@ -115,6 +114,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let field_count = layout.fields.count();\n \n     let mut offset = Size::from_bytes(0);\n+    let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n         let field = layout.field(ccx, i);\n@@ -123,7 +123,9 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             i, field, offset, target_offset);\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n-        result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n+        let padding_align = layout.align.min(prev_align).min(field.align);\n+        assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n+        result.push(Type::padding_filler(ccx, padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n         result.push(field.llvm_type(ccx));\n@@ -137,16 +139,19 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         offset = target_offset + field.size;\n+        prev_align = field.align;\n     }\n     if !layout.is_unsized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\",\n                  layout, layout.size, offset);\n         }\n         let padding = layout.size - offset;\n+        let padding_align = layout.align.min(prev_align);\n+        assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n-        result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n+        result.push(Type::padding_filler(ccx, padding, padding_align));\n         assert!(result.len() == 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\","}, {"sha": "3b720dc30d3f5310ae6750bef378ffa24d289502", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77efd6800c57ba83923dddbbabf03c7afa6a34a4/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=77efd6800c57ba83923dddbbabf03c7afa6a34a4", "patch": "@@ -9,25 +9,37 @@\n // except according to those terms.\n \n // compile-flags: -C no-prepopulate-passes\n+// ignore-tidy-linelength\n+\n #![crate_type = \"lib\"]\n \n #![feature(attr_literals)]\n #![feature(repr_align)]\n \n #[repr(align(64))]\n pub struct Align64(i32);\n+// CHECK: %Align64 = type { [0 x i32], i32, [15 x i32] }\n \n pub struct Nested64 {\n     a: Align64,\n     b: i32,\n     c: i32,\n     d: i8,\n }\n+// CHECK: %Nested64 = type { [0 x i64], %Align64, [0 x i32], i32, [0 x i32], i32, [0 x i8], i8, [55 x i8] }\n+\n+pub enum Enum4 {\n+    A(i32),\n+    B(i32),\n+}\n+// CHECK: %Enum4 = type { [2 x i32] }\n \n pub enum Enum64 {\n     A(Align64),\n     B(i32),\n }\n+// CHECK: %Enum64 = type { [16 x i64] }\n+// CHECK: %\"Enum64::A\" = type { [8 x i64], %Align64, [0 x i64] }\n \n // CHECK-LABEL: @align64\n #[no_mangle]\n@@ -46,6 +58,14 @@ pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {\n     n64\n }\n \n+// CHECK-LABEL: @enum4\n+#[no_mangle]\n+pub fn enum4(a: i32) -> Enum4 {\n+// CHECK: %e4 = alloca %Enum4, align 4\n+    let e4 = Enum4::A(a);\n+    e4\n+}\n+\n // CHECK-LABEL: @enum64\n #[no_mangle]\n pub fn enum64(a: Align64) -> Enum64 {"}]}