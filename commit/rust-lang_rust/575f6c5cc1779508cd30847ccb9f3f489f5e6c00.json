{"sha": "575f6c5cc1779508cd30847ccb9f3f489f5e6c00", "node_id": "C_kwDOAAsO6NoAKDU3NWY2YzVjYzE3Nzk1MDhjZDMwODQ3Y2NiOWYzZjQ4OWY1ZTZjMDA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-19T23:37:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-19T23:37:23Z"}, "message": "Rollup merge of #93686 - dbrgn:trim-on-byte-slices, r=joshtriplett\n\ncore: Implement ASCII trim functions on byte slices\n\nHi ````````@rust-lang/libs!```````` This is a feature that I wished for when implementing serial protocols with microcontrollers. Often these protocols may contain leading or trailing whitespace, which needs to be removed. Because oftentimes drivers will operate on the byte level, decoding to unicode and checking for unicode whitespace is unnecessary overhead.\n\nThis PR adds three new methods to byte slices:\n\n- `trim_ascii_start`\n- `trim_ascii_end`\n- `trim_ascii`\n\nI did not find any pre-existing discussions about this, which surprises me a bit. Maybe I'm missing something, and this functionality is already possible through other means? There's https://github.com/rust-lang/rfcs/issues/2547 (\"Trim methods on slices\"), but that has a different purpose.\n\nAs per the [std dev guide](https://std-dev-guide.rust-lang.org/feature-lifecycle/new-unstable-features.html), this is a proposed implementation without any issue / RFC. If this is the wrong process, please let me know. However, I thought discussing code is easier than discussing a mere idea, and hacking on the stdlib was fun.\n\nTracking issue: https://github.com/rust-lang/rust/issues/94035", "tree": {"sha": "5c6ef62c5414d405964d5f986945c379eed3338c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c6ef62c5414d405964d5f986945c379eed3338c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/575f6c5cc1779508cd30847ccb9f3f489f5e6c00", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiEX8zCRBK7hj4Ov3rIwAAlicIAKBxbDJAgbbd3WCzEDbwK5uK\ngPDstMuEONkZ50N8mV/mhW5paRbAiuaUOVsJEU7k5KiY/RtRm2dW1rBodQxBAOIW\nndG+CCkDd7qUUZFAFwXZsa8Z5VUXtKHpWqqtj0gqQ+EqrylPVh50mLt7tqD3gyZ0\nKmJXmLP8I009OWFjaIhs1Suf7AWXyDc6e1PQhTfWpGN0pxLBCilvbNzC+WLtPIXY\nHpBuVEOO499CvSvvLwTC7cJojxzryrsxO2ZercYvA74VgEnVU/2dpaLi25cUvTdr\nUvLDK5uqKGRZPE8GvisSwypBN45xf7aVc0MejdoUMLUbUEn7ap5FSFjv1OPDJaQ=\n=l+WS\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c6ef62c5414d405964d5f986945c379eed3338c\nparent 4f533de571acce5913d3713062c1f3e44e9a3594\nparent f7448a77e4d9ddb2e0b52905a6a89cab86ea35f6\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645313843 +0100\ncommitter GitHub <noreply@github.com> 1645313843 +0100\n\nRollup merge of #93686 - dbrgn:trim-on-byte-slices, r=joshtriplett\n\ncore: Implement ASCII trim functions on byte slices\n\nHi ````````@rust-lang/libs!```````` This is a feature that I wished for when implementing serial protocols with microcontrollers. Often these protocols may contain leading or trailing whitespace, which needs to be removed. Because oftentimes drivers will operate on the byte level, decoding to unicode and checking for unicode whitespace is unnecessary overhead.\n\nThis PR adds three new methods to byte slices:\n\n- `trim_ascii_start`\n- `trim_ascii_end`\n- `trim_ascii`\n\nI did not find any pre-existing discussions about this, which surprises me a bit. Maybe I'm missing something, and this functionality is already possible through other means? There's https://github.com/rust-lang/rfcs/issues/2547 (\"Trim methods on slices\"), but that has a different purpose.\n\nAs per the [std dev guide](https://std-dev-guide.rust-lang.org/feature-lifecycle/new-unstable-features.html), this is a proposed implementation without any issue / RFC. If this is the wrong process, please let me know. However, I thought discussing code is easier than discussing a mere idea, and hacking on the stdlib was fun.\n\nTracking issue: https://github.com/rust-lang/rust/issues/94035\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/575f6c5cc1779508cd30847ccb9f3f489f5e6c00", "html_url": "https://github.com/rust-lang/rust/commit/575f6c5cc1779508cd30847ccb9f3f489f5e6c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/575f6c5cc1779508cd30847ccb9f3f489f5e6c00/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f533de571acce5913d3713062c1f3e44e9a3594", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f533de571acce5913d3713062c1f3e44e9a3594", "html_url": "https://github.com/rust-lang/rust/commit/4f533de571acce5913d3713062c1f3e44e9a3594"}, {"sha": "f7448a77e4d9ddb2e0b52905a6a89cab86ea35f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7448a77e4d9ddb2e0b52905a6a89cab86ea35f6", "html_url": "https://github.com/rust-lang/rust/commit/f7448a77e4d9ddb2e0b52905a6a89cab86ea35f6"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "1dba24dd149073b39093b3afa79f170a519d23e7", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/575f6c5cc1779508cd30847ccb9f3f489f5e6c00/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575f6c5cc1779508cd30847ccb9f3f489f5e6c00/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=575f6c5cc1779508cd30847ccb9f3f489f5e6c00", "patch": "@@ -79,6 +79,84 @@ impl [u8] {\n     pub fn escape_ascii(&self) -> EscapeAscii<'_> {\n         EscapeAscii { inner: self.iter().flat_map(EscapeByte) }\n     }\n+\n+    /// Returns a byte slice with leading ASCII whitespace bytes removed.\n+    ///\n+    /// 'Whitespace' refers to the definition used by\n+    /// `u8::is_ascii_whitespace`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(byte_slice_trim_ascii)]\n+    ///\n+    /// assert_eq!(b\" \\t hello world\\n\".trim_ascii_start(), b\"hello world\\n\");\n+    /// assert_eq!(b\"  \".trim_ascii_start(), b\"\");\n+    /// assert_eq!(b\"\".trim_ascii_start(), b\"\");\n+    /// ```\n+    #[unstable(feature = \"byte_slice_trim_ascii\", issue = \"94035\")]\n+    pub const fn trim_ascii_start(&self) -> &[u8] {\n+        let mut bytes = self;\n+        // Note: A pattern matching based approach (instead of indexing) allows\n+        // making the function const.\n+        while let [first, rest @ ..] = bytes {\n+            if first.is_ascii_whitespace() {\n+                bytes = rest;\n+            } else {\n+                break;\n+            }\n+        }\n+        bytes\n+    }\n+\n+    /// Returns a byte slice with trailing ASCII whitespace bytes removed.\n+    ///\n+    /// 'Whitespace' refers to the definition used by\n+    /// `u8::is_ascii_whitespace`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(byte_slice_trim_ascii)]\n+    ///\n+    /// assert_eq!(b\"\\r hello world\\n \".trim_ascii_end(), b\"\\r hello world\");\n+    /// assert_eq!(b\"  \".trim_ascii_end(), b\"\");\n+    /// assert_eq!(b\"\".trim_ascii_end(), b\"\");\n+    /// ```\n+    #[unstable(feature = \"byte_slice_trim_ascii\", issue = \"94035\")]\n+    pub const fn trim_ascii_end(&self) -> &[u8] {\n+        let mut bytes = self;\n+        // Note: A pattern matching based approach (instead of indexing) allows\n+        // making the function const.\n+        while let [rest @ .., last] = bytes {\n+            if last.is_ascii_whitespace() {\n+                bytes = rest;\n+            } else {\n+                break;\n+            }\n+        }\n+        bytes\n+    }\n+\n+    /// Returns a byte slice with leading and trailing ASCII whitespace bytes\n+    /// removed.\n+    ///\n+    /// 'Whitespace' refers to the definition used by\n+    /// `u8::is_ascii_whitespace`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(byte_slice_trim_ascii)]\n+    ///\n+    /// assert_eq!(b\"\\r hello world\\n \".trim_ascii(), b\"hello world\");\n+    /// assert_eq!(b\"  \".trim_ascii(), b\"\");\n+    /// assert_eq!(b\"\".trim_ascii(), b\"\");\n+    /// ```\n+    #[unstable(feature = \"byte_slice_trim_ascii\", issue = \"94035\")]\n+    pub const fn trim_ascii(&self) -> &[u8] {\n+        self.trim_ascii_start().trim_ascii_end()\n+    }\n }\n \n impl_fn_for_zst! {"}]}