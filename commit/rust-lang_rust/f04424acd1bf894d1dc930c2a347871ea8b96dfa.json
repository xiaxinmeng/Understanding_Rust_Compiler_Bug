{"sha": "f04424acd1bf894d1dc930c2a347871ea8b96dfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNDQyNGFjZDFiZjg5NGQxZGM5MzBjMmEzNDc4NzFlYThiOTZkZmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-06T15:18:42Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-14T11:36:51Z"}, "message": "rustc_mir: compute all the qualification bits separately in qualify_consts.", "tree": {"sha": "7da006092dddce5d64fddbbf9fa9d60d98d3bb4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da006092dddce5d64fddbbf9fa9d60d98d3bb4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f04424acd1bf894d1dc930c2a347871ea8b96dfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f04424acd1bf894d1dc930c2a347871ea8b96dfa", "html_url": "https://github.com/rust-lang/rust/commit/f04424acd1bf894d1dc930c2a347871ea8b96dfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f04424acd1bf894d1dc930c2a347871ea8b96dfa/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81648a0a6e6aaf66913dc92187613d8cffff3fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/81648a0a6e6aaf66913dc92187613d8cffff3fd4", "html_url": "https://github.com/rust-lang/rust/commit/81648a0a6e6aaf66913dc92187613d8cffff3fd4"}], "stats": {"total": 869, "additions": 504, "deletions": 365}, "files": [{"sha": "963bbcf0f0429b59a0164a95b6f5e7b981aa02b2", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f04424acd1bf894d1dc930c2a347871ea8b96dfa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f04424acd1bf894d1dc930c2a347871ea8b96dfa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f04424acd1bf894d1dc930c2a347871ea8b96dfa", "patch": "@@ -2822,7 +2822,6 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\","}, {"sha": "c32bafa99205f4179312e8ecd74915a6f2390ccb", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f04424acd1bf894d1dc930c2a347871ea8b96dfa/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f04424acd1bf894d1dc930c2a347871ea8b96dfa/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=f04424acd1bf894d1dc930c2a347871ea8b96dfa", "patch": "@@ -11,7 +11,6 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n arena = { path = \"../libarena\" }\n-bitflags = \"1.0\"\n either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n log = \"0.4\""}, {"sha": "51168f650aeb774d9afea7bf15c6287654c70537", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 504, "deletions": 363, "changes": 867, "blob_url": "https://github.com/rust-lang/rust/blob/f04424acd1bf894d1dc930c2a347871ea8b96dfa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04424acd1bf894d1dc930c2a347871ea8b96dfa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f04424acd1bf894d1dc930c2a347871ea8b96dfa", "patch": "@@ -25,67 +25,12 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n-use std::ops::Deref;\n+use std::ops::{Deref, Index, IndexMut};\n use std::usize;\n \n use crate::transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n \n-bitflags::bitflags! {\n-    // Borrows of temporaries can be promoted only if\n-    // they have none of these qualifications, with\n-    // the exception of `STATIC_REF` (in statics only).\n-    struct Qualif: u8 {\n-        // Constant containing interior mutability (UnsafeCell).\n-        const MUTABLE_INTERIOR  = 1 << 0;\n-\n-        // Constant containing an ADT that implements Drop.\n-        const NEEDS_DROP        = 1 << 1;\n-\n-        // Not constant at all - non-`const fn` calls, asm!,\n-        // pointer comparisons, ptr-to-int casts, etc.\n-        const NOT_CONST         = 1 << 2;\n-\n-        // Refers to temporaries which cannot be promoted as\n-        // promote_consts decided they weren't simple enough.\n-        const NOT_PROMOTABLE    = 1 << 3;\n-    }\n-}\n-\n-impl<'a, 'tcx> Qualif {\n-    /// Compute the qualifications for the given type.\n-    fn any_value_of_ty(\n-        ty: Ty<'tcx>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> Self {\n-        let mut qualif = Self::empty();\n-        if !ty.is_freeze(tcx, param_env, DUMMY_SP) {\n-            qualif = qualif | Qualif::MUTABLE_INTERIOR;\n-        }\n-        if ty.needs_drop(tcx, param_env) {\n-            qualif = qualif | Qualif::NEEDS_DROP;\n-        }\n-        qualif\n-    }\n-\n-    /// Remove flags which are impossible for the given type.\n-    fn restrict(\n-        &mut self,\n-        ty: Ty<'tcx>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) {\n-        let ty_qualif = Self::any_value_of_ty(ty, tcx, param_env);\n-        if !ty_qualif.contains(Qualif::MUTABLE_INTERIOR) {\n-            *self = *self - Qualif::MUTABLE_INTERIOR;\n-        }\n-        if !ty_qualif.contains(Qualif::NEEDS_DROP) {\n-            *self = *self - Qualif::NEEDS_DROP;\n-        }\n-    }\n-}\n-\n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Mode {\n@@ -107,264 +52,404 @@ impl fmt::Display for Mode {\n     }\n }\n \n+const QUALIF_COUNT: usize = 4;\n+\n+// FIXME(eddyb) once we can use const generics, replace this array with\n+// something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n+#[derive(Copy, Clone, Default)]\n+struct PerQualif<T>([T; QUALIF_COUNT]);\n+\n+impl<T: Clone> PerQualif<T> {\n+    fn new(x: T) -> Self {\n+        PerQualif([x.clone(), x.clone(), x.clone(), x])\n+    }\n+}\n+\n+impl<T> PerQualif<T> {\n+    fn as_mut(&mut self) -> PerQualif<&mut T> {\n+        let [x0, x1, x2, x3] = &mut self.0;\n+        PerQualif([x0, x1, x2, x3])\n+    }\n+\n+    fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n+        let [x0, x1, x2, x3] = self.0;\n+        let [y0, y1, y2, y3] = other.0;\n+        PerQualif([(x0, y0), (x1, y1), (x2, y2), (x3, y3)])\n+    }\n+}\n+\n+impl PerQualif<bool> {\n+    fn encode_to_bits(self) -> u8 {\n+        self.0.iter().enumerate().fold(0, |bits, (i, &qualif)| {\n+            bits | ((qualif as u8) << i)\n+        })\n+    }\n+\n+    fn decode_from_bits(bits: u8) -> Self {\n+        let mut qualifs = Self::default();\n+        for (i, qualif) in qualifs.0.iter_mut().enumerate() {\n+            *qualif = (bits & (1 << i)) != 0;\n+        }\n+        qualifs\n+    }\n+}\n+\n+impl<Q: Qualif, T> Index<Q> for PerQualif<T> {\n+    type Output = T;\n+\n+    fn index(&self, _: Q) -> &T {\n+        &self.0[Q::IDX]\n+    }\n+}\n+\n+impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n+    fn index_mut(&mut self, _: Q) -> &mut T {\n+        &mut self.0[Q::IDX]\n+    }\n+}\n+\n struct ConstCx<'a, 'tcx> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n     mir: &'a Mir<'tcx>,\n \n-    local_qualif: IndexVec<Local, Qualif>,\n+    per_local: PerQualif<BitSet<Local>>,\n }\n \n impl<'a, 'tcx> ConstCx<'a, 'tcx> {\n-    fn qualify_any_value_of_ty(&self, ty: Ty<'tcx>) -> Qualif {\n-        Qualif::any_value_of_ty(ty, self.tcx, self.param_env)\n+    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n+        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n+        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n     }\n+}\n \n-    fn qualify_local(&self, local: Local) -> Qualif {\n-        self.local_qualif[local]\n+#[derive(Copy, Clone, Debug)]\n+enum ValueSource<'a, 'tcx> {\n+    Rvalue(&'a Rvalue<'tcx>),\n+    Call {\n+        callee: &'a Operand<'tcx>,\n+        args: &'a [Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    },\n+}\n+\n+trait Qualif {\n+    const IDX: usize;\n+\n+    /// Return the qualification that is (conservatively) correct for any value\n+    /// of the type, or `None` if the qualification is not value/type-based.\n+    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> Option<bool> {\n+        None\n+    }\n+\n+    /// Return a mask for the qualification, given a type. This is `false` iff\n+    /// no value of that type can have the qualification.\n+    fn mask_for_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        Self::in_any_value_of_ty(cx, ty).unwrap_or(true)\n     }\n \n-    fn qualify_projection_elem(&self, proj: &PlaceElem<'tcx>) -> Qualif {\n-        match *proj {\n+    fn in_local(cx: &ConstCx<'_, '_>, local: Local) -> bool {\n+        cx.per_local.0[Self::IDX].contains(local)\n+    }\n+\n+    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n+        // FIXME(eddyb) should we do anything here for value properties?\n+        false\n+    }\n+\n+    fn in_projection_structurally(\n+        cx: &ConstCx<'_, 'tcx>,\n+        proj: &PlaceProjection<'tcx>,\n+    ) -> bool {\n+        let base_qualif = Self::in_place(cx, &proj.base);\n+        let qualif = base_qualif && Self::mask_for_ty(\n+            cx,\n+            proj.base.ty(cx.mir, cx.tcx)\n+                .projection_ty(cx.tcx, &proj.elem)\n+                .to_ty(cx.tcx),\n+        );\n+        match proj.elem {\n             ProjectionElem::Deref |\n             ProjectionElem::Subslice { .. } |\n             ProjectionElem::Field(..) |\n             ProjectionElem::ConstantIndex { .. } |\n-            ProjectionElem::Downcast(..) => Qualif::empty(),\n+            ProjectionElem::Downcast(..) => qualif,\n \n-            ProjectionElem::Index(local) => self.qualify_local(local),\n+            ProjectionElem::Index(local) => qualif || Self::in_local(cx, local),\n         }\n     }\n \n-    fn qualify_place(&self, place: &Place<'tcx>) -> Qualif {\n+    fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n+        Self::in_projection_structurally(cx, proj)\n+    }\n+\n+    fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n         match *place {\n-            Place::Local(local) => self.qualify_local(local),\n+            Place::Local(local) => Self::in_local(cx, local),\n             Place::Promoted(_) => bug!(\"qualifying already promoted MIR\"),\n-            Place::Static(ref global) => {\n-                if self.tcx\n-                       .get_attrs(global.def_id)\n-                       .iter()\n-                       .any(|attr| attr.check_name(\"thread_local\")) {\n-                    return Qualif::NOT_CONST;\n-                }\n-\n-                // Only allow statics (not consts) to refer to other statics.\n-                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    Qualif::empty()\n-                } else {\n-                    Qualif::NOT_CONST\n-                }\n-            }\n-            Place::Projection(ref proj) => {\n-                let mut qualif =\n-                    self.qualify_place(&proj.base) |\n-                    self.qualify_projection_elem(&proj.elem);\n-                match proj.elem {\n-                    ProjectionElem::Deref |\n-                    ProjectionElem::Downcast(..) => qualif | Qualif::NOT_CONST,\n-\n-                    ProjectionElem::ConstantIndex {..} |\n-                    ProjectionElem::Subslice {..} |\n-                    ProjectionElem::Field(..) |\n-                    ProjectionElem::Index(_) => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                        if let Some(def) = base_ty.ty_adt_def() {\n-                            if def.is_union() {\n-                                match self.mode {\n-                                    Mode::Fn => qualif = qualif | Qualif::NOT_CONST,\n-\n-                                    Mode::ConstFn |\n-                                    Mode::Static |\n-                                    Mode::StaticMut |\n-                                    Mode::Const => {}\n-                                }\n-                            }\n-                        }\n-\n-                        let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                        qualif.restrict(ty, self.tcx, self.param_env);\n-                        qualif\n-                    }\n-                }\n-            }\n+            Place::Static(ref static_) => Self::in_static(cx, static_),\n+            Place::Projection(ref proj) => Self::in_projection(cx, proj),\n         }\n     }\n \n-    fn qualify_operand(&self, operand: &Operand<'tcx>) -> Qualif {\n+    fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n         match *operand {\n             Operand::Copy(ref place) |\n-            Operand::Move(ref place) => self.qualify_place(place),\n+            Operand::Move(ref place) => Self::in_place(cx, place),\n \n             Operand::Constant(ref constant) => {\n                 if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n                     // Don't peek inside trait associated constants.\n-                    if self.tcx.trait_of_item(*def_id).is_some() {\n-                        self.qualify_any_value_of_ty(constant.ty)\n+                    if cx.tcx.trait_of_item(*def_id).is_some() {\n+                        Self::in_any_value_of_ty(cx, constant.ty).unwrap_or(false)\n                     } else {\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(*def_id);\n+                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(*def_id);\n \n-                        let mut qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n+                        let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n \n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n-                        qualif.restrict(constant.ty, self.tcx, self.param_env);\n-                        qualif\n+                        qualif && Self::mask_for_ty(cx, constant.ty)\n                     }\n                 } else {\n-                    Qualif::empty()\n+                    false\n                 }\n             }\n         }\n     }\n \n-    fn qualify_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Qualif {\n+    fn in_rvalue_structurally(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n         match *rvalue {\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) => Qualif::empty(),\n+            Rvalue::NullaryOp(..) => false,\n+\n+            Rvalue::Discriminant(ref place) |\n+            Rvalue::Len(ref place) => Self::in_place(cx, place),\n \n             Rvalue::Use(ref operand) |\n             Rvalue::Repeat(ref operand, _) |\n-            Rvalue::UnaryOp(UnOp::Neg, ref operand) |\n-            Rvalue::UnaryOp(UnOp::Not, ref operand) |\n-            Rvalue::Cast(CastKind::ReifyFnPointer, ref operand, _) |\n-            Rvalue::Cast(CastKind::UnsafeFnPointer, ref operand, _) |\n-            Rvalue::Cast(CastKind::ClosureFnPointer, ref operand, _) |\n-            Rvalue::Cast(CastKind::Unsize, ref operand, _) => {\n-                self.qualify_operand(operand)\n-            }\n+            Rvalue::UnaryOp(_, ref operand) |\n+            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, operand),\n \n+            Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n             Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n-                self.qualify_operand(lhs) | self.qualify_operand(rhs)\n+                Self::in_operand(cx, lhs) || Self::in_operand(cx, rhs)\n             }\n \n-            Rvalue::Discriminant(ref place) |\n-            Rvalue::Len(ref place) => self.qualify_place(place),\n-\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let mut reborrow_qualif = None;\n+            Rvalue::Ref(_, _, ref place) => {\n+                // Special-case reborrows to be more like a copy of the reference.\n                 if let Place::Projection(ref proj) = *place {\n                     if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n                         if let ty::Ref(..) = base_ty.sty {\n-                            reborrow_qualif = Some(self.qualify_place(&proj.base));\n+                            return Self::in_place(cx, &proj.base);\n                         }\n                     }\n                 }\n \n-                let mut qualif = reborrow_qualif.unwrap_or_else(|| {\n-                    self.qualify_place(place)\n-                });\n+                Self::in_place(cx, place)\n+            }\n \n-                let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            Rvalue::Aggregate(_, ref operands) => {\n+                operands.iter().any(|o| Self::in_operand(cx, o))\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        _callee: &Operand<'tcx>,\n+        _args: &[Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Be conservative about the returned value of a const fn.\n+        Self::in_any_value_of_ty(cx, return_ty).unwrap_or(false)\n+    }\n+\n+    fn in_value(cx: &ConstCx<'_, 'tcx>, source: ValueSource<'_, 'tcx>) -> bool {\n+        match source {\n+            ValueSource::Rvalue(rvalue) => Self::in_rvalue(cx, rvalue),\n+            ValueSource::Call { callee, args, return_ty } => {\n+                Self::in_call(cx, callee, args, return_ty)\n+            }\n+        }\n+    }\n+}\n+\n+// Constant containing interior mutability (UnsafeCell).\n+struct HasMutInterior;\n+\n+impl Qualif for HasMutInterior {\n+    const IDX: usize = 0;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+        Some(!ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP))\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n+            // allowed in constants (and the `Checker` will error), and/or it\n+            // won't be promoted, due to `&mut ...` or interior mutability.\n+            Rvalue::Ref(_, kind, ref place) => {\n+                let ty = place.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n \n                 if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    let allowed = if self.mode == Mode::StaticMut {\n+                    if cx.mode == Mode::StaticMut {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.sty {\n-                            ty::Array(..) | ty::Slice(_) => true,\n-                            _ => false\n+                            ty::Array(..) | ty::Slice(_) => {}\n+                            _ => return true,\n                         }\n                     } else if let ty::Array(_, len) = ty.sty {\n-                        // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n+                        // FIXME(eddyb) the `cx.mode == Mode::Fn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n-                        len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn\n+                        if !(len.unwrap_usize(cx.tcx) == 0 && cx.mode == Mode::Fn) {\n+                            return true;\n+                        }\n                     } else {\n-                        false\n-                    };\n+                        return true;\n+                    }\n+                }\n+            }\n \n-                    if !allowed {\n-                        qualif = qualif | Qualif::MUTABLE_INTERIOR;\n+            Rvalue::Aggregate(ref kind, _) => {\n+                if let AggregateKind::Adt(def, ..) = **kind {\n+                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n+                        let ty = rvalue.ty(cx.mir, cx.tcx);\n+                        assert_eq!(Self::in_any_value_of_ty(cx, ty), Some(true));\n+                        return true;\n                     }\n                 }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+}\n+\n+// Constant containing an ADT that implements Drop.\n+struct NeedsDrop;\n+\n+impl Qualif for NeedsDrop {\n+    const IDX: usize = 1;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+        Some(ty.needs_drop(cx.tcx, cx.param_env))\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n+            if let AggregateKind::Adt(def, ..) = **kind {\n+                if def.has_dtor(cx.tcx) {\n+                    return true;\n+                }\n+            }\n+        }\n \n-                qualif\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+}\n+\n+// Not constant at all - non-`const fn` calls, asm!,\n+// pointer comparisons, ptr-to-int casts, etc.\n+struct IsNotConst;\n+\n+impl Qualif for IsNotConst {\n+    const IDX: usize = 2;\n+\n+    fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n+        // Only allow statics (not consts) to refer to other statics.\n+        let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n+\n+        !allowed ||\n+            cx.tcx.get_attrs(static_.def_id).iter().any(|attr| attr.check_name(\"thread_local\"))\n+    }\n+\n+    fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n+        match proj.elem {\n+            ProjectionElem::Deref |\n+            ProjectionElem::Downcast(..) => return true,\n+\n+            ProjectionElem::ConstantIndex {..} |\n+            ProjectionElem::Subslice {..} |\n+            ProjectionElem::Index(_) => {}\n+\n+            ProjectionElem::Field(..) => {\n+                if cx.mode == Mode::Fn {\n+                    let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                    if let Some(def) = base_ty.ty_adt_def() {\n+                        if def.is_union() {\n+                            return true;\n+                        }\n+                    }\n+                }\n             }\n+        }\n \n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let mut qualif = self.qualify_operand(operand);\n+        Self::in_projection_structurally(cx, proj)\n+    }\n \n-                let operand_ty = operand.ty(self.mir, self.tcx);\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::Fn => {\n+                let operand_ty = operand.ty(cx.mir, cx.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n                     (CastTy::FnPtr, CastTy::Int(_)) => {\n-                        if let Mode::Fn = self.mode {\n-                            // in normal functions, mark such casts as not promotable\n-                            qualif = qualif | Qualif::NOT_CONST;\n-                        }\n+                        // in normal functions, mark such casts as not promotable\n+                        return true;\n                     }\n                     _ => {}\n                 }\n-\n-                qualif\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let mut qualif = self.qualify_operand(lhs) | self.qualify_operand(rhs);\n-\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.mir, self.tcx).sty {\n+            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::Fn => {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.mir, cx.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n                             op == BinOp::Offset);\n \n-                    if let Mode::Fn = self.mode {\n-                        // raw pointer operations are not allowed inside promoteds\n-                        qualif = qualif | Qualif::NOT_CONST;\n-                    }\n+                    // raw pointer operations are not allowed inside promoteds\n+                    return true;\n                 }\n-\n-                qualif\n             }\n \n-            Rvalue::NullaryOp(NullOp::Box, _) => Qualif::NOT_CONST,\n-\n-            Rvalue::Aggregate(ref kind, ref operands) => {\n-                let mut qualif = operands.iter().map(|o| self.qualify_operand(o))\n-                    .fold(Qualif::empty(), |a, b| a | b);\n-\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(self.mir, self.tcx);\n-                        qualif = qualif | self.qualify_any_value_of_ty(ty);\n-                        assert!(qualif.contains(Qualif::MUTABLE_INTERIOR));\n-                    }\n-\n-                    if def.has_dtor(self.tcx) {\n-                        qualif = qualif | Qualif::NEEDS_DROP;\n-                    }\n-                }\n+            Rvalue::NullaryOp(NullOp::Box, _) => return true,\n \n-                qualif\n-            }\n+            _ => {}\n         }\n-    }\n \n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        Self::in_rvalue_structurally(cx, rvalue)\n     }\n \n-    fn qualify_call(\n-        &self,\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> Qualif {\n-        let fn_ty = callee.ty(self.mir, self.tcx);\n-        let mut is_promotable_const_fn = false;\n-        let is_const_fn = match fn_ty.sty {\n+        _return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let fn_ty = callee.ty(cx.mir, cx.tcx);\n+        match fn_ty.sty {\n             ty::FnDef(def_id, _) => {\n-                match self.tcx.fn_sig(def_id).abi() {\n+                match cx.tcx.fn_sig(def_id).abi() {\n                     Abi::RustIntrinsic |\n                     Abi::PlatformIntrinsic => {\n-                        assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id).as_str()[..] {\n+                        assert!(!cx.tcx.is_const_fn(def_id));\n+                        match &cx.tcx.item_name(def_id).as_str()[..] {\n                             | \"size_of\"\n                             | \"min_align_of\"\n                             | \"needs_drop\"\n@@ -389,50 +474,100 @@ impl<'a, 'tcx> ConstCx<'a, 'tcx> {\n                             | \"saturating_add\"\n                             | \"saturating_sub\"\n                             | \"transmute\"\n-                            => true,\n+                            => return true,\n \n-                            _ => false,\n+                            _ => {}\n                         }\n                     }\n                     _ => {\n-                        // Never promote runtime `const fn` calls of\n-                        // functions without `#[rustc_promotable]`.\n-                        if self.tcx.is_promotable_const_fn(def_id) {\n-                            is_promotable_const_fn = true;\n-                        }\n-\n-                        if self.mode == Mode::Fn {\n-                            self.tcx.is_const_fn(def_id)\n-                        } else {\n-                            self.tcx.is_const_fn(def_id) ||\n-                            self.is_const_panic_fn(def_id) ||\n-                            self.tcx.is_unstable_const_fn(def_id).is_some()\n+                        let is_const_fn =\n+                            cx.tcx.is_const_fn(def_id) ||\n+                            cx.tcx.is_unstable_const_fn(def_id).is_some() ||\n+                            cx.is_const_panic_fn(def_id);\n+                        if !is_const_fn {\n+                            return true;\n                         }\n                     }\n                 }\n             }\n-            _ => false,\n-        };\n-\n-        // Bail out on oon-`const fn` calls or if the callee had errors.\n-        if !is_const_fn || self.qualify_operand(callee).intersects(Qualif::NOT_CONST) {\n-            return Qualif::NOT_CONST;\n+            _ => return true,\n         }\n \n-        // Bail out if any arguments had errors.\n-        for arg in args {\n-            if self.qualify_operand(arg).intersects(Qualif::NOT_CONST) {\n-                return Qualif::NOT_CONST;\n+        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n+    }\n+}\n+\n+// Refers to temporaries which cannot be promoted as\n+// promote_consts decided they weren't simple enough.\n+struct IsNotPromotable;\n+\n+impl Qualif for IsNotPromotable {\n+    const IDX: usize = 3;\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        callee: &Operand<'tcx>,\n+        _args: &[Operand<'tcx>],\n+        _return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if cx.mode == Mode::Fn {\n+            if let ty::FnDef(def_id, _) = callee.ty(cx.mir, cx.tcx).sty {\n+                // Never promote runtime `const fn` calls of\n+                // functions without `#[rustc_promotable]`.\n+                if !cx.tcx.is_promotable_const_fn(def_id) {\n+                    return true;\n+                }\n             }\n         }\n \n-        // Be conservative about the returned value of a const fn.\n-        let qualif = self.qualify_any_value_of_ty(return_ty);\n-        if !is_promotable_const_fn && self.mode == Mode::Fn {\n-            qualif | Qualif::NOT_PROMOTABLE\n-        } else {\n-            qualif\n-        }\n+        // FIXME(eddyb) do we need \"not promotable\" in anything\n+        // other than `Mode::Fn` by any chance?\n+\n+        false\n+    }\n+}\n+\n+// Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n+macro_rules! static_assert_seq_qualifs {\n+    ($i:expr => $first:ident $(, $rest:ident)*) => {\n+        static_assert!(SEQ_QUALIFS: {\n+            static_assert_seq_qualifs!($i + 1 => $($rest),*);\n+\n+            $first::IDX == $i\n+        });\n+    };\n+    ($i:expr =>) => {\n+        static_assert!(SEQ_QUALIFS: QUALIF_COUNT == $i);\n+    };\n+}\n+static_assert_seq_qualifs!(0 => HasMutInterior, NeedsDrop, IsNotConst, IsNotPromotable);\n+\n+impl ConstCx<'_, 'tcx> {\n+    fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n+        let mut qualifs = PerQualif::default();\n+        qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs[IsNotConst] = IsNotConst::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs[IsNotPromotable] = IsNotPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs\n+    }\n+\n+    fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n+        let mut qualifs = PerQualif::default();\n+        qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n+        qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n+        qualifs[IsNotConst] = IsNotConst::in_local(self, local);\n+        qualifs[IsNotPromotable] = IsNotPromotable::in_local(self, local);\n+        qualifs\n+    }\n+\n+    fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n+        let mut qualifs = PerQualif::default();\n+        qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n+        qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n+        qualifs[IsNotConst] = IsNotConst::in_value(self, source);\n+        qualifs[IsNotPromotable] = IsNotPromotable::in_value(self, source);\n+        qualifs\n     }\n }\n \n@@ -477,31 +612,40 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let param_env = tcx.param_env(def_id);\n \n-        let local_qualif = mir.local_decls.iter_enumerated().map(|(local, decl)| {\n+        let mut cx = ConstCx {\n+            tcx,\n+            param_env,\n+            mode,\n+            mir,\n+            per_local: PerQualif::new(BitSet::new_empty(mir.local_decls.len())),\n+        };\n+\n+        for (local, decl) in mir.local_decls.iter_enumerated() {\n             match mir.local_kind(local) {\n                 LocalKind::Arg => {\n-                    Qualif::any_value_of_ty(decl.ty, tcx, param_env) |\n-                        Qualif::NOT_PROMOTABLE\n+                    let qualifs = cx.qualifs_in_any_value_of_ty(decl.ty);\n+                    for (per_local, qualif) in &mut cx.per_local.as_mut().zip(qualifs).0 {\n+                        if *qualif {\n+                            per_local.insert(local);\n+                        }\n+                    }\n+                    cx.per_local[IsNotPromotable].insert(local);\n                 }\n \n-                LocalKind::Var if mode == Mode::Fn => Qualif::NOT_CONST,\n+                LocalKind::Var if mode == Mode::Fn => {\n+                    cx.per_local[IsNotConst].insert(local);\n+                }\n \n                 LocalKind::Temp if !temps[local].is_promotable() => {\n-                    Qualif::NOT_PROMOTABLE\n+                    cx.per_local[IsNotPromotable].insert(local);\n                 }\n \n-                _ => Qualif::empty(),\n+                _ => {}\n             }\n-        }).collect();\n+        }\n \n         Checker {\n-            cx: ConstCx {\n-                tcx,\n-                param_env,\n-                mode,\n-                mir,\n-                local_qualif,\n-            },\n+            cx,\n             span: mir.span,\n             def_id,\n             rpo,\n@@ -534,23 +678,76 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n \n     /// Assigns an rvalue/call qualification to the given destination.\n-    fn assign(&mut self, dest: &Place<'tcx>, qualif: Qualif, location: Location) {\n-        trace!(\"assign: {:?} <- {:?}\", dest, qualif);\n+    fn assign(&mut self, dest: &Place<'tcx>, source: ValueSource<'_, 'tcx>, location: Location) {\n+        trace!(\"assign: {:?} <- {:?}\", dest, source);\n \n-        // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::Fn {\n-            if let Place::Local(index) = *dest {\n-                if self.mir.local_kind(index) == LocalKind::Temp\n-                && self.temp_promotion_state[index].is_promotable() {\n-                    debug!(\"store to promotable temp {:?} ({:?})\", index, qualif);\n-                    let slot = &mut self.cx.local_qualif[index];\n-                    if !slot.is_empty() {\n-                        span_bug!(self.span, \"multiple assignments to {:?}\", dest);\n+        let mut qualifs = self.qualifs_in_value(source);\n+\n+        if let ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) = source {\n+            // Getting `true` from `HasMutInterior::in_rvalue` means\n+            // the borrowed place is disallowed from being borrowed,\n+            // due to either a mutable borrow (with some exceptions),\n+            // or an shared borrow of a value with interior mutability.\n+            // Then `HasMutInterior` is replaced with `IsNotConst`,\n+            // to avoid duplicate errors (e.g. from reborrowing).\n+            if qualifs[HasMutInterior] {\n+                qualifs[HasMutInterior] = false;\n+                qualifs[IsNotConst] = true;\n+\n+                if self.mode != Mode::Fn {\n+                    if let BorrowKind::Mut { .. } = kind {\n+                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                       \"references in {}s may only refer \\\n+                                                        to immutable values\", self.mode);\n+                        err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                            self.mode));\n+                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                            err.note(\"References in statics and constants may only refer to \\\n+                                      immutable values.\\n\\n\\\n+                                      Statics are shared everywhere, and if they refer to \\\n+                                      mutable data one might violate memory safety since \\\n+                                      holding multiple mutable references to shared data is \\\n+                                      not allowed.\\n\\n\\\n+                                      If you really want global mutable state, try using \\\n+                                      static mut or a global UnsafeCell.\");\n+                        }\n+                        err.emit();\n+                    } else {\n+                        span_err!(self.tcx.sess, self.span, E0492,\n+                                  \"cannot borrow a constant which may contain \\\n+                                   interior mutability, create a static instead\");\n+                    }\n+                }\n+            } else {\n+                // We might have a candidate for promotion.\n+                let candidate = Candidate::Ref(location);\n+                // We can only promote interior borrows of promotable temps.\n+                let mut place = place;\n+                while let Place::Projection(ref proj) = *place {\n+                    if proj.elem == ProjectionElem::Deref {\n+                        break;\n+                    }\n+                    place = &proj.base;\n+                }\n+                debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                if let Place::Local(local) = *place {\n+                    if self.mir.local_kind(local) == LocalKind::Temp {\n+                        debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n+                        // The borrowed place doesn't have `HasMutInterior`\n+                        // (from `in_rvalue`), so we can safely ignore\n+                        // `HasMutInterior` from the local's qualifications.\n+                        // This allows borrowing fields which don't have\n+                        // `HasMutInterior`, from a type that does, e.g.:\n+                        // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                        let mut local_qualifs = self.qualifs_in_local(local);\n+                        local_qualifs[HasMutInterior] = false;\n+                        if !local_qualifs.0.iter().any(|&qualif| qualif) {\n+                            debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n+                            self.promotion_candidates.push(candidate);\n+                        }\n                     }\n-                    *slot = qualif;\n                 }\n             }\n-            return;\n         }\n \n         let mut dest = dest;\n@@ -588,27 +785,39 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let kind = self.mir.local_kind(index);\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n+        // Only handle promotable temps in non-const functions.\n+        if self.mode == Mode::Fn {\n+            if kind != LocalKind::Temp ||\n+               !self.temp_promotion_state[index].is_promotable() {\n+                return;\n+            }\n+        }\n+\n         // this is overly restrictive, because even full assignments do not clear the qualif\n         // While we could special case full assignments, this would be inconsistent with\n         // aggregates where we overwrite all fields via assignments, which would not get\n         // that feature.\n-        let slot = &mut self.cx.local_qualif[index];\n-        *slot = *slot | qualif;\n+        for (per_local, qualif) in &mut self.cx.per_local.as_mut().zip(qualifs).0 {\n+            if *qualif {\n+                per_local.insert(index);\n+            }\n+        }\n \n-        // Ensure we keep the `NOT_PROMOTABLE` flag is preserved.\n+        // Ensure the `IsNotPromotable` qualification is preserved.\n         // NOTE(eddyb) this is actually unnecessary right now, as\n-        // we never replace the local's qualif (but we might in\n-        // the future) - also, if `NOT_PROMOTABLE` only matters\n-        // for `Mode::Fn`, then this is also pointless.\n+        // we never replace the local's qualif, but we might in\n+        // the future, and so it serves to catch changes that unset\n+        // important bits (in which case, asserting `contains` could\n+        // be replaced with calling `insert` to re-set the bit).\n         if kind == LocalKind::Temp {\n             if !self.temp_promotion_state[index].is_promotable() {\n-                *slot = *slot | Qualif::NOT_PROMOTABLE;\n+                assert!(self.cx.per_local[IsNotPromotable].contains(index));\n             }\n         }\n     }\n \n     /// Check a whole const, static initializer or const fn.\n-    fn check_const(&mut self) -> (Qualif, Lrc<BitSet<Local>>) {\n+    fn check_const(&mut self) -> (u8, Lrc<BitSet<Local>>) {\n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n@@ -660,14 +869,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        let mut qualif = self.local_qualif[RETURN_PLACE];\n-\n-        // Account for errors in consts by using the\n-        // conservative type qualification instead.\n-        if qualif.intersects(Qualif::NOT_CONST) {\n-            qualif = self.qualify_any_value_of_ty(mir.return_ty());\n-        }\n-\n \n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n@@ -687,7 +888,17 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        (qualif, Lrc::new(promoted_temps))\n+        let promoted_temps = Lrc::new(promoted_temps);\n+\n+        let mut qualifs = self.qualifs_in_local(RETURN_PLACE);\n+\n+        // Account for errors in consts by using the\n+        // conservative type qualification instead.\n+        if qualifs[IsNotConst] {\n+            qualifs = self.qualifs_in_any_value_of_ty(mir.return_ty());\n+        }\n+\n+        (qualifs.encode_to_bits(), promoted_temps)\n     }\n }\n \n@@ -822,8 +1033,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n                 if let Place::Local(local) = *place {\n-                    let slot = &mut self.cx.local_qualif[local];\n-                    *slot = *slot - Qualif::NEEDS_DROP;\n+                    self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n             Operand::Copy(_) |\n@@ -960,9 +1170,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         debug!(\"visit_terminator_kind: bb={:?} kind={:?} location={:?}\", bb, kind, location);\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n             if let Some((ref dest, _)) = *destination {\n-                let ty = dest.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                let qualif = self.qualify_call(func, args, ty);\n-                self.assign(dest, qualif, location);\n+                self.assign(dest, ValueSource::Call {\n+                    callee: func,\n+                    args,\n+                    return_ty: dest.ty(self.mir, self.tcx).to_ty(self.tcx),\n+                }, location);\n             }\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n@@ -1094,8 +1306,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     // which happens even without the user requesting it.\n                     // We can error out with a hard error if the argument is not\n                     // constant here.\n-                    let arg_qualif = self.qualify_operand(arg);\n-                    if (arg_qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n+                    if !IsNotConst::in_operand(self, arg) {\n                         debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n                         self.promotion_candidates.push(candidate);\n                     } else {\n@@ -1125,7 +1336,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n-                    if self.local_qualif[local].contains(Qualif::NEEDS_DROP) {\n+                    if NeedsDrop::in_local(self, local) {\n                         Some(self.mir.local_decls[local].source_info.span)\n                     } else {\n                         None\n@@ -1158,75 +1369,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         debug!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-        let mut qualif = self.qualify_rvalue(rvalue);\n-\n-        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            // Getting `MUTABLE_INTERIOR` from `qualify_rvalue` means\n-            // the borrowed place is disallowed from being borrowed,\n-            // due to either a mutable borrow (with some exceptions),\n-            // or an shared borrow of a value with interior mutability.\n-            // Then `MUTABLE_INTERIOR` is replaced with `NOT_CONST`,\n-            // to avoid duplicate errors (e.g. from reborrowing).\n-            if qualif.contains(Qualif::MUTABLE_INTERIOR) {\n-                qualif = (qualif - Qualif::MUTABLE_INTERIOR) | Qualif::NOT_CONST;\n-\n-                if self.mode != Mode::Fn {\n-                    if let BorrowKind::Mut { .. } = kind {\n-                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                       \"references in {}s may only refer \\\n-                                                        to immutable values\", self.mode);\n-                        err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                            self.mode));\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\"References in statics and constants may only refer to \\\n-                                      immutable values.\\n\\n\\\n-                                      Statics are shared everywhere, and if they refer to \\\n-                                      mutable data one might violate memory safety since \\\n-                                      holding multiple mutable references to shared data is \\\n-                                      not allowed.\\n\\n\\\n-                                      If you really want global mutable state, try using \\\n-                                      static mut or a global UnsafeCell.\");\n-                        }\n-                        err.emit();\n-                    } else {\n-                        span_err!(self.tcx.sess, self.span, E0492,\n-                                  \"cannot borrow a constant which may contain \\\n-                                   interior mutability, create a static instead\");\n-                    }\n-                }\n-            } else {\n-                // We might have a candidate for promotion.\n-                let candidate = Candidate::Ref(location);\n-                // We can only promote interior borrows of promotable temps.\n-                let mut place = place;\n-                while let Place::Projection(ref proj) = *place {\n-                    if proj.elem == ProjectionElem::Deref {\n-                        break;\n-                    }\n-                    place = &proj.base;\n-                }\n-                debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n-                if let Place::Local(local) = *place {\n-                    if self.mir.local_kind(local) == LocalKind::Temp {\n-                        debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                        let qualif = self.local_qualif[local];\n-                        // The borrowed place doesn't have `MUTABLE_INTERIOR`\n-                        // (from `qualify_rvalue`), so we can safely ignore\n-                        // `MUTABLE_INTERIOR` from the local's qualifications.\n-                        // This allows borrowing fields which don't have\n-                        // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n-                        // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                        debug!(\"qualify_consts: promotion candidate: qualif={:?}\", qualif);\n-                        if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n-                            debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                            self.promotion_candidates.push(candidate);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.assign(dest, qualif, location);\n+        self.assign(dest, ValueSource::Rvalue(rvalue), location);\n \n         self.visit_rvalue(rvalue, location);\n     }\n@@ -1281,12 +1424,10 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n-        return (Qualif::NOT_CONST.bits(), Lrc::new(BitSet::new_empty(0)));\n+        return (1 << IsNotConst::IDX, Lrc::new(BitSet::new_empty(0)));\n     }\n \n-    let mut checker = Checker::new(tcx, def_id, mir, Mode::Const);\n-    let (qualif, promoted_temps) = checker.check_const();\n-    (qualif.bits(), promoted_temps)\n+    Checker::new(tcx, def_id, mir, Mode::Const).check_const()\n }\n \n pub struct QualifyAndPromoteConstants;"}]}