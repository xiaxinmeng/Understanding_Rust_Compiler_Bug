{"sha": "637a4590f672998f1265eba1c68efa97f1675e79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzN2E0NTkwZjY3Mjk5OGYxMjY1ZWJhMWM2OGVmYTk3ZjE2NzVlNzk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-13T10:15:12Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-13T10:15:12Z"}, "message": "Merge remote-tracking branch 'origin/master'", "tree": {"sha": "20f011d9c1f7194ac2d0568881aa23f51a6a61cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20f011d9c1f7194ac2d0568881aa23f51a6a61cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/637a4590f672998f1265eba1c68efa97f1675e79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlihhzMACgkQpp+NIls6\n19mjehAAp+OlL+mc71aOsCDHp+PEvFuuU2DUAYDBYYJPUxAjaXVh6hiMzpVrGmWM\nzmuJW732EqGfCOtWmhZ52R/ejdXms1/kcLa64jpGn3nAI78kswD2YtE9hZ+w/ON7\n/J+P52PlL4ItuEoiWrINpSBlQeHZyfLestKyZW8rmxOMEArrKZqrdJfawdIyts++\nTQDy1h56pi+5Ri37CfGG7v3E0rKWmemDg9UR8mZki9RTO1YTItkXmQsQwiW6lBh4\ny59sbryrdiMW6PmhNdzNqivxvLf9zRSMPoXmHN2UKM3ItBZHQ+FsckLuH2kDaJ4O\nnHmPBd3u1yzjV8Ld52SA3Q+PKAUVLkNrX5K8c2P6rdwP/E6QDEVHladgXPjrDdoj\nXsmc3f+QbVh1EmVPvQMKpx21CKtkuIGz+Zsi2dvWJg4BJO2r9mdKN59gQqhE7I4I\nL8qTJuy2SN8SNiFvL36dL+qnHvSCh8yDYHrc4O80GzQkKJKcJO3MMju8D7A57Ak3\nztCDzMCmJOh/h1iEiXBG4mGUliJziUvFdcVG5Fe/AGFN6ZbafjkG/lHDBu6Xd79j\n7DvolZl9+IRVVP49/CzgMgsAAwDVwyC39jDhalqkUpcpakOhqoLtBqrWaedDL59T\nMILq6Mo/q+HqUFoJehgb3LKSG1gMZmxxLG51dOUTTyZgksThrOg=\n=8A2p\n-----END PGP SIGNATURE-----", "payload": "tree 20f011d9c1f7194ac2d0568881aa23f51a6a61cc\nparent 9824c997fe6ee50015e1701e94231331d815db7d\nparent 9a7597d5af4d882ddc92bf568a1c7ba582bb4b55\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486980912 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486980912 +0100\n\nMerge remote-tracking branch 'origin/master'\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/637a4590f672998f1265eba1c68efa97f1675e79", "html_url": "https://github.com/rust-lang/rust/commit/637a4590f672998f1265eba1c68efa97f1675e79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/637a4590f672998f1265eba1c68efa97f1675e79/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9824c997fe6ee50015e1701e94231331d815db7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9824c997fe6ee50015e1701e94231331d815db7d", "html_url": "https://github.com/rust-lang/rust/commit/9824c997fe6ee50015e1701e94231331d815db7d"}, {"sha": "9a7597d5af4d882ddc92bf568a1c7ba582bb4b55", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a7597d5af4d882ddc92bf568a1c7ba582bb4b55", "html_url": "https://github.com/rust-lang/rust/commit/9a7597d5af4d882ddc92bf568a1c7ba582bb4b55"}], "stats": {"total": 371, "additions": 281, "deletions": 90}, "files": [{"sha": "8fdc1487bcc08be1f9ac8e20b946d49591d8fd10", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -1,6 +1,8 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+* New [`mut_from_ref`] lint\n+\n ## 0.0.114 \u2014 2017-02-08\n * Rustup to rustc 1.17.0-nightly (c49d10207 2017-02-07)\n * Tests are now ui tests (testing the exact output of rustc)\n@@ -370,6 +372,7 @@ All notable changes to this project will be documented in this file.\n [`mixed_case_hex_literals`]: https://github.com/Manishearth/rust-clippy/wiki#mixed_case_hex_literals\n [`module_inception`]: https://github.com/Manishearth/rust-clippy/wiki#module_inception\n [`modulo_one`]: https://github.com/Manishearth/rust-clippy/wiki#modulo_one\n+[`mut_from_ref`]: https://github.com/Manishearth/rust-clippy/wiki#mut_from_ref\n [`mut_mut`]: https://github.com/Manishearth/rust-clippy/wiki#mut_mut\n [`mutex_atomic`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic\n [`mutex_integer`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_integer"}, {"sha": "c87733f9dfa7933645a69355309c4a046f74945a", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -256,7 +256,7 @@ name\n [iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                       | warn    | for-looping over `_.next()` which is probably not intended\n [iter_nth](https://github.com/Manishearth/rust-clippy/wiki#iter_nth)                                                   | warn    | using `.iter().nth()` on a standard library type with O(1) element access\n [iter_skip_next](https://github.com/Manishearth/rust-clippy/wiki#iter_skip_next)                                       | warn    | using `.skip(x).next()` on an iterator\n-[large_enum_variant](https://github.com/Manishearth/rust-clippy/wiki#large_enum_variant)                               | warn    | large variants on an enum\n+[large_enum_variant](https://github.com/Manishearth/rust-clippy/wiki#large_enum_variant)                               | warn    | large size difference between variants on an enum\n [len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                           | warn    | traits or impls with a public `len` method but no corresponding `is_empty` method\n [len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                                   | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n@@ -279,6 +279,7 @@ name\n [mixed_case_hex_literals](https://github.com/Manishearth/rust-clippy/wiki#mixed_case_hex_literals)                     | warn    | hex literals whose letter digits are not consistently upper- or lowercased\n [module_inception](https://github.com/Manishearth/rust-clippy/wiki#module_inception)                                   | warn    | modules that have the same name as their parent module\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                               | warn    | taking a number modulo 1, which always returns 0\n+[mut_from_ref](https://github.com/Manishearth/rust-clippy/wiki#mut_from_ref)                                           | warn    | fns that create mutable refs from immutable ref args\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                                     | allow   | usage of double-mut refs, e.g. `&mut &mut ...`\n [mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                                           | warn    | using a mutex where an atomic value could be used instead\n [mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                                         | allow   | using a mutex for an integer type"}, {"sha": "f656d513b516cb3d49f8f2af59d5261e3d7742f1", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -1,4 +1,4 @@\n-//! lint when there are large variants on an enum\n+//! lint when there is a large size difference between variants on an enum\n \n use rustc::lint::*;\n use rustc::hir::*;\n@@ -7,7 +7,7 @@ use rustc::ty::layout::TargetDataLayout;\n use rustc::ty::TypeFoldable;\n use rustc::traits::Reveal;\n \n-/// **What it does:** Checks for large variants on `enum`s.\n+/// **What it does:** Checks for large size differences between variants on `enum`s.\n ///\n /// **Why is this bad?** Enum size is bounded by the largest variant. Having a large variant\n /// can penalize the memory layout of that enum.\n@@ -24,17 +24,17 @@ use rustc::traits::Reveal;\n declare_lint! {\n     pub LARGE_ENUM_VARIANT,\n     Warn,\n-    \"large variants on an enum\"\n+    \"large size difference between variants on an enum\"\n }\n \n #[derive(Copy,Clone)]\n pub struct LargeEnumVariant {\n-    maximum_variant_size_allowed: u64,\n+    maximum_size_difference_allowed: u64,\n }\n \n impl LargeEnumVariant {\n-    pub fn new(maximum_variant_size_allowed: u64) -> Self {\n-        LargeEnumVariant { maximum_variant_size_allowed: maximum_variant_size_allowed }\n+    pub fn new(maximum_size_difference_allowed: u64) -> Self {\n+        LargeEnumVariant { maximum_size_difference_allowed: maximum_size_difference_allowed }\n     }\n }\n \n@@ -50,6 +50,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n         if let ItemEnum(ref def, _) = item.node {\n             let ty = cx.tcx.item_type(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+\n+            let mut smallest_variant: Option<(_, _)> = None;\n+            let mut largest_variant: Option<(_, _)> = None;\n+\n             for (i, variant) in adt.variants.iter().enumerate() {\n                 let data_layout = TargetDataLayout::parse(cx.sess());\n                 cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n@@ -67,32 +71,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n                             }\n                         })\n                         .sum();\n-                    if size > self.maximum_variant_size_allowed {\n-                        span_lint_and_then(cx,\n-                                           LARGE_ENUM_VARIANT,\n-                                           def.variants[i].span,\n-                                           \"large enum variant found\",\n-                                           |db| {\n-                            if variant.fields.len() == 1 {\n-                                let span = match def.variants[i].node.data {\n-                                    VariantData::Struct(ref fields, _) |\n-                                    VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n-                                    VariantData::Unit(_) => unreachable!(),\n-                                };\n-                                if let Some(snip) = snippet_opt(cx, span) {\n-                                    db.span_suggestion(span,\n-                                                       \"consider boxing the large fields to reduce the total size of \\\n-                                                        the enum\",\n-                                                       format!(\"Box<{}>\", snip));\n-                                    return;\n-                                }\n-                            }\n-                            db.span_help(def.variants[i].span,\n-                                         \"consider boxing the large fields to reduce the total size of the enum\");\n-                        });\n-                    }\n+\n+                    let grouped = (size, (i, variant));\n+\n+                    update_if(&mut smallest_variant, grouped, |a, b| b.0 <= a.0);\n+                    update_if(&mut largest_variant, grouped, |a, b| b.0 >= a.0);\n                 });\n             }\n+\n+            if let (Some(smallest), Some(largest)) = (smallest_variant, largest_variant) {\n+                let difference = largest.0 - smallest.0;\n+\n+                if difference > self.maximum_size_difference_allowed {\n+                    let (i, variant) = largest.1;\n+\n+                    span_lint_and_then(cx,\n+                                       LARGE_ENUM_VARIANT,\n+                                       def.variants[i].span,\n+                                       \"large size difference between variants\",\n+                                       |db| {\n+                        if variant.fields.len() == 1 {\n+                            let span = match def.variants[i].node.data {\n+                                VariantData::Struct(ref fields, _) |\n+                                VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n+                                VariantData::Unit(_) => unreachable!(),\n+                            };\n+                            if let Some(snip) = snippet_opt(cx, span) {\n+                                db.span_suggestion(span,\n+                                                   \"consider boxing the large fields to reduce the total size of the \\\n+                                                    enum\",\n+                                                   format!(\"Box<{}>\", snip));\n+                                return;\n+                            }\n+                        }\n+                        db.span_help(def.variants[i].span,\n+                                     \"consider boxing the large fields to reduce the total size of the enum\");\n+                    });\n+                }\n+            }\n+\n+        }\n+    }\n+}\n+\n+fn update_if<T, F>(old: &mut Option<T>, new: T, f: F)\n+    where F: Fn(&T, &T) -> bool\n+{\n+    if let Some(ref mut val) = *old {\n+        if f(val, &new) {\n+            *val = new;\n         }\n+    } else {\n+        *old = Some(new);\n     }\n }"}, {"sha": "de5945df81ffc66859dd5dbb42eca2f277015fbf", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -15,6 +15,7 @@\n #![allow(needless_lifetimes)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n@@ -465,6 +466,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         precedence::PRECEDENCE,\n         print::PRINT_WITH_NEWLINE,\n         ptr::CMP_NULL,\n+        ptr::MUT_FROM_REF,\n         ptr::PTR_ARG,\n         ranges::RANGE_STEP_BY_ZERO,\n         ranges::RANGE_ZIP_WITH_LEN,"}, {"sha": "e9176372ebce97a217d123e9fe89867111e7e559", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -5,7 +5,9 @@ use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n use syntax::ast::NodeId;\n-use utils::{match_path, match_type, paths, span_lint};\n+use syntax::codemap::Span;\n+use syntax_pos::MultiSpan;\n+use utils::{match_path, match_type, paths, span_lint, span_lint_and_then};\n \n /// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless\n /// the references are mutable.\n@@ -44,13 +46,32 @@ declare_lint! {\n     \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n }\n \n+/// **What it does:** This lint checks for functions that take immutable references and return\n+/// mutable ones.\n+///\n+/// **Why is this bad?** This is trivially unsound, as one can create two mutable references\n+/// from the same (immutable!) source. This [error](https://github.com/rust-lang/rust/issues/39465)\n+/// actually lead to an interim Rust release 1.15.1.\n+///\n+/// **Known problems:** To be on the conservative side, if there's at least one mutable reference\n+/// with the output lifetime, this lint will not trigger. In practice, this case is unlikely anyway.\n+///\n+/// **Example:**\n+/// ```rust\n+/// fn foo(&Foo) -> &mut Bar { .. }\n+/// ```\n+declare_lint! {\n+    pub MUT_FROM_REF,\n+    Warn,\n+    \"fns that create mutable refs from immutable ref args\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct PointerPass;\n \n impl LintPass for PointerPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PTR_ARG, CMP_NULL)\n+        lint_array!(PTR_ARG, CMP_NULL, MUT_FROM_REF)\n     }\n }\n \n@@ -111,6 +132,37 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n             }\n         }\n     }\n+\n+    if let FunctionRetTy::Return(ref ty) = decl.output {\n+        if let Some((out, MutMutable, _)) = get_rptr_lm(ty) {\n+            let mut immutables = vec![];\n+            for (_, ref mutbl, ref argspan) in\n+                decl.inputs\n+                    .iter()\n+                    .filter_map(|ty| get_rptr_lm(ty))\n+                    .filter(|&(lt, _, _)| lt.name == out.name) {\n+                if *mutbl == MutMutable {\n+                    return;\n+                }\n+                immutables.push(*argspan);\n+            }\n+            if immutables.is_empty() {\n+                return;\n+            }\n+            span_lint_and_then(cx, MUT_FROM_REF, ty.span, \"mutable borrow from immutable input(s)\", |db| {\n+                let ms = MultiSpan::from_spans(immutables);\n+                db.span_note(ms, \"immutable borrow here\");\n+            });\n+        }\n+    }\n+}\n+\n+fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n+    if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n+        Some((lt, m.mutbl, ty.span))\n+    } else {\n+        None\n+    }\n }\n \n fn is_null_path(expr: &Expr) -> bool {"}, {"sha": "ac90528c60639bc7f3702f7417fc49424a41e48c", "filename": "src/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -1,7 +1,6 @@\n // error-pattern:yummy\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n-#![feature(static_in_const)]\n \n #![allow(unknown_lints, missing_docs_in_private_items)]\n "}, {"sha": "8ac7571c1b1f043740e350c9872e73a4429cd72d", "filename": "tests/ui/large_enum_variant.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.rs?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -8,46 +8,50 @@\n enum LargeEnum {\n     A(i32),\n     B([i32; 8000]),\n+}\n \n-\n+enum GenericEnumOk<T> {\n+    A(i32),\n+    B([T; 8000]),\n }\n \n-enum GenericEnum<T> {\n+enum GenericEnum2<T> {\n     A(i32),\n     B([i32; 8000]),\n-\n-\n-    C([T; 8000]),\n-    D(T, [i32; 8000]),\n-\n+    C(T, [i32; 8000]),\n }\n \n trait SomeTrait {\n     type Item;\n }\n \n enum LargeEnumGeneric<A: SomeTrait> {\n-    Var(A::Item), // regression test, this used to ICE\n+    Var(A::Item),\n }\n \n-enum AnotherLargeEnum {\n+enum LargeEnum2 {\n     VariantOk(i32, u32),\n     ContainingLargeEnum(LargeEnum),\n-\n-\n+}\n+enum LargeEnum3 {\n     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n-\n     VoidVariant,\n     StructLikeLittle { x: i32, y: i32 },\n-    StructLikeLarge { x: [i32; 8000], y: i32 },\n-\n-    StructLikeLarge2 {\n-        x:\n-        [i32; 8000]\n+}\n \n-    },\n+enum LargeEnum4 {\n+    VariantOk(i32, u32),\n+    StructLikeLarge { x: [i32; 8000], y: i32 },\n }\n \n-fn main() {\n+enum LargeEnum5 {\n+    VariantOk(i32, u32),\n+    StructLikeLarge2 { x: [i32; 8000] },\n+}\n \n+enum LargeEnumOk {\n+    LargeA([i32; 8000]),\n+    LargeB([i32; 8001]),\n }\n+\n+fn main() {}"}, {"sha": "84213003eb70d80036759c7891ef03105b073580", "filename": "tests/ui/large_enum_variant.stderr", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Flarge_enum_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Flarge_enum_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.stderr?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -1,4 +1,4 @@\n-error: large enum variant found\n+error: large size difference between variants\n   --> $DIR/large_enum_variant.rs:10:5\n    |\n 10 |     B([i32; 8000]),\n@@ -12,73 +12,59 @@ note: lint level defined here\n help: consider boxing the large fields to reduce the total size of the enum\n    |     B(Box<[i32; 8000]>),\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:17:5\n-   |\n-17 |     B([i32; 8000]),\n-   |     ^^^^^^^^^^^^^^\n-   |\n-help: consider boxing the large fields to reduce the total size of the enum\n-   |     B(Box<[i32; 8000]>),\n-\n-error: large enum variant found\n+error: large size difference between variants\n   --> $DIR/large_enum_variant.rs:21:5\n    |\n-21 |     D(T, [i32; 8000]),\n+21 |     C(T, [i32; 8000]),\n    |     ^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n   --> $DIR/large_enum_variant.rs:21:5\n    |\n-21 |     D(T, [i32; 8000]),\n+21 |     C(T, [i32; 8000]),\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:35:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:34:5\n    |\n-35 |     ContainingLargeEnum(LargeEnum),\n+34 |     ContainingLargeEnum(LargeEnum),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n    |     ContainingLargeEnum(Box<LargeEnum>),\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:38:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:37:5\n    |\n-38 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n+37 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n-  --> $DIR/large_enum_variant.rs:38:5\n+  --> $DIR/large_enum_variant.rs:37:5\n    |\n-38 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n+37 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:42:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:44:5\n    |\n-42 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n+44 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n-  --> $DIR/large_enum_variant.rs:42:5\n+  --> $DIR/large_enum_variant.rs:44:5\n    |\n-42 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n+44 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:44:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:49:5\n    |\n-44 |       StructLikeLarge2 {\n-   |  _____^ starting here...\n-45 | |         x:\n-46 | |         [i32; 8000]\n-47 | |\n-48 | |     },\n-   | |_____^ ...ending here\n+49 |     StructLikeLarge2 { x: [i32; 8000] },\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n-   |         Box<[i32; 8000]>\n+   |     StructLikeLarge2 { x: Box<[i32; 8000]> },\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "35bff9371d9e2fdb697184260ce0baee3f3abcbe", "filename": "tests/ui/mut_from_ref.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Fmut_from_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Fmut_from_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.rs?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -0,0 +1,48 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![allow(unused)]\n+#![deny(mut_from_ref)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn this_wont_hurt_a_bit(&self) -> &mut Foo {\n+        unimplemented!()\n+    }\n+}\n+\n+trait Ouch {\n+    fn ouch(x: &Foo) -> &mut Foo;\n+}\n+\n+impl Ouch for Foo {\n+    fn ouch(x: &Foo) -> &mut Foo {\n+        unimplemented!()\n+    }\n+}\n+\n+fn fail(x: &u32) -> &mut u16 {\n+    unimplemented!()\n+}\n+\n+fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n+    unimplemented!()\n+}\n+\n+fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n+    unimplemented!()\n+}\n+\n+// this is OK, because the result borrows y\n+fn works<'a>(x: &u32, y: &'a mut u32) -> &'a mut u32 {\n+    unimplemented!()\n+}\n+\n+// this is also OK, because the result could borrow y\n+fn also_works<'a>(x: &'a u32, y: &'a mut u32) -> &'a mut u32 {\n+    unimplemented!()\n+}\n+\n+fn main() {\n+    //TODO\n+}"}, {"sha": "5098d7d0ab562c573d11cf071cf6c09ed17c06c2", "filename": "tests/ui/mut_from_ref.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Fmut_from_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/637a4590f672998f1265eba1c68efa97f1675e79/tests%2Fui%2Fmut_from_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.stderr?ref=637a4590f672998f1265eba1c68efa97f1675e79", "patch": "@@ -0,0 +1,67 @@\n+error: mutable borrow from immutable input(s)\n+ --> $DIR/mut_from_ref.rs:9:39\n+  |\n+9 |     fn this_wont_hurt_a_bit(&self) -> &mut Foo {\n+  |                                       ^^^^^^^^\n+  |\n+note: lint level defined here\n+ --> $DIR/mut_from_ref.rs:4:9\n+  |\n+4 | #![deny(mut_from_ref)]\n+  |         ^^^^^^^^^^^^\n+note: immutable borrow here\n+ --> $DIR/mut_from_ref.rs:9:29\n+  |\n+9 |     fn this_wont_hurt_a_bit(&self) -> &mut Foo {\n+  |                             ^^^^^\n+\n+error: mutable borrow from immutable input(s)\n+  --> $DIR/mut_from_ref.rs:15:25\n+   |\n+15 |     fn ouch(x: &Foo) -> &mut Foo;\n+   |                         ^^^^^^^^\n+   |\n+note: immutable borrow here\n+  --> $DIR/mut_from_ref.rs:15:16\n+   |\n+15 |     fn ouch(x: &Foo) -> &mut Foo;\n+   |                ^^^^\n+\n+error: mutable borrow from immutable input(s)\n+  --> $DIR/mut_from_ref.rs:24:21\n+   |\n+24 | fn fail(x: &u32) -> &mut u16 {\n+   |                     ^^^^^^^^\n+   |\n+note: immutable borrow here\n+  --> $DIR/mut_from_ref.rs:24:12\n+   |\n+24 | fn fail(x: &u32) -> &mut u16 {\n+   |            ^^^^\n+\n+error: mutable borrow from immutable input(s)\n+  --> $DIR/mut_from_ref.rs:28:50\n+   |\n+28 | fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n+   |                                                  ^^^^^^^^^^^\n+   |\n+note: immutable borrow here\n+  --> $DIR/mut_from_ref.rs:28:25\n+   |\n+28 | fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n+   |                         ^^^^^^^\n+\n+error: mutable borrow from immutable input(s)\n+  --> $DIR/mut_from_ref.rs:32:67\n+   |\n+32 | fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n+   |                                                                   ^^^^^^^^^^^\n+   |\n+note: immutable borrow here\n+  --> $DIR/mut_from_ref.rs:32:27\n+   |\n+32 | fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n+   |                           ^^^^^^^     ^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}]}