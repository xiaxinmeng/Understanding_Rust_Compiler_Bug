{"sha": "4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMjYyNGNhYzkwZWU5MTQ1MTc1ZDZlNGI5YzU5YjlhYjc4NzVhOWM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-10-22T04:12:16Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-10-22T23:40:43Z"}, "message": "Fix Rustdoc ICE when checking blanket impls\n\nFixes #55001, #54744\n\nPreviously, SelectionContext would unconditionally cache the selection\nresult for an obligation. This worked fine for most users of\nSelectionContext, but it caused an issue when used by Rustdoc's blanket\nimpl finder.\n\nThe issue occured when SelectionContext chose a ParamCandidate which\ncontained inference variables. Since inference variables can change\nbetween calls to select(), it's not safe to cache the selection result -\nthe chosen candidate might not be applicable for future results, leading\nto an ICE when we try to run confirmation.\n\nThis commit prevents SelectionContext from caching any ParamCandidate\nthat contains inference variables. This should always be completely\nsafe, as trait selection should never depend on a particular result\nbeing cached.\n\nI've also added some extra debug!() statements, which I found helpful in\ntracking down this bug.", "tree": {"sha": "55d71dee6692252002f407575265b35560944a8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55d71dee6692252002f407575265b35560944a8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlvOX/0ACgkQtAh+UQ6Y\nsWRR2w//ZaQh2seZWYw7PF3yz/kTJ38cTkkiPgnGS2yztpjZPe9wMMEcCPfFzeTz\nT9ksk7frrElpMXS6Ka2UxQY+b5xtdul1Urf6c90t+GCM6JiKBEP1Amb5KHqn/COV\nJV5ZMtg529HZU5Ds0NWQjUaeb6zzMSy3KK47XK1ZADZIgu+sxIQfsLIfwvOz7A45\n0Jum5hUNCwGnr+SqPCUaX3OvTO4rejeonT5ipXCVmI7y8jtUMzt1YVL4/PKUACBR\nsbrixLclOnbdFt867rQJJ3tX1lai0iEr+5ioiUnGO/h0QtLGUBW5PTqZkVe52Qw0\nLUyttliqNNdXARwlt3SzVXEhCwWBnl63w0FLLLe5zFhM6YnNc9q/jRw9RDB6GdBe\nJUj2OzB2tEWpsiHvSach1J5peEWeIfpLD6rG159REST+OBSVZY4RXoh7cXbJlSkh\njznkXB0Wu5zm2P1LPE95xpikLTpufWiAWgYEOlt6oxFUfcJMuT9zvc2JvB49i8N2\ntQXgtjm8RG1tiHnJW0XTH3Zx1A28jHdJ907ge6ey8g5sEctkxbKDs86SLiZuXB1w\nM2jyOyFoubVHDtm3ZBEARjvSfXOUx1bZIEyLN0o2fjAwgRvD+GGuCYK8Mrq5sgr3\nJOkeWG/JBH7qul2xhZWtNQsT0/H5WOeooQxNKVamO6So7ZwOpxk=\n=6Wus\n-----END PGP SIGNATURE-----", "payload": "tree 55d71dee6692252002f407575265b35560944a8f\nparent ca2639e82ec4a18d7359efbfb555ea69dd644c97\nauthor Aaron Hill <aa1ronham@gmail.com> 1540181536 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1540251643 -0400\n\nFix Rustdoc ICE when checking blanket impls\n\nFixes #55001, #54744\n\nPreviously, SelectionContext would unconditionally cache the selection\nresult for an obligation. This worked fine for most users of\nSelectionContext, but it caused an issue when used by Rustdoc's blanket\nimpl finder.\n\nThe issue occured when SelectionContext chose a ParamCandidate which\ncontained inference variables. Since inference variables can change\nbetween calls to select(), it's not safe to cache the selection result -\nthe chosen candidate might not be applicable for future results, leading\nto an ICE when we try to run confirmation.\n\nThis commit prevents SelectionContext from caching any ParamCandidate\nthat contains inference variables. This should always be completely\nsafe, as trait selection should never depend on a particular result\nbeing cached.\n\nI've also added some extra debug!() statements, which I found helpful in\ntracking down this bug.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "html_url": "https://github.com/rust-lang/rust/commit/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca2639e82ec4a18d7359efbfb555ea69dd644c97", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2639e82ec4a18d7359efbfb555ea69dd644c97", "html_url": "https://github.com/rust-lang/rust/commit/ca2639e82ec4a18d7359efbfb555ea69dd644c97"}], "stats": {"total": 90, "additions": 87, "deletions": 3}, "files": [{"sha": "0ee03bc4c6e00902d0026a78e23b8be1c63a0a5d", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "patch": "@@ -251,6 +251,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n                   dir: RelationDir)\n                   -> RelateResult<'tcx, Generalization<'tcx>>\n     {\n+        debug!(\"generalize(ty={:?}, for_vid={:?}, dir={:?}\", ty, for_vid, dir);\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -273,8 +274,15 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n             root_ty: ty,\n         };\n \n-        let ty = generalize.relate(&ty, &ty)?;\n+        let ty = match generalize.relate(&ty, &ty) {\n+            Ok(ty) => ty,\n+            Err(e) => {\n+                debug!(\"generalize: failure {:?}\", e);\n+                return Err(e);\n+            }\n+        };\n         let needs_wf = generalize.needs_wf;\n+        debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n         Ok(Generalization { ty, needs_wf })\n     }\n }"}, {"sha": "c7b5ddb83410f6c969a0c088aad262c6d7d6ad3e", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "patch": "@@ -74,6 +74,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+\n+        debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n+\n         match (&a.sty, &b.sty) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);"}, {"sha": "3f4aa3a500d718e02410de685ea3f21be544edbd", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "patch": "@@ -1522,6 +1522,33 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map(|v| v.get(tcx))\n     }\n \n+    /// Determines whether can we safely cache the result\n+    /// of selecting an obligation. This is almost always 'true',\n+    /// except when dealing with certain ParamCandidates.\n+    ///\n+    /// Ordinarily, a ParamCandidate will contain no inference variables,\n+    /// since it was usually produced directly from a DefId. However,\n+    /// certain cases (currently only librustdoc's blanket impl finder),\n+    /// a ParamEnv may be explicitly constructed with inference types.\n+    /// When this is the case, we do *not* want to cache the resulting selection\n+    /// candidate. This is due to the fact that it might not always be possible\n+    /// to equate the obligation's trait ref and the candidate's trait ref,\n+    /// if more constraints end up getting added to an inference variable.\n+    ///\n+    /// Because of this, we always want to re-run the full selection\n+    /// process for our obligation the next time we see it, since\n+    /// we might end up picking a different SelectionCandidate (or none at all)\n+    fn can_cache_candidate(&self,\n+        result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>\n+     ) -> bool {\n+        match result {\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => {\n+                !trait_ref.skip_binder().input_types().any(|t| t.walk().any(|t_| t_.is_ty_infer()))\n+            },\n+            _ => true\n+        }\n+    }\n+\n     fn insert_candidate_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -1531,6 +1558,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         let trait_ref = cache_fresh_trait_pred.skip_binder().trait_ref;\n+\n+        if !self.can_cache_candidate(&candidate) {\n+            debug!(\"insert_candidate_cache(trait_ref={:?}, candidate={:?} -\\\n+                    candidate is not cacheable\", trait_ref, candidate);\n+            return;\n+\n+        }\n+\n         if self.can_use_global_caches(param_env) {\n             if let Err(Overflow) = candidate {\n                 // Don't cache overflow globally; we only produce this"}, {"sha": "57c7e2afd625e02c99cdfa530338327599c7f4e3", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "patch": "@@ -50,6 +50,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n         name: Option<String>,\n     ) -> Vec<Item>\n     where F: Fn(DefId) -> Def {\n+        debug!(\"get_blanket_impls(def_id={:?}, ...)\", def_id);\n         let mut impls = Vec::new();\n         if self.cx\n             .tcx\n@@ -78,6 +79,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n             }\n             self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n                 self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                    debug!(\"get_blanet_impls: Considering impl for trait '{:?}' {:?}\",\n+                           trait_def_id, impl_def_id);\n                     let t_generics = infcx.tcx.generics_of(impl_def_id);\n                     let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n                                              .expect(\"Cannot get impl trait\");\n@@ -104,8 +107,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n                         drop(obligations);\n \n                         debug!(\n-                            \"invoking predicate_may_hold: {:?}\",\n-                            trait_ref,\n+                            \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n+                             param_env, trait_ref, ty\n                         );\n                         let may_apply = match infcx.evaluate_obligation(\n                             &traits::Obligation::new(\n@@ -117,6 +120,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no\n                         };\n+                        debug!(\"get_blanket_impls: found applicable impl: {}\\\n+                               for trait_ref={:?}, ty={:?}\",\n+                               may_apply, trait_ref, ty);\n+\n                         if !may_apply {\n                             return\n                         }"}, {"sha": "f6c7f9a3d082c674d09b20d0b1ea54c824565981", "filename": "src/test/rustdoc/issue-55001.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Ftest%2Frustdoc%2Fissue-55001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2624cac90ee9145175d6e4b9c59b9ab7875a9c/src%2Ftest%2Frustdoc%2Fissue-55001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55001.rs?ref=4f2624cac90ee9145175d6e4b9c59b9ab7875a9c", "patch": "@@ -0,0 +1,31 @@\n+// Regression test for issue #55001. Previously, we would incorrectly\n+// cache certain trait selection results when checking for blanket impls,\n+// resulting in an ICE when we tried to confirm the cached ParamCandidate\n+// against an obligation.\n+\n+pub struct DefaultAllocator;\n+pub struct Standard;\n+pub struct Inner;\n+\n+pub trait Rand {}\n+\n+pub trait Distribution<T> {}\n+pub trait Allocator<N> {}\n+\n+impl<T> Rand for T where Standard: Distribution<T> {}\n+\n+impl<A> Distribution<Point<A>> for Standard\n+where\n+DefaultAllocator: Allocator<A>,\n+Standard: Distribution<A> {}\n+\n+impl Distribution<Inner> for Standard {}\n+\n+\n+pub struct Point<N>\n+where DefaultAllocator: Allocator<N>\n+{\n+    field: N\n+}\n+\n+fn main() {}"}]}