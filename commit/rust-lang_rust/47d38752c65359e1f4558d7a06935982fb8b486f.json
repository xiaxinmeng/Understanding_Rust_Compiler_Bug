{"sha": "47d38752c65359e1f4558d7a06935982fb8b486f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDM4NzUyYzY1MzU5ZTFmNDU1OGQ3YTA2OTM1OTgyZmI4YjQ4NmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-09T14:06:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-09T14:06:10Z"}, "message": "Auto merge of #86150 - cjgillot:notable, r=michaelwoerister\n\nDo not require the DefPathTable to construct the on-disk cache.\n\nr? `@michaelwoerister`", "tree": {"sha": "4870a8ac02664b82d7c397766b86e3d15043dbd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4870a8ac02664b82d7c397766b86e3d15043dbd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d38752c65359e1f4558d7a06935982fb8b486f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d38752c65359e1f4558d7a06935982fb8b486f", "html_url": "https://github.com/rust-lang/rust/commit/47d38752c65359e1f4558d7a06935982fb8b486f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d38752c65359e1f4558d7a06935982fb8b486f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38bc9b9933abee088d2416e28f0c2ef9a039e1b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/38bc9b9933abee088d2416e28f0c2ef9a039e1b9", "html_url": "https://github.com/rust-lang/rust/commit/38bc9b9933abee088d2416e28f0c2ef9a039e1b9"}, {"sha": "aeb050da9f672dcdf0ba665dac54f36385b9a986", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb050da9f672dcdf0ba665dac54f36385b9a986", "html_url": "https://github.com/rust-lang/rust/commit/aeb050da9f672dcdf0ba665dac54f36385b9a986"}], "stats": {"total": 53, "additions": 14, "deletions": 39}, "files": [{"sha": "753b8c85670ba5dd1e01f9f7ba6c5a57752149e9", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=47d38752c65359e1f4558d7a06935982fb8b486f", "patch": "@@ -94,15 +94,6 @@ impl DefPathTable {\n             .iter_enumerated()\n             .map(move |(index, key)| (index, key, &self.def_path_hashes[index]))\n     }\n-\n-    pub fn all_def_path_hashes_and_def_ids(\n-        &self,\n-        krate: CrateNum,\n-    ) -> impl Iterator<Item = (DefPathHash, DefId)> + '_ {\n-        self.def_path_hashes\n-            .iter_enumerated()\n-            .map(move |(index, hash)| (*hash, DefId { krate, index }))\n-    }\n }\n \n /// The definition table containing node definitions.\n@@ -440,6 +431,14 @@ impl Definitions {\n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n         self.def_id_to_hir_id.iter_enumerated().map(|(k, _)| k)\n     }\n+\n+    #[inline(always)]\n+    pub fn local_def_path_hash_to_def_id(&self, hash: DefPathHash) -> Option<LocalDefId> {\n+        self.table\n+            .def_path_hash_to_index\n+            .get(&hash)\n+            .map(|&local_def_index| LocalDefId { local_def_index })\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "8539cc693713952a356be917bf923b6bc909357f", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=47d38752c65359e1f4558d7a06935982fb8b486f", "patch": "@@ -1,7 +1,6 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::definitions::DefPathTable;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n@@ -196,10 +195,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n /// If we are not in incremental compilation mode, returns `None`.\n /// Otherwise, tries to load the query result cache from disk,\n /// creating an empty cache if it could not be loaded.\n-pub fn load_query_result_cache<'a>(\n-    sess: &'a Session,\n-    def_path_table: &DefPathTable,\n-) -> Option<OnDiskCache<'a>> {\n+pub fn load_query_result_cache<'a>(sess: &'a Session) -> Option<OnDiskCache<'a>> {\n     if sess.opts.incremental.is_none() {\n         return None;\n     }\n@@ -212,7 +208,7 @@ pub fn load_query_result_cache<'a>(\n         sess.is_nightly_build(),\n     ) {\n         LoadResult::Ok { data: (bytes, start_pos) } => {\n-            Some(OnDiskCache::new(sess, bytes, start_pos, def_path_table))\n+            Some(OnDiskCache::new(sess, bytes, start_pos))\n         }\n         _ => Some(OnDiskCache::new_empty(sess.source_map())),\n     }"}, {"sha": "cfe65c5372d2ff7506479335b145ea6fa84c15be", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=47d38752c65359e1f4558d7a06935982fb8b486f", "patch": "@@ -765,9 +765,7 @@ pub fn create_global_ctxt<'tcx>(\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n \n-    let def_path_table = resolver_outputs.definitions.def_path_table();\n-    let query_result_on_disk_cache =\n-        rustc_incremental::load_query_result_cache(sess, def_path_table);\n+    let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n     let codegen_backend = compiler.codegen_backend();\n     let mut local_providers = *DEFAULT_QUERY_PROVIDERS;"}, {"sha": "5c42625306bf3aa0296377605d92d516ec38890a", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d38752c65359e1f4558d7a06935982fb8b486f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=47d38752c65359e1f4558d7a06935982fb8b486f", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathHash, DefPathTable};\n+use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::QueryContext;\n@@ -27,7 +27,6 @@ use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, SourceFile, Span, DUMMY_SP};\n use std::collections::hash_map::Entry;\n-use std::iter::FromIterator;\n use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n@@ -103,12 +102,6 @@ pub struct OnDiskCache<'sess> {\n     // during the next compilation session.\n     latest_foreign_def_path_hashes: Lock<UnhashMap<DefPathHash, RawDefId>>,\n \n-    // Maps `DefPathHashes` to their corresponding `LocalDefId`s for all\n-    // local items in the current compilation session. This is only populated\n-    // when we are in incremental mode and have loaded a pre-existing cache\n-    // from disk, since this map is only used when deserializing a `DefPathHash`\n-    // from the incremental cache.\n-    local_def_path_hash_to_def_id: UnhashMap<DefPathHash, LocalDefId>,\n     // Caches all lookups of `DefPathHashes`, both for local and foreign\n     // definitions. A definition from the previous compilation session\n     // may no longer exist in the current compilation session, so\n@@ -168,12 +161,7 @@ crate struct RawDefId {\n \n impl<'sess> OnDiskCache<'sess> {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n-    pub fn new(\n-        sess: &'sess Session,\n-        data: Vec<u8>,\n-        start_pos: usize,\n-        def_path_table: &DefPathTable,\n-    ) -> Self {\n+    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n         // Wrap in a scope so we can borrow `data`.\n@@ -210,11 +198,6 @@ impl<'sess> OnDiskCache<'sess> {\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: footer.foreign_def_path_hashes,\n             latest_foreign_def_path_hashes: Default::default(),\n-            local_def_path_hash_to_def_id: UnhashMap::from_iter(\n-                def_path_table\n-                    .all_def_path_hashes_and_def_ids(LOCAL_CRATE)\n-                    .map(|(hash, def_id)| (hash, def_id.as_local().unwrap())),\n-            ),\n             def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n@@ -236,7 +219,6 @@ impl<'sess> OnDiskCache<'sess> {\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: Default::default(),\n             latest_foreign_def_path_hashes: Default::default(),\n-            local_def_path_hash_to_def_id: Default::default(),\n             def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n@@ -616,7 +598,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 debug!(\"def_path_hash_to_def_id({:?})\", hash);\n                 // Check if the `DefPathHash` corresponds to a definition in the current\n                 // crate\n-                if let Some(def_id) = self.local_def_path_hash_to_def_id.get(&hash).cloned() {\n+                if let Some(def_id) = tcx.definitions.local_def_path_hash_to_def_id(hash) {\n                     let def_id = def_id.to_def_id();\n                     e.insert(Some(def_id));\n                     return Some(def_id);"}]}