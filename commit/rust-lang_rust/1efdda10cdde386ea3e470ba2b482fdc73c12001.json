{"sha": "1efdda10cdde386ea3e470ba2b482fdc73c12001", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZmRkYTEwY2RkZTM4NmVhM2U0NzBiYTJiNDgyZmRjNzNjMTIwMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-07T01:41:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-07T01:41:14Z"}, "message": "Auto merge of #58125 - taiki-e:libsyntax-2018, r=Centril\n\nlibsyntax => 2018\n\nTransitions `libsyntax` to Rust 2018; cc #58099\n\nr? @Centril", "tree": {"sha": "5e6afa3b847faec789606ee039d1b2523c7ac357", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e6afa3b847faec789606ee039d1b2523c7ac357"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1efdda10cdde386ea3e470ba2b482fdc73c12001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1efdda10cdde386ea3e470ba2b482fdc73c12001", "html_url": "https://github.com/rust-lang/rust/commit/1efdda10cdde386ea3e470ba2b482fdc73c12001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1efdda10cdde386ea3e470ba2b482fdc73c12001/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff9158c1f8c5aee77b9b3b399c4adabeb3d0716c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9158c1f8c5aee77b9b3b399c4adabeb3d0716c", "html_url": "https://github.com/rust-lang/rust/commit/ff9158c1f8c5aee77b9b3b399c4adabeb3d0716c"}, {"sha": "7bb082d27fe472f52b103de0ae9fc6fa7e6546cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb082d27fe472f52b103de0ae9fc6fa7e6546cc", "html_url": "https://github.com/rust-lang/rust/commit/7bb082d27fe472f52b103de0ae9fc6fa7e6546cc"}], "stats": {"total": 1191, "additions": 617, "deletions": 574}, "files": [{"sha": "f1e60ba78b753cba474edb78c110e89cad0a12ae", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"syntax\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"syntax\""}, {"sha": "2cfe2cc896cb1e679f3a2dd71589988169b63f0c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,22 +1,23 @@\n // The Rust abstract syntax tree.\n \n-pub use self::GenericArgs::*;\n-pub use self::UnsafeSource::*;\n-pub use symbol::{Ident, Symbol as Name};\n-pub use util::parser::ExprPrecedence;\n-\n-use ext::hygiene::{Mark, SyntaxContext};\n-use print::pprust;\n-use ptr::P;\n+pub use GenericArgs::*;\n+pub use UnsafeSource::*;\n+pub use crate::symbol::{Ident, Symbol as Name};\n+pub use crate::util::parser::ExprPrecedence;\n+\n+use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::print::pprust;\n+use crate::ptr::P;\n+use crate::source_map::{dummy_spanned, respan, Spanned};\n+use crate::symbol::{keywords, Symbol};\n+use crate::tokenstream::TokenStream;\n+use crate::ThinVec;\n+\n use rustc_data_structures::indexed_vec::Idx;\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert;\n use rustc_target::spec::abi::Abi;\n-use source_map::{dummy_spanned, respan, Spanned};\n-use symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n-use tokenstream::TokenStream;\n-use ThinVec;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -31,7 +32,7 @@ pub struct Label {\n }\n \n impl fmt::Debug for Label {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"label({:?})\", self.ident)\n     }\n }\n@@ -43,7 +44,7 @@ pub struct Lifetime {\n }\n \n impl fmt::Debug for Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"lifetime({}: {})\",\n@@ -74,13 +75,13 @@ impl<'a> PartialEq<&'a str> for Path {\n }\n \n impl fmt::Debug for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"path({})\", pprust::path_to_string(self))\n     }\n }\n \n impl fmt::Display for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", pprust::path_to_string(self))\n     }\n }\n@@ -219,6 +220,7 @@ impl ParenthesizedArgs {\n // hack to ensure that we don't try to access the private parts of `NodeId` in this module\n mod node_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n+    use rustc_data_structures::newtype_index;\n     newtype_index! {\n         pub struct NodeId {\n             ENCODABLE = custom\n@@ -227,7 +229,7 @@ mod node_id_inner {\n     }\n }\n \n-pub use self::node_id_inner::NodeId;\n+pub use node_id_inner::NodeId;\n \n impl NodeId {\n     pub fn placeholder_from_mark(mark: Mark) -> Self {\n@@ -240,7 +242,7 @@ impl NodeId {\n }\n \n impl fmt::Display for NodeId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.as_u32(), f)\n     }\n }\n@@ -478,7 +480,7 @@ pub struct Pat {\n }\n \n impl fmt::Debug for Pat {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"pat({}: {})\", self.id, pprust::pat_to_string(self))\n     }\n }\n@@ -676,7 +678,7 @@ pub enum BinOpKind {\n \n impl BinOpKind {\n     pub fn to_string(&self) -> &'static str {\n-        use self::BinOpKind::*;\n+        use BinOpKind::*;\n         match *self {\n             Add => \"+\",\n             Sub => \"-\",\n@@ -713,7 +715,7 @@ impl BinOpKind {\n     }\n \n     pub fn is_comparison(&self) -> bool {\n-        use self::BinOpKind::*;\n+        use BinOpKind::*;\n         match *self {\n             Eq | Lt | Le | Ne | Gt | Ge => true,\n             And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr => false,\n@@ -792,7 +794,7 @@ impl Stmt {\n }\n \n impl fmt::Debug for Stmt {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"stmt({}: {})\",\n@@ -1030,7 +1032,7 @@ impl Expr {\n }\n \n impl fmt::Debug for Expr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n     }\n }\n@@ -1438,13 +1440,13 @@ pub enum IntTy {\n }\n \n impl fmt::Debug for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)\n     }\n }\n \n impl fmt::Display for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.ty_to_string())\n     }\n }\n@@ -1519,13 +1521,13 @@ impl UintTy {\n }\n \n impl fmt::Debug for UintTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)\n     }\n }\n \n impl fmt::Display for UintTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.ty_to_string())\n     }\n }\n@@ -1547,7 +1549,7 @@ pub struct Ty {\n }\n \n impl fmt::Debug for Ty {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"type({})\", pprust::ty_to_string(self))\n     }\n }\n@@ -1832,7 +1834,7 @@ pub enum Defaultness {\n }\n \n impl fmt::Display for Unsafety {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(\n             match *self {\n                 Unsafety::Normal => \"normal\",\n@@ -1852,7 +1854,7 @@ pub enum ImplPolarity {\n }\n \n impl fmt::Debug for ImplPolarity {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             ImplPolarity::Positive => \"positive\".fmt(f),\n             ImplPolarity::Negative => \"negative\".fmt(f),"}, {"sha": "6f7761b54fc29daf22b45aef5dbb87702b68f3e6", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,9 +1,10 @@\n //! Parsing and validation of builtin attributes\n \n-use ast::{self, Attribute, MetaItem, Name, NestedMetaItemKind};\n-use errors::{Applicability, Handler};\n-use feature_gate::{Features, GatedCfg};\n-use parse::ParseSess;\n+use crate::ast::{self, Attribute, MetaItem, Name, NestedMetaItemKind};\n+use crate::errors::{Applicability, Handler};\n+use crate::feature_gate::{Features, GatedCfg};\n+use crate::parse::ParseSess;\n+\n use syntax_pos::{symbol::Symbol, Span};\n \n use super::{list_contains_name, mark_used, MetaItemKind};\n@@ -188,7 +189,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                  -> Option<Stability>\n     where I: Iterator<Item = &'a Attribute>\n {\n-    use self::StabilityLevel::*;\n+    use StabilityLevel::*;\n \n     let mut stab: Option<Stability> = None;\n     let mut rustc_depr: Option<RustcDeprecation> = None;\n@@ -694,7 +695,7 @@ pub enum IntType {\n impl IntType {\n     #[inline]\n     pub fn is_signed(self) -> bool {\n-        use self::IntType::*;\n+        use IntType::*;\n \n         match self {\n             SignedInt(..) => true,\n@@ -711,7 +712,7 @@ impl IntType {\n /// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n /// concerns to the only non-ZST field.\n pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n-    use self::ReprAttr::*;\n+    use ReprAttr::*;\n \n     let mut acc = Vec::new();\n     let diagnostic = &sess.span_diagnostic;\n@@ -831,7 +832,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n }\n \n fn int_type_of_word(s: &str) -> Option<IntType> {\n-    use self::IntType::*;\n+    use IntType::*;\n \n     match s {\n         \"i8\" => Some(SignedInt(ast::IntTy::I8)),"}, {"sha": "0c3aedae71598d3b7fb11f5d3a5fac4a3f771ca4", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -2,31 +2,33 @@\n \n mod builtin;\n \n-pub use self::builtin::{\n+pub use builtin::{\n     cfg_matches, contains_feature_attr, eval_condition, find_crate_name, find_deprecation,\n     find_repr_attrs, find_stability, find_unwind_attr, Deprecation, InlineAttr, OptimizeAttr,\n     IntType, ReprAttr, RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n };\n-pub use self::IntType::*;\n-pub use self::ReprAttr::*;\n-pub use self::StabilityLevel::*;\n-\n-use ast;\n-use ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n-use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n-use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n-use mut_visit::visit_clobber;\n-use source_map::{BytePos, Spanned, respan, dummy_spanned};\n+pub use IntType::*;\n+pub use ReprAttr::*;\n+pub use StabilityLevel::*;\n+\n+use crate::ast;\n+use crate::ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n+use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use crate::ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n+use crate::mut_visit::visit_clobber;\n+use crate::source_map::{BytePos, Spanned, respan, dummy_spanned};\n+use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use crate::parse::parser::Parser;\n+use crate::parse::{self, ParseSess, PResult};\n+use crate::parse::token::{self, Token};\n+use crate::ptr::P;\n+use crate::symbol::Symbol;\n+use crate::ThinVec;\n+use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n+use crate::GLOBALS;\n+\n+use log::debug;\n use syntax_pos::{FileName, Span};\n-use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::parser::Parser;\n-use parse::{self, ParseSess, PResult};\n-use parse::token::{self, Token};\n-use ptr::P;\n-use symbol::Symbol;\n-use ThinVec;\n-use tokenstream::{TokenStream, TokenTree, DelimSpan};\n-use GLOBALS;\n \n use std::iter;\n use std::ops::DerefMut;"}, {"sha": "bfc4457f0547f10ac7c919e5cb78d1cbf5769bef", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,20 +1,21 @@\n-use attr::HasAttrs;\n-use feature_gate::{\n+use crate::attr::HasAttrs;\n+use crate::feature_gate::{\n     feature_err,\n     EXPLAIN_STMT_ATTR_SYNTAX,\n     Features,\n     get_features,\n     GateIssue,\n };\n-use attr;\n-use ast;\n-use edition::Edition;\n-use errors::Applicability;\n-use mut_visit::*;\n-use parse::{token, ParseSess};\n-use ptr::P;\n+use crate::attr;\n+use crate::ast;\n+use crate::edition::Edition;\n+use crate::errors::Applicability;\n+use crate::mut_visit::*;\n+use crate::parse::{token, ParseSess};\n+use crate::ptr::P;\n+use crate::util::map_in_place::MapInPlace;\n+\n use smallvec::SmallVec;\n-use util::map_in_place::MapInPlace;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {"}, {"sha": "3abb820a6789fd1d0a4489b08eea0d203852dacc", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -12,8 +12,9 @@ use std::error::Error;\n use rustc_serialize::json::as_json;\n \n use syntax_pos::{Span, FileName};\n-use ext::base::ExtCtxt;\n-use diagnostics::plugin::{ErrorMap, ErrorInfo};\n+\n+use crate::ext::base::ExtCtxt;\n+use crate::diagnostics::plugin::{ErrorMap, ErrorInfo};\n \n /// JSON encodable/decodable version of `ErrorInfo`.\n #[derive(PartialEq, RustcDecodable, RustcEncodable)]\n@@ -34,7 +35,7 @@ pub struct ErrorLocation {\n \n impl ErrorLocation {\n     /// Create an error location from a span.\n-    pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation {\n+    pub fn from_span(ecx: &ExtCtxt<'_>, sp: Span) -> ErrorLocation {\n         let loc = ecx.source_map().lookup_char_pos_adj(sp.lo());\n         ErrorLocation {\n             filename: loc.filename,\n@@ -62,7 +63,7 @@ fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf {\n ///\n /// For our current purposes the prefix is the target architecture and the name is a crate name.\n /// If an error occurs steps will be taken to ensure that no file is created.\n-pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorMap)\n+pub fn output_metadata(ecx: &ExtCtxt<'_>, prefix: &str, name: &str, err_map: &ErrorMap)\n     -> Result<(), Box<dyn Error>>\n {\n     // Create the directory to place the file in."}, {"sha": "e79378d93bd1de2fa361ba3d0571fa036382fb4d", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,20 +1,21 @@\n use std::collections::BTreeMap;\n use std::env;\n \n-use ast;\n-use ast::{Ident, Name};\n-use source_map;\n+use crate::ast::{self, Ident, Name};\n+use crate::source_map;\n+use crate::ext::base::{ExtCtxt, MacEager, MacResult};\n+use crate::ext::build::AstBuilder;\n+use crate::parse::token;\n+use crate::ptr::P;\n+use crate::symbol::{keywords, Symbol};\n+use crate::tokenstream::{TokenTree};\n+\n+use smallvec::smallvec;\n use syntax_pos::Span;\n-use ext::base::{ExtCtxt, MacEager, MacResult};\n-use ext::build::AstBuilder;\n-use parse::token;\n-use ptr::P;\n-use symbol::{keywords, Symbol};\n-use tokenstream::{TokenTree};\n \n-use diagnostics::metadata::output_metadata;\n+use crate::diagnostics::metadata::output_metadata;\n \n-pub use errors::*;\n+pub use crate::errors::*;\n \n // Maximum width of any line in an extended error description (inclusive).\n const MAX_DESCRIPTION_WIDTH: usize = 80;\n@@ -28,7 +29,7 @@ pub struct ErrorInfo {\n /// Mapping from error codes to metadata.\n pub type ErrorMap = BTreeMap<Name, ErrorInfo>;\n \n-pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n+pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n                                    -> Box<dyn MacResult+'cx> {\n@@ -61,7 +62,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n     MacEager::expr(ecx.expr_tuple(span, Vec::new()))\n }\n \n-pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n+pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n                                        -> Box<dyn MacResult+'cx> {\n@@ -134,7 +135,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n }\n \n #[allow(deprecated)]\n-pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n+pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n                                           -> Box<dyn MacResult+'cx> {"}, {"sha": "977e6d4587709be238c9b86080c42c7ee20e54d2", "filename": "src/libsyntax/early_buffered_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fearly_buffered_lints.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -3,7 +3,7 @@\n //! Since we cannot have a dependency on `librustc`, we implement some types here that are somewhat\n //! redundant. Later, these types can be converted to types for use by the rest of the compiler.\n \n-use syntax::ast::NodeId;\n+use crate::syntax::ast::NodeId;\n use syntax_pos::MultiSpan;\n \n /// Since we cannot import `LintId`s from `rustc::lint`, we define some Ids here which can later be"}, {"sha": "09e26e29d86a81857a2092fa1b3407ae0b876711", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,5 +1,5 @@\n-use attr;\n-use ast::{Item, ItemKind};\n+use crate::attr;\n+use crate::ast::{Item, ItemKind};\n \n pub enum EntryPointType {\n     None,"}, {"sha": "465b53184dcd704a91ea896e75da4ad69e940a3f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,28 +1,29 @@\n-pub use self::SyntaxExtension::*;\n-\n-use ast::{self, Attribute, Name, PatKind, MetaItem};\n-use attr::HasAttrs;\n-use source_map::{SourceMap, Spanned, respan};\n+pub use SyntaxExtension::*;\n+\n+use crate::ast::{self, Attribute, Name, PatKind, MetaItem};\n+use crate::attr::HasAttrs;\n+use crate::source_map::{SourceMap, Spanned, respan};\n+use crate::edition::Edition;\n+use crate::errors::{DiagnosticBuilder, DiagnosticId};\n+use crate::ext::expand::{self, AstFragment, Invocation};\n+use crate::ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n+use crate::mut_visit::{self, MutVisitor};\n+use crate::parse::{self, parser, DirectoryOwnership};\n+use crate::parse::token;\n+use crate::ptr::P;\n+use crate::symbol::{keywords, Ident, Symbol};\n+use crate::ThinVec;\n+use crate::tokenstream::{self, TokenStream};\n+\n+use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n-use edition::Edition;\n-use errors::{DiagnosticBuilder, DiagnosticId};\n-use ext::expand::{self, AstFragment, Invocation};\n-use ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n-use mut_visit::{self, MutVisitor};\n-use parse::{self, parser, DirectoryOwnership};\n-use parse::token;\n-use ptr::P;\n-use smallvec::SmallVec;\n-use symbol::{keywords, Ident, Symbol};\n-use ThinVec;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{self, Lrc};\n use std::iter;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use rustc_data_structures::sync::{self, Lrc};\n use std::default::Default;\n-use tokenstream::{self, TokenStream};\n \n \n #[derive(Debug,Clone)]\n@@ -139,18 +140,18 @@ impl Annotatable {\n // A more flexible ItemDecorator.\n pub trait MultiItemDecorator {\n     fn expand(&self,\n-              ecx: &mut ExtCtxt,\n+              ecx: &mut ExtCtxt<'_>,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &Annotatable,\n               push: &mut dyn FnMut(Annotatable));\n }\n \n impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n+    where F : Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n {\n     fn expand(&self,\n-              ecx: &mut ExtCtxt,\n+              ecx: &mut ExtCtxt<'_>,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &Annotatable,\n@@ -163,19 +164,19 @@ impl<F> MultiItemDecorator for F\n // FIXME Decorators should follow the same pattern too.\n pub trait MultiItemModifier {\n     fn expand(&self,\n-              ecx: &mut ExtCtxt,\n+              ecx: &mut ExtCtxt<'_>,\n               span: Span,\n               meta_item: &ast::MetaItem,\n               item: Annotatable)\n               -> Vec<Annotatable>;\n }\n \n impl<F, T> MultiItemModifier for F\n-    where F: Fn(&mut ExtCtxt, Span, &ast::MetaItem, Annotatable) -> T,\n+    where F: Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, Annotatable) -> T,\n           T: Into<Vec<Annotatable>>,\n {\n     fn expand(&self,\n-              ecx: &mut ExtCtxt,\n+              ecx: &mut ExtCtxt<'_>,\n               span: Span,\n               meta_item: &ast::MetaItem,\n               item: Annotatable)\n@@ -192,7 +193,7 @@ impl Into<Vec<Annotatable>> for Annotatable {\n \n pub trait ProcMacro {\n     fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n                    span: Span,\n                    ts: TokenStream)\n                    -> TokenStream;\n@@ -202,7 +203,7 @@ impl<F> ProcMacro for F\n     where F: Fn(TokenStream) -> TokenStream\n {\n     fn expand<'cx>(&self,\n-                   _ecx: &'cx mut ExtCtxt,\n+                   _ecx: &'cx mut ExtCtxt<'_>,\n                    _span: Span,\n                    ts: TokenStream)\n                    -> TokenStream {\n@@ -213,7 +214,7 @@ impl<F> ProcMacro for F\n \n pub trait AttrProcMacro {\n     fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n                    span: Span,\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n@@ -224,7 +225,7 @@ impl<F> AttrProcMacro for F\n     where F: Fn(TokenStream, TokenStream) -> TokenStream\n {\n     fn expand<'cx>(&self,\n-                   _ecx: &'cx mut ExtCtxt,\n+                   _ecx: &'cx mut ExtCtxt<'_>,\n                    _span: Span,\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n@@ -238,24 +239,24 @@ impl<F> AttrProcMacro for F\n pub trait TTMacroExpander {\n     fn expand<'cx>(\n         &self,\n-        ecx: &'cx mut ExtCtxt,\n+        ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n         input: TokenStream,\n         def_span: Option<Span>,\n     ) -> Box<dyn MacResult+'cx>;\n }\n \n pub type MacroExpanderFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n+    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, &[tokenstream::TokenTree])\n                 -> Box<dyn MacResult+'cx>;\n \n impl<F> TTMacroExpander for F\n-    where F: for<'cx> Fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n+    where F: for<'cx> Fn(&'cx mut ExtCtxt<'_>, Span, &[tokenstream::TokenTree])\n     -> Box<dyn MacResult+'cx>\n {\n     fn expand<'cx>(\n         &self,\n-        ecx: &'cx mut ExtCtxt,\n+        ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n         input: TokenStream,\n         _def_span: Option<Span>,\n@@ -286,23 +287,23 @@ impl<F> TTMacroExpander for F\n \n pub trait IdentMacroExpander {\n     fn expand<'cx>(&self,\n-                   cx: &'cx mut ExtCtxt,\n+                   cx: &'cx mut ExtCtxt<'_>,\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<tokenstream::TokenTree>)\n                    -> Box<dyn MacResult+'cx>;\n }\n \n pub type IdentMacroExpanderFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n+    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n                 -> Box<dyn MacResult+'cx>;\n \n impl<F> IdentMacroExpander for F\n-    where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, ast::Ident,\n+    where F : for<'cx> Fn(&'cx mut ExtCtxt<'_>, Span, ast::Ident,\n                           Vec<tokenstream::TokenTree>) -> Box<dyn MacResult+'cx>\n {\n     fn expand<'cx>(&self,\n-                   cx: &'cx mut ExtCtxt,\n+                   cx: &'cx mut ExtCtxt<'_>,\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<tokenstream::TokenTree>)\n@@ -567,7 +568,7 @@ impl MacResult for DummyResult {\n }\n \n pub type BuiltinDeriveFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n+    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n \n /// Represents different kinds of macro invocations that can be resolved.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -979,7 +980,7 @@ impl<'a> ExtCtxt<'a> {\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string<'a>(\n-    cx: &'a mut ExtCtxt,\n+    cx: &'a mut ExtCtxt<'_>,\n     mut expr: P<ast::Expr>,\n     err_msg: &str,\n ) -> Result<Spanned<(Symbol, ast::StrStyle)>, Option<DiagnosticBuilder<'a>>> {\n@@ -998,7 +999,7 @@ pub fn expr_to_spanned_string<'a>(\n     })\n }\n \n-pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+pub fn expr_to_string(cx: &mut ExtCtxt<'_>, expr: P<ast::Expr>, err_msg: &str)\n                       -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg)\n         .map_err(|err| err.map(|mut err| err.emit()))\n@@ -1011,7 +1012,7 @@ pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n /// compilation should call\n /// `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\n /// done as rarely as possible).\n-pub fn check_zero_tts(cx: &ExtCtxt,\n+pub fn check_zero_tts(cx: &ExtCtxt<'_>,\n                       sp: Span,\n                       tts: &[tokenstream::TokenTree],\n                       name: &str) {\n@@ -1022,7 +1023,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n \n /// Interpreting `tts` as a comma-separated sequence of expressions,\n /// expect exactly one string literal, or emit an error and return None.\n-pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n+pub fn get_single_str_from_tts(cx: &mut ExtCtxt<'_>,\n                                sp: Span,\n                                tts: &[tokenstream::TokenTree],\n                                name: &str)\n@@ -1045,7 +1046,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n \n /// Extract comma-separated expressions from `tts`. If there is a\n /// parsing error, emit a non-fatal error and return None.\n-pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n+pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>,\n                           sp: Span,\n                           tts: &[tokenstream::TokenTree]) -> Option<Vec<P<ast::Expr>>> {\n     let mut p = cx.new_parser_from_tts(tts);"}, {"sha": "1e83f6c03ec3097664fbd219001b8b2caf7a32a8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,17 +1,18 @@\n+use crate::ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n+use crate::attr;\n+use crate::source_map::{dummy_spanned, respan, Spanned};\n+use crate::ext::base::ExtCtxt;\n+use crate::ptr::P;\n+use crate::symbol::{Symbol, keywords};\n+use crate::ThinVec;\n+\n use rustc_target::spec::abi::Abi;\n-use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n-use attr;\n use syntax_pos::{Pos, Span, DUMMY_SP};\n-use source_map::{dummy_spanned, respan, Spanned};\n-use ext::base::ExtCtxt;\n-use ptr::P;\n-use symbol::{Symbol, keywords};\n-use ThinVec;\n \n // Transitional re-exports so qquote can find the paths it is looking for\n mod syntax {\n-    pub use ext;\n-    pub use parse;\n+    pub use crate::ext;\n+    pub use crate::parse;\n }\n \n pub trait AstBuilder {"}, {"sha": "50cec9e7908c1ca2807d42778c63139dda8a8a81", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,15 +1,16 @@\n-use attr::HasAttrs;\n-use ast;\n-use source_map::{hygiene, ExpnInfo, ExpnFormat};\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use parse::parser::PathStyle;\n-use symbol::Symbol;\n+use crate::attr::HasAttrs;\n+use crate::ast;\n+use crate::source_map::{hygiene, ExpnInfo, ExpnFormat};\n+use crate::ext::base::ExtCtxt;\n+use crate::ext::build::AstBuilder;\n+use crate::parse::parser::PathStyle;\n+use crate::symbol::Symbol;\n+\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashSet;\n \n-pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n+pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n         if attr.path != \"derive\" {\n@@ -40,7 +41,7 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n     result\n }\n \n-pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path], item: &mut T)\n+pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T)\n     where T: HasAttrs,\n {\n     let (mut names, mut pretty_name) = (FxHashSet::default(), \"derive(\".to_owned());"}, {"sha": "89d59478a5df1837da80beef43e76b7d1edddf08", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,27 +1,28 @@\n-use ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n-use ast::{MacStmtStyle, StmtKind, ItemKind};\n-use attr::{self, HasAttrs};\n-use source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n-use config::StripUnconfigured;\n-use errors::{Applicability, FatalError};\n-use ext::base::*;\n-use ext::derive::{add_derived_markers, collect_derives};\n-use ext::hygiene::{self, Mark, SyntaxContext};\n-use ext::placeholders::{placeholder, PlaceholderExpander};\n-use feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n-use mut_visit::*;\n-use parse::{DirectoryOwnership, PResult, ParseSess};\n-use parse::token::{self, Token};\n-use parse::parser::Parser;\n-use ptr::P;\n-use smallvec::SmallVec;\n-use symbol::Symbol;\n-use symbol::keywords;\n+use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n+use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n+use crate::attr::{self, HasAttrs};\n+use crate::source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use crate::config::StripUnconfigured;\n+use crate::errors::{Applicability, FatalError};\n+use crate::ext::base::*;\n+use crate::ext::derive::{add_derived_markers, collect_derives};\n+use crate::ext::hygiene::{self, Mark, SyntaxContext};\n+use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n+use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n+use crate::mut_visit::*;\n+use crate::parse::{DirectoryOwnership, PResult, ParseSess};\n+use crate::parse::token::{self, Token};\n+use crate::parse::parser::Parser;\n+use crate::ptr::P;\n+use crate::symbol::Symbol;\n+use crate::symbol::keywords;\n+use crate::tokenstream::{TokenStream, TokenTree};\n+use crate::visit::{self, Visitor};\n+use crate::util::map_in_place::MapInPlace;\n+\n+use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, DUMMY_SP, FileName};\n use syntax_pos::hygiene::ExpnFormat;\n-use tokenstream::{TokenStream, TokenTree};\n-use visit::{self, Visitor};\n-use util::map_in_place::MapInPlace;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::fs;\n@@ -129,8 +130,8 @@ macro_rules! ast_fragments {\n             })*)*\n         }\n \n-        impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n-            $(fn $make_ast(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n+        impl<'a> MacResult for crate::ext::tt::macro_rules::ParserAnyMacro<'a> {\n+            $(fn $make_ast(self: Box<crate::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n                            -> Option<$AstTy> {\n                 Some(self.make(AstFragmentKind::$Kind).$make_ast())\n             })*"}, {"sha": "3e60dd81a3bc81ce7d84c01fbd18f64d158325b1", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,14 +1,15 @@\n-use ast::{self, NodeId};\n-use source_map::{DUMMY_SP, dummy_spanned};\n-use ext::base::ExtCtxt;\n-use ext::expand::{AstFragment, AstFragmentKind};\n-use ext::hygiene::Mark;\n-use tokenstream::TokenStream;\n-use mut_visit::*;\n-use ptr::P;\n-use smallvec::SmallVec;\n-use symbol::keywords;\n-use ThinVec;\n+use crate::ast::{self, NodeId};\n+use crate::source_map::{DUMMY_SP, dummy_spanned};\n+use crate::ext::base::ExtCtxt;\n+use crate::ext::expand::{AstFragment, AstFragmentKind};\n+use crate::ext::hygiene::Mark;\n+use crate::tokenstream::TokenStream;\n+use crate::mut_visit::*;\n+use crate::ptr::P;\n+use crate::symbol::keywords;\n+use crate::ThinVec;\n+\n+use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n "}, {"sha": "31a134b856d822613465d8bceb62b7acaacac6ac", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,15 +1,14 @@\n-use ast;\n-use syntax_pos::{self, Pos, Span, FileName};\n-use ext::base::*;\n-use ext::base;\n-use ext::build::AstBuilder;\n-use parse::{token, DirectoryOwnership};\n-use parse;\n-use print::pprust;\n-use ptr::P;\n+use crate::ast;\n+use crate::ext::base::{self, *};\n+use crate::ext::build::AstBuilder;\n+use crate::parse::{self, token, DirectoryOwnership};\n+use crate::print::pprust;\n+use crate::ptr::P;\n+use crate::symbol::Symbol;\n+use crate::tokenstream;\n+\n use smallvec::SmallVec;\n-use symbol::Symbol;\n-use tokenstream;\n+use syntax_pos::{self, Pos, Span, FileName};\n \n use std::fs;\n use std::io::ErrorKind;\n@@ -21,7 +20,7 @@ use rustc_data_structures::sync::Lrc;\n // a given file into the current one.\n \n /// line!(): expands to the current line number\n-pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_line(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -32,7 +31,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n }\n \n /* column!(): expands to the current column number */\n-pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_column(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n@@ -43,7 +42,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n }\n \n /* __rust_unstable_column!(): expands to the current column number */\n-pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_column_gated(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<dyn base::MacResult+'static> {\n     if sp.allows_unstable() {\n         expand_column(cx, sp, tts)\n@@ -55,7 +54,7 @@ pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n /// file!(): expands to the current filename */\n /// The source_file (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted.\n-pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_file(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -64,13 +63,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name.to_string())))\n }\n \n-pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_stringify(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                         -> Box<dyn base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n-pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_mod(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let mod_path = &cx.current_expansion.module.mod_path;\n@@ -82,7 +81,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n /// include! : parse the given file as an expr\n /// This is generally a bad idea because it's going to behave\n /// unhygienically.\n-pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                            -> Box<dyn base::MacResult+'cx> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n@@ -120,7 +119,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                           -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n@@ -148,7 +147,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n     }\n }\n \n-pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                             -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n@@ -178,7 +177,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: String) -> PathBuf {\n+fn res_rel_file(cx: &mut ExtCtxt<'_>, sp: syntax_pos::Span, arg: String) -> PathBuf {\n     let arg = PathBuf::from(arg);\n     // Relative paths are resolved relative to the file in which they are found\n     // after macro expansion (that is, they are unhygienic)."}, {"sha": "a9000b89fb48ea6c1d49ee53ed110222ea6e459d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -70,21 +70,22 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n-pub use self::NamedMatch::*;\n-pub use self::ParseResult::*;\n-use self::TokenTreeOrTokenTreeSlice::*;\n-\n-use ast::Ident;\n+pub use NamedMatch::*;\n+pub use ParseResult::*;\n+use TokenTreeOrTokenTreeSlice::*;\n+\n+use crate::ast::Ident;\n+use crate::errors::FatalError;\n+use crate::ext::tt::quoted::{self, TokenTree};\n+use crate::parse::{Directory, ParseSess};\n+use crate::parse::parser::{Parser, PathStyle};\n+use crate::parse::token::{self, DocComment, Nonterminal, Token};\n+use crate::print::pprust;\n+use crate::symbol::keywords;\n+use crate::tokenstream::{DelimSpan, TokenStream};\n+\n+use smallvec::{smallvec, SmallVec};\n use syntax_pos::{self, Span};\n-use errors::FatalError;\n-use ext::tt::quoted::{self, TokenTree};\n-use parse::{Directory, ParseSess};\n-use parse::parser::{Parser, PathStyle};\n-use parse::token::{self, DocComment, Nonterminal, Token};\n-use print::pprust;\n-use smallvec::SmallVec;\n-use symbol::keywords;\n-use tokenstream::{DelimSpan, TokenStream};\n \n use rustc_data_structures::fx::FxHashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -649,7 +650,7 @@ pub fn parse(\n     sess: &ParseSess,\n     tts: TokenStream,\n     ms: &[TokenTree],\n-    directory: Option<Directory>,\n+    directory: Option<Directory<'_>>,\n     recurse_into_modules: bool,\n ) -> NamedParseResult {\n     // Create a parser that can be used for the \"black box\" parts."}, {"sha": "b3ecaeaedbb7ace2fd75875676bf40789df0ed6d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,29 +1,31 @@\n-use {ast, attr};\n+use crate::{ast, attr};\n+use crate::edition::Edition;\n+use crate::errors::FatalError;\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n+use crate::ext::base::{NormalTT, TTMacroExpander};\n+use crate::ext::expand::{AstFragment, AstFragmentKind};\n+use crate::ext::tt::macro_parser::{Success, Error, Failure};\n+use crate::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n+use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n+use crate::ext::tt::quoted;\n+use crate::ext::tt::transcribe::transcribe;\n+use crate::feature_gate::Features;\n+use crate::parse::{Directory, ParseSess};\n+use crate::parse::parser::Parser;\n+use crate::parse::token::{self, NtTT};\n+use crate::parse::token::Token::*;\n+use crate::symbol::Symbol;\n+use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+\n use syntax_pos::{Span, DUMMY_SP};\n-use edition::Edition;\n-use errors::FatalError;\n-use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n-use ext::base::{NormalTT, TTMacroExpander};\n-use ext::expand::{AstFragment, AstFragmentKind};\n-use ext::tt::macro_parser::{Success, Error, Failure};\n-use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n-use ext::tt::macro_parser::{parse, parse_failure_msg};\n-use ext::tt::quoted;\n-use ext::tt::transcribe::transcribe;\n-use feature_gate::Features;\n-use parse::{Directory, ParseSess};\n-use parse::parser::Parser;\n-use parse::token::{self, NtTT};\n-use parse::token::Token::*;\n-use symbol::Symbol;\n-use tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use log::debug;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n \n use rustc_data_structures::sync::Lrc;\n-use errors::Applicability;\n+use crate::errors::Applicability;\n \n const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n     `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, `literal`, \\\n@@ -91,7 +93,7 @@ struct MacroRulesMacroExpander {\n impl TTMacroExpander for MacroRulesMacroExpander {\n     fn expand<'cx>(\n         &self,\n-        cx: &'cx mut ExtCtxt,\n+        cx: &'cx mut ExtCtxt<'_>,\n         sp: Span,\n         input: TokenStream,\n         def_span: Option<Span>,\n@@ -109,13 +111,13 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n-fn trace_macros_note(cx: &mut ExtCtxt, sp: Span, message: String) {\n+fn trace_macros_note(cx: &mut ExtCtxt<'_>, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n     cx.expansions.entry(sp).or_default().push(message);\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n-fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n+fn generic_extension<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                           sp: Span,\n                           def_span: Option<Span>,\n                           name: ast::Ident,\n@@ -423,7 +425,7 @@ fn check_lhs_nt_follows(sess: &ParseSess,\n /// Check that the lhs contains no repetition which could match an empty token\n /// tree, because then the matcher would hang indefinitely.\n fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n-    use self::quoted::TokenTree;\n+    use quoted::TokenTree;\n     for tt in tts {\n         match *tt {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => (),\n@@ -497,7 +499,7 @@ struct FirstSets {\n \n impl FirstSets {\n     fn new(tts: &[quoted::TokenTree]) -> FirstSets {\n-        use self::quoted::TokenTree;\n+        use quoted::TokenTree;\n \n         let mut sets = FirstSets { first: FxHashMap::default() };\n         build_recur(&mut sets, tts);\n@@ -567,7 +569,7 @@ impl FirstSets {\n     // walks forward over `tts` until all potential FIRST tokens are\n     // identified.\n     fn first(&self, tts: &[quoted::TokenTree]) -> TokenSet {\n-        use self::quoted::TokenTree;\n+        use quoted::TokenTree;\n \n         let mut first = TokenSet::empty();\n         for tt in tts.iter() {\n@@ -721,7 +723,7 @@ fn check_matcher_core(sess: &ParseSess,\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n-    use self::quoted::TokenTree;\n+    use quoted::TokenTree;\n \n     let mut last = TokenSet::empty();\n \n@@ -940,7 +942,7 @@ enum IsInFollow {\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n-    use self::quoted::TokenTree;\n+    use quoted::TokenTree;\n \n     if let TokenTree::Token(_, token::CloseDelim(_)) = *tok {\n         // closing a token tree can never be matched by any fragment;\n@@ -1072,7 +1074,7 @@ fn is_legal_fragment_specifier(_sess: &ParseSess,\n \n fn quoted_tt_to_string(tt: &quoted::TokenTree) -> String {\n     match *tt {\n-        quoted::TokenTree::Token(_, ref tok) => ::print::pprust::token_to_string(tok),\n+        quoted::TokenTree::Token(_, ref tok) => crate::print::pprust::token_to_string(tok),\n         quoted::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n         quoted::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n         _ => panic!(\"unexpected quoted::TokenTree::{{Sequence or Delimited}} \\"}, {"sha": "6c3cf3e63121db2642c9facca1e2261704bc44a1", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,13 +1,14 @@\n-use ast::NodeId;\n-use early_buffered_lints::BufferedEarlyLintId;\n-use ext::tt::macro_parser;\n-use feature_gate::Features;\n-use parse::{token, ParseSess};\n-use print::pprust;\n-use symbol::keywords;\n+use crate::ast::NodeId;\n+use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::ext::tt::macro_parser;\n+use crate::feature_gate::Features;\n+use crate::parse::{token, ParseSess};\n+use crate::print::pprust;\n+use crate::tokenstream::{self, DelimSpan};\n+use crate::ast;\n+use crate::symbol::keywords;\n+\n use syntax_pos::{edition::Edition, BytePos, Span};\n-use tokenstream::{self, DelimSpan};\n-use ast;\n \n use rustc_data_structures::sync::Lrc;\n use std::iter::Peekable;"}, {"sha": "b9a50cc6488dde0b424093fa79689be2f38b2d3f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,13 +1,14 @@\n-use ast::Ident;\n-use ext::base::ExtCtxt;\n-use ext::expand::Marker;\n-use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n-use ext::tt::quoted;\n-use mut_visit::noop_visit_tt;\n-use parse::token::{self, Token, NtTT};\n-use smallvec::SmallVec;\n+use crate::ast::Ident;\n+use crate::ext::base::ExtCtxt;\n+use crate::ext::expand::Marker;\n+use crate::ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use crate::ext::tt::quoted;\n+use crate::mut_visit::noop_visit_tt;\n+use crate::parse::token::{self, Token, NtTT};\n+use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+\n+use smallvec::{smallvec, SmallVec};\n use syntax_pos::DUMMY_SP;\n-use tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -56,7 +57,7 @@ impl Iterator for Frame {\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::{Sequence, MetaVar, MetaVarDecl}`s, `interp` can\n /// (and should) be None.\n-pub fn transcribe(cx: &ExtCtxt,\n+pub fn transcribe(cx: &ExtCtxt<'_>,\n                   interp: Option<FxHashMap<Ident, Rc<NamedMatch>>>,\n                   src: Vec<quoted::TokenTree>)\n                   -> TokenStream {\n@@ -230,7 +231,7 @@ fn lockstep_iter_size(tree: &quoted::TokenTree,\n                       interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n                       repeats: &[(usize, usize)])\n                       -> LockstepIterSize {\n-    use self::quoted::TokenTree;\n+    use quoted::TokenTree;\n     match *tree {\n         TokenTree::Delimited(_, ref delimed) => {\n             delimed.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {"}, {"sha": "6c780369a0a2d92887e5bcc9b18a261ad0c6a2cd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -12,21 +12,23 @@\n //! gate usage is added, *do not remove it again* even once the feature\n //! becomes stable.\n \n-use self::AttributeType::*;\n-use self::AttributeGate::*;\n+use AttributeType::*;\n+use AttributeGate::*;\n+\n+use crate::ast::{self, NodeId, PatKind, RangeEnd};\n+use crate::attr;\n+use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::source_map::Spanned;\n+use crate::edition::{ALL_EDITIONS, Edition};\n+use crate::errors::{DiagnosticBuilder, Handler};\n+use crate::visit::{self, FnKind, Visitor};\n+use crate::parse::ParseSess;\n+use crate::symbol::Symbol;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n-use ast::{self, NodeId, PatKind, RangeEnd};\n-use attr;\n-use early_buffered_lints::BufferedEarlyLintId;\n-use source_map::Spanned;\n-use edition::{ALL_EDITIONS, Edition};\n use syntax_pos::{Span, DUMMY_SP};\n-use errors::{DiagnosticBuilder, Handler};\n-use visit::{self, FnKind, Visitor};\n-use parse::ParseSess;\n-use symbol::Symbol;\n+use log::debug;\n \n use std::env;\n \n@@ -778,8 +780,8 @@ pub enum Stability {\n }\n \n // fn() is not Debug\n-impl ::std::fmt::Debug for AttributeGate {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+impl std::fmt::Debug for AttributeGate {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match *self {\n             Gated(ref stab, name, expl, _) =>\n                 write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl),"}, {"sha": "2953b35298eabd4b6c19c72c7b13b77a245be5c8", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -9,13 +9,13 @@\n \n // FIXME: spec the JSON output properly.\n \n-use source_map::{SourceMap, FilePathMapping};\n-use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n-use errors::registry::Registry;\n-use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, SourceMapper};\n-use errors::{DiagnosticId, Applicability};\n-use errors::emitter::{Emitter, EmitterWriter};\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::errors::registry::Registry;\n+use crate::errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, SourceMapper};\n+use crate::errors::{DiagnosticId, Applicability};\n+use crate::errors::emitter::{Emitter, EmitterWriter};\n \n+use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use rustc_data_structures::sync::{self, Lrc};\n use std::io::{self, Write};\n use std::vec;\n@@ -69,7 +69,7 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n+    fn emit(&mut self, db: &DiagnosticBuilder<'_>) {\n         let data = Diagnostic::from_diagnostic_builder(db, self);\n         let result = if self.pretty {\n             writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n@@ -159,7 +159,7 @@ struct DiagnosticCode {\n }\n \n impl Diagnostic {\n-    fn from_diagnostic_builder(db: &DiagnosticBuilder,\n+    fn from_diagnostic_builder(db: &DiagnosticBuilder<'_>,\n                                je: &JsonEmitter)\n                                -> Diagnostic {\n         let sugg = db.suggestions.iter().map(|sugg| {"}, {"sha": "c04391b34ee1f33da722591d3f7cf644a69bce92", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -9,9 +9,10 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n-#![feature(nll)]\n #![feature(rustc_attrs)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n@@ -22,20 +23,10 @@\n \n #![recursion_limit=\"256\"]\n \n-#[macro_use] extern crate bitflags;\n-extern crate core;\n-extern crate serialize;\n-#[macro_use] extern crate log;\n-pub extern crate rustc_errors as errors;\n-extern crate syntax_pos;\n-#[macro_use] extern crate rustc_data_structures;\n-extern crate rustc_target;\n-#[macro_use] extern crate scoped_tls;\n-#[macro_use]\n-extern crate smallvec;\n-\n+#[allow(unused_extern_crates)]\n extern crate serialize as rustc_serialize; // used by deriving\n \n+pub use rustc_errors as errors;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::bit_set::GrowableBitSet;\n pub use rustc_data_structures::thin_vec::ThinVec;\n@@ -48,7 +39,7 @@ use ast::AttrId;\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use errors::FatalError;\n+        use crate::errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(mut e) => {\n@@ -63,7 +54,7 @@ macro_rules! panictry {\n macro_rules! panictry_buffer {\n     ($handler:expr, $e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use errors::{FatalError, DiagnosticBuilder};\n+        use crate::errors::{FatalError, DiagnosticBuilder};\n         match $e {\n             Ok(e) => e,\n             Err(errs) => {\n@@ -113,7 +104,7 @@ pub fn with_globals<F, R>(f: F) -> R\n     })\n }\n \n-scoped_thread_local!(pub static GLOBALS: Globals);\n+scoped_tls::scoped_thread_local!(pub static GLOBALS: Globals);\n \n #[macro_use]\n pub mod diagnostics {\n@@ -139,9 +130,9 @@ pub mod util {\n pub mod json;\n \n pub mod syntax {\n-    pub use ext;\n-    pub use parse;\n-    pub use ast;\n+    pub use crate::ext;\n+    pub use crate::parse;\n+    pub use crate::ast;\n }\n \n pub mod ast;"}, {"sha": "0fd8bbf100fa25235aabbccadebbb0fd03617412", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -7,19 +7,20 @@\n //! a MutVisitor renaming item names in a module will miss all of those\n //! that are created by the expansion of a macro.\n \n-use ast::*;\n+use crate::ast::*;\n+use crate::source_map::{Spanned, respan};\n+use crate::parse::token::{self, Token};\n+use crate::ptr::P;\n+use crate::symbol::keywords;\n+use crate::ThinVec;\n+use crate::tokenstream::*;\n+use crate::util::map_in_place::MapInPlace;\n+\n+use smallvec::{smallvec, Array, SmallVec};\n use syntax_pos::Span;\n-use source_map::{Spanned, respan};\n-use parse::token::{self, Token};\n-use ptr::P;\n-use smallvec::{Array, SmallVec};\n-use std::ops::DerefMut;\n-use symbol::keywords;\n-use ThinVec;\n-use tokenstream::*;\n-use util::map_in_place::MapInPlace;\n \n use rustc_data_structures::sync::Lrc;\n+use std::ops::DerefMut;\n \n pub trait ExpectOne<A: Array> {\n     fn expect_one(self, err: &'static str) -> A::Item;\n@@ -1256,15 +1257,15 @@ pub fn noop_visit_vis<T: MutVisitor>(Spanned { node, span }: &mut Visibility, vi\n #[cfg(test)]\n mod tests {\n     use std::io;\n-    use ast::{self, Ident};\n-    use util::parser_testing::{string_to_crate, matches_codepattern};\n-    use print::pprust;\n-    use mut_visit;\n-    use with_globals;\n+    use crate::ast::{self, Ident};\n+    use crate::util::parser_testing::{string_to_crate, matches_codepattern};\n+    use crate::print::pprust;\n+    use crate::mut_visit;\n+    use crate::with_globals;\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: &mut pprust::State,\n+    fn fake_print_crate(s: &mut pprust::State<'_>,\n                         krate: &ast::Crate) -> io::Result<()> {\n         s.print_mod(&krate.module, &krate.attrs)\n     }"}, {"sha": "b36ca0574cb8dca7e995a5ae0db4c7da40d684fd", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,10 +1,12 @@\n-use attr;\n-use ast;\n-use source_map::respan;\n-use parse::{SeqSep, PResult};\n-use parse::token::{self, Nonterminal, DelimToken};\n-use parse::parser::{Parser, TokenType, PathStyle};\n-use tokenstream::{TokenStream, TokenTree};\n+use crate::attr;\n+use crate::ast;\n+use crate::source_map::respan;\n+use crate::parse::{SeqSep, PResult};\n+use crate::parse::token::{self, Nonterminal, DelimToken};\n+use crate::parse::parser::{Parser, TokenType, PathStyle};\n+use crate::tokenstream::{TokenStream, TokenTree};\n+\n+use log::debug;\n \n #[derive(Debug)]\n enum InnerAttributeParsePolicy<'a> {\n@@ -74,7 +76,7 @@ impl<'a> Parser<'a> {\n     /// The same as `parse_attribute`, except it takes in an `InnerAttributeParsePolicy`\n     /// that prescribes how to handle inner attributes.\n     fn parse_attribute_with_inner_parse_policy(&mut self,\n-                                               inner_parse_policy: InnerAttributeParsePolicy)\n+                                               inner_parse_policy: InnerAttributeParsePolicy<'_>)\n                                                -> PResult<'a, ast::Attribute> {\n         debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n                inner_parse_policy,"}, {"sha": "b4103440e357719e00e2637bb71a0e42aaecbe9d", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -2,7 +2,7 @@\n \n // Predicates on exprs and stmts that the pretty-printer and parser use\n \n-use ast;\n+use crate::ast;\n \n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression"}, {"sha": "4632d814d5caceeb09cba3ac971beeeff93ec651", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,11 +1,13 @@\n-pub use self::CommentStyle::*;\n+pub use CommentStyle::*;\n+\n+use crate::ast;\n+use crate::source_map::SourceMap;\n+use crate::parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n+use crate::parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n+use crate::print::pprust;\n \n-use ast;\n-use source_map::SourceMap;\n use syntax_pos::{BytePos, CharPos, Pos, FileName};\n-use parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n-use parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n-use print::pprust;\n+use log::debug;\n \n use std::io::Read;\n use std::usize;\n@@ -135,7 +137,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     panic!(\"not a doc-comment: {}\", comment);\n }\n \n-fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n+fn push_blank_line_comment(rdr: &StringReader<'_>, comments: &mut Vec<Comment>) {\n     debug!(\">>> blank-line comment\");\n     comments.push(Comment {\n         style: BlankLine,\n@@ -144,7 +146,10 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n     });\n }\n \n-fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader, comments: &mut Vec<Comment>) {\n+fn consume_whitespace_counting_blank_lines(\n+    rdr: &mut StringReader<'_>,\n+    comments: &mut Vec<Comment>\n+) {\n     while is_pattern_whitespace(rdr.ch) && !rdr.is_eof() {\n         if rdr.ch_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n@@ -153,7 +158,7 @@ fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader, comments: &mu\n     }\n }\n \n-fn read_shebang_comment(rdr: &mut StringReader,\n+fn read_shebang_comment(rdr: &mut StringReader<'_>,\n                         code_to_the_left: bool,\n                         comments: &mut Vec<Comment>) {\n     debug!(\">>> shebang comment\");\n@@ -166,7 +171,7 @@ fn read_shebang_comment(rdr: &mut StringReader,\n     });\n }\n \n-fn read_line_comments(rdr: &mut StringReader,\n+fn read_line_comments(rdr: &mut StringReader<'_>,\n                       code_to_the_left: bool,\n                       comments: &mut Vec<Comment>) {\n     debug!(\">>> line comments\");\n@@ -222,7 +227,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String>, s: String, col:\n     lines.push(s1);\n }\n \n-fn read_block_comment(rdr: &mut StringReader,\n+fn read_block_comment(rdr: &mut StringReader<'_>,\n                       code_to_the_left: bool,\n                       comments: &mut Vec<Comment>) {\n     debug!(\">>> block comment\");\n@@ -312,7 +317,7 @@ fn read_block_comment(rdr: &mut StringReader,\n }\n \n \n-fn consume_comment(rdr: &mut StringReader,\n+fn consume_comment(rdr: &mut StringReader<'_>,\n                    comments: &mut Vec<Comment>,\n                    code_to_the_left: &mut bool,\n                    anything_to_the_left: &mut bool) {"}, {"sha": "2e3233c8ed8fac8a2f9f4f8dda58a5956f8c1830", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,16 +1,18 @@\n-use ast::{self, Ident};\n+use crate::ast::{self, Ident};\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::errors::{Applicability, FatalError, Diagnostic, DiagnosticBuilder};\n+use crate::parse::{token, ParseSess};\n+use crate::symbol::{Symbol, keywords};\n+\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n-use source_map::{SourceMap, FilePathMapping};\n-use errors::{Applicability, FatalError, Diagnostic, DiagnosticBuilder};\n-use parse::{token, ParseSess};\n-use symbol::{Symbol, keywords};\n use core::unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n use std::char;\n use std::iter;\n use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n+use log::debug;\n \n pub mod comments;\n mod tokentrees;\n@@ -449,7 +451,7 @@ impl<'a> StringReader<'a> {\n         }\n         return s.into();\n \n-        fn translate_crlf_(rdr: &StringReader,\n+        fn translate_crlf_(rdr: &StringReader<'_>,\n                            start: BytePos,\n                            s: &str,\n                            mut j: usize,\n@@ -1866,19 +1868,20 @@ fn char_at(s: &str, byte: usize) -> char {\n mod tests {\n     use super::*;\n \n-    use ast::{Ident, CrateConfig};\n-    use symbol::Symbol;\n-    use syntax_pos::{BytePos, Span, NO_EXPANSION};\n-    use source_map::SourceMap;\n-    use errors;\n-    use feature_gate::UnstableFeatures;\n-    use parse::token;\n+    use crate::ast::{Ident, CrateConfig};\n+    use crate::symbol::Symbol;\n+    use crate::source_map::SourceMap;\n+    use crate::errors;\n+    use crate::feature_gate::UnstableFeatures;\n+    use crate::parse::token;\n+    use crate::diagnostics::plugin::ErrorMap;\n+    use crate::with_globals;\n     use std::io;\n     use std::path::PathBuf;\n-    use diagnostics::plugin::ErrorMap;\n+    use syntax_pos::{BytePos, Span, NO_EXPANSION};\n     use rustc_data_structures::fx::FxHashSet;\n     use rustc_data_structures::sync::Lock;\n-    use with_globals;\n+\n     fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                           Some(sm.clone()),\n@@ -1943,7 +1946,7 @@ mod tests {\n \n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n-    fn check_tokenization(mut string_reader: StringReader, expected: Vec<token::Token>) {\n+    fn check_tokenization(mut string_reader: StringReader<'_>, expected: Vec<token::Token>) {\n         for expected_tok in &expected {\n             assert_eq!(&string_reader.next_token().tok, expected_tok);\n         }"}, {"sha": "7699d9eab222543938193a960b359899d84759b9", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,7 +1,7 @@\n-use print::pprust::token_to_string;\n-use parse::lexer::StringReader;\n-use parse::{token, PResult};\n-use tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n+use crate::print::pprust::token_to_string;\n+use crate::parse::lexer::StringReader;\n+use crate::parse::{token, PResult};\n+use crate::tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n \n impl<'a> StringReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`."}, {"sha": "75862178169ea980dd9a3c15528d2fb753ceb348", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -2,7 +2,7 @@\n // http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n use syntax_pos::{Span, NO_EXPANSION};\n-use errors::{Applicability, DiagnosticBuilder};\n+use crate::errors::{Applicability, DiagnosticBuilder};\n use super::StringReader;\n \n const UNICODE_ARRAY: &[(char, &str, char)] = &["}, {"sha": "c723d591f2fb2d1b571c92f3efb30fb258db4dca", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,16 +1,18 @@\n //! The main parser interface\n \n+use crate::ast::{self, CrateConfig, NodeId};\n+use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::errors::{FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n+use crate::feature_gate::UnstableFeatures;\n+use crate::parse::parser::Parser;\n+use crate::symbol::Symbol;\n+use crate::tokenstream::{TokenStream, TokenTree};\n+use crate::diagnostics::plugin::ErrorMap;\n+\n use rustc_data_structures::sync::{Lrc, Lock};\n-use ast::{self, CrateConfig, NodeId};\n-use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n-use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use errors::{FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n-use feature_gate::UnstableFeatures;\n-use parse::parser::Parser;\n-use symbol::Symbol;\n-use tokenstream::{TokenStream, TokenTree};\n-use diagnostics::plugin::ErrorMap;\n+use log::debug;\n \n use rustc_data_structures::fx::FxHashSet;\n use std::borrow::Cow;\n@@ -125,12 +127,12 @@ pub fn parse_crate_attrs_from_file<'a>(input: &Path, sess: &'a ParseSess)\n }\n \n pub fn parse_crate_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                       -> PResult<ast::Crate> {\n+                                       -> PResult<'_, ast::Crate> {\n     new_parser_from_source_str(sess, name, source).parse_crate_mod()\n }\n \n pub fn parse_crate_attrs_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                             -> PResult<Vec<ast::Attribute>> {\n+                                             -> PResult<'_, Vec<ast::Attribute>> {\n     new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n@@ -142,14 +144,14 @@ pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &Parse\n \n /// Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n-                                      -> Parser {\n+                                      -> Parser<'_> {\n     panictry_buffer!(&sess.span_diagnostic, maybe_new_parser_from_source_str(sess, name, source))\n }\n \n /// Create a new parser from a source string. Returns any buffered errors from lexing the initial\n /// token stream.\n pub fn maybe_new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n-    -> Result<Parser, Vec<Diagnostic>>\n+    -> Result<Parser<'_>, Vec<Diagnostic>>\n {\n     let mut parser = maybe_source_file_to_parser(sess,\n                                                  sess.source_map().new_source_file(name, source))?;\n@@ -186,15 +188,15 @@ crate fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n }\n \n /// Given a source_file and config, return a parser\n-fn source_file_to_parser(sess: & ParseSess, source_file: Lrc<SourceFile>) -> Parser {\n+fn source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>) -> Parser<'_> {\n     panictry_buffer!(&sess.span_diagnostic,\n                      maybe_source_file_to_parser(sess, source_file))\n }\n \n /// Given a source_file and config, return a parser. Returns any buffered errors from lexing the\n /// initial token stream.\n fn maybe_source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>)\n-    -> Result<Parser, Vec<Diagnostic>>\n+    -> Result<Parser<'_>, Vec<Diagnostic>>\n {\n     let end_pos = source_file.end_pos;\n     let mut parser = stream_to_parser(sess, maybe_file_to_stream(sess, source_file, None)?);\n@@ -208,7 +210,7 @@ fn maybe_source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>)\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n-pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n+pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser<'_> {\n     stream_to_parser(sess, tts.into_iter().collect())\n }\n \n@@ -270,7 +272,7 @@ pub fn maybe_file_to_stream(sess: &ParseSess,\n }\n \n /// Given stream and the `ParseSess`, produce a parser\n-pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser {\n+pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n     Parser::new(sess, stream, None, true, false)\n }\n \n@@ -758,22 +760,22 @@ impl SeqSep {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use crate::ast::{self, Ident, PatKind};\n+    use crate::attr::first_attr_value_str_by_name;\n+    use crate::ptr::P;\n+    use crate::print::pprust::item_to_string;\n+    use crate::tokenstream::{DelimSpan, TokenTree};\n+    use crate::util::parser_testing::string_to_stream;\n+    use crate::util::parser_testing::{string_to_expr, string_to_item};\n+    use crate::with_globals;\n     use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n-    use ast::{self, Ident, PatKind};\n-    use attr::first_attr_value_str_by_name;\n-    use ptr::P;\n-    use print::pprust::item_to_string;\n-    use tokenstream::{DelimSpan, TokenTree};\n-    use util::parser_testing::string_to_stream;\n-    use util::parser_testing::{string_to_expr, string_to_item};\n-    use with_globals;\n \n     /// Parses an item.\n     ///\n     /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n     /// when a syntax error occurred.\n     fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                        -> PResult<Option<P<ast::Item>>> {\n+                                        -> PResult<'_, Option<P<ast::Item>>> {\n         new_parser_from_source_str(sess, name, source).parse_item()\n     }\n \n@@ -913,20 +915,20 @@ mod tests {\n         struct PatIdentVisitor {\n             spans: Vec<Span>\n         }\n-        impl<'a> ::visit::Visitor<'a> for PatIdentVisitor {\n+        impl<'a> crate::visit::Visitor<'a> for PatIdentVisitor {\n             fn visit_pat(&mut self, p: &'a ast::Pat) {\n                 match p.node {\n                     PatKind::Ident(_ , ref spannedident, _) => {\n                         self.spans.push(spannedident.span.clone());\n                     }\n                     _ => {\n-                        ::visit::walk_pat(self, p);\n+                        crate::visit::walk_pat(self, p);\n                     }\n                 }\n             }\n         }\n         let mut v = PatIdentVisitor { spans: Vec::new() };\n-        ::visit::walk_item(&mut v, &item);\n+        crate::visit::walk_item(&mut v, &item);\n         return v.spans;\n     }\n \n@@ -1007,7 +1009,7 @@ mod tests {\n     fn ttdelim_span() {\n         fn parse_expr_from_source_str(\n             name: FileName, source: String, sess: &ParseSess\n-        ) -> PResult<P<ast::Expr>> {\n+        ) -> PResult<'_, P<ast::Expr>> {\n             new_parser_from_source_str(sess, name, source).parse_expr()\n         }\n "}, {"sha": "cacdab980facde315770f3b5d33a07ded5e3647f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,53 +1,55 @@\n+use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{GenericBound, TraitBoundModifier};\n+use crate::ast::Unsafety;\n+use crate::ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n+use crate::ast::Block;\n+use crate::ast::{BlockCheckMode, CaptureBy, Movability};\n+use crate::ast::{Constness, Crate};\n+use crate::ast::Defaultness;\n+use crate::ast::EnumDef;\n+use crate::ast::{Expr, ExprKind, RangeLimits};\n+use crate::ast::{Field, FnDecl, FnHeader};\n+use crate::ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n+use crate::ast::{GenericParam, GenericParamKind};\n+use crate::ast::GenericArg;\n+use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n+use crate::ast::{Label, Lifetime, Lit, LitKind};\n+use crate::ast::Local;\n+use crate::ast::MacStmtStyle;\n+use crate::ast::{Mac, Mac_, MacDelimiter};\n+use crate::ast::{MutTy, Mutability};\n+use crate::ast::{Pat, PatKind, PathSegment};\n+use crate::ast::{PolyTraitRef, QSelf};\n+use crate::ast::{Stmt, StmtKind};\n+use crate::ast::{VariantData, StructField};\n+use crate::ast::StrStyle;\n+use crate::ast::SelfKind;\n+use crate::ast::{TraitItem, TraitRef, TraitObjectSyntax};\n+use crate::ast::{Ty, TyKind, TypeBinding, GenericBounds};\n+use crate::ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n+use crate::ast::{UseTree, UseTreeKind};\n+use crate::ast::{BinOpKind, UnOp};\n+use crate::ast::{RangeEnd, RangeSyntax};\n+use crate::{ast, attr};\n+use crate::ext::base::DummyResult;\n+use crate::source_map::{self, SourceMap, Spanned, respan};\n+use crate::errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n+use crate::parse::{self, SeqSep, classify, token};\n+use crate::parse::lexer::TokenAndSpan;\n+use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use crate::parse::token::DelimToken;\n+use crate::parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n+use crate::util::parser::{AssocOp, Fixity};\n+use crate::print::pprust;\n+use crate::ptr::P;\n+use crate::parse::PResult;\n+use crate::ThinVec;\n+use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n+use crate::symbol::{Symbol, keywords};\n+\n use rustc_target::spec::abi::{self, Abi};\n-use ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n-use ast::{GenericBound, TraitBoundModifier};\n-use ast::Unsafety;\n-use ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n-use ast::Block;\n-use ast::{BlockCheckMode, CaptureBy, Movability};\n-use ast::{Constness, Crate};\n-use ast::Defaultness;\n-use ast::EnumDef;\n-use ast::{Expr, ExprKind, RangeLimits};\n-use ast::{Field, FnDecl, FnHeader};\n-use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n-use ast::{GenericParam, GenericParamKind};\n-use ast::GenericArg;\n-use ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n-use ast::{Label, Lifetime, Lit, LitKind};\n-use ast::Local;\n-use ast::MacStmtStyle;\n-use ast::{Mac, Mac_, MacDelimiter};\n-use ast::{MutTy, Mutability};\n-use ast::{Pat, PatKind, PathSegment};\n-use ast::{PolyTraitRef, QSelf};\n-use ast::{Stmt, StmtKind};\n-use ast::{VariantData, StructField};\n-use ast::StrStyle;\n-use ast::SelfKind;\n-use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n-use ast::{Ty, TyKind, TypeBinding, GenericBounds};\n-use ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n-use ast::{UseTree, UseTreeKind};\n-use ast::{BinOpKind, UnOp};\n-use ast::{RangeEnd, RangeSyntax};\n-use {ast, attr};\n-use ext::base::DummyResult;\n-use source_map::{self, SourceMap, Spanned, respan};\n use syntax_pos::{self, Span, MultiSpan, BytePos, FileName};\n-use errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n-use parse::{self, SeqSep, classify, token};\n-use parse::lexer::TokenAndSpan;\n-use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::token::DelimToken;\n-use parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n-use util::parser::{AssocOp, Fixity};\n-use print::pprust;\n-use ptr::P;\n-use parse::PResult;\n-use ThinVec;\n-use tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n-use symbol::{Symbol, keywords};\n+use log::{debug, trace};\n \n use std::borrow::Cow;\n use std::cmp;\n@@ -64,7 +66,7 @@ pub enum AliasKind {\n     Existential(GenericBounds),\n }\n \n-bitflags! {\n+bitflags::bitflags! {\n     struct Restrictions: u8 {\n         const STMT_EXPR         = 1 << 0;\n         const NO_STRUCT_LITERAL = 1 << 1;\n@@ -453,7 +455,7 @@ pub enum Error {\n impl Error {\n     fn span_err<S: Into<MultiSpan>>(self,\n                                         sp: S,\n-                                        handler: &errors::Handler) -> DiagnosticBuilder {\n+                                        handler: &errors::Handler) -> DiagnosticBuilder<'_> {\n         match self {\n             Error::FileNotFoundForModule { ref mod_name,\n                                            ref default_path,\n@@ -1313,7 +1315,7 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n \n-    fn cancel(&self, err: &mut DiagnosticBuilder) {\n+    fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n         self.sess.span_diagnostic.cancel(err)\n     }\n \n@@ -1721,7 +1723,7 @@ impl<'a> Parser<'a> {\n         match ty.node {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n-                    use print::pprust::PrintState;\n+                    use crate::print::pprust::PrintState;\n \n                     s.s.word(\"&\")?;\n                     s.print_opt_lifetime(lifetime)?;\n@@ -3063,7 +3065,7 @@ impl<'a> Parser<'a> {\n                             None => continue,\n                         };\n                         let sugg = pprust::to_string(|s| {\n-                            use print::pprust::PrintState;\n+                            use crate::print::pprust::PrintState;\n                             s.popen()?;\n                             s.print_expr(&e)?;\n                             s.s.word( \".\")?;\n@@ -5220,7 +5222,7 @@ impl<'a> Parser<'a> {\n                         stmt_span = stmt_span.with_hi(self.prev_span.hi());\n                     }\n                     let sugg = pprust::to_string(|s| {\n-                        use print::pprust::{PrintState, INDENT_UNIT};\n+                        use crate::print::pprust::{PrintState, INDENT_UNIT};\n                         s.ibox(INDENT_UNIT)?;\n                         s.bopen()?;\n                         s.print_stmt(&stmt)?;\n@@ -7050,7 +7052,7 @@ impl<'a> Parser<'a> {\n     /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n         let (in_cfg, outer_attrs) = {\n-            let mut strip_unconfigured = ::config::StripUnconfigured {\n+            let mut strip_unconfigured = crate::config::StripUnconfigured {\n                 sess: self.sess,\n                 features: None, // don't perform gated feature checking\n             };"}, {"sha": "3b1fa5ea01f541057b7d2084e59eacff29e5ef79", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,22 +1,26 @@\n-pub use self::BinOpToken::*;\n-pub use self::Nonterminal::*;\n-pub use self::DelimToken::*;\n-pub use self::Lit::*;\n-pub use self::Token::*;\n-\n-use ast::{self};\n-use parse::ParseSess;\n-use print::pprust;\n-use ptr::P;\n+pub use BinOpToken::*;\n+pub use Nonterminal::*;\n+pub use DelimToken::*;\n+pub use Lit::*;\n+pub use Token::*;\n+\n+use crate::ast::{self};\n+use crate::parse::ParseSess;\n+use crate::print::pprust;\n+use crate::ptr::P;\n+use crate::symbol::keywords;\n+use crate::syntax::parse::parse_stream_from_source_str;\n+use crate::tokenstream::{self, DelimSpan, TokenStream, TokenTree};\n+\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n-use symbol::keywords;\n-use syntax::parse::parse_stream_from_source_str;\n-use syntax_pos::{self, Span, FileName};\n use syntax_pos::symbol::{self, Symbol};\n-use tokenstream::{self, DelimSpan, TokenStream, TokenTree};\n+use syntax_pos::{self, Span, FileName};\n+use log::info;\n \n use std::{cmp, fmt};\n use std::mem;\n+#[cfg(target_arch = \"x86_64\")]\n+use rustc_data_structures::static_assert;\n use rustc_data_structures::sync::{Lrc, Lock};\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -683,7 +687,7 @@ impl PartialEq for Nonterminal {\n }\n \n impl fmt::Debug for Nonterminal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             NtItem(..) => f.pad(\"NtItem(..)\"),\n             NtBlock(..) => f.pad(\"NtBlock(..)\"),\n@@ -729,7 +733,7 @@ impl PartialEq for LazyTokenStream {\n }\n \n impl fmt::Debug for LazyTokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.clone().0.into_inner(), f)\n     }\n }"}, {"sha": "2d837cb565b149a4c9331213c9bcdbb2db6dcd90", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -138,6 +138,7 @@ use std::collections::VecDeque;\n use std::fmt;\n use std::io;\n use std::borrow::Cow;\n+use log::debug;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n@@ -192,7 +193,7 @@ impl Token {\n }\n \n impl fmt::Display for Token {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             Token::String(ref s, len) => write!(f, \"STR({},{})\", s, len),\n             Token::Break(_) => f.write_str(\"BREAK\"),"}, {"sha": "c7c4c4f16205bd74d137bcb0dafefb1bebefd026", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,21 +1,22 @@\n+use crate::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n+use crate::ast::{SelfKind, GenericBound, TraitBoundModifier};\n+use crate::ast::{Attribute, MacDelimiter, GenericArg};\n+use crate::util::parser::{self, AssocOp, Fixity};\n+use crate::attr;\n+use crate::source_map::{self, SourceMap, Spanned};\n+use crate::parse::token::{self, BinOpToken, Token};\n+use crate::parse::lexer::comments;\n+use crate::parse::{self, ParseSess};\n+use crate::print::pp::{self, Breaks};\n+use crate::print::pp::Breaks::{Consistent, Inconsistent};\n+use crate::ptr::P;\n+use crate::std_inject;\n+use crate::symbol::keywords;\n+use crate::tokenstream::{self, TokenStream, TokenTree};\n+\n use rustc_target::spec::abi::{self, Abi};\n-use ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use ast::{SelfKind, GenericBound, TraitBoundModifier};\n-use ast::{Attribute, MacDelimiter, GenericArg};\n-use util::parser::{self, AssocOp, Fixity};\n-use attr;\n-use source_map::{self, SourceMap, Spanned};\n use syntax_pos::{self, BytePos};\n-use parse::token::{self, BinOpToken, Token};\n-use parse::lexer::comments;\n-use parse::{self, ParseSess};\n-use print::pp::{self, Breaks};\n-use print::pp::Breaks::{Consistent, Inconsistent};\n-use ptr::P;\n-use std_inject;\n-use symbol::keywords;\n use syntax_pos::{DUMMY_SP, FileName};\n-use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n use std::borrow::Cow;\n@@ -34,8 +35,8 @@ pub enum AnnNode<'a> {\n }\n \n pub trait PpAnn {\n-    fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }\n-    fn post(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }\n+    fn pre(&self, _state: &mut State<'_>, _node: AnnNode<'_>) -> io::Result<()> { Ok(()) }\n+    fn post(&self, _state: &mut State<'_>, _node: AnnNode<'_>) -> io::Result<()> { Ok(()) }\n }\n \n #[derive(Copy, Clone)]\n@@ -150,7 +151,7 @@ impl<'a> State<'a> {\n }\n \n pub fn to_string<F>(f: F) -> String where\n-    F: FnOnce(&mut State) -> io::Result<()>,\n+    F: FnOnce(&mut State<'_>) -> io::Result<()>,\n {\n     let mut wr = Vec::new();\n     {\n@@ -969,7 +970,7 @@ impl<'a> State<'a> {\n                                   elts: &[T],\n                                   mut op: F,\n                                   mut get_span: G) -> io::Result<()> where\n-        F: FnMut(&mut State, &T) -> io::Result<()>,\n+        F: FnMut(&mut State<'_>, &T) -> io::Result<()>,\n         G: FnMut(&T) -> syntax_pos::Span,\n     {\n         self.rbox(0, b)?;\n@@ -3210,10 +3211,10 @@ impl<'a> State<'a> {\n mod tests {\n     use super::*;\n \n-    use ast;\n-    use source_map;\n+    use crate::ast;\n+    use crate::source_map;\n+    use crate::with_globals;\n     use syntax_pos;\n-    use with_globals;\n \n     #[test]\n     fn test_fun_to_string() {"}, {"sha": "0ec83447d52e7b262be3c066620e8c49a39c87e6", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -129,19 +129,19 @@ impl<T: 'static + Clone> Clone for P<T> {\n }\n \n impl<T: ?Sized + Debug> Debug for P<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Debug::fmt(&self.ptr, f)\n     }\n }\n \n impl<T: Display> Display for P<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Display::fmt(&**self, f)\n     }\n }\n \n impl<T> fmt::Pointer for P<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Pointer::fmt(&self.ptr, f)\n     }\n }"}, {"sha": "2c32771266e7d99536828f9e2940a59452d90736", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -5,10 +5,10 @@\n \n use std::str::FromStr;\n \n-use ast;\n-use errors;\n-use visit;\n-use visit::Visitor;\n+use crate::ast;\n+use crate::errors;\n+use crate::visit;\n+use crate::visit::Visitor;\n \n enum Mode {\n     Expression,"}, {"sha": "552a3d30261eb33a15f9d841fe30f8551d1720c8", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -10,7 +10,7 @@\n \n pub use syntax_pos::*;\n pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo};\n-pub use self::ExpnFormat::*;\n+pub use ExpnFormat::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -22,7 +22,9 @@ use std::path::{Path, PathBuf};\n use std::env;\n use std::fs;\n use std::io;\n-use errors::SourceMapper;\n+use log::debug;\n+\n+use crate::errors::SourceMapper;\n \n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n@@ -167,7 +169,7 @@ impl SourceMap {\n         Ok(self.new_source_file(filename, src))\n     }\n \n-    pub fn files(&self) -> MappedLockGuard<Vec<Lrc<SourceFile>>> {\n+    pub fn files(&self) -> MappedLockGuard<'_, Vec<Lrc<SourceFile>>> {\n         LockGuard::map(self.files.borrow(), |files| &mut files.source_files)\n     }\n "}, {"sha": "5b904fa86ad0939cc8abe71c928e886cbaf9bad3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,14 +1,15 @@\n-use ast;\n-use attr;\n+use crate::ast;\n+use crate::attr;\n+use crate::edition::Edition;\n+use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::symbol::{Symbol, keywords};\n+use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n+use crate::ptr::P;\n+use crate::tokenstream::TokenStream;\n+\n use std::cell::Cell;\n use std::iter;\n-use edition::Edition;\n-use ext::hygiene::{Mark, SyntaxContext};\n-use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n-use source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n-use ptr::P;\n-use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to source_map's `is_internal` check."}, {"sha": "703c4f2db347b9cc63144fd6cd633ada48529c9f", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -3,33 +3,35 @@\n #![allow(dead_code)]\n #![allow(unused_imports)]\n \n-use self::HasTestSignature::*;\n+use HasTestSignature::*;\n \n use std::iter;\n use std::slice;\n use std::mem;\n use std::vec;\n-use attr::{self, HasAttrs};\n+\n+use log::debug;\n+use smallvec::{smallvec, SmallVec};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n \n-use source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned, respan};\n-use errors;\n-use config;\n-use entry::{self, EntryPointType};\n-use ext::base::{ExtCtxt, Resolver};\n-use ext::build::AstBuilder;\n-use ext::expand::ExpansionConfig;\n-use ext::hygiene::{self, Mark, SyntaxContext};\n-use mut_visit::{*, ExpectOne};\n-use feature_gate::Features;\n-use util::map_in_place::MapInPlace;\n-use parse::{token, ParseSess};\n-use print::pprust;\n-use ast::{self, Ident};\n-use ptr::P;\n-use smallvec::SmallVec;\n-use symbol::{self, Symbol, keywords};\n-use ThinVec;\n+use crate::attr::{self, HasAttrs};\n+use crate::source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned, respan};\n+use crate::errors;\n+use crate::config;\n+use crate::entry::{self, EntryPointType};\n+use crate::ext::base::{ExtCtxt, Resolver};\n+use crate::ext::build::AstBuilder;\n+use crate::ext::expand::ExpansionConfig;\n+use crate::ext::hygiene::{self, Mark, SyntaxContext};\n+use crate::mut_visit::{*, ExpectOne};\n+use crate::feature_gate::Features;\n+use crate::util::map_in_place::MapInPlace;\n+use crate::parse::{token, ParseSess};\n+use crate::print::pprust;\n+use crate::ast::{self, Ident};\n+use crate::ptr::P;\n+use crate::symbol::{self, Symbol, keywords};\n+use crate::ThinVec;\n \n struct Test {\n     span: Span,\n@@ -210,7 +212,7 @@ impl MutVisitor for EntryPointCleaner {\n /// Each tested submodule will contain a similar reexport module that we will export\n /// under the name of the original module. That is, `submod::__test_reexports` is\n /// reexported like so `pub use submod::__test_reexports as submod`.\n-fn mk_reexport_mod(cx: &mut TestCtxt,\n+fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n                    parent: ast::NodeId,\n                    tests: Vec<Ident>,\n                    tested_submods: Vec<(Ident, Ident)>)\n@@ -299,7 +301,7 @@ fn generate_test_harness(sess: &ParseSess,\n /// Craft a span that will be ignored by the stability lint's\n /// call to source_map's `is_internal` check.\n /// The expanded code calls some unstable functions in the test crate.\n-fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n+fn ignored_span(cx: &TestCtxt<'_>, sp: Span) -> Span {\n     sp.with_ctxt(cx.ctxt)\n }\n \n@@ -318,7 +320,7 @@ enum BadTestSignature {\n \n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n-fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n+fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     // Writing this out by hand with 'ignored_span':\n     //        pub fn main() {\n     //            #![main]\n@@ -398,7 +400,7 @@ fn path_name_i(idents: &[Ident]) -> String {\n \n /// Creates a slice containing every test like so:\n /// &[path::to::test1, path::to::test2]\n-fn mk_tests_slice(cx: &TestCtxt) -> P<ast::Expr> {\n+fn mk_tests_slice(cx: &TestCtxt<'_>) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ref ecx = cx.ext_cx;\n \n@@ -410,7 +412,7 @@ fn mk_tests_slice(cx: &TestCtxt) -> P<ast::Expr> {\n }\n \n /// Creates a path from the top-level __test module to the test via __test_reexports\n-fn visible_path(cx: &TestCtxt, path: &[Ident]) -> Vec<Ident>{\n+fn visible_path(cx: &TestCtxt<'_>, path: &[Ident]) -> Vec<Ident>{\n     let mut visible_path = vec![];\n     match cx.toplevel_reexport {\n         Some(id) => visible_path.push(id),"}, {"sha": "add4d2bead1395365dc19f9f059ff93623fb3fa2", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,14 +1,15 @@\n-use source_map::{SourceMap, FilePathMapping};\n-use errors::Handler;\n-use errors::emitter::EmitterWriter;\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::errors::Handler;\n+use crate::errors::emitter::EmitterWriter;\n+use crate::with_globals;\n+\n use std::io;\n use std::io::prelude::*;\n use rustc_data_structures::sync::Lrc;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::path::Path;\n use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n-use with_globals;\n \n /// Identify a position in the text by the Nth occurrence of a string.\n struct Position {"}, {"sha": "b6e4d4cd9763537826eff25ce64a2ae1d5954a82", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -12,12 +12,15 @@\n //! and a borrowed `TokenStream` is sufficient to build an owned `TokenStream` without taking\n //! ownership of the original.\n \n+use crate::ext::base;\n+use crate::ext::tt::{macro_parser, quoted};\n+use crate::parse::Directory;\n+use crate::parse::token::{self, DelimToken, Token};\n+use crate::print::pprust;\n+\n use syntax_pos::{BytePos, Mark, Span, DUMMY_SP};\n-use ext::base;\n-use ext::tt::{macro_parser, quoted};\n-use parse::Directory;\n-use parse::token::{self, DelimToken, Token};\n-use print::pprust;\n+#[cfg(target_arch = \"x86_64\")]\n+use rustc_data_structures::static_assert;\n use rustc_data_structures::sync::Lrc;\n use serialize::{Decoder, Decodable, Encoder, Encodable};\n \n@@ -46,7 +49,7 @@ pub enum TokenTree {\n \n impl TokenTree {\n     /// Use this token tree as a matcher to parse given tts.\n-    pub fn parse(cx: &base::ExtCtxt, mtch: &[quoted::TokenTree], tts: TokenStream)\n+    pub fn parse(cx: &base::ExtCtxt<'_>, mtch: &[quoted::TokenTree], tts: TokenStream)\n                  -> macro_parser::NamedParseResult {\n         // `None` is because we're not interpolating\n         let directory = Directory {\n@@ -161,7 +164,7 @@ pub enum IsJoint {\n     NonJoint\n }\n \n-use self::IsJoint::*;\n+use IsJoint::*;\n \n impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n@@ -492,7 +495,7 @@ impl Cursor {\n }\n \n impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&pprust::tokens_to_string(self.clone()))\n     }\n }\n@@ -546,11 +549,11 @@ impl DelimSpan {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use syntax::ast::Ident;\n-    use with_globals;\n+    use crate::syntax::ast::Ident;\n+    use crate::with_globals;\n+    use crate::parse::token::Token;\n+    use crate::util::parser_testing::string_to_stream;\n     use syntax_pos::{Span, BytePos, NO_EXPANSION};\n-    use parse::token::Token;\n-    use util::parser_testing::string_to_stream;\n \n     fn string_to_ts(string: &str) -> TokenStream {\n         string_to_stream(string.to_owned())"}, {"sha": "c989fc7a5b830a80c207de4406a5de2870e12482", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,5 +1,5 @@\n use std::cmp;\n-use symbol::Symbol;\n+use crate::symbol::Symbol;\n \n /// Find the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {\n@@ -101,7 +101,7 @@ fn test_lev_distance() {\n \n #[test]\n fn test_find_best_match_for_name() {\n-    use with_globals;\n+    use crate::with_globals;\n     with_globals(|| {\n         let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n         assert_eq!("}, {"sha": "521edac8f5fc358152a0debddce1303f48801693", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,7 +1,7 @@\n // Simply gives a rought count of the number of nodes in an AST.\n \n-use visit::*;\n-use ast::*;\n+use crate::visit::*;\n+use crate::ast::*;\n use syntax_pos::Span;\n \n pub struct NodeCounter {\n@@ -69,7 +69,7 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'_>, fd: &FnDecl, s: Span, _: NodeId) {\n         self.count += 1;\n         walk_fn(self, fk, fd, s)\n     }"}, {"sha": "61729a08060129c1fdfe70436dbe49f170749a2d", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,6 +1,6 @@\n-use parse::token::{Token, BinOpToken};\n-use symbol::keywords;\n-use ast::{self, BinOpKind};\n+use crate::parse::token::{Token, BinOpToken};\n+use crate::symbol::keywords;\n+use crate::ast::{self, BinOpKind};\n \n /// Associative operator with precedence.\n ///\n@@ -72,7 +72,7 @@ pub enum Fixity {\n impl AssocOp {\n     /// Create a new AssocOP from a token\n     pub fn from_token(t: &Token) -> Option<AssocOp> {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         match *t {\n             Token::BinOpEq(k) => Some(AssignOp(k)),\n             Token::LArrow => Some(ObsoleteInPlace),\n@@ -107,7 +107,7 @@ impl AssocOp {\n \n     /// Create a new AssocOp from ast::BinOpKind.\n     pub fn from_ast_binop(op: BinOpKind) -> Self {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         match op {\n             BinOpKind::Lt => Less,\n             BinOpKind::Gt => Greater,\n@@ -132,7 +132,7 @@ impl AssocOp {\n \n     /// Gets the precedence of this operator\n     pub fn precedence(&self) -> usize {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         match *self {\n             As | Colon => 14,\n             Multiply | Divide | Modulus => 13,\n@@ -152,7 +152,7 @@ impl AssocOp {\n \n     /// Gets the fixity of this operator\n     pub fn fixity(&self) -> Fixity {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         // NOTE: it is a bug to have an operators that has same precedence but different fixities!\n         match *self {\n             ObsoleteInPlace | Assign | AssignOp(_) => Fixity::Right,\n@@ -164,7 +164,7 @@ impl AssocOp {\n     }\n \n     pub fn is_comparison(&self) -> bool {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             ObsoleteInPlace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add |\n@@ -174,7 +174,7 @@ impl AssocOp {\n     }\n \n     pub fn is_assign_like(&self) -> bool {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         match *self {\n             Assign | AssignOp(_) | ObsoleteInPlace => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n@@ -184,7 +184,7 @@ impl AssocOp {\n     }\n \n     pub fn to_ast_binop(&self) -> Option<BinOpKind> {\n-        use self::AssocOp::*;\n+        use AssocOp::*;\n         match *self {\n             Less => Some(BinOpKind::Lt),\n             Greater => Some(BinOpKind::Gt),"}, {"sha": "dbe2b8d39f2d06515f68b03a735cd4506c07e2e1", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -1,10 +1,11 @@\n-use ast::{self, Ident};\n-use source_map::FilePathMapping;\n-use parse::{ParseSess, PResult, source_file_to_stream};\n-use parse::{lexer, new_parser_from_source_str};\n-use parse::parser::Parser;\n-use ptr::P;\n-use tokenstream::TokenStream;\n+use crate::ast::{self, Ident};\n+use crate::source_map::FilePathMapping;\n+use crate::parse::{ParseSess, PResult, source_file_to_stream};\n+use crate::parse::{lexer, new_parser_from_source_str};\n+use crate::parse::parser::Parser;\n+use crate::ptr::P;\n+use crate::tokenstream::TokenStream;\n+\n use std::iter::Peekable;\n use std::path::PathBuf;\n "}, {"sha": "acbb58a66b6b47f37d44cce571ce890419fbfa80", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efdda10cdde386ea3e470ba2b482fdc73c12001/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1efdda10cdde386ea3e470ba2b482fdc73c12001", "patch": "@@ -13,10 +13,11 @@\n //! instance, a walker looking for item names in a module will miss all of\n //! those that are created by the expansion of a macro.\n \n-use ast::*;\n+use crate::ast::*;\n+use crate::parse::token::Token;\n+use crate::tokenstream::{TokenTree, TokenStream};\n+\n use syntax_pos::Span;\n-use parse::token::Token;\n-use tokenstream::{TokenTree, TokenStream};\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {"}]}