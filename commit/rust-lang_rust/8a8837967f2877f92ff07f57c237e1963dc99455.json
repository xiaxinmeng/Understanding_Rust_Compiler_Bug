{"sha": "8a8837967f2877f92ff07f57c237e1963dc99455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhODgzNzk2N2YyODc3ZjkyZmYwN2Y1N2MyMzdlMTk2M2RjOTk0NTU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-30T10:25:22Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-20T11:21:40Z"}, "message": "Move some function from cg_llvm/back/link.rs to cg_ssa/back/link.rs", "tree": {"sha": "3b9f4f3e10b8306820ac4468ca191e20a6ad0f15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b9f4f3e10b8306820ac4468ca191e20a6ad0f15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8837967f2877f92ff07f57c237e1963dc99455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8837967f2877f92ff07f57c237e1963dc99455", "html_url": "https://github.com/rust-lang/rust/commit/8a8837967f2877f92ff07f57c237e1963dc99455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8837967f2877f92ff07f57c237e1963dc99455/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "775486589279430b4c9ebe7c1aac6017563c853a", "url": "https://api.github.com/repos/rust-lang/rust/commits/775486589279430b4c9ebe7c1aac6017563c853a", "html_url": "https://github.com/rust-lang/rust/commit/775486589279430b4c9ebe7c1aac6017563c853a"}], "stats": {"total": 757, "additions": 382, "deletions": 375}, "files": [{"sha": "395da953d0b67f79246ffc03008b7c2f0274424e", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 3, "deletions": 373, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/8a8837967f2877f92ff07f57c237e1963dc99455/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8837967f2877f92ff07f57c237e1963dc99455/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=8a8837967f2877f92ff07f57c237e1963dc99455", "patch": "@@ -7,15 +7,14 @@ use crate::metadata::METADATA_FILENAME;\n use crate::context::get_reloc_model;\n use crate::llvm;\n use rustc_codegen_ssa::back::linker::Linker;\n-use rustc_codegen_ssa::back::link::{remove, ignored_for_lto, each_linked_rlib, linker_and_flavor,\n-    get_linker};\n+use rustc_codegen_ssa::back::link::*;\n use rustc_codegen_ssa::back::command::Command;\n use rustc::session::config::{self, DebugInfo, OutputFilenames, OutputType, PrintRequest};\n-use rustc::session::config::{RUST_CGU_EXT, Lto, Sanitizer};\n+use rustc::session::config::{RUST_CGU_EXT, Sanitizer};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n+use rustc::middle::cstore::NativeLibraryKind;\n use rustc::middle::dependency_format::Linkage;\n use rustc_codegen_ssa::CodegenResults;\n use rustc::util::common::{time, time_ext};\n@@ -28,14 +27,10 @@ use rustc_data_structures::fx::FxHashSet;\n use std::ascii;\n use std::char;\n use std::env;\n-use std::fmt;\n use std::fs;\n use std::io;\n-use std::iter;\n use std::path::{Path, PathBuf};\n-use std::process::{Output, Stdio};\n use std::str;\n-use syntax::attr;\n \n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                     invalid_output_for_target, filename_for_metadata,\n@@ -96,52 +91,6 @@ pub(crate) fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-/// Returns a boolean indicating whether we should preserve the object files on\n-/// the filesystem for their debug information. This is often useful with\n-/// split-dwarf like schemes.\n-fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n-    // If the objects don't have debuginfo there's nothing to preserve.\n-    if sess.opts.debuginfo == DebugInfo::None {\n-        return false\n-    }\n-\n-    // If we're only producing artifacts that are archives, no need to preserve\n-    // the objects as they're losslessly contained inside the archives.\n-    let output_linked = sess.crate_types.borrow()\n-        .iter()\n-        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n-    if !output_linked {\n-        return false\n-    }\n-\n-    // If we're on OSX then the equivalent of split dwarf is turned on by\n-    // default. The final executable won't actually have any debug information\n-    // except it'll have pointers to elsewhere. Historically we've always run\n-    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n-    // a bummer for incremental compilation! (the whole point of split dwarf is\n-    // that you don't do this sort of dwarf link).\n-    //\n-    // Basically as a result this just means that if we're on OSX and we're\n-    // *not* running dsymutil then the object files are the only source of truth\n-    // for debug information, so we must preserve them.\n-    if sess.target.target.options.is_like_osx {\n-        match sess.opts.debugging_opts.run_dsymutil {\n-            // dsymutil is not being run, preserve objects\n-            Some(false) => return true,\n-\n-            // dsymutil is being run, no need to preserve the objects\n-            Some(true) => return false,\n-\n-            // The default historical behavior was to always run dsymutil, so\n-            // we're preserving that temporarily, but we're likely to switch the\n-            // default soon.\n-            None => return false,\n-        }\n-    }\n-\n-    false\n-}\n-\n fn link_binary_output(sess: &Session,\n                       codegen_results: &CodegenResults,\n                       crate_type: config::CrateType,\n@@ -201,10 +150,6 @@ fn link_binary_output(sess: &Session,\n     out_filenames\n }\n \n-fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n-    sess.target_filesearch(PathKind::Native).search_path_dirs()\n-}\n-\n fn archive_config<'a>(sess: &'a Session,\n                       output: &Path,\n                       input: Option<&Path>) -> ArchiveConfig<'a> {\n@@ -415,53 +360,6 @@ fn link_staticlib(sess: &Session,\n     }\n }\n \n-fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n-    let lib_args: Vec<_> = all_native_libs.iter()\n-        .filter(|l| relevant_lib(sess, l))\n-        .filter_map(|lib| {\n-            let name = lib.name?;\n-            match lib.kind {\n-                NativeLibraryKind::NativeStaticNobundle |\n-                NativeLibraryKind::NativeUnknown => {\n-                    if sess.target.target.options.is_like_msvc {\n-                        Some(format!(\"{}.lib\", name))\n-                    } else {\n-                        Some(format!(\"-l{}\", name))\n-                    }\n-                },\n-                NativeLibraryKind::NativeFramework => {\n-                    // ld-only syntax, since there are no frameworks in MSVC\n-                    Some(format!(\"-framework {}\", name))\n-                },\n-                // These are included, no need to print them\n-                NativeLibraryKind::NativeStatic => None,\n-            }\n-        })\n-        .collect();\n-    if !lib_args.is_empty() {\n-        sess.note_without_error(\"Link against the following native artifacts when linking \\\n-                                 against this static library. The order and any duplication \\\n-                                 can be significant on some platforms.\");\n-        // Prefix for greppability\n-        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n-    }\n-}\n-\n-fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n-    let fs = sess.target_filesearch(PathKind::Native);\n-    let file_path = fs.get_lib_path().join(name);\n-    if file_path.exists() {\n-        return file_path\n-    }\n-    for search_path in fs.search_paths() {\n-        let file_path = search_path.dir.join(name);\n-        if file_path.exists() {\n-            return file_path\n-        }\n-    }\n-    PathBuf::from(name)\n-}\n-\n // Create a dynamic library or executable\n //\n // This will invoke the system linker/cc to create the resulting file. This\n@@ -706,147 +604,6 @@ fn link_natively(sess: &Session,\n     }\n }\n \n-fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n-    -> io::Result<Output>\n-{\n-    // When attempting to spawn the linker we run a risk of blowing out the\n-    // size limits for spawning a new process with respect to the arguments\n-    // we pass on the command line.\n-    //\n-    // Here we attempt to handle errors from the OS saying \"your list of\n-    // arguments is too big\" by reinvoking the linker again with an `@`-file\n-    // that contains all the arguments. The theory is that this is then\n-    // accepted on all linkers and the linker will read all its options out of\n-    // there instead of looking at the command line.\n-    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n-        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n-            Ok(child) => {\n-                let output = child.wait_with_output();\n-                flush_linked_file(&output, out_filename)?;\n-                return output;\n-            }\n-            Err(ref e) if command_line_too_big(e) => {\n-                info!(\"command line to linker was too big: {}\", e);\n-            }\n-            Err(e) => return Err(e)\n-        }\n-    }\n-\n-    info!(\"falling back to passing arguments to linker via an @-file\");\n-    let mut cmd2 = cmd.clone();\n-    let mut args = String::new();\n-    for arg in cmd2.take_args() {\n-        args.push_str(&Escape {\n-            arg: arg.to_str().unwrap(),\n-            is_like_msvc: sess.target.target.options.is_like_msvc,\n-        }.to_string());\n-        args.push_str(\"\\n\");\n-    }\n-    let file = tmpdir.join(\"linker-arguments\");\n-    let bytes = if sess.target.target.options.is_like_msvc {\n-        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n-        // start the stream with a UTF-16 BOM\n-        for c in iter::once(0xFEFF).chain(args.encode_utf16()) {\n-            // encode in little endian\n-            out.push(c as u8);\n-            out.push((c >> 8) as u8);\n-        }\n-        out\n-    } else {\n-        args.into_bytes()\n-    };\n-    fs::write(&file, &bytes)?;\n-    cmd2.arg(format!(\"@{}\", file.display()));\n-    info!(\"invoking linker {:?}\", cmd2);\n-    let output = cmd2.output();\n-    flush_linked_file(&output, out_filename)?;\n-    return output;\n-\n-    #[cfg(unix)]\n-    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n-    #[cfg(windows)]\n-    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n-        -> io::Result<()>\n-    {\n-        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n-        // even long after process exit, causing nasty, non-reproducible output bugs.\n-        //\n-        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n-        //\n-        // \u0410 full writeup of the original Chrome bug can be found at\n-        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n-\n-        if let &Ok(ref out) = command_output {\n-            if out.status.success() {\n-                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n-                    of.sync_all()?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[cfg(unix)]\n-    fn command_line_too_big(err: &io::Error) -> bool {\n-        err.raw_os_error() == Some(::libc::E2BIG)\n-    }\n-\n-    #[cfg(windows)]\n-    fn command_line_too_big(err: &io::Error) -> bool {\n-        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n-        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n-    }\n-\n-    struct Escape<'a> {\n-        arg: &'a str,\n-        is_like_msvc: bool,\n-    }\n-\n-    impl<'a> fmt::Display for Escape<'a> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            if self.is_like_msvc {\n-                // This is \"documented\" at\n-                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n-                //\n-                // Unfortunately there's not a great specification of the\n-                // syntax I could find online (at least) but some local\n-                // testing showed that this seemed sufficient-ish to catch\n-                // at least a few edge cases.\n-                write!(f, \"\\\"\")?;\n-                for c in self.arg.chars() {\n-                    match c {\n-                        '\"' => write!(f, \"\\\\{}\", c)?,\n-                        c => write!(f, \"{}\", c)?,\n-                    }\n-                }\n-                write!(f, \"\\\"\")?;\n-            } else {\n-                // This is documented at https://linux.die.net/man/1/ld, namely:\n-                //\n-                // > Options in file are separated by whitespace. A whitespace\n-                // > character may be included in an option by surrounding the\n-                // > entire option in either single or double quotes. Any\n-                // > character (including a backslash) may be included by\n-                // > prefixing the character to be included with a backslash.\n-                //\n-                // We put an argument on each line, so all we need to do is\n-                // ensure the line is interpreted as one whole argument.\n-                for c in self.arg.chars() {\n-                    match c {\n-                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n-                        c => write!(f, \"{}\", c)?,\n-                    }\n-                }\n-            }\n-            Ok(())\n-        }\n-    }\n-}\n-\n fn link_args(cmd: &mut dyn Linker,\n              flavor: LinkerFlavor,\n              sess: &Session,\n@@ -1051,48 +808,6 @@ fn link_args(cmd: &mut dyn Linker,\n     cmd.args(&used_link_args);\n }\n \n-// # Native library linking\n-//\n-// User-supplied library search paths (-L on the command line). These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n-//\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut dyn Linker,\n-                              sess: &Session,\n-                              codegen_results: &CodegenResults) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => { cmd.framework_path(&search_path.dir); }\n-            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)); }\n-        }\n-    }\n-\n-    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n-        relevant_lib(sess, l)\n-    });\n-\n-    let search_path = archive_search_paths(sess);\n-    for lib in relevant_libs {\n-        let name = match lib.name {\n-            Some(ref l) => l,\n-            None => continue,\n-        };\n-        match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n-                                                                        &search_path)\n-        }\n-    }\n-}\n-\n // # Rust Crate linking\n //\n // Rust crates are not considered at all when creating an rlib output. All\n@@ -1407,88 +1122,3 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n                             parent.unwrap_or(Path::new(\"\")));\n     }\n }\n-\n-// Link in all of our upstream crates' native dependencies. Remember that\n-// all of these upstream native dependencies are all non-static\n-// dependencies. We've got two cases then:\n-//\n-// 1. The upstream crate is an rlib. In this case we *must* link in the\n-// native dependency because the rlib is just an archive.\n-//\n-// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n-// have the dependency present on the system somewhere. Thus, we don't\n-// gain a whole lot from not linking in the dynamic dependency to this\n-// crate as well.\n-//\n-// The use case for this is a little subtle. In theory the native\n-// dependencies of a crate are purely an implementation detail of the crate\n-// itself, but the problem arises with generic and inlined functions. If a\n-// generic function calls a native function, then the generic function must\n-// be instantiated in the target crate, meaning that the native symbol must\n-// also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n-                                 sess: &Session,\n-                                 codegen_results: &CodegenResults,\n-                                 crate_type: config::CrateType) {\n-    // Be sure to use a topological sorting of crates because there may be\n-    // interdependencies between native libraries. When passing -nodefaultlibs,\n-    // for example, almost all native libraries depend on libc, so we have to\n-    // make sure that's all the way at the right (liblibc is near the base of\n-    // the dependency chain).\n-    //\n-    // This passes RequireStatic, but the actual requirement doesn't matter,\n-    // we're just getting an ordering of crate numbers, we're not worried about\n-    // the paths.\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n-\n-    let crates = &codegen_results.crate_info.used_crates_static;\n-    for &(cnum, _) in crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let name = match lib.name {\n-                Some(ref l) => l,\n-                None => continue,\n-            };\n-            if !relevant_lib(sess, &lib) {\n-                continue\n-            }\n-            match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-                NativeLibraryKind::NativeStaticNobundle => {\n-                    // Link \"static-nobundle\" native libs only if the crate they originate from\n-                    // is being linked statically to the current crate.  If it's linked dynamically\n-                    // or is an rlib already included via some other dylib crate, the symbols from\n-                    // native libs will have already been included in that dylib.\n-                    if data[cnum.as_usize() - 1] == Linkage::Static {\n-                        cmd.link_staticlib(&name.as_str())\n-                    }\n-                },\n-                // ignore statically included native libraries here as we've\n-                // already included them when we included the rust library\n-                // previously\n-                NativeLibraryKind::NativeStatic => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n-    match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n-        None => true,\n-    }\n-}\n-\n-fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n-    match sess.lto() {\n-        Lto::Fat => true,\n-        Lto::Thin => {\n-            // If we defer LTO to the linker, we haven't run LTO ourselves, so\n-            // any upstream object files have not been copied yet.\n-            !sess.opts.cg.linker_plugin_lto.enabled()\n-        }\n-        Lto::No |\n-        Lto::ThinLocal => false,\n-    }\n-}"}, {"sha": "3d7ca251fcf3d75a1df3aac65f9408d8e132932f", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 379, "deletions": 2, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/8a8837967f2877f92ff07f57c237e1963dc99455/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8837967f2877f92ff07f57c237e1963dc99455/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=8a8837967f2877f92ff07f57c237e1963dc99455", "patch": "@@ -4,18 +4,25 @@\n use rustc::session::{Session, config};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::cstore::LibSource;\n+use rustc::middle::cstore::{LibSource, NativeLibrary, NativeLibraryKind};\n use rustc_target::spec::LinkerFlavor;\n use rustc::hir::def_id::CrateNum;\n+use rustc_fs_util::fix_windows_verbatim_for_gcc;\n \n use super::command::Command;\n-use crate::CrateInfo;\n+use crate::{CrateInfo, CodegenResults};\n+use crate::back::linker::Linker;\n \n use cc::windows_registry;\n+use std::fmt;\n use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n+use std::process::{Output, Stdio};\n use std::env;\n \n+pub use rustc_codegen_utils::link::*;\n+\n pub fn remove(sess: &Session, path: &Path) {\n     if let Err(e) = fs::remove_file(path) {\n         sess.err(&format!(\"failed to remove {}: {}\",\n@@ -200,3 +207,373 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     bug!(\"Not enough information provided to determine how to invoke the linker\");\n }\n+\n+/// Returns a boolean indicating whether we should preserve the object files on\n+/// the filesystem for their debug information. This is often useful with\n+/// split-dwarf like schemes.\n+pub fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+    // If the objects don't have debuginfo there's nothing to preserve.\n+    if sess.opts.debuginfo == config::DebugInfo::None {\n+        return false\n+    }\n+\n+    // If we're only producing artifacts that are archives, no need to preserve\n+    // the objects as they're losslessly contained inside the archives.\n+    let output_linked = sess.crate_types.borrow()\n+        .iter()\n+        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n+    if !output_linked {\n+        return false\n+    }\n+\n+    // If we're on OSX then the equivalent of split dwarf is turned on by\n+    // default. The final executable won't actually have any debug information\n+    // except it'll have pointers to elsewhere. Historically we've always run\n+    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n+    // a bummer for incremental compilation! (the whole point of split dwarf is\n+    // that you don't do this sort of dwarf link).\n+    //\n+    // Basically as a result this just means that if we're on OSX and we're\n+    // *not* running dsymutil then the object files are the only source of truth\n+    // for debug information, so we must preserve them.\n+    if sess.target.target.options.is_like_osx {\n+        match sess.opts.debugging_opts.run_dsymutil {\n+            // dsymutil is not being run, preserve objects\n+            Some(false) => return true,\n+\n+            // dsymutil is being run, no need to preserve the objects\n+            Some(true) => return false,\n+\n+            // The default historical behavior was to always run dsymutil, so\n+            // we're preserving that temporarily, but we're likely to switch the\n+            // default soon.\n+            None => return false,\n+        }\n+    }\n+\n+    false\n+}\n+\n+pub fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n+    sess.target_filesearch(PathKind::Native).search_path_dirs()\n+}\n+\n+enum RlibFlavor {\n+    Normal,\n+    StaticlibBase,\n+}\n+\n+pub fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n+    let lib_args: Vec<_> = all_native_libs.iter()\n+        .filter(|l| relevant_lib(sess, l))\n+        .filter_map(|lib| {\n+            let name = lib.name?;\n+            match lib.kind {\n+                NativeLibraryKind::NativeStaticNobundle |\n+                NativeLibraryKind::NativeUnknown => {\n+                    if sess.target.target.options.is_like_msvc {\n+                        Some(format!(\"{}.lib\", name))\n+                    } else {\n+                        Some(format!(\"-l{}\", name))\n+                    }\n+                },\n+                NativeLibraryKind::NativeFramework => {\n+                    // ld-only syntax, since there are no frameworks in MSVC\n+                    Some(format!(\"-framework {}\", name))\n+                },\n+                // These are included, no need to print them\n+                NativeLibraryKind::NativeStatic => None,\n+            }\n+        })\n+        .collect();\n+    if !lib_args.is_empty() {\n+        sess.note_without_error(\"Link against the following native artifacts when linking \\\n+                                 against this static library. The order and any duplication \\\n+                                 can be significant on some platforms.\");\n+        // Prefix for greppability\n+        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n+    }\n+}\n+\n+pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n+    let fs = sess.target_filesearch(PathKind::Native);\n+    let file_path = fs.get_lib_path().join(name);\n+    if file_path.exists() {\n+        return file_path\n+    }\n+    for search_path in fs.search_paths() {\n+        let file_path = search_path.dir.join(name);\n+        if file_path.exists() {\n+            return file_path\n+        }\n+    }\n+    PathBuf::from(name)\n+}\n+\n+pub fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n+    -> io::Result<Output>\n+{\n+    // When attempting to spawn the linker we run a risk of blowing out the\n+    // size limits for spawning a new process with respect to the arguments\n+    // we pass on the command line.\n+    //\n+    // Here we attempt to handle errors from the OS saying \"your list of\n+    // arguments is too big\" by reinvoking the linker again with an `@`-file\n+    // that contains all the arguments. The theory is that this is then\n+    // accepted on all linkers and the linker will read all its options out of\n+    // there instead of looking at the command line.\n+    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n+        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n+            Ok(child) => {\n+                let output = child.wait_with_output();\n+                flush_linked_file(&output, out_filename)?;\n+                return output;\n+            }\n+            Err(ref e) if command_line_too_big(e) => {\n+                info!(\"command line to linker was too big: {}\", e);\n+            }\n+            Err(e) => return Err(e)\n+        }\n+    }\n+\n+    info!(\"falling back to passing arguments to linker via an @-file\");\n+    let mut cmd2 = cmd.clone();\n+    let mut args = String::new();\n+    for arg in cmd2.take_args() {\n+        args.push_str(&Escape {\n+            arg: arg.to_str().unwrap(),\n+            is_like_msvc: sess.target.target.options.is_like_msvc,\n+        }.to_string());\n+        args.push_str(\"\\n\");\n+    }\n+    let file = tmpdir.join(\"linker-arguments\");\n+    let bytes = if sess.target.target.options.is_like_msvc {\n+        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n+        // start the stream with a UTF-16 BOM\n+        for c in std::iter::once(0xFEFF).chain(args.encode_utf16()) {\n+            // encode in little endian\n+            out.push(c as u8);\n+            out.push((c >> 8) as u8);\n+        }\n+        out\n+    } else {\n+        args.into_bytes()\n+    };\n+    fs::write(&file, &bytes)?;\n+    cmd2.arg(format!(\"@{}\", file.display()));\n+    info!(\"invoking linker {:?}\", cmd2);\n+    let output = cmd2.output();\n+    flush_linked_file(&output, out_filename)?;\n+    return output;\n+\n+    #[cfg(unix)]\n+    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    #[cfg(windows)]\n+    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n+        -> io::Result<()>\n+    {\n+        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n+        // even long after process exit, causing nasty, non-reproducible output bugs.\n+        //\n+        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n+        //\n+        // \u0410 full writeup of the original Chrome bug can be found at\n+        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n+\n+        if let &Ok(ref out) = command_output {\n+            if out.status.success() {\n+                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n+                    of.sync_all()?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[cfg(unix)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(::libc::E2BIG)\n+    }\n+\n+    #[cfg(windows)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n+        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n+    }\n+\n+    struct Escape<'a> {\n+        arg: &'a str,\n+        is_like_msvc: bool,\n+    }\n+\n+    impl<'a> fmt::Display for Escape<'a> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            if self.is_like_msvc {\n+                // This is \"documented\" at\n+                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n+                //\n+                // Unfortunately there's not a great specification of the\n+                // syntax I could find online (at least) but some local\n+                // testing showed that this seemed sufficient-ish to catch\n+                // at least a few edge cases.\n+                write!(f, \"\\\"\")?;\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\"' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+                write!(f, \"\\\"\")?;\n+            } else {\n+                // This is documented at https://linux.die.net/man/1/ld, namely:\n+                //\n+                // > Options in file are separated by whitespace. A whitespace\n+                // > character may be included in an option by surrounding the\n+                // > entire option in either single or double quotes. Any\n+                // > character (including a backslash) may be included by\n+                // > prefixing the character to be included with a backslash.\n+                //\n+                // We put an argument on each line, so all we need to do is\n+                // ensure the line is interpreted as one whole argument.\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+            }\n+            Ok(())\n+        }\n+    }\n+}\n+\n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the command line). These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n+                              sess: &Session,\n+                              codegen_results: &CodegenResults) {\n+    let filesearch = sess.target_filesearch(PathKind::All);\n+    for search_path in filesearch.search_paths() {\n+        match search_path.kind {\n+            PathKind::Framework => { cmd.framework_path(&search_path.dir); }\n+            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)); }\n+        }\n+    }\n+\n+    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n+        relevant_lib(sess, l)\n+    });\n+\n+    let search_path = archive_search_paths(sess);\n+    for lib in relevant_libs {\n+        let name = match lib.name {\n+            Some(ref l) => l,\n+            None => continue,\n+        };\n+        match lib.kind {\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n+                                                                        &search_path)\n+        }\n+    }\n+}\n+\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native dependencies are all non-static\n+// dependencies. We've got two cases then:\n+//\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+// native dependency because the rlib is just an archive.\n+//\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+// have the dependency present on the system somewhere. Thus, we don't\n+// gain a whole lot from not linking in the dynamic dependency to this\n+// crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate are purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n+                                 sess: &Session,\n+                                 codegen_results: &CodegenResults,\n+                                 crate_type: config::CrateType) {\n+    // Be sure to use a topological sorting of crates because there may be\n+    // interdependencies between native libraries. When passing -nodefaultlibs,\n+    // for example, almost all native libraries depend on libc, so we have to\n+    // make sure that's all the way at the right (liblibc is near the base of\n+    // the dependency chain).\n+    //\n+    // This passes RequireStatic, but the actual requirement doesn't matter,\n+    // we're just getting an ordering of crate numbers, we're not worried about\n+    // the paths.\n+    let formats = sess.dependency_formats.borrow();\n+    let data = formats.get(&crate_type).unwrap();\n+\n+    let crates = &codegen_results.crate_info.used_crates_static;\n+    for &(cnum, _) in crates {\n+        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n+            let name = match lib.name {\n+                Some(ref l) => l,\n+                None => continue,\n+            };\n+            if !relevant_lib(sess, &lib) {\n+                continue\n+            }\n+            match lib.kind {\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+                NativeLibraryKind::NativeStaticNobundle => {\n+                    // Link \"static-nobundle\" native libs only if the crate they originate from\n+                    // is being linked statically to the current crate.  If it's linked dynamically\n+                    // or is an rlib already included via some other dylib crate, the symbols from\n+                    // native libs will have already been included in that dylib.\n+                    if data[cnum.as_usize() - 1] == Linkage::Static {\n+                        cmd.link_staticlib(&name.as_str())\n+                    }\n+                },\n+                // ignore statically included native libraries here as we've\n+                // already included them when we included the rust library\n+                // previously\n+                NativeLibraryKind::NativeStatic => {}\n+            }\n+        }\n+    }\n+}\n+\n+pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => syntax::attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}\n+\n+pub fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+    match sess.lto() {\n+        config::Lto::Fat => true,\n+        config::Lto::Thin => {\n+            // If we defer LTO to the linker, we haven't run LTO ourselves, so\n+            // any upstream object files have not been copied yet.\n+            !sess.opts.cg.linker_plugin_lto.enabled()\n+        }\n+        config::Lto::No |\n+        config::Lto::ThinLocal => false,\n+    }\n+}"}]}