{"sha": "17064dae1a91fb7a96f68508a052826d0f4e1d8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MDY0ZGFlMWE5MWZiN2E5NmY2ODUwOGEwNTI4MjZkMGY0ZTFkOGE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-19T16:15:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T16:15:04Z"}, "message": "Rollup merge of #73257 - davidtwco:issue-73249-improper-ctypes-projection, r=lcnr,varkor\n\nty: projections in `transparent_newtype_field`\n\nFixes #73249.\n\nThis PR modifies `transparent_newtype_field` so that it handles\nprojections with generic parameters, where `normalize_erasing_regions`\nwould ICE.", "tree": {"sha": "0f8ad66699dfbed576e90c94784afb88e85a33ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f8ad66699dfbed576e90c94784afb88e85a33ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17064dae1a91fb7a96f68508a052826d0f4e1d8a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7OSICRBK7hj4Ov3rIwAAdHIIAKrmvLEoFKsbpBNVqZJvLH8c\ns/n/wri7nJhrhxxgf6lczJ1zL8JZ5msQuQit/x7ggVaMoD/HDI1G98KKOJiWYZSr\nfFfjP/leYJ9gt+UhP1IwW9oq7Ks2jbcIOfRjHa2+d4A+3cOEn1x4otGaJEEmZpCq\nrr1ozdFQ5eZJR/0yFeUAAqlc+5fwx8TeY8kKjJoKQt+hu5DPaawVssB2N7HCZcfK\nwlFaq5djejBZqm41Cwn066L9YSmzE6hZvo8Z7C6OnWkcLhYTPjlF12Ht+rJYLOSo\nchMd1tyh3n3YqbN/9nZhFib+u4j48qhTBKhHEbulc/C6ZI/eMp4TP95XWSQT5Zw=\n=ivRs\n-----END PGP SIGNATURE-----\n", "payload": "tree 0f8ad66699dfbed576e90c94784afb88e85a33ce\nparent 186640a158d732ec6de0a0a9dc79803c47be551d\nparent a730d888aee99f9a556dae799deadacb83c34d0e\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592583304 -0700\ncommitter GitHub <noreply@github.com> 1592583304 -0700\n\nRollup merge of #73257 - davidtwco:issue-73249-improper-ctypes-projection, r=lcnr,varkor\n\nty: projections in `transparent_newtype_field`\n\nFixes #73249.\n\nThis PR modifies `transparent_newtype_field` so that it handles\nprojections with generic parameters, where `normalize_erasing_regions`\nwould ICE.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17064dae1a91fb7a96f68508a052826d0f4e1d8a", "html_url": "https://github.com/rust-lang/rust/commit/17064dae1a91fb7a96f68508a052826d0f4e1d8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17064dae1a91fb7a96f68508a052826d0f4e1d8a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "186640a158d732ec6de0a0a9dc79803c47be551d", "url": "https://api.github.com/repos/rust-lang/rust/commits/186640a158d732ec6de0a0a9dc79803c47be551d", "html_url": "https://github.com/rust-lang/rust/commit/186640a158d732ec6de0a0a9dc79803c47be551d"}, {"sha": "a730d888aee99f9a556dae799deadacb83c34d0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a730d888aee99f9a556dae799deadacb83c34d0e", "html_url": "https://github.com/rust-lang/rust/commit/a730d888aee99f9a556dae799deadacb83c34d0e"}], "stats": {"total": 458, "additions": 299, "deletions": 159}, "files": [{"sha": "d92c1131ff9fd0a8a9ac1a31accf17a3a643a646", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 104, "deletions": 136, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -11,7 +11,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -507,7 +507,7 @@ struct ImproperCTypesVisitor<'a, 'tcx> {\n enum FfiResult<'tcx> {\n     FfiSafe,\n     FfiPhantom(Ty<'tcx>),\n-    FfiUnsafe { ty: Ty<'tcx>, reason: &'static str, help: Option<&'static str> },\n+    FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -597,6 +597,66 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n+    /// Checks if the given field's type is \"ffi-safe\".\n+    fn check_field_type_for_ffi(\n+        &self,\n+        cache: &mut FxHashSet<Ty<'tcx>>,\n+        field: &ty::FieldDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> FfiResult<'tcx> {\n+        let field_ty = field.ty(self.cx.tcx, substs);\n+        if field_ty.has_opaque_types() {\n+            self.check_type_for_ffi(cache, field_ty)\n+        } else {\n+            let field_ty = self.cx.tcx.normalize_erasing_regions(self.cx.param_env, field_ty);\n+            self.check_type_for_ffi(cache, field_ty)\n+        }\n+    }\n+\n+    /// Checks if the given `VariantDef`'s field types are \"ffi-safe\".\n+    fn check_variant_for_ffi(\n+        &self,\n+        cache: &mut FxHashSet<Ty<'tcx>>,\n+        ty: Ty<'tcx>,\n+        def: &ty::AdtDef,\n+        variant: &ty::VariantDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> FfiResult<'tcx> {\n+        use FfiResult::*;\n+\n+        if def.repr.transparent() {\n+            // Can assume that only one field is not a ZST, so only check\n+            // that field's type for FFI-safety.\n+            if let Some(field) = variant.transparent_newtype_field(self.cx.tcx) {\n+                self.check_field_type_for_ffi(cache, field, substs)\n+            } else {\n+                bug!(\"malformed transparent type\");\n+            }\n+        } else {\n+            // We can't completely trust repr(C) markings; make sure the fields are\n+            // actually safe.\n+            let mut all_phantom = !variant.fields.is_empty();\n+            for field in &variant.fields {\n+                match self.check_field_type_for_ffi(cache, &field, substs) {\n+                    FfiSafe => {\n+                        all_phantom = false;\n+                    }\n+                    FfiPhantom(..) if def.is_enum() => {\n+                        return FfiUnsafe {\n+                            ty,\n+                            reason: \"this enum contains a PhantomData field\".into(),\n+                            help: None,\n+                        };\n+                    }\n+                    FfiPhantom(..) => {}\n+                    r => return r,\n+                }\n+            }\n+\n+            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+        }\n+    }\n+\n     /// Checks if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n     fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult<'tcx> {\n@@ -618,15 +678,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     return FfiPhantom(ty);\n                 }\n                 match def.adt_kind() {\n-                    AdtKind::Struct => {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        let kind = if def.is_struct() { \"struct\" } else { \"union\" };\n+\n                         if !def.repr.c() && !def.repr.transparent() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this struct has unspecified layout\",\n-                                help: Some(\n+                                reason: format!(\"this {} has unspecified layout\", kind),\n+                                help: Some(format!(\n                                     \"consider adding a `#[repr(C)]` or \\\n-                                            `#[repr(transparent)]` attribute to this struct\",\n-                                ),\n+                                             `#[repr(transparent)]` attribute to this {}\",\n+                                    kind\n+                                )),\n                             };\n                         }\n \n@@ -635,101 +698,20 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if is_non_exhaustive && !def.did.is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this struct is non-exhaustive\",\n+                                reason: format!(\"this {} is non-exhaustive\", kind),\n                                 help: None,\n                             };\n                         }\n \n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this struct has no fields\",\n-                                help: Some(\"consider adding a member to this struct\"),\n-                            };\n-                        }\n-\n-                        if def.repr.transparent() {\n-                            // Can assume that only one field is not a ZST, so only check\n-                            // that field's type for FFI-safety.\n-                            if let Some(field) =\n-                                def.transparent_newtype_field(cx, self.cx.param_env)\n-                            {\n-                                let field_ty = cx.normalize_erasing_regions(\n-                                    self.cx.param_env,\n-                                    field.ty(cx, substs),\n-                                );\n-                                self.check_type_for_ffi(cache, field_ty)\n-                            } else {\n-                                FfiSafe\n-                            }\n-                        } else {\n-                            // We can't completely trust repr(C) markings; make sure the fields are\n-                            // actually safe.\n-                            let mut all_phantom = true;\n-                            for field in &def.non_enum_variant().fields {\n-                                let field_ty = cx.normalize_erasing_regions(\n-                                    self.cx.param_env,\n-                                    field.ty(cx, substs),\n-                                );\n-                                let r = self.check_type_for_ffi(cache, field_ty);\n-                                match r {\n-                                    FfiSafe => {\n-                                        all_phantom = false;\n-                                    }\n-                                    FfiPhantom(..) => {}\n-                                    FfiUnsafe { .. } => {\n-                                        return r;\n-                                    }\n-                                }\n-                            }\n-\n-                            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n-                        }\n-                    }\n-                    AdtKind::Union => {\n-                        if !def.repr.c() && !def.repr.transparent() {\n-                            return FfiUnsafe {\n-                                ty,\n-                                reason: \"this union has unspecified layout\",\n-                                help: Some(\n-                                    \"consider adding a `#[repr(C)]` or \\\n-                                            `#[repr(transparent)]` attribute to this union\",\n-                                ),\n-                            };\n-                        }\n-\n-                        if def.non_enum_variant().fields.is_empty() {\n-                            return FfiUnsafe {\n-                                ty,\n-                                reason: \"this union has no fields\",\n-                                help: Some(\"consider adding a field to this union\"),\n+                                reason: format!(\"this {} has no fields\", kind),\n+                                help: Some(format!(\"consider adding a member to this {}\", kind)),\n                             };\n                         }\n \n-                        let mut all_phantom = true;\n-                        for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.normalize_erasing_regions(\n-                                ParamEnv::reveal_all(),\n-                                field.ty(cx, substs),\n-                            );\n-                            // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n-                            // PhantomData -- skip checking all ZST fields.\n-                            if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n-                                continue;\n-                            }\n-                            let r = self.check_type_for_ffi(cache, field_ty);\n-                            match r {\n-                                FfiSafe => {\n-                                    all_phantom = false;\n-                                }\n-                                FfiPhantom(..) => {}\n-                                FfiUnsafe { .. } => {\n-                                    return r;\n-                                }\n-                            }\n-                        }\n-\n-                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                        self.check_variant_for_ffi(cache, ty, def, def.non_enum_variant(), substs)\n                     }\n                     AdtKind::Enum => {\n                         if def.variants.is_empty() {\n@@ -744,11 +726,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if !is_repr_nullable_ptr(cx, ty, def, substs) {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"enum has no representation hint\",\n+                                    reason: \"enum has no representation hint\".into(),\n                                     help: Some(\n                                         \"consider adding a `#[repr(C)]`, \\\n                                                 `#[repr(transparent)]`, or integer `#[repr(...)]` \\\n-                                                attribute to this enum\",\n+                                                attribute to this enum\"\n+                                            .into(),\n                                     ),\n                                 };\n                             }\n@@ -757,7 +740,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if def.is_variant_list_non_exhaustive() && !def.did.is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this enum is non-exhaustive\",\n+                                reason: \"this enum is non-exhaustive\".into(),\n                                 help: None,\n                             };\n                         }\n@@ -768,51 +751,31 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"this enum has non-exhaustive variants\",\n+                                    reason: \"this enum has non-exhaustive variants\".into(),\n                                     help: None,\n                                 };\n                             }\n \n-                            for field in &variant.fields {\n-                                let field_ty = cx.normalize_erasing_regions(\n-                                    ParamEnv::reveal_all(),\n-                                    field.ty(cx, substs),\n-                                );\n-                                // repr(transparent) types are allowed to have arbitrary ZSTs, not\n-                                // just PhantomData -- skip checking all ZST fields.\n-                                if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n-                                    continue;\n-                                }\n-                                let r = self.check_type_for_ffi(cache, field_ty);\n-                                match r {\n-                                    FfiSafe => {}\n-                                    FfiUnsafe { .. } => {\n-                                        return r;\n-                                    }\n-                                    FfiPhantom(..) => {\n-                                        return FfiUnsafe {\n-                                            ty,\n-                                            reason: \"this enum contains a PhantomData field\",\n-                                            help: None,\n-                                        };\n-                                    }\n-                                }\n+                            match self.check_variant_for_ffi(cache, ty, def, variant, substs) {\n+                                FfiSafe => (),\n+                                r => return r,\n                             }\n                         }\n+\n                         FfiSafe\n                     }\n                 }\n             }\n \n             ty::Char => FfiUnsafe {\n                 ty,\n-                reason: \"the `char` type has no C equivalent\",\n-                help: Some(\"consider using `u32` or `libc::wchar_t` instead\"),\n+                reason: \"the `char` type has no C equivalent\".into(),\n+                help: Some(\"consider using `u32` or `libc::wchar_t` instead\".into()),\n             },\n \n             ty::Int(ast::IntTy::I128) | ty::Uint(ast::UintTy::U128) => FfiUnsafe {\n                 ty,\n-                reason: \"128-bit integers don't currently have a known stable ABI\",\n+                reason: \"128-bit integers don't currently have a known stable ABI\".into(),\n                 help: None,\n             },\n \n@@ -821,24 +784,24 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Slice(_) => FfiUnsafe {\n                 ty,\n-                reason: \"slices have no C equivalent\",\n-                help: Some(\"consider using a raw pointer instead\"),\n+                reason: \"slices have no C equivalent\".into(),\n+                help: Some(\"consider using a raw pointer instead\".into()),\n             },\n \n             ty::Dynamic(..) => {\n-                FfiUnsafe { ty, reason: \"trait objects have no C equivalent\", help: None }\n+                FfiUnsafe { ty, reason: \"trait objects have no C equivalent\".into(), help: None }\n             }\n \n             ty::Str => FfiUnsafe {\n                 ty,\n-                reason: \"string slices have no C equivalent\",\n-                help: Some(\"consider using `*const u8` and a length instead\"),\n+                reason: \"string slices have no C equivalent\".into(),\n+                help: Some(\"consider using `*const u8` and a length instead\".into()),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n                 ty,\n-                reason: \"tuples have unspecified layout\",\n-                help: Some(\"consider using a struct instead\"),\n+                reason: \"tuples have unspecified layout\".into(),\n+                help: Some(\"consider using a struct instead\".into()),\n             },\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n@@ -852,10 +815,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: \"this function pointer has Rust-specific calling convention\",\n+                            reason: \"this function pointer has Rust-specific calling convention\"\n+                                .into(),\n                             help: Some(\n                                 \"consider using an `extern fn(...) -> ...` \\\n-                                        function pointer instead\",\n+                                        function pointer instead\"\n+                                    .into(),\n                             ),\n                         };\n                     }\n@@ -886,6 +851,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Foreign(..) => FfiSafe,\n \n+            // While opaque types are checked for earlier, if a projection in a struct field\n+            // normalizes to an opaque type, then it will reach this branch.\n+            ty::Opaque(..) => {\n+                FfiUnsafe { ty, reason: \"opaque types have no C equivalent\".into(), help: None }\n+            }\n+\n             ty::Param(..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n@@ -895,7 +866,6 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             | ty::GeneratorWitness(..)\n             | ty::Placeholder(..)\n             | ty::Projection(..)\n-            | ty::Opaque(..)\n             | ty::FnDef(..) => bug!(\"unexpected type in foreign function: {:?}\", ty),\n         }\n     }\n@@ -925,8 +895,6 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n-        use rustc_middle::ty::TypeFoldable;\n-\n         struct ProhibitOpaqueTypes<'tcx> {\n             ty: Option<Ty<'tcx>>,\n         };\n@@ -993,7 +961,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // argument, which after substitution, is `()`, then this branch can be hit.\n             FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n+                self.emit_ffi_unsafe_type_lint(ty, sp, &reason, help.as_deref());\n             }\n         }\n     }"}, {"sha": "b4e3e6ab5ab7e7ca5d095f0699bc3468fed99b08", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -1807,6 +1807,19 @@ impl<'tcx> VariantDef {\n     pub fn is_field_list_non_exhaustive(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n     }\n+\n+    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+    /// field.\n+    pub fn transparent_newtype_field(&self, tcx: TyCtxt<'tcx>) -> Option<&FieldDef> {\n+        for field in &self.fields {\n+            let field_ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.def_id));\n+            if !field_ty.is_zst(tcx, self.def_id) {\n+                return Some(field);\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2376,29 +2389,6 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n-\n-    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n-    /// field.\n-    pub fn transparent_newtype_field(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-    ) -> Option<&FieldDef> {\n-        assert!(self.is_struct() && self.repr.transparent());\n-\n-        for field in &self.non_enum_variant().fields {\n-            let field_ty = tcx.normalize_erasing_regions(\n-                param_env,\n-                field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.did)),\n-            );\n-\n-            if !field_ty.is_zst(tcx, self.did) {\n-                return Some(field);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n impl<'tcx> FieldDef {"}, {"sha": "cf416c3fe8b12a85aca5507bff6a37ed532157ff", "filename": "src/test/ui/lint/lint-ctypes-73249-1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-1.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+#![deny(improper_ctypes)]\n+\n+pub trait Foo {\n+    type Assoc: 'static;\n+}\n+\n+impl Foo for () {\n+    type Assoc = u32;\n+}\n+\n+extern \"C\" {\n+    pub fn lint_me(x: Bar<()>);\n+}\n+\n+#[repr(transparent)]\n+pub struct Bar<T: Foo> {\n+    value: &'static <T as Foo>::Assoc,\n+}\n+\n+fn main() {}"}, {"sha": "86cc5e2c31e8170014f5c25081af499220217e29", "filename": "src/test/ui/lint/lint-ctypes-73249-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,29 @@\n+#![feature(type_alias_impl_trait)]\n+#![deny(improper_ctypes)]\n+\n+pub trait Baz { }\n+\n+impl Baz for () { }\n+\n+type Qux = impl Baz;\n+\n+fn assign() -> Qux {}\n+\n+pub trait Foo {\n+    type Assoc: 'static;\n+}\n+\n+impl Foo for () {\n+    type Assoc = Qux;\n+}\n+\n+#[repr(transparent)]\n+pub struct A<T: Foo> {\n+    x: &'static <T as Foo>::Assoc,\n+}\n+\n+extern \"C\" {\n+    pub fn lint_me() -> A<()>; //~ ERROR: uses type `impl Baz`\n+}\n+\n+fn main() {}"}, {"sha": "36dbe3217d75ada5d0e445ea6b3f217c669109cf", "filename": "src/test/ui/lint/lint-ctypes-73249-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,15 @@\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+  --> $DIR/lint-ctypes-73249-2.rs:26:25\n+   |\n+LL |     pub fn lint_me() -> A<()>;\n+   |                         ^^^^^ not FFI-safe\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-ctypes-73249-2.rs:2:9\n+   |\n+LL | #![deny(improper_ctypes)]\n+   |         ^^^^^^^^^^^^^^^\n+   = note: opaque types have no C equivalent\n+\n+error: aborting due to previous error\n+"}, {"sha": "25c4e7c92a854f303933b1899efa950fa131bbc2", "filename": "src/test/ui/lint/lint-ctypes-73249-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+#![deny(improper_ctypes)]\n+\n+pub trait Baz { }\n+\n+impl Baz for u32 { }\n+\n+type Qux = impl Baz;\n+\n+fn assign() -> Qux { 3 }\n+\n+#[repr(C)]\n+pub struct A {\n+    x: Qux,\n+}\n+\n+extern \"C\" {\n+    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n+}\n+\n+fn main() {}"}, {"sha": "7d133287bd73e9468ebccc804cb3b5d966f5be54", "filename": "src/test/ui/lint/lint-ctypes-73249-3.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,15 @@\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+  --> $DIR/lint-ctypes-73249-3.rs:18:25\n+   |\n+LL |     pub fn lint_me() -> A;\n+   |                         ^ not FFI-safe\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-ctypes-73249-3.rs:2:9\n+   |\n+LL | #![deny(improper_ctypes)]\n+   |         ^^^^^^^^^^^^^^^\n+   = note: opaque types have no C equivalent\n+\n+error: aborting due to previous error\n+"}, {"sha": "6c72bd691b17cf5a22f291265bc237b0c96f78d3", "filename": "src/test/ui/lint/lint-ctypes-73249-4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-4.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+#![deny(improper_ctypes)]\n+\n+use std::marker::PhantomData;\n+\n+trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for () {\n+    type Assoc = PhantomData<()>;\n+}\n+\n+#[repr(transparent)]\n+struct Wow<T> where T: Foo<Assoc = PhantomData<T>> {\n+    x: <T as Foo>::Assoc,\n+    v: u32,\n+}\n+\n+extern \"C\" {\n+    fn test(v: Wow<()>);\n+}\n+\n+fn main() {}"}, {"sha": "61e46983ede65479cf3b051a82245ab962dde4dd", "filename": "src/test/ui/lint/lint-ctypes-73249-5.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+#![deny(improper_ctypes)]\n+\n+pub trait Baz { }\n+\n+impl Baz for u32 { }\n+\n+type Qux = impl Baz;\n+\n+fn assign() -> Qux { 3 }\n+\n+#[repr(transparent)]\n+pub struct A {\n+    x: Qux,\n+}\n+\n+extern \"C\" {\n+    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n+}\n+\n+fn main() {}"}, {"sha": "d2780cb60e7dd11b1af1587eb7281a08c058dc36", "filename": "src/test/ui/lint/lint-ctypes-73249-5.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,15 @@\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+  --> $DIR/lint-ctypes-73249-5.rs:18:25\n+   |\n+LL |     pub fn lint_me() -> A;\n+   |                         ^ not FFI-safe\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-ctypes-73249-5.rs:2:9\n+   |\n+LL | #![deny(improper_ctypes)]\n+   |         ^^^^^^^^^^^^^^^\n+   = note: opaque types have no C equivalent\n+\n+error: aborting due to previous error\n+"}, {"sha": "5b48fa9b7376f50d33156c61ca8ddccc8a1be234", "filename": "src/test/ui/lint/lint-ctypes-73249.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17064dae1a91fb7a96f68508a052826d0f4e1d8a/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249.rs?ref=17064dae1a91fb7a96f68508a052826d0f4e1d8a", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+#![deny(improper_ctypes)]\n+\n+pub trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for () {\n+    type Assoc = u32;\n+}\n+\n+extern \"C\" {\n+    pub fn lint_me(x: Bar<()>);\n+}\n+\n+#[repr(transparent)]\n+pub struct Bar<T: Foo> {\n+    value: <T as Foo>::Assoc,\n+}\n+\n+fn main() {}"}]}