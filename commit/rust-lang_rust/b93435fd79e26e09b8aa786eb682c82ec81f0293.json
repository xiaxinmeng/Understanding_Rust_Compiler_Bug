{"sha": "b93435fd79e26e09b8aa786eb682c82ec81f0293", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MzQzNWZkNzllMjZlMDliOGFhNzg2ZWI2ODJjODJlYzgxZjAyOTM=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-09T16:13:20Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-09-05T04:19:07Z"}, "message": "Remove most uses of expr_ty", "tree": {"sha": "8400c78a2d1a7e11fb6c71ae3a0f39ec7393cb07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8400c78a2d1a7e11fb6c71ae3a0f39ec7393cb07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b93435fd79e26e09b8aa786eb682c82ec81f0293", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b93435fd79e26e09b8aa786eb682c82ec81f0293", "html_url": "https://github.com/rust-lang/rust/commit/b93435fd79e26e09b8aa786eb682c82ec81f0293", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b93435fd79e26e09b8aa786eb682c82ec81f0293/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ddf060b6d347f89afb584501c86a4fa96ec7acc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ddf060b6d347f89afb584501c86a4fa96ec7acc", "html_url": "https://github.com/rust-lang/rust/commit/0ddf060b6d347f89afb584501c86a4fa96ec7acc"}], "stats": {"total": 116, "additions": 47, "deletions": 69}, "files": [{"sha": "2bb0abfab4ee7a3ae9abe28c4ff6ee9d791e69cd", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b93435fd79e26e09b8aa786eb682c82ec81f0293", "patch": "@@ -37,12 +37,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.write_ty(pat.id, expected);\n             }\n             PatKind::Lit(ref lt) => {\n-                self.check_expr(&lt);\n-                let expr_ty = self.expr_ty(&lt);\n+                let expr_t = self.check_expr(&lt);\n \n                 // Byte string patterns behave the same way as array patterns\n                 // They can denote both statically and dynamically sized byte arrays\n-                let mut pat_ty = expr_ty;\n+                let mut pat_ty = expr_t;\n                 if let hir::ExprLit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n@@ -63,7 +62,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // relation at all but rather that there exists a LUB (so\n                 // that they can be compared). However, in practice,\n                 // constants are always scalars or strings.  For scalars\n-                // subtyping is irrelevant, and for strings `expr_ty` is\n+                // subtyping is irrelevant, and for strings `expr_t` is\n                 // type is `&'static str`, so if we say that\n                 //\n                 //     &'static str <: expected\n@@ -72,11 +71,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_suptype(pat.span, expected, pat_ty);\n             }\n             PatKind::Range(ref begin, ref end) => {\n-                self.check_expr(begin);\n-                self.check_expr(end);\n-\n-                let lhs_ty = self.expr_ty(begin);\n-                let rhs_ty = self.expr_ty(end);\n+                let lhs_ty = self.check_expr(begin);\n+                let rhs_ty = self.check_expr(end);\n \n                 // Check that both end-points are of numeric or char type.\n                 let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n@@ -385,8 +381,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         });\n         let discrim_ty;\n         if let Some(m) = contains_ref_bindings {\n-            self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n-            discrim_ty = self.expr_ty(discrim);\n+            discrim_ty = self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n         } else {\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n@@ -429,8 +424,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let Some(ref e) = arm.guard {\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n-            self.check_expr_with_expectation(&arm.body, expected);\n-            let arm_ty = self.expr_ty(&arm.body);\n+            let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;"}, {"sha": "bc3c5aba7100b39c26e4276d89c6a16fc6eeb3a5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b93435fd79e26e09b8aa786eb682c82ec81f0293", "patch": "@@ -47,8 +47,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       arg_exprs: &'gcx [P<hir::Expr>],\n                       expected: Expectation<'tcx>) -> Ty<'tcx>\n     {\n-        self.check_expr(callee_expr);\n-        let original_callee_ty = self.expr_ty(callee_expr);\n+        let original_callee_ty = self.check_expr(callee_expr);\n \n         let mut autoderef = self.autoderef(callee_expr.span, original_callee_ty);\n         let result = autoderef.by_ref().flat_map(|(adj_ty, idx)| {"}, {"sha": "774969daf388a8ce5dfced44121521ada8b3694b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b93435fd79e26e09b8aa786eb682c82ec81f0293", "patch": "@@ -1750,13 +1750,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.require_type_meets(ty, span, code, ty::BoundSized);\n     }\n \n-    pub fn require_expr_have_sized_type(&self,\n-                                        expr: &hir::Expr,\n-                                        code: traits::ObligationCauseCode<'tcx>)\n-    {\n-        self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n-    }\n-\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -1801,7 +1794,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n-        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.node_ty(expr.id);\n         let raw_ty = self.shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n         raw_ty.adjust(self.tcx, expr.span, expr.id, adjustment, |method_call| {\n@@ -2623,12 +2616,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // arguments which we skipped above.\n         if variadic {\n             for arg in args.iter().skip(expected_arg_count) {\n-                self.check_expr(&arg);\n+                let arg_ty = self.check_expr(&arg);\n \n                 // There are a few types which get autopromoted when passed via varargs\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = self.structurally_resolved_type(arg.span,\n-                                                             self.expr_ty(&arg));\n+                                                             arg_ty);\n                 match arg_ty.sty {\n                     ty::TyFloat(ast::FloatTy::F32) => {\n                         self.type_error_message(arg.span, |t| {\n@@ -2718,15 +2711,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_eq_type(&self,\n                           expr: &'gcx hir::Expr,\n                           expected: Ty<'tcx>) {\n-        self.check_expr_with_hint(expr, expected);\n-        self.demand_eqtype(expr.span, expected, self.expr_ty(expr));\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        self.demand_eqtype(expr.span, expected, ty);\n     }\n \n     pub fn check_expr_has_type(&self,\n                                expr: &'gcx hir::Expr,\n                                expected: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n-        self.demand_suptype(expr.span, expected, self.expr_ty(expr));\n+        self.demand_suptype(expr.span, expected, ty);\n         ty\n     }\n \n@@ -2821,10 +2814,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          expected: Expectation<'tcx>,\n                          lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n+        let rcvr_t = self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n \n         // no need to check for bot/err -- callee does that\n-        let expr_t = self.structurally_resolved_type(expr.span, self.expr_ty(&rcvr));\n+        let expr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n         let tps = tps.iter().map(|ast_ty| self.to_ty(&ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match self.lookup_method(method_name.span,\n@@ -2867,7 +2860,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+        let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n \n         let expected = expected.adjust_for_branches(self);\n         self.check_block_with_expected(then_blk, expected);\n@@ -2876,8 +2869,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let unit = self.tcx.mk_nil();\n         let (origin, expected, found, result) =\n         if let Some(else_expr) = opt_else_expr {\n-            self.check_expr_with_expectation(else_expr, expected);\n-            let else_ty = self.expr_ty(else_expr);\n+            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let origin = TypeOrigin::IfExpression(sp);\n \n             // Only try to coerce-unify if we have a then expression\n@@ -2919,7 +2911,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let if_ty = match result {\n             Ok(ty) => {\n-                if self.expr_ty(cond_expr).references_error() {\n+                if cond_ty.references_error() {\n                     self.tcx.types.err\n                 } else {\n                     ty\n@@ -2940,9 +2932,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                    lvalue_pref: LvaluePreference,\n                    base: &'gcx hir::Expr,\n                    field: &Spanned<ast::Name>) -> Ty<'tcx> {\n-        self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n-                                                     self.expr_ty(base));\n+                                                     expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n@@ -3038,9 +3030,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        lvalue_pref: LvaluePreference,\n                        base: &'gcx hir::Expr,\n                        idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n-        self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n-                                                     self.expr_ty(base));\n+                                                     expr_t);\n         let mut private_candidate = None;\n         let mut tuple_like = false;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n@@ -3272,18 +3264,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, expr_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n+        let (variant, expr_t) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n                                                                                   expr.span) {\n             variant_ty\n         } else {\n             return self.check_struct_fields_on_error(expr.id, fields, base_expr);\n         };\n \n-        self.check_expr_struct_fields(expr_ty, path.span, variant, fields,\n+        self.check_expr_struct_fields(expr_t, path.span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n-            self.check_expr_has_type(base_expr, expr_ty);\n-            match expr_ty.sty {\n+            self.check_expr_has_type(base_expr, expr_t);\n+            match expr_t.sty {\n                 ty::TyStruct(adt, substs) => {\n                     self.tables.borrow_mut().fru_field_types.insert(\n                         expr.id,\n@@ -3300,7 +3292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-        expr_ty\n+        expr_t\n     }\n \n \n@@ -3331,8 +3323,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => NoExpectation\n                 }\n             });\n-            self.check_expr_with_expectation(subexpr, expected_inner);\n-            let referent_ty = self.expr_ty(&subexpr);\n+            let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n             self.write_ty(id, tcx.mk_box(referent_ty))\n           }\n \n@@ -3510,7 +3501,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n-            self.require_expr_have_sized_type(&lhs, traits::AssignmentLhsSized);\n+            self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n             if lhs_ty.references_error() || rhs_ty.references_error() {\n                 self.write_error(id)\n@@ -3523,9 +3514,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  id, expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            self.check_expr_has_type(&cond, tcx.types.bool);\n+            let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n             self.check_block_no_value(&body);\n-            let cond_ty = self.expr_ty(&cond);\n             let body_ty = self.node_ty(body.id);\n             if cond_ty.references_error() || body_ty.references_error() {\n                 self.write_error(id)\n@@ -3714,7 +3704,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprStruct(ref path, ref fields, ref base_expr) => {\n             let ty = self.check_expr_struct(expr, path, fields, base_expr);\n \n-            self.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n+            self.require_type_is_sized(ty, expr.span, traits::StructInitializerSized);\n             ty\n           }\n           hir::ExprField(ref base, ref field) => {\n@@ -3735,8 +3725,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n                   match self.lookup_indexing(expr, base, base_t, idx_t, lvalue_pref) {\n                       Some((index_ty, element_ty)) => {\n-                          let idx_expr_ty = self.expr_ty(idx);\n-                          self.demand_eqtype(expr.span, index_ty, idx_expr_ty);\n+                          self.demand_eqtype(expr.span, index_ty, idx_t);\n                           self.write_ty(id, element_ty)\n                       }\n                       None => {\n@@ -3865,7 +3854,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_decl_initializer(&self,\n                                   local: &'gcx hir::Local,\n-                                  init: &'gcx hir::Expr)\n+                                  init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n         let ref_bindings = self.tcx.pat_contains_ref_binding(&local.pat);\n \n@@ -3884,16 +3873,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             init_ty\n         } else {\n             self.check_expr_coercable_to_type(init, local_ty)\n-        };\n+        }\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n         let t = self.local_ty(local.span, local.id);\n         self.write_ty(local.id, t);\n \n         if let Some(ref init) = local.init {\n-            self.check_decl_initializer(local, &init);\n-            let init_ty = self.expr_ty(&init);\n+            let init_ty = self.check_decl_initializer(local, &init);\n             if init_ty.references_error() {\n                 self.write_ty(local.id, init_ty);\n             }\n@@ -3926,17 +3914,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::StmtExpr(ref expr, id) => {\n             node_id = id;\n             // Check with expected type of ()\n-            self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-            let expr_ty = self.expr_ty(&expr);\n-            saw_bot = saw_bot || self.type_var_diverges(expr_ty);\n-            saw_err = saw_err || expr_ty.references_error();\n+            let expr_t = self.check_expr_has_type(&expr, self.tcx.mk_nil());\n+            saw_bot = saw_bot || self.type_var_diverges(expr_t);\n+            saw_err = saw_err || expr_t.references_error();\n           }\n           hir::StmtSemi(ref expr, id) => {\n             node_id = id;\n-            self.check_expr(&expr);\n-            let expr_ty = self.expr_ty(&expr);\n-            saw_bot |= self.type_var_diverges(expr_ty);\n-            saw_err |= expr_ty.references_error();\n+            let expr_t = self.check_expr(&expr);\n+            saw_bot |= self.type_var_diverges(expr_t);\n+            saw_err |= expr_t.references_error();\n           }\n         }\n         if saw_bot {\n@@ -4023,8 +4009,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         ety\n                     }\n                     _ => {\n-                        self.check_expr_with_expectation(&e, expected);\n-                        self.expr_ty(&e)\n+                        self.check_expr_with_expectation(&e, expected)\n                     }\n                 };\n "}, {"sha": "5462826ef9048ade1af2b1ba40fecedec00574ca", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93435fd79e26e09b8aa786eb682c82ec81f0293/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b93435fd79e26e09b8aa786eb682c82ec81f0293", "patch": "@@ -25,9 +25,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               lhs_expr: &'gcx hir::Expr,\n                               rhs_expr: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n+        let lhs_ty = self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n \n-        let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n+        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n         let (rhs_ty, return_ty) =\n             self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n         let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n@@ -69,8 +69,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                lhs_expr,\n                rhs_expr);\n \n-        self.check_expr(lhs_expr);\n-        let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n+        let lhs_ty = self.check_expr(lhs_expr);\n+        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n         let ty = match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {"}]}