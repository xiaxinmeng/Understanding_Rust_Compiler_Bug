{"sha": "166d4f5fe98aa58666322fe6413ca3b7bee832aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmQ0ZjVmZTk4YWE1ODY2NjMyMmZlNjQxM2NhM2I3YmVlODMyYWE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-06-30T02:50:50Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-26T19:30:14Z"}, "message": "Translate anonymous block closures.", "tree": {"sha": "a2324c58dfb073c28824ca33160d87e84319ed6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2324c58dfb073c28824ca33160d87e84319ed6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166d4f5fe98aa58666322fe6413ca3b7bee832aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166d4f5fe98aa58666322fe6413ca3b7bee832aa", "html_url": "https://github.com/rust-lang/rust/commit/166d4f5fe98aa58666322fe6413ca3b7bee832aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166d4f5fe98aa58666322fe6413ca3b7bee832aa/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac948b4ccd485f12019f0b1d11359990725dfab5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac948b4ccd485f12019f0b1d11359990725dfab5", "html_url": "https://github.com/rust-lang/rust/commit/ac948b4ccd485f12019f0b1d11359990725dfab5"}], "stats": {"total": 58, "additions": 50, "deletions": 8}, "files": [{"sha": "1b928c7c11008f8a01a961c698573e9ccc83d4d0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/166d4f5fe98aa58666322fe6413ca3b7bee832aa/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166d4f5fe98aa58666322fe6413ca3b7bee832aa/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=166d4f5fe98aa58666322fe6413ca3b7bee832aa", "patch": "@@ -5299,8 +5299,14 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n             auto s = mangle_internal_name_by_path(ccx, sub_cx.path);\n             auto llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n-            trans_fn(sub_cx, e.span, f, llfn, none, ~[], e.id);\n-            ret rslt(cx, create_fn_pair(ccx, s, llfnty, llfn, false));\n+\n+            auto fn_res = trans_closure(some(cx), some(llfnty), sub_cx,\n+                                        e.span, f, llfn, none, ~[], e.id);\n+            auto fn_pair = alt (fn_res) {\n+                some(?fn_pair) { fn_pair }\n+                none { create_fn_pair(ccx, s, llfnty, llfn, false) }\n+            };\n+            ret rslt(cx, fn_pair);\n         }\n         case (ast::expr_block(?blk)) {\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n@@ -6592,10 +6598,16 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n     new_builder(fcx.lldynamicallocas).Br(lltop);\n }\n \n-\n-fn trans_fn_inner(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n-                  option::t[ty::t] ty_self, &ast::ty_param[] ty_params,\n-                  ast::node_id id) {\n+// trans_closure: Builds an LLVM function out of a source function.\n+// If the function closes over its environment a closure will be\n+// returned.\n+fn trans_closure(&option::t[@block_ctxt] bcx_maybe,\n+                 &option::t[TypeRef] llfnty,\n+                 @local_ctxt cx,\n+                 &span sp, &ast::_fn f, ValueRef llfndecl,\n+                 option::t[ty::t] ty_self,\n+                 &ast::ty_param[] ty_params, ast::node_id id)\n+    -> option::t[ValueRef] {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -6605,12 +6617,34 @@ fn trans_fn_inner(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n                               f.decl.inputs, ty_params);\n     copy_any_self_to_alloca(fcx);\n     alt ({ fcx.llself }) {\n-        case (some(?llself)) { populate_fn_ctxt_from_llself(fcx, llself); }\n-        case (_) { }\n+        some(?llself) { populate_fn_ctxt_from_llself(fcx, llself); }\n+        _ { }\n     }\n     auto arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n     copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n \n+    // Figure out if we need to build a closure and act accordingly\n+    auto closure = none;\n+    alt(f.proto) {\n+        ast::proto_block {\n+            auto bcx = option::get(bcx_maybe);\n+            auto upvars = get_freevars(cx.ccx.tcx, id);\n+\n+            auto llenv = build_environment(bcx, upvars);\n+\n+            // Generate code to load the environment out of the\n+            // environment pointer.\n+            load_environment(bcx, fcx, llenv.ptrty, upvars);\n+            // Build the closure.\n+            closure = some(create_real_fn_pair(bcx, option::get(llfnty),\n+                                               llfndecl, llenv.ptr));\n+        }\n+        ast::proto_closure {\n+            fail \"copy capture not implemented yet\";\n+        }\n+        _ {}\n+    }\n+\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     auto bcx = new_top_block_ctxt(fcx);\n@@ -6643,6 +6677,14 @@ fn trans_fn_inner(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n \n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n+\n+    ret closure;\n+}\n+\n+fn trans_fn_inner(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n+                  option::t[ty::t] ty_self, &ast::ty_param[] ty_params,\n+                  ast::node_id id) {\n+    trans_closure(none, none, cx, sp, f, llfndecl, ty_self, ty_params, id);\n }\n \n "}]}