{"sha": "eeceba748053cc365a55c3c73798186ceec09991", "node_id": "C_kwDOAAsO6NoAKGVlY2ViYTc0ODA1M2NjMzY1YTU1YzNjNzM3OTgxODZjZWVjMDk5OTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T09:06:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T09:06:22Z"}, "message": "Auto merge of #14065 - lowr:patch/generate-generic-function, r=Veykril\n\nSupport generic function in `generate_function` assist\n\nPart of #3639\n\nThis PR adds support for generic function generation in `generate_function` assist. Now the assist looks for generic parameters and trait bounds in scope, filters out irrelevant ones, and generates new function with them.\n\nSee `fn_generic_params()` for the outline of the procedure, and see comments on `filter_unnecessary_bounds()` for criteria for filtering. I think it's good criteria for most cases, but I'm open to opinions and suggestions.\n\nThe diff is pretty big, but it should run in linear time w.r.t. the number of nodes we operate on and should be fast enough.\n\nSome notes:\n- When we generate function in an existing impl, generic parameters may cause name conflict. While we can detect the conflict and rename conflicting params, I didn't find it worthwhile mainly because it's really easy to resolve on IDE: use Rename functionality.\n- I've implemented graph structure myself, because we don't have graph library as a dependency and we only need the simplest one.\n  - Although `petgraph` is in our dependency graph and I was initially looking to use it, we don't actually depend on it AFAICT since it's only used in chalk's specialization graph handling, which we don't use. I'd be happy to replace my implementation with `petgraph` if it's okay to use it though.\n- There are some caveats that I consider out of scope of this PR. See FIXME notes on added tests.", "tree": {"sha": "9fd82d6d25542ca16c9a6a107a7f98a847002513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fd82d6d25542ca16c9a6a107a7f98a847002513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeceba748053cc365a55c3c73798186ceec09991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeceba748053cc365a55c3c73798186ceec09991", "html_url": "https://github.com/rust-lang/rust/commit/eeceba748053cc365a55c3c73798186ceec09991", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeceba748053cc365a55c3c73798186ceec09991/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd142c6163c992dfb482b85bbddbb7b3370c9c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd142c6163c992dfb482b85bbddbb7b3370c9c8", "html_url": "https://github.com/rust-lang/rust/commit/ccd142c6163c992dfb482b85bbddbb7b3370c9c8"}, {"sha": "493cabbde7f5838cbc0e1ccebc15dd6a5c82c1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/493cabbde7f5838cbc0e1ccebc15dd6a5c82c1c5", "html_url": "https://github.com/rust-lang/rust/commit/493cabbde7f5838cbc0e1ccebc15dd6a5c82c1c5"}], "stats": {"total": 1044, "additions": 980, "deletions": 64}, "files": [{"sha": "cbeb61067dfbe742f28f812d554e842a45e2f9ae", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -39,11 +39,13 @@ use std::sync::Arc;\n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n     interner::HasInterner,\n-    NoSolution,\n+    visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n+    NoSolution, TyData,\n };\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use itertools::Either;\n+use rustc_hash::FxHashSet;\n use traits::FnTrait;\n use utils::Generics;\n \n@@ -562,3 +564,68 @@ pub fn callable_sig_from_fnonce(\n \n     Some(CallableSig::from_params_and_return(params, ret_ty, false, Safety::Safe))\n }\n+\n+struct PlaceholderCollector<'db> {\n+    db: &'db dyn HirDatabase,\n+    placeholders: FxHashSet<TypeOrConstParamId>,\n+}\n+\n+impl PlaceholderCollector<'_> {\n+    fn collect(&mut self, idx: PlaceholderIndex) {\n+        let id = from_placeholder_idx(self.db, idx);\n+        self.placeholders.insert(id);\n+    }\n+}\n+\n+impl TypeVisitor<Interner> for PlaceholderCollector<'_> {\n+    type BreakTy = ();\n+\n+    fn as_dyn(&mut self) -> &mut dyn TypeVisitor<Interner, BreakTy = Self::BreakTy> {\n+        self\n+    }\n+\n+    fn interner(&self) -> Interner {\n+        Interner\n+    }\n+\n+    fn visit_ty(\n+        &mut self,\n+        ty: &Ty,\n+        outer_binder: DebruijnIndex,\n+    ) -> std::ops::ControlFlow<Self::BreakTy> {\n+        let has_placeholder_bits = TypeFlags::HAS_TY_PLACEHOLDER | TypeFlags::HAS_CT_PLACEHOLDER;\n+        let TyData { kind, flags } = ty.data(Interner);\n+\n+        if let TyKind::Placeholder(idx) = kind {\n+            self.collect(*idx);\n+        } else if flags.intersects(has_placeholder_bits) {\n+            return ty.super_visit_with(self, outer_binder);\n+        } else {\n+            // Fast path: don't visit inner types (e.g. generic arguments) when `flags` indicate\n+            // that there are no placeholders.\n+        }\n+\n+        std::ops::ControlFlow::Continue(())\n+    }\n+\n+    fn visit_const(\n+        &mut self,\n+        constant: &chalk_ir::Const<Interner>,\n+        _outer_binder: DebruijnIndex,\n+    ) -> std::ops::ControlFlow<Self::BreakTy> {\n+        if let chalk_ir::ConstValue::Placeholder(idx) = constant.data(Interner).value {\n+            self.collect(idx);\n+        }\n+        std::ops::ControlFlow::Continue(())\n+    }\n+}\n+\n+/// Returns unique placeholders for types and consts contained in `value`.\n+pub fn collect_placeholders<T>(value: &T, db: &dyn HirDatabase) -> Vec<TypeOrConstParamId>\n+where\n+    T: ?Sized + TypeVisitable<Interner>,\n+{\n+    let mut collector = PlaceholderCollector { db, placeholders: FxHashSet::default() };\n+    value.visit_with(&mut collector, DebruijnIndex::INNERMOST);\n+    collector.placeholders.into_iter().collect()\n+}"}, {"sha": "2cb4ed2c33518d170a9bae52a78dbde26364186f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -2165,6 +2165,16 @@ impl AsAssocItem for ModuleDef {\n         }\n     }\n }\n+impl AsAssocItem for DefWithBody {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        match self {\n+            DefWithBody::Function(it) => it.as_assoc_item(db),\n+            DefWithBody::Const(it) => it.as_assoc_item(db),\n+            DefWithBody::Static(_) | DefWithBody::Variant(_) => None,\n+        }\n+    }\n+}\n+\n fn as_assoc_item<ID, DEF, CTOR, AST>(db: &dyn HirDatabase, ctor: CTOR, id: ID) -> Option<AssocItem>\n where\n     ID: Lookup<Data = AssocItemLoc<AST>>,\n@@ -2565,6 +2575,14 @@ impl GenericParam {\n             GenericParam::LifetimeParam(it) => it.name(db),\n         }\n     }\n+\n+    pub fn parent(self) -> GenericDef {\n+        match self {\n+            GenericParam::TypeParam(it) => it.id.parent().into(),\n+            GenericParam::ConstParam(it) => it.id.parent().into(),\n+            GenericParam::LifetimeParam(it) => it.id.parent.into(),\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -3144,15 +3162,15 @@ impl Type {\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::Closure { .. })\n+        matches!(self.ty.kind(Interner), TyKind::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n+        matches!(self.ty.kind(Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n     }\n \n     pub fn is_array(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::Array(..))\n+        matches!(self.ty.kind(Interner), TyKind::Array(..))\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n@@ -3169,7 +3187,7 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::Raw(..))\n+        matches!(self.ty.kind(Interner), TyKind::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n@@ -3604,6 +3622,14 @@ impl Type {\n             _ => None,\n         }\n     }\n+\n+    /// Returns unique `GenericParam`s contained in this type.\n+    pub fn generic_params(&self, db: &dyn HirDatabase) -> FxHashSet<GenericParam> {\n+        hir_ty::collect_placeholders(&self.ty, db)\n+            .into_iter()\n+            .map(|id| TypeOrConstParam { id }.split(db).either_into())\n+            .collect()\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "486b7ee62ed3ad0383872e7da8184ecb141f5235", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -1319,10 +1319,7 @@ impl<'db> SemanticsImpl<'db> {\n         let _p = profile::span(\"Semantics::analyze_impl\");\n         let node = self.find_file(node);\n \n-        let container = match self.with_ctx(|ctx| ctx.find_container(node)) {\n-            Some(it) => it,\n-            None => return None,\n-        };\n+        let container = self.with_ctx(|ctx| ctx.find_container(node))?;\n \n         let resolver = match container {\n             ChildContainer::DefWithBodyId(def) => {\n@@ -1582,7 +1579,7 @@ fn find_root(node: &SyntaxNode) -> SyntaxNode {\n     node.ancestors().last().unwrap()\n }\n \n-/// `SemanticScope` encapsulates the notion of a scope (the set of visible\n+/// `SemanticsScope` encapsulates the notion of a scope (the set of visible\n /// names) at a particular program point.\n ///\n /// It is a bit tricky, as scopes do not really exist inside the compiler."}, {"sha": "ed1b8f4e28d304eb4a62edde2bb5f0c910227b03", "filename": "crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -109,7 +109,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                 let tail_expr_finished =\n                     if is_async { make::expr_await(tail_expr) } else { tail_expr };\n                 let body = make::block_expr([], Some(tail_expr_finished));\n-                let f = make::fn_(vis, name, type_params, params, body, ret_type, is_async)\n+                let f = make::fn_(vis, name, type_params, None, params, body, ret_type, is_async)\n                     .indent(ast::edit::IndentLevel(1))\n                     .clone_for_update();\n "}, {"sha": "45b27a63ce26d43b7c60ebf5cc0601bec415147a", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 854, "deletions": 47, "changes": 901, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -1,23 +1,25 @@\n-use hir::{Adt, HasSource, HirDisplay, Module, Semantics, TypeInfo};\n+use hir::{\n+    Adt, AsAssocItem, HasSource, HirDisplay, Module, PathResolution, Semantics, Type, TypeInfo,\n+};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n     famous_defs::FamousDefs,\n+    path_transform::PathTransform,\n     FxHashMap, FxHashSet, RootDatabase, SnippetCap,\n };\n use stdx::to_lower_snake_case;\n use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        make, AstNode, CallExpr, HasArgList, HasModuleItem,\n+        make, AstNode, CallExpr, HasArgList, HasGenericParams, HasModuleItem, HasTypeBounds,\n     },\n     SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{\n-    utils::convert_reference_type,\n-    utils::{find_struct_impl, render_snippet, Cursor},\n+    utils::{convert_reference_type, find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n@@ -107,7 +109,7 @@ fn fn_target_info(\n     match path.qualifier() {\n         Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n             Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => {\n-                get_fn_target_info(ctx, &Some(module), call.clone())\n+                get_fn_target_info(ctx, Some(module), call.clone())\n             }\n             Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n                 if let hir::Adt::Enum(_) = adt {\n@@ -125,7 +127,7 @@ fn fn_target_info(\n             }\n             _ => None,\n         },\n-        _ => get_fn_target_info(ctx, &None, call.clone()),\n+        _ => get_fn_target_info(ctx, None, call.clone()),\n     }\n }\n \n@@ -136,7 +138,8 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     }\n \n     let fn_name = call.name_ref()?;\n-    let adt = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references().as_adt()?;\n+    let receiver_ty = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references();\n+    let adt = receiver_ty.as_adt()?;\n \n     let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module = adt.module(ctx.sema.db);\n@@ -147,8 +150,14 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n     let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n \n-    let function_builder =\n-        FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n+    let function_builder = FunctionBuilder::from_method_call(\n+        ctx,\n+        &call,\n+        &fn_name,\n+        receiver_ty,\n+        target_module,\n+        target,\n+    )?;\n     let text_range = call.syntax().text_range();\n     let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n     let label = format!(\"Generate {} method\", function_builder.fn_name);\n@@ -179,6 +188,7 @@ fn add_func_to_accumulator(\n         let function_template = function_builder.render(adt_name.is_some());\n         let mut func = function_template.to_string(ctx.config.snippet_cap);\n         if let Some(name) = adt_name {\n+            // FIXME: adt may have generic params.\n             func = format!(\"\\n{indent}impl {name} {{\\n{func}\\n{indent}}}\");\n         }\n         builder.edit_file(file);\n@@ -238,7 +248,8 @@ impl FunctionTemplate {\n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n-    type_params: Option<ast::GenericParamList>,\n+    generic_param_list: Option<ast::GenericParamList>,\n+    where_clause: Option<ast::WhereClause>,\n     params: ast::ParamList,\n     ret_type: Option<ast::RetType>,\n     should_focus_return_type: bool,\n@@ -260,19 +271,32 @@ impl FunctionBuilder {\n         let target_module =\n             target_module.or_else(|| ctx.sema.scope(target.syntax()).map(|it| it.module()))?;\n         let fn_name = make::name(fn_name);\n-        let (type_params, params) =\n-            fn_args(ctx, target_module, ast::CallableExpr::Call(call.clone()))?;\n+        let mut necessary_generic_params = FxHashSet::default();\n+        let params = fn_args(\n+            ctx,\n+            target_module,\n+            ast::CallableExpr::Call(call.clone()),\n+            &mut necessary_generic_params,\n+        )?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        let (ret_type, should_focus_return_type) =\n-            make_return_type(ctx, &ast::Expr::CallExpr(call.clone()), target_module);\n+        let (ret_type, should_focus_return_type) = make_return_type(\n+            ctx,\n+            &ast::Expr::CallExpr(call.clone()),\n+            target_module,\n+            &mut necessary_generic_params,\n+        );\n+\n+        let (generic_param_list, where_clause) =\n+            fn_generic_params(ctx, necessary_generic_params, &target)?;\n \n         Some(Self {\n             target,\n             fn_name,\n-            type_params,\n+            generic_param_list,\n+            where_clause,\n             params,\n             ret_type,\n             should_focus_return_type,\n@@ -285,25 +309,40 @@ impl FunctionBuilder {\n         ctx: &AssistContext<'_>,\n         call: &ast::MethodCallExpr,\n         name: &ast::NameRef,\n+        receiver_ty: Type,\n         target_module: Module,\n         target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n         let needs_pub =\n             !module_is_descendant(&ctx.sema.scope(call.syntax())?.module(), &target_module, ctx);\n         let fn_name = make::name(&name.text());\n-        let (type_params, params) =\n-            fn_args(ctx, target_module, ast::CallableExpr::MethodCall(call.clone()))?;\n+        let mut necessary_generic_params = FxHashSet::default();\n+        necessary_generic_params.extend(receiver_ty.generic_params(ctx.db()));\n+        let params = fn_args(\n+            ctx,\n+            target_module,\n+            ast::CallableExpr::MethodCall(call.clone()),\n+            &mut necessary_generic_params,\n+        )?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        let (ret_type, should_focus_return_type) =\n-            make_return_type(ctx, &ast::Expr::MethodCallExpr(call.clone()), target_module);\n+        let (ret_type, should_focus_return_type) = make_return_type(\n+            ctx,\n+            &ast::Expr::MethodCallExpr(call.clone()),\n+            target_module,\n+            &mut necessary_generic_params,\n+        );\n+\n+        let (generic_param_list, where_clause) =\n+            fn_generic_params(ctx, necessary_generic_params, &target)?;\n \n         Some(Self {\n             target,\n             fn_name,\n-            type_params,\n+            generic_param_list,\n+            where_clause,\n             params,\n             ret_type,\n             should_focus_return_type,\n@@ -319,7 +358,8 @@ impl FunctionBuilder {\n         let mut fn_def = make::fn_(\n             visibility,\n             self.fn_name,\n-            self.type_params,\n+            self.generic_param_list,\n+            self.where_clause,\n             self.params,\n             fn_body,\n             self.ret_type,\n@@ -375,13 +415,15 @@ fn make_return_type(\n     ctx: &AssistContext<'_>,\n     call: &ast::Expr,\n     target_module: Module,\n+    necessary_generic_params: &mut FxHashSet<hir::GenericParam>,\n ) -> (Option<ast::RetType>, bool) {\n     let (ret_ty, should_focus_return_type) = {\n         match ctx.sema.type_of_expr(call).map(TypeInfo::original) {\n             Some(ty) if ty.is_unknown() => (Some(make::ty_placeholder()), true),\n             None => (Some(make::ty_placeholder()), true),\n             Some(ty) if ty.is_unit() => (None, false),\n             Some(ty) => {\n+                necessary_generic_params.extend(ty.generic_params(ctx.db()));\n                 let rendered = ty.display_source_code(ctx.db(), target_module.into());\n                 match rendered {\n                     Ok(rendered) => (Some(make::ty(&rendered)), false),\n@@ -396,16 +438,16 @@ fn make_return_type(\n \n fn get_fn_target_info(\n     ctx: &AssistContext<'_>,\n-    target_module: &Option<Module>,\n+    target_module: Option<Module>,\n     call: CallExpr,\n ) -> Option<TargetInfo> {\n     let (target, file, insert_offset) = get_fn_target(ctx, target_module, call)?;\n-    Some(TargetInfo::new(*target_module, None, target, file, insert_offset))\n+    Some(TargetInfo::new(target_module, None, target, file, insert_offset))\n }\n \n fn get_fn_target(\n     ctx: &AssistContext<'_>,\n-    target_module: &Option<Module>,\n+    target_module: Option<Module>,\n     call: CallExpr,\n ) -> Option<(GeneratedFunctionTarget, FileId, TextSize)> {\n     let mut file = ctx.file_id();\n@@ -473,37 +515,386 @@ impl GeneratedFunctionTarget {\n             GeneratedFunctionTarget::InEmptyItemList(it) => it,\n         }\n     }\n+\n+    fn parent(&self) -> SyntaxNode {\n+        match self {\n+            GeneratedFunctionTarget::BehindItem(it) => it.parent().expect(\"item without parent\"),\n+            GeneratedFunctionTarget::InEmptyItemList(it) => it.clone(),\n+        }\n+    }\n }\n \n-/// Computes the type variables and arguments required for the generated function\n+/// Computes parameter list for the generated function.\n fn fn_args(\n     ctx: &AssistContext<'_>,\n     target_module: hir::Module,\n     call: ast::CallableExpr,\n-) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n+    necessary_generic_params: &mut FxHashSet<hir::GenericParam>,\n+) -> Option<ast::ParamList> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n         arg_names.push(fn_arg_name(&ctx.sema, &arg));\n-        arg_types.push(fn_arg_type(ctx, target_module, &arg));\n+        arg_types.push(fn_arg_type(ctx, target_module, &arg, necessary_generic_params));\n     }\n     deduplicate_arg_names(&mut arg_names);\n     let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n         make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))\n     });\n \n-    Some((\n-        None,\n-        make::param_list(\n-            match call {\n-                ast::CallableExpr::Call(_) => None,\n-                ast::CallableExpr::MethodCall(_) => Some(make::self_param()),\n-            },\n-            params,\n-        ),\n+    Some(make::param_list(\n+        match call {\n+            ast::CallableExpr::Call(_) => None,\n+            ast::CallableExpr::MethodCall(_) => Some(make::self_param()),\n+        },\n+        params,\n     ))\n }\n \n+/// Gets parameter bounds and where predicates in scope and filters out irrelevant ones. Returns\n+/// `None` when it fails to get scope information.\n+///\n+/// See comment on `filter_unnecessary_bounds()` for what bounds we consider relevant.\n+///\n+/// NOTE: Generic parameters returned from this function may cause name clash at `target`. We don't\n+/// currently do anything about it because it's actually easy to resolve it after the assist: just\n+/// use the Rename functionality.\n+fn fn_generic_params(\n+    ctx: &AssistContext<'_>,\n+    necessary_params: FxHashSet<hir::GenericParam>,\n+    target: &GeneratedFunctionTarget,\n+) -> Option<(Option<ast::GenericParamList>, Option<ast::WhereClause>)> {\n+    if necessary_params.is_empty() {\n+        // Not really needed but fast path.\n+        return Some((None, None));\n+    }\n+\n+    // 1. Get generic parameters (with bounds) and where predicates in scope.\n+    let (generic_params, where_preds) = params_and_where_preds_in_scope(ctx);\n+\n+    // 2. Extract type parameters included in each bound.\n+    let mut generic_params = generic_params\n+        .into_iter()\n+        .filter_map(|it| compute_contained_params_in_generic_param(ctx, it))\n+        .collect();\n+    let mut where_preds = where_preds\n+        .into_iter()\n+        .filter_map(|it| compute_contained_params_in_where_pred(ctx, it))\n+        .collect();\n+\n+    // 3. Filter out unnecessary bounds.\n+    filter_unnecessary_bounds(&mut generic_params, &mut where_preds, necessary_params);\n+    filter_bounds_in_scope(&mut generic_params, &mut where_preds, ctx, target);\n+\n+    let generic_params: Vec<_> =\n+        generic_params.into_iter().map(|it| it.node.clone_for_update()).collect();\n+    let where_preds: Vec<_> =\n+        where_preds.into_iter().map(|it| it.node.clone_for_update()).collect();\n+\n+    // 4. Rewrite paths\n+    if let Some(param) = generic_params.first() {\n+        let source_scope = ctx.sema.scope(param.syntax())?;\n+        let target_scope = ctx.sema.scope(&target.parent())?;\n+        if source_scope.module() != target_scope.module() {\n+            let transform = PathTransform::generic_transformation(&target_scope, &source_scope);\n+            let generic_params = generic_params.iter().map(|it| it.syntax());\n+            let where_preds = where_preds.iter().map(|it| it.syntax());\n+            transform.apply_all(generic_params.chain(where_preds));\n+        }\n+    }\n+\n+    let generic_param_list = make::generic_param_list(generic_params);\n+    let where_clause =\n+        if where_preds.is_empty() { None } else { Some(make::where_clause(where_preds)) };\n+\n+    Some((Some(generic_param_list), where_clause))\n+}\n+\n+fn params_and_where_preds_in_scope(\n+    ctx: &AssistContext<'_>,\n+) -> (Vec<ast::GenericParam>, Vec<ast::WherePred>) {\n+    let Some(body) = containing_body(ctx) else { return Default::default(); };\n+\n+    let mut generic_params = Vec::new();\n+    let mut where_clauses = Vec::new();\n+\n+    // There are two items where generic parameters currently in scope may be declared: the item\n+    // the cursor is at, and its parent (if any).\n+    //\n+    // We handle parent first so that their generic parameters appear first in the generic\n+    // parameter list of the function we're generating.\n+    let db = ctx.db();\n+    if let Some(parent) = body.as_assoc_item(db).map(|it| it.container(db)) {\n+        match parent {\n+            hir::AssocItemContainer::Impl(it) => {\n+                let (params, clauses) = get_bounds_in_scope(ctx, it);\n+                generic_params.extend(params);\n+                where_clauses.extend(clauses);\n+            }\n+            hir::AssocItemContainer::Trait(it) => {\n+                let (params, clauses) = get_bounds_in_scope(ctx, it);\n+                generic_params.extend(params);\n+                where_clauses.extend(clauses);\n+            }\n+        }\n+    }\n+\n+    // Other defs with body may inherit generic parameters from its parent, but never have their\n+    // own generic parameters.\n+    if let hir::DefWithBody::Function(it) = body {\n+        let (params, clauses) = get_bounds_in_scope(ctx, it);\n+        generic_params.extend(params);\n+        where_clauses.extend(clauses);\n+    }\n+\n+    (generic_params, where_clauses)\n+}\n+\n+fn containing_body(ctx: &AssistContext<'_>) -> Option<hir::DefWithBody> {\n+    let item: ast::Item = ctx.find_node_at_offset()?;\n+    let def = match item {\n+        ast::Item::Fn(it) => ctx.sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => ctx.sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => ctx.sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def)\n+}\n+\n+fn get_bounds_in_scope<D>(\n+    ctx: &AssistContext<'_>,\n+    def: D,\n+) -> (impl Iterator<Item = ast::GenericParam>, impl Iterator<Item = ast::WherePred>)\n+where\n+    D: HasSource,\n+    D::Ast: HasGenericParams,\n+{\n+    // This function should be only called with `Impl`, `Trait`, or `Function`, for which it's\n+    // infallible to get source ast.\n+    let node = ctx.sema.source(def).unwrap().value;\n+    let generic_params = node.generic_param_list().into_iter().flat_map(|it| it.generic_params());\n+    let where_clauses = node.where_clause().into_iter().flat_map(|it| it.predicates());\n+    (generic_params, where_clauses)\n+}\n+\n+#[derive(Debug)]\n+struct ParamBoundWithParams {\n+    node: ast::GenericParam,\n+    /// Generic parameter `node` introduces.\n+    ///\n+    /// ```text\n+    /// impl<T> S<T> {\n+    ///     fn f<U: Trait<T>>() {}\n+    ///          ^ this\n+    /// }\n+    /// ```\n+    ///\n+    /// `U` in this example.\n+    self_ty_param: hir::GenericParam,\n+    /// Generic parameters contained in the trait reference of this bound.\n+    ///\n+    /// ```text\n+    /// impl<T> S<T> {\n+    ///     fn f<U: Trait<T>>() {}\n+    ///             ^^^^^^^^ params in this part\n+    /// }\n+    /// ```\n+    ///\n+    /// `T` in this example.\n+    other_params: FxHashSet<hir::GenericParam>,\n+}\n+\n+#[derive(Debug)]\n+struct WherePredWithParams {\n+    node: ast::WherePred,\n+    /// Generic parameters contained in the \"self type\" of this where predicate.\n+    ///\n+    /// ```text\n+    /// Struct<T, U>: Trait<T, Assoc = V>,\n+    /// ^^^^^^^^^^^^ params in this part\n+    /// ```\n+    ///\n+    /// `T` and `U` in this example.\n+    self_ty_params: FxHashSet<hir::GenericParam>,\n+    /// Generic parameters contained in the trait reference of this where predicate.\n+    ///\n+    /// ```text\n+    /// Struct<T, U>: Trait<T, Assoc = V>,\n+    ///               ^^^^^^^^^^^^^^^^^^^ params in this part\n+    /// ```\n+    ///\n+    /// `T` and `V` in this example.\n+    other_params: FxHashSet<hir::GenericParam>,\n+}\n+\n+fn compute_contained_params_in_generic_param(\n+    ctx: &AssistContext<'_>,\n+    node: ast::GenericParam,\n+) -> Option<ParamBoundWithParams> {\n+    match &node {\n+        ast::GenericParam::TypeParam(ty) => {\n+            let self_ty_param = ctx.sema.to_def(ty)?.into();\n+\n+            let other_params = ty\n+                .type_bound_list()\n+                .into_iter()\n+                .flat_map(|it| it.bounds())\n+                .flat_map(|bound| bound.syntax().descendants())\n+                .filter_map(|node| filter_generic_params(ctx, node))\n+                .collect();\n+\n+            Some(ParamBoundWithParams { node, self_ty_param, other_params })\n+        }\n+        ast::GenericParam::ConstParam(ct) => {\n+            let self_ty_param = ctx.sema.to_def(ct)?.into();\n+            Some(ParamBoundWithParams { node, self_ty_param, other_params: FxHashSet::default() })\n+        }\n+        ast::GenericParam::LifetimeParam(_) => {\n+            // FIXME: It might be a good idea to handle lifetime parameters too.\n+            None\n+        }\n+    }\n+}\n+\n+fn compute_contained_params_in_where_pred(\n+    ctx: &AssistContext<'_>,\n+    node: ast::WherePred,\n+) -> Option<WherePredWithParams> {\n+    let self_ty = node.ty()?;\n+    let bound_list = node.type_bound_list()?;\n+\n+    let self_ty_params = self_ty\n+        .syntax()\n+        .descendants()\n+        .filter_map(|node| filter_generic_params(ctx, node))\n+        .collect();\n+\n+    let other_params = bound_list\n+        .bounds()\n+        .flat_map(|bound| bound.syntax().descendants())\n+        .filter_map(|node| filter_generic_params(ctx, node))\n+        .collect();\n+\n+    Some(WherePredWithParams { node, self_ty_params, other_params })\n+}\n+\n+fn filter_generic_params(ctx: &AssistContext<'_>, node: SyntaxNode) -> Option<hir::GenericParam> {\n+    let path = ast::Path::cast(node)?;\n+    match ctx.sema.resolve_path(&path)? {\n+        PathResolution::TypeParam(it) => Some(it.into()),\n+        PathResolution::ConstParam(it) => Some(it.into()),\n+        _ => None,\n+    }\n+}\n+\n+/// Filters out irrelevant bounds from `generic_params` and `where_preds`.\n+///\n+/// Say we have a trait bound `Struct<T>: Trait<U>`. Given `necessary_params`, when is it relevant\n+/// and when not? Some observations:\n+/// - When `necessary_params` contains `T`, it's likely that we want this bound, but now we have\n+/// an extra param to consider: `U`.\n+/// - On the other hand, when `necessary_params` contains `U` (but not `T`), then it's unlikely\n+/// that we want this bound because it doesn't really constrain `U`.\n+///\n+/// (FIXME?: The latter clause might be overstating. We may want to include the bound if the self\n+/// type does *not* include generic params at all - like `Option<i32>: From<U>`)\n+///\n+/// Can we make this a bit more formal? Let's define \"dependency\" between generic parameters and\n+/// trait bounds:\n+/// - A generic parameter `T` depends on a trait bound if `T` appears in the self type (i.e. left\n+/// part) of the bound.\n+/// - A trait bound depends on a generic parameter `T` if `T` appears in the bound.\n+///\n+/// Using the notion, what we want is all the bounds that params in `necessary_params`\n+/// *transitively* depend on!\n+///\n+/// Now it's not hard to solve: we build a dependency graph and compute all reachable nodes from\n+/// nodes that represent params in `necessary_params` by usual and boring DFS.\n+///\n+/// The time complexity is O(|generic_params| + |where_preds| + |necessary_params|).\n+fn filter_unnecessary_bounds(\n+    generic_params: &mut Vec<ParamBoundWithParams>,\n+    where_preds: &mut Vec<WherePredWithParams>,\n+    necessary_params: FxHashSet<hir::GenericParam>,\n+) {\n+    // All `self_ty_param` should be unique as they were collected from `ast::GenericParamList`s.\n+    let param_map: FxHashMap<hir::GenericParam, usize> =\n+        generic_params.iter().map(|it| it.self_ty_param).zip(0..).collect();\n+    let param_count = param_map.len();\n+    let generic_params_upper_bound = param_count + generic_params.len();\n+    let node_count = generic_params_upper_bound + where_preds.len();\n+\n+    // | node index range                        | what the node represents |\n+    // |-----------------------------------------|--------------------------|\n+    // | 0..param_count                          | generic parameter        |\n+    // | param_count..generic_params_upper_bound | `ast::GenericParam`      |\n+    // | generic_params_upper_bound..node_count  | `ast::WherePred`         |\n+    let mut graph = Graph::new(node_count);\n+    for (pred, pred_idx) in generic_params.iter().zip(param_count..) {\n+        let param_idx = param_map[&pred.self_ty_param];\n+        graph.add_edge(param_idx, pred_idx);\n+        graph.add_edge(pred_idx, param_idx);\n+\n+        for param in &pred.other_params {\n+            let param_idx = param_map[param];\n+            graph.add_edge(pred_idx, param_idx);\n+        }\n+    }\n+    for (pred, pred_idx) in where_preds.iter().zip(generic_params_upper_bound..) {\n+        for param in &pred.self_ty_params {\n+            let param_idx = param_map[param];\n+            graph.add_edge(param_idx, pred_idx);\n+            graph.add_edge(pred_idx, param_idx);\n+        }\n+        for param in &pred.other_params {\n+            let param_idx = param_map[param];\n+            graph.add_edge(pred_idx, param_idx);\n+        }\n+    }\n+\n+    let starting_nodes = necessary_params.iter().map(|param| param_map[param]);\n+    let reachable = graph.compute_reachable_nodes(starting_nodes);\n+\n+    // Not pretty, but effective. If only there were `Vec::retain_index()`...\n+    let mut idx = param_count;\n+    generic_params.retain(|_| {\n+        idx += 1;\n+        reachable[idx - 1]\n+    });\n+    stdx::always!(idx == generic_params_upper_bound, \"inconsistent index\");\n+    where_preds.retain(|_| {\n+        idx += 1;\n+        reachable[idx - 1]\n+    });\n+}\n+\n+/// Filters out bounds from impl if we're generating the function into the same impl we're\n+/// generating from.\n+fn filter_bounds_in_scope(\n+    generic_params: &mut Vec<ParamBoundWithParams>,\n+    where_preds: &mut Vec<WherePredWithParams>,\n+    ctx: &AssistContext<'_>,\n+    target: &GeneratedFunctionTarget,\n+) -> Option<()> {\n+    let target_impl = target.parent().ancestors().find_map(ast::Impl::cast)?;\n+    let target_impl = ctx.sema.to_def(&target_impl)?;\n+    // It's sufficient to test only the first element of `generic_params` because of the order of\n+    // insertion (see `relevant_parmas_and_where_clauses()`).\n+    let def = generic_params.first()?.self_ty_param.parent();\n+    if def != hir::GenericDef::Impl(target_impl) {\n+        return None;\n+    }\n+\n+    // Now we know every element that belongs to an impl would be in scope at `target`, we can\n+    // filter them out just by lookint at their parent.\n+    generic_params.retain(|it| !matches!(it.self_ty_param.parent(), hir::GenericDef::Impl(_)));\n+    where_preds.retain(|it| {\n+        it.node.syntax().parent().and_then(|it| it.parent()).and_then(ast::Impl::cast).is_none()\n+    });\n+\n+    Some(())\n+}\n+\n /// Makes duplicate argument names unique by appending incrementing numbers.\n ///\n /// ```\n@@ -564,17 +955,25 @@ fn fn_arg_name(sema: &Semantics<'_, RootDatabase>, arg_expr: &ast::Expr) -> Stri\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistContext<'_>, target_module: hir::Module, fn_arg: &ast::Expr) -> String {\n+fn fn_arg_type(\n+    ctx: &AssistContext<'_>,\n+    target_module: hir::Module,\n+    fn_arg: &ast::Expr,\n+    generic_params: &mut FxHashSet<hir::GenericParam>,\n+) -> String {\n     fn maybe_displayed_type(\n         ctx: &AssistContext<'_>,\n         target_module: hir::Module,\n         fn_arg: &ast::Expr,\n+        generic_params: &mut FxHashSet<hir::GenericParam>,\n     ) -> Option<String> {\n         let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n         if ty.is_unknown() {\n             return None;\n         }\n \n+        generic_params.extend(ty.generic_params(ctx.db()));\n+\n         if ty.is_reference() || ty.is_mutable_reference() {\n             let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(fn_arg.syntax())?.krate());\n             convert_reference_type(ty.strip_references(), ctx.db(), famous_defs)\n@@ -585,7 +984,8 @@ fn fn_arg_type(ctx: &AssistContext<'_>, target_module: hir::Module, fn_arg: &ast\n         }\n     }\n \n-    maybe_displayed_type(ctx, target_module, fn_arg).unwrap_or_else(|| String::from(\"_\"))\n+    maybe_displayed_type(ctx, target_module, fn_arg, generic_params)\n+        .unwrap_or_else(|| String::from(\"_\"))\n }\n \n /// Returns the position inside the current mod or file\n@@ -640,10 +1040,11 @@ fn next_space_for_fn_in_module(\n }\n \n fn next_space_for_fn_in_impl(impl_: &ast::Impl) -> Option<GeneratedFunctionTarget> {\n-    if let Some(last_item) = impl_.assoc_item_list().and_then(|it| it.assoc_items().last()) {\n+    let assoc_item_list = impl_.assoc_item_list()?;\n+    if let Some(last_item) = assoc_item_list.assoc_items().last() {\n         Some(GeneratedFunctionTarget::BehindItem(last_item.syntax().clone()))\n     } else {\n-        Some(GeneratedFunctionTarget::InEmptyItemList(impl_.assoc_item_list()?.syntax().clone()))\n+        Some(GeneratedFunctionTarget::InEmptyItemList(assoc_item_list.syntax().clone()))\n     }\n }\n \n@@ -659,6 +1060,73 @@ fn module_is_descendant(module: &hir::Module, ans: &hir::Module, ctx: &AssistCon\n     false\n }\n \n+// This is never intended to be used as a generic graph strucuture. If there's ever another need of\n+// graph algorithm, consider adding a library for that (and replace the following).\n+/// Minimally implemented directed graph structure represented by adjacency list.\n+struct Graph {\n+    edges: Vec<Vec<usize>>,\n+}\n+\n+impl Graph {\n+    fn new(node_count: usize) -> Self {\n+        Self { edges: vec![Vec::new(); node_count] }\n+    }\n+\n+    fn add_edge(&mut self, from: usize, to: usize) {\n+        self.edges[from].push(to);\n+    }\n+\n+    fn edges_for(&self, node_idx: usize) -> &[usize] {\n+        &self.edges[node_idx]\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.edges.len()\n+    }\n+\n+    fn compute_reachable_nodes(\n+        &self,\n+        starting_nodes: impl IntoIterator<Item = usize>,\n+    ) -> Vec<bool> {\n+        let mut visitor = Visitor::new(self);\n+        for idx in starting_nodes {\n+            visitor.mark_reachable(idx);\n+        }\n+        visitor.visited\n+    }\n+}\n+\n+struct Visitor<'g> {\n+    graph: &'g Graph,\n+    visited: Vec<bool>,\n+    // Stack is held in this struct so we can reuse its buffer.\n+    stack: Vec<usize>,\n+}\n+\n+impl<'g> Visitor<'g> {\n+    fn new(graph: &'g Graph) -> Self {\n+        let visited = vec![false; graph.len()];\n+        Self { graph, visited, stack: Vec::new() }\n+    }\n+\n+    fn mark_reachable(&mut self, start_idx: usize) {\n+        // non-recursive DFS\n+        stdx::always!(self.stack.is_empty());\n+\n+        self.stack.push(start_idx);\n+        while let Some(idx) = self.stack.pop() {\n+            if !self.visited[idx] {\n+                self.visited[idx] = true;\n+                for &neighbor in self.graph.edges_for(idx) {\n+                    if !self.visited[neighbor] {\n+                        self.stack.push(neighbor);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -1087,27 +1555,302 @@ fn bar(baz: Baz::Bof) {\n     }\n \n     #[test]\n-    fn add_function_with_generic_arg() {\n-        // FIXME: This is wrong, generated `bar` should include generic parameter.\n+    fn generate_function_with_generic_param() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+fn foo<T, const N: usize>(t: [T; N]) { $0bar(t) }\n+\",\n+            r\"\n+fn foo<T, const N: usize>(t: [T; N]) { bar(t) }\n+\n+fn bar<T, const N: usize>(t: [T; N]) {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generate_function_with_parent_generic_param() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo<U>(t: T, u: U) { $0bar(t, u) }\n+}\n+\",\n+            r\"\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo<U>(t: T, u: U) { bar(t, u) }\n+}\n+\n+fn bar<T, U>(t: T, u: U) {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generic_param_in_receiver_type() {\n+        // FIXME: Generic parameter `T` should be part of impl, not method.\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S<T>(T);\n+fn foo<T, U>(s: S<T>, u: U) { s.$0foo(u) }\n+\",\n+            r\"\n+struct S<T>(T);\n+impl S {\n+    fn foo<T, U>(&self, u: U) {\n+        ${0:todo!()}\n+    }\n+}\n+fn foo<T, U>(s: S<T>, u: U) { s.foo(u) }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generic_param_in_return_type() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+fn foo<T, const N: usize>() -> [T; N] { $0bar() }\n+\",\n+            r\"\n+fn foo<T, const N: usize>() -> [T; N] { bar() }\n+\n+fn bar<T, const N: usize>() -> [T; N] {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generate_fn_with_bounds() {\n+        // FIXME: where predicates should be on next lines.\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<i64>,\n+{\n+    fn foo<U>(t: T, u: U)\n+    where\n+        T: A<()>,\n+        U: A<i32> + A<i64>,\n+    {\n+        $0bar(t, u)\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<i64>,\n+{\n+    fn foo<U>(t: T, u: U)\n+    where\n+        T: A<()>,\n+        U: A<i32> + A<i64>,\n+    {\n+        bar(t, u)\n+    }\n+}\n+\n+fn bar<T: A<i32>, U>(t: T, u: U) where T: A<i64>, T: A<()>, U: A<i32> + A<i64> {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn include_transitive_param_dependency() {\n+        // FIXME: where predicates should be on next lines.\n         check_assist(\n             generate_function,\n             r\"\n-fn foo<T>(t: T) {\n-    $0bar(t)\n+trait A<T> { type Assoc; }\n+trait B { type Item; }\n+struct S<T>(T);\n+impl<T, U, V: B, W> S<(T, U, V, W)>\n+where\n+    T: A<U, Assoc = V>,\n+    S<V::Item>: A<U, Assoc = W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T, Assoc = I>,\n+    {\n+        $0bar(u)\n+    }\n }\n \",\n             r\"\n-fn foo<T>(t: T) {\n-    bar(t)\n+trait A<T> { type Assoc; }\n+trait B { type Item; }\n+struct S<T>(T);\n+impl<T, U, V: B, W> S<(T, U, V, W)>\n+where\n+    T: A<U, Assoc = V>,\n+    S<V::Item>: A<U, Assoc = W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T, Assoc = I>,\n+    {\n+        bar(u)\n+    }\n }\n \n-fn bar(t: T) {\n+fn bar<T, U, V: B, W, I>(u: U) where T: A<U, Assoc = V>, S<V::Item>: A<U, Assoc = W>, U: A<T, Assoc = I> {\n     ${0:todo!()}\n }\n \",\n         )\n     }\n \n+    #[test]\n+    fn irrelevant_bounds_are_filtered_out() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U, V, W> S<(T, U, V, W)>\n+where\n+    T: A<U>,\n+    V: A<W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T> + A<I>,\n+    {\n+        $0bar(u)\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U, V, W> S<(T, U, V, W)>\n+where\n+    T: A<U>,\n+    V: A<W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T> + A<I>,\n+    {\n+        bar(u)\n+    }\n+}\n+\n+fn bar<T, U, I>(u: U) where T: A<U>, U: A<T> + A<I> {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn params_in_trait_arg_are_not_dependency() {\n+        // Even though `bar` depends on `U` and `I`, we don't have to copy these bounds:\n+        // `T: A<I>` and `T: A<U>`.\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U> S<(T, U)>\n+where\n+    T: A<U>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        T: A<I>,\n+        U: A<I>,\n+    {\n+        $0bar(u)\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U> S<(T, U)>\n+where\n+    T: A<U>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        T: A<I>,\n+        U: A<I>,\n+    {\n+        bar(u)\n+    }\n+}\n+\n+fn bar<U, I>(u: U) where U: A<I> {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_copy_bounds_already_in_scope() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<usize>,\n+{\n+    fn foo<U: A<()>>(t: T, u: U)\n+    where\n+        T: A<S<i32>>,\n+    {\n+        Self::$0bar(t, u);\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<usize>,\n+{\n+    fn foo<U: A<()>>(t: T, u: U)\n+    where\n+        T: A<S<i32>>,\n+    {\n+        Self::bar(t, u);\n+    }\n+\n+    fn bar<U: A<()>>(t: T, u: U) ${0:-> _} where T: A<S<i32>> {\n+        todo!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_with_fn_arg() {\n         // FIXME: The argument in `bar` is wrong.\n@@ -1289,6 +2032,50 @@ fn baz(foo: foo::Foo) {\n         )\n     }\n \n+    #[test]\n+    fn qualified_path_in_generic_bounds_uses_correct_scope() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+mod a {\n+    pub trait A {};\n+}\n+pub mod b {\n+    pub struct S<T>(T);\n+}\n+struct S<T>(T);\n+impl<T> S<T>\n+where\n+    T: a::A,\n+{\n+    fn foo<U: a::A>(t: b::S<T>, u: S<U>) {\n+        a::$0bar(t, u);\n+    }\n+}\n+\",\n+            r\"\n+mod a {\n+    pub trait A {}\n+\n+    pub(crate) fn bar<T, U: self::A>(t: crate::b::S<T>, u: crate::S<U>) ${0:-> _} where T: self::A {\n+        todo!()\n+    };\n+}\n+pub mod b {\n+    pub struct S<T>(T);\n+}\n+struct S<T>(T);\n+impl<T> S<T>\n+where\n+    T: a::A,\n+{\n+    fn foo<U: a::A>(t: b::S<T>, u: S<U>) {\n+        a::bar(t, u);\n+    }\n+}\n+\",\n+        )\n+    }\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n@@ -1606,6 +2393,26 @@ fn foo() {S::bar();}\n         )\n     }\n \n+    #[test]\n+    fn create_generic_static_method() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo<T, const N: usize>(t: [T; N]) { S::bar$0(t); }\n+\",\n+            r\"\n+struct S;\n+impl S {\n+    fn bar<T, const N: usize>(t: [T; N]) ${0:-> _} {\n+        todo!()\n+    }\n+}\n+fn foo<T, const N: usize>(t: [T; N]) { S::bar(t); }\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn create_static_method_within_an_impl() {\n         check_assist("}, {"sha": "6402a84a68bb350045286fba2896bd694c94766d", "filename": "crates/ide-db/src/path_transform.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fide-db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fide-db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fpath_transform.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -33,7 +33,7 @@ use syntax::{\n /// }\n /// ```\n pub struct PathTransform<'a> {\n-    generic_def: hir::GenericDef,\n+    generic_def: Option<hir::GenericDef>,\n     substs: Vec<ast::Type>,\n     target_scope: &'a SemanticsScope<'a>,\n     source_scope: &'a SemanticsScope<'a>,\n@@ -49,7 +49,7 @@ impl<'a> PathTransform<'a> {\n         PathTransform {\n             source_scope,\n             target_scope,\n-            generic_def: trait_.into(),\n+            generic_def: Some(trait_.into()),\n             substs: get_syntactic_substs(impl_).unwrap_or_default(),\n         }\n     }\n@@ -63,28 +63,42 @@ impl<'a> PathTransform<'a> {\n         PathTransform {\n             source_scope,\n             target_scope,\n-            generic_def: function.into(),\n+            generic_def: Some(function.into()),\n             substs: get_type_args_from_arg_list(generic_arg_list).unwrap_or_default(),\n         }\n     }\n \n+    pub fn generic_transformation(\n+        target_scope: &'a SemanticsScope<'a>,\n+        source_scope: &'a SemanticsScope<'a>,\n+    ) -> PathTransform<'a> {\n+        PathTransform { source_scope, target_scope, generic_def: None, substs: Vec::new() }\n+    }\n+\n     pub fn apply(&self, syntax: &SyntaxNode) {\n         self.build_ctx().apply(syntax)\n     }\n \n+    pub fn apply_all<'b>(&self, nodes: impl IntoIterator<Item = &'b SyntaxNode>) {\n+        let ctx = self.build_ctx();\n+        for node in nodes {\n+            ctx.apply(node);\n+        }\n+    }\n+\n     fn build_ctx(&self) -> Ctx<'a> {\n         let db = self.source_scope.db;\n         let target_module = self.target_scope.module();\n         let source_module = self.source_scope.module();\n         let skip = match self.generic_def {\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n-            hir::GenericDef::Trait(_) => 1,\n+            Some(hir::GenericDef::Trait(_)) => 1,\n             _ => 0,\n         };\n         let substs_by_param: FxHashMap<_, _> = self\n             .generic_def\n-            .type_params(db)\n             .into_iter()\n+            .flat_map(|it| it.type_params(db))\n             .skip(skip)\n             // The actual list of trait type parameters may be longer than the one\n             // used in the `impl` block due to trailing default type parameters."}, {"sha": "78ed2a73e581a8b1fc7b24874fafe6aefb31efca", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceba748053cc365a55c3c73798186ceec09991/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=eeceba748053cc365a55c3c73798186ceec09991", "patch": "@@ -823,6 +823,7 @@ pub fn fn_(\n     visibility: Option<ast::Visibility>,\n     fn_name: ast::Name,\n     type_params: Option<ast::GenericParamList>,\n+    where_clause: Option<ast::WhereClause>,\n     params: ast::ParamList,\n     body: ast::BlockExpr,\n     ret_type: Option<ast::RetType>,\n@@ -832,6 +833,10 @@ pub fn fn_(\n         Some(type_params) => format!(\"{type_params}\"),\n         None => \"\".into(),\n     };\n+    let where_clause = match where_clause {\n+        Some(it) => format!(\"{it} \"),\n+        None => \"\".into(),\n+    };\n     let ret_type = match ret_type {\n         Some(ret_type) => format!(\"{ret_type} \"),\n         None => \"\".into(),\n@@ -844,7 +849,7 @@ pub fn fn_(\n     let async_literal = if is_async { \"async \" } else { \"\" };\n \n     ast_from_text(&format!(\n-        \"{visibility}{async_literal}fn {fn_name}{type_params}{params} {ret_type}{body}\",\n+        \"{visibility}{async_literal}fn {fn_name}{type_params}{params} {ret_type}{where_clause}{body}\",\n     ))\n }\n "}]}