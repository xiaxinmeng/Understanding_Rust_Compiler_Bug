{"sha": "f49d878ce5aede7e99d284a97cfdca321314ccc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OWQ4NzhjZTVhZWRlN2U5OWQyODRhOTdjZmRjYTMyMTMxNGNjYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-15T05:40:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-15T05:40:02Z"}, "message": "Auto merge of #4066 - rust-lang:hash, r=Manishearth\n\nProperly hash enums\n\nWhile I wrote this I was saved by a clippy lint... I accidentally fetched the discriminant of a reference to an enum and not of an enum.\n\nchangelog: reduce hash collisions during clippy-internal hashing", "tree": {"sha": "984db4b556c023b9f33a3b2db9b7b75621c115b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/984db4b556c023b9f33a3b2db9b7b75621c115b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f49d878ce5aede7e99d284a97cfdca321314ccc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f49d878ce5aede7e99d284a97cfdca321314ccc2", "html_url": "https://github.com/rust-lang/rust/commit/f49d878ce5aede7e99d284a97cfdca321314ccc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f49d878ce5aede7e99d284a97cfdca321314ccc2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b2dfb9f6113b074746c7702d9e28162770b52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/82b2dfb9f6113b074746c7702d9e28162770b52f", "html_url": "https://github.com/rust-lang/rust/commit/82b2dfb9f6113b074746c7702d9e28162770b52f"}, {"sha": "5dea5d404c389417e960c52ed5f386699a13d904", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dea5d404c389417e960c52ed5f386699a13d904", "html_url": "https://github.com/rust-lang/rust/commit/5dea5d404c389417e960c52ed5f386699a13d904"}], "stats": {"total": 122, "additions": 21, "deletions": 101}, "files": [{"sha": "cbc10768bbc1604dc7b24e0fd395750a5616a9cd", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f49d878ce5aede7e99d284a97cfdca321314ccc2/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49d878ce5aede7e99d284a97cfdca321314ccc2/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=f49d878ce5aede7e99d284a97cfdca321314ccc2", "patch": "@@ -81,6 +81,7 @@ impl Hash for Constant {\n     where\n         H: Hasher,\n     {\n+        std::mem::discriminant(self).hash(state);\n         match *self {\n             Constant::Str(ref s) => {\n                 s.hash(state);"}, {"sha": "702738b6696cc18a0ac269ab3277c01fbb470cf2", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 20, "deletions": 101, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f49d878ce5aede7e99d284a97cfdca321314ccc2/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49d878ce5aede7e99d284a97cfdca321314ccc2/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=f49d878ce5aede7e99d284a97cfdca321314ccc2", "patch": "@@ -389,84 +389,65 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n     pub fn hash_expr(&mut self, e: &Expr) {\n-        if let Some(e) = constant_simple(self.cx, self.tables, e) {\n+        let simple_const = constant_simple(self.cx, self.tables, e);\n+\n+        // const hashing may result in the same hash as some unrelated node, so add a sort of\n+        // discriminant depending on which path we're choosing next\n+        simple_const.is_some().hash(&mut self.s);\n+\n+        if let Some(e) = simple_const {\n             return e.hash(&mut self.s);\n         }\n \n+        std::mem::discriminant(&e.node).hash(&mut self.s);\n+\n         match e.node {\n             ExprKind::AddrOf(m, ref e) => {\n-                let c: fn(_, _) -> _ = ExprKind::AddrOf;\n-                c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n             ExprKind::Continue(i) => {\n-                let c: fn(_) -> _ = ExprKind::Continue;\n-                c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprKind::Yield(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::Yield;\n-                c.hash(&mut self.s);\n-                self.hash_expr(e);\n-            },\n             ExprKind::Assign(ref l, ref r) => {\n-                let c: fn(_, _) -> _ = ExprKind::Assign;\n-                c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::AssignOp(ref o, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::AssignOp;\n-                c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::Block(ref b, _) => {\n-                let c: fn(_, _) -> _ = ExprKind::Block;\n-                c.hash(&mut self.s);\n                 self.hash_block(b);\n             },\n             ExprKind::Binary(op, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Binary;\n-                c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::Break(i, ref j) => {\n-                let c: fn(_, _) -> _ = ExprKind::Break;\n-                c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n                 }\n             },\n-            ExprKind::Box(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::Box;\n-                c.hash(&mut self.s);\n+            ExprKind::Box(ref e) | ExprKind::DropTemps(ref e) | ExprKind::Yield(ref e) => {\n                 self.hash_expr(e);\n             },\n             ExprKind::Call(ref fun, ref args) => {\n-                let c: fn(_, _) -> _ = ExprKind::Call;\n-                c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprKind::Cast(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprKind::Cast;\n-                c.hash(&mut self.s);\n+            ExprKind::Cast(ref e, ref _ty) | ExprKind::Type(ref e, ref _ty) => {\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n             ExprKind::Closure(cap, _, eid, _, _) => {\n-                let c: fn(_, _, _, _, _) -> _ = ExprKind::Closure;\n-                c.hash(&mut self.s);\n                 match cap {\n                     CaptureClause::CaptureByValue => 0,\n                     CaptureClause::CaptureByRef => 1,\n@@ -475,37 +456,24 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n             ExprKind::Field(ref e, ref f) => {\n-                let c: fn(_, _) -> _ = ExprKind::Field;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n             ExprKind::Index(ref a, ref i) => {\n-                let c: fn(_, _) -> _ = ExprKind::Index;\n-                c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprKind::InlineAsm(..) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::InlineAsm;\n-                c.hash(&mut self.s);\n-            },\n+            ExprKind::InlineAsm(..) | ExprKind::Err => {},\n             ExprKind::Lit(ref l) => {\n-                let c: fn(_) -> _ = ExprKind::Lit;\n-                c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n             },\n             ExprKind::Loop(ref b, ref i, _) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Loop;\n-                c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n             ExprKind::Match(ref e, ref arms, ref s) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Match;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n \n                 for arm in arms {\n@@ -519,36 +487,25 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 s.hash(&mut self.s);\n             },\n             ExprKind::MethodCall(ref path, ref _tys, ref args) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::MethodCall;\n-                c.hash(&mut self.s);\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n             ExprKind::Repeat(ref e, ref l_id) => {\n-                let c: fn(_, _) -> _ = ExprKind::Repeat;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id.body);\n                 self.hash_expr(&self.cx.tcx.hir().body(l_id.body).value);\n                 self.tables = full_table;\n             },\n             ExprKind::Ret(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::Ret;\n-                c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n             ExprKind::Path(ref qpath) => {\n-                let c: fn(_) -> _ = ExprKind::Path;\n-                c.hash(&mut self.s);\n                 self.hash_qpath(qpath);\n             },\n             ExprKind::Struct(ref path, ref fields, ref expr) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Struct;\n-                c.hash(&mut self.s);\n-\n                 self.hash_qpath(path);\n \n                 for f in fields {\n@@ -560,46 +517,20 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprKind::Tup(ref tup) => {\n-                let c: fn(_) -> _ = ExprKind::Tup;\n-                c.hash(&mut self.s);\n-                self.hash_exprs(tup);\n-            },\n-            ExprKind::Type(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprKind::Type;\n-                c.hash(&mut self.s);\n-                self.hash_expr(e);\n-                // TODO: _ty\n+            ExprKind::Tup(ref v) | ExprKind::Array(ref v) => {\n+                self.hash_exprs(v);\n             },\n             ExprKind::Unary(lop, ref le) => {\n-                let c: fn(_, _) -> _ = ExprKind::Unary;\n-                c.hash(&mut self.s);\n-\n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n-            ExprKind::Array(ref v) => {\n-                let c: fn(_) -> _ = ExprKind::Array;\n-                c.hash(&mut self.s);\n-\n-                self.hash_exprs(v);\n-            },\n             ExprKind::While(ref cond, ref b, l) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::While;\n-                c.hash(&mut self.s);\n-\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n                     self.hash_name(l.ident.name);\n                 }\n             },\n-            ExprKind::Err => {},\n-            ExprKind::DropTemps(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::DropTemps;\n-                c.hash(&mut self.s);\n-                self.hash_expr(e);\n-            },\n         }\n     }\n \n@@ -633,26 +564,16 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_stmt(&mut self, b: &Stmt) {\n-        match b.node {\n-            StmtKind::Local(ref local) => {\n-                let c: fn(_) -> _ = StmtKind::Local;\n-                c.hash(&mut self.s);\n+        std::mem::discriminant(&b.node).hash(&mut self.s);\n+\n+        match &b.node {\n+            StmtKind::Local(local) => {\n                 if let Some(ref init) = local.init {\n                     self.hash_expr(init);\n                 }\n             },\n-            StmtKind::Item(..) => {\n-                let c: fn(_) -> _ = StmtKind::Item;\n-                c.hash(&mut self.s);\n-            },\n-            StmtKind::Expr(ref expr) => {\n-                let c: fn(_) -> _ = StmtKind::Expr;\n-                c.hash(&mut self.s);\n-                self.hash_expr(expr);\n-            },\n-            StmtKind::Semi(ref expr) => {\n-                let c: fn(_) -> _ = StmtKind::Semi;\n-                c.hash(&mut self.s);\n+            StmtKind::Item(..) => {},\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n                 self.hash_expr(expr);\n             },\n         }\n@@ -661,8 +582,6 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_guard(&mut self, g: &Guard) {\n         match g {\n             Guard::If(ref expr) => {\n-                let c: fn(_) -> _ = Guard::If;\n-                c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },\n         }"}]}