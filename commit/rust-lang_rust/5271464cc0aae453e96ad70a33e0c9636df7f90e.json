{"sha": "5271464cc0aae453e96ad70a33e0c9636df7f90e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNzE0NjRjYzBhYWU0NTNlOTZhZDcwYTMzZTBjOTYzNmRmN2Y5MGU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-25T05:27:51Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T04:48:12Z"}, "message": "libsyntax: remove vecs_implicitly_copyable from the syntax extensions", "tree": {"sha": "09dc98a7897d85b8deac21ad2e2227dab8c99fba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09dc98a7897d85b8deac21ad2e2227dab8c99fba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5271464cc0aae453e96ad70a33e0c9636df7f90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5271464cc0aae453e96ad70a33e0c9636df7f90e", "html_url": "https://github.com/rust-lang/rust/commit/5271464cc0aae453e96ad70a33e0c9636df7f90e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5271464cc0aae453e96ad70a33e0c9636df7f90e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1652f34fee38f3d88f5944c86f159c0f7d7fee", "html_url": "https://github.com/rust-lang/rust/commit/5f1652f34fee38f3d88f5944c86f159c0f7d7fee"}], "stats": {"total": 275, "additions": 151, "deletions": 124}, "files": [{"sha": "ea8678ed208dc21e53c1049c1106faad723057ba", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -143,8 +143,8 @@ pub fn expand_auto_encode(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        *enum_def,\n-                        *tps\n+                        copy *enum_def,\n+                        copy *tps\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n@@ -188,7 +188,7 @@ pub fn expand_auto_decode(\n                         item.span,\n                         item.ident,\n                         struct_def.fields,\n-                        *tps\n+                        copy *tps\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n@@ -198,8 +198,8 @@ pub fn expand_auto_decode(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        *enum_def,\n-                        *tps\n+                        copy *enum_def,\n+                        copy *tps\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n@@ -346,7 +346,7 @@ priv impl ext_ctxt {\n \n     fn lambda(+blk: ast::blk) -> @ast::expr {\n         let ext_cx = self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n         quote_expr!( || $blk_e )\n     }\n \n@@ -840,14 +840,14 @@ fn mk_enum_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    enum_def: ast::enum_def,\n+    +enum_def: ast::enum_def,\n     tps: ~[ast::ty_param]\n ) -> @ast::item {\n     let body = mk_enum_ser_body(\n         cx,\n         span,\n         ident,\n-        enum_def.variants\n+        copy enum_def.variants\n     );\n \n     mk_ser_impl(cx, span, ident, tps, body)\n@@ -857,7 +857,7 @@ fn mk_enum_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    enum_def: ast::enum_def,\n+    +enum_def: ast::enum_def,\n     tps: ~[ast::ty_param]\n ) -> @ast::item {\n     let body = mk_enum_deser_body(\n@@ -960,8 +960,14 @@ fn mk_enum_ser_body(\n ) -> @ast::expr {\n     let arms = do variants.mapi |v_idx, variant| {\n         match variant.node.kind {\n-            ast::tuple_variant_kind(args) =>\n-                ser_variant(cx, span, variant.node.name, v_idx, args),\n+            ast::tuple_variant_kind(ref args) =>\n+                ser_variant(\n+                    cx,\n+                    span,\n+                    variant.node.name,\n+                    v_idx,\n+                    /*bad*/ copy *args\n+                ),\n             ast::struct_variant_kind(*) =>\n                 fail!(~\"struct variants unimplemented\"),\n             ast::enum_variant_kind(*) =>\n@@ -1041,7 +1047,7 @@ fn mk_enum_deser_body(\n ) -> @ast::expr {\n     let mut arms = do variants.mapi |v_idx, variant| {\n         let body = match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n+            ast::tuple_variant_kind(ref args) => {\n                 if args.is_empty() {\n                     // for a nullary variant v, do \"v\"\n                     ext_cx.expr_path(span, ~[variant.node.name])\n@@ -1051,7 +1057,7 @@ fn mk_enum_deser_body(\n                         ext_cx,\n                         span,\n                         variant.node.name,\n-                        args\n+                        copy *args\n                     )\n                 }\n             },\n@@ -1074,7 +1080,7 @@ fn mk_enum_deser_body(\n         }\n     };\n \n-    let quoted_expr = quote_expr!(\n+    let quoted_expr = copy quote_expr!(\n       ::core::sys::begin_unwind(~\"explicit failure\", ~\"empty\", 1);\n     ).node;\n "}, {"sha": "9d597b539bbf21fe2bbb16390e67e3566dd8e13f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -192,7 +192,7 @@ pub trait ext_ctxt {\n }\n \n pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n-               cfg: ast::crate_cfg) -> ext_ctxt {\n+               +cfg: ast::crate_cfg) -> ext_ctxt {\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n@@ -203,7 +203,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     impl ext_ctxt for CtxtRepr {\n         fn codemap(@mut self) -> @CodeMap { self.parse_sess.cm }\n         fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n-        fn cfg(@mut self) -> ast::crate_cfg { self.cfg }\n+        fn cfg(@mut self) -> ast::crate_cfg { copy self.cfg }\n         fn call_site(@mut self) -> span {\n             match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n@@ -214,15 +214,15 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n         fn backtrace(@mut self) -> Option<@ExpnInfo> { *self.backtrace }\n         fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n         fn mod_pop(@mut self) { self.mod_path.pop(); }\n-        fn mod_path(@mut self) -> ~[ast::ident] { return self.mod_path; }\n+        fn mod_path(@mut self) -> ~[ast::ident] { copy self.mod_path }\n         fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n                     Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n-                        callee: (*callee)}));\n+                        callee: copy *callee}));\n               }\n             }\n         }\n@@ -269,12 +269,11 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n         fn set_trace_macros(@mut self, x: bool) {\n             self.trace_mac = x\n         }\n-\n         fn str_of(@mut self, id: ast::ident) -> ~str {\n-            *self.parse_sess.interner.get(id)\n+            copy *self.parse_sess.interner.get(id)\n         }\n         fn ident_of(@mut self, st: ~str) -> ast::ident {\n-            self.parse_sess.interner.intern(@st)\n+            self.parse_sess.interner.intern(@/*bad*/ copy st)\n         }\n     }\n     let imp: @mut CtxtRepr = @mut CtxtRepr {\n@@ -290,7 +289,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n-        ast::lit_str(s) => return *s,\n+        ast::lit_str(s) => copy *s,\n         _ => cx.span_fatal(l.span, err_msg)\n       },\n       _ => cx.span_fatal(expr.span, err_msg)"}, {"sha": "13a29c54b97fb5e47834b9365a0ae85f855a7b1e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -26,7 +26,7 @@ pub struct Field {\n \n pub fn mk_expr(cx: ext_ctxt,\n                sp: codemap::span,\n-               expr: ast::expr_)\n+               +expr: ast::expr_)\n             -> @ast::expr {\n     @ast::expr {\n         id: cx.next_id(),\n@@ -62,7 +62,7 @@ pub fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n-pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n     let p = @ast::path { span: sp,\n                          global: false,\n                          idents: idents,\n@@ -71,7 +71,7 @@ pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n     return p;\n }\n pub fn mk_raw_path_(sp: span,\n-                    idents: ~[ast::ident],\n+                    +idents: ~[ast::ident],\n                     +types: ~[@ast::Ty])\n                  -> @ast::path {\n     @ast::path { span: sp,\n@@ -80,25 +80,25 @@ pub fn mk_raw_path_(sp: span,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n     @ast::path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n                  types: ~[] }\n }\n-pub fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) -> @ast::expr {\n+pub fn mk_path(cx: ext_ctxt, sp: span, +idents: ~[ast::ident]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n-pub fn mk_path_global(cx: ext_ctxt, sp: span, idents: ~[ast::ident])\n+pub fn mk_path_global(cx: ext_ctxt, sp: span, +idents: ~[ast::ident])\n                    -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n }\n pub fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-pub fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n+pub fn mk_access(cx: ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n               -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n@@ -107,21 +107,21 @@ pub fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n pub fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n-                args: ~[@ast::expr]) -> @ast::expr {\n+                +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n-pub fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-               args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call(cx: ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n+               +args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-pub fn mk_call_global(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-                      args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call_global(cx: ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n+                      +args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-pub fn mk_base_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_base_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n@@ -131,25 +131,25 @@ pub fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr,\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-pub fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-pub fn mk_slice_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_slice_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_fixed(None))\n }\n-pub fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n pub fn mk_field(sp: span, f: &Field) -> ast::field {\n@@ -161,28 +161,36 @@ pub fn mk_field(sp: span, f: &Field) -> ast::field {\n pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n     fields.map(|f| mk_field(sp, f))\n }\n-pub fn mk_rec_e(cx: ext_ctxt, sp: span, fields: ~[Field]) -> @ast::expr {\n+pub fn mk_rec_e(cx: ext_ctxt,\n+                sp: span,\n+                +fields: ~[Field])\n+             -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_rec(mk_fields(sp, fields),\n                                   option::None::<@ast::expr>))\n }\n-pub fn mk_struct_e(cx: ext_ctxt, sp: span, ctor_path: ~[ast::ident],\n-                   fields: ~[Field]) -> @ast::expr {\n+pub fn mk_struct_e(cx: ext_ctxt,\n+                   sp: span,\n+                   +ctor_path: ~[ast::ident],\n+                   +fields: ~[Field])\n+                -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_global_struct_e(cx: ext_ctxt, sp: span,\n-                          ctor_path: ~[ast::ident],\n-                          fields: ~[Field])\n+pub fn mk_global_struct_e(cx: ext_ctxt,\n+                          sp: span,\n+                          +ctor_path: ~[ast::ident],\n+                          +fields: ~[Field])\n                        -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_glob_use(cx: ext_ctxt, sp: span, path: ~[ast::ident])\n-            -> @ast::view_item {\n+pub fn mk_glob_use(cx: ext_ctxt,\n+                   sp: span,\n+                   +path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n@@ -218,8 +226,8 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n     @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n pub fn mk_block(cx: ext_ctxt, span: span,\n-                view_items: ~[@ast::view_item],\n-                stmts: ~[@ast::stmt],\n+                +view_items: ~[@ast::view_item],\n+                +stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n     let blk = codemap::spanned {\n         node: ast::blk_ {\n@@ -313,7 +321,7 @@ pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n }\n pub fn mk_ty_path(cx: ext_ctxt,\n                   span: span,\n-                  idents: ~[ ast::ident ])\n+                  +idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n@@ -322,7 +330,7 @@ pub fn mk_ty_path(cx: ext_ctxt,\n }\n pub fn mk_ty_path_global(cx: ext_ctxt,\n                          span: span,\n-                         idents: ~[ ast::ident ])\n+                         +idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());"}, {"sha": "54fb6bd3bb6ea00c26be41d59168b47a17452122", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -472,8 +472,8 @@ fn call_substructure_iter_bytes_method(cx: ext_ctxt,\n \n fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n     match variant.node.kind {\n-        tuple_variant_kind(args) => args.len(),\n-        struct_variant_kind(struct_def) => struct_def.fields.len(),\n+        tuple_variant_kind(ref args) => args.len(),\n+        struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n         enum_variant_kind(*) => {\n             cx.span_bug(span, ~\"variant_arg_count: enum variants deprecated\")\n         }"}, {"sha": "030e819ca3f1c23fc1631d1b9598b7b17f9bba95", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -31,8 +31,8 @@ pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      option::None => mk_uniq_str(cx, sp, ~\"\"),\n-      option::Some(ref s) => mk_uniq_str(cx, sp, (*s))\n+      None => mk_uniq_str(cx, sp, ~\"\"),\n+      Some(ref s) => mk_uniq_str(cx, sp, copy *s)\n     };\n     MRExpr(e)\n }"}, {"sha": "282506929ffdec8fe509cf2d5f167b995b3d22c8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -52,7 +52,7 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n                             cx.bt_push(ExpandedFrom(CallInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n-                                    name: *extname,\n+                                    name: copy *extname,\n                                     span: exp_sp,\n                                 },\n                             }));\n@@ -72,7 +72,8 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n                             };\n \n                             //keep going, outside-in\n-                            let fully_expanded = fld.fold_expr(expanded).node;\n+                            let fully_expanded =\n+                                copy fld.fold_expr(expanded).node;\n                             cx.bt_pop();\n \n                             (fully_expanded, s)\n@@ -169,7 +170,7 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n \n     let (pth, tts) = match it.node {\n         item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n-            (pth, (*tts))\n+            (pth, copy *tts)\n         }\n         _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n     };\n@@ -189,8 +190,8 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: *extname,\n-                    span: (*expand).span\n+                    name: copy *extname,\n+                    span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, tts)\n@@ -204,8 +205,8 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: *extname,\n-                    span: (*expand).span\n+                    name: copy *extname,\n+                    span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n@@ -238,7 +239,9 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n-                mac_invoc_tt(pth, ref tts) => ((*mac), pth, (*tts), semi)\n+                mac_invoc_tt(pth, ref tts) => {\n+                    (copy *mac, pth, copy *tts, semi)\n+                }\n             }\n         }\n         _ => return orig(s, sp, fld)\n@@ -254,7 +257,7 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n             SyntaxExpanderTT{expander: exp, span: exp_sp})) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n-                callee: NameAndSpan { name: *extname, span: exp_sp }\n+                callee: NameAndSpan { name: copy *extname, span: exp_sp }\n             }));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n@@ -267,7 +270,7 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n             };\n \n             //keep going, outside-in\n-            let fully_expanded = fld.fold_stmt(expanded).node;\n+            let fully_expanded = copy fld.fold_stmt(expanded).node;\n             cx.bt_pop();\n \n             (fully_expanded, sp)\n@@ -351,7 +354,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::crate_cfg, c: @crate) -> @crate {\n     let exts = syntax_expander_table();\n     let afp = default_ast_fold();\n-    let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n+    let cx: ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n     let f_pre = @AstFoldFns {\n         fold_expr: |a,b,c| expand_expr(exts, cx, a, b, c, afp.fold_expr),\n         fold_mod: |a,b| expand_mod_items(exts, cx, a, b, afp.fold_mod),\n@@ -362,7 +365,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(~\"<core-macros>\",\n                                         @core_macros(),\n-                                        cfg,\n+                                        copy cfg,\n                                         parse_sess);\n \n     // This is run for its side-effects on the expander env,"}, {"sha": "2169e8f6f2ffb389253e060c41119f3820e1873e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -276,19 +276,24 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     for pieces.each |pc| {\n         match *pc {\n           PieceString(ref s) => {\n-            piece_exprs.push(mk_uniq_str(cx, fmt_sp, (*s)))\n+            piece_exprs.push(mk_uniq_str(cx, fmt_sp, copy *s))\n           }\n-          PieceConv(conv) => {\n+          PieceConv(ref conv) => {\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n                               ~\"not enough arguments to fmt! \" +\n                                   ~\"for the given format string\");\n             }\n             debug!(\"Building conversion:\");\n-            log_conv(conv);\n+            log_conv(/*bad*/ copy *conv);\n             let arg_expr = args[n];\n-            let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n+            let c_expr = make_new_conv(\n+                cx,\n+                fmt_sp,\n+                /*bad*/ copy *conv,\n+                arg_expr\n+            );\n             piece_exprs.push(c_expr);\n           }\n         }"}, {"sha": "7917a072414a6fb63839164edfef8f4f0e1bca0b", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -58,14 +58,14 @@ pub impl append_types for @ast::path {\n     fn add_ty(&self, ty: @ast::Ty) -> @ast::path {\n         @ast::path {\n             types: vec::append_one(copy self.types, ty),\n-            .. **self\n+            .. copy **self\n         }\n     }\n \n     fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::path {\n         @ast::path {\n             types: vec::append(copy self.types, tys),\n-            .. **self\n+            .. copy **self\n         }\n     }\n }\n@@ -97,12 +97,12 @@ pub trait ext_ctxt_ast_builder {\n                  +enum_definition: ast::enum_def) -> @ast::item;\n     fn item_struct_poly(&self,\n         name: ident, span: span,\n-        struct_def: ast::struct_def,\n+        +struct_def: ast::struct_def,\n         +ty_params: ~[ast::ty_param]) -> @ast::item;\n     fn item_struct(&self, name: ident, span: span,\n-                   struct_def: ast::struct_def) -> @ast::item;\n+                   +struct_def: ast::struct_def) -> @ast::item;\n     fn struct_expr(&self, path: @ast::path,\n-                   fields: ~[ast::field]) -> @ast::expr;\n+                   +fields: ~[ast::field]) -> @ast::expr;\n     fn variant(&self, name: ident, span: span,\n                +tys: ~[@ast::Ty]) -> ast::variant;\n     fn item_mod(&self, name: ident, span: span,\n@@ -284,18 +284,18 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n     }\n \n     fn item_struct(&self, name: ident, span: span,\n-                   struct_def: ast::struct_def) -> @ast::item {\n+                   +struct_def: ast::struct_def) -> @ast::item {\n         self.item_struct_poly(name, span, struct_def, ~[])\n     }\n \n     fn item_struct_poly(&self, name: ident, span: span,\n-                        struct_def: ast::struct_def,\n+                        +struct_def: ast::struct_def,\n                         +ty_params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_struct(@struct_def, ty_params))\n     }\n \n     fn struct_expr(&self, path: @ast::path,\n-                   fields: ~[ast::field]) -> @ast::expr {\n+                   +fields: ~[ast::field]) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),"}, {"sha": "c5bed32a24f2a13ca8d50dca9c37757561be9e32", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -88,7 +88,7 @@ pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     }\n \n     if self_live.len() > 0 {\n-        let states = str::connect(self_live.map(|s| s.name), ~\" \");\n+        let states = str::connect(self_live.map(|s| copy s.name), ~\" \");\n \n         debug!(\"protocol %s is unbounded due to loops involving: %s\",\n                proto.name, states);"}, {"sha": "c26bfd178b024a017cdb2be380a38c51398f55ab", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -65,11 +65,11 @@ pub mod liveness;\n \n \n pub fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n-                tt: ~[ast::token_tree]) -> base::MacResult {\n+                    tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, None, tt);\n+                               cx.parse_sess().interner, None, copy tt);\n     let rdr = tt_rdr as reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());\n "}, {"sha": "ce253f6156b5f3d2e85529981aa6babaec642ecd", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -18,13 +18,13 @@ use parse::token;\n use core::prelude::*;\n \n pub trait proto_parser {\n-    fn parse_proto(&self, id: ~str) -> protocol;\n+    fn parse_proto(&self, +id: ~str) -> protocol;\n     fn parse_state(&self, proto: protocol);\n     fn parse_message(&self, state: state);\n }\n \n pub impl proto_parser for parser::Parser {\n-    fn parse_proto(&self, id: ~str) -> protocol {\n+    fn parse_proto(&self, +id: ~str) -> protocol {\n         let proto = protocol(id, *self.span);\n \n         self.parse_seq_to_before_end(\n@@ -41,7 +41,7 @@ pub impl proto_parser for parser::Parser {\n \n     fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n-        let name = *self.interner.get(id);\n+        let name = copy *self.interner.get(id);\n \n         self.expect(&token::COLON);\n         let dir = match copy *self.token {\n@@ -76,7 +76,7 @@ pub impl proto_parser for parser::Parser {\n     }\n \n     fn parse_message(&self, state: state) {\n-        let mname = *self.interner.get(self.parse_ident());\n+        let mname = copy *self.interner.get(self.parse_ident());\n \n         let args = if *self.token == token::LPAREN {\n             self.parse_unspanned_seq(\n@@ -95,7 +95,7 @@ pub impl proto_parser for parser::Parser {\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {\n-            let name = *self.interner.get(self.parse_ident());\n+            let name = copy *self.interner.get(self.parse_ident());\n             let ntys = if *self.token == token::LT {\n                 self.parse_unspanned_seq(\n                     &token::LT,"}, {"sha": "be25876cfbf30be67f65da17d6127296e2d47f2e", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -118,7 +118,7 @@ pub impl gen_send for message {\n \n             let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n                                                       span)\n-                                                 .add_tys(next_state.tys));\n+                                               .add_tys(copy next_state.tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -152,7 +152,7 @@ pub impl gen_send for message {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| *x),\n+                    ~\"(\" + str::connect(arg_names.map(|x| copy *x),\n                                         ~\", \") + ~\")\"\n                 };\n \n@@ -209,7 +209,7 @@ pub impl to_type_decls for state {\n         let mut items_msg = ~[];\n \n         for self.messages.each |m| {\n-            let message(name, span, tys, this, next) = *m;\n+            let message(name, span, tys, this, next) = copy *m;\n \n             let tys = match next {\n               Some(ref next_state) => {\n@@ -225,7 +225,7 @@ pub impl to_type_decls for state {\n                                 cx.ty_path_ast_builder(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(next_state.tys)))\n+                                    .add_tys(copy next_state.tys)))\n               }\n               None => tys\n             };"}, {"sha": "52eb88d0700e828729d44f7fba2ed3287f2cdbe9", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -50,7 +50,7 @@ pub struct message(~str, span, ~[@ast::Ty], state, Option<next_state>);\n pub impl message {\n     fn name(&mut self) -> ~str {\n         match *self {\n-          message(ref id, _, _, _, _) => (*id)\n+          message(ref id, _, _, _, _) => copy *id\n         }\n     }\n \n@@ -63,7 +63,7 @@ pub impl message {\n     /// Return the type parameters actually used by this message\n     fn get_params(&mut self) -> ~[ast::ty_param] {\n         match *self {\n-          message(_, _, _, this, _) => this.ty_params\n+          message(_, _, _, this, _) => copy this.ty_params\n         }\n     }\n }\n@@ -82,8 +82,8 @@ pub struct state_ {\n }\n \n pub impl state_ {\n-    fn add_message(@self, name: ~str, span: span,\n-                   +data: ~[@ast::Ty], next: Option<next_state>) {\n+    fn add_message(@self, +name: ~str, span: span,\n+                   +data: ~[@ast::Ty], +next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }"}, {"sha": "534953b4c8adf25c0683c8eca2f47e4cd2758ef1", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -262,10 +262,10 @@ pub fn expand_quote_stmt(cx: ext_ctxt,\n }\n \n fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(@*str))\n+    strs.map(|str| cx.parse_sess().interner.intern(@copy *str))\n }\n \n-fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n+fn id_ext(cx: ext_ctxt, +str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)\n }\n \n@@ -580,8 +580,8 @@ fn expand_tts(cx: ext_ctxt,\n \n fn expand_parse_call(cx: ext_ctxt,\n                      sp: span,\n-                     parse_method: ~str,\n-                     arg_exprs: ~[@ast::expr],\n+                     +parse_method: ~str,\n+                     +arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n "}, {"sha": "86c4cbee04b6c20877241ed1a96bb7e9efdcd9bb", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -138,10 +138,10 @@ pub fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(+ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n-    for ms.each() |elt| {\n+    for ms.each |elt| {\n         match elt.node {\n           match_tok(_) => (),\n           match_seq(_,_,_,_,hi) => {\n@@ -152,12 +152,13 @@ pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n           }\n         }\n     }\n+    let matches = vec::from_fn(count_names(ms), |_i| dvec::DVec());\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n         idx: 0u,\n         up: matcher_pos_up(None),\n-        matches: copy vec::from_fn(count_names(ms), |_i| dvec::DVec()),\n+        matches: matches,\n         match_lo: 0u,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n@@ -238,7 +239,7 @@ pub fn parse(sess: @mut ParseSess,\n              ms: ~[matcher])\n           -> parse_result {\n     let mut cur_eis = ~[];\n-    cur_eis.push(initial_matcher_pos(ms, None, rdr.peek().sp.lo));\n+    cur_eis.push(initial_matcher_pos(copy ms, None, rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = ~[]; // black-box parsed by parser.rs\n@@ -329,8 +330,8 @@ pub fn parse(sess: @mut ParseSess,\n                                            |_m| DVec::<@named_match>());\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n-                        elts: (*matchers),\n-                        sep: (*sep),\n+                        elts: copy *matchers,\n+                        sep: copy *sep,\n                         idx: 0u,\n                         up: matcher_pos_up(Some(ei_t)),\n                         matches: matches,"}, {"sha": "5c20abc385d3e6ddc3dd1d7f18e2f83c88708abd", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -54,7 +54,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, None, arg);\n+                                   cx.parse_sess().interner, None, copy arg);\n     let argument_map = parse_or_else(cx.parse_sess(), cx.cfg(),\n                                      arg_reader as reader, argument_gram);\n \n@@ -130,7 +130,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                   }\n                   failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                     best_fail_spot = sp;\n-                    best_fail_msg = (*msg);\n+                    best_fail_msg = copy *msg;\n                   },\n                   error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n                 }\n@@ -145,7 +145,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, lhses, rhses);\n \n     return MRDef(MacroDef{\n-        name: *cx.parse_sess().interner.get(name),\n+        name: copy *cx.parse_sess().interner.get(name),\n         ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n     });\n }"}, {"sha": "4aa6236bf5a8af9e23faebe07db327522d1e43a4", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271464cc0aae453e96ad70a33e0c9636df7f90e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5271464cc0aae453e96ad70a33e0c9636df7f90e", "patch": "@@ -54,7 +54,7 @@ pub struct TtReader {\n pub fn new_tt_reader(sp_diag: span_handler,\n                      itr: @ident_interner,\n                      interp: Option<std::oldmap::HashMap<ident,@named_match>>,\n-                     src: ~[ast::token_tree])\n+                     +src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n@@ -101,7 +101,7 @@ pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n         interpolations: r.interpolations,\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n-        cur_tok: r.cur_tok,\n+        cur_tok: copy r.cur_tok,\n         cur_span: r.cur_span\n     }\n }\n@@ -115,7 +115,7 @@ pure fn lookup_cur_matched_by_matched(r: @mut TtReader,\n             // end of the line; duplicate henceforth\n             ad\n           }\n-          matched_seq(ads, _) => ads[*idx]\n+          matched_seq(ref ads, _) => ads[*idx]\n         }\n     }\n     vec::foldl(start, r.repeat_idx, red)\n@@ -131,15 +131,15 @@ enum lis {\n fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis, r: @mut TtReader) -> lis {\n         match lhs {\n-          lis_unconstrained => rhs,\n-          lis_contradiction(_) => lhs,\n+          lis_unconstrained => copy rhs,\n+          lis_contradiction(_) => copy lhs,\n           lis_constraint(l_len, l_id) => match rhs {\n-            lis_unconstrained => lhs,\n-            lis_contradiction(_) => rhs,\n-            lis_constraint(r_len, _) if l_len == r_len => lhs,\n+            lis_unconstrained => copy lhs,\n+            lis_contradiction(_) => copy rhs,\n+            lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n             lis_constraint(r_len, r_id) => {\n-                let l_n = *r.interner.get(l_id);\n-                let r_n = *r.interner.get(r_id);\n+                let l_n = copy *r.interner.get(l_id);\n+                let r_n = copy *r.interner.get(r_id);\n                 lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n                                         l_n, l_len, r_n, r_len))\n@@ -155,14 +155,17 @@ fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n         matched_nonterminal(_) => lis_unconstrained,\n-        matched_seq(ads, _) => lis_constraint(ads.len(), name)\n+        matched_seq(ref ads, _) => lis_constraint(ads.len(), name)\n       }\n     }\n }\n \n \n pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n-    let ret_val = TokenAndSpan { tok: r.cur_tok, sp: r.cur_span };\n+    let ret_val = TokenAndSpan {\n+        tok: copy r.cur_tok,\n+        sp: r.cur_span,\n+    };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted\n@@ -210,12 +213,13 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, copy tok) => {\n-            r.cur_span = sp; r.cur_tok = tok;\n+            r.cur_span = sp;\n+            r.cur_tok = tok;\n             r.cur.idx += 1u;\n             return ret_val;\n           }\n           tt_seq(sp, copy tts, copy sep, zerok) => {\n-            match lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n+            match lockstep_iter_size(tt_seq(sp, copy tts, sep, zerok), r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n@@ -264,7 +268,8 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n-                r.cur_span = sp; r.cur_tok = INTERPOLATED((*other_whole_nt));\n+                r.cur_span = sp;\n+                r.cur_tok = INTERPOLATED(copy *other_whole_nt);\n                 r.cur.idx += 1u;\n                 return ret_val;\n               }"}]}