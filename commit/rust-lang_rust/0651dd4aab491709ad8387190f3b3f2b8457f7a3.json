{"sha": "0651dd4aab491709ad8387190f3b3f2b8457f7a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NTFkZDRhYWI0OTE3MDlhZDgzODcxOTBmM2IzZjJiODQ1N2Y3YTM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-07-24T09:56:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T09:56:27Z"}, "message": "Rollup merge of #74572 - Mark-Simulacrum:unify-rustc-depr, r=petrochenkov\n\nInternally unify rustc_deprecated and deprecated\n\nThis PR intentionally tries to be \"featureless\" in that the behavior is not altered for either attribute, though it more clearly exposes cases where that is the case in the code.", "tree": {"sha": "3234398886255c731763f689bcebd58772c5bd7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3234398886255c731763f689bcebd58772c5bd7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0651dd4aab491709ad8387190f3b3f2b8457f7a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGrBLCRBK7hj4Ov3rIwAAdHIIAKb58pog7DrYfhxVnpEf9FH0\nYCDW/JlTAr48S7h751ay+m94baHXYTYX6Ixe0fh7aUw5X7FvfAS5ho2hEF28cwbA\nrq5aeZf14ieZ6ziW0eZbQopPD4y2A95V0UkfpfgJCTQ6XwfFMpvH5a/wvJgwcUuN\nqh2JmBsP1+V0acI5Yl4AFFekX8bGrhClCoz7mFzFEo7OnXvxxNriTJw6U+fhmD6T\nw0pzhshSbUWKnLlahuL6ybCtVhDPVbrjp9HpF5U2n0SYYIax5o2CWqsrGOWIjKYA\novixTzzAGNIUwRQ71LfYbnMnHRFumLmggmIxWvOkEG6ur0GJRgPofSgQ/+jvkhc=\n=fm9x\n-----END PGP SIGNATURE-----\n", "payload": "tree 3234398886255c731763f689bcebd58772c5bd7e\nparent 52476f53dd736d2182d6f55a67faf7a7a4ea27bb\nparent 8454ee89b2f519a5436a4699c7f65b76ee4fb259\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1595584587 +0900\ncommitter GitHub <noreply@github.com> 1595584587 +0900\n\nRollup merge of #74572 - Mark-Simulacrum:unify-rustc-depr, r=petrochenkov\n\nInternally unify rustc_deprecated and deprecated\n\nThis PR intentionally tries to be \"featureless\" in that the behavior is not altered for either attribute, though it more clearly exposes cases where that is the case in the code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0651dd4aab491709ad8387190f3b3f2b8457f7a3", "html_url": "https://github.com/rust-lang/rust/commit/0651dd4aab491709ad8387190f3b3f2b8457f7a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0651dd4aab491709ad8387190f3b3f2b8457f7a3/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52476f53dd736d2182d6f55a67faf7a7a4ea27bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/52476f53dd736d2182d6f55a67faf7a7a4ea27bb", "html_url": "https://github.com/rust-lang/rust/commit/52476f53dd736d2182d6f55a67faf7a7a4ea27bb"}, {"sha": "8454ee89b2f519a5436a4699c7f65b76ee4fb259", "url": "https://api.github.com/repos/rust-lang/rust/commits/8454ee89b2f519a5436a4699c7f65b76ee4fb259", "html_url": "https://github.com/rust-lang/rust/commit/8454ee89b2f519a5436a4699c7f65b76ee4fb259"}], "stats": {"total": 439, "additions": 195, "deletions": 244}, "files": [{"sha": "1e088b52dcc35b5fffb03d09cde40843b6801e81", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 55, "deletions": 111, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -124,13 +124,11 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n ///\n /// - `#[stable]`\n /// - `#[unstable]`\n-/// - `#[rustc_deprecated]`\n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: Symbol,\n-    pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// Represents the `#[rustc_const_unstable]` and `#[rustc_const_stable]` attributes.\n@@ -163,15 +161,6 @@ impl StabilityLevel {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n-#[derive(HashStable_Generic)]\n-pub struct RustcDeprecation {\n-    pub since: Symbol,\n-    pub reason: Symbol,\n-    /// A text snippet used to completely replace any use of the deprecated item in an expression.\n-    pub suggestion: Option<Symbol>,\n-}\n-\n /// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n@@ -205,15 +194,13 @@ where\n     use StabilityLevel::*;\n \n     let mut stab: Option<Stability> = None;\n-    let mut rustc_depr: Option<RustcDeprecation> = None;\n     let mut const_stab: Option<ConstStability> = None;\n     let mut promotable = false;\n     let mut allow_const_fn_ptr = false;\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n         if ![\n-            sym::rustc_deprecated,\n             sym::rustc_const_unstable,\n             sym::rustc_const_stable,\n             sym::unstable,\n@@ -258,76 +245,8 @@ where\n                 }\n             };\n \n-            macro_rules! get_meta {\n-                ($($name:ident),+) => {\n-                    $(\n-                        let mut $name = None;\n-                    )+\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty() {\n-                                $(\n-                                    sym::$name => if !get(mi, &mut $name) { continue 'outer },\n-                                )+\n-                                _ => {\n-                                    let expected = &[ $( stringify!($name) ),+ ];\n-                                    handle_errors(\n-                                        sess,\n-                                        mi.span,\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            expected,\n-                                        ),\n-                                    );\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(\n-                                sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(\n-                                    \"unsupported literal\",\n-                                    false,\n-                                ),\n-                            );\n-                            continue 'outer\n-                        }\n-                    }\n-                }\n-            }\n-\n             let meta_name = meta.name_or_empty();\n             match meta_name {\n-                sym::rustc_deprecated => {\n-                    if rustc_depr.is_some() {\n-                        struct_span_err!(\n-                            diagnostic,\n-                            item_sp,\n-                            E0540,\n-                            \"multiple rustc_deprecated attributes\"\n-                        )\n-                        .emit();\n-                        continue 'outer;\n-                    }\n-\n-                    get_meta!(since, reason, suggestion);\n-\n-                    match (since, reason) {\n-                        (Some(since), Some(reason)) => {\n-                            rustc_depr = Some(RustcDeprecation { since, reason, suggestion })\n-                        }\n-                        (None, _) => {\n-                            handle_errors(sess, attr.span, AttrError::MissingSince);\n-                            continue;\n-                        }\n-                        _ => {\n-                            struct_span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\")\n-                                .emit();\n-                            continue;\n-                        }\n-                    }\n-                }\n                 sym::rustc_const_unstable | sym::unstable => {\n                     if meta_name == sym::unstable && stab.is_some() {\n                         handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n@@ -429,7 +348,7 @@ where\n                         (Some(feature), reason, Some(_)) => {\n                             let level = Unstable { reason, issue: issue_num, is_soft };\n                             if sym::unstable == meta_name {\n-                                stab = Some(Stability { level, feature, rustc_depr: None });\n+                                stab = Some(Stability { level, feature });\n                             } else {\n                                 const_stab = Some(ConstStability {\n                                     level,\n@@ -501,7 +420,7 @@ where\n                         (Some(feature), Some(since)) => {\n                             let level = Stable { since };\n                             if sym::stable == meta_name {\n-                                stab = Some(Stability { level, feature, rustc_depr: None });\n+                                stab = Some(Stability { level, feature });\n                             } else {\n                                 const_stab = Some(ConstStability {\n                                     level,\n@@ -526,22 +445,6 @@ where\n         }\n     }\n \n-    // Merge the deprecation info into the stability info\n-    if let Some(rustc_depr) = rustc_depr {\n-        if let Some(ref mut stab) = stab {\n-            stab.rustc_depr = Some(rustc_depr);\n-        } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0549,\n-                \"rustc_deprecated attribute must be paired with \\\n-                       either stable or unstable attribute\"\n-            )\n-            .emit();\n-        }\n-    }\n-\n     // Merge the const-unstable info into the stability info\n     if promotable || allow_const_fn_ptr {\n         if let Some(ref mut stab) = const_stab {\n@@ -714,7 +617,16 @@ pub fn eval_condition(\n #[derive(RustcEncodable, RustcDecodable, Clone, HashStable_Generic)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n+    /// The note to issue a reason.\n     pub note: Option<Symbol>,\n+    /// A text snippet used to completely replace any use of the deprecated item in an expression.\n+    ///\n+    /// This is currently unstable.\n+    pub suggestion: Option<Symbol>,\n+\n+    /// Whether to treat the since attribute as being a Rust version identifier\n+    /// (rather than an opaque string).\n+    pub is_since_rustc_version: bool,\n }\n \n /// Finds the deprecation attribute. `None` if none exists.\n@@ -738,7 +650,7 @@ where\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !attr.check_name(sym::deprecated) {\n+        if !(attr.check_name(sym::deprecated) || attr.check_name(sym::rustc_deprecated)) {\n             continue;\n         }\n \n@@ -751,11 +663,12 @@ where\n             Some(meta) => meta,\n             None => continue,\n         };\n-        depr = match &meta.kind {\n-            MetaItemKind::Word => Some(Deprecation { since: None, note: None }),\n-            MetaItemKind::NameValue(..) => {\n-                meta.value_str().map(|note| Deprecation { since: None, note: Some(note) })\n-            }\n+        let mut since = None;\n+        let mut note = None;\n+        let mut suggestion = None;\n+        match &meta.kind {\n+            MetaItemKind::Word => {}\n+            MetaItemKind::NameValue(..) => note = meta.value_str(),\n             MetaItemKind::List(list) => {\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n@@ -789,8 +702,6 @@ where\n                     }\n                 };\n \n-                let mut since = None;\n-                let mut note = None;\n                 for meta in list {\n                     match meta {\n                         NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n@@ -799,18 +710,32 @@ where\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::note => {\n+                            sym::note if attr.check_name(sym::deprecated) => {\n+                                if !get(mi, &mut note) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::reason if attr.check_name(sym::rustc_deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n+                            sym::suggestion if attr.check_name(sym::rustc_deprecated) => {\n+                                if !get(mi, &mut suggestion) {\n+                                    continue 'outer;\n+                                }\n+                            }\n                             _ => {\n                                 handle_errors(\n                                     sess,\n                                     meta.span(),\n                                     AttrError::UnknownMetaItem(\n                                         pprust::path_to_string(&mi.path),\n-                                        &[\"since\", \"note\"],\n+                                        if attr.check_name(sym::deprecated) {\n+                                            &[\"since\", \"note\"]\n+                                        } else {\n+                                            &[\"since\", \"reason\", \"suggestion\"]\n+                                        },\n                                     ),\n                                 );\n                                 continue 'outer;\n@@ -829,10 +754,29 @@ where\n                         }\n                     }\n                 }\n+            }\n+        }\n+\n+        if suggestion.is_some() && attr.check_name(sym::deprecated) {\n+            unreachable!(\"only allowed on rustc_deprecated\")\n+        }\n \n-                Some(Deprecation { since, note })\n+        if attr.check_name(sym::rustc_deprecated) {\n+            if since.is_none() {\n+                handle_errors(sess, attr.span, AttrError::MissingSince);\n+                continue;\n             }\n-        };\n+\n+            if note.is_none() {\n+                struct_span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\").emit();\n+                continue;\n+            }\n+        }\n+\n+        mark_used(&attr);\n+\n+        let is_since_rustc_version = attr.check_name(sym::rustc_deprecated);\n+        depr = Some(Deprecation { since, note, suggestion, is_since_rustc_version });\n     }\n \n     depr"}, {"sha": "4e5e77f80c28a1208c4f0121777816cd98cbf24f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -589,7 +589,7 @@ E0771: include_str!(\"./error_codes/E0771.md\"),\n     E0521, // borrowed data escapes outside of closure\n     E0523,\n //  E0526, // shuffle indices are not constant\n-    E0540, // multiple rustc_deprecated attributes\n+//  E0540, // multiple rustc_deprecated attributes\n     E0542, // missing 'since'\n     E0543, // missing 'reason'\n     E0544, // multiple stability levels"}, {"sha": "5f7ff54fd31c3ee5a3e329752aa59e6e19e96ad4", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -5,7 +5,7 @@ pub use self::StabilityLevel::*;\n \n use crate::ty::{self, TyCtxt};\n use rustc_ast::ast::CRATE_NODE_ID;\n-use rustc_attr::{self as attr, ConstStability, Deprecation, RustcDeprecation, Stability};\n+use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::GateIssue;\n@@ -130,14 +130,26 @@ pub fn report_unstable(\n \n /// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n-pub fn deprecation_in_effect(since: &str) -> bool {\n+pub fn deprecation_in_effect(is_since_rustc_version: bool, since: Option<&str>) -> bool {\n+    let since = if let Some(since) = since {\n+        if is_since_rustc_version {\n+            since\n+        } else {\n+            // We assume that the deprecation is in effect if it's not a\n+            // rustc version.\n+            return true;\n+        }\n+    } else {\n+        // If since attribute is not set, then we're definitely in effect.\n+        return true;\n+    };\n     fn parse_version(ver: &str) -> Vec<u32> {\n         // We ignore non-integer components of the version (e.g., \"nightly\").\n         ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n     }\n \n     if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n-        let since: Vec<u32> = parse_version(since);\n+        let since: Vec<u32> = parse_version(&since);\n         let rustc: Vec<u32> = parse_version(rustc);\n         // We simply treat invalid `since` attributes as relating to a previous\n         // Rust version, thus always displaying the warning.\n@@ -167,31 +179,27 @@ pub fn deprecation_suggestion(\n     }\n }\n \n-fn deprecation_message_common(message: String, reason: Option<Symbol>) -> String {\n-    match reason {\n-        Some(reason) => format!(\"{}: {}\", message, reason),\n-        None => message,\n-    }\n-}\n-\n pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n-    let message = format!(\"use of deprecated item '{}'\", path);\n-    (deprecation_message_common(message, depr.note), DEPRECATED)\n-}\n-\n-pub fn rustc_deprecation_message(depr: &RustcDeprecation, path: &str) -> (String, &'static Lint) {\n-    let (message, lint) = if deprecation_in_effect(&depr.since.as_str()) {\n+    let (message, lint) = if deprecation_in_effect(\n+        depr.is_since_rustc_version,\n+        depr.since.map(Symbol::as_str).as_deref(),\n+    ) {\n         (format!(\"use of deprecated item '{}'\", path), DEPRECATED)\n     } else {\n         (\n             format!(\n                 \"use of item '{}' that will be deprecated in future version {}\",\n-                path, depr.since\n+                path,\n+                depr.since.unwrap()\n             ),\n             DEPRECATED_IN_FUTURE,\n         )\n     };\n-    (deprecation_message_common(message, Some(depr.reason)), lint)\n+    let message = match depr.note {\n+        Some(reason) => format!(\"{}: {}\", message, reason),\n+        None => message,\n+    };\n+    (message, lint)\n }\n \n pub fn early_report_deprecation(\n@@ -289,10 +297,23 @@ impl<'tcx> TyCtxt<'tcx> {\n                     .lookup_deprecation_entry(parent_def_id.to_def_id())\n                     .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n-                if !skip {\n+                // #[deprecated] doesn't emit a notice if we're not on the\n+                // topmost deprecation. For example, if a struct is deprecated,\n+                // the use of a field won't be linted.\n+                //\n+                // #[rustc_deprecated] however wants to emit down the whole\n+                // hierarchy.\n+                if !skip || depr_entry.attr.is_since_rustc_version {\n                     let (message, lint) =\n                         deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, None, lint, span, id);\n+                    late_report_deprecation(\n+                        self,\n+                        &message,\n+                        depr_entry.attr.suggestion,\n+                        lint,\n+                        span,\n+                        id,\n+                    );\n                 }\n             };\n         }\n@@ -310,16 +331,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             def_id, span, stability\n         );\n \n-        if let Some(id) = id {\n-            if let Some(stability) = stability {\n-                if let Some(depr) = &stability.rustc_depr {\n-                    let (message, lint) =\n-                        rustc_deprecation_message(depr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, depr.suggestion, lint, span, id);\n-                }\n-            }\n-        }\n-\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !def_id.is_local();\n         if !cross_crate {"}, {"sha": "830af8d31e7a6a3b48baa76f6f72ffb05624c9a6", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -59,20 +59,50 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n+        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n+        let mut did_error = false;\n         if !self.tcx.features().staged_api {\n-            self.forbid_staged_api_attrs(hir_id, attrs, item_sp, kind, visit_children);\n-            return;\n+            did_error = self.forbid_staged_api_attrs(hir_id, attrs);\n         }\n \n-        // This crate explicitly wants staged API.\n+        let depr = if did_error {\n+            None\n+        } else {\n+            attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp)\n+        };\n+        let mut is_deprecated = false;\n+        if let Some(depr) = &depr {\n+            is_deprecated = true;\n \n-        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n-        if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-            self.tcx.sess.span_err(\n-                item_sp,\n-                \"`#[deprecated]` cannot be used in staged API; \\\n-                                             use `#[rustc_deprecated]` instead\",\n+            if kind == AnnotationKind::Prohibited {\n+                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+            }\n+\n+            // `Deprecation` is just two pointers, no need to intern it\n+            let depr_entry = DeprecationEntry::local(depr.clone(), hir_id);\n+            self.index.depr_map.insert(hir_id, depr_entry);\n+        } else if let Some(parent_depr) = self.parent_depr.clone() {\n+            is_deprecated = true;\n+            info!(\"tagging child {:?} as deprecated from parent\", hir_id);\n+            self.index.depr_map.insert(hir_id, parent_depr);\n+        }\n+\n+        if self.tcx.features().staged_api {\n+            if let Some(..) = attrs.iter().find(|a| a.check_name(sym::deprecated)) {\n+                self.tcx.sess.span_err(\n+                    item_sp,\n+                    \"`#[deprecated]` cannot be used in staged API; \\\n+                                                use `#[rustc_deprecated]` instead\",\n+                );\n+            }\n+        } else {\n+            self.recurse_with_stability_attrs(\n+                depr.map(|d| DeprecationEntry::local(d, hir_id)),\n+                None,\n+                None,\n+                visit_children,\n             );\n+            return;\n         }\n \n         let (stab, const_stab) = attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n@@ -92,33 +122,34 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        let stab = stab.map(|mut stab| {\n+        if depr.as_ref().map_or(false, |d| d.is_since_rustc_version) {\n+            if stab.is_none() {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    item_sp,\n+                    E0549,\n+                    \"rustc_deprecated attribute must be paired with \\\n+                    either stable or unstable attribute\"\n+                )\n+                .emit();\n+            }\n+        }\n+\n+        let stab = stab.map(|stab| {\n             // Error if prohibited, or can't inherit anything from a container.\n             if kind == AnnotationKind::Prohibited\n-                || (kind == AnnotationKind::Container\n-                    && stab.level.is_stable()\n-                    && stab.rustc_depr.is_none())\n+                || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n                 self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n-            // If parent is deprecated and we're not, inherit this by merging\n-            // deprecated_since and its reason.\n-            if let Some(parent_stab) = self.parent_stab {\n-                if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                    stab.rustc_depr = parent_stab.rustc_depr\n-                }\n-            }\n-\n             let stab = self.tcx.intern_stability(stab);\n \n             // Check if deprecated_since < stable_since. If it is,\n             // this is *almost surely* an accident.\n-            if let (\n-                &Some(attr::RustcDeprecation { since: dep_since, .. }),\n-                &attr::Stable { since: stab_since },\n-            ) = (&stab.rustc_depr, &stab.level)\n+            if let (&Some(dep_since), &attr::Stable { since: stab_since }) =\n+                (&depr.as_ref().and_then(|d| d.since), &stab.level)\n             {\n                 // Explicit version of iter::order::lt to handle parse errors properly\n                 for (dep_v, stab_v) in\n@@ -163,19 +194,29 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        self.recurse_with_stability_attrs(stab, const_stab, visit_children);\n+        self.recurse_with_stability_attrs(\n+            depr.map(|d| DeprecationEntry::local(d, hir_id)),\n+            stab,\n+            const_stab,\n+            visit_children,\n+        );\n     }\n \n     fn recurse_with_stability_attrs(\n         &mut self,\n+        depr: Option<DeprecationEntry>,\n         stab: Option<&'tcx Stability>,\n         const_stab: Option<&'tcx ConstStability>,\n         f: impl FnOnce(&mut Self),\n     ) {\n         // These will be `Some` if this item changes the corresponding stability attribute.\n+        let mut replaced_parent_depr = None;\n         let mut replaced_parent_stab = None;\n         let mut replaced_parent_const_stab = None;\n \n+        if let Some(depr) = depr {\n+            replaced_parent_depr = Some(replace(&mut self.parent_depr, Some(depr)));\n+        }\n         if let Some(stab) = stab {\n             replaced_parent_stab = Some(replace(&mut self.parent_stab, Some(stab)));\n         }\n@@ -186,6 +227,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         f(self);\n \n+        if let Some(orig_parent_depr) = replaced_parent_depr {\n+            self.parent_depr = orig_parent_depr;\n+        }\n         if let Some(orig_parent_stab) = replaced_parent_stab {\n             self.parent_stab = orig_parent_stab;\n         }\n@@ -194,14 +238,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n     }\n \n-    fn forbid_staged_api_attrs(\n-        &mut self,\n-        hir_id: HirId,\n-        attrs: &[Attribute],\n-        item_sp: Span,\n-        kind: AnnotationKind,\n-        visit_children: impl FnOnce(&mut Self),\n-    ) {\n+    // returns true if an error occurred, used to suppress some spurious errors\n+    fn forbid_staged_api_attrs(&mut self, hir_id: HirId, attrs: &[Attribute]) -> bool {\n         // Emit errors for non-staged-api crates.\n         let unstable_attrs = [\n             sym::unstable,\n@@ -210,6 +248,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             sym::rustc_const_unstable,\n             sym::rustc_const_stable,\n         ];\n+        let mut has_error = false;\n         for attr in attrs {\n             let name = attr.name_or_empty();\n             if unstable_attrs.contains(&name) {\n@@ -221,6 +260,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                     \"stability attributes may not be used outside of the standard library\",\n                 )\n                 .emit();\n+                has_error = true;\n             }\n         }\n \n@@ -232,24 +272,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-            if kind == AnnotationKind::Prohibited {\n-                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n-            }\n-\n-            // `Deprecation` is just two pointers, no need to intern it\n-            let depr_entry = DeprecationEntry::local(depr, hir_id);\n-            self.index.depr_map.insert(hir_id, depr_entry.clone());\n-\n-            let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n-            visit_children(self);\n-            self.parent_depr = orig_parent_depr;\n-        } else if let Some(parent_depr) = self.parent_depr.clone() {\n-            self.index.depr_map.insert(hir_id, parent_depr);\n-            visit_children(self);\n-        } else {\n-            visit_children(self);\n-        }\n+        has_error\n     }\n }\n \n@@ -454,7 +477,6 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n                     is_soft: false,\n                 },\n                 feature: sym::rustc_private,\n-                rustc_depr: None,\n             });\n             annotator.parent_stab = Some(stability);\n         }"}, {"sha": "fee7cb4836e3d6a61e11901540979b02f4e33b23", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -1017,22 +1017,17 @@ impl<'a> Resolver<'a> {\n                     );\n                 }\n             }\n-            if let Some(depr) = &stability.rustc_depr {\n-                let path = pprust::path_to_string(path);\n-                let (message, lint) = stability::rustc_deprecation_message(depr, &path);\n-                stability::early_report_deprecation(\n-                    &mut self.lint_buffer,\n-                    &message,\n-                    depr.suggestion,\n-                    lint,\n-                    span,\n-                );\n-            }\n         }\n         if let Some(depr) = &ext.deprecation {\n             let path = pprust::path_to_string(&path);\n             let (message, lint) = stability::deprecation_message(depr, &path);\n-            stability::early_report_deprecation(&mut self.lint_buffer, &message, None, lint, span);\n+            stability::early_report_deprecation(\n+                &mut self.lint_buffer,\n+                &message,\n+                depr.suggestion,\n+                lint,\n+                span,\n+            );\n         }\n     }\n "}, {"sha": "94d95115dcdbcaed7bfd447b6cc22331da063d87", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -2353,10 +2353,6 @@ impl Clean<Stability> for attr::Stability {\n                 attr::Stable { ref since } => since.to_string(),\n                 _ => String::new(),\n             },\n-            deprecation: self.rustc_depr.as_ref().map(|d| Deprecation {\n-                note: Some(d.reason.to_string()).filter(|r| !r.is_empty()),\n-                since: Some(d.since.to_string()).filter(|d| !d.is_empty()),\n-            }),\n             unstable_reason: match self.level {\n                 attr::Unstable { reason: Some(ref reason), .. } => Some(reason.to_string()),\n                 _ => None,\n@@ -2374,6 +2370,7 @@ impl Clean<Deprecation> for attr::Deprecation {\n         Deprecation {\n             since: self.since.map(|s| s.to_string()).filter(|s| !s.is_empty()),\n             note: self.note.map(|n| n.to_string()).filter(|n| !n.is_empty()),\n+            is_since_rustc_version: self.is_since_rustc_version,\n         }\n     }\n }"}, {"sha": "071834c59d65ec749aafa5f8b4a72113638b74d7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -195,7 +195,8 @@ impl Item {\n                 classes.push(\"unstable\");\n             }\n \n-            if s.deprecation.is_some() {\n+            // FIXME: what about non-staged API items that are deprecated?\n+            if self.deprecation.is_some() {\n                 classes.push(\"deprecated\");\n             }\n \n@@ -216,14 +217,6 @@ impl Item {\n         ItemType::from(self)\n     }\n \n-    /// Returns the info in the item's `#[deprecated]` or `#[rustc_deprecated]` attributes.\n-    ///\n-    /// If the item is not deprecated, returns `None`.\n-    pub fn deprecation(&self) -> Option<&Deprecation> {\n-        self.deprecation\n-            .as_ref()\n-            .or_else(|| self.stability.as_ref().and_then(|s| s.deprecation.as_ref()))\n-    }\n     pub fn is_default(&self) -> bool {\n         match self.inner {\n             ItemEnum::MethodItem(ref meth) => {\n@@ -1528,7 +1521,6 @@ pub struct Stability {\n     pub level: stability::StabilityLevel,\n     pub feature: Option<String>,\n     pub since: String,\n-    pub deprecation: Option<Deprecation>,\n     pub unstable_reason: Option<String>,\n     pub issue: Option<NonZeroU32>,\n }\n@@ -1537,6 +1529,7 @@ pub struct Stability {\n pub struct Deprecation {\n     pub since: Option<String>,\n     pub note: Option<String>,\n+    pub is_since_rustc_version: bool,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or"}, {"sha": "f7050cf377722622eee91859903f82a04b0cf5d0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -2216,16 +2216,10 @@ fn stability_tags(item: &clean::Item) -> String {\n     }\n \n     // The trailing space after each tag is to space it properly against the rest of the docs.\n-    if item.deprecation().is_some() {\n+    if let Some(depr) = &item.deprecation {\n         let mut message = \"Deprecated\";\n-        if let Some(ref stab) = item.stability {\n-            if let Some(ref depr) = stab.deprecation {\n-                if let Some(ref since) = depr.since {\n-                    if !stability::deprecation_in_effect(&since) {\n-                        message = \"Deprecation planned\";\n-                    }\n-                }\n-            }\n+        if !stability::deprecation_in_effect(depr.is_since_rustc_version, depr.since.as_deref()) {\n+            message = \"Deprecation planned\";\n         }\n         tags += &tag_html(\"deprecated\", message);\n     }\n@@ -2254,23 +2248,18 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     let mut stability = vec![];\n     let error_codes = cx.shared.codes;\n \n-    if let Some(Deprecation { note, since }) = &item.deprecation() {\n+    if let Some(Deprecation { ref note, ref since, is_since_rustc_version }) = item.deprecation {\n         // We display deprecation messages for #[deprecated] and #[rustc_deprecated]\n         // but only display the future-deprecation messages for #[rustc_deprecated].\n         let mut message = if let Some(since) = since {\n-            format!(\"Deprecated since {}\", Escape(since))\n+            if !stability::deprecation_in_effect(is_since_rustc_version, Some(since)) {\n+                format!(\"Deprecating in {}\", Escape(&since))\n+            } else {\n+                format!(\"Deprecated since {}\", Escape(&since))\n+            }\n         } else {\n             String::from(\"Deprecated\")\n         };\n-        if let Some(ref stab) = item.stability {\n-            if let Some(ref depr) = stab.deprecation {\n-                if let Some(ref since) = depr.since {\n-                    if !stability::deprecation_in_effect(&since) {\n-                        message = format!(\"Deprecating in {}\", Escape(&since));\n-                    }\n-                }\n-            }\n-        }\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();"}, {"sha": "80d7ae6dc637d78723cdc17ab762f4d7945bc324", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.rs?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -62,7 +62,7 @@ fn multiple3() { }\n #[rustc_deprecated(since = \"b\", reason = \"text\")]\n #[rustc_const_unstable(feature = \"c\", issue = \"none\")]\n #[rustc_const_unstable(feature = \"d\", issue = \"none\")] //~ ERROR multiple stability levels\n-pub const fn multiple4() { } //~ ERROR multiple rustc_deprecated attributes [E0540]\n+pub const fn multiple4() { } //~ ERROR multiple deprecated attributes\n //~^ ERROR Invalid stability or deprecation version found\n \n #[rustc_deprecated(since = \"a\", reason = \"text\")]"}, {"sha": "134c657c62015b51be3739ec0fa7ba2d048d14a1", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0651dd4aab491709ad8387190f3b3f2b8457f7a3/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr?ref=0651dd4aab491709ad8387190f3b3f2b8457f7a3", "patch": "@@ -82,7 +82,7 @@ error[E0544]: multiple stability levels\n LL | #[stable(feature = \"a\", since = \"b\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0540]: multiple rustc_deprecated attributes\n+error[E0550]: multiple deprecated attributes\n   --> $DIR/stability-attribute-sanity.rs:65:1\n    |\n LL | pub const fn multiple4() { }\n@@ -108,5 +108,5 @@ LL | fn deprecated_without_unstable_or_stable() { }\n \n error: aborting due to 18 previous errors\n \n-Some errors have detailed explanations: E0539, E0541.\n+Some errors have detailed explanations: E0539, E0541, E0550.\n For more information about an error, try `rustc --explain E0539`."}]}