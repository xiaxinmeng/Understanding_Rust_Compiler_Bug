{"sha": "7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "node_id": "C_kwDOAAsO6NoAKDdhOWJlZjRkODNhMDkxYmUyNWZkZjBmMWJlYWFkZTY2ZWVjMGNkOTI", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-06-27T16:42:47Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-06-30T07:59:21Z"}, "message": "lint: port overflowing literals diagnostics\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "15fa22e0acc8b8a9f74438bbdec8a305fcd82ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15fa22e0acc8b8a9f74438bbdec8a305fcd82ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "html_url": "https://github.com/rust-lang/rust/commit/7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ef610c003f8072ec4ca4ecf195922a9a44e48dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef610c003f8072ec4ca4ecf195922a9a44e48dd", "html_url": "https://github.com/rust-lang/rust/commit/7ef610c003f8072ec4ca4ecf195922a9a44e48dd"}], "stats": {"total": 120, "additions": 79, "deletions": 41}, "files": [{"sha": "ae53fb4821b535662e9f2a96741149a336f1ba55", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "patch": "@@ -147,3 +147,28 @@ lint-drop-trait-constraints =\n \n lint-drop-glue =\n     types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n+\n+lint-range-endpoint-out-of-range = range endpoint is out of range for `{$ty}`\n+    .suggestion = use an inclusive range instead\n+\n+lint-overflowing-bin-hex = literal out of range for `{$ty}`\n+    .negative-note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n+    .negative-becomes-note = and the value `-{$lit}` will become `{$actually}{$ty}`\n+    .positive-note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n+    .suggestion = consider using the type `{$suggestion_ty}` instead\n+    .help = consider using the type `{$suggestion_ty}` instead\n+\n+lint-overflowing-int = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+    .help = consider using the type `{$suggestion_ty}` instead\n+\n+lint-only-cast-u8-to-char = only `u8` can be cast into `char`\n+    .suggestion = use a `char` literal instead\n+\n+lint-overflowing-uint = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+\n+lint-overflowing-literal = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n+\n+lint-unused-comparisons = comparison is useless due to type limits"}, {"sha": "576248ae7c23017616f747774435bc915f01ec31", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "patch": "@@ -49,6 +49,18 @@ impl IntoDiagnosticArg for bool {\n     }\n }\n \n+impl IntoDiagnosticArg for i128 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u128 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for String {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Owned(self))"}, {"sha": "c92459c770b3ea0b61d35db6dbd64cf608808758", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9bef4d83a091be25fdf0f1beaade66eec0cd92/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "patch": "@@ -2,7 +2,7 @@ use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n@@ -139,7 +139,8 @@ fn lint_overflowing_range_endpoint<'tcx>(\n         // overflowing and only by 1.\n         if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n             cx.struct_span_lint(OVERFLOWING_LITERALS, parent_expr.span, |lint| {\n-                let mut err = lint.build(&format!(\"range endpoint is out of range for `{}`\", ty));\n+                let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n+                err.set_arg(\"ty\", ty);\n                 if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n                     use ast::{LitIntType, LitKind};\n                     // We need to preserve the literal's suffix,\n@@ -153,7 +154,7 @@ fn lint_overflowing_range_endpoint<'tcx>(\n                     let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n                     err.span_suggestion(\n                         parent_expr.span,\n-                        \"use an inclusive range instead\",\n+                        fluent::lint::suggestion,\n                         suggestion,\n                         Applicability::MachineApplicable,\n                     );\n@@ -229,38 +230,35 @@ fn report_bin_hex_error(\n                 (t.name_str(), actually.to_string())\n             }\n         };\n-        let mut err = lint.build(&format!(\"literal out of range for `{}`\", t));\n+        let mut err = lint.build(fluent::lint::overflowing_bin_hex);\n         if negative {\n             // If the value is negative,\n             // emits a note about the value itself, apart from the literal.\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 the type `{}`\",\n-                repr_str, val, t\n-            ));\n-            err.note(&format!(\"and the value `-{}` will become `{}{}`\", repr_str, actually, t));\n+            err.note(fluent::lint::negative_note);\n+            err.note(fluent::lint::negative_becomes_note);\n         } else {\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 the type `{}` and will become `{}{}`\",\n-                repr_str, val, t, actually, t\n-            ));\n+            err.note(fluent::lint::positive_note);\n         }\n         if let Some(sugg_ty) =\n             get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n         {\n+            err.set_arg(\"suggestion_ty\", sugg_ty);\n             if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                 let (sans_suffix, _) = repr_str.split_at(pos);\n                 err.span_suggestion(\n                     expr.span,\n-                    &format!(\"consider using the type `{}` instead\", sugg_ty),\n+                    fluent::lint::suggestion,\n                     format!(\"{}{}\", sans_suffix, sugg_ty),\n                     Applicability::MachineApplicable,\n                 );\n             } else {\n-                err.help(&format!(\"consider using the type `{}` instead\", sugg_ty));\n+                err.help(fluent::lint::help);\n             }\n         }\n+        err.set_arg(\"ty\", t);\n+        err.set_arg(\"lit\", repr_str);\n+        err.set_arg(\"dec\", val);\n+        err.set_arg(\"actually\", actually);\n         err.emit();\n     });\n }\n@@ -353,21 +351,23 @@ fn lint_int_literal<'tcx>(\n         }\n \n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-            let mut err = lint.build(&format!(\"literal out of range for `{}`\", t.name_str()));\n-            err.note(&format!(\n-                \"the literal `{}` does not fit into the type `{}` whose range is `{}..={}`\",\n+            let mut err = lint.build(fluent::lint::overflowing_int);\n+            err.set_arg(\"ty\", t.name_str());\n+            err.set_arg(\n+                \"lit\",\n                 cx.sess()\n                     .source_map()\n                     .span_to_snippet(lit.span)\n                     .expect(\"must get snippet from literal\"),\n-                t.name_str(),\n-                min,\n-                max,\n-            ));\n+            );\n+            err.set_arg(\"min\", min);\n+            err.set_arg(\"max\", max);\n+            err.note(fluent::lint::note);\n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n-                err.help(&format!(\"consider using the type `{}` instead\", sugg_ty));\n+                err.set_arg(\"suggestion_ty\", sugg_ty);\n+                err.help(fluent::lint::help);\n             }\n             err.emit();\n         });\n@@ -395,10 +395,10 @@ fn lint_uint_literal<'tcx>(\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n                         cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n-                            lint.build(\"only `u8` can be cast into `char`\")\n+                            lint.build(fluent::lint::only_cast_u8_to_char)\n                                 .span_suggestion(\n                                     par_e.span,\n-                                    \"use a `char` literal instead\",\n+                                    fluent::lint::suggestion,\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )\n@@ -429,17 +429,18 @@ fn lint_uint_literal<'tcx>(\n             return;\n         }\n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-            lint.build(&format!(\"literal out of range for `{}`\", t.name_str()))\n-                .note(&format!(\n-                    \"the literal `{}` does not fit into the type `{}` whose range is `{}..={}`\",\n+            lint.build(fluent::lint::overflowing_uint)\n+                .set_arg(\"ty\", t.name_str())\n+                .set_arg(\n+                    \"lit\",\n                     cx.sess()\n                         .source_map()\n                         .span_to_snippet(lit.span)\n                         .expect(\"must get snippet from literal\"),\n-                    t.name_str(),\n-                    min,\n-                    max,\n-                ))\n+                )\n+                .set_arg(\"min\", min)\n+                .set_arg(\"max\", max)\n+                .note(fluent::lint::note)\n                 .emit();\n         });\n     }\n@@ -471,16 +472,16 @@ fn lint_literal<'tcx>(\n             };\n             if is_infinite == Ok(true) {\n                 cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-                    lint.build(&format!(\"literal out of range for `{}`\", t.name_str()))\n-                        .note(&format!(\n-                            \"the literal `{}` does not fit into the type `{}` and will be converted to `{}::INFINITY`\",\n+                    lint.build(fluent::lint::overflowing_literal)\n+                        .set_arg(\"ty\", t.name_str())\n+                        .set_arg(\n+                            \"lit\",\n                             cx.sess()\n                                 .source_map()\n                                 .span_to_snippet(lit.span)\n                                 .expect(\"must get snippet from literal\"),\n-                            t.name_str(),\n-                            t.name_str(),\n-                        ))\n+                        )\n+                        .note(fluent::lint::note)\n                         .emit();\n                 });\n             }\n@@ -501,7 +502,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n                     cx.struct_span_lint(UNUSED_COMPARISONS, e.span, |lint| {\n-                        lint.build(\"comparison is useless due to type limits\").emit();\n+                        lint.build(fluent::lint::unused_comparisons).emit();\n                     });\n                 }\n             }"}]}