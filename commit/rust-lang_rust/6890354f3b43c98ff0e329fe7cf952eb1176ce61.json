{"sha": "6890354f3b43c98ff0e329fe7cf952eb1176ce61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OTAzNTRmM2I0M2M5OGZmMGUzMjlmZTdjZjk1MmViMTE3NmNlNjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-08T18:36:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:04Z"}, "message": "rustc_metadata: use the shorthand encoding for predicates also.", "tree": {"sha": "b81eb54aff621f8aa6644d83b65ebe56c372448f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b81eb54aff621f8aa6644d83b65ebe56c372448f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6890354f3b43c98ff0e329fe7cf952eb1176ce61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6890354f3b43c98ff0e329fe7cf952eb1176ce61", "html_url": "https://github.com/rust-lang/rust/commit/6890354f3b43c98ff0e329fe7cf952eb1176ce61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6890354f3b43c98ff0e329fe7cf952eb1176ce61/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "html_url": "https://github.com/rust-lang/rust/commit/cc47dc5c6e2502f554c465bef5a8f883139c0c4e"}], "stats": {"total": 187, "additions": 65, "deletions": 122}, "files": [{"sha": "f30551cadd97adfca0afc5bcafd092e7613a204d", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=6890354f3b43c98ff0e329fe7cf952eb1176ce61", "patch": "@@ -72,8 +72,6 @@ pub mod root_tag {\n     pub const crate_info: usize = 0x104;\n \n     pub const index: usize = 0x110;\n-    pub const xref_index: usize = 0x111;\n-    pub const xref_data: usize = 0x112;\n     pub const crate_deps: usize = 0x102;\n     pub const dylib_dependency_formats: usize = 0x106;\n     pub const native_libraries: usize = 0x10a;\n@@ -202,7 +200,7 @@ pub mod item_tag {\n     pub const fn_arg_names: usize = 0x85;\n }\n \n-/// The shorthand encoding of `Ty` uses `TypeVariants`' variant `usize`\n+/// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n /// This offset is also chosen so that the first byte is never < 0x80.\n-pub const TYPE_SHORTHAND_OFFSET: usize = 0x80;\n+pub const SHORTHAND_OFFSET: usize = 0x80;"}, {"sha": "73dcf9470183b7311d18a5cbfed67185c689ed02", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=6890354f3b43c98ff0e329fe7cf952eb1176ce61", "patch": "@@ -329,7 +329,6 @@ impl<'a> CrateReader<'a> {\n             extern_crate: Cell::new(None),\n             info: crate_info,\n             index: decoder::load_index(metadata.as_slice()),\n-            xref_index: decoder::load_xrefs(metadata.as_slice()),\n             key_map: decoder::load_key_map(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),"}, {"sha": "44fdf29aa73c461efaa1e7c2871f431b0c5c2026", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=6890354f3b43c98ff0e329fe7cf952eb1176ce61", "patch": "@@ -80,7 +80,6 @@ pub struct CrateMetadata {\n \n     pub info: common::CrateInfo,\n     pub index: index::Index,\n-    pub xref_index: index::DenseIndex,\n \n     /// For each public item in this crate, we encode a key.  When the\n     /// crate is loaded, we read all the keys and put them in this"}, {"sha": "c665a7be955dc372dee451d79719c7ca9c06b5bf", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6890354f3b43c98ff0e329fe7cf952eb1176ce61", "patch": "@@ -243,10 +243,10 @@ impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n         // Handle shorthands first, if we have an usize > 0x80.\n         if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n             let pos = self.read_usize()?;\n-            assert!(pos >= TYPE_SHORTHAND_OFFSET);\n+            assert!(pos >= SHORTHAND_OFFSET);\n             let key = ty::CReaderCacheKey {\n                 cnum: self.cdata().cnum,\n-                pos: pos - TYPE_SHORTHAND_OFFSET\n+                pos: pos - SHORTHAND_OFFSET\n             };\n             if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n                 return Ok(ty);\n@@ -333,11 +333,6 @@ pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n     })\n }\n \n-pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n-    let index = rbml::Doc::new(data).get(root_tag::xref_index);\n-    index::DenseIndex::from_buf(index.data, index.start, index.end)\n-}\n-\n // Go through each item in the metadata and create a map from that\n // item's def-key to the item's DefIndex.\n pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n@@ -1099,20 +1094,28 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n {\n     let mut dcx = base_doc.get(tag).decoder();\n     dcx.cdata = Some(cdata);\n+    dcx.tcx = Some(tcx);\n \n     ty::GenericPredicates {\n         parent: dcx.decode(),\n-        predicates: dcx.seq().map(|offset| {\n-            let predicate_pos = cdata.xref_index.lookup(\n-                cdata.data(), offset).unwrap() as usize;\n-            let mut dcx = rbml::Doc {\n-                data: cdata.data(),\n-                start: predicate_pos,\n-                end: cdata.data().len(),\n-            }.decoder();\n-            dcx.tcx = Some(tcx);\n-            dcx.cdata = Some(cdata);\n-            dcx.decode()\n+        predicates: (0..dcx.decode::<usize>()).map(|_| {\n+            // Handle shorthands first, if we have an usize > 0x80.\n+            if dcx.opaque.data[dcx.opaque.position()] & 0x80 != 0 {\n+                let pos = dcx.decode::<usize>();\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let pos = pos - SHORTHAND_OFFSET;\n+\n+                let mut dcx = rbml::Doc {\n+                    data: cdata.data(),\n+                    start: pos,\n+                    end: cdata.data().len(),\n+                }.decoder();\n+                dcx.tcx = Some(tcx);\n+                dcx.cdata = Some(cdata);\n+                dcx.decode()\n+            } else {\n+                dcx.decode()\n+            }\n         }).collect()\n     }\n }"}, {"sha": "637228725e0be18b3d90843eaae1dc6462890ac7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 42, "deletions": 68, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6890354f3b43c98ff0e329fe7cf952eb1176ce61", "patch": "@@ -16,7 +16,7 @@\n use astencode::encode_inlined_item;\n use common::*;\n use cstore;\n-use index::{self, IndexData};\n+use index::IndexData;\n \n use rustc::middle::cstore::{InlinedItemRef, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n@@ -30,11 +30,10 @@ use rustc::session::config::{self, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n-use std::cell::RefCell;\n+use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n-use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n@@ -58,14 +57,10 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     reachable: &'a NodeSet,\n     mir_map: &'a MirMap<'tcx>,\n \n-    type_shorthands: RefCell<FnvHashMap<Ty<'tcx>, usize>>,\n-    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n+    type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n+    predicate_shorthands: FnvHashMap<ty::Predicate<'tcx>, usize>,\n }\n \n-/// \"interned\" entries referenced by id\n-#[derive(PartialEq, Eq, Hash)]\n-enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n-\n impl<'a, 'tcx> Deref for EncodeContext<'a, 'tcx> {\n     type Target = rbml::writer::Encoder<'a>;\n     fn deref(&self) -> &Self::Target {\n@@ -117,20 +112,49 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n-        let existing_shorthand = self.type_shorthands.borrow().get(ty).cloned();\n+        self.encode_with_shorthand(ty, &ty.sty, |ecx| &mut ecx.type_shorthands)\n+    }\n+}\n+\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    fn seq<I, F, T>(&mut self, iter: I, mut f: F)\n+    where I: IntoIterator,\n+          I::IntoIter: ExactSizeIterator,\n+          F: FnMut(&mut Self, I::Item) -> T,\n+          T: Encodable {\n+        let iter = iter.into_iter();\n+        self.emit_seq(iter.len(), move |ecx| {\n+            for (i, elem) in iter.enumerate() {\n+                ecx.emit_seq_elt(i, |ecx| {\n+                    f(ecx, elem).encode(ecx)\n+                })?;\n+            }\n+            Ok(())\n+        }).unwrap();\n+    }\n+\n+    /// Encode the given value or a previously cached shorthand.\n+    fn encode_with_shorthand<T, U, M>(&mut self, value: &T, variant: &U, map: M)\n+                                      -> Result<(), <Self as Encoder>::Error>\n+    where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n+          T: Clone + Eq + Hash,\n+          U: Encodable {\n+        let existing_shorthand = map(self).get(value).cloned();\n         if let Some(shorthand) = existing_shorthand {\n             return self.emit_usize(shorthand);\n         }\n \n         let start = self.mark_stable_position();\n-        ty.sty.encode(self)?;\n+        variant.encode(self)?;\n         let len = self.mark_stable_position() - start;\n \n         // The shorthand encoding uses the same usize as the\n         // discriminant, with an offset so they can't conflict.\n-        let discriminant = unsafe { intrinsics::discriminant_value(&ty.sty) };\n-        assert!(discriminant < TYPE_SHORTHAND_OFFSET as u64);\n-        let shorthand = start + TYPE_SHORTHAND_OFFSET;\n+        let discriminant = unsafe {\n+            intrinsics::discriminant_value(variant)\n+        };\n+        assert!(discriminant < SHORTHAND_OFFSET as u64);\n+        let shorthand = start + SHORTHAND_OFFSET;\n \n         // Get the number of bits that leb128 could fit\n         // in the same space as the fully encoded type.\n@@ -139,29 +163,11 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n         // Check that the shorthand is a not longer than the\n         // full encoding itself, i.e. it's an obvious win.\n         if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n-            self.type_shorthands.borrow_mut().insert(*ty, shorthand);\n+            map(self).insert(value.clone(), shorthand);\n         }\n \n         Ok(())\n     }\n-}\n-\n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn seq<I, F, T>(&mut self, iter: I, mut f: F)\n-    where I: IntoIterator,\n-          I::IntoIter: ExactSizeIterator,\n-          F: FnMut(&mut Self, I::Item) -> T,\n-          T: Encodable {\n-        let iter = iter.into_iter();\n-        self.emit_seq(iter.len(), move |ecx| {\n-            for (i, elem) in iter.enumerate() {\n-                ecx.emit_seq_elt(i, |ecx| {\n-                    f(ecx, elem).encode(ecx)\n-                })?;\n-            }\n-            Ok(())\n-        }).unwrap();\n-    }\n \n     /// For every DefId that we create a metadata item for, we include a\n     /// serialized copy of its DefKey, which allows us to recreate a path.\n@@ -393,7 +399,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.start_tag(tag);\n         predicates.parent.encode(self).unwrap();\n         self.seq(&predicates.predicates, |ecx, predicate| {\n-            ecx.add_xref(XRef::Predicate(predicate.clone()))\n+            ecx.encode_with_shorthand(predicate, predicate,\n+                                      |ecx| &mut ecx.predicate_shorthands).unwrap()\n         });\n         self.end_tag();\n     }\n@@ -575,34 +582,6 @@ fn encode_stability(ecx: &mut EncodeContext, def_id: DefId) {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n-        let old_len = self.xrefs.len() as u32;\n-        *self.xrefs.entry(xref).or_insert(old_len)\n-    }\n-\n-    fn encode_xrefs(&mut self) {\n-        let xrefs = mem::replace(&mut self.xrefs, Default::default());\n-        let mut xref_positions = vec![0; xrefs.len()];\n-\n-        // Encode XRefs sorted by their ID\n-        let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n-        sorted_xrefs.sort_by_key(|&(_, id)| id);\n-\n-        self.start_tag(root_tag::xref_data);\n-        for (xref, id) in sorted_xrefs.into_iter() {\n-            xref_positions[id as usize] = self.mark_stable_position() as u32;\n-            match xref {\n-                XRef::Predicate(p) => p.encode(self).unwrap()\n-            }\n-        }\n-        self.mark_stable_position();\n-        self.end_tag();\n-\n-        self.start_tag(root_tag::xref_index);\n-        index::write_dense_index(xref_positions, &mut self.opaque.cursor);\n-        self.end_tag();\n-    }\n-\n     fn encode_info_for_item(&mut self,\n                             (def_id, item): (DefId, &hir::Item)) {\n         let tcx = self.tcx;\n@@ -1233,7 +1212,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable: reachable,\n         mir_map: mir_map,\n         type_shorthands: Default::default(),\n-        xrefs: Default::default()\n+        predicate_shorthands: Default::default()\n     });\n \n     // RBML compacts the encoded bytes whenever appropriate,\n@@ -1345,10 +1324,6 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     encode_item_index(ecx, items);\n     let index_bytes = ecx.position() - i;\n \n-    i = ecx.position();\n-    ecx.encode_xrefs();\n-    let xref_bytes = ecx.position() - i;\n-\n     let total_bytes = ecx.position();\n \n     if ecx.tcx.sess.meta_stats() {\n@@ -1369,7 +1344,6 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n         println!(\"       reachable bytes: {}\", reachable_bytes);\n         println!(\"            item bytes: {}\", item_bytes);\n         println!(\"           index bytes: {}\", index_bytes);\n-        println!(\"            xref bytes: {}\", xref_bytes);\n         println!(\"            zero bytes: {}\", zero_bytes);\n         println!(\"           total bytes: {}\", total_bytes);\n     }"}, {"sha": "2c16411c37bdf349435b5fe848aa54da3eec4104", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6890354f3b43c98ff0e329fe7cf952eb1176ce61/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=6890354f3b43c98ff0e329fe7cf952eb1176ce61", "patch": "@@ -108,36 +108,6 @@ impl IndexData {\n     }\n }\n \n-/// A dense index with integer keys. Different API from IndexData (should\n-/// these be merged?)\n-pub struct DenseIndex {\n-    start: usize,\n-    end: usize\n-}\n-\n-impl DenseIndex {\n-    pub fn lookup(&self, buf: &[u8], ix: u32) -> Option<u32> {\n-        let data = bytes_to_words(&buf[self.start..self.end]);\n-        data.get(ix as usize).map(|d| u32::from_le(*d))\n-    }\n-    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n-        assert!((end-start)%4 == 0 && start <= end && end <= buf.len());\n-        DenseIndex {\n-            start: start,\n-            end: end\n-        }\n-    }\n-}\n-\n-pub fn write_dense_index(entries: Vec<u32>, buf: &mut Cursor<Vec<u8>>) {\n-    let elen = entries.len();\n-    assert!(elen < u32::MAX as usize);\n-\n-    buf.write_all(words_to_bytes(&entries)).unwrap();\n-\n-    info!(\"write_dense_index: {} entries\", elen);\n-}\n-\n fn bytes_to_words(b: &[u8]) -> &[u32] {\n     assert!(b.len() % 4 == 0);\n     unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }"}]}