{"sha": "764839320c247b813528533c79d4b25a4f55f5fd", "node_id": "C_kwDOAAsO6NoAKDc2NDgzOTMyMGMyNDdiODEzNTI4NTMzYzc5ZDRiMjVhNGY1NWY1ZmQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-11T07:42:28Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-15T17:17:09Z"}, "message": "rename some variables in gat wfcheck", "tree": {"sha": "67546778c9f2648771d9d54d98451706c1a740a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67546778c9f2648771d9d54d98451706c1a740a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/764839320c247b813528533c79d4b25a4f55f5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/764839320c247b813528533c79d4b25a4f55f5fd", "html_url": "https://github.com/rust-lang/rust/commit/764839320c247b813528533c79d4b25a4f55f5fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/764839320c247b813528533c79d4b25a4f55f5fd/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "html_url": "https://github.com/rust-lang/rust/commit/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57"}], "stats": {"total": 43, "additions": 18, "deletions": 25}, "files": [{"sha": "1864101467b7aeb11ee96f5205879ad452370c65", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/764839320c247b813528533c79d4b25a4f55f5fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764839320c247b813528533c79d4b25a4f55f5fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=764839320c247b813528533c79d4b25a4f55f5fd", "patch": "@@ -275,30 +275,27 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n ///   fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n /// }\n /// ```\n-fn check_gat_where_clauses(\n-    tcx: TyCtxt<'_>,\n-    trait_item: &hir::TraitItem<'_>,\n-    encl_trait_def_id: DefId,\n-) {\n-    let item = tcx.associated_item(trait_item.def_id);\n+fn check_gat_where_clauses(tcx: TyCtxt<'_>, gat_hir: &hir::TraitItem<'_>, gat_def_id: DefId) {\n+    let gat_item = tcx.associated_item(gat_def_id);\n+    let gat_def_id = gat_hir.def_id;\n     // If the current trait item isn't a type, it isn't a GAT\n-    if !matches!(item.kind, ty::AssocKind::Type) {\n+    if !matches!(gat_item.kind, ty::AssocKind::Type) {\n         return;\n     }\n-    let generics: &ty::Generics = tcx.generics_of(trait_item.def_id);\n+    let gat_generics: &ty::Generics = tcx.generics_of(gat_def_id);\n     // If the current associated type doesn't have any (own) params, it's not a GAT\n     // FIXME(jackh726): we can also warn in the more general case\n-    if generics.params.len() == 0 {\n+    if gat_generics.params.len() == 0 {\n         return;\n     }\n-    let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n+    let associated_items: &ty::AssocItems<'_> = tcx.associated_items(gat_def_id);\n     let mut clauses: Option<FxHashSet<ty::Predicate<'_>>> = None;\n     // For every function in this trait...\n     // In our example, this would be the `next` method\n     for item in\n         associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n     {\n-        let id = hir::HirId::make_owner(item.def_id.expect_local());\n+        let item_hir_id = hir::HirId::make_owner(item.def_id.expect_local());\n         let param_env = tcx.param_env(item.def_id.expect_local());\n \n         // Get the signature using placeholders. In our example, this would\n@@ -314,11 +311,11 @@ fn check_gat_where_clauses(\n         let function_clauses = gather_gat_bounds(\n             tcx,\n             param_env,\n-            id,\n+            item_hir_id,\n             sig.output(),\n             &wf_tys,\n-            trait_item.def_id,\n-            generics,\n+            gat_def_id,\n+            gat_generics,\n         );\n \n         if let Some(function_clauses) = function_clauses {\n@@ -347,15 +344,15 @@ fn check_gat_where_clauses(\n     let clauses = clauses.unwrap_or_default();\n     debug!(?clauses);\n     if !clauses.is_empty() {\n-        let param_env = tcx.param_env(trait_item.def_id);\n+        let param_env = tcx.param_env(gat_def_id);\n \n         let mut clauses: Vec<_> = clauses\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n                     !region_known_to_outlive(\n                         tcx,\n-                        trait_item.hir_id(),\n+                        gat_hir.hir_id(),\n                         param_env,\n                         &FxHashSet::default(),\n                         a,\n@@ -365,7 +362,7 @@ fn check_gat_where_clauses(\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n                     !ty_known_to_outlive(\n                         tcx,\n-                        trait_item.hir_id(),\n+                        gat_hir.hir_id(),\n                         param_env,\n                         &FxHashSet::default(),\n                         a,\n@@ -383,21 +380,17 @@ fn check_gat_where_clauses(\n         if !clauses.is_empty() {\n             let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n             let mut err = tcx.sess.struct_span_err(\n-                trait_item.span,\n-                &format!(\"missing required bound{} on `{}`\", plural, trait_item.ident),\n+                gat_hir.span,\n+                &format!(\"missing required bound{} on `{}`\", plural, gat_hir.ident),\n             );\n \n             let suggestion = format!(\n                 \"{} {}\",\n-                if !trait_item.generics.where_clause.predicates.is_empty() {\n-                    \",\"\n-                } else {\n-                    \" where\"\n-                },\n+                if !gat_hir.generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n                 clauses.join(\", \"),\n             );\n             err.span_suggestion(\n-                trait_item.generics.where_clause.tail_span_for_suggestion(),\n+                gat_hir.generics.where_clause.tail_span_for_suggestion(),\n                 &format!(\"add the required where clause{}\", plural),\n                 suggestion,\n                 Applicability::MachineApplicable,"}]}