{"sha": "c4ac124edda29eabffc2acc3255aca1a0c2680f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YWMxMjRlZGRhMjllYWJmZmMyYWNjMzI1NWFjYTFhMGMyNjgwZjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-03T01:48:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-03T01:48:23Z"}, "message": "Merge remote-tracking branch 'origin/master' into 0.11.0-release\n\nConflicts:\n\tRELEASES.txt", "tree": {"sha": "488edf8d1734ab70c6556e322260ad98e0910f7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/488edf8d1734ab70c6556e322260ad98e0910f7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4ac124edda29eabffc2acc3255aca1a0c2680f0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ac124edda29eabffc2acc3255aca1a0c2680f0", "html_url": "https://github.com/rust-lang/rust/commit/c4ac124edda29eabffc2acc3255aca1a0c2680f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4ac124edda29eabffc2acc3255aca1a0c2680f0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "html_url": "https://github.com/rust-lang/rust/commit/ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "c8ae065182d19a098aa397fddcb4f4f4eccc0b32", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ae065182d19a098aa397fddcb4f4f4eccc0b32", "html_url": "https://github.com/rust-lang/rust/commit/c8ae065182d19a098aa397fddcb4f4f4eccc0b32"}], "stats": {"total": 840, "additions": 604, "deletions": 236}, "files": [{"sha": "dd62defa02039ad5934b688d94fe07980706b4df", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -41,7 +41,7 @@ script: |\n     if [[ $LLVM_VERSION != '3.4' ]]; then exit 0; fi\n   fi &&\n   make tidy &&\n-  travis_wait make -j4 rustc-stage1 &&\n+  make -j4 rustc-stage1 RUSTFLAGS='-Z time-passes' &&\n   make check-stage1-std check-stage1-rpass check-stage1-cfail check-stage1-rfail check-stage1-doc\n \n env:"}, {"sha": "ab4f234cc99b1f5249e5eb50b5316df2dc9f65a9", "filename": "AUTHORS.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -487,7 +487,6 @@ TyOverby <ty@pre-alpha.com>\n Tycho Sci <tychosci@gmail.com>\n Tyler Bindon <martica@martica.org>\n U-NOV2010\\eugals\n-User Jyyou <jyyou@plaslab.cs.nctu.edu.tw>\n Utkarsh Kukreti <utkarshkukreti@gmail.com>\n Uwe Dauernheim <uwe@dauernheim.net>\n Vadim Chugunov <vadimcn@gmail.com>"}, {"sha": "457328b2c90ca32ab54991f0ff1c21516a6e697c", "filename": "RELEASES.txt", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -1,7 +1,7 @@\n-Version 0.11 (July 2014)\n+Version 0.11.0 (July 2014)\n -------------------------\n \n-  * ~1700 cahnges, numerous bugfixes\n+  * ~1700 changes, numerous bugfixes\n \n   * Language\n     * ~[T] has been removed from the language. This type is superseded by\n@@ -13,26 +13,25 @@ Version 0.11 (July 2014)\n     * @T has been removed from the language. This type is superseded by the\n       standard library's std::gc::Gc<T> type.\n     * Struct fields are now all private by default.\n-    * Vector indices and shift amounts are both required to be a `uint` now\n+    * Vector indices and shift amounts are both required to be a `uint`\n       instead of any integral type.\n     * Byte character, byte string, and raw byte string literals are now all\n       supported by prefixing the normal literal with a `b`.\n     * Multiple ABIs are no longer allowed in an ABI string\n-    * The syntax for lifetimes on clousres/procedures has been tweaked\n-      slightly.\n-    * Floating point modulus has been removed from the language, it is still\n-      provided by a library implementation, however.\n+    * The syntax for lifetimes on closures/procedures has been tweaked\n+      slightly: `<'a>|A, B|: 'b + K -> T`\n+    * Floating point modulus has been removed from the language; however it\n+      is still provided by a library implementation.\n     * Private enum variants are now disallowed.\n     * The `priv` keyword has been removed from the language.\n     * A closure can no longer be invoked through a &-pointer.\n     * The `use foo, bar, baz;` syntax has been removed from the language.\n     * The transmute intrinsic no longer works on type parameters.\n     * Statics now allow blocks/items in their definition.\n     * Trait bounds are separated from objects with + instead of : now.\n-    * Mutably borrowed objects can no longer be read while they are\n-      borrowed.\n+    * Objects can no longer be read while they are mutably borrowed.\n     * The address of a static is now marked as insignificant unless the\n-      #[inline(never)] attribute is placed on a static.\n+      #[inline(never)] attribute is placed it.\n     * The #[unsafe_destructor] attribute is now behind a feature gate.\n     * Struct literals are no longer allowed in ambiguous positions such as\n       if, while, match, and for..in.\n@@ -48,13 +47,13 @@ Version 0.11 (July 2014)\n   * Libraries\n     * The standard library is now a \"facade\" over a number of underlying\n       libraries. This means that development on the standard library should\n-      be speeder due to less to compile, as well as a clearer line between\n+      be speeder due to smaller crates, as well as a clearer line between\n       all dependencies.\n     * A new library, libcore, lives under the standard library's facade\n       which is Rust's \"0-assumption\" library, suitable for embedded and\n       kernel development for example.\n     * A regex crate has been added to the standard distribution. This crate\n-      includes statically compiled regulard expressions.\n+      includes statically compiled regular expressions.\n     * The unwrap/unwrap_err methods on Result require a Show bound for\n       better error messages.\n     * The return types of the std::comm primitives have been centralized\n@@ -72,11 +71,11 @@ Version 0.11 (July 2014)\n     * A graphviz crate has been added for creating .dot files.\n     * The std::cast module has been migrated into std::mem.\n     * The std::local_data api has been migrated from freestanding functions\n-      to based on methods.\n+      to being based on methods.\n     * The Pod trait has been renamed to Copy.\n     * jemalloc has been added as the default allocator for types.\n-    * The api for allocating memory in rust has been modified for sized\n-      deallocation as well as using proper alignment.\n+    * The API for allocating memory has been changed to use proper alignment\n+      and sized deallocation\n     * Connecting a TcpStream or binding a TcpListener is now based on a\n       string address and a u16 port. This allows connecting to a hostname as\n       opposed to an IP.\n@@ -100,11 +99,11 @@ Version 0.11 (July 2014)\n       discovery of breaking changes.\n     * The compiler will now try to suggest how to annotate lifetimes if a\n       lifetime-related error occurs.\n-    * Debug info continues to be improved greatly with better support for\n-      situations such as LTO and general bug fixes.\n+    * Debug info continues to be improved greatly with general bug fixes and\n+      better support for situations like link time optimization (LTO).\n     * Usage of syntax extensions when cross-compiling has been fixed.\n-    * The equivalent of ffunction-sections and fdata-sections have been\n-      enabled by default with the equivalent of --gc-sections.\n+    * Functionality equivalent to GCC & Clang's -ffunction-sections,\n+      -fdata-sections and --gc-sections has been enabled by default\n     * The compiler is now stricter about where it will load module files\n       from when a module is declared via `mod foo;`.\n     * The #[phase(syntax)] attribute has been renamed to #[phase(plugin)].\n@@ -128,7 +127,7 @@ Version 0.11 (July 2014)\n     * Cross-compiling to mipsel is now supported.\n     * Stability attributes are now inherited by default and no longer apply\n       to intra-crate usage, only inter-crate usage.\n-    * Error message related to non-exhaustive match statements have been\n+    * Error message related to non-exhaustive match expressions have been\n       greatly improved.\n \n Version 0.10 (April 2014)"}, {"sha": "1400e207ab1a8615f73416d3fd7a7227bea279a1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 290, "deletions": 198, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil, const_val};\n use middle::const_eval::{eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n-\n+use std::fmt;\n use std::gc::{Gc, GC};\n-use std::iter;\n+use std::iter::AdditiveIterator;\n+use std::iter::range_inclusive;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n@@ -28,7 +27,71 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use util::ppaux::ty_to_str;\n \n-type Matrix = Vec<Vec<Gc<Pat>>>;\n+struct Matrix(Vec<Vec<Gc<Pat>>>);\n+\n+/// Pretty-printer for matrices of patterns, example:\n+/// ++++++++++++++++++++++++++\n+/// + _     + []             +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [First]        +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [Second(true)] +\n+/// ++++++++++++++++++++++++++\n+/// + false + [_]            +\n+/// ++++++++++++++++++++++++++\n+/// + _     + [_, _, ..tail] +\n+/// ++++++++++++++++++++++++++\n+impl fmt::Show for Matrix {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"\\n\"));\n+\n+        let &Matrix(ref m) = self;\n+        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n+            row.iter().map(|&pat| pat_to_str(pat)).collect::<Vec<String>>()\n+        }).collect();\n+\n+        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n+        assert!(m.iter().all(|row| row.len() == column_count));\n+        let column_widths: Vec<uint> = range(0, column_count).map(|col| {\n+            pretty_printed_matrix.iter().map(|row| row.get(col).len()).max().unwrap_or(0u)\n+        }).collect();\n+\n+        let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n+        let br = String::from_char(total_width, '+');\n+        try!(write!(f, \"{}\\n\", br));\n+        for row in pretty_printed_matrix.move_iter() {\n+            try!(write!(f, \"+\"));\n+            for (column, pat_str) in row.move_iter().enumerate() {\n+                try!(write!(f, \" \"));\n+                f.width = Some(*column_widths.get(column));\n+                try!(f.pad(pat_str.as_slice()));\n+                try!(write!(f, \" +\"));\n+            }\n+            try!(write!(f, \"\\n\"));\n+            try!(write!(f, \"{}\\n\", br));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct MatchCheckCtxt<'a> {\n+    tcx: &'a ty::ctxt\n+}\n+\n+#[deriving(Clone, PartialEq)]\n+enum Constructor {\n+    /// The constructor of all patterns that don't vary by constructor,\n+    /// e.g. struct patterns and fixed-length arrays.\n+    Single,\n+    /// Enum variants.\n+    Variant(DefId),\n+    /// Literal values.\n+    ConstantValue(const_val),\n+    /// Ranges of literal values (2..5).\n+    ConstantRange(const_val, const_val),\n+    /// Array patterns of length n.\n+    Slice(uint)\n+}\n \n #[deriving(Clone)]\n enum Usefulness {\n@@ -50,22 +113,6 @@ impl Usefulness {\n     }\n }\n \n-fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n-    ty::with_path(tcx, id, |mut path| Path {\n-        global: false,\n-        segments: path.last().map(|elem| PathSegment {\n-            identifier: Ident::new(elem.name()),\n-            lifetimes: vec!(),\n-            types: OwnedSlice::empty()\n-        }).move_iter().collect(),\n-        span: DUMMY_SP,\n-    })\n-}\n-\n-struct MatchCheckCtxt<'a> {\n-    tcx: &'a ty::ctxt,\n-}\n-\n impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n@@ -78,11 +125,8 @@ impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &Crate) {\n-    let mut cx = MatchCheckCtxt {\n-        tcx: tcx,\n-    };\n+pub fn check_crate(tcx: &ty::ctxt, krate: &Crate) {\n+    let mut cx = MatchCheckCtxt { tcx: tcx, };\n \n     visit::walk_crate(&mut cx, krate, ());\n \n@@ -116,12 +160,12 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                // If the type *is* empty, it's vacuously exhaustive\n                return;\n             }\n-            let m: Matrix = arms\n+            let m: Matrix = Matrix(arms\n                 .iter()\n                 .filter(|&arm| is_unguarded(arm))\n                 .flat_map(|arm| arm.pats.iter())\n                 .map(|pat| vec!(pat.clone()))\n-                .collect();\n+                .collect());\n             check_exhaustive(cx, ex.span, &m);\n         },\n         _ => ()\n@@ -130,7 +174,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n \n // Check for unreachable patterns\n fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = Vec::new();\n+    let mut seen = Matrix(vec!());\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n             // Check that we do not match against a static NaN (#6804)\n@@ -161,7 +205,11 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 NotUseful => cx.tcx.sess.span_err(pat.span, \"unreachable pattern\"),\n                 _ => ()\n             }\n-            if arm.guard.is_none() { seen.push(v); }\n+            if arm.guard.is_none() {\n+                let Matrix(mut rows) = seen;\n+                rows.push(v);\n+                seen = Matrix(rows);\n+            }\n         }\n     }\n }\n@@ -175,10 +223,6 @@ fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n \n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n     match is_useful(cx, m, [wild()], ConstructWitness) {\n-        NotUseful => {\n-            // This is good, wildcard pattern isn't reachable\n-            return;\n-        }\n         Useful(pats) => {\n             let witness = match pats.as_slice() {\n                 [witness] => witness,\n@@ -188,38 +232,58 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n             let msg = format!(\"non-exhaustive patterns: `{0}` not covered\", pat_to_str(&*witness));\n             cx.tcx.sess.span_err(sp, msg.as_slice());\n         }\n+        NotUseful => {\n+            // This is good, wildcard pattern isn't reachable\n+        }\n     }\n }\n \n-#[deriving(Clone, PartialEq)]\n-enum ctor {\n-    single,\n-    variant(DefId),\n-    val(const_val),\n-    range(const_val, const_val),\n-    vec(uint)\n-}\n-\n fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n     let node = match value {\n         &const_bool(b) => LitBool(b),\n         &const_nil => LitNil,\n         _ => unreachable!()\n     };\n-    box(GC) Expr {\n+    box (GC) Expr {\n         id: 0,\n         node: ExprLit(box(GC) Spanned { node: node, span: DUMMY_SP }),\n         span: DUMMY_SP\n     }\n }\n \n-fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty: ty::t) -> Gc<Pat> {\n-    let pat = match ty::get(lty).sty {\n+fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n+    ty::with_path(tcx, id, |mut path| Path {\n+        global: false,\n+        segments: path.last().map(|elem| PathSegment {\n+            identifier: Ident::new(elem.name()),\n+            lifetimes: vec!(),\n+            types: OwnedSlice::empty()\n+        }).move_iter().collect(),\n+        span: DUMMY_SP,\n+    })\n+}\n+\n+/// Constructs a partial witness for a pattern given a list of\n+/// patterns expanded by the specialization step.\n+///\n+/// When a pattern P is discovered to be useful, this function is used bottom-up\n+/// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n+/// of values, V, where each value in that set is not covered by any previously\n+/// used patterns and is covered by the pattern P'. Examples:\n+///\n+/// left_ty: tuple of 3 elements\n+/// pats: [10, 20, _]           => (10, 20, _)\n+///\n+/// left_ty: struct X { a: (bool, &'static str), b: uint}\n+/// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n+                     pats: Vec<Gc<Pat>>, left_ty: ty::t) -> Gc<Pat> {\n+    let pat = match ty::get(left_ty).sty {\n         ty::ty_tup(_) => PatTup(pats),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n-                &variant(vid) => (vid,\n+                &Variant(vid) => (vid,\n                     ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n                 _ => (cid, true)\n             };\n@@ -235,103 +299,95 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty:\n             } else {\n                 PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n             }\n-        },\n+        }\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n             match ty::get(ty).sty {\n+               ty::ty_vec(_, Some(n)) => match ctor {\n+                    &Single => {\n+                        assert_eq!(pats.len(), n);\n+                        PatVec(pats, None, vec!())\n+                    },\n+                    _ => unreachable!()\n+                },\n                 ty::ty_vec(_, None) => match ctor {\n-                    &vec(_) => PatVec(pats, None, vec!()),\n+                    &Slice(n) => {\n+                        assert_eq!(pats.len(), n);\n+                        PatVec(pats, None, vec!())\n+                    },\n                     _ => unreachable!()\n                 },\n                 ty::ty_str => PatWild,\n+\n                 _ => {\n                     assert_eq!(pats.len(), 1);\n                     PatRegion(pats.get(0).clone())\n                 }\n             }\n-        },\n+        }\n \n         ty::ty_box(_) => {\n             assert_eq!(pats.len(), 1);\n             PatBox(pats.get(0).clone())\n-        },\n+        }\n+\n+        ty::ty_vec(_, Some(len)) => {\n+            assert_eq!(pats.len(), len);\n+            PatVec(pats, None, vec!())\n+        }\n \n         _ => {\n-            match ctor {\n-                &vec(_) => PatVec(pats, None, vec!()),\n-                &val(ref v) => PatLit(const_val_to_expr(v)),\n+            match *ctor {\n+                ConstantValue(ref v) => PatLit(const_val_to_expr(v)),\n                 _ => PatWild\n             }\n         }\n     };\n \n-    box(GC) Pat {\n+    box (GC) Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n     }\n }\n \n-fn missing_constructor(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Option<ctor> {\n-    let used_constructors: Vec<ctor> = m.iter()\n-        .filter_map(|r| pat_ctor_id(cx, left_ty, *r.get(0)))\n+fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n+                       left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n+    let used_constructors: Vec<Constructor> = rows.iter()\n+        .flat_map(|row| pat_constructors(cx, *row.get(0), left_ty, max_slice_length).move_iter())\n         .collect();\n-\n-    all_constructors(cx, m, left_ty)\n+    all_constructors(cx, left_ty, max_slice_length)\n         .move_iter()\n         .find(|c| !used_constructors.contains(c))\n }\n \n-fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor> {\n-    // This produces a list of all vector constructors that we would expect to appear\n-    // in an exhaustive set of patterns. Because such a list would normally be infinite,\n-    // we narrow it down to only those constructors that actually appear in the inspected\n-    // column, plus, any that are missing and not covered by a pattern with a destructured slice.\n-    fn vec_constructors(m: &Matrix) -> Vec<ctor> {\n-        let max_vec_len = m.iter().map(|r| match r.get(0).node {\n-            PatVec(ref before, _, ref after) => before.len() + after.len(),\n-            _ => 0u\n-        }).max().unwrap_or(0u);\n-        let min_vec_len_with_slice = m.iter().map(|r| match r.get(0).node {\n-            PatVec(ref before, Some(_), ref after) => before.len() + after.len(),\n-            _ => max_vec_len + 1\n-        }).min().unwrap_or(max_vec_len + 1);\n-        let other_lengths = m.iter().map(|r| match r.get(0).node {\n-            PatVec(ref before, _, ref after) => before.len() + after.len(),\n-            _ => 0u\n-        }).filter(|&len| len > min_vec_len_with_slice);\n-        iter::range_inclusive(0u, min_vec_len_with_slice)\n-            .chain(other_lengths)\n-            .map(|len| vec(len))\n-            .collect()\n-    }\n-\n+/// This determines the set of all possible constructors of a pattern matching\n+/// values of type `left_ty`. For vectors, this would normally be an infinite set\n+/// but is instead bounded by the maximum fixed length of slice patterns in\n+/// the column of patterns being analyzed.\n+fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n+                    max_slice_length: uint) -> Vec<Constructor> {\n     match ty::get(left_ty).sty {\n         ty::ty_bool =>\n-            [true, false].iter().map(|b| val(const_bool(*b))).collect(),\n+            [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n         ty::ty_nil =>\n-            vec!(val(const_nil)),\n+            vec!(ConstantValue(const_nil)),\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n-            ty::ty_vec(_, None) => vec_constructors(m),\n-            _ => vec!(single)\n+            ty::ty_vec(_, None) =>\n+                range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n+            _ => vec!(Single)\n         },\n \n         ty::ty_enum(eid, _) =>\n             ty::enum_variants(cx.tcx, eid)\n                 .iter()\n-                .map(|va| variant(va.id))\n+                .map(|va| Variant(va.id))\n                 .collect(),\n \n-        ty::ty_vec(_, None) =>\n-            vec_constructors(m),\n-\n-        ty::ty_vec(_, Some(n)) =>\n-            vec!(vec(n)),\n-\n         _ =>\n-            vec!(single)\n+            vec!(Single)\n     }\n }\n \n@@ -348,15 +404,16 @@ fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n-             witness: WitnessPreference) -> Usefulness {\n-    if m.len() == 0u {\n+fn is_useful(cx: &MatchCheckCtxt, m @ &Matrix(ref rows): &Matrix,\n+             v: &[Gc<Pat>], witness: WitnessPreference) -> Usefulness {\n+    debug!(\"{:}\", m);\n+    if rows.len() == 0u {\n         return Useful(vec!());\n     }\n-    if m.get(0).len() == 0u {\n+    if rows.get(0).len() == 0u {\n         return NotUseful;\n     }\n-    let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n+    let real_pat = match rows.iter().find(|r| r.get(0).id != 0) {\n         Some(r) => {\n             match r.get(0).node {\n                 // An arm of the form `ref x @ sub_pat` has type\n@@ -374,10 +431,16 @@ fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n         ty::pat_ty(cx.tcx, &*real_pat)\n     };\n \n-    match pat_ctor_id(cx, left_ty, v[0]) {\n-        None => match missing_constructor(cx, m, left_ty) {\n+    let max_slice_length = rows.iter().filter_map(|row| match row.get(0).node {\n+        PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        _ => None\n+    }).max().map_or(0, |v| v + 1);\n+\n+    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n+    if constructors.is_empty() {\n+        match missing_constructor(cx, m, left_ty, max_slice_length) {\n             None => {\n-                all_constructors(cx, m, left_ty).move_iter().filter_map(|c| {\n+                all_constructors(cx, left_ty, max_slice_length).move_iter().filter_map(|c| {\n                     is_useful_specialized(cx, m, v, c.clone(),\n                                           left_ty, witness).useful().map(|pats| {\n                         Useful(match witness {\n@@ -400,79 +463,98 @@ fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n                 }).nth(0).unwrap_or(NotUseful)\n             },\n \n-            Some(ctor) => {\n-                let matrix = m.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+            Some(constructor) => {\n+                let matrix = Matrix(rows.iter().filter_map(|r|\n+                    default(cx, r.as_slice())).collect());\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     Useful(pats) => Useful(match witness {\n                         ConstructWitness => {\n-                            let arity = constructor_arity(cx, &ctor, left_ty);\n+                            let arity = constructor_arity(cx, &constructor, left_ty);\n                             let wild_pats = Vec::from_elem(arity, wild());\n-                            let enum_pat = construct_witness(cx, &ctor, wild_pats, left_ty);\n+                            let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                             (vec!(enum_pat)).append(pats.as_slice())\n                         }\n                         LeaveOutWitness => vec!()\n                     }),\n                     result => result\n                 }\n             }\n-        },\n-\n-        Some(v0_ctor) => is_useful_specialized(cx, m, v, v0_ctor, left_ty, witness)\n+        }\n+    } else {\n+        constructors.move_iter().filter_map(|c| {\n+            is_useful_specialized(cx, m, v, c.clone(), left_ty, witness)\n+                .useful().map(|pats| Useful(pats))\n+        }).nth(0).unwrap_or(NotUseful)\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n-                         ctor: ctor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n+fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<Pat>],\n+                         ctor: Constructor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n-    let matrix = m.iter().filter_map(|r| {\n+    let matrix = Matrix(m.iter().filter_map(|r| {\n         specialize(cx, r.as_slice(), &ctor, arity)\n-    }).collect();\n+    }).collect());\n     match specialize(cx, v, &ctor, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n }\n \n-fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor> {\n+/// Determines the constructors that the given pattern can be specialized to.\n+///\n+/// In most cases, there's only one constructor that a specific pattern\n+/// represents, such as a specific enum variant or a specific literal value.\n+/// Slice patterns, however, can match slices of different lengths. For instance,\n+/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n+///\n+/// On the other hand, a wild pattern and an identifier pattern cannot be\n+/// specialized in any way.\n+fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n+                    left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n         PatIdent(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefStatic(did, false)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                    vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-                _ => None\n+                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                _ => vec!()\n             },\n         PatEnum(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefStatic(did, false)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                    vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-                _ => Some(single)\n+                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                _ => vec!(Single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-                _ => Some(single)\n+                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                _ => vec!(Single)\n             },\n         PatLit(expr) =>\n-            Some(val(eval_const_expr(cx.tcx, &*expr))),\n+            vec!(ConstantValue(eval_const_expr(cx.tcx, &*expr))),\n         PatRange(lo, hi) =>\n-            Some(range(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n-        PatVec(ref before, _, ref after) => match ty::get(left_ty).sty {\n-            ty::ty_vec(_, Some(n)) =>\n-                Some(vec(n)),\n-            _ =>\n-                Some(vec(before.len() + after.len()))\n-        },\n+            vec!(ConstantRange(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n+        PatVec(ref before, ref slice, ref after) =>\n+            match ty::get(left_ty).sty {\n+                ty::ty_vec(_, Some(_)) => vec!(Single),\n+                _                      => if slice.is_some() {\n+                    range_inclusive(before.len() + after.len(), max_slice_length)\n+                        .map(|length| Slice(length))\n+                        .collect()\n+                } else {\n+                    vec!(Slice(before.len() + after.len()))\n+                }\n+            },\n         PatBox(_) | PatTup(_) | PatRegion(..) =>\n-            Some(single),\n+            vec!(Single),\n         PatWild | PatWildMulti =>\n-            None,\n+            vec!(),\n         PatMac(_) =>\n             cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n@@ -482,53 +564,53 @@ fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n         PatWild | PatWildMulti => true,\n-        PatIdent(_, _, _) => {\n+        PatIdent(_, _, _) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => false,\n                 _ => true\n-            }\n-        }\n+            },\n+        PatVec(ref before, Some(_), ref after) =>\n+            before.is_empty() && after.is_empty(),\n         _ => false\n     }\n }\n \n-fn constructor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n+/// This computes the arity of a constructor. The arity of a constructor\n+/// is how many subpattern patterns of that constructor should be expanded to.\n+///\n+/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n+/// A struct pattern's arity is the number of fields it contains, etc.\n+fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) => match *ctor {\n-                vec(n) => n,\n-                _ => 0u\n+                Slice(length) => length,\n+                _ => unreachable!()\n             },\n             ty::ty_str => 0u,\n             _ => 1u\n         },\n         ty::ty_enum(eid, _) => {\n             match *ctor {\n-                variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                Variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n         ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-        ty::ty_vec(_, _) => match *ctor {\n-            vec(n) => n,\n-            _ => 0u\n-        },\n+        ty::ty_vec(_, Some(n)) => n,\n         _ => 0u\n     }\n }\n \n-fn wild() -> Gc<Pat> {\n-    box(GC) Pat {id: 0, node: PatWild, span: DUMMY_SP}\n-}\n-\n-fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n-    let (c_from, c_to) = match *ctor_id {\n-        val(ref value)          => (value, value),\n-        range(ref from, ref to) => (from, to),\n-        single                  => return Some(true),\n-        _                       => unreachable!()\n+fn range_covered_by_constructor(ctor: &Constructor,\n+                                from: &const_val,to: &const_val) -> Option<bool> {\n+    let (c_from, c_to) = match *ctor {\n+        ConstantValue(ref value)        => (value, value),\n+        ConstantRange(ref from, ref to) => (from, to),\n+        Single                          => return Some(true),\n+        _                               => unreachable!()\n     };\n     let cmp_from = compare_const_vals(c_from, from);\n     let cmp_to = compare_const_vals(c_to, to);\n@@ -538,34 +620,42 @@ fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val\n     }\n }\n \n+/// This is the main specialization step. It expands the first pattern in the given row\n+/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n+/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n+///\n+/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n+/// different patterns.\n+/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+/// fields filled with wild patterns.\n fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n-              ctor_id: &ctor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+              constructor: &Constructor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n     let &Pat {\n-        id: ref pat_id, node: ref n, span: ref pat_span\n+        id: pat_id, node: ref node, span: pat_span\n     } = &(*raw_pat(r[0]));\n-    let head: Option<Vec<Gc<Pat>>> = match n {\n-        &PatWild => {\n-            Some(Vec::from_elem(arity, wild()))\n-        }\n-        &PatWildMulti => {\n-            Some(Vec::from_elem(arity, wild()))\n-        }\n+    let head: Option<Vec<Gc<Pat>>> = match node {\n+        &PatWild =>\n+            Some(Vec::from_elem(arity, wild())),\n+\n+        &PatWildMulti =>\n+            Some(Vec::from_elem(arity, wild())),\n+\n         &PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n+            let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n             match opt_def {\n-                Some(DefVariant(_, id, _)) => if *ctor_id == variant(id) {\n+                Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n                     Some(vec!())\n                 } else {\n                     None\n                 },\n                 Some(DefStatic(did, _)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                    match range_covered_by_constructor(constructor, &e_v, &e_v) {\n                         Some(true) => Some(vec!()),\n                         Some(false) => None,\n                         None => {\n-                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                             None\n                         }\n                     }\n@@ -575,22 +665,23 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 }\n             }\n         }\n+\n         &PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             match def {\n                 DefStatic(did, _) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                    match range_covered_by_constructor(constructor, &e_v, &e_v) {\n                         Some(true) => Some(vec!()),\n                         Some(false) => None,\n                         None => {\n-                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                             None\n                         }\n                     }\n                 }\n-                DefVariant(_, id, _) if *ctor_id != variant(id) => None,\n+                DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.clone(),\n@@ -603,9 +694,9 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n \n         &PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             let class_id = match def {\n-                DefVariant(_, variant_id, _) => if *ctor_id == variant(variant_id) {\n+                DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n                     Some(variant_id)\n                 } else {\n                     None\n@@ -633,11 +724,11 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n \n         &PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n-            match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n+            match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec!()),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -646,41 +737,42 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n         &PatRange(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n-            match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n+            match range_covered_by_constructor(constructor, &from_value, &to_value) {\n                 Some(true) => Some(vec!()),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                     None\n                 }\n             }\n         }\n \n         &PatVec(ref before, ref slice, ref after) => {\n-            match *ctor_id {\n-                vec(_) => {\n-                    let num_elements = before.len() + after.len();\n-                    if num_elements < arity && slice.is_some() {\n-                        let mut result = Vec::new();\n-                        result.push_all(before.as_slice());\n-                        result.grow_fn(arity - num_elements, |_| wild());\n-                        result.push_all(after.as_slice());\n-                        Some(result)\n-                    } else if num_elements == arity {\n-                        let mut result = Vec::new();\n-                        result.push_all(before.as_slice());\n-                        result.push_all(after.as_slice());\n-                        Some(result)\n-                    } else {\n-                        None\n-                    }\n-                }\n+            match *constructor {\n+                // Fixed-length vectors.\n+                Single => {\n+                    let mut pats = before.clone();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                },\n+                Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n+                    let mut pats = before.clone();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                },\n+                Slice(length) if before.len() + after.len() == length => {\n+                    let mut pats = before.clone();\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                },\n                 _ => None\n             }\n         }\n \n         &PatMac(_) => {\n-            cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n+            cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n             None\n         }\n     };\n@@ -740,7 +832,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n }\n \n fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n-    let pats = vec!(vec!(pat));\n+    let pats = Matrix(vec!(vec!(pat)));\n     is_useful(cx, &pats, [wild()], ConstructWitness)\n         .useful()\n         .map(|pats| {"}, {"sha": "1e06b3b1fd46393a0434ddd09230667307c76c01", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 97, "deletions": 10, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -19,13 +19,14 @@ use middle::def;\n use middle::freevars;\n use middle::pat_util;\n use middle::ty;\n-use middle::typeck::MethodCall;\n+use middle::typeck::{MethodCall, MethodObject, MethodOrigin, MethodParam};\n+use middle::typeck::{MethodStatic};\n use middle::typeck;\n-use syntax::ast;\n-use syntax::codemap::{Span};\n use util::ppaux::Repr;\n \n use std::gc::Gc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -101,6 +102,74 @@ pub enum MutateMode {\n     WriteAndRead, // x += y\n }\n \n+enum OverloadedCallType {\n+    FnOverloadedCall,\n+    FnMutOverloadedCall,\n+    FnOnceOverloadedCall,\n+}\n+\n+impl OverloadedCallType {\n+    fn from_trait_id(tcx: &ty::ctxt, trait_id: ast::DefId)\n+                     -> OverloadedCallType {\n+        for &(maybe_function_trait, overloaded_call_type) in [\n+            (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n+            (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n+            (tcx.lang_items.fn_trait(), FnOverloadedCall)\n+        ].iter() {\n+            match maybe_function_trait {\n+                Some(function_trait) if function_trait == trait_id => {\n+                    return overloaded_call_type\n+                }\n+                _ => continue,\n+            }\n+        }\n+\n+        tcx.sess.bug(\"overloaded call didn't map to known function trait\")\n+    }\n+\n+    fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n+                      -> OverloadedCallType {\n+        let method_descriptor =\n+            match tcx.methods.borrow_mut().find(&method_id) {\n+                None => {\n+                    tcx.sess.bug(\"overloaded call method wasn't in method \\\n+                                  map\")\n+                }\n+                Some(ref method_descriptor) => (*method_descriptor).clone(),\n+            };\n+        let impl_id = match method_descriptor.container {\n+            ty::TraitContainer(_) => {\n+                tcx.sess.bug(\"statically resolved overloaded call method \\\n+                              belonged to a trait?!\")\n+            }\n+            ty::ImplContainer(impl_id) => impl_id,\n+        };\n+        let trait_ref = match ty::impl_trait_ref(tcx, impl_id) {\n+            None => {\n+                tcx.sess.bug(\"statically resolved overloaded call impl \\\n+                              didn't implement a trait?!\")\n+            }\n+            Some(ref trait_ref) => (*trait_ref).clone(),\n+        };\n+        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n+    }\n+\n+    fn from_method_origin(tcx: &ty::ctxt, origin: &MethodOrigin)\n+                          -> OverloadedCallType {\n+        match *origin {\n+            MethodStatic(def_id) => {\n+                OverloadedCallType::from_method_id(tcx, def_id)\n+            }\n+            MethodParam(ref method_param) => {\n+                OverloadedCallType::from_trait_id(tcx, method_param.trait_id)\n+            }\n+            MethodObject(ref method_object) => {\n+                OverloadedCallType::from_trait_id(tcx, method_object.trait_id)\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The ExprUseVisitor type\n //\n@@ -413,19 +482,37 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             }\n             _ => {\n-                match self.tcx()\n-                          .method_map\n-                          .borrow()\n-                          .find(&MethodCall::expr(call.id)) {\n-                    Some(_) => {\n-                        // FIXME(#14774, pcwalton): Implement this.\n+                let overloaded_call_type =\n+                    match self.tcx()\n+                              .method_map\n+                              .borrow()\n+                              .find(&MethodCall::expr(call.id)) {\n+                    Some(ref method_callee) => {\n+                        OverloadedCallType::from_method_origin(\n+                            self.tcx(),\n+                            &method_callee.origin)\n                     }\n                     None => {\n                         self.tcx().sess.span_bug(\n                             callee.span,\n                             format!(\"unexpected callee type {}\",\n-                                    callee_ty.repr(self.tcx())).as_slice());\n+                                    callee_ty.repr(self.tcx())).as_slice())\n+                    }\n+                };\n+                match overloaded_call_type {\n+                    FnMutOverloadedCall => {\n+                        self.borrow_expr(callee,\n+                                         ty::ReScope(call.id),\n+                                         ty::MutBorrow,\n+                                         ClosureInvocation);\n+                    }\n+                    FnOverloadedCall => {\n+                        self.borrow_expr(callee,\n+                                         ty::ReScope(call.id),\n+                                         ty::ImmBorrow,\n+                                         ClosureInvocation);\n                     }\n+                    FnOnceOverloadedCall => self.consume_expr(callee),\n                 }\n             }\n         }"}, {"sha": "24d97f5aac354212171f61b1110cae7506c0fb96", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -12,9 +12,10 @@ use middle::def::*;\n use middle::resolve;\n \n use std::collections::HashMap;\n+use std::gc::{Gc, GC};\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n \n@@ -111,3 +112,7 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Path> {\n         }\n     }\n }\n+\n+pub fn wild() -> Gc<Pat> {\n+    box (GC) Pat { id: 0, node: PatWild, span: DUMMY_SP }\n+}"}, {"sha": "349a20313fa8c7b6a8edec1a574a3d74cc65cff1", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{Fn, FnMut, FnOnce};\n+\n+struct SFn {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Fn<(int,),int> for SFn {\n+    fn call(&self, (z,): (int,)) -> int {\n+        self.x * self.y * z\n+    }\n+}\n+\n+struct SFnMut {\n+    x: int,\n+    y: int,\n+}\n+\n+impl FnMut<(int,),int> for SFnMut {\n+    fn call_mut(&mut self, (z,): (int,)) -> int {\n+        self.x * self.y * z\n+    }\n+}\n+\n+struct SFnOnce {\n+    x: String,\n+}\n+\n+impl FnOnce<(String,),uint> for SFnOnce {\n+    fn call_once(self, (z,): (String,)) -> uint {\n+        self.x.len() + z.len()\n+    }\n+}\n+\n+fn f() {\n+    let mut s = SFn {\n+        x: 1,\n+        y: 2,\n+    };\n+    let sp = &mut s;\n+    s(3);   //~ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable\n+}\n+\n+fn g() {\n+    let s = SFnMut {\n+        x: 1,\n+        y: 2,\n+    };\n+    s(3);   //~ ERROR cannot borrow immutable local variable `s` as mutable\n+}\n+\n+fn h() {\n+    let s = SFnOnce {\n+        x: \"hello\".to_string(),\n+    };\n+    s(\" world\".to_string());\n+    s(\" world\".to_string());    //~ ERROR use of moved value: `s`\n+}\n+\n+fn main() {}\n+"}, {"sha": "439c82a6df08b19f858cd68de06f24abe731a74d", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,10 +11,19 @@\n enum t { a(u), b }\n enum u { c, d }\n \n+fn match_nested_vecs<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n+    match (l1, l2) { //~ ERROR non-exhaustive patterns: `(Some([]), Err(_))` not covered\n+        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n+        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n+        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\"\n+    }\n+}\n+\n fn main() {\n-  let x = a(c);\n-  match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n-      a(d) => { fail!(\"hello\"); }\n-      b => { fail!(\"goodbye\"); }\n+    let x = a(c);\n+    match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n+        a(d) => { fail!(\"hello\"); }\n+        b => { fail!(\"goodbye\"); }\n     }\n }"}, {"sha": "d2711339ccbd41d10677c9e9b479d6fb074870d4", "filename": "src/test/run-pass/issue-15104.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15104.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert_eq!(count_members(&[1, 2, 3, 4]), 4);\n+}\n+\n+fn count_members(v: &[uint]) -> uint {\n+    match v {\n+        []         => 0,\n+        [_]        => 1,\n+        [_x, ..xs] => 1 + count_members(xs)\n+    }\n+}"}, {"sha": "ffbc4e85cb685762e7bddf39dfb34facb4f1722e", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ac124edda29eabffc2acc3255aca1a0c2680f0/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=c4ac124edda29eabffc2acc3255aca1a0c2680f0", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n+    match (l1, l2) {\n+        ([], []) => \"both empty\",\n+        ([], [..]) | ([..], []) => \"one empty\",\n+        ([..], [..]) => \"both non-empty\"\n+    }\n+}\n+\n+fn match_vecs_cons<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n+    match (l1, l2) {\n+        ([], []) => \"both empty\",\n+        ([], [_, ..]) | ([_, ..], []) => \"one empty\",\n+        ([_, ..], [_, ..]) => \"both non-empty\"\n+    }\n+}\n+\n+fn match_vecs_snoc<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n+    match (l1, l2) {\n+        ([], []) => \"both empty\",\n+        ([], [.., _]) | ([.., _], []) => \"one empty\",\n+        ([.., _], [.., _]) => \"both non-empty\"\n+    }\n+}\n+\n+fn match_nested_vecs_cons<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n+    match (l1, l2) {\n+        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n+        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n+        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\",\n+        _ => \"other\"\n+    }\n+}\n+\n+fn match_nested_vecs_snoc<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n+    match (l1, l2) {\n+        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n+        (Some([.., _]), Ok(_)) | (Some([.., _]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n+        (None, Ok([.., _, _])) => \"None, Ok(at least two elements)\",\n+        _ => \"other\"\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(match_vecs(&[1i, 2], &[2i, 3]), \"both non-empty\");\n+    assert_eq!(match_vecs(&[], &[1i, 2, 3, 4]), \"one empty\");\n+    assert_eq!(match_vecs::<uint>(&[], &[]), \"both empty\");\n+    assert_eq!(match_vecs(&[1i, 2, 3], &[]), \"one empty\");\n+\n+    assert_eq!(match_vecs_cons(&[1i, 2], &[2i, 3]), \"both non-empty\");\n+    assert_eq!(match_vecs_cons(&[], &[1i, 2, 3, 4]), \"one empty\");\n+    assert_eq!(match_vecs_cons::<uint>(&[], &[]), \"both empty\");\n+    assert_eq!(match_vecs_cons(&[1i, 2, 3], &[]), \"one empty\");\n+\n+    assert_eq!(match_vecs_snoc(&[1i, 2], &[2i, 3]), \"both non-empty\");\n+    assert_eq!(match_vecs_snoc(&[], &[1i, 2, 3, 4]), \"one empty\");\n+    assert_eq!(match_vecs_snoc::<uint>(&[], &[]), \"both empty\");\n+    assert_eq!(match_vecs_snoc(&[1i, 2, 3], &[]), \"one empty\");\n+\n+    assert_eq!(match_nested_vecs_cons(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_cons::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n+    assert_eq!(match_nested_vecs_cons::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_cons(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_cons(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+\n+    assert_eq!(match_nested_vecs_snoc(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_snoc::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n+    assert_eq!(match_nested_vecs_snoc::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_snoc(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_snoc(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+}"}]}