{"sha": "b64c7b83dd08c7c3afc643564d65975d57785172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NGM3YjgzZGQwOGM3YzNhZmM2NDM1NjRkNjU5NzVkNTc3ODUxNzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-08T11:59:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-19T10:53:40Z"}, "message": "Refactor QPath to take an ast::TraitRef", "tree": {"sha": "2df9a43cab3b8b88a4f264e92efceeff8694379b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df9a43cab3b8b88a4f264e92efceeff8694379b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b64c7b83dd08c7c3afc643564d65975d57785172", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b64c7b83dd08c7c3afc643564d65975d57785172", "html_url": "https://github.com/rust-lang/rust/commit/b64c7b83dd08c7c3afc643564d65975d57785172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b64c7b83dd08c7c3afc643564d65975d57785172/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf7df1e6382e239619a8447719c3c19787d7b60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7df1e6382e239619a8447719c3c19787d7b60d", "html_url": "https://github.com/rust-lang/rust/commit/cf7df1e6382e239619a8447719c3c19787d7b60d"}], "stats": {"total": 312, "additions": 122, "deletions": 190}, "files": [{"sha": "f369f00a14e304d1d7719aa2ad08ea4af97c1ed9", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 59, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -633,6 +633,7 @@ enum TraitReferenceType {\n     TraitDerivation,                 // trait T : SomeTrait { ... }\n     TraitBoundingTypeParameter,      // fn f<T:SomeTrait>() { ... }\n     TraitObject,                     // Box<for<'a> SomeTrait>\n+    TraitQPath,                      // <T as SomeTrait>::\n }\n \n impl NameBindings {\n@@ -4532,6 +4533,7 @@ impl<'a> Resolver<'a> {\n                     TraitImplementation        => \"implement\",\n                     TraitDerivation            => \"derive\",\n                     TraitObject                => \"reference\",\n+                    TraitQPath                 => \"extract an associated type from\",\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n@@ -4969,65 +4971,8 @@ impl<'a> Resolver<'a> {\n             }\n \n             TyQPath(ref qpath) => {\n-                self.resolve_type(&*qpath.for_type);\n-\n-                let current_module = self.current_module.clone();\n-                let module_path: Vec<_> =\n-                    qpath.trait_name\n-                         .segments\n-                         .iter()\n-                         .map(|ps| ps.identifier.name)\n-                         .collect();\n-                match self.resolve_module_path(\n-                        current_module,\n-                        module_path.as_slice(),\n-                        UseLexicalScope,\n-                        qpath.trait_name.span,\n-                        PathSearch) {\n-                    Success((ref module, _)) if module.kind.get() ==\n-                            TraitModuleKind => {\n-                        match self.resolve_definition_of_name_in_module(\n-                                (*module).clone(),\n-                                qpath.item_name.name,\n-                                TypeNS) {\n-                            ChildNameDefinition(def, lp) |\n-                            ImportNameDefinition(def, lp) => {\n-                                match def {\n-                                    DefAssociatedTy(trait_type_id) => {\n-                                        let def = DefAssociatedTy(\n-                                            trait_type_id);\n-                                        self.record_def(ty.id, (def, lp));\n-                                    }\n-                                    _ => {\n-                                        self.resolve_error(\n-                                            ty.span,\n-                                            \"not an associated type\");\n-                                    }\n-                                }\n-                            }\n-                            NoNameDefinition => {\n-                                self.resolve_error(ty.span,\n-                                                   \"unresolved associated \\\n-                                                    type\");\n-                            }\n-                        }\n-                    }\n-                    Success(..) => self.resolve_error(ty.span, \"not a trait\"),\n-                    Indeterminate => {\n-                        self.session.span_bug(ty.span,\n-                                              \"indeterminate result when \\\n-                                               resolving associated type\")\n-                    }\n-                    Failed(error) => {\n-                        let (span, help) = match error {\n-                            Some((span, msg)) => (span, format!(\"; {}\", msg)),\n-                            None => (ty.span, String::new()),\n-                        };\n-                        self.resolve_error(span,\n-                                           format!(\"unresolved trait: {}\",\n-                                                   help).as_slice())\n-                    }\n-                }\n+                self.resolve_type(&*qpath.self_type);\n+                self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n             }\n \n             TyClosure(ref c) | TyProc(ref c) => {"}, {"sha": "b030867fc841c5fbe6670ef76c2417d2c7e687ca", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -100,6 +100,10 @@ impl<'tcx> Substs<'tcx> {\n         regions_is_noop && self.types.is_empty()\n     }\n \n+    pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+        *self.types.get(ty_param_def.space, ty_param_def.index)\n+    }\n+\n     pub fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n         self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n             match self.regions {"}, {"sha": "d34d413225e808f89a91dee0f4e83a29b12271d4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -25,6 +25,7 @@ use std::rc::Rc;\n use std::slice::Items;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n+use util::common::ErrorReported;\n \n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n@@ -95,10 +96,6 @@ pub enum ObligationCauseCode<'tcx> {\n     FieldSized,\n }\n \n-// An error has already been reported to the user, so no need to continue checking.\n-#[deriving(Clone,Show)]\n-pub struct ErrorReported;\n-\n pub type Obligations<'tcx> = subst::VecPerParamSpace<Obligation<'tcx>>;\n \n pub type Selection<'tcx> = Vtable<'tcx, Obligation<'tcx>>;"}, {"sha": "9cb7023e1b59f777f99f9be3036aaa75b9cfba37", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -17,7 +17,6 @@ use self::Candidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n-use super::{ErrorReported};\n use super::{Obligation, ObligationCause};\n use super::{SelectionError, Unimplemented, Overflow,\n             OutputTypeParameterMismatch};\n@@ -38,6 +37,7 @@ use std::cell::RefCell;\n use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {"}, {"sha": "ec49d5010562b8d966a00e63bca3083794030a78", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -18,9 +18,10 @@ use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n-use super::{ErrorReported, Obligation, ObligationCause, VtableImpl,\n+use super::{Obligation, ObligationCause, VtableImpl,\n             VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "637c1f58157e20c29170d6682f0c27e925f3d3ee", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 90, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -207,7 +207,6 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n-    associated_ty: Option<Ty<'tcx>>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -243,7 +242,7 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     };\n \n     create_substs_for_ast_path(this, rscope, path.span, decl_def_id,\n-                               decl_generics, self_ty, types, regions, associated_ty)\n+                               decl_generics, self_ty, types, regions)\n }\n \n fn create_substs_for_ast_path<'tcx,AC,RS>(\n@@ -254,8 +253,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>,\n-    associated_ty: Option<Ty<'tcx>>)\n+    regions: Vec<ty::Region>)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -366,9 +364,9 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n         substs.types.push(\n             AssocSpace,\n             this.associated_type_binding(span,\n-                                         associated_ty,\n+                                         self_ty,\n                                          decl_def_id,\n-                                         param.def_id))\n+                                         param.def_id));\n     }\n \n     return substs;\n@@ -417,19 +415,17 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<Ty<'tcx>>,\n-    associated_type: Option<Ty<'tcx>>)\n+    self_ty: Option<Ty<'tcx>>)\n     -> Rc<ty::TraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n-    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, associated_type)\n+    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty)\n }\n \n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty<'tcx>>,\n-                                         associated_type: Option<Ty<'tcx>>)\n+                                         self_ty: Option<Ty<'tcx>>)\n                                          -> Rc<ty::TraitRef<'tcx>>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n@@ -444,8 +440,8 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                          ast_trait_ref.path.span,\n                          ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n-            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id, self_ty,\n-                                                          associated_type, &ast_trait_ref.path));\n+            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id,\n+                                                          self_ty, &ast_trait_ref.path));\n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n             trait_ref\n@@ -463,7 +459,6 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n-    associated_type: Option<Ty<'tcx>>,\n     path: &ast::Path)\n     -> ty::TraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -493,8 +488,7 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n-                                            regions,\n-                                            associated_type);\n+                                            regions);\n \n     ty::TraitRef::new(trait_def_id, substs)\n }\n@@ -517,7 +511,6 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                         did,\n                                         &generics,\n                                         None,\n-                                        None,\n                                         path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n@@ -558,7 +551,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs_for_ty(this, rscope, did, &generics, None, None, path)\n+        ast_path_substs_for_ty(this, rscope, did, &generics, None, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -726,7 +719,6 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        rscope,\n                                                        trait_def_id,\n                                                        None,\n-                                                       None,\n                                                        path);\n                     let empty_vec = [];\n                     let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n@@ -750,61 +742,37 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n }\n \n-fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n-                                   rscope: &RS,\n-                                   trait_path: &ast::Path,\n-                                   for_ast_type: &ast::Ty,\n-                                   trait_type_id: ast::DefId,\n-                                   span: Span)\n-                                   -> Ty<'tcx>\n-                                   where AC: AstConv<'tcx>, RS: RegionScope\n+fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n+                           rscope: &RS,\n+                           ast_ty: &ast::Ty, // the TyQPath\n+                           qpath: &ast::QPath)\n+                           -> Ty<'tcx>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n-    debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n-           trait_path.repr(this.tcx()),\n-           for_ast_type.repr(this.tcx()),\n-           trait_type_id.repr(this.tcx()));\n-\n-    // Find the trait that this associated type belongs to.\n-    let trait_did = match ty::impl_or_trait_item(this.tcx(),\n-                                                 trait_type_id).container() {\n-        ty::ImplContainer(_) => {\n-            this.tcx().sess.span_bug(span,\n-                                     \"associated_ty_to_ty(): impl associated \\\n-                                      types shouldn't go through this \\\n-                                      function\")\n-        }\n-        ty::TraitContainer(trait_id) => trait_id,\n-    };\n+    debug!(\"qpath_to_ty(ast_ty={})\",\n+           ast_ty.repr(this.tcx()));\n \n-    let for_type = ast_ty_to_ty(this, rscope, for_ast_type);\n-    if !this.associated_types_of_trait_are_valid(for_type, trait_did) {\n-        this.tcx().sess.span_err(span,\n-                                 \"this associated type is not \\\n-                                  allowed in this context\");\n-        return ty::mk_err()\n-    }\n+    let self_type = ast_ty_to_ty(this, rscope, &*qpath.self_type);\n+\n+    debug!(\"qpath_to_ty: self_type={}\", self_type.repr(this.tcx()));\n \n-    let trait_ref = ast_path_to_trait_ref(this,\n+    let trait_ref = instantiate_trait_ref(this,\n                                           rscope,\n-                                          trait_did,\n-                                          None,\n-                                          Some(for_type),\n-                                          trait_path);\n-\n-    debug!(\"associated_ty_to_ty(trait_ref={})\",\n-           trait_ref.repr(this.tcx()));\n-\n-    let trait_def = this.get_trait_def(trait_did);\n-    for type_parameter in trait_def.generics.types.iter() {\n-        if type_parameter.def_id == trait_type_id {\n-            debug!(\"associated_ty_to_ty(type_parameter={} substs={})\",\n-                   type_parameter.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()));\n-            return *trait_ref.substs.types.get(type_parameter.space,\n-                                               type_parameter.index)\n+                                          &*qpath.trait_ref,\n+                                          Some(self_type));\n+\n+    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n+\n+    let trait_def = this.get_trait_def(trait_ref.def_id);\n+\n+    for ty_param_def in trait_def.generics.types.get_slice(AssocSpace).iter() {\n+        if ty_param_def.name == qpath.item_name.name {\n+            debug!(\"qpath_to_ty: corresponding ty_param_def={}\", ty_param_def);\n+            return trait_ref.substs.type_for_def(ty_param_def);\n         }\n     }\n-    this.tcx().sess.span_bug(span,\n+\n+    this.tcx().sess.span_bug(ast_ty.span,\n                              \"this associated type didn't get added \\\n                               as a parameter for some reason\")\n }\n@@ -931,7 +899,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            rscope,\n                                                            trait_def_id,\n                                                            None,\n-                                                           None,\n                                                            path);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n@@ -996,26 +963,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 }\n             }\n             ast::TyQPath(ref qpath) => {\n-                match tcx.def_map.borrow().get(&ast_ty.id) {\n-                    None => {\n-                        tcx.sess.span_bug(ast_ty.span,\n-                                          \"unbound qualified path\")\n-                    }\n-                    Some(&def::DefAssociatedTy(trait_type_id)) => {\n-                        associated_ty_to_ty(this,\n-                                            rscope,\n-                                            &qpath.trait_name,\n-                                            &*qpath.for_type,\n-                                            trait_type_id,\n-                                            ast_ty.span)\n-                    }\n-                    Some(_) => {\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          \"this qualified path does not name \\\n-                                           an associated type\");\n-                        ty::mk_err()\n-                    }\n-                }\n+                qpath_to_ty(this, rscope, ast_ty, &**qpath)\n             }\n             ast::TyFixedLengthVec(ref ty, ref e) => {\n                 match const_eval::eval_const_expr_partial(tcx, &**e) {\n@@ -1411,7 +1359,7 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None, None))\n+            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None))\n         }\n         None => {\n             this.tcx().sess.span_err("}, {"sha": "90ad0d2f3e5e223d3537e2cc7a2eba022d92e830", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -684,7 +684,11 @@ fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                           ty: Option<Ty<'tcx>>,\n                                           associated_type_id: ast::DefId,\n                                           generics: &ty::Generics<'tcx>)\n-                                          -> Ty<'tcx> {\n+                                          -> Ty<'tcx>\n+{\n+    debug!(\"find_associated_type_in_generics(ty={}, associated_type_id={}, generics={}\",\n+           ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n+\n     let ty = match ty {\n         None => {\n             tcx.sess.span_bug(span,\n@@ -703,20 +707,22 @@ fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n             for type_parameter in generics.types.iter() {\n                 if type_parameter.def_id == associated_type_id\n                     && type_parameter.associated_with == Some(param_id) {\n-                    return ty::mk_param_from_def(tcx, type_parameter)\n+                    return ty::mk_param_from_def(tcx, type_parameter);\n                 }\n             }\n \n-            tcx.sess.span_bug(span,\n-                              \"find_associated_type_in_generics(): didn't \\\n-                               find associated type anywhere in the generics \\\n-                               list\")\n+            tcx.sess.span_err(\n+                span,\n+                format!(\"no suitable bound on `{}`\",\n+                        ty.user_string(tcx))[]);\n+            ty::mk_err()\n         }\n         _ => {\n-            tcx.sess.span_bug(span,\n-                              \"find_associated_type_in_generics(): self type \\\n-                               is not a parameter\")\n-\n+            tcx.sess.span_err(\n+                span,\n+                \"it is currently unsupported to access associated types except \\\n+                 through a type parameter; this restriction will be lifted in time\");\n+            ty::mk_err()\n         }\n     }\n }\n@@ -1155,7 +1161,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             for trait_ref in opt_trait_ref.iter() {\n                 astconv::instantiate_trait_ref(&icx, &ExplicitRscope, trait_ref,\n-                                               Some(selfty), None);\n+                                               Some(selfty));\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1627,7 +1633,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ccx,\n                         subst::AssocSpace,\n                         &associated_type.ty_param,\n-                        generics.types.len(subst::TypeSpace),\n+                        generics.types.len(subst::AssocSpace),\n                         &ast_generics.where_clause,\n                         Some(local_def(trait_id)));\n                 ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n@@ -2019,7 +2025,6 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n             astconv::instantiate_poly_trait_ref(this,\n                                                 &ExplicitRscope,\n                                                 bound,\n-                                                Some(param_ty.to_ty(this.tcx())),\n                                                 Some(param_ty.to_ty(this.tcx())))\n         })\n         .collect();"}, {"sha": "cdbe107e11c9576fdd1f02ae540ccceabb9d6e97", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -20,6 +20,10 @@ use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// An error has already been reported to the user, so no need to continue checking.\n+#[deriving(Clone,Show)]\n+pub struct ErrorReported;\n+\n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     local_data_key!(depth: uint);\n     if !do_it { return f(u); }"}, {"sha": "61e56f0cc42e4f1e172f4094fa43564e3adcaf80", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -706,11 +706,11 @@ pub enum Expr_ {\n ///\n ///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n ///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n-///      for_type  trait_name  item_name\n+///      self_type  trait_name  item_name\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct QPath {\n-    pub for_type: P<Ty>,\n-    pub trait_name: Path,\n+    pub self_type: P<Ty>,\n+    pub trait_ref: P<TraitRef>,\n     pub item_name: Ident,\n }\n "}, {"sha": "2e6ee49f0ff72200c2ce9d239831274cbda5f661", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -142,6 +142,10 @@ pub trait Folder {\n         noop_fold_ty(t, self)\n     }\n \n+    fn fold_qpath(&mut self, t: P<QPath>) -> P<QPath> {\n+        noop_fold_qpath(t, self)\n+    }\n+\n     fn fold_mod(&mut self, m: Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n@@ -435,12 +439,8 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                         fld.fold_opt_bounds(bounds),\n                         id)\n             }\n-            TyQPath(ref qpath) => {\n-                TyQPath(P(QPath {\n-                    for_type: fld.fold_ty(qpath.for_type.clone()),\n-                    trait_name: fld.fold_path(qpath.trait_name.clone()),\n-                    item_name: fld.fold_ident(qpath.item_name.clone()),\n-                }))\n+            TyQPath(qpath) => {\n+                TyQPath(fld.fold_qpath(qpath))\n             }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n@@ -456,6 +456,16 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     })\n }\n \n+pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n+    qpath.map(|qpath| {\n+        QPath {\n+            self_type: fld.fold_ty(qpath.self_type),\n+            trait_ref: qpath.trait_ref.map(|tr| fld.fold_trait_ref(tr)),\n+            item_name: fld.fold_ident(qpath.item_name),\n+        }\n+    })\n+}\n+\n pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {"}, {"sha": "d3ae9838c6d147c1f890092baf9ce1262704b283", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -1502,17 +1502,17 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type(Vec::new())\n         } else if self.token == token::Lt {\n-            // QUALIFIED PATH\n+            // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             self.bump();\n-            let for_type = self.parse_ty(true);\n+            let self_type = self.parse_ty(true);\n             self.expect_keyword(keywords::As);\n-            let trait_name = self.parse_path(LifetimeAndTypesWithoutColons);\n+            let trait_ref = self.parse_trait_ref();\n             self.expect(&token::Gt);\n             self.expect(&token::ModSep);\n             let item_name = self.parse_ident();\n             TyQPath(P(QPath {\n-                for_type: for_type,\n-                trait_name: trait_name.path,\n+                self_type: self_type,\n+                trait_ref: P(trait_ref),\n                 item_name: item_name,\n             }))\n         } else if self.token == token::ModSep ||"}, {"sha": "fa6b70389b4c873f3b62f2b0884c3d5a5e2d8294", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -744,10 +744,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n-                try!(self.print_type(&*qpath.for_type));\n+                try!(self.print_type(&*qpath.self_type));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_path(&qpath.trait_name, false));\n+                try!(self.print_trait_ref(&*qpath.trait_ref));\n                 try!(word(&mut self.s, \">\"));\n                 try!(word(&mut self.s, \"::\"));\n                 try!(self.print_ident(qpath.item_name));"}, {"sha": "bbbec5e0626c5965d238d4464093f3da445d5fbf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -403,8 +403,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n         }\n         TyQPath(ref qpath) => {\n-            visitor.visit_ty(&*qpath.for_type);\n-            visitor.visit_path(&qpath.trait_name, typ.id);\n+            visitor.visit_ty(&*qpath.self_type);\n+            visitor.visit_trait_ref(&*qpath.trait_ref);\n             visitor.visit_ident(typ.span, qpath.item_name);\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {"}, {"sha": "24de1fa2f78444ecc6b40426dcf355fab96f8669", "filename": "src/test/compile-fail/associated-types-in-ambiguous-context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -20,12 +20,12 @@ fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n \n trait Other {\n     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-    //~^ ERROR this associated type is not allowed in this context\n+    //~^ ERROR no suitable bound on `Self`\n }\n \n impl<T:Get> Other for T {\n     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-    //~^ ERROR this associated type is not allowed in this context\n+    //~^ ERROR currently unsupported\n }\n \n trait Grab {"}, {"sha": "8cab2759ad55a319c34aa258e27bfd11e109c279", "filename": "src/test/compile-fail/associated-types-in-wrong-context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -16,15 +16,15 @@ trait Get {\n }\n \n fn get(x: int) -> <int as Get>::Value {}\n-//~^ ERROR this associated type is not allowed in this context\n+//~^ ERROR unsupported\n \n struct Struct {\n     x: int,\n }\n \n impl Struct {\n     fn uhoh<T>(foo: <T as Get>::Value) {}\n-    //~^ ERROR this associated type is not allowed in this context\n+    //~^ ERROR no suitable bound on `T`\n }\n \n fn main() {"}, {"sha": "1b4eb2604a82bf4251ccfc5213b6af0c4ef04266", "filename": "src/test/run-pass/associated-types-qualified-path-with-trait-with-type-parameters.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Ftest%2Frun-pass%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c7b83dd08c7c3afc643564d65975d57785172/src%2Ftest%2Frun-pass%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs?ref=b64c7b83dd08c7c3afc643564d65975d57785172", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Foo<T> {\n+    type Bar;\n+    fn get_bar() -> <Self as Foo<T>>::Bar;\n+}\n+\n+fn main() { }"}]}