{"sha": "585f0e928b0e88e6da8d7203ef5d077147569ce0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NWYwZTkyOGIwZTg4ZTZkYThkNzIwM2VmNWQwNzcxNDc1NjljZTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-08-03T22:17:56Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-08-03T22:17:56Z"}, "message": "rustc_lint: handle more method calls in unconditional_recursion.", "tree": {"sha": "33541aa636e67d05149420a29f83315af1a64a24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33541aa636e67d05149420a29f83315af1a64a24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/585f0e928b0e88e6da8d7203ef5d077147569ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/585f0e928b0e88e6da8d7203ef5d077147569ce0", "html_url": "https://github.com/rust-lang/rust/commit/585f0e928b0e88e6da8d7203ef5d077147569ce0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/585f0e928b0e88e6da8d7203ef5d077147569ce0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a34b0a4691ce08a1ae843bc0d33577fd22f48a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/a34b0a4691ce08a1ae843bc0d33577fd22f48a64", "html_url": "https://github.com/rust-lang/rust/commit/a34b0a4691ce08a1ae843bc0d33577fd22f48a64"}], "stats": {"total": 134, "additions": 119, "deletions": 15}, "files": [{"sha": "ffd09326abc35aba550c6c1f57608e11d03837ce", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/585f0e928b0e88e6da8d7203ef5d077147569ce0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585f0e928b0e88e6da8d7203ef5d077147569ce0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=585f0e928b0e88e6da8d7203ef5d077147569ce0", "patch": "@@ -33,7 +33,6 @@\n \n use metadata::{csearch, decoder};\n use middle::{cfg, def, infer, pat_util, stability, traits};\n-use middle::def::*;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n@@ -2251,34 +2250,73 @@ impl LintPass for UnconditionalRecursion {\n             }\n         }\n \n-        // Check if the method call `id` refers to method `method`.\n+        // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method(tcx: &ty::ctxt,\n                                       method: &ty::Method,\n                                       id: ast::NodeId) -> bool {\n-            let method_call = ty::MethodCall::expr(id);\n-            let callee = match tcx.tables.borrow().method_map.get(&method_call) {\n-                Some(&m) => m,\n-                None => return false\n-            };\n-            let callee_item = tcx.impl_or_trait_item(callee.def_id);\n+            let tables = tcx.tables.borrow();\n+\n+            // Check for method calls and overloaded operators.\n+            if let Some(m) = tables.method_map.get(&ty::MethodCall::expr(id)) {\n+                if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                    return true;\n+                }\n+            }\n+\n+            // Check for overloaded autoderef method calls.\n+            if let Some(&ty::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n+                for i in 0..adj.autoderefs {\n+                    let method_call = ty::MethodCall::autoderef(id, i as u32);\n+                    if let Some(m) = tables.method_map.get(&method_call) {\n+                        if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check for calls to methods via explicit paths (e.g. `T::method()`).\n+            match tcx.map.get(id) {\n+                ast_map::NodeExpr(&ast::Expr { node: ast::ExprCall(ref callee, _), .. }) => {\n+                    match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n+                        Some(def::DefMethod(def_id)) => {\n+                            let no_substs = &ty::ItemSubsts::empty();\n+                            let ts = tables.item_substs.get(&callee.id).unwrap_or(no_substs);\n+                            method_call_refers_to_method(tcx, method, def_id, &ts.substs, id)\n+                        }\n+                        _ => false\n+                    }\n+                }\n+                _ => false\n+            }\n+        }\n+\n+        // Check if the method call to the method with the ID `callee_id`\n+        // and instantiated with `callee_substs` refers to method `method`.\n+        fn method_call_refers_to_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                              method: &ty::Method,\n+                                              callee_id: ast::DefId,\n+                                              callee_substs: &Substs<'tcx>,\n+                                              expr_id: ast::NodeId) -> bool {\n+            let callee_item = tcx.impl_or_trait_item(callee_id);\n \n             match callee_item.container() {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n                 ty::ImplContainer(_) => {\n-                    callee.def_id == method.def_id\n+                    callee_id == method.def_id\n                 }\n \n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n                 ty::TraitContainer(trait_def_id) => {\n-                    let trait_substs = callee.substs.clone().method_to_trait();\n+                    let trait_substs = callee_substs.clone().method_to_trait();\n                     let trait_substs = tcx.mk_substs(trait_substs);\n                     let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n-                    let span = tcx.map.span(id);\n+                    let span = tcx.map.span(expr_id);\n                     let obligation =\n-                        traits::Obligation::new(traits::ObligationCause::misc(span, id),\n+                        traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, method.def_id.node);\n@@ -2289,12 +2327,12 @@ impl LintPass for UnconditionalRecursion {\n                         // If `T` is `Self`, then this call is inside\n                         // a default method definition.\n                         Ok(Some(traits::VtableParam(_))) => {\n-                            let self_ty = callee.substs.self_ty();\n+                            let self_ty = callee_substs.self_ty();\n                             let on_self = self_ty.map_or(false, |t| t.is_self());\n                             // We can only be recurring in a default\n                             // method if we're being called literally\n                             // on the `Self` type.\n-                            on_self && callee.def_id == method.def_id\n+                            on_self && callee_id == method.def_id\n                         }\n \n                         // The `impl` is known, so we check that with a\n@@ -2454,7 +2492,7 @@ impl LintPass for MutableTransmutes {\n                 ast::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n+            if let def::DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "6e3a00746f3e6107bcd3654e5f41a57fdc57bef4", "filename": "src/test/compile-fail/lint-unconditional-recursion.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/585f0e928b0e88e6da8d7203ef5d077147569ce0/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585f0e928b0e88e6da8d7203ef5d077147569ce0/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs?ref=585f0e928b0e88e6da8d7203ef5d077147569ce0", "patch": "@@ -41,6 +41,7 @@ fn quz() -> bool { //~ ERROR function cannot return without recurring\n     }\n }\n \n+// Trait method calls.\n trait Foo {\n     fn bar(&self) { //~ ERROR function cannot return without recurring\n         self.bar() //~ NOTE recursive call site\n@@ -53,14 +54,79 @@ impl Foo for Box<Foo+'static> {\n             self.bar() //~ NOTE recursive call site\n         }\n     }\n+}\n+\n+// Trait method call with integer fallback after method resolution.\n+impl Foo for i32 {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        0.bar() //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo for u32 {\n+    fn bar(&self) {\n+        0.bar()\n+    }\n+}\n \n+// Trait method calls via paths.\n+trait Foo2 {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        Foo2::bar(self) //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo2 for Box<Foo2+'static> {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        loop {\n+            Foo2::bar(self) //~ NOTE recursive call site\n+        }\n+    }\n }\n \n struct Baz;\n impl Baz {\n+    // Inherent method call.\n     fn qux(&self) { //~ ERROR function cannot return without recurring\n         self.qux(); //~ NOTE recursive call site\n     }\n+\n+    // Inherent method call via path.\n+    fn as_ref(&self) -> &Self { //~ ERROR function cannot return without recurring\n+        Baz::as_ref(self) //~ NOTE recursive call site\n+    }\n+}\n+\n+// Trait method calls to impls via paths.\n+impl Default for Baz {\n+    fn default() -> Baz { //~ ERROR function cannot return without recurring\n+        let x = Default::default(); //~ NOTE recursive call site\n+        x\n+    }\n+}\n+\n+// Overloaded operators.\n+impl std::ops::Deref for Baz {\n+    type Target = ();\n+    fn deref(&self) -> &() { //~ ERROR function cannot return without recurring\n+        &**self //~ NOTE recursive call site\n+    }\n+}\n+\n+impl std::ops::Index<usize> for Baz {\n+    type Output = Baz;\n+    fn index(&self, x: usize) -> &Baz { //~ ERROR function cannot return without recurring\n+        &self[x] //~ NOTE recursive call site\n+    }\n+}\n+\n+// Overloaded autoderef.\n+struct Quux;\n+impl std::ops::Deref for Quux {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { //~ ERROR function cannot return without recurring\n+        self.as_ref() //~ NOTE recursive call site\n+    }\n }\n \n fn all_fine() {"}]}