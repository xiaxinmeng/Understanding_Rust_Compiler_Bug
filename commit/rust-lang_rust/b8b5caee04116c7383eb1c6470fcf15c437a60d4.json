{"sha": "b8b5caee04116c7383eb1c6470fcf15c437a60d4", "node_id": "C_kwDOAAsO6NoAKGI4YjVjYWVlMDQxMTZjNzM4M2ViMWM2NDcwZmNmMTVjNDM3YTYwZDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T20:34:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T20:34:38Z"}, "message": "Auto merge of #102026 - Bryanskiy:resolve_update, r=petrochenkov\n\nPopulate effective visibilities in 'rustc_resolve'\n\nNext part of RFC https://github.com/rust-lang/rust/issues/48054.\nprevious: https://github.com/rust-lang/rust/pull/101713\n\n`@rustbot` author\nr? `@petrochenkov`", "tree": {"sha": "7e8d5009eeef6799f29e49f9caee86d83121f7fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e8d5009eeef6799f29e49f9caee86d83121f7fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b5caee04116c7383eb1c6470fcf15c437a60d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b5caee04116c7383eb1c6470fcf15c437a60d4", "html_url": "https://github.com/rust-lang/rust/commit/b8b5caee04116c7383eb1c6470fcf15c437a60d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b5caee04116c7383eb1c6470fcf15c437a60d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf286a82e236e065c67909657e3a35d1511d1864", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf286a82e236e065c67909657e3a35d1511d1864", "html_url": "https://github.com/rust-lang/rust/commit/bf286a82e236e065c67909657e3a35d1511d1864"}, {"sha": "496ccd982ce155d8f4026eb69c6af1a2b6b5628a", "url": "https://api.github.com/repos/rust-lang/rust/commits/496ccd982ce155d8f4026eb69c6af1a2b6b5628a", "html_url": "https://github.com/rust-lang/rust/commit/496ccd982ce155d8f4026eb69c6af1a2b6b5628a"}], "stats": {"total": 403, "additions": 240, "deletions": 163}, "files": [{"sha": "556bd24d00f92cb50b7021af35668d9a3eae29db", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 104, "deletions": 32, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -1,12 +1,12 @@\n //! A pass that checks to make sure private fields and methods aren't used\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n-use crate::ty::Visibility;\n+use crate::ty::{DefIdTree, Visibility};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::def_id::LocalDefId;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use std::hash::Hash;\n \n /// Represents the levels of accessibility an item can have.\n@@ -27,26 +27,36 @@ pub enum AccessLevel {\n     Public,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable, Default)]\n+impl AccessLevel {\n+    pub fn all_levels() -> [AccessLevel; 4] {\n+        [\n+            AccessLevel::Public,\n+            AccessLevel::Exported,\n+            AccessLevel::Reachable,\n+            AccessLevel::ReachableFromImplTrait,\n+        ]\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub struct EffectiveVisibility {\n-    public: Option<Visibility>,\n-    exported: Option<Visibility>,\n-    reachable: Option<Visibility>,\n-    reachable_from_impl_trait: Option<Visibility>,\n+    public: Visibility,\n+    exported: Visibility,\n+    reachable: Visibility,\n+    reachable_from_impl_trait: Visibility,\n }\n \n impl EffectiveVisibility {\n-    pub fn get(&self, tag: AccessLevel) -> Option<&Visibility> {\n+    pub fn get(&self, tag: AccessLevel) -> &Visibility {\n         match tag {\n             AccessLevel::Public => &self.public,\n             AccessLevel::Exported => &self.exported,\n             AccessLevel::Reachable => &self.reachable,\n             AccessLevel::ReachableFromImplTrait => &self.reachable_from_impl_trait,\n         }\n-        .as_ref()\n     }\n \n-    fn get_mut(&mut self, tag: AccessLevel) -> &mut Option<Visibility> {\n+    fn get_mut(&mut self, tag: AccessLevel) -> &mut Visibility {\n         match tag {\n             AccessLevel::Public => &mut self.public,\n             AccessLevel::Exported => &mut self.exported,\n@@ -56,7 +66,30 @@ impl EffectiveVisibility {\n     }\n \n     pub fn is_public_at_level(&self, tag: AccessLevel) -> bool {\n-        self.get(tag).map_or(false, |vis| vis.is_public())\n+        self.get(tag).is_public()\n+    }\n+\n+    fn update(&mut self, vis: Visibility, tag: AccessLevel, tree: impl DefIdTree) -> bool {\n+        let mut changed = false;\n+        for level in AccessLevel::all_levels() {\n+            if level <= tag {\n+                let current_effective_vis = self.get_mut(level);\n+                if *current_effective_vis != vis && vis.is_at_least(*current_effective_vis, tree) {\n+                    changed = true;\n+                    *current_effective_vis = vis;\n+                }\n+            }\n+        }\n+        changed\n+    }\n+\n+    fn from_vis(vis: Visibility) -> EffectiveVisibility {\n+        EffectiveVisibility {\n+            public: vis,\n+            exported: vis,\n+            reachable: vis,\n+            reachable_from_impl_trait: vis,\n+        }\n     }\n }\n \n@@ -89,12 +122,7 @@ impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n \n     pub fn get_access_level(&self, id: Id) -> Option<AccessLevel> {\n         self.get_effective_vis(id).and_then(|effective_vis| {\n-            for level in [\n-                AccessLevel::Public,\n-                AccessLevel::Exported,\n-                AccessLevel::Reachable,\n-                AccessLevel::ReachableFromImplTrait,\n-            ] {\n+            for level in AccessLevel::all_levels() {\n                 if effective_vis.is_public_at_level(level) {\n                     return Some(level);\n                 }\n@@ -103,21 +131,6 @@ impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n         })\n     }\n \n-    pub fn set_access_level(&mut self, id: Id, tag: AccessLevel) {\n-        let mut effective_vis = self.get_effective_vis(id).copied().unwrap_or_default();\n-        for level in [\n-            AccessLevel::Public,\n-            AccessLevel::Exported,\n-            AccessLevel::Reachable,\n-            AccessLevel::ReachableFromImplTrait,\n-        ] {\n-            if level <= tag {\n-                *effective_vis.get_mut(level) = Some(Visibility::Public);\n-            }\n-        }\n-        self.map.insert(id, effective_vis);\n-    }\n-\n     pub fn get_effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }\n@@ -129,6 +142,65 @@ impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n     pub fn map_id<OutId: Hash + Eq + Copy>(&self, f: impl Fn(Id) -> OutId) -> AccessLevels<OutId> {\n         AccessLevels { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n     }\n+\n+    pub fn set_access_level(\n+        &mut self,\n+        id: Id,\n+        default_vis: impl FnOnce() -> Visibility,\n+        tag: AccessLevel,\n+    ) {\n+        let mut effective_vis = self\n+            .get_effective_vis(id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n+        for level in AccessLevel::all_levels() {\n+            if level <= tag {\n+                *effective_vis.get_mut(level) = Visibility::Public;\n+            }\n+        }\n+        self.map.insert(id, effective_vis);\n+    }\n+}\n+\n+impl<Id: Hash + Eq + Copy + Into<DefId>> AccessLevels<Id> {\n+    // `parent_id` is not necessarily a parent in source code tree,\n+    // it is the node from which the maximum effective visibility is inherited.\n+    pub fn update(\n+        &mut self,\n+        id: Id,\n+        nominal_vis: Visibility,\n+        default_vis: impl FnOnce() -> Visibility,\n+        parent_id: Id,\n+        tag: AccessLevel,\n+        tree: impl DefIdTree,\n+    ) -> Result<bool, ()> {\n+        let mut changed = false;\n+        let mut current_effective_vis = self\n+            .get_effective_vis(id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n+        if let Some(inherited_effective_vis) = self.get_effective_vis(parent_id) {\n+            for level in AccessLevel::all_levels() {\n+                if tag >= level {\n+                    let inherited_effective_vis_at_level = *inherited_effective_vis.get(level);\n+                    let calculated_effective_vis =\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n+                            inherited_effective_vis_at_level\n+                        } else {\n+                            nominal_vis\n+                        };\n+                    changed |= current_effective_vis.update(calculated_effective_vis, level, tree);\n+                }\n+            }\n+        } else {\n+            if !id.into().is_crate_root() {\n+                return Err(());\n+            }\n+            changed |= current_effective_vis.update(Visibility::Public, AccessLevel::Public, tree);\n+        }\n+        self.map.insert(id, current_effective_vis);\n+        Ok(changed)\n+    }\n }\n \n impl<Id> Default for AccessLevels<Id> {"}, {"sha": "b36b893c78ef746176eb144472779fa59c5f6195", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -444,7 +444,11 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         let old_level = self.get(def_id);\n         // Accessibility levels can only grow.\n         if level > old_level {\n-            self.access_levels.set_access_level(def_id, level.unwrap());\n+            self.access_levels.set_access_level(\n+                def_id,\n+                || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n+                level.unwrap(),\n+            );\n             self.changed = true;\n             level\n         } else {\n@@ -932,31 +936,30 @@ pub struct TestReachabilityVisitor<'tcx, 'a> {\n \n impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n     fn access_level_diagnostic(&mut self, def_id: LocalDefId) {\n-        let span = self.tcx.def_span(def_id.to_def_id());\n         if self.tcx.has_attr(def_id.to_def_id(), sym::rustc_effective_visibility) {\n-            let mut error_msg = String::new();\n-\n-            let effective_vis =\n-                self.access_levels.get_effective_vis(def_id).copied().unwrap_or_default();\n-            for level in [\n-                AccessLevel::Public,\n-                AccessLevel::Exported,\n-                AccessLevel::Reachable,\n-                AccessLevel::ReachableFromImplTrait,\n-            ] {\n-                let vis_str = match effective_vis.get(level) {\n-                    Some(ty::Visibility::Restricted(restricted_id)) => {\n-                        format!(\"pub({})\", self.tcx.item_name(restricted_id.to_def_id()))\n+            if let Some(effective_vis) = self.access_levels.get_effective_vis(def_id) {\n+                let mut error_msg = String::new();\n+                let span = self.tcx.def_span(def_id.to_def_id());\n+                for level in AccessLevel::all_levels() {\n+                    let vis_str = match effective_vis.get(level) {\n+                        ty::Visibility::Restricted(restricted_id) => {\n+                            if restricted_id.is_top_level_module() {\n+                                \"pub(crate)\".to_string()\n+                            } else if *restricted_id == self.tcx.parent_module_from_def_id(def_id) {\n+                                \"pub(self)\".to_string()\n+                            } else {\n+                                format!(\"pub({})\", self.tcx.item_name(restricted_id.to_def_id()))\n+                            }\n+                        }\n+                        ty::Visibility::Public => \"pub\".to_string(),\n+                    };\n+                    if level != AccessLevel::Public {\n+                        error_msg.push_str(\", \");\n                     }\n-                    Some(ty::Visibility::Public) => \"pub\".to_string(),\n-                    None => \"pub(self)\".to_string(),\n-                };\n-                if level != AccessLevel::Public {\n-                    error_msg.push_str(\", \");\n+                    error_msg.push_str(&format!(\"{:?}: {}\", level, vis_str));\n                 }\n-                error_msg.push_str(&format!(\"{:?}: {}\", level, vis_str));\n+                self.tcx.sess.emit_err(ReportEffectiveVisibility { span, descr: error_msg });\n             }\n-            self.tcx.sess.emit_err(ReportEffectiveVisibility { span, descr: error_msg });\n         }\n     }\n }"}, {"sha": "1cef60949d81249927a4026353d212971a181ee3", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -1,17 +1,14 @@\n-use crate::NameBinding;\n use crate::NameBindingKind;\n use crate::Resolver;\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n-use rustc_ast::NodeId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n-use rustc_middle::ty::DefIdTree;\n-use rustc_span::sym;\n+use rustc_middle::ty::{DefIdTree, Visibility};\n \n pub struct AccessLevelsVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n@@ -25,7 +22,7 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n     pub fn compute_access_levels<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n         let mut visitor = AccessLevelsVisitor { r, changed: false };\n \n-        visitor.set_access_level_def_id(CRATE_DEF_ID, Some(AccessLevel::Public));\n+        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, AccessLevel::Public);\n         visitor.set_bindings_access_level(CRATE_DEF_ID);\n \n         while visitor.changed {\n@@ -45,67 +42,72 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n     /// This will also follow `use` chains (see PrivacyVisitor::set_import_binding_access_level).\n     fn set_bindings_access_level(&mut self, module_id: LocalDefId) {\n         assert!(self.r.module_map.contains_key(&&module_id.to_def_id()));\n-        let module_level = self.r.access_levels.get_access_level(module_id);\n-        if !module_level.is_some() {\n-            return;\n-        }\n-        // Set the given binding access level to `AccessLevel::Public` and\n-        // sets the rest of the `use` chain to `AccessLevel::Exported` until\n-        // we hit the actual exported item.\n-        let set_import_binding_access_level =\n-            |this: &mut Self, mut binding: &NameBinding<'a>, mut access_level, ns| {\n-                while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n-                    binding.kind\n-                {\n-                    this.set_access_level(this.r.import_id_for_ns(import, ns), access_level);\n-\n-                    access_level = Some(AccessLevel::Exported);\n-                    binding = nested_binding;\n-                }\n-            };\n-\n         let module = self.r.get_module(module_id.to_def_id()).unwrap();\n         let resolutions = self.r.resolutions(module);\n \n         for (key, name_resolution) in resolutions.borrow().iter() {\n-            if let Some(binding) = name_resolution.borrow().binding() && binding.vis.is_public() && !binding.is_ambiguity() {\n-                let access_level = match binding.is_import() {\n-                    true => {\n-                        set_import_binding_access_level(self, binding, module_level, key.ns);\n-                        Some(AccessLevel::Exported)\n-                    },\n-                    false => module_level,\n-                };\n+            if let Some(mut binding) = name_resolution.borrow().binding() && !binding.is_ambiguity() {\n+                // Set the given binding access level to `AccessLevel::Public` and\n+                // sets the rest of the `use` chain to `AccessLevel::Exported` until\n+                // we hit the actual exported item.\n+\n+                // FIXME: tag and is_public() condition must be deleted,\n+                // but assertion fail occurs in import_id_for_ns\n+                let tag = if binding.is_import() { AccessLevel::Exported } else { AccessLevel::Public };\n+                if binding.vis.is_public() {\n+                    let mut prev_parent_id = module_id;\n+                    let mut level = AccessLevel::Public;\n+                    while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n+                        binding.kind\n+                    {\n+                        let id = self.r.local_def_id(self.r.import_id_for_ns(import, key.ns));\n+                        self.update(\n+                            id,\n+                            binding.vis.expect_local(),\n+                            prev_parent_id,\n+                            level,\n+                        );\n+\n+                        level = AccessLevel::Exported;\n+                        prev_parent_id = id;\n+                        binding = nested_binding;\n+                    }\n+                }\n+\n                 if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                    self.set_access_level_def_id(def_id, access_level);\n+                    self.update(def_id, binding.vis.expect_local(), module_id, tag);\n                 }\n             }\n         }\n     }\n \n-    /// Sets the access level of the `LocalDefId` corresponding to the given `NodeId`.\n-    /// This function will panic if the `NodeId` does not have a `LocalDefId`\n-    fn set_access_level(\n-        &mut self,\n-        node_id: NodeId,\n-        access_level: Option<AccessLevel>,\n-    ) -> Option<AccessLevel> {\n-        self.set_access_level_def_id(self.r.local_def_id(node_id), access_level)\n-    }\n-\n-    fn set_access_level_def_id(\n+    fn update(\n         &mut self,\n         def_id: LocalDefId,\n-        access_level: Option<AccessLevel>,\n-    ) -> Option<AccessLevel> {\n-        let old_level = self.r.access_levels.get_access_level(def_id);\n-        if old_level < access_level {\n-            self.r.access_levels.set_access_level(def_id, access_level.unwrap());\n-            self.changed = true;\n-            access_level\n+        nominal_vis: Visibility,\n+        parent_id: LocalDefId,\n+        tag: AccessLevel,\n+    ) {\n+        let mut access_levels = std::mem::take(&mut self.r.access_levels);\n+        let module_id =\n+            self.r.get_nearest_non_block_module(def_id.to_def_id()).def_id().expect_local();\n+        let res = access_levels.update(\n+            def_id,\n+            nominal_vis,\n+            || Visibility::Restricted(module_id),\n+            parent_id,\n+            tag,\n+            &*self.r,\n+        );\n+        if let Ok(changed) = res {\n+            self.changed |= changed;\n         } else {\n-            old_level\n+            self.r.session.delay_span_bug(\n+                self.r.opt_span(def_id.to_def_id()).unwrap(),\n+                \"Can't update effective visibility\",\n+            );\n         }\n+        self.r.access_levels = access_levels;\n     }\n }\n \n@@ -125,16 +127,15 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n \n             // Foreign modules inherit level from parents.\n             ast::ItemKind::ForeignMod(..) => {\n-                let parent_level =\n-                    self.r.access_levels.get_access_level(self.r.local_parent(def_id));\n-                self.set_access_level(item.id, parent_level);\n+                let parent_id = self.r.local_parent(def_id);\n+                self.update(def_id, Visibility::Public, parent_id, AccessLevel::Public);\n             }\n \n             // Only exported `macro_rules!` items are public, but they always are\n             ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                if item.attrs.iter().any(|attr| attr.has_name(sym::macro_export)) {\n-                    self.set_access_level(item.id, Some(AccessLevel::Public));\n-                }\n+                let parent_id = self.r.local_parent(def_id);\n+                let vis = self.r.visibilities[&def_id];\n+                self.update(def_id, vis, parent_id, AccessLevel::Public);\n             }\n \n             ast::ItemKind::Mod(..) => {\n@@ -146,19 +147,19 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n                 self.set_bindings_access_level(def_id);\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n-                    let variant_level = self.r.access_levels.get_access_level(variant_def_id);\n                     for field in variant.data.fields() {\n-                        self.set_access_level(field.id, variant_level);\n+                        let field_def_id = self.r.local_def_id(field.id);\n+                        let vis = self.r.visibilities[&field_def_id];\n+                        self.update(field_def_id, vis, variant_def_id, AccessLevel::Public);\n                     }\n                 }\n             }\n \n             ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n-                let inherited_level = self.r.access_levels.get_access_level(def_id);\n                 for field in def.fields() {\n-                    if field.vis.kind.is_pub() {\n-                        self.set_access_level(field.id, inherited_level);\n-                    }\n+                    let field_def_id = self.r.local_def_id(field.id);\n+                    let vis = self.r.visibilities[&field_def_id];\n+                    self.update(field_def_id, vis, def_id, AccessLevel::Public);\n                 }\n             }\n "}, {"sha": "b8522ea5d8fdc6ad2f762c48502177f76cd631c3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{TyCtxt, Visibility};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -230,7 +230,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     } else {\n                         // All items need to be handled here in case someone wishes to link\n                         // to them with intra-doc links\n-                        self.cx.cache.access_levels.set_access_level(did, AccessLevel::Public);\n+                        self.cx.cache.access_levels.set_access_level(\n+                            did,\n+                            || Visibility::Restricted(CRATE_DEF_ID),\n+                            AccessLevel::Public,\n+                        );\n                     }\n                 }\n             }"}, {"sha": "0511494668b133fc4195ba1dfb1b74ab79623399", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{TyCtxt, Visibility};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n@@ -41,7 +41,11 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         let old_level = self.access_levels.get_access_level(did);\n         // Accessibility levels can only grow\n         if level > old_level && !is_hidden {\n-            self.access_levels.set_access_level(did, level.unwrap());\n+            self.access_levels.set_access_level(\n+                did,\n+                || Visibility::Restricted(CRATE_DEF_ID),\n+                level.unwrap(),\n+            );\n             level\n         } else {\n             old_level"}, {"sha": "cc074a4f958656c2551fe5d882f1125690da04b6", "filename": "src/test/ui/privacy/access_levels.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -1,44 +1,44 @@\n #![feature(rustc_attrs)]\n \n #[rustc_effective_visibility]\n-mod outer { //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+mod outer { //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n     #[rustc_effective_visibility]\n-    pub mod inner1 { //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+    pub mod inner1 { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n \n         #[rustc_effective_visibility]\n-        extern \"C\" {} //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+        extern \"C\" {} //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n \n         #[rustc_effective_visibility]\n-        pub trait PubTrait { //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+        pub trait PubTrait { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n             #[rustc_effective_visibility]\n-            const A: i32; //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+            const A: i32; //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n             #[rustc_effective_visibility]\n-            type B; //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+            type B; //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n         }\n \n         #[rustc_effective_visibility]\n         struct PrivStruct; //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n \n         #[rustc_effective_visibility]\n-        pub union PubUnion { //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+        pub union PubUnion { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n             #[rustc_effective_visibility]\n             a: u8, //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n             #[rustc_effective_visibility]\n-            pub b: u8, //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+            pub b: u8, //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n         }\n \n         #[rustc_effective_visibility]\n-        pub enum Enum { //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+        pub enum Enum { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n             #[rustc_effective_visibility]\n-            A( //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+            A( //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n                 #[rustc_effective_visibility]\n-                PubUnion,  //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+                PubUnion,  //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n             ),\n         }\n     }\n \n     #[rustc_effective_visibility]\n-    macro_rules! none_macro { //~ Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+    macro_rules! none_macro { //~ Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n         () => {};\n     }\n \n@@ -49,9 +49,9 @@ mod outer { //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(sel\n     }\n \n     #[rustc_effective_visibility]\n-    pub struct ReachableStruct { //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub, ReachableFromImplTrait: pub\n+    pub struct ReachableStruct { //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n         #[rustc_effective_visibility]\n-        pub a: u8, //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub, ReachableFromImplTrait: pub\n+        pub a: u8, //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n     }\n }\n \n@@ -62,14 +62,13 @@ pub fn foo() -> outer::ReachableStruct { outer::ReachableStruct {a: 0} }\n \n mod half_public_import {\n     #[rustc_effective_visibility]\n-    pub type HalfPublicImport = u8; //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+    pub type HalfPublicImport = u8; //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n     #[rustc_effective_visibility]\n     #[allow(non_upper_case_globals)]\n-    pub(crate) const HalfPublicImport: u8 = 0; //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+    pub(crate) const HalfPublicImport: u8 = 0; //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n }\n \n #[rustc_effective_visibility]\n pub use half_public_import::HalfPublicImport; //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-                                              //~^ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n \n fn main() {}"}, {"sha": "19199a3eb87a65e8e16d0d0df2757eec5427cd06", "filename": "src/test/ui/privacy/access_levels.stderr", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b5caee04116c7383eb1c6470fcf15c437a60d4/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr?ref=b8b5caee04116c7383eb1c6470fcf15c437a60d4", "patch": "@@ -1,22 +1,22 @@\n-error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+error: Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n   --> $DIR/access_levels.rs:4:1\n    |\n LL | mod outer {\n    | ^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:6:5\n    |\n LL |     pub mod inner1 {\n    |     ^^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:9:9\n    |\n LL |         extern \"C\" {}\n    |         ^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:12:9\n    |\n LL |         pub trait PubTrait {\n@@ -28,7 +28,7 @@ error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFr\n LL |         struct PrivStruct;\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:23:9\n    |\n LL |         pub union PubUnion {\n@@ -40,31 +40,31 @@ error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFr\n LL |             a: u8,\n    |             ^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:27:13\n    |\n LL |             pub b: u8,\n    |             ^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:31:9\n    |\n LL |         pub enum Enum {\n    |         ^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:33:13\n    |\n LL |             A(\n    |             ^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:35:17\n    |\n LL |                 PubUnion,\n    |                 ^^^^^^^^\n \n-error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+error: Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n   --> $DIR/access_levels.rs:41:5\n    |\n LL |     macro_rules! none_macro {\n@@ -76,13 +76,13 @@ error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n LL |     macro_rules! public_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub(self), Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:52:5\n    |\n LL |     pub struct ReachableStruct {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub(self), Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:54:9\n    |\n LL |         pub a: u8,\n@@ -94,13 +94,13 @@ error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n LL | pub use outer::inner1;\n    |         ^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:65:5\n    |\n LL |     pub type HalfPublicImport = u8;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+error: Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n   --> $DIR/access_levels.rs:68:5\n    |\n LL |     pub(crate) const HalfPublicImport: u8 = 0;\n@@ -112,23 +112,17 @@ error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n LL | pub use half_public_import::HalfPublicImport;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n-  --> $DIR/access_levels.rs:72:9\n-   |\n-LL | pub use half_public_import::HalfPublicImport;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:14:13\n    |\n LL |             const A: i32;\n    |             ^^^^^^^^^^^^\n \n-error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:16:13\n    |\n LL |             type B;\n    |             ^^^^^^\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 21 previous errors\n "}]}