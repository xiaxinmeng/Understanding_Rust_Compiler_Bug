{"sha": "e3274fd148273796e93c142d8cef28acc3af0b60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMjc0ZmQxNDgyNzM3OTZlOTNjMTQyZDhjZWYyOGFjYzNhZjBiNjA=", "commit": {"author": {"name": "Rune Tynan", "email": "runetynan@gmail.com", "date": "2021-01-14T19:49:58Z"}, "committer": {"name": "Rune Tynan", "email": "runetynan@gmail.com", "date": "2021-01-15T17:49:45Z"}, "message": "Remove doctree::Import", "tree": {"sha": "c8fad959dc9d6738d13f3dbf33b6d546d1230fc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8fad959dc9d6738d13f3dbf33b6d546d1230fc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3274fd148273796e93c142d8cef28acc3af0b60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEETdpCnQmiF6hBYUqdfsyTL4sscx4FAmAB1csACgkQfsyTL4ss\ncx6CJA/9EJsHA0oI4kc/fX63dDyO8OnpTQj9jpw0bJsZA13vbLVlqKDg3DzEg3K5\np8UlFQWTY2Oq+pp4/Gb8sOj9tJ2F3Z/j9G7U2hJffbJCPYr0hPHL8HNEZ3CHwkQR\n37dozuE2NwI2NLkEC9UF+WKvx39v1HWIJbGi/2jNrSGJAfqOP4sgtLVfNvuVUGvt\nwf4w5Zd76srlXRaRLU8r0KVvY5tv6Fon0bT7KaOKsYvHzXsBBqzCE6y+dL+upq7c\n4SFtP3S4cEs6jb/z8vBCYLmCP2MWp+nTg80foXNSAKeDjivWQ8xKN+CH1svTTZyN\n763WAk7ri26ynlbDm3wAhKSTGiWut54g7dpIFiSYH48wbiX6Ve6gGYcVmR/75QDC\nVKyeuhBTeOn3WhFIhKSpWQb2DvKAA8XS9KzSlGe6fmERnXWFaIeNW6ZL1D8qrOVp\negR0i3GE2/WQKQk7dLP1ZWz7iXHTAJS74KQbAwYolpMuk6rbF48ClN4VmEiHL/Yt\nA4WDFn7d3Rcw/ZScdfmieiUBKx33w93pua7zdYLYCHVN9M89SkZ/AO6+pdjZ/cdV\numGJp4IHiUfI8LrESX1OIrUdOU2M1nKZBtiTjBeSM0tNe//4TBPCm0WaAkO7cEgW\nUyAQyjIVlYGHtcld5Ojlg1xipaqpZdGXfN/9A347Jd1q7mfqdnE=\n=XE0E\n-----END PGP SIGNATURE-----", "payload": "tree c8fad959dc9d6738d13f3dbf33b6d546d1230fc5\nparent 18ec4a9a74731ddc6a453ca29c0836f61dbcb8d4\nauthor Rune Tynan <runetynan@gmail.com> 1610653798 -0500\ncommitter Rune Tynan <runetynan@gmail.com> 1610732985 -0500\n\nRemove doctree::Import\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3274fd148273796e93c142d8cef28acc3af0b60", "html_url": "https://github.com/rust-lang/rust/commit/e3274fd148273796e93c142d8cef28acc3af0b60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3274fd148273796e93c142d8cef28acc3af0b60/comments", "author": {"login": "CraftSpider", "id": 13342132, "node_id": "MDQ6VXNlcjEzMzQyMTMy", "avatar_url": "https://avatars.githubusercontent.com/u/13342132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CraftSpider", "html_url": "https://github.com/CraftSpider", "followers_url": "https://api.github.com/users/CraftSpider/followers", "following_url": "https://api.github.com/users/CraftSpider/following{/other_user}", "gists_url": "https://api.github.com/users/CraftSpider/gists{/gist_id}", "starred_url": "https://api.github.com/users/CraftSpider/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CraftSpider/subscriptions", "organizations_url": "https://api.github.com/users/CraftSpider/orgs", "repos_url": "https://api.github.com/users/CraftSpider/repos", "events_url": "https://api.github.com/users/CraftSpider/events{/privacy}", "received_events_url": "https://api.github.com/users/CraftSpider/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CraftSpider", "id": 13342132, "node_id": "MDQ6VXNlcjEzMzQyMTMy", "avatar_url": "https://avatars.githubusercontent.com/u/13342132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CraftSpider", "html_url": "https://github.com/CraftSpider", "followers_url": "https://api.github.com/users/CraftSpider/followers", "following_url": "https://api.github.com/users/CraftSpider/following{/other_user}", "gists_url": "https://api.github.com/users/CraftSpider/gists{/gist_id}", "starred_url": "https://api.github.com/users/CraftSpider/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CraftSpider/subscriptions", "organizations_url": "https://api.github.com/users/CraftSpider/orgs", "repos_url": "https://api.github.com/users/CraftSpider/repos", "events_url": "https://api.github.com/users/CraftSpider/events{/privacy}", "received_events_url": "https://api.github.com/users/CraftSpider/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18ec4a9a74731ddc6a453ca29c0836f61dbcb8d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/18ec4a9a74731ddc6a453ca29c0836f61dbcb8d4", "html_url": "https://github.com/rust-lang/rust/commit/18ec4a9a74731ddc6a453ca29c0836f61dbcb8d4"}], "stats": {"total": 204, "additions": 90, "deletions": 114}, "files": [{"sha": "0aabd9477e325a44bb760abd932ffb4530e55a6d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 89, "deletions": 91, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/e3274fd148273796e93c142d8cef28acc3af0b60/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3274fd148273796e93c142d8cef28acc3af0b60/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e3274fd148273796e93c142d8cef28acc3af0b60", "patch": "@@ -219,7 +219,6 @@ impl Clean<ExternalCrate> for CrateNum {\n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n-        items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n@@ -2019,7 +2018,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n-                hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                     let items = item_ids\n                         .iter()\n                         .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n@@ -2038,6 +2037,9 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::ExternCrate(orig_name) => {\n                     return clean_extern_crate(item, name, orig_name, cx);\n                 }\n+                ItemKind::Use(path, kind) => {\n+                    return clean_use_statement(item, name, path, kind, cx);\n+                }\n                 _ => unreachable!(\"not yet converted\"),\n             };\n \n@@ -2159,105 +2161,101 @@ fn clean_extern_crate(\n     }]\n }\n \n-impl Clean<Vec<Item>> for doctree::Import<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        // We need this comparison because some imports (for std types for example)\n-        // are \"inserted\" as well but directly by the compiler and they should not be\n-        // taken into account.\n-        if self.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n-            return Vec::new();\n-        }\n-\n-        let (doc_meta_item, please_inline) = self.attrs.lists(sym::doc).get_word_attr(sym::inline);\n-        let pub_underscore = self.vis.node.is_pub() && self.name == kw::Underscore;\n-\n-        if pub_underscore && please_inline {\n-            rustc_errors::struct_span_err!(\n-                cx.tcx.sess,\n-                doc_meta_item.unwrap().span(),\n-                E0780,\n-                \"anonymous imports cannot be inlined\"\n-            )\n-            .span_label(self.span, \"anonymous import\")\n-            .emit();\n-        }\n+fn clean_use_statement(\n+    import: &hir::Item<'_>,\n+    name: Symbol,\n+    path: &hir::Path<'_>,\n+    kind: hir::UseKind,\n+    cx: &DocContext<'_>,\n+) -> Vec<Item> {\n+    // We need this comparison because some imports (for std types for example)\n+    // are \"inserted\" as well but directly by the compiler and they should not be\n+    // taken into account.\n+    if import.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n+        return Vec::new();\n+    }\n+\n+    let (doc_meta_item, please_inline) = import.attrs.lists(sym::doc).get_word_attr(sym::inline);\n+    let pub_underscore = import.vis.node.is_pub() && name == kw::Underscore;\n+\n+    if pub_underscore && please_inline {\n+        rustc_errors::struct_span_err!(\n+            cx.tcx.sess,\n+            doc_meta_item.unwrap().span(),\n+            E0780,\n+            \"anonymous imports cannot be inlined\"\n+        )\n+        .span_label(import.span, \"anonymous import\")\n+        .emit();\n+    }\n \n-        // We consider inlining the documentation of `pub use` statements, but we\n-        // forcefully don't inline if this is not public or if the\n-        // #[doc(no_inline)] attribute is present.\n-        // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let mut denied = !self.vis.node.is_pub()\n-            || pub_underscore\n-            || self.attrs.iter().any(|a| {\n-                a.has_name(sym::doc)\n-                    && match a.meta_item_list() {\n-                        Some(l) => {\n-                            attr::list_contains_name(&l, sym::no_inline)\n-                                || attr::list_contains_name(&l, sym::hidden)\n-                        }\n-                        None => false,\n+    // We consider inlining the documentation of `pub use` statements, but we\n+    // forcefully don't inline if this is not public or if the\n+    // #[doc(no_inline)] attribute is present.\n+    // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n+    let mut denied = !import.vis.node.is_pub()\n+        || pub_underscore\n+        || import.attrs.iter().any(|a| {\n+            a.has_name(sym::doc)\n+                && match a.meta_item_list() {\n+                    Some(l) => {\n+                        attr::list_contains_name(&l, sym::no_inline)\n+                            || attr::list_contains_name(&l, sym::hidden)\n                     }\n-            });\n-        // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n-        // crate in Rust 2018+\n-        let path = self.path.clean(cx);\n-        let inner = if self.glob {\n-            if !denied {\n-                let mut visited = FxHashSet::default();\n-                if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n-                    return items;\n+                    None => false,\n                 }\n+        });\n+\n+    // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n+    // crate in Rust 2018+\n+    let path = path.clean(cx);\n+    let inner = if kind == hir::UseKind::Glob {\n+        if !denied {\n+            let mut visited = FxHashSet::default();\n+            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n+                return items;\n             }\n-            Import::new_glob(resolve_use_source(cx, path), true)\n-        } else {\n-            let name = self.name;\n-            if !please_inline {\n-                if let Res::Def(DefKind::Mod, did) = path.res {\n-                    if !did.is_local() && did.index == CRATE_DEF_INDEX {\n-                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                        // were specifically asked for it\n-                        denied = true;\n-                    }\n+        }\n+        Import::new_glob(resolve_use_source(cx, path), true)\n+    } else {\n+        if !please_inline {\n+            if let Res::Def(DefKind::Mod, did) = path.res {\n+                if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                    // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                    // were specifically asked for it\n+                    denied = true;\n                 }\n             }\n-            if !denied {\n-                let mut visited = FxHashSet::default();\n+        }\n+        if !denied {\n+            let mut visited = FxHashSet::default();\n \n-                if let Some(mut items) = inline::try_inline(\n+            if let Some(mut items) = inline::try_inline(\n+                cx,\n+                cx.tcx.parent_module(import.hir_id).to_def_id(),\n+                path.res,\n+                name,\n+                Some(import.attrs),\n+                &mut visited,\n+            ) {\n+                items.push(Item::from_def_id_and_parts(\n+                    cx.tcx.hir().local_def_id(import.hir_id).to_def_id(),\n+                    None,\n+                    ImportItem(Import::new_simple(name, resolve_use_source(cx, path), false)),\n                     cx,\n-                    cx.tcx.parent_module(self.id).to_def_id(),\n-                    path.res,\n-                    name,\n-                    Some(self.attrs),\n-                    &mut visited,\n-                ) {\n-                    items.push(Item {\n-                        name: None,\n-                        attrs: box self.attrs.clean(cx),\n-                        source: self.span.clean(cx),\n-                        def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-                        visibility: self.vis.clean(cx),\n-                        kind: box ImportItem(Import::new_simple(\n-                            self.name,\n-                            resolve_use_source(cx, path),\n-                            false,\n-                        )),\n-                    });\n-                    return items;\n-                }\n+                ));\n+                return items;\n             }\n-            Import::new_simple(name, resolve_use_source(cx, path), true)\n-        };\n+        }\n+        Import::new_simple(name, resolve_use_source(cx, path), true)\n+    };\n \n-        vec![Item {\n-            name: None,\n-            attrs: box self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            kind: box ImportItem(inner),\n-        }]\n-    }\n+    vec![Item::from_def_id_and_parts(\n+        cx.tcx.hir().local_def_id(import.hir_id).to_def_id(),\n+        None,\n+        ImportItem(inner),\n+        cx,\n+    )]\n }\n \n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {"}, {"sha": "f90623c03118b6ef8b462589a1888e1b38782327", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3274fd148273796e93c142d8cef28acc3af0b60/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3274fd148273796e93c142d8cef28acc3af0b60/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=e3274fd148273796e93c142d8cef28acc3af0b60", "patch": "@@ -2,7 +2,6 @@\n //! manner (and with prettier names) before cleaning.\n crate use self::StructType::*;\n \n-use rustc_ast as ast;\n use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n@@ -11,7 +10,6 @@ crate struct Module<'hir> {\n     crate name: Option<Symbol>,\n     crate where_outer: Span,\n     crate where_inner: Span,\n-    crate imports: Vec<Import<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n     // (item, renamed)\n@@ -28,7 +26,6 @@ impl Module<'hir> {\n             id: hir::CRATE_HIR_ID,\n             where_outer: rustc_span::DUMMY_SP,\n             where_inner: rustc_span::DUMMY_SP,\n-            imports: Vec::new(),\n             mods: Vec::new(),\n             items: Vec::new(),\n             foreigns: Vec::new(),\n@@ -48,17 +45,6 @@ crate enum StructType {\n     Unit,\n }\n \n-#[derive(Debug)]\n-crate struct Import<'hir> {\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate path: &'hir hir::Path<'hir>,\n-    crate glob: bool,\n-    crate span: Span,\n-}\n-\n crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "7d161ca3648ccabfd5630d597e0803f145212f7c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3274fd148273796e93c142d8cef28acc3af0b60/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3274fd148273796e93c142d8cef28acc3af0b60/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e3274fd148273796e93c142d8cef28acc3af0b60", "patch": "@@ -316,15 +316,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                om.imports.push(Import {\n-                    name,\n-                    id: item.hir_id,\n-                    vis: &item.vis,\n-                    attrs: &item.attrs,\n-                    path,\n-                    glob: is_glob,\n-                    span: item.span,\n-                });\n+                om.items.push((item, renamed))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents("}]}