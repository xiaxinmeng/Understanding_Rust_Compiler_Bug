{"sha": "022a01d40c7fd9693f1b10607912605a6fc898b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmEwMWQ0MGM3ZmQ5NjkzZjFiMTA2MDc5MTI2MDVhNmZjODk4Yjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-25T18:13:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-26T17:22:37Z"}, "message": "std: Add experimental networking methods\n\nThe underlying I/O objects implement a good deal of various options here and\nthere for tuning network sockets and how they perform. Most of this is a relic\nof \"whatever libuv provides\", but these options are genuinely useful.\n\nIt is unclear at this time whether these options should be well supported or\nnot, or whether they have correct names or not. For now, I believe it's better\nto expose the functionality than to not, but all new methods are added with\nan #[experimental] annotation.", "tree": {"sha": "b9513d43de8d38c930f942e3139e9bcac788bcf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9513d43de8d38c930f942e3139e9bcac788bcf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022a01d40c7fd9693f1b10607912605a6fc898b8", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022a01d40c7fd9693f1b10607912605a6fc898b8", "html_url": "https://github.com/rust-lang/rust/commit/022a01d40c7fd9693f1b10607912605a6fc898b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022a01d40c7fd9693f1b10607912605a6fc898b8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a28a701d648d88ed63f575fa1efed47f5cbb81ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28a701d648d88ed63f575fa1efed47f5cbb81ca", "html_url": "https://github.com/rust-lang/rust/commit/a28a701d648d88ed63f575fa1efed47f5cbb81ca"}], "stats": {"total": 71, "additions": 70, "deletions": 1}, "files": [{"sha": "c6a8702b674c0f4771711b17f04da5cc5cb5e66c", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/022a01d40c7fd9693f1b10607912605a6fc898b8/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a01d40c7fd9693f1b10607912605a6fc898b8/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=022a01d40c7fd9693f1b10607912605a6fc898b8", "patch": "@@ -85,6 +85,29 @@ impl TcpStream {\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         self.obj.socket_name()\n     }\n+\n+    /// Sets the nodelay flag on this connection to the boolean specified\n+    #[experimental]\n+    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n+        if nodelay {\n+            self.obj.nodelay()\n+        } else {\n+            self.obj.control_congestion()\n+        }\n+    }\n+\n+    /// Sets the keepalive timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then the keepalive flag is cleared on\n+    /// this connection. Otherwise, the keepalive timeout will be set to the\n+    /// specified time, in seconds.\n+    #[experimental]\n+    pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n+        match delay_in_seconds {\n+            Some(i) => self.obj.keepalive(i),\n+            None => self.obj.letdie(),\n+        }\n+    }\n }\n \n impl Clone for TcpStream {"}, {"sha": "f0346fe5d4b5115ecd8aad536e85be93a171cc66", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/022a01d40c7fd9693f1b10607912605a6fc898b8/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a01d40c7fd9693f1b10607912605a6fc898b8/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=022a01d40c7fd9693f1b10607912605a6fc898b8", "patch": "@@ -16,7 +16,7 @@\n //! datagram protocol.\n \n use clone::Clone;\n-use io::net::ip::SocketAddr;\n+use io::net::ip::{SocketAddr, IpAddr};\n use io::{Reader, Writer, IoResult};\n use kinds::Send;\n use result::{Ok, Err};\n@@ -95,6 +95,52 @@ impl UdpSocket {\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         self.obj.socket_name()\n     }\n+\n+    /// Joins a multicast IP address (becomes a member of it)\n+    #[experimental]\n+    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n+        self.obj.join_multicast(multi)\n+    }\n+\n+    /// Leaves a multicast IP address (drops membership from it)\n+    #[experimental]\n+    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n+        self.obj.leave_multicast(multi)\n+    }\n+\n+    /// Set the multicast loop flag to the specified value\n+    ///\n+    /// This lets multicast packets loop back to local sockets (if enabled)\n+    #[experimental]\n+    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n+        if on {\n+            self.obj.loop_multicast_locally()\n+        } else {\n+            self.obj.dont_loop_multicast_locally()\n+        }\n+    }\n+\n+    /// Sets the multicast TTL\n+    #[experimental]\n+    pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n+        self.obj.multicast_time_to_live(ttl)\n+    }\n+\n+    /// Sets this socket's TTL\n+    #[experimental]\n+    pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n+        self.obj.time_to_live(ttl)\n+    }\n+\n+    /// Sets the broadcast flag on or off\n+    #[experimental]\n+    pub fn set_broadast(&mut self, broadcast: bool) -> IoResult<()> {\n+        if broadcast {\n+            self.obj.hear_broadcasts()\n+        } else {\n+            self.obj.ignore_broadcasts()\n+        }\n+    }\n }\n \n impl Clone for UdpSocket {"}]}