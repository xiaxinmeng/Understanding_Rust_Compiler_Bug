{"sha": "4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZmM0MjUwYmY3MjFkNTk0NmI0ZjkxYzdiNTYxZGQ1N2EwMGNjOTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-24T21:56:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-24T21:56:04Z"}, "message": "More work on trans, almost getting to the point of emitting an upcall.", "tree": {"sha": "74ddce35ffc08f66def2dccba16515414b01868d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74ddce35ffc08f66def2dccba16515414b01868d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "html_url": "https://github.com/rust-lang/rust/commit/4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b412be619279aa89bf30fe31f69e9bfa3d550ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b412be619279aa89bf30fe31f69e9bfa3d550ee", "html_url": "https://github.com/rust-lang/rust/commit/6b412be619279aa89bf30fe31f69e9bfa3d550ee"}], "stats": {"total": 241, "additions": 204, "deletions": 37}, "files": [{"sha": "ad4c066e361ccfd25ae1653c9bbec85eee0c2d17", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "patch": "@@ -36,6 +36,18 @@ const int worst_case_glue_call_args = 7;\n \n const int n_upcall_glues = 7;\n \n+fn upcall_glue_name(int n) -> str {\n+    ret \"rust_upcall_\" + util.common.istr(n);\n+}\n+\n+fn activate_glue_name() -> str {\n+    ret \"rust_activate_glue\";\n+}\n+\n+fn yield_glue_name() -> str {\n+    ret \"rust_yield_glue\";\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "b3edcae6f0a0114f0e98ce80398d8ccae74c56de", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "patch": "@@ -121,7 +121,7 @@ fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n fn decl_upcall_glue(int align, str prefix, uint n) -> str {\n     let int i = n as int;\n     ret decl_glue(align, prefix,\n-                  \"rust_upcall_\" + istr(i),\n+                  abi.upcall_glue_name(i),\n                   upcall_glue(i));\n }\n \n@@ -131,11 +131,11 @@ fn get_module_asm() -> str {\n \n     auto glues =\n         vec(decl_glue(align, prefix,\n-                      \"rust_activate_glue\",\n+                      abi.activate_glue_name(),\n                       rust_activate_glue()),\n \n             decl_glue(align, prefix,\n-                      \"rust_yield_glue\",\n+                      abi.yield_glue_name(),\n                       rust_yield_glue()))\n \n         + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, _),"}, {"sha": "ac8dd76f3d9a28d97eb14a553a3dadde0ee4078c", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "patch": "@@ -41,7 +41,6 @@ const uint LLVMColdCallConv = 9u;\n const uint LLVMX86StdcallCallConv = 64u;\n const uint LLVMX86FastcallCallConv = 65u;\n \n-\n native mod llvm = llvm_lib {\n \n     type ModuleRef;\n@@ -96,6 +95,14 @@ native mod llvm = llvm_lib {\n     /** See Module::setModuleInlineAsm. */\n     fn LLVMSetModuleInlineAsm(ModuleRef M, sbuf Asm);\n \n+    /** See llvm::LLVMTypeKind::getTypeID. */\n+\n+    // FIXME: returning int rather than TypeKind because\n+    // we directly inspect the values, and casting from\n+    // a native doesn't work yet (only *to* a native).\n+\n+    fn LLVMGetTypeKind(TypeRef Ty) -> int;\n+\n     /** See llvm::LLVMType::getContext. */\n     fn LLVMGetTypeContext(TypeRef Ty) -> ContextRef;\n \n@@ -213,7 +220,9 @@ native mod llvm = llvm_lib {\n \n     /* Operations on scalar constants */\n     fn LLVMConstInt(TypeRef IntTy, ULongLong N, Bool SignExtend) -> ValueRef;\n-    fn LLVMConstIntOfString(TypeRef IntTy, sbuf Text, u8 Radix) -> ValueRef;\n+    // FIXME: radix is actually u8, but our native layer can't handle this\n+    // yet.  lucky for us we're little-endian. Small miracles.\n+    fn LLVMConstIntOfString(TypeRef IntTy, sbuf Text, int Radix) -> ValueRef;\n     fn LLVMConstIntOfStringAndSize(TypeRef IntTy, sbuf Text,\n                                    uint SLen, u8 Radix) -> ValueRef;\n     fn LLVMConstReal(TypeRef RealTy, f64 N) -> ValueRef;\n@@ -1041,6 +1050,82 @@ obj builder(BuilderRef B) {\n     }\n }\n \n+fn type_to_str(TypeRef ty) -> str {\n+    let int kind = llvm.LLVMGetTypeKind(ty);\n+\n+    fn tys_str(vec[TypeRef] tys) -> str {\n+        let str s = \"\";\n+        let bool first = true;\n+        for (TypeRef t in tys) {\n+            if (first) {\n+                first = false;\n+            } else {\n+                s += \", \";\n+            }\n+            s += type_to_str(t);\n+        }\n+        ret s;\n+    }\n+\n+    alt (kind) {\n+\n+        // FIXME: more enum-as-int constants determined from Core.h;\n+        // horrible, horrible. Complete as needed.\n+\n+        case (0) { ret \"Void\"; }\n+        case (1) { ret \"Float\"; }\n+        case (2) { ret \"Double\"; }\n+        case (3) { ret \"X86_FP80\"; }\n+        case (4) { ret \"FP128\"; }\n+        case (5) { ret \"PPC_FP128\"; }\n+        case (6) { ret \"Label\"; }\n+\n+        case (7) {\n+            ret \"i\" + util.common.istr(llvm.LLVMGetIntTypeWidth(ty) as int);\n+        }\n+\n+        case (8) {\n+            auto s = \"fn(\";\n+            let TypeRef out_ty = llvm.LLVMGetReturnType(ty);\n+            let uint n_args = llvm.LLVMCountParamTypes(ty);\n+            let vec[TypeRef] args =\n+                _vec.init_elt[TypeRef](0 as TypeRef, n_args);\n+            llvm.LLVMGetParamTypes(ty, _vec.buf[TypeRef](args));\n+            s += tys_str(args);\n+            s += \") -> \";\n+            s += type_to_str(out_ty);\n+            ret s;\n+        }\n+\n+        case (9) {\n+            let str s = \"{\";\n+            let uint n_elts = llvm.LLVMCountStructElementTypes(ty);\n+            let vec[TypeRef] elts =\n+                _vec.init_elt[TypeRef](0 as TypeRef, n_elts);\n+            llvm.LLVMGetStructElementTypes(ty, _vec.buf[TypeRef](elts));\n+            s += tys_str(elts);\n+            s += \"}\";\n+            ret s;\n+        }\n+\n+        case (10) { ret \"Array\"; }\n+\n+        case (11) {\n+            ret \"*\" + type_to_str(llvm.LLVMGetElementType(ty));\n+        }\n+\n+        case (12) { ret \"Opaque\"; }\n+        case (13) { ret \"Vector\"; }\n+        case (14) { ret \"Metadata\"; }\n+        case (15) { ret \"Union\"; }\n+        case (_) {\n+            log \"unknown TypeKind\" + util.common.istr(kind as int);\n+            fail;\n+        }\n+    }\n+}\n+\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e2dfc7c1b29506a58e45c09fda6a3a012d9cbc0b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 101, "deletions": 32, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "patch": "@@ -33,6 +33,21 @@ type trans_ctxt = rec(session.session sess,\n                       @glue_fns glues,\n                       str path);\n \n+type fn_ctxt = rec(ValueRef llfn,\n+                   ValueRef lloutptr,\n+                   ValueRef lltaskptr,\n+                   @trans_ctxt tcx);\n+\n+type terminator = fn(@fn_ctxt cx, builder build);\n+\n+type block_ctxt = rec(BasicBlockRef llbb,\n+                      builder build,\n+                      terminator term,\n+                      @fn_ctxt fcx);\n+\n+\n+// LLVM type constructors.\n+\n fn T_nil() -> TypeRef {\n     ret llvm.LLVMVoidType();\n }\n@@ -67,9 +82,38 @@ fn T_task() -> TypeRef {\n                      T_opaque())); // Rest is opaque for now\n }\n \n+\n+// LLVM constant constructors.\n+\n+fn C_null(TypeRef t) -> ValueRef {\n+    ret llvm.LLVMConstNull(t);\n+}\n+\n+fn C_int(int i) -> ValueRef {\n+    // FIXME. We can't use LLVM.ULongLong with our existing minimal native\n+    // API, which only knows word-sized args.  Lucky for us LLVM has a \"take a\n+    // string encoding\" version.  Hilarious. Please fix to handle:\n+    //\n+    // ret llvm.LLVMConstInt(T_int(), t as LLVM.ULongLong, False);\n+    //\n+    ret llvm.LLVMConstIntOfString(T_int(),\n+                                  _str.buf(istr(i)), 10);\n+}\n+\n+fn C_str(str s) -> ValueRef {\n+    ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n+}\n+\n+fn C_struct(vec[ValueRef] elts) -> ValueRef {\n+    ret llvm.LLVMConstStruct(_vec.buf[ValueRef](elts),\n+                             _vec.len[ValueRef](elts),\n+                             False);\n+}\n+\n fn decl_cdecl_fn(ModuleRef llmod, str name,\n                  vec[TypeRef] inputs, TypeRef output) -> ValueRef {\n     let TypeRef llty = T_fn(inputs, output);\n+    log \"declaring \" + name + \" with type \" + lib.llvm.type_to_str(llty);\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n     llvm.LLVMSetFunctionCallConv(llfn, lib.llvm.LLVMCCallConv);\n@@ -82,7 +126,7 @@ fn decl_glue(ModuleRef llmod, str s) -> ValueRef {\n \n fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n     let int n = _n as int;\n-    let str s = \"rust_upcall_\" + istr(n);\n+    let str s = abi.upcall_glue_name(n);\n     let vec[TypeRef] args =\n         vec(T_ptr(T_task()), // taskptr\n             T_int())         // callee\n@@ -91,9 +135,7 @@ fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, args, T_int());\n }\n \n-type terminator = fn(&trans_ctxt cx, builder b);\n-\n-fn get_upcall(&trans_ctxt cx, str name, int n_args) -> ValueRef {\n+fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n     if (cx.upcalls.contains_key(name)) {\n         ret cx.upcalls.get(name);\n     }\n@@ -105,61 +147,87 @@ fn get_upcall(&trans_ctxt cx, str name, int n_args) -> ValueRef {\n     ret f;\n }\n \n-fn trans_log(&trans_ctxt cx, builder b, &ast.atom a) {\n+fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n+    let int n = _vec.len[ValueRef](args) as int;\n+    let ValueRef llupcall = get_upcall(cx.fcx.tcx, name, n);\n+    llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n+\n+    let ValueRef llglue = cx.fcx.tcx.glues.upcall_glues.(n);\n+    let vec[ValueRef] call_args = vec(cx.fcx.lltaskptr, llupcall) + args;\n+    log \"emitting indirect-upcall via \" + abi.upcall_glue_name(n);\n+    for (ValueRef v in call_args) {\n+        log \"arg: \" + lib.llvm.type_to_str(llvm.LLVMTypeOf(v));\n+    }\n+    log \"emitting call to callee of type: \" +\n+        lib.llvm.type_to_str(llvm.LLVMTypeOf(llglue));\n+    ret cx.build.Call(llglue, call_args);\n+}\n+\n+fn trans_log(@block_ctxt cx, &ast.atom a) {\n     alt (a) {\n         case (ast.atom_lit(?lit)) {\n             alt (*lit) {\n                 case (ast.lit_int(?i)) {\n-                    cx.sess.unimpl(\"log int\");\n+                    trans_upcall(cx, \"upcall_log_int\", vec(C_int(i)));\n                 }\n                 case (_) {\n-                    cx.sess.unimpl(\"literal variant in trans_log\");\n+                    cx.fcx.tcx.sess.unimpl(\"literal variant in trans_log\");\n                 }\n             }\n         }\n         case (_) {\n-            cx.sess.unimpl(\"atom variant in trans_log\");\n+            cx.fcx.tcx.sess.unimpl(\"atom variant in trans_log\");\n         }\n     }\n }\n \n-fn trans_stmt(&trans_ctxt cx, builder b, &ast.stmt s, terminator t) {\n+fn trans_stmt(@block_ctxt cx, &ast.stmt s) {\n     alt (s) {\n         case (ast.stmt_log(?a)) {\n-            trans_log(cx, b, *a);\n+            trans_log(cx, *a);\n         }\n         case (_) {\n-            cx.sess.unimpl(\"stmt variant\");\n+            cx.fcx.tcx.sess.unimpl(\"stmt variant\");\n         }\n     }\n }\n \n-fn default_terminate(&trans_ctxt cx, builder b) {\n-    b.RetVoid();\n+fn default_terminate(@fn_ctxt cx, builder build) {\n+    build.RetVoid();\n }\n \n-fn trans_block(&trans_ctxt cx, ValueRef llfn, &ast.block b, terminator t) {\n+fn trans_block(@fn_ctxt cx, &ast.block b, terminator term) {\n     let BasicBlockRef llbb =\n-        llvm.LLVMAppendBasicBlock(llfn, _str.buf(\"\"));\n+        llvm.LLVMAppendBasicBlock(cx.llfn, _str.buf(\"\"));\n     let BuilderRef llbuild = llvm.LLVMCreateBuilder();\n     llvm.LLVMPositionBuilderAtEnd(llbuild, llbb);\n-    auto bld = builder(llbuild);\n+    auto bcx = @rec(llbb=llbb,\n+                    build=builder(llbuild),\n+                    term=term,\n+                    fcx=cx);\n     for (@ast.stmt s in b) {\n-        trans_stmt(cx, bld, *s, t);\n+        trans_stmt(bcx, *s);\n     }\n-    t(cx, bld);\n+    bcx.term(cx, bcx.build);\n }\n \n-fn trans_fn(&trans_ctxt cx, &ast._fn f) {\n-    let vec[TypeRef] args = vec();\n+fn trans_fn(@trans_ctxt cx, &ast._fn f) {\n+    let vec[TypeRef] args = vec(T_ptr(T_int()), // outptr.\n+                                T_ptr(T_task()) // taskptr\n+                                );\n     let ValueRef llfn = decl_cdecl_fn(cx.llmod, cx.path, args, T_nil());\n+    let ValueRef lloutptr = llvm.LLVMGetParam(llfn, 0u);\n+    let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 1u);\n+    auto fcx = @rec(llfn=llfn,\n+                    lloutptr=lloutptr,\n+                    lltaskptr=lltaskptr,\n+                    tcx=cx);\n     auto term = default_terminate;\n-\n-    trans_block(cx, llfn, f.body, term);\n+    trans_block(fcx, f.body, term);\n }\n \n-fn trans_item(&trans_ctxt cx, &str name, &ast.item item) {\n-    auto sub_cx = rec(path=cx.path + \".\" + name with cx);\n+fn trans_item(@trans_ctxt cx, &str name, &ast.item item) {\n+    auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n     alt (item) {\n         case (ast.item_fn(?f)) {\n             trans_fn(sub_cx, *f);\n@@ -170,7 +238,7 @@ fn trans_item(&trans_ctxt cx, &str name, &ast.item item) {\n     }\n }\n \n-fn trans_mod(&trans_ctxt cx, &ast._mod m) {\n+fn trans_mod(@trans_ctxt cx, &ast._mod m) {\n     for each (tup(str, ast.item) pair in m.items()) {\n         trans_item(cx, pair._0, pair._1);\n     }\n@@ -183,17 +251,18 @@ fn trans_crate(session.session sess, ast.crate crate) {\n \n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n-    auto glues = @rec(activate_glue = decl_glue(llmod, \"rust_activate_glue\"),\n-                      yield_glue = decl_glue(llmod, \"rust_yield_glue\"),\n+    auto glues = @rec(activate_glue = decl_glue(llmod,\n+                                                abi.activate_glue_name()),\n+                      yield_glue = decl_glue(llmod, abi.yield_glue_name()),\n                       upcall_glues =\n                       _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n                                              abi.n_upcall_glues as uint));\n \n-    auto cx = rec(sess = sess,\n-                  llmod = llmod,\n-                  upcalls = new_str_hash[ValueRef](),\n-                  glues = glues,\n-                  path = \"\");\n+    auto cx = @rec(sess = sess,\n+                   llmod = llmod,\n+                   upcalls = new_str_hash[ValueRef](),\n+                   glues = glues,\n+                   path = \"\");\n \n     trans_mod(cx, crate.module);\n "}, {"sha": "76b8fd624bcafb34f3e8a1e8bf991b1de8b2f162", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4cfc4250bf721d5946b4f91c7b561dd57a00cc96/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "patch": "@@ -30,6 +30,7 @@ mod util {\n \n auth driver.rustc.main = state;\n auth middle.trans = unsafe;\n+auth lib.llvm = unsafe;\n \n \n mod lib {"}]}