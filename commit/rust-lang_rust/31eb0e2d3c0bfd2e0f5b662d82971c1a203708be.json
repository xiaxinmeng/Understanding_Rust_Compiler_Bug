{"sha": "31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZWIwZTJkM2MwYmZkMmUwZjViNjYyZDgyOTcxYzFhMjAzNzA4YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T06:27:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T06:27:35Z"}, "message": "Auto merge of #57609 - matthewjasper:more-restrictive-match, r=pnkfelix\n\nUse normal mutable borrows in matches\n\n`ref mut` borrows are currently two-phase with NLL enabled. This changes them to be proper mutable borrows. To accommodate this, first the position of fake borrows is changed:\n\n```text\n[ 1. Pre-match ]\n       |\n[ (old create fake borrows) ]\n[ 2. Discriminant testing -- check discriminants ] <-+\n       |                                             |\n       | (once a specific arm is chosen)             |\n       |                                             |\n[ (old read fake borrows) ]                          |\n[ 3. Create \"guard bindings\" for arm ]               |\n[ (create fake borrows) ]                            |\n       |                                             |\n[ 4. Execute guard code ]                            |\n[ (read fake borrows) ] --(guard is false)-----------+\n       |\n       | (guard results in true)\n       |\n[ 5. Create real bindings and execute arm ]\n       |\n[ Exit match ]\n```\n\nThe following additional changes are made to accommodate `ref mut` bindings:\n\n* We no longer create fake `Shared` borrows. These borrows are no longer needed for soundness, just to avoid some arguably strange cases.\n* `Shallow` borrows no longer conflict with existing borrows, avoiding conflicting access between the guard borrow access and the `ref mut` borrow.\n\nThere is some further clean up done in this PR:\n\n* Avoid the \"later used here\" note for Shallow borrows (since it's not relevant with the message provided)\n* Make any use of a two-phase borrow activate it.\n* Simplify the cleanup_post_borrowck passes into a single pass.\n\ncc #56254\n\nr? @nikomatsakis", "tree": {"sha": "d54f740779bf1dcdc1d499831dca0aa4e649f504", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d54f740779bf1dcdc1d499831dca0aa4e649f504"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "html_url": "https://github.com/rust-lang/rust/commit/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1911babed0364ede7dedc646dbca63fac03d5c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1911babed0364ede7dedc646dbca63fac03d5c5", "html_url": "https://github.com/rust-lang/rust/commit/c1911babed0364ede7dedc646dbca63fac03d5c5"}, {"sha": "5ffc9197264a07a50bfb27e436fe284ae8c0687c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ffc9197264a07a50bfb27e436fe284ae8c0687c", "html_url": "https://github.com/rust-lang/rust/commit/5ffc9197264a07a50bfb27e436fe284ae8c0687c"}], "stats": {"total": 2376, "additions": 1198, "deletions": 1178}, "files": [{"sha": "ddc091b7187063eb714aecee9d1724c5f329a9ee", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -196,7 +196,12 @@ impl_stable_hash_for!(impl<'gcx> for enum mir::StatementKind<'gcx> [ mir::Statem\n });\n \n impl_stable_hash_for!(enum mir::RetagKind { FnEntry, TwoPhase, Raw, Default });\n-impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n+impl_stable_hash_for!(enum mir::FakeReadCause {\n+    ForMatchGuard,\n+    ForMatchedPlace,\n+    ForGuardBinding,\n+    ForLet\n+});\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "6c72a7c31591e74e9a2a0ee339f3445d7adb74e0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -1823,17 +1823,22 @@ pub enum RetagKind {\n /// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum FakeReadCause {\n-    /// Inject a fake read of the borrowed input at the start of each arm's\n-    /// pattern testing code.\n+    /// Inject a fake read of the borrowed input at the end of each guards\n+    /// code.\n     ///\n-    /// This should ensure that you cannot change the variant for an enum\n-    /// while you are in the midst of matching on it.\n+    /// This should ensure that you cannot change the variant for an enum while\n+    /// you are in the midst of matching on it.\n     ForMatchGuard,\n \n     /// `let x: !; match x {}` doesn't generate any read of x so we need to\n     /// generate a read of x to check that it is initialized and safe.\n     ForMatchedPlace,\n \n+    /// A fake read of the RefWithinGuard version of a bind-by-value variable\n+    /// in a match guard to ensure that it's value hasn't change by the time\n+    /// we create the OutsideGuard version.\n+    ForGuardBinding,\n+\n     /// Officially, the semantics of\n     ///\n     /// `let pattern = <expr>;`"}, {"sha": "2a3a616317c172a86692d4eb7ab35545f3d44a08", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -3,9 +3,7 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n-use rustc::mir::visit::{\n-    PlaceContext, Visitor, NonUseContext, MutatingUseContext, NonMutatingUseContext\n-};\n+use rustc::mir::visit::{PlaceContext, Visitor, NonUseContext, MutatingUseContext};\n use rustc::mir::{self, Location, Mir, Local};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -257,31 +255,21 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 );\n             }\n \n-            // Otherwise, this is the unique later use\n-            // that we expect.\n-            borrow_data.activation_location = match context {\n-                // The use of TMP in a shared borrow does not\n-                // count as an actual activation.\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(..)) |\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(..)) =>\n-                    TwoPhaseActivation::NotActivated,\n-                _ => {\n-                    // Double check: This borrow is indeed a two-phase borrow (that is,\n-                    // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n-                    // we've not found any other activations (checked above).\n-                    assert_eq!(\n-                        borrow_data.activation_location,\n-                        TwoPhaseActivation::NotActivated,\n-                        \"never found an activation for this borrow!\",\n-                    );\n-\n-                    self.activation_map\n-                        .entry(location)\n-                        .or_default()\n-                        .push(borrow_index);\n-                    TwoPhaseActivation::ActivatedAt(location)\n-                }\n-            };\n+            // Otherwise, this is the unique later use that we expect.\n+            // Double check: This borrow is indeed a two-phase borrow (that is,\n+            // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n+            // we've not found any other activations (checked above).\n+            assert_eq!(\n+                borrow_data.activation_location,\n+                TwoPhaseActivation::NotActivated,\n+                \"never found an activation for this borrow!\",\n+            );\n+            self.activation_map\n+                .entry(location)\n+                .or_default()\n+                .push(borrow_index);\n+\n+            borrow_data.activation_location = TwoPhaseActivation::ActivatedAt(location);\n         }\n     }\n "}, {"sha": "67fbe5762e73ab267473b862e27e2e61e31735e3", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -1336,22 +1336,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let loan_span = loan_spans.args_or_use();\n \n         let tcx = self.infcx.tcx;\n-        let mut err = if loan.kind == BorrowKind::Shallow {\n-            tcx.cannot_mutate_in_match_guard(\n+        if loan.kind == BorrowKind::Shallow {\n+            let mut err = tcx.cannot_mutate_in_match_guard(\n                 span,\n                 loan_span,\n                 &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n                 \"assign\",\n                 Origin::Mir,\n-            )\n-        } else {\n-            tcx.cannot_assign_to_borrowed(\n-                span,\n-                loan_span,\n-                &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-                Origin::Mir,\n-            )\n-        };\n+            );\n+            loan_spans.var_span_label(\n+                &mut err,\n+                format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+            );\n+\n+            err.buffer(&mut self.errors_buffer);\n+\n+            return;\n+        }\n+\n+        let mut err = tcx.cannot_assign_to_borrowed(\n+            span,\n+            loan_span,\n+            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            Origin::Mir,\n+        );\n \n         loan_spans.var_span_label(\n             &mut err,"}, {"sha": "1e9dab5016f8d24abe2b21171a48ece212d7a609", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -998,7 +998,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared)\n-                | (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow) => {\n+                | (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow)\n+                | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Unique)\n+                | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Mut { .. }) => {\n                     Control::Continue\n                 }\n "}, {"sha": "9c067677621081998c9f4af0835d6948366a119b", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -78,13 +78,8 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     JustWrite\n                 );\n             }\n-            StatementKind::FakeRead(_, ref place) => {\n-                self.access_place(\n-                    ContextKind::FakeRead.new(location),\n-                    place,\n-                    (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n-                    LocalMutationIsAllowed::No,\n-                );\n+            StatementKind::FakeRead(_, _) => {\n+                // Only relavent for initialized/liveness/safety checks.\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -438,7 +433,9 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     }\n \n                     (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow)\n-                    | (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                    | (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared)\n+                    | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Unique)\n+                    | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Mut { .. }) => {\n                         // Reads/reservations don't invalidate shared or shallow borrows\n                     }\n "}, {"sha": "627fd7d2e16677a68b1bf3d8751a32f2f8da24a8", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -6,8 +6,6 @@ use rustc::mir::*;\n use rustc::hir;\n use syntax_pos::Span;\n \n-use std::slice;\n-\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Place<'tcx>,\n@@ -125,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None,\n                             remainder_span,\n                             lint_level,\n-                            slice::from_ref(&pattern),\n+                            &pattern,\n                             ArmHasGuard(false),\n                             Some((None, initializer_span)),\n                         );\n@@ -138,7 +136,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             }));\n                     } else {\n                         scope = this.declare_bindings(\n-                            None, remainder_span, lint_level, slice::from_ref(&pattern),\n+                            None, remainder_span, lint_level, &pattern,\n                             ArmHasGuard(false), None);\n \n                         debug!(\"ast_block_stmts: pattern={:?}\", pattern);"}, {"sha": "07db67a6ae00ff738e23275ae507ec31ad1cac1d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -53,8 +53,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)\n             }\n-            ExprKind::Match { discriminant, arms } => {\n-                this.match_expr(destination, expr_span, block, discriminant, arms)\n+            ExprKind::Match { scrutinee, arms } => {\n+                this.match_expr(destination, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::NeverToAny { source } => {\n                 let source = this.hir.mirror(source);"}, {"sha": "2c4eb0bc091c3c18b9c49f1954601394a756113d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 566, "deletions": 475, "changes": 1041, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -1,18 +1,20 @@\n-//! Code related to match expressions. These are sufficiently complex\n-//! to warrant their own module and submodules. :) This main module\n-//! includes the high-level algorithm, the submodules contain the\n-//! details.\n+//! Code related to match expressions. These are sufficiently complex to\n+//! warrant their own module and submodules. :) This main module includes the\n+//! high-level algorithm, the submodules contain the details.\n+//!\n+//! This also includes code for pattern bindings in `let` statements and\n+//! function parameters.\n \n use crate::build::scope::{CachedBlock, DropKind};\n-use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n+use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;\n \n@@ -23,168 +25,199 @@ mod util;\n \n use std::convert::TryFrom;\n \n-/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n-/// a match arm has a guard expression attached to it.\n-#[derive(Copy, Clone, Debug)]\n-pub(crate) struct ArmHasGuard(pub bool);\n-\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    /// Generates MIR for a `match` expression.\n+    ///\n+    /// The MIR that we generate for a match looks like this.\n+    ///\n+    /// ```text\n+    /// [ 0. Pre-match ]\n+    ///        |\n+    /// [ 1. Evaluate Scrutinee (expression being matched on) ]\n+    /// [ (fake read of scrutinee) ]\n+    ///        |\n+    /// [ 2. Decision tree -- check discriminants ] <--------+\n+    ///        |                                             |\n+    ///        | (once a specific arm is chosen)             |\n+    ///        |                                             |\n+    /// [pre_binding_block]                           [otherwise_block]\n+    ///        |                                             |\n+    /// [ 3. Create \"guard bindings\" for arm ]               |\n+    /// [ (create fake borrows) ]                            |\n+    ///        |                                             |\n+    /// [ 4. Execute guard code ]                            |\n+    /// [ (read fake borrows) ] --(guard is false)-----------+\n+    ///        |\n+    ///        | (guard results in true)\n+    ///        |\n+    /// [ 5. Create real bindings and execute arm ]\n+    ///        |\n+    /// [ Exit match ]\n+    /// ```\n+    ///\n+    /// All of the different arms have been stacked on top of each other to\n+    /// simplify the diagram. For an arm with no guard the blocks marked 3 and\n+    /// 4 and the fake borrows are omitted.\n+    ///\n+    /// We generate MIR in the following steps:\n+    ///\n+    /// 1. Evaluate the scrutinee and add the fake read of it.\n+    /// 2. Create the prebinding and otherwise blocks.\n+    /// 3. Create the decision tree and record the places that we bind or test.\n+    /// 4. Determine the fake borrows that are needed from the above places.\n+    ///    Create the required temporaries for them.\n+    /// 5. Create everything else: Create everything else: the guards and the\n+    ///    arms.\n+    ///\n+    /// ## Fake Reads and borrows\n+    ///\n+    /// Match exhaustiveness checking is not able to handle the case where the\n+    /// place being matched on is mutated in the guards. There is an AST check\n+    /// that tries to stop this but it is buggy and overly restrictive. Instead\n+    /// we add \"fake borrows\" to the guards that prevent any mutation of the\n+    /// place being matched. There are a some subtleties:\n+    ///\n+    /// 1. Borrowing `*x` doesn't prevent assigning to `x`. If `x` is a shared\n+    ///    refence, the borrow isn't even tracked. As such we have to add fake\n+    ///    borrows of any prefixes of a place\n+    /// 2. We don't want `match x { _ => (), }` to conflict with mutable\n+    ///    borrows of `x`, so we only add fake borrows for places which are\n+    ///    bound or tested by the match.\n+    /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n+    ///    so we use a special BorrowKind for them.\n+    /// 4. The fake borrows may be of places in inactive variants, so it would\n+    ///    be UB to generate code for them. They therefore have to be removed\n+    ///    by a MIR pass run after borrow checking.\n+    ///\n+    /// ## False edges\n+    ///\n+    /// We don't want to have the exact structure of the decision tree be\n+    /// visible through borrow checking. False edges ensure that the CFG as\n+    /// seen by borrow checking doesn't encode this. False edges are added:\n+    ///\n+    /// * From each prebinding block to the next prebinding block.\n+    /// * From each otherwise block to the next prebinding block.\n     pub fn match_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n-        discriminant: ExprRef<'tcx>,\n+        scrutinee: ExprRef<'tcx>,\n         arms: Vec<Arm<'tcx>>,\n     ) -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n-        let discriminant_span = discriminant.span();\n-        let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n-        // Matching on a `discriminant_place` with an uninhabited type doesn't\n+        // Step 1. Evaluate the scrutinee and add the fake read of it.\n+\n+        let scrutinee_span = scrutinee.span();\n+        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n+\n+        // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n         // field projections, we wouldn't know to require an `unsafe` block\n         // around a `match` equivalent to `std::intrinsics::unreachable()`.\n         // See issue #47412 for this hole being discovered in the wild.\n         //\n         // HACK(eddyb) Work around the above issue by adding a dummy inspection\n-        // of `discriminant_place`, specifically by applying `ReadForMatch`.\n+        // of `scrutinee_place`, specifically by applying `ReadForMatch`.\n         //\n-        // NOTE: ReadForMatch also checks that the discriminant is initialized.\n+        // NOTE: ReadForMatch also checks that the scrutinee is initialized.\n         // This is currently needed to not allow matching on an uninitialized,\n         // uninhabited value. If we get never patterns, those will check that\n         // the place is initialized, and so this read would only be used to\n         // check safety.\n \n-        let source_info = self.source_info(discriminant_span);\n+        let source_info = self.source_info(scrutinee_span);\n         self.cfg.push(block, Statement {\n             source_info,\n             kind: StatementKind::FakeRead(\n                 FakeReadCause::ForMatchedPlace,\n-                discriminant_place.clone(),\n+                scrutinee_place.clone(),\n             ),\n         });\n \n-        let mut arm_blocks = ArmBlocks {\n-            blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n-        };\n-\n-        // Get the arm bodies and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter()\n-            .map(|arm| {\n-                // BUG: use arm lint level\n-                let body = self.hir.mirror(arm.body.clone());\n-                let scope = self.declare_bindings(\n-                    None,\n-                    body.span,\n-                    LintLevel::Inherited,\n-                    &arm.patterns[..],\n-                    ArmHasGuard(arm.guard.is_some()),\n-                    Some((Some(&discriminant_place), discriminant_span)),\n-                );\n-                (body, scope.unwrap_or(self.source_scope))\n-            })\n-            .collect();\n+        // Step 2. Create the otherwise and prebinding blocks.\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> = (0..=candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n-        let mut has_guard = false;\n-\n-        // assemble a list of candidates: there is one candidate per\n-        // pattern, which means there may be more than one candidate\n-        // *per arm*. These candidates are kept sorted such that the\n-        // highest priority candidate comes first in the list.\n-        // (i.e., same order as in source)\n-\n-        let candidates: Vec<_> = arms.iter()\n-            .enumerate()\n-            .flat_map(|(arm_index, arm)| {\n-                arm.patterns\n-                    .iter()\n-                    .enumerate()\n-                    .map(move |(pat_index, pat)| (arm_index, pat_index, pat, arm.guard.clone()))\n-            })\n-            .zip(\n-                pre_binding_blocks\n-                    .iter()\n-                    .zip(pre_binding_blocks.iter().skip(1)),\n-            )\n-            .map(\n-                |(\n-                    (arm_index, pat_index, pattern, guard),\n-                    (pre_binding_block, next_candidate_pre_binding_block)\n-                )| {\n-                    has_guard |= guard.is_some();\n-\n-                    // One might ask: why not build up the match pair such that it\n-                    // matches via `borrowed_input_temp.deref()` instead of\n-                    // using the `discriminant_place` directly, as it is doing here?\n-                    //\n-                    // The basic answer is that if you do that, then you end up with\n-                    // accceses to a shared borrow of the input and that conflicts with\n-                    // any arms that look like e.g.\n-                    //\n-                    // match Some(&4) {\n-                    //     ref mut foo => {\n-                    //         ... /* mutate `foo` in arm body */ ...\n-                    //     }\n-                    // }\n-                    //\n-                    // (Perhaps we could further revise the MIR\n-                    //  construction here so that it only does a\n-                    //  shared borrow at the outset and delays doing\n-                    //  the mutable borrow until after the pattern is\n-                    //  matched *and* the guard (if any) for the arm\n-                    //  has been run.)\n-\n-                    Candidate {\n-                        span: pattern.span,\n-                        match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],\n-                        bindings: vec![],\n-                        ascriptions: vec![],\n-                        guard,\n-                        arm_index,\n-                        pat_index,\n-                        pre_binding_block: *pre_binding_block,\n-                        next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n-                    }\n-                },\n-            )\n-            .collect();\n-\n+        // There's one more pre_binding block than there are candidates so that\n+        // every candidate can have a `next_candidate_pre_binding_block`.\n         let outer_source_info = self.source_info(span);\n         self.cfg.terminate(\n             *pre_binding_blocks.last().unwrap(),\n             outer_source_info,\n             TerminatorKind::Unreachable,\n         );\n \n-        // Maps a place to the kind of Fake borrow that we want to perform on\n-        // it: either Shallow or Shared, depending on whether the place is\n-        // bound in the match, or just switched on.\n-        // If there are no match guards then we don't need any fake borrows,\n-        // so don't track them.\n-        let mut fake_borrows = if has_guard && tcx.generate_borrow_of_any_match_input() {\n-            Some(FxHashMap::default())\n+        let mut match_has_guard = false;\n+\n+        let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n+        let mut next_candidate_pre_binding_blocks = pre_binding_blocks.iter().skip(1);\n+\n+        // Assemble a list of candidates: there is one candidate per pattern,\n+        // which means there may be more than one candidate *per arm*.\n+        let mut arm_candidates: Vec<_> = arms\n+            .iter()\n+            .map(|arm| {\n+                let arm_has_guard = arm.guard.is_some();\n+                match_has_guard |= arm_has_guard;\n+                let arm_candidates: Vec<_> = arm.patterns\n+                    .iter()\n+                    .zip(candidate_pre_binding_blocks.by_ref())\n+                    .zip(next_candidate_pre_binding_blocks.by_ref())\n+                    .map(\n+                        |((pattern, pre_binding_block), next_candidate_pre_binding_block)| {\n+                            Candidate {\n+                                span: pattern.span,\n+                                match_pairs: vec![\n+                                    MatchPair::new(scrutinee_place.clone(), pattern),\n+                                ],\n+                                bindings: vec![],\n+                                ascriptions: vec![],\n+                                otherwise_block: if arm_has_guard {\n+                                    Some(self.cfg.start_new_block())\n+                                } else {\n+                                    None\n+                                },\n+                                pre_binding_block: *pre_binding_block,\n+                                next_candidate_pre_binding_block:\n+                                    *next_candidate_pre_binding_block,\n+                            }\n+                        },\n+                    )\n+                    .collect();\n+                (arm, arm_candidates)\n+            })\n+            .collect();\n+\n+        // Step 3. Create the decision tree and record the places that we bind or test.\n+\n+        // The set of places that we are creating fake borrows of. If there are\n+        // no match guards then we don't need any fake borrows, so don't track\n+        // them.\n+        let mut fake_borrows = if match_has_guard && tcx.generate_borrow_of_any_match_input() {\n+            Some(FxHashSet::default())\n         } else {\n             None\n         };\n \n-        let pre_binding_blocks: Vec<_> = candidates\n-            .iter()\n-            .map(|cand| (cand.pre_binding_block, cand.span))\n-            .collect();\n+        // These candidates are kept sorted such that the highest priority\n+        // candidate comes first in the list. (i.e., same order as in source)\n+        // As we gnerate the decision tree,\n+        let candidates = &mut arm_candidates\n+            .iter_mut()\n+            .flat_map(|(_, candidates)| candidates)\n+            .collect::<Vec<_>>();\n \n-        // this will generate code to test discriminant_place and\n+        // this will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n         let otherwise = self.match_candidates(\n-            discriminant_span,\n-            &mut arm_blocks,\n+            scrutinee_span,\n             candidates,\n             block,\n             &mut fake_borrows,\n@@ -197,36 +230,70 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // In that case, the inexhaustive tips of the decision tree\n             // can't be reached - terminate them with an `unreachable`.\n-            let source_info = self.source_info(span);\n-\n             let mut otherwise = otherwise;\n             otherwise.sort();\n             otherwise.dedup(); // variant switches can introduce duplicate target blocks\n             for block in otherwise {\n                 self.cfg\n-                    .terminate(block, source_info, TerminatorKind::Unreachable);\n+                    .terminate(block, outer_source_info, TerminatorKind::Unreachable);\n             }\n         }\n \n-        if let Some(fake_borrows) = fake_borrows {\n-            self.add_fake_borrows(&pre_binding_blocks, fake_borrows, source_info, block);\n-        }\n+        // Step 4. Determine the fake borrows that are needed from the above\n+        // places. Create the required temporaries for them.\n \n-        // all the arm blocks will rejoin here\n-        let end_block = self.cfg.start_new_block();\n+        let fake_borrow_temps = if let Some(ref borrows) = fake_borrows {\n+            self.calculate_fake_borrows(borrows, scrutinee_span)\n+        } else {\n+            Vec::new()\n+        };\n+\n+        // Step 5. Create everything else: the guards and the arms.\n \n         let outer_source_info = self.source_info(span);\n-        for (arm_index, (body, source_scope)) in arm_bodies.into_iter().enumerate() {\n-            let mut arm_block = arm_blocks.blocks[arm_index];\n-            // Re-enter the source scope we created the bindings in.\n-            self.source_scope = source_scope;\n+        let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, candidates)| {\n+            let mut arm_block = self.cfg.start_new_block();\n+\n+            let body = self.hir.mirror(arm.body.clone());\n+            let scope = self.declare_bindings(\n+                None,\n+                body.span,\n+                LintLevel::Inherited,\n+                &arm.patterns[0],\n+                ArmHasGuard(arm.guard.is_some()),\n+                Some((Some(&scrutinee_place), scrutinee_span)),\n+            );\n+\n+            for candidate in candidates {\n+                self.bind_and_guard_matched_candidate(\n+                    candidate,\n+                    arm.guard.clone(),\n+                    arm_block,\n+                    &fake_borrow_temps,\n+                    scrutinee_span,\n+                );\n+            }\n+\n+            if let Some(source_scope) = scope {\n+                self.source_scope = source_scope;\n+            }\n+\n             unpack!(arm_block = self.into(destination, arm_block, body));\n+\n+            arm_block\n+        }).collect();\n+\n+        // all the arm blocks will rejoin here\n+        let end_block = self.cfg.start_new_block();\n+\n+        for arm_block in arm_end_blocks {\n             self.cfg.terminate(\n                 arm_block,\n                 outer_source_info,\n                 TerminatorKind::Goto { target: end_block },\n             );\n         }\n+\n         self.source_scope = outer_source_info.scope;\n \n         end_block.unit()\n@@ -359,11 +426,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n             ascriptions: vec![],\n-            guard: None,\n \n-            // since we don't call `match_candidates`, next fields is unused\n-            arm_index: 0,\n-            pat_index: 0,\n+            // since we don't call `match_candidates`, next fields are unused\n+            otherwise_block: None,\n             pre_binding_block: block,\n             next_candidate_pre_binding_block: block,\n         };\n@@ -418,7 +483,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n         lint_level: LintLevel,\n-        patterns: &[Pattern<'tcx>],\n+        pattern: &Pattern<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n@@ -427,10 +492,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"can't have both a visibility and a lint scope at the same time\"\n         );\n         let mut scope = self.source_scope;\n-        let num_patterns = patterns.len();\n-        debug!(\"declare_bindings: patterns={:?}\", patterns);\n+        debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_bindings(\n-            &patterns[0],\n+            &pattern,\n             UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n@@ -451,13 +515,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     mutability,\n                     name,\n                     mode,\n-                    num_patterns,\n                     var,\n                     ty,\n                     user_ty,\n                     has_guard,\n                     opt_match_place.map(|(x, y)| (x.cloned(), y)),\n-                    patterns[0].span,\n+                    pattern.span,\n                 );\n             },\n         );\n@@ -613,13 +676,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// List of blocks for each arm (and potentially other metadata in the\n-/// future).\n-struct ArmBlocks {\n-    blocks: Vec<BasicBlock>,\n-}\n-\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct Candidate<'pat, 'tcx: 'pat> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n@@ -630,21 +687,15 @@ pub struct Candidate<'pat, 'tcx: 'pat> {\n     // ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n \n-    // ...these types asserted...\n+    // ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    // ...and the guard must be evaluated...\n-    guard: Option<Guard<'tcx>>,\n-\n-    // ...and then we branch to arm with this index.\n-    arm_index: usize,\n+    // ...and the guard must be evaluated, if false branch to Block...\n+    otherwise_block: Option<BasicBlock>,\n \n     // ...and the blocks for add false edges between candidates\n     pre_binding_block: BasicBlock,\n     next_candidate_pre_binding_block: BasicBlock,\n-\n-    // This uniquely identifies this candidate *within* the arm.\n-    pat_index: usize,\n }\n \n #[derive(Clone, Debug)]\n@@ -676,13 +727,6 @@ pub struct MatchPair<'pat, 'tcx: 'pat> {\n \n     // ... must match this pattern.\n     pattern: &'pat Pattern<'tcx>,\n-\n-    // HACK(eddyb) This is used to toggle whether a Slice pattern\n-    // has had its length checked. This is only necessary because\n-    // the \"rest\" part of the pattern right now has type &[T] and\n-    // as such, it requires an Rvalue::Slice to be generated.\n-    // See RFC 495 / issue #23121 for the eventual (proper) solution.\n-    slice_len_checked: bool,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -722,6 +766,11 @@ pub struct Test<'tcx> {\n     kind: TestKind<'tcx>,\n }\n \n+/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// a match arm has a guard expression attached to it.\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct ArmHasGuard(pub bool);\n+\n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n \n@@ -732,7 +781,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n     /// the value, we will generate a branch to the appropriate\n-    /// block found in `arm_blocks`.\n+    /// prebinding block.\n     ///\n     /// The return value is a list of \"otherwise\" blocks. These are\n     /// points in execution where we found that *NONE* of the\n@@ -747,32 +796,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n     ///\n-    /// If `add_fake_borrows` is true, then places which need fake borrows\n+    /// If `fake_borrows` is Some, then places which need fake borrows\n     /// will be added to it.\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n-        arm_blocks: &mut ArmBlocks,\n-        mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+        candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         mut block: BasicBlock,\n-        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Vec<BasicBlock> {\n         debug!(\n             \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n             span, block, candidates\n         );\n \n-        // Start by simplifying candidates. Once this process is\n-        // complete, all the match pairs which remain require some\n-        // form of test, whether it be a switch or pattern comparison.\n-        for candidate in &mut candidates {\n+        // Start by simplifying candidates. Once this process is complete, all\n+        // the match pairs which remain require some form of test, whether it\n+        // be a switch or pattern comparison.\n+        for candidate in &mut *candidates {\n             self.simplify_candidate(candidate);\n         }\n \n-        // The candidates are sorted by priority. Check to see\n-        // whether the higher priority candidates (and hence at\n-        // the front of the vec) have satisfied all their match\n-        // pairs.\n+        // The candidates are sorted by priority. Check to see whether the\n+        // higher priority candidates (and hence at the front of the slice)\n+        // have satisfied all their match pairs.\n         let fully_matched = candidates\n             .iter()\n             .take_while(|c| c.match_pairs.is_empty())\n@@ -781,87 +828,192 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"match_candidates: {:?} candidates fully matched\",\n             fully_matched\n         );\n-        let mut unmatched_candidates = candidates.split_off(fully_matched);\n-\n-        // Insert a *Shared* borrow of any places that are bound.\n-        if let Some(fake_borrows) = fake_borrows {\n-            for Binding { source, .. }\n-                in candidates.iter().flat_map(|candidate| &candidate.bindings)\n-            {\n-                fake_borrows.insert(source.clone(), BorrowKind::Shared);\n-            }\n-        }\n-\n-        let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n-\n-        let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n-            candidates.split_off(fully_matched_with_guard + 1)\n-        } else {\n-            vec![]\n-        };\n+        let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n \n-        for candidate in candidates {\n-            // If so, apply any bindings, test the guard (if any), and\n-            // branch to the arm.\n-            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n-                block = b;\n+        if !matched_candidates.is_empty() {\n+            block = if let Some(last_otherwise_block) = self.select_matched_candidates(\n+                matched_candidates,\n+                block,\n+                fake_borrows,\n+            ) {\n+                last_otherwise_block\n             } else {\n-                // if None is returned, then any remaining candidates\n-                // are unreachable (at least not through this path).\n-                // Link them with false edges.\n-                debug!(\n-                    \"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n-                    unreachable_candidates, unmatched_candidates\n-                );\n-                for candidate in unreachable_candidates {\n-                    let source_info = self.source_info(candidate.span);\n-                    let target = self.cfg.start_new_block();\n-                    if let Some(otherwise) =\n-                        self.bind_and_guard_matched_candidate(target, arm_blocks, candidate)\n-                    {\n-                        self.cfg\n-                            .terminate(otherwise, source_info, TerminatorKind::Unreachable);\n-                    }\n-                }\n-\n+                // Any remaining candidates are unreachable.\n                 if unmatched_candidates.is_empty() {\n-                    return vec![];\n+                    return Vec::new();\n                 } else {\n-                    let target = self.cfg.start_new_block();\n-                    return self.match_candidates(\n-                        span,\n-                        arm_blocks,\n-                        unmatched_candidates,\n-                        target,\n-                        &mut None,\n-                    );\n+                    self.cfg.start_new_block()\n                 }\n-            }\n+            };\n         }\n \n-        // If there are no candidates that still need testing, we're done.\n-        // Since all matches are exhaustive, execution should never reach this point.\n+        // If there are no candidates that still need testing, we're\n+        // done. Since all matches are exhaustive, execution should\n+        // never reach this point.\n         if unmatched_candidates.is_empty() {\n             return vec![block];\n         }\n \n         // Test candidates where possible.\n-        let (otherwise, tested_candidates) =\n-            self.test_candidates(span, arm_blocks, &unmatched_candidates, block, fake_borrows);\n+        let (otherwise, untested_candidates) = self.test_candidates(\n+            span,\n+            unmatched_candidates,\n+            block,\n+            fake_borrows,\n+        );\n \n         // If the target candidates were exhaustive, then we are done.\n         // But for borrowck continue build decision tree.\n-\n-        // If all candidates were sorted into `target_candidates` somewhere, then\n-        // the initial set was inexhaustive.\n-        let untested_candidates = unmatched_candidates.split_off(tested_candidates);\n-        if untested_candidates.len() == 0 {\n+        if untested_candidates.is_empty() {\n             return otherwise;\n         }\n \n         // Otherwise, let's process those remaining candidates.\n         let join_block = self.join_otherwise_blocks(span, otherwise);\n-        self.match_candidates(span, arm_blocks, untested_candidates, join_block, &mut None)\n+        self.match_candidates(\n+            span,\n+            untested_candidates,\n+            join_block,\n+            &mut None,\n+        )\n+    }\n+\n+    /// Link up matched candidates. For example, if we have something like\n+    /// this:\n+    ///\n+    /// ...\n+    /// Some(x) if cond => ...\n+    /// Some(x) => ...\n+    /// Some(x) if cond => ...\n+    /// ...\n+    ///\n+    /// We generate real edges from:\n+    /// * `block` to the prebinding_block of the first pattern,\n+    /// * the otherwise block of the first pattern to the second pattern,\n+    /// * the otherwise block of the third pattern to the a block with an\n+    ///   Unreachable terminator.\n+    ///\n+    /// As well as that we add fake edges from the otherwise blocks to the\n+    /// prebinding block of the next candidate in the original set of\n+    /// candidates.\n+    fn select_matched_candidates(\n+        &mut self,\n+        matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n+        block: BasicBlock,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) -> Option<BasicBlock> {\n+        debug_assert!(\n+            !matched_candidates.is_empty(),\n+            \"select_matched_candidates called with no candidates\",\n+        );\n+\n+        // Insert a borrows of prefixes of places that are bound and are\n+        // behind a dereference projection.\n+        //\n+        // These borrows are taken to avoid situations like the following:\n+        //\n+        // match x[10] {\n+        //     _ if { x = &[0]; false } => (),\n+        //     y => (), // Out of bounds array access!\n+        // }\n+        //\n+        // match *x {\n+        //     // y is bound by reference in the guard and then by copy in the\n+        //     // arm, so y is 2 in the arm!\n+        //     y if { y == 1 && (x = &2) == () } => y,\n+        //     _ => 3,\n+        // }\n+        if let Some(fake_borrows) = fake_borrows {\n+            for Binding { source, .. }\n+                in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n+            {\n+                let mut cursor = source;\n+                while let Place::Projection(box Projection { base, elem }) = cursor {\n+                    cursor = base;\n+                    if let ProjectionElem::Deref = elem {\n+                        fake_borrows.insert(cursor.clone());\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let fully_matched_with_guard = matched_candidates\n+            .iter()\n+            .position(|c| c.otherwise_block.is_none())\n+            .unwrap_or(matched_candidates.len() - 1);\n+\n+        let (reachable_candidates, unreachable_candidates)\n+            = matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n+\n+        let first_candidate = &reachable_candidates[0];\n+\n+        let candidate_source_info = self.source_info(first_candidate.span);\n+\n+        self.cfg.terminate(\n+            block,\n+            candidate_source_info,\n+            TerminatorKind::Goto {\n+                target: first_candidate.pre_binding_block,\n+            },\n+        );\n+\n+        for window in reachable_candidates.windows(2) {\n+            if let [first_candidate, second_candidate] = window {\n+                let source_info = self.source_info(first_candidate.span);\n+                if let Some(otherwise_block) = first_candidate.otherwise_block {\n+                    self.cfg.terminate(\n+                        otherwise_block,\n+                        source_info,\n+                        TerminatorKind::FalseEdges {\n+                            real_target: second_candidate.pre_binding_block,\n+                            imaginary_targets: vec![\n+                                first_candidate.next_candidate_pre_binding_block\n+                            ],\n+                        }\n+                    )\n+                } else {\n+                    bug!(\"candidate other than the last has no guard\");\n+                }\n+            } else {\n+                bug!(\"<[_]>::windows returned incorrectly sized window\");\n+            }\n+        }\n+\n+        debug!(\"match_candidates: add false edges for unreachable {:?}\", unreachable_candidates);\n+        for candidate in unreachable_candidates {\n+            if let Some(otherwise) = candidate.otherwise_block {\n+                let source_info = self.source_info(candidate.span);\n+                let unreachable = self.cfg.start_new_block();\n+                self.cfg.terminate(\n+                    otherwise,\n+                    source_info,\n+                    TerminatorKind::FalseEdges {\n+                        real_target: unreachable,\n+                        imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+                    }\n+                );\n+                self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n+            }\n+        }\n+\n+        let last_candidate = reachable_candidates.last().unwrap();\n+\n+        if let Some(otherwise) = last_candidate.otherwise_block {\n+            let source_info = self.source_info(last_candidate.span);\n+            let block = self.cfg.start_new_block();\n+            self.cfg.terminate(\n+                otherwise,\n+                source_info,\n+                TerminatorKind::FalseEdges {\n+                    real_target: block,\n+                    imaginary_targets: vec![last_candidate.next_candidate_pre_binding_block]\n+                }\n+            );\n+            Some(block)\n+        } else {\n+            None\n+        }\n     }\n \n     fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n@@ -995,17 +1147,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// In addition to avoiding exponential-time blowups, this algorithm\n     /// also has nice property that each guard and arm is only generated\n     /// once.\n-    fn test_candidates<'pat>(\n+    fn test_candidates<'pat, 'b, 'c>(\n         &mut self,\n         span: Span,\n-        arm_blocks: &mut ArmBlocks,\n-        candidates: &[Candidate<'pat, 'tcx>],\n+        mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n-        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n-    ) -> (Vec<BasicBlock>, usize) {\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) -> (Vec<BasicBlock>, &'b mut [&'c mut Candidate<'pat, 'tcx>]) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n+        let match_place = match_pair.place.clone();\n \n         // most of the time, the test to perform is simply a function\n         // of the main candidate; but for a test like SwitchInt, we\n@@ -1019,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(\n-                        &match_pair.place,\n+                        &match_place,\n                         candidate,\n                         switch_ty,\n                         options,\n@@ -1034,7 +1186,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref mut variants,\n             } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_pair.place, candidate, variants) {\n+                    if !self.add_variants_to_switch(&match_place, candidate, variants) {\n                         break;\n                     }\n                 }\n@@ -1044,7 +1196,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         fake_borrows.as_mut().map(|fb| {\n-            fb.entry(match_pair.place.clone()).or_insert(BorrowKind::Shallow)\n+            fb.insert(match_place.clone())\n         });\n \n         // perform the test, branching to one of N blocks. For each of\n@@ -1055,25 +1207,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"match_candidates: test={:?} match_pair={:?}\",\n             test, match_pair\n         );\n-        let target_blocks = self.perform_test(block, &match_pair.place, &test);\n-        let mut target_candidates = vec![vec![]; target_blocks.len()];\n+        let target_blocks = self.perform_test(block, &match_place, &test);\n+        let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n+        target_candidates.resize_with(target_blocks.len(), Default::default);\n+\n+        let total_candidate_count = candidates.len();\n \n         // Sort the candidates into the appropriate vector in\n         // `target_candidates`. Note that at some point we may\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n-        let tested_candidates = candidates\n-            .iter()\n-            .take_while(|c| {\n-                self.sort_candidate(&match_pair.place, &test, c, &mut target_candidates)\n-            })\n-            .count();\n-        assert!(tested_candidates > 0); // at least the last candidate ought to be tested\n-        debug!(\"tested_candidates: {}\", tested_candidates);\n-        debug!(\n-            \"untested_candidates: {}\",\n-            candidates.len() - tested_candidates\n-        );\n+        while let Some(candidate) = candidates.first_mut() {\n+            if let Some(idx) = self.sort_candidate(&match_place, &test, candidate) {\n+                let (candidate, rest) = candidates.split_first_mut().unwrap();\n+                target_candidates[idx].push(candidate);\n+                candidates = rest;\n+            } else {\n+                break;\n+            }\n+        }\n+        // at least the first candidate ought to be tested\n+        assert!(total_candidate_count > candidates.len());\n+        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"untested_candidates: {}\", candidates.len());\n \n         // For each outcome of test, process the candidates that still\n         // apply. Collect a list of blocks where control flow will\n@@ -1082,59 +1238,98 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let otherwise: Vec<_> = target_blocks\n             .into_iter()\n             .zip(target_candidates)\n-            .flat_map(|(target_block, target_candidates)| {\n+            .flat_map(|(target_block, mut target_candidates)| {\n                 self.match_candidates(\n                     span,\n-                    arm_blocks,\n-                    target_candidates,\n+                    &mut *target_candidates,\n                     target_block,\n                     fake_borrows,\n                 )\n             })\n             .collect();\n \n-        (otherwise, tested_candidates)\n+        (otherwise, candidates)\n+    }\n+\n+    // Determine the fake borrows that are needed to ensure that the place\n+    // will evaluate to the same thing until an arm has been chosen.\n+    fn calculate_fake_borrows<'b>(\n+        &mut self,\n+        fake_borrows: &'b FxHashSet<Place<'tcx>>,\n+        temp_span: Span,\n+    ) -> Vec<(&'b Place<'tcx>, Local)> {\n+        let tcx = self.hir.tcx();\n+\n+        debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n+\n+        let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n+\n+        // Insert a Shallow borrow of the prefixes of any fake borrows.\n+        for place in fake_borrows\n+        {\n+            let mut prefix_cursor = place;\n+            while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n+                if let ProjectionElem::Deref = elem {\n+                    // Insert a shallow borrow after a deref. For other\n+                    // projections the borrow of prefix_cursor will\n+                    // conflict with any mutation of base.\n+                    all_fake_borrows.push(base);\n+                }\n+                prefix_cursor = base;\n+            }\n+\n+            all_fake_borrows.push(place);\n+        }\n+\n+        // Deduplicate and ensure a deterministic order.\n+        all_fake_borrows.sort();\n+        all_fake_borrows.dedup();\n+\n+        debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n+\n+        all_fake_borrows.into_iter().map(|matched_place| {\n+            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).to_ty(tcx);\n+            let fake_borrow_ty = tcx.mk_imm_ref(tcx.types.re_erased, fake_borrow_deref_ty);\n+            let fake_borrow_temp = self.local_decls.push(\n+                LocalDecl::new_temp(fake_borrow_ty, temp_span)\n+            );\n+\n+            (matched_place, fake_borrow_temp)\n+        }).collect()\n     }\n+}\n \n+///////////////////////////////////////////////////////////////////////////\n+// Pattern binding - used for `let` and function parameters as well.\n+\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Initializes each of the bindings from the candidate by\n-    /// moving/copying/ref'ing the source as appropriate. Tests the\n-    /// guard, if any, and then branches to the arm. Returns the block\n-    /// for the case where the guard fails.\n+    /// moving/copying/ref'ing the source as appropriate. Tests the guard, if\n+    /// any, and then branches to the arm. Returns the block for the case where\n+    /// the guard fails.\n     ///\n-    /// Note: we check earlier that if there is a guard, there cannot\n-    /// be move bindings. This isn't really important for the\n-    /// self-consistency of this fn, but the reason for it should be\n-    /// clear: after we've done the assignments, if there were move\n-    /// bindings, further tests would be a use-after-move (which would\n-    /// in turn be detected by the borrowck code that runs on the\n-    /// MIR).\n+    /// Note: we check earlier that if there is a guard, there cannot be move\n+    /// bindings (unless feature(bind_by_move_pattern_guards) is used). This\n+    /// isn't really important for the self-consistency of this fn, but the\n+    /// reason for it should be clear: after we've done the assignments, if\n+    /// there were move bindings, further tests would be a use-after-move.\n+    /// bind_by_move_pattern_guards avoids this by only moving the binding once\n+    /// the guard has evaluated to true (see below).\n     fn bind_and_guard_matched_candidate<'pat>(\n         &mut self,\n-        mut block: BasicBlock,\n-        arm_blocks: &mut ArmBlocks,\n         candidate: Candidate<'pat, 'tcx>,\n-    ) -> Option<BasicBlock> {\n-        debug!(\n-            \"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n-            block, candidate\n-        );\n+        guard: Option<Guard<'tcx>>,\n+        arm_block: BasicBlock,\n+        fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n+        scrutinee_span: Span,\n+    ) {\n+        debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n-        self.ascribe_types(block, &candidate.ascriptions);\n-\n-        let arm_block = arm_blocks.blocks[candidate.arm_index];\n         let candidate_source_info = self.source_info(candidate.span);\n \n-        self.cfg.terminate(\n-            block,\n-            candidate_source_info,\n-            TerminatorKind::Goto {\n-                target: candidate.pre_binding_block,\n-            },\n-        );\n-\n-        block = self.cfg.start_new_block();\n+        let mut block = self.cfg.start_new_block();\n         self.cfg.terminate(\n             candidate.pre_binding_block,\n             candidate_source_info,\n@@ -1143,6 +1338,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n             },\n         );\n+        self.ascribe_types(block, &candidate.ascriptions);\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -1221,19 +1417,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //\n         //    * Here, the guard expression wants a `&&` or `&&mut`\n         //      into the original input. This means we need to borrow\n-        //      a reference that we do not immediately have at hand\n-        //      (because all we have is the places associated with the\n-        //      match input itself; it is up to us to create a place\n-        //      holding a `&` or `&mut` that we can then borrow).\n-\n-        let autoref = self.hir\n-            .tcx()\n-            .all_pat_vars_are_implicit_refs_within_guards();\n-        if let Some(guard) = candidate.guard {\n+        //      the reference that we create for the arm.\n+        //    * So we eagerly create the reference for the arm and then take a\n+        //      reference to that.\n+        let tcx = self.hir.tcx();\n+        let autoref = tcx.all_pat_vars_are_implicit_refs_within_guards();\n+        if let Some(guard) = guard {\n             if autoref {\n                 self.bind_matched_candidate_for_guard(\n                     block,\n-                    candidate.pat_index,\n                     &candidate.bindings,\n                 );\n                 let guard_frame = GuardFrame {\n@@ -1249,12 +1441,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n             }\n \n+            let re_erased = tcx.types.re_erased;\n+            let scrutinee_source_info = self.source_info(scrutinee_span);\n+            for &(place, temp) in fake_borrows {\n+                let borrow = Rvalue::Ref(\n+                    re_erased,\n+                    BorrowKind::Shallow,\n+                    place.clone(),\n+                );\n+                self.cfg.push_assign(\n+                    block,\n+                    scrutinee_source_info,\n+                    &Place::Local(temp),\n+                    borrow,\n+                );\n+            }\n+\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = match guard {\n                 Guard::If(e) => self.hir.mirror(e),\n             };\n             let source_info = self.source_info(guard.span);\n+            let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {\n                 let guard_frame = self.guard_context.pop().unwrap();\n@@ -1264,7 +1473,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let false_edge_block = self.cfg.start_new_block();\n+            for &(_, temp) in fake_borrows {\n+                self.cfg.push(block, Statement {\n+                    source_info: guard_end,\n+                    kind: StatementKind::FakeRead(\n+                        FakeReadCause::ForMatchGuard,\n+                        Place::Local(temp),\n+                    ),\n+                });\n+            }\n \n             // We want to ensure that the matched candidates are bound\n             // after we have confirmed this candidate *and* any\n@@ -1296,31 +1513,44 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.cfg.terminate(\n                 block,\n                 source_info,\n-                TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block, false_edge_block),\n+                TerminatorKind::if_(\n+                    self.hir.tcx(),\n+                    cond,\n+                    post_guard_block,\n+                    candidate.otherwise_block.unwrap()\n+                ),\n             );\n \n             if autoref {\n-                self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n+                let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n+                    if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n+                });\n+                // Read all of the by reference bindings to ensure that the\n+                // place they refer to can't be modified by the guard.\n+                for binding in by_value_bindings.clone() {\n+                    let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n+                    let place = Place::Local(local_id);\n+                    self.cfg.push(\n+                        block,\n+                        Statement {\n+                            source_info: guard_end,\n+                            kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),\n+                        },\n+                    );\n+                }\n+                self.bind_matched_candidate_for_arm_body(\n+                    post_guard_block,\n+                    by_value_bindings,\n+                );\n             }\n \n             self.cfg.terminate(\n                 post_guard_block,\n                 source_info,\n                 TerminatorKind::Goto { target: arm_block },\n             );\n-\n-            let otherwise = self.cfg.start_new_block();\n-\n-            self.cfg.terminate(\n-                false_edge_block,\n-                source_info,\n-                TerminatorKind::FalseEdges {\n-                    real_target: otherwise,\n-                    imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n-                },\n-            );\n-            Some(otherwise)\n         } else {\n+            assert!(candidate.otherwise_block.is_none());\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n@@ -1330,7 +1560,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 candidate_source_info,\n                 TerminatorKind::Goto { target: arm_block },\n             );\n-            None\n         }\n     }\n \n@@ -1375,13 +1604,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn bind_matched_candidate_for_guard(\n         &mut self,\n         block: BasicBlock,\n-        pat_index: usize,\n         bindings: &[Binding<'tcx>],\n     ) {\n-        debug!(\n-            \"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n-            block, pat_index, bindings\n-        );\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\", block, bindings);\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1397,8 +1622,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let ref_for_guard =\n                 self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n-            // shared-&'s?  Answer: Because schedule_drop_for_binding\n-            // also emits StorageDead's for those locals.\n+            // shared-&'s?\n+            // Answer: Because schedule_drop_for_binding also emits\n+            // StorageDead's for those locals.\n             self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n@@ -1407,66 +1633,35 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(borrow_kind) => {\n-                    // Tricky business: For `ref id` and `ref mut id`\n-                    // patterns, we want `id` within the guard to\n-                    // correspond to a temp of type `& &T` or `& &mut\n-                    // T` (i.e., a \"borrow of a borrow\") that is\n-                    // implicitly dereferenced.\n-                    //\n-                    // To borrow a borrow, we need that inner borrow\n-                    // to point to. So, create a temp for the inner\n-                    // borrow, and then take a reference to it.\n-                    //\n-                    // Note: the temp created here is *not* the one\n-                    // used by the arm body itself. This eases\n-                    // observing two-phase borrow restrictions.\n-                    let val_for_guard = self.storage_live_binding(\n+                    let value_for_arm = self.storage_live_binding(\n                         block,\n                         binding.var_id,\n                         binding.span,\n-                        ValWithinGuard(pat_index),\n+                        OutsideGuard,\n                     );\n                     self.schedule_drop_for_binding(\n                         binding.var_id,\n                         binding.span,\n-                        ValWithinGuard(pat_index),\n+                        OutsideGuard,\n                     );\n \n-                    // rust-lang/rust#27282: We reuse the two-phase\n-                    // borrow infrastructure so that the mutable\n-                    // borrow (whose mutabilty is *unusable* within\n-                    // the guard) does not conflict with the implicit\n-                    // borrow of the whole match input. See additional\n-                    // discussion on rust-lang/rust#49870.\n-                    let borrow_kind = match borrow_kind {\n-                        BorrowKind::Shared\n-                        | BorrowKind::Shallow\n-                        | BorrowKind::Unique => borrow_kind,\n-                        BorrowKind::Mut { .. } => BorrowKind::Mut {\n-                            allow_two_phase_borrow: true,\n-                        },\n-                    };\n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source.clone());\n                     self.cfg\n-                        .push_assign(block, source_info, &val_for_guard, rvalue);\n-                    let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, val_for_guard);\n+                        .push_assign(block, source_info, &value_for_arm, rvalue);\n+                    let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, value_for_arm);\n                     self.cfg\n                         .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n-    fn bind_matched_candidate_for_arm_body(\n+    fn bind_matched_candidate_for_arm_body<'b>(\n         &mut self,\n         block: BasicBlock,\n-        bindings: &[Binding<'tcx>],\n-    ) {\n-        debug!(\n-            \"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\",\n-            block, bindings\n-        );\n-\n+        bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n+    ) where 'tcx: 'b {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?})\", block);\n \n         let re_erased = self.hir.tcx().types.re_erased;\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n@@ -1487,29 +1682,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n-    /// the bound `var` has type `T` in the arm body) in a pattern\n-    /// maps to `2+N` locals. The first local is a binding for\n-    /// occurrences of `var` in the guard, which will all have type\n-    /// `&T`. The N locals are bindings for the `T` that is referenced\n-    /// by the first local; they are not used outside of the\n-    /// guard. The last local is a binding for occurrences of `var` in\n-    /// the arm body, which will have type `T`.\n-    ///\n-    /// The reason we have N locals rather than just 1 is to\n-    /// accommodate rust-lang/rust#51348: If the arm has N candidate\n-    /// patterns, then in general they can correspond to distinct\n-    /// parts of the matched data, and we want them to be distinct\n-    /// temps in order to simplify checks performed by our internal\n-    /// leveraging of two-phase borrows).\n+    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where the bound\n+    /// `var` has type `T` in the arm body) in a pattern maps to 2 locals. The\n+    /// first local is a binding for occurrences of `var` in the guard, which\n+    /// will have type `&T`. The second local is a binding for occurrences of\n+    /// `var` in the arm body, which will have type `T`.\n     fn declare_binding(\n         &mut self,\n         source_info: SourceInfo,\n         visibility_scope: SourceScope,\n         mutability: Mutability,\n         name: Name,\n         mode: BindingMode,\n-        num_patterns: usize,\n         var_id: NodeId,\n         var_ty: Ty<'tcx>,\n         user_ty: UserTypeProjections<'tcx>,\n@@ -1551,31 +1735,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n-            let mut vals_for_guard = Vec::with_capacity(num_patterns);\n-            for _ in 0..num_patterns {\n-                let val_for_guard_idx = self.local_decls.push(LocalDecl {\n-                    // This variable isn't mutated but has a name, so has to be\n-                    // immutable to avoid the unused mut lint.\n-                    mutability: Mutability::Not,\n-                    ..local.clone()\n-                });\n-                vals_for_guard.push(val_for_guard_idx);\n-            }\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n-                // See previous comment.\n+                // This variable isn't mutated but has a name, so has to be\n+                // immutable to avoid the unused mut lint.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.types.re_erased, var_ty),\n                 user_ty: UserTypeProjections::none(),\n                 name: Some(name),\n                 source_info,\n                 visibility_scope,\n-                // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n                 is_block_tail: None,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::ForGuard {\n-                vals_for_guard,\n                 ref_for_guard,\n                 for_arm_body,\n             }\n@@ -1585,86 +1758,4 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n-\n-    // Determine the fake borrows that are needed to ensure that the place\n-    // will evaluate to the same thing until an arm has been chosen.\n-    fn add_fake_borrows<'pat>(\n-        &mut self,\n-        pre_binding_blocks: &[(BasicBlock, Span)],\n-        fake_borrows: FxHashMap<Place<'tcx>, BorrowKind>,\n-        source_info: SourceInfo,\n-        start_block: BasicBlock,\n-    ) {\n-        let tcx = self.hir.tcx();\n-\n-        debug!(\"add_fake_borrows pre_binding_blocks = {:?}, fake_borrows = {:?}\",\n-               pre_binding_blocks, fake_borrows);\n-\n-        let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n-\n-        // Insert a Shallow borrow of the prefixes of any fake borrows.\n-        for (place, borrow_kind) in fake_borrows\n-        {\n-            {\n-                let mut prefix_cursor = &place;\n-                while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n-                    if let ProjectionElem::Deref = elem {\n-                        // Insert a shallow borrow after a deref. For other\n-                        // projections the borrow of prefix_cursor will\n-                        // conflict with any mutation of base.\n-                        all_fake_borrows.push((base.clone(), BorrowKind::Shallow));\n-                    }\n-                    prefix_cursor = base;\n-                }\n-            }\n-\n-            all_fake_borrows.push((place, borrow_kind));\n-        }\n-\n-        // Deduplicate and ensure a deterministic order.\n-        all_fake_borrows.sort();\n-        all_fake_borrows.dedup();\n-\n-        debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n-\n-        // Add fake borrows to the start of the match and reads of them before\n-        // the start of each arm.\n-        let mut borrowed_input_temps = Vec::with_capacity(all_fake_borrows.len());\n-\n-        for (matched_place, borrow_kind) in all_fake_borrows {\n-            let borrowed_input =\n-                Rvalue::Ref(tcx.types.re_erased, borrow_kind, matched_place.clone());\n-            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n-            let borrowed_input_temp = self.temp(borrowed_input_ty, source_info.span);\n-            self.cfg.push_assign(\n-                start_block,\n-                source_info,\n-                &borrowed_input_temp,\n-                borrowed_input\n-            );\n-            borrowed_input_temps.push(borrowed_input_temp);\n-        }\n-\n-        // FIXME: This could be a lot of reads (#fake borrows * #patterns).\n-        // The false edges that we currently generate would allow us to only do\n-        // this on the last Candidate, but it's possible that there might not be\n-        // so many false edges in the future, so we read for all Candidates for\n-        // now.\n-        // Another option would be to make our own block and add our own false\n-        // edges to it.\n-        if tcx.emit_read_for_match() {\n-            for &(pre_binding_block, span) in pre_binding_blocks {\n-                let pattern_source_info = self.source_info(span);\n-                for temp in &borrowed_input_temps {\n-                    self.cfg.push(pre_binding_block, Statement {\n-                        source_info: pattern_source_info,\n-                        kind: StatementKind::FakeRead(\n-                            FakeReadCause::ForMatchGuard,\n-                            temp.clone(),\n-                        ),\n-                    });\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "72b92444dece9be37883af5998213616f8d597b5", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 99, "deletions": 167, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -69,8 +69,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix }\n-                    if !match_pair.slice_len_checked => {\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n                 let op = if slice.is_some() {\n                     BinOp::Ge\n@@ -85,7 +84,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n-            PatternKind::Slice { .. } |\n             PatternKind::Wild |\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n@@ -433,77 +431,65 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         target_block\n     }\n \n-    /// Given that we are performing `test` against `test_place`,\n-    /// this job sorts out what the status of `candidate` will be\n-    /// after the test. The `resulting_candidates` vector stores, for\n-    /// each possible outcome of `test`, a vector of the candidates\n-    /// that will result. This fn should add a (possibly modified)\n-    /// clone of candidate into `resulting_candidates` wherever\n-    /// appropriate.\n+    /// Given that we are performing `test` against `test_place`, this job\n+    /// sorts out what the status of `candidate` will be after the test. See\n+    /// `test_candidates` for the usage of this function. The returned index is\n+    /// the index that this candiate should be placed in the\n+    /// `target_candidates` vec. The candidate may be modified to update its\n+    /// `match_pairs`.\n     ///\n-    /// So, for example, if this candidate is `x @ Some(P0)` and the\n-    /// Tests is a variant test, then we would add `(x as Option).0 @\n-    /// P0` to the `resulting_candidates` entry corresponding to the\n-    /// variant `Some`.\n+    /// So, for example, if this candidate is `x @ Some(P0)` and the `Test` is\n+    /// a variant test, then we would modify the candidate to be `(x as\n+    /// Option).0 @ P0` and return the index corresponding to the variant\n+    /// `Some`.\n     ///\n-    /// However, in some cases, the test may just not be relevant to\n-    /// candidate. For example, suppose we are testing whether `foo.x == 22`,\n-    /// but in one match arm we have `Foo { x: _, ... }`... in that case,\n-    /// the test for what value `x` has has no particular relevance\n-    /// to this candidate. In such cases, this function just returns false\n-    /// without doing anything. This is used by the overall `match_candidates`\n-    /// algorithm to structure the match as a whole. See `match_candidates` for\n-    /// more details.\n+    /// However, in some cases, the test may just not be relevant to candidate.\n+    /// For example, suppose we are testing whether `foo.x == 22`, but in one\n+    /// match arm we have `Foo { x: _, ... }`... in that case, the test for\n+    /// what value `x` has has no particular relevance to this candidate. In\n+    /// such cases, this function just returns None without doing anything.\n+    /// This is used by the overall `match_candidates` algorithm to structure\n+    /// the match as a whole. See `match_candidates` for more details.\n     ///\n-    /// FIXME(#29623). In some cases, we have some tricky choices to\n-    /// make.  for example, if we are testing that `x == 22`, but the\n-    /// candidate is `x @ 13..55`, what should we do? In the event\n-    /// that the test is true, we know that the candidate applies, but\n-    /// in the event of false, we don't know that it *doesn't*\n-    /// apply. For now, we return false, indicate that the test does\n-    /// not apply to this candidate, but it might be we can get\n+    /// FIXME(#29623). In some cases, we have some tricky choices to make.  for\n+    /// example, if we are testing that `x == 22`, but the candidate is `x @\n+    /// 13..55`, what should we do? In the event that the test is true, we know\n+    /// that the candidate applies, but in the event of false, we don't know\n+    /// that it *doesn't* apply. For now, we return false, indicate that the\n+    /// test does not apply to this candidate, but it might be we can get\n     /// tighter match code if we do something a bit different.\n-    pub fn sort_candidate<'pat>(&mut self,\n-                                test_place: &Place<'tcx>,\n-                                test: &Test<'tcx>,\n-                                candidate: &Candidate<'pat, 'tcx>,\n-                                resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>])\n-                                -> bool {\n+    pub fn sort_candidate<'pat, 'cand>(\n+        &mut self,\n+        test_place: &Place<'tcx>,\n+        test: &Test<'tcx>,\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+    ) -> Option<usize> {\n         // Find the match_pair for this place (if any). At present,\n         // afaik, there can be at most one. (In the future, if we\n         // adopted a more general `@` operator, there might be more\n         // than one, but it'd be very unusual to have two sides that\n         // both require tests; you'd expect one side to be simplified\n         // away.)\n-        let tested_match_pair = candidate.match_pairs.iter()\n-                                                     .enumerate()\n-                                                     .find(|&(_, mp)| mp.place == *test_place);\n-        let (match_pair_index, match_pair) = match tested_match_pair {\n-            Some(pair) => pair,\n-            None => {\n-                // We are not testing this place. Therefore, this\n-                // candidate applies to ALL outcomes.\n-                return false;\n-            }\n-        };\n+        let (match_pair_index, match_pair) = candidate.match_pairs\n+            .iter()\n+            .enumerate()\n+            .find(|&(_, mp)| mp.place == *test_place)?;\n \n         match (&test.kind, &*match_pair.pattern.kind) {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n              &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n-                let new_candidate =\n-                    self.candidate_after_variant_switch(match_pair_index,\n-                                                        adt_def,\n-                                                        variant_index,\n-                                                        subpatterns,\n-                                                        candidate);\n-                resulting_candidates[variant_index.as_usize()].push(new_candidate);\n-                true\n+                self.candidate_after_variant_switch(match_pair_index,\n+                                                    adt_def,\n+                                                    variant_index,\n+                                                    subpatterns,\n+                                                    candidate);\n+                Some(variant_index.as_usize())\n             }\n \n-            (&TestKind::Switch { .. }, _) => false,\n+            (&TestKind::Switch { .. }, _) => None,\n \n             // If we are performing a switch over integers, then this informs integer\n             // equality, but nothing else.\n@@ -514,10 +500,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n              &PatternKind::Constant { ref value })\n             if is_switch_ty(match_pair.pattern.ty) => {\n                 let index = indices[value];\n-                let new_candidate = self.candidate_without_match_pair(match_pair_index,\n-                                                                      candidate);\n-                resulting_candidates[index].push(new_candidate);\n-                true\n+                self.candidate_without_match_pair(match_pair_index, candidate);\n+                Some(index)\n             }\n \n             (&TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n@@ -530,14 +514,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // No switch values are contained in the pattern range,\n                     // so the pattern can be matched only if this test fails.\n                     let otherwise = options.len();\n-                    resulting_candidates[otherwise].push(candidate.clone());\n-                    true\n+                    Some(otherwise)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n \n-            (&TestKind::SwitchInt { .. }, _) => false,\n+            (&TestKind::SwitchInt { .. }, _) => None,\n \n             (&TestKind::Len { len: test_len, op: BinOp::Eq },\n              &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n@@ -546,32 +529,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (Ordering::Equal, &None) => {\n                         // on true, min_len = len = $actual_length,\n                         // on false, len != $actual_length\n-                        resulting_candidates[0].push(\n-                            self.candidate_after_slice_test(match_pair_index,\n-                                                            candidate,\n-                                                            prefix,\n-                                                            slice.as_ref(),\n-                                                            suffix)\n-                        );\n-                        true\n+                        self.candidate_after_slice_test(match_pair_index,\n+                                                        candidate,\n+                                                        prefix,\n+                                                        slice.as_ref(),\n+                                                        suffix);\n+                        Some(0)\n                     }\n                     (Ordering::Less, _) => {\n                         // test_len < pat_len. If $actual_len = test_len,\n                         // then $actual_len < pat_len and we don't have\n                         // enough elements.\n-                        resulting_candidates[1].push(candidate.clone());\n-                        true\n+                        Some(1)\n                     }\n                     (Ordering::Equal, &Some(_)) | (Ordering::Greater, &Some(_)) => {\n                         // This can match both if $actual_len = test_len >= pat_len,\n                         // and if $actual_len > test_len. We can't advance.\n-                        false\n+                        None\n                     }\n                     (Ordering::Greater, &None) => {\n                         // test_len != pat_len, so if $actual_len = test_len, then\n                         // $actual_len != pat_len.\n-                        resulting_candidates[1].push(candidate.clone());\n-                        true\n+                        Some(1)\n                     }\n                 }\n             }\n@@ -584,45 +563,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (Ordering::Equal, &Some(_))  => {\n                         // $actual_len >= test_len = pat_len,\n                         // so we can match.\n-                        resulting_candidates[0].push(\n-                            self.candidate_after_slice_test(match_pair_index,\n-                                                            candidate,\n-                                                            prefix,\n-                                                            slice.as_ref(),\n-                                                            suffix)\n-                        );\n-                        true\n+                        self.candidate_after_slice_test(match_pair_index,\n+                                                        candidate,\n+                                                        prefix,\n+                                                        slice.as_ref(),\n+                                                        suffix);\n+                        Some(0)\n                     }\n                     (Ordering::Less, _) | (Ordering::Equal, &None) => {\n                         // test_len <= pat_len. If $actual_len < test_len,\n                         // then it is also < pat_len, so the test passing is\n                         // necessary (but insufficient).\n-                        resulting_candidates[0].push(candidate.clone());\n-                        true\n+                        Some(0)\n                     }\n                     (Ordering::Greater, &None) => {\n                         // test_len > pat_len. If $actual_len >= test_len > pat_len,\n                         // then we know we won't have a match.\n-                        resulting_candidates[1].push(candidate.clone());\n-                        true\n+                        Some(1)\n                     }\n                     (Ordering::Greater, &Some(_)) => {\n                         // test_len < pat_len, and is therefore less\n                         // strict. This can still go both ways.\n-                        false\n+                        None\n                     }\n                 }\n             }\n \n             (&TestKind::Range(test),\n              &PatternKind::Range(pat)) => {\n                 if test == pat {\n-                    resulting_candidates[0]\n-                        .push(self.candidate_without_match_pair(\n-                            match_pair_index,\n-                            candidate,\n-                        ));\n-                    return true;\n+                    self.candidate_without_match_pair(\n+                        match_pair_index,\n+                        candidate,\n+                    );\n+                    return Some(0);\n                 }\n \n                 let no_overlap = (|| {\n@@ -649,26 +623,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if no_overlap == Some(true) {\n                     // Testing range does not overlap with pattern range,\n                     // so the pattern can be matched only if this test fails.\n-                    resulting_candidates[1].push(candidate.clone());\n-                    true\n+                    Some(1)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n \n             (&TestKind::Range(range), &PatternKind::Constant { value }) => {\n                 if self.const_range_contains(range, value) == Some(false) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails.\n-                    resulting_candidates[1].push(candidate.clone());\n-                    true\n+                    Some(1)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n \n-            (&TestKind::Range { .. }, _) => false,\n-\n+            (&TestKind::Range { .. }, _) => None,\n \n             (&TestKind::Eq { .. }, _) |\n             (&TestKind::Len { .. }, _) => {\n@@ -677,73 +648,53 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(#29623) we can be more clever here\n                 let pattern_test = self.test(&match_pair);\n                 if pattern_test.kind == test.kind {\n-                    let new_candidate = self.candidate_without_match_pair(match_pair_index,\n-                                                                          candidate);\n-                    resulting_candidates[0].push(new_candidate);\n-                    true\n+                    self.candidate_without_match_pair(match_pair_index, candidate);\n+                    Some(0)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n         }\n     }\n \n-    fn candidate_without_match_pair<'pat>(&mut self,\n-                                          match_pair_index: usize,\n-                                          candidate: &Candidate<'pat, 'tcx>)\n-                                          -> Candidate<'pat, 'tcx> {\n-        let other_match_pairs =\n-            candidate.match_pairs.iter()\n-                                 .enumerate()\n-                                 .filter(|&(index, _)| index != match_pair_index)\n-                                 .map(|(_, mp)| mp.clone())\n-                                 .collect();\n-        Candidate {\n-            span: candidate.span,\n-            match_pairs: other_match_pairs,\n-            bindings: candidate.bindings.clone(),\n-            ascriptions: candidate.ascriptions.clone(),\n-            guard: candidate.guard.clone(),\n-            arm_index: candidate.arm_index,\n-            pat_index: candidate.pat_index,\n-            pre_binding_block: candidate.pre_binding_block,\n-            next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n-        }\n+    fn candidate_without_match_pair(\n+        &mut self,\n+        match_pair_index: usize,\n+        candidate: &mut Candidate<'_, 'tcx>,\n+    ) {\n+        candidate.match_pairs.remove(match_pair_index);\n     }\n \n     fn candidate_after_slice_test<'pat>(&mut self,\n                                         match_pair_index: usize,\n-                                        candidate: &Candidate<'pat, 'tcx>,\n+                                        candidate: &mut Candidate<'pat, 'tcx>,\n                                         prefix: &'pat [Pattern<'tcx>],\n                                         opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                        suffix: &'pat [Pattern<'tcx>])\n-                                        -> Candidate<'pat, 'tcx> {\n-        let mut new_candidate =\n-            self.candidate_without_match_pair(match_pair_index, candidate);\n+                                        suffix: &'pat [Pattern<'tcx>]) {\n+        let removed_place = candidate.match_pairs.remove(match_pair_index).place;\n         self.prefix_slice_suffix(\n-            &mut new_candidate.match_pairs,\n-            &candidate.match_pairs[match_pair_index].place,\n+            &mut candidate.match_pairs,\n+            &removed_place,\n             prefix,\n             opt_slice,\n             suffix);\n-\n-        new_candidate\n     }\n \n-    fn candidate_after_variant_switch<'pat>(&mut self,\n-                                            match_pair_index: usize,\n-                                            adt_def: &'tcx ty::AdtDef,\n-                                            variant_index: VariantIdx,\n-                                            subpatterns: &'pat [FieldPattern<'tcx>],\n-                                            candidate: &Candidate<'pat, 'tcx>)\n-                                            -> Candidate<'pat, 'tcx> {\n-        let match_pair = &candidate.match_pairs[match_pair_index];\n+    fn candidate_after_variant_switch<'pat>(\n+        &mut self,\n+        match_pair_index: usize,\n+        adt_def: &'tcx ty::AdtDef,\n+        variant_index: VariantIdx,\n+        subpatterns: &'pat [FieldPattern<'tcx>],\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+    ) {\n+        let match_pair = candidate.match_pairs.remove(match_pair_index);\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem = ProjectionElem::Downcast(adt_def, variant_index);\n-        let downcast_place = match_pair.place.clone().elem(elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n         let consequent_match_pairs =\n             subpatterns.iter()\n                        .map(|subpattern| {\n@@ -754,26 +705,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                            MatchPair::new(place, &subpattern.pattern)\n                        });\n \n-        // In addition, we need all the other match pairs from the old candidate.\n-        let other_match_pairs =\n-            candidate.match_pairs.iter()\n-                                 .enumerate()\n-                                 .filter(|&(index, _)| index != match_pair_index)\n-                                 .map(|(_, mp)| mp.clone());\n-\n-        let all_match_pairs = consequent_match_pairs.chain(other_match_pairs).collect();\n-\n-        Candidate {\n-            span: candidate.span,\n-            match_pairs: all_match_pairs,\n-            bindings: candidate.bindings.clone(),\n-            ascriptions: candidate.ascriptions.clone(),\n-            guard: candidate.guard.clone(),\n-            arm_index: candidate.arm_index,\n-            pat_index: candidate.pat_index,\n-            pre_binding_block: candidate.pre_binding_block,\n-            next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n-        }\n+        candidate.match_pairs.extend(consequent_match_pairs);\n     }\n \n     fn error_simplifyable<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> ! {"}, {"sha": "3b90ff7884f012a70341494a317d7148dcca54a1", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -72,7 +72,6 @@ impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             place,\n             pattern,\n-            slice_len_checked: false,\n         }\n     }\n }"}, {"sha": "903c8f8657f3d38c13f283d224b55226367003dd", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -459,25 +459,15 @@ enum LocalsForNode {\n \n     /// The exceptional case is identifiers in a match arm's pattern\n     /// that are referenced in a guard of that match arm. For these,\n-    /// we can have `2 + k` Locals, where `k` is the number of candidate\n-    /// patterns (separated by `|`) in the arm.\n+    /// we have `2` Locals.\n     ///\n     /// * `for_arm_body` is the Local used in the arm body (which is\n     ///   just like the `One` case above),\n     ///\n     /// * `ref_for_guard` is the Local used in the arm's guard (which\n     ///   is a reference to a temp that is an alias of\n     ///   `for_arm_body`).\n-    ///\n-    /// * `vals_for_guard` is the `k` Locals; at most one of them will\n-    ///   get initialized by the arm's execution, and after it is\n-    ///   initialized, `ref_for_guard` will be assigned a reference to\n-    ///   it.\n-    ///\n-    /// There reason we have `k` Locals rather than just 1 is to\n-    /// accommodate some restrictions imposed by two-phase borrows,\n-    /// which apply when we have a `ref mut` pattern.\n-    ForGuard { vals_for_guard: Vec<Local>, ref_for_guard: Local, for_arm_body: Local },\n+    ForGuard { ref_for_guard: Local, for_arm_body: Local },\n }\n \n #[derive(Debug)]\n@@ -510,16 +500,11 @@ struct GuardFrame {\n }\n \n /// `ForGuard` indicates whether we are talking about:\n-///   1. the temp for a local binding used solely within guard expressions,\n-///   2. the temp that holds reference to (1.), which is actually what the\n-///      guard expressions see, or\n-///   3. the temp for use outside of guard expressions.\n+///   1. The variable for use outside of guard expressions, or\n+///   2. The temp that holds reference to (1.), which is actually what the\n+///      guard expressions see.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ForGuard {\n-    /// The `usize` identifies for which candidate pattern we want the\n-    /// local binding. We keep a temp per-candidate to accommodate\n-    /// two-phase borrows (see `LocalsForNode` documentation).\n-    ValWithinGuard(usize),\n     RefWithinGuard,\n     OutsideGuard,\n }\n@@ -532,11 +517,6 @@ impl LocalsForNode {\n             (&LocalsForNode::ForGuard { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n                 local_id,\n \n-            (&LocalsForNode::ForGuard { ref vals_for_guard, .. },\n-             ForGuard::ValWithinGuard(pat_idx)) =>\n-                vals_for_guard[pat_idx],\n-\n-            (&LocalsForNode::One(_), ForGuard::ValWithinGuard(_)) |\n             (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n                 bug!(\"anything with one local should never be within a guard.\"),\n         }\n@@ -941,7 +921,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &[pattern.clone()],\n+                                                      LintLevel::Inherited, &pattern,\n                                                       matches::ArmHasGuard(false),\n                                                       Some((Some(&place), span)));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place, false));"}, {"sha": "e1b66312da2d306360b8c782940fed4328411b6f", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -1985,8 +1985,8 @@ could cause the match to be non-exhaustive:\n let mut x = Some(0);\n match x {\n     None => (),\n-    Some(v) if { x = None; false } => (),\n-    Some(_) => (), // No longer matches\n+    Some(_) if { x = None; false } => (),\n+    Some(v) => (), // No longer matches\n }\n ```\n "}, {"sha": "3c38f870b04b85476337e8d4166cc9ce3f445427", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -611,7 +611,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprKind::Match(ref discr, ref arms, _) => {\n             ExprKind::Match {\n-                discriminant: discr.to_ref(),\n+                scrutinee: discr.to_ref(),\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }"}, {"sha": "bce0a0dd0a8bdf8781a5294a31a132961b336c78", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -203,7 +203,7 @@ pub enum ExprKind<'tcx> {\n         body: ExprRef<'tcx>,\n     },\n     Match {\n-        discriminant: ExprRef<'tcx>,\n+        scrutinee: ExprRef<'tcx>,\n         arms: Vec<Arm<'tcx>>,\n     },\n     Block {"}, {"sha": "349b27523a0a10ecce6fd1a21f8d51c5a5200955", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 18, "deletions": 79, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -1,112 +1,51 @@\n-//! This module provides two passes:\n+//! This module provides a pass to replacing the following statements with\n+//! [`Nop`]s\n //!\n-//!   - [`CleanAscribeUserType`], that replaces all [`AscribeUserType`]\n-//!     statements with [`Nop`].\n-//!   - [`CleanFakeReadsAndBorrows`], that replaces all [`FakeRead`] statements\n-//!     and borrows that are read by [`ForMatchGuard`] fake reads with [`Nop`].\n+//!   - [`AscribeUserType`]\n+//!   - [`FakeRead`]\n+//!   - [`Assign`] statements with a [`Shallow`] borrow\n //!\n //! The `CleanFakeReadsAndBorrows` \"pass\" is actually implemented as two\n //! traversals (aka visits) of the input MIR. The first traversal,\n //! [`DeleteAndRecordFakeReads`], deletes the fake reads and finds the\n //! temporaries read by [`ForMatchGuard`] reads, and [`DeleteFakeBorrows`]\n //! deletes the initialization of those temporaries.\n //!\n-//! [`CleanAscribeUserType`]: cleanup_post_borrowck::CleanAscribeUserType\n-//! [`CleanFakeReadsAndBorrows`]: cleanup_post_borrowck::CleanFakeReadsAndBorrows\n-//! [`DeleteAndRecordFakeReads`]: cleanup_post_borrowck::DeleteAndRecordFakeReads\n-//! [`DeleteFakeBorrows`]: cleanup_post_borrowck::DeleteFakeBorrows\n //! [`AscribeUserType`]: rustc::mir::StatementKind::AscribeUserType\n-//! [`Nop`]: rustc::mir::StatementKind::Nop\n+//! [`Shallow`]: rustc::mir::BorrowKind::Shallow\n //! [`FakeRead`]: rustc::mir::StatementKind::FakeRead\n-//! [`ForMatchGuard`]: rustc::mir::FakeReadCause::ForMatchGuard\n-\n-use rustc_data_structures::fx::FxHashSet;\n+//! [`Nop`]: rustc::mir::StatementKind::Nop\n \n-use rustc::mir::{BasicBlock, FakeReadCause, Local, Location, Mir, Place};\n+use rustc::mir::{BasicBlock, BorrowKind, Rvalue, Location, Mir};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n \n-pub struct CleanAscribeUserType;\n+pub struct CleanupNonCodegenStatements;\n \n-pub struct DeleteAscribeUserType;\n+pub struct DeleteNonCodegenStatements;\n \n-impl MirPass for CleanAscribeUserType {\n+impl MirPass for CleanupNonCodegenStatements {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n                           mir: &mut Mir<'tcx>) {\n-        let mut delete = DeleteAscribeUserType;\n+        let mut delete = DeleteNonCodegenStatements;\n         delete.visit_mir(mir);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for DeleteAscribeUserType {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n-        if let StatementKind::AscribeUserType(..) = statement.kind {\n-            statement.make_nop();\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n-}\n-\n-pub struct CleanFakeReadsAndBorrows;\n-\n-#[derive(Default)]\n-pub struct DeleteAndRecordFakeReads {\n-    fake_borrow_temporaries: FxHashSet<Local>,\n-}\n-\n-pub struct DeleteFakeBorrows {\n-    fake_borrow_temporaries: FxHashSet<Local>,\n-}\n-\n-// Removes any FakeReads from the MIR\n-impl MirPass for CleanFakeReadsAndBorrows {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n-        let mut delete_reads = DeleteAndRecordFakeReads::default();\n-        delete_reads.visit_mir(mir);\n-        let mut delete_borrows = DeleteFakeBorrows {\n-            fake_borrow_temporaries: delete_reads.fake_borrow_temporaries,\n-        };\n-        delete_borrows.visit_mir(mir);\n-    }\n-}\n-\n-impl<'tcx> MutVisitor<'tcx> for DeleteAndRecordFakeReads {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n-        if let StatementKind::FakeRead(cause, ref place) = statement.kind {\n-            if let FakeReadCause::ForMatchGuard = cause {\n-                match *place {\n-                    Place::Local(local) => self.fake_borrow_temporaries.insert(local),\n-                    _ => bug!(\"Fake match guard read of non-local: {:?}\", place),\n-                };\n-            }\n-            statement.make_nop();\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n-}\n-\n-impl<'tcx> MutVisitor<'tcx> for DeleteFakeBorrows {\n+impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements {\n     fn visit_statement(&mut self,\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if let StatementKind::Assign(Place::Local(local), _) = statement.kind {\n-            if self.fake_borrow_temporaries.contains(&local) {\n-                statement.make_nop();\n-            }\n+        match statement.kind {\n+            StatementKind::AscribeUserType(..)\n+            | StatementKind::Assign(_, box Rvalue::Ref(_, BorrowKind::Shallow, _))\n+            | StatementKind::FakeRead(..) => statement.make_nop(),\n+            _ => (),\n         }\n         self.super_statement(block, statement, location);\n     }"}, {"sha": "c1bb31a49a4b5369fc1f1274ff291375ce194088", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -241,15 +241,11 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n \n     let mut mir = tcx.mir_validated(def_id).steal();\n     run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Optimized, &[\n-        // Remove all things not needed by analysis\n+        // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads,\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n-        // Remove all `AscribeUserType` statements.\n-        &cleanup_post_borrowck::CleanAscribeUserType,\n-        // Remove all `FakeRead` statements and the borrows that are only\n-        // used for checking matches\n-        &cleanup_post_borrowck::CleanFakeReadsAndBorrows,\n+        &cleanup_post_borrowck::CleanupNonCodegenStatements,\n \n         &simplify::SimplifyCfg::new(\"early-opt\"),\n "}, {"sha": "1b46bb3b25f9074820015e964708d3eaa31b1a03", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -14,12 +14,12 @@ pub fn exhaustive_match(e: E, unit: ()) {\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: ]\n+// CHECK: [[OTHERWISE]]:\n+// CHECK-NEXT: unreachable\n // CHECK: [[A]]:\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n // CHECK: [[B]]:\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-// CHECK: [[OTHERWISE]]:\n-// CHECK-NEXT: unreachable\n     match e {\n         E::A => unit,\n         E::B => unit,"}, {"sha": "0f0401a55eacae8d4bdd16134aab434ebe81f6c8", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -41,62 +41,62 @@ fn main() {\n //         StorageLive(_3);\n //         _3 = const true;\n //         FakeRead(ForMatchedPlace, _3);\n-//         switchInt(_3) -> [false: bb11, otherwise: bb10];\n+//         switchInt(_3) -> [false: bb9, otherwise: bb8];\n //     }\n //     bb4: {\n //         resume;\n //     }\n //     bb5: {\n-//         _2 = const 4i32;\n-//         goto -> bb14;\n+//         falseEdges -> [real: bb11, imaginary: bb6];\n //     }\n //     bb6: {\n-//         _0 = ();\n-//         goto -> bb15;\n+//         falseEdges -> [real: bb13, imaginary: bb7];\n //     }\n //     bb7: {\n-//         falseEdges -> [real: bb12, imaginary: bb8];\n+//         unreachable;\n //     }\n //     bb8: {\n-//         falseEdges -> [real: bb13, imaginary: bb9];\n+//         goto -> bb6;\n //     }\n //     bb9: {\n-//         unreachable;\n+//         goto -> bb5;\n //     }\n //     bb10: {\n-//         goto -> bb8;\n+//         _2 = const 4i32;\n+//         goto -> bb18;\n //     }\n //     bb11: {\n-//         goto -> bb7;\n+//         goto -> bb10;\n //     }\n //     bb12: {\n-//         goto -> bb5;\n+//         _0 = ();\n+//         goto -> bb14;\n //     }\n //     bb13: {\n-//         goto -> bb6;\n+//         goto -> bb12;\n //     }\n //     bb14: {\n-//         FakeRead(ForLet, _2);\n //         StorageDead(_3);\n-//         StorageLive(_6);\n-//         _6 = &_2;\n-//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n+//         goto -> bb15;\n //     }\n //     bb15: {\n-//         StorageDead(_3);\n-//         goto -> bb16;\n-//     }\n-//     bb16: {\n //         StorageDead(_2);\n //         goto -> bb2;\n //     }\n-//     bb17: {\n+//     bb16: {\n //         _4 = ();\n //         unreachable;\n //     }\n-//     bb18: {\n+//     bb17: {\n //         StorageDead(_4);\n-//         goto -> bb14;\n+//         goto -> bb18;\n+//     }\n+//     bb18: {\n+//         FakeRead(ForLet, _2);\n+//         StorageDead(_3);\n+//         StorageLive(_6);\n+//         _6 = &_2;\n+//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n //     }\n //     bb19: {\n //         StorageDead(_6);"}, {"sha": "ab6de71d2894d49488ebbbcbd3e89dc8da918a97", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 151, "deletions": 165, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -44,67 +44,62 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n-//      _7 = discriminant(_2);\n-//      _9 = &shallow (promoted[2]: std::option::Option<i32>);\n-//      _10 = &(((promoted[1]: std::option::Option<i32>) as Some).0: i32);\n-//      switchInt(move _7) -> [0isize: bb5, 1isize: bb3, otherwise: bb7];\n+//      _3 = discriminant(_2);\n+//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n //  }\n-//  bb2: {  // arm1\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//  bb2: {\n+//      falseEdges -> [real: bb8, imaginary: bb3]; //pre_binding1\n //  }\n-//  bb3: { // binding3(empty) and arm3\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n+//  bb3: {\n+//      falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n //  }\n //  bb4: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding2\n+//      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n //  }\n //  bb5: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb2, imaginary: bb6]; //pre_binding3\n-//  }\n-//  bb6: {\n //      unreachable;\n //  }\n+//  bb6: { // to pre_binding2\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n //  bb7: {\n //      unreachable;\n //  }\n //  bb8: { // binding1 and guard\n-//      StorageLive(_5);\n-//      _5 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n-//      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb9, unwind: bb1];\n+//      StorageLive(_6);\n+//      _6 = &(((promoted[1]: std::option::Option<i32>) as Some).0: i32);\n+//      _4 = &shallow (promoted[0]: std::option::Option<i32>);\n+//      StorageLive(_7);\n+//      _7 = const guard() -> [return: bb9, unwind: bb1];\n //  }\n //  bb9: {\n-//      switchInt(move _8) -> [false: bb10, otherwise: bb11];\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForGuardBinding, _6);\n+//      switchInt(move _7) -> [false: bb6, otherwise: bb10];\n //  }\n-//  bb10: { // to pre_binding2\n-//      falseEdges -> [real: bb4, imaginary: bb4];\n+//  bb10: {\n+//      StorageLive(_5);\n+//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = _5;\n+//      _1 = (const 1i32, move _8);\n+//      StorageDead(_8);\n+//      goto -> bb13;\n //  }\n-//  bb11: { // bindingNoLandingPads.before.mir2 and arm2\n-//      StorageLive(_3);\n-//      _3 = ((_2 as Some).0: i32);\n-//      StorageLive(_11);\n-//      _11 = _3;\n-//      _1 = (const 1i32, move _11);\n-//      StorageDead(_11);\n+//  bb11: {\n+//      StorageLive(_9);\n+//      _9 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _9;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n //      goto -> bb13;\n //  }\n //  bb12: {\n-//      StorageLive(_6);\n-//      _6 = ((_2 as Some).0: i32);\n-//      StorageLive(_12);\n-//      _12 = _6;\n-//      _1 = (const 2i32, move_12);\n-//      StorageDead(_12);\n+//      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n //  }\n //  bb13: {\n@@ -118,67 +113,62 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n-//      _7 = discriminant(_2);\n-//      _9 = &shallow _2;\n-//      _10 = &((_2 as Some).0: i32);\n-//      switchInt(move _7) -> [0isize: bb4, 1isize: bb3, otherwise: bb7];\n+//      _3 = discriminant(_2);\n+//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n //  }\n-//  bb2: { // arm2\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//  bb2: {\n+//      falseEdges -> [real: bb8, imaginary: bb3];\n //  }\n //  bb3: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n+//      falseEdges -> [real: bb11, imaginary: bb4];\n //  }\n //  bb4: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb2, imaginary: bb5]; //pre_binding2\n+//      falseEdges -> [real: bb12, imaginary: bb5];\n //  }\n //  bb5: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb12, imaginary: bb6]; //pre_binding3\n-//  }\n-//  bb6: {\n //      unreachable;\n //  }\n+//  bb6: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//      falseEdges -> [real: bb4, imaginary: bb3];\n+//  }\n //  bb7: {\n //      unreachable;\n //  }\n //  bb8: { // binding1 and guard\n-//      StorageLive(_5);\n-//      _5 = &((_2 as Some).0: i32);\n-//      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb9, unwind: bb1];\n+//      StorageLive(_6);\n+//      _6 = &((_2 as Some).0: i32);\n+//      _4 = &shallow _2;\n+//      StorageLive(_7);\n+//      _7 = const guard() -> [return: bb9, unwind: bb1];\n //  }\n //  bb9: { // end of guard\n-//      switchInt(move _8) -> [false: bb10, otherwise: bb11];\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForGuardBinding, _6);\n+//      switchInt(move _7) -> [false: bb6, otherwise: bb10];\n //  }\n-//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n-//      falseEdges -> [real: bb5, imaginary: bb4];\n+//  bb10: { // arm1\n+//      StorageLive(_5);\n+//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = _5;\n+//      _1 = (const 1i32, move _8);\n+//      StorageDead(_8);\n+//      goto -> bb13;\n //  }\n-//  bb11: { // arm1\n-//      StorageLive(_3);\n-//      _3 = ((_2 as Some).0: i32);\n-//      StorageLive(_11);\n-//      _11 = _3;\n-//      _1 = (const 1i32, move _11);\n-//      StorageDead(_11);\n+//  bb11: { // arm2\n+//      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n //  }\n //  bb12: { // binding3 and arm3\n-//      StorageLive(_6);\n-//      _6 = ((_2 as Some).0: i32);\n-//      StorageLive(_12);\n-//      _12 = _6;\n-//      _1 = (const 2i32, move _12);\n-//      StorageDead(_12);\n+//      StorageLive(_9);\n+//      _9 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _9;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n //      goto -> bb13;\n //  }\n //  bb13: {\n@@ -190,92 +180,88 @@ fn main() {\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n // bb0: {\n //     ...\n-//     _2 = std::option::Option<i32>::Some(const 1i32,);\n-//     FakeRead(ForMatchedPlace, _2);\n-//     _11 = discriminant(_2);\n-//    _16 = &shallow _2;\n-//    _17 = &((_2 as Some).0: i32);\n-//     switchInt(move _11) -> [1isize: bb2, otherwise: bb3];\n-// }\n-// bb1: {\n-//     resume;\n-// }\n-// bb2: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n-// }\n-// bb3: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n-// }\n-// bb4: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n-// }\n-// bb5: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb16, imaginary: bb6]; //pre_binding4\n-// }\n-// bb6: {\n-//     unreachable;\n-// }\n-// bb7: { // binding1: Some(w) if guard()\n-//     StorageLive(_5);\n-//     _5 = &((_2 as Some).0: i32);\n-//     StorageLive(_12);\n-//     _12 = const guard() -> [return: bb8, unwind: bb1];\n-// }\n-// bb8: { //end of guard\n-//     switchInt(move _12) -> [false: bb9, otherwise: bb10];\n-// }\n-// bb9: { // to pre_binding2\n-//     falseEdges -> [real: bb3, imaginary: bb3];\n-// }\n-// bb10: { // set up bindings for arm1\n-//     StorageLive(_3);\n-//     _3 = ((_2 as Some).0: i32);\n-//     _1 = const 1i32;\n-//     goto -> bb17;\n-// }\n-// bb11: { // binding2 & arm2\n-//     StorageLive(_6);\n-//     _6 = _2;\n-//     _1 = const 2i32;\n-//     goto -> bb17;\n-// }\n-// bb12: { // binding3: Some(y) if guard2(y)\n-//     StorageLive(_9);\n-//     _9 = &((_2 as Some).0: i32);\n-//     StorageLive(_14);\n-//     StorageLive(_15);\n-//     _15 = (*_9);\n-//     _14 = const guard2(move _15) -> [return: bb13, unwind: bb1];\n-// }\n-// bb13: { // end of guard2\n-//     StorageDead(_15);\n-//     switchInt(move _14) -> [false: bb14, otherwise: bb15];\n-// }\n-// bb14: { // to pre_binding4\n-//     falseEdges -> [real: bb5, imaginary: bb5];\n-// }\n-// bb15: { // set up bindings for arm3\n-//     StorageLive(_7);\n-//     _7 = ((_2 as Some).0: i32);\n-//     _1 = const 3i32;\n-//     goto -> bb17;\n-// }\n-// bb16: { // binding4 & arm4\n-//     StorageLive(_10);\n-//     _10 = _2;\n-//     _1 = const 4i32;\n-//     goto -> bb17;\n-// }\n-// bb17: {\n-//     ...\n-//     return;\n-// }\n+//      _2 = std::option::Option<i32>::Some(const 1i32,);\n+//      FakeRead(ForMatchedPlace, _2);\n+//      _3 = discriminant(_2);\n+//      switchInt(move _3) -> [1isize: bb2, otherwise: bb3];\n+//  }\n+//  bb1: {\n+//      resume;\n+//  }\n+//  bb2: {\n+//      falseEdges -> [real: bb9, imaginary: bb3];\n+//  }\n+//  bb3: {\n+//      falseEdges -> [real: bb12, imaginary: bb4];\n+//  }\n+//  bb4: {\n+//      falseEdges -> [real: bb13, imaginary: bb5];\n+//  }\n+//  bb5: {\n+//      falseEdges -> [real: bb16, imaginary: bb6];\n+//  }\n+//  bb6: {\n+//      unreachable;\n+//  }\n+//  bb7: {\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n+//  bb8: {\n+//      falseEdges -> [real: bb5, imaginary: bb5];\n+//  }\n+//  bb9: { // binding1: Some(w) if guard()\n+//      StorageLive(_7);\n+//      _7 = &((_2 as Some).0: i32);\n+//      _5 = &shallow _2;\n+//      StorageLive(_8);\n+//      _8 = const guard() -> [return: bb10, unwind: bb1];\n+//  }\n+//  bb10: { //end of guard\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForGuardBinding, _7);\n+//      switchInt(move _8) -> [false: bb7, otherwise: bb11];\n+//  }\n+//  bb11: { // set up bindings for arm1\n+//      StorageLive(_6);\n+//      _6 = ((_2 as Some).0: i32);\n+//      _1 = const 1i32;\n+//      goto -> bb17;\n+//  }\n+//  bb12: { // binding2 & arm2\n+//      StorageLive(_9);\n+//      _9 = _2;\n+//      _1 = const 2i32;\n+//      goto -> bb17;\n+//  }\n+//  bb13: { // binding3: Some(y) if guard2(y)\n+//      StorageLive(_11);\n+//      _11 = &((_2 as Some).0: i32);\n+//      _5 = &shallow _2;\n+//      StorageLive(_12);\n+//      StorageLive(_13);\n+//      _13 = (*_11);\n+//      _12 = const guard2(move _13) -> [return: bb14, unwind: bb1];\n+//  }\n+//  bb14: { // end of guard2\n+//      StorageDead(_13);\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForGuardBinding, _11);\n+//      switchInt(move _12) -> [false: bb8, otherwise: bb15];\n+//  }\n+//  bb15: { // binding4 & arm4\n+//      StorageLive(_10);\n+//      _10 = ((_2 as Some).0: i32);\n+//      _1 = const 3i32;\n+//      goto -> bb17;\n+//  }\n+//  bb16: {\n+//      StorageLive(_14);\n+//      _14 = _2;\n+//      _1 = const 4i32;\n+//      goto -> bb17;\n+//  }\n+//  bb17: {\n+//      ...\n+//      return;\n+//  }\n // END rustc.main.QualifyAndPromoteConstants.before.mir"}, {"sha": "3f248f3d41a646d3fcca0ad3ce20f7896872783a", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -20,66 +20,67 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        _4 = Le(const 0i32, _1);\n-//        switchInt(move _4) -> [false: bb10, otherwise: bb11];\n+//        switchInt(move _4) -> [false: bb7, otherwise: bb8];\n //    }\n //    bb1: {\n-//        _3 = const 0i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb12, imaginary: bb2];\n //    }\n //    bb2: {\n-//        _3 = const 1i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb13, imaginary: bb3];\n //    }\n //    bb3: {\n-//        _3 = const 2i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb14, imaginary: bb4];\n //    }\n //    bb4: {\n-//        _3 = const 3i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb15, imaginary: bb5];\n //    }\n //    bb5: {\n-//        falseEdges -> [real: bb12, imaginary: bb6];\n+//        unreachable;\n //    }\n //    bb6: {\n-//        falseEdges -> [real: bb2, imaginary: bb7];\n+//        falseEdges -> [real: bb4, imaginary: bb2];\n //    }\n //    bb7: {\n-//        falseEdges -> [real: bb3, imaginary: bb8];\n+//        _6 = Le(const 10i32, _1);\n+//        switchInt(move _6) -> [false: bb9, otherwise: bb10];\n //    }\n //    bb8: {\n-//        falseEdges -> [real: bb4, imaginary: bb9];\n+//        _5 = Lt(_1, const 10i32);\n+//        switchInt(move _5) -> [false: bb7, otherwise: bb1];\n //    }\n //    bb9: {\n-//        unreachable;\n+//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n //    }\n //    bb10: {\n-//        _7 = Le(const 10i32, _1);\n-//        switchInt(move _7) -> [false: bb14, otherwise: bb15];\n+//        _7 = Le(_1, const 20i32);\n+//        switchInt(move _7) -> [false: bb9, otherwise: bb2];\n //    }\n //    bb11: {\n-//        _5 = Lt(_1, const 10i32);\n-//        switchInt(move _5) -> [false: bb10, otherwise: bb5];\n+//        _3 = const 0i32;\n+//        goto -> bb16;\n //    }\n //    bb12: {\n-//        StorageLive(_6);\n-//        _6 = _2;\n-//        switchInt(move _6) -> [false: bb13, otherwise: bb1];\n+//        StorageLive(_8);\n+//        _8 = _2;\n+//        switchInt(move _8) -> [false: bb6, otherwise: bb11];\n //    }\n //    bb13: {\n-//        falseEdges -> [real: bb8, imaginary: bb6];\n+//        _3 = const 1i32;\n+//        goto -> bb16;\n //    }\n //    bb14: {\n-//        switchInt(_1) -> [-1i32: bb7, otherwise: bb8];\n+//        _3 = const 2i32;\n+//        goto -> bb16;\n //    }\n //    bb15: {\n-//        _8 = Le(_1, const 20i32);\n-//        switchInt(move _8) -> [false: bb14, otherwise: bb6];\n+//        _3 = const 3i32;\n+//        goto -> bb16;\n //    }\n //    bb16: {\n-//        StorageDead(_6);\n-//        ...\n+//        StorageDead(_8);\n+//        _0 = ();\n+//        StorageDead(_2);\n+//        StorageDead(_1);\n //        return;\n //    }\n // END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "48d1c991b623ed981eda7306d6d21e87eae7e701", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -4,119 +4,117 @@\n \n #![feature(nll)]\n \n-fn match_guard(x: Option<&&i32>) -> i32 {\n+fn match_guard(x: Option<&&i32>, c: bool) -> i32 {\n     match x {\n-        Some(0) if true => 0,\n+        Some(0) if c => 0,\n         _ => 1,\n     }\n }\n \n fn main() {\n-    match_guard(None);\n+    match_guard(None, true);\n }\n \n // END RUST SOURCE\n \n-// START rustc.match_guard.CleanFakeReadsAndBorrows.before.mir\n+// START rustc.match_guard.CleanupNonCodegenStatements.before.mir\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n-//     _2 = discriminant(_1);\n-//     _3 = &shallow _1;\n-//     _4 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n-//     _5 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n-//     _6 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n-//     switchInt(move _2) -> [1isize: bb6, otherwise: bb4];\n+//     _3 = discriminant(_1);\n+//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n // }\n // bb1: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n // bb2: {\n-//     _0 = const 1i32;\n-//     goto -> bb9;\n+//     goto -> bb8;\n // }\n // bb3: {\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForMatchGuard, _5);\n-//     FakeRead(ForMatchGuard, _6);\n-//     goto -> bb7;\n+//     unreachable;\n // }\n // bb4: {\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForMatchGuard, _5);\n-//     FakeRead(ForMatchGuard, _6);\n //     goto -> bb2;\n // }\n // bb5: {\n-//     unreachable;\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n // bb6: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb4];\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n // }\n // bb7: {\n-//     goto -> bb1;\n+//     _4 = &shallow _1;\n+//     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n+//     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n+//     _7 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n+//     StorageLive(_8);\n+//     _8 = _2;\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForMatchGuard, _5);\n+//     FakeRead(ForMatchGuard, _6);\n+//     FakeRead(ForMatchGuard, _7);\n+//     switchInt(move _8) -> [false: bb4, otherwise: bb6];\n // }\n // bb8: {\n-//     goto -> bb4;\n+//     _0 = const 1i32;\n+//     goto -> bb9;\n // }\n // bb9: {\n+//     StorageDead(_8);\n //     return;\n // }\n // bb10: {\n //     resume;\n // }\n-// END rustc.match_guard.CleanFakeReadsAndBorrows.before.mir\n+// END rustc.match_guard.CleanupNonCodegenStatements.before.mir\n \n-// START rustc.match_guard.CleanFakeReadsAndBorrows.after.mir\n+// START rustc.match_guard.CleanupNonCodegenStatements.after.mir\n // bb0: {\n //     nop;\n-//     _2 = discriminant(_1);\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     switchInt(move _2) -> [1isize: bb6, otherwise: bb4];\n+//     _3 = discriminant(_1);\n+//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n // }\n // bb1: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n // bb2: {\n-//     _0 = const 1i32;\n-//     goto -> bb9;\n+//     goto -> bb8;\n // }\n // bb3: {\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     goto -> bb7;\n+//     unreachable;\n // }\n // bb4: {\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n //     goto -> bb2;\n // }\n // bb5: {\n-//     unreachable;\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n // bb6: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb4];\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n // }\n // bb7: {\n-//     goto -> bb1;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     StorageLive(_8);\n+//     _8 = _2;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     switchInt(move _8) -> [false: bb4, otherwise: bb6];\n // }\n // bb8: {\n-//     goto -> bb4;\n+//     _0 = const 1i32;\n+//     goto -> bb9;\n // }\n // bb9: {\n+//     StorageDead(_8);\n //     return;\n // }\n // bb10: {\n //     resume;\n // }\n-// END rustc.match_guard.CleanFakeReadsAndBorrows.after.mir\n+// END rustc.match_guard.CleanupNonCodegenStatements.after.mir"}, {"sha": "795a3fc210f6a1a91d84954d4add468c4ed9a0f0", "filename": "src/test/ui/match/match-ref-mut-stability.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-stability.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -0,0 +1,39 @@\n+// Check that `ref mut` variables don't change address between the match guard\n+// and the arm expression.\n+\n+// run-pass\n+\n+#![feature(nll, bind_by_move_pattern_guards)]\n+\n+// Test that z always point to the same temporary.\n+fn referent_stability() {\n+    let p;\n+    match 0 {\n+        ref mut z if { p = z as *const _; true } => assert_eq!(p, z as *const _),\n+        _ => unreachable!(),\n+    };\n+}\n+\n+// Test that z is always effectively the same variable.\n+fn variable_stability() {\n+    let p;\n+    match 0 {\n+        ref mut z if { p = &z as *const _; true } => assert_eq!(p, &z as *const _),\n+        _ => unreachable!(),\n+    };\n+}\n+\n+// Test that a borrow of *z can cross from the guard to the arm.\n+fn persist_borrow() {\n+    let r;\n+    match 0 {\n+        ref mut z if { r = z as &_; true } => assert_eq!(*r, 0),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+fn main() {\n+    referent_stability();\n+    variable_stability();\n+    persist_borrow();\n+}"}, {"sha": "a3add8856dfa1ecf81feb3ab8364fa29d996dd5b", "filename": "src/test/ui/nll/match-cfg-fake-edges.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -0,0 +1,58 @@\n+// Test that we have enough false edges to avoid exposing the exact matching\n+// algorithm in borrow checking.\n+\n+#![feature(nll, bind_by_move_pattern_guards)]\n+\n+fn guard_always_precedes_arm(y: i32) {\n+    let mut x;\n+    // x should always be initialized, as the only way to reach the arm is\n+    // through the guard.\n+    match y {\n+        0 | 2 if { x = 2; true } => x,\n+        _ => 2,\n+    };\n+}\n+\n+fn guard_may_be_skipped(y: i32) {\n+    let x;\n+    // Even though x *is* always initialized, we don't want to have borrowck\n+    // results be based on whether patterns are exhaustive.\n+    match y {\n+        _ if { x = 2; true } => 1,\n+        _ if {\n+            x; //~ ERROR use of possibly uninitialized variable: `x`\n+            false\n+        } => 2,\n+        _ => 3,\n+    };\n+}\n+\n+fn guard_may_be_taken(y: bool) {\n+    let x = String::new();\n+    // Even though x *is* never moved before the use, we don't want to have\n+    // borrowck results be based on whether patterns are disjoint.\n+    match y {\n+        false if { drop(x); true } => 1,\n+        true => {\n+            x; //~ ERROR use of moved value: `x`\n+            2\n+        }\n+        false => 3,\n+    };\n+}\n+\n+fn all_previous_tests_may_be_done(y: &mut (bool, bool)) {\n+    let r = &mut y.1;\n+    // We don't actually test y.1 to select the second arm, but we don't want\n+    // borrowck results to be based on the order we match patterns.\n+    match y {\n+        (false, true) => 1, //~ ERROR cannot use `y.1` because it was mutably borrowed\n+        (true, _) => {\n+            r;\n+            2\n+        }\n+        (false, _) => 3,\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "a855b28a978dd9473db8f916962459ac26eb77af", "filename": "src/test/ui/nll/match-cfg-fake-edges.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -0,0 +1,34 @@\n+error[E0381]: use of possibly uninitialized variable: `x`\n+  --> $DIR/match-cfg-fake-edges.rs:23:13\n+   |\n+LL |             x; //~ ERROR use of possibly uninitialized variable: `x`\n+   |             ^ use of possibly uninitialized `x`\n+\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/match-cfg-fake-edges.rs:37:13\n+   |\n+LL |     let x = String::new();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n+LL |         false if { drop(x); true } => 1,\n+   |                         - value moved here\n+LL |         true => {\n+LL |             x; //~ ERROR use of moved value: `x`\n+   |             ^ value used here after move\n+\n+error[E0503]: cannot use `y.1` because it was mutably borrowed\n+  --> $DIR/match-cfg-fake-edges.rs:49:17\n+   |\n+LL |     let r = &mut y.1;\n+   |             -------- borrow of `y.1` occurs here\n+...\n+LL |         (false, true) => 1, //~ ERROR cannot use `y.1` because it was mutably borrowed\n+   |                 ^^^^ use of borrowed `y.1`\n+LL |         (true, _) => {\n+LL |             r;\n+   |             - borrow later used here\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0381, E0382, E0503.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "6e158713146f15a0e1521dae7eda854e39945e4a", "filename": "src/test/ui/nll/match-guards-partially-borrow.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -17,6 +17,30 @@ fn ok_mutation_in_guard(mut q: i32) {\n     }\n }\n \n+fn ok_mutation_in_guard2(mut u: bool) {\n+    // OK value of u is unused before modification\n+    match u {\n+        _ => (),\n+        _ if {\n+            u = true;\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n+fn ok_mutation_in_guard4(mut w: (&mut bool,)) {\n+    // OK value of u is unused before modification\n+    match w {\n+        _ => (),\n+        _ if {\n+            *w.0 = true;\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n fn ok_indirect_mutation_in_guard(mut p: &bool) {\n     match *p {\n         // OK, mutation doesn't change which patterns s matches\n@@ -30,7 +54,7 @@ fn ok_indirect_mutation_in_guard(mut p: &bool) {\n \n fn mutation_invalidates_pattern_in_guard(mut q: bool) {\n     match q {\n-        // s doesn't match the pattern with the guard by the end of the guard.\n+        // q doesn't match the pattern with the guard by the end of the guard.\n         false if {\n             q = true; //~ ERROR\n             true\n@@ -41,7 +65,7 @@ fn mutation_invalidates_pattern_in_guard(mut q: bool) {\n \n fn mutation_invalidates_previous_pattern_in_guard(mut r: bool) {\n     match r {\n-        // s matches a previous pattern by the end of the guard.\n+        // r matches a previous pattern by the end of the guard.\n         true => (),\n         _ if {\n             r = true; //~ ERROR\n@@ -53,8 +77,8 @@ fn mutation_invalidates_previous_pattern_in_guard(mut r: bool) {\n \n fn match_on_borrowed_early_end(mut s: bool) {\n     let h = &mut s;\n-    match s { //~ ERROR\n-        // s changes value between the start of the match and when its value is checked.\n+    // OK value of s is unused before modification.\n+    match s {\n         _ if {\n             *h = !*h;\n             false\n@@ -75,19 +99,7 @@ fn bad_mutation_in_guard(mut t: bool) {\n     }\n }\n \n-fn bad_mutation_in_guard2(mut u: bool) {\n-    match u {\n-        // Guard changes the value bound in the last pattern.\n-        _ => (),\n-        _ if {\n-            u = true; //~ ERROR\n-            false\n-        } => (),\n-        x => (),\n-    }\n-}\n-\n-pub fn bad_mutation_in_guard3(mut x: Option<Option<&i32>>) {\n+fn bad_mutation_in_guard2(mut x: Option<Option<&i32>>) {\n     // Check that nested patterns are checked.\n     match x {\n         None => (),\n@@ -103,16 +115,13 @@ pub fn bad_mutation_in_guard3(mut x: Option<Option<&i32>>) {\n     }\n }\n \n-\n-fn bad_mutation_in_guard4(mut w: (&mut bool,)) {\n-    match w {\n-        // Guard changes the value bound in the last pattern.\n-        _ => (),\n-        _ if {\n-            *w.0 = true; //~ ERROR\n+fn bad_mutation_in_guard3(mut t: bool) {\n+    match t {\n+        s if {\n+            t = !t; //~ ERROR\n             false\n-        } => (),\n-        x => (),\n+        } => (), // What value should `s` have in the arm?\n+        _ => (),\n     }\n }\n "}, {"sha": "baff2fda9f5d143e58213eb3ad93eab8567519a9", "filename": "src/test/ui/nll/match-guards-partially-borrow.stderr", "status": "modified", "additions": 19, "deletions": 64, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr?ref=31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "patch": "@@ -1,132 +1,87 @@\n error[E0510]: cannot assign `q` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:35:13\n+  --> $DIR/match-guards-partially-borrow.rs:59:13\n    |\n LL |     match q {\n    |           - value is immutable in match guard\n ...\n LL |             q = true; //~ ERROR\n    |             ^^^^^^^^ cannot assign\n-...\n-LL |         _ => (),\n-   |         - borrow later used here\n \n error[E0510]: cannot assign `r` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:47:13\n+  --> $DIR/match-guards-partially-borrow.rs:71:13\n    |\n LL |     match r {\n    |           - value is immutable in match guard\n ...\n LL |             r = true; //~ ERROR\n    |             ^^^^^^^^ cannot assign\n-...\n-LL |         _ => (),\n-   |         - borrow later used here\n-\n-error[E0503]: cannot use `s` because it was mutably borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:56:11\n-   |\n-LL |     let h = &mut s;\n-   |             ------ borrow of `s` occurs here\n-LL |     match s { //~ ERROR\n-   |           ^ use of borrowed `s`\n-...\n-LL |             *h = !*h;\n-   |                   -- borrow later used here\n \n error[E0510]: cannot assign `t` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:71:13\n+  --> $DIR/match-guards-partially-borrow.rs:95:13\n    |\n LL |     match t {\n    |           - value is immutable in match guard\n ...\n LL |             t = true; //~ ERROR\n    |             ^^^^^^^^ cannot assign\n-...\n-LL |         false => (),\n-   |         ----- borrow later used here\n-\n-error[E0506]: cannot assign to `u` because it is borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:83:13\n-   |\n-LL |     match u {\n-   |           - borrow of `u` occurs here\n-...\n-LL |             u = true; //~ ERROR\n-   |             ^^^^^^^^ assignment to borrowed `u` occurs here\n-...\n-LL |         x => (),\n-   |         - borrow later used here\n \n error[E0510]: cannot mutably borrow `x.0` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:97:22\n+  --> $DIR/match-guards-partially-borrow.rs:109:22\n    |\n LL |     match x {\n    |           - value is immutable in match guard\n ...\n LL |                 Some(ref mut r) => *r = None, //~ ERROR\n    |                      ^^^^^^^^^ cannot mutably borrow\n \n-error[E0506]: cannot assign to `*w.0` because it is borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:112:13\n+error[E0506]: cannot assign to `t` because it is borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:121:13\n    |\n-LL |     match w {\n-   |           - borrow of `*w.0` occurs here\n-...\n-LL |             *w.0 = true; //~ ERROR\n-   |             ^^^^^^^^^^^ assignment to borrowed `*w.0` occurs here\n-...\n-LL |         x => (),\n+LL |         s if {\n+   |         - borrow of `t` occurs here\n+LL |             t = !t; //~ ERROR\n+   |             ^^^^^^ assignment to borrowed `t` occurs here\n+LL |             false\n+LL |         } => (), // What value should `s` have in the arm?\n    |         - borrow later used here\n \n error[E0510]: cannot assign `y` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:123:13\n+  --> $DIR/match-guards-partially-borrow.rs:132:13\n    |\n LL |     match *y {\n    |           -- value is immutable in match guard\n ...\n LL |             y = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n-...\n-LL |         false => (),\n-   |         ----- borrow later used here\n \n error[E0510]: cannot assign `z` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:134:13\n+  --> $DIR/match-guards-partially-borrow.rs:143:13\n    |\n LL |     match z {\n    |           - value is immutable in match guard\n ...\n LL |             z = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n-...\n-LL |         &false => (),\n-   |         ------ borrow later used here\n \n error[E0510]: cannot assign `a` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:146:13\n+  --> $DIR/match-guards-partially-borrow.rs:155:13\n    |\n LL |     match a {\n    |           - value is immutable in match guard\n ...\n LL |             a = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n-...\n-LL |         false => (),\n-   |         ----- borrow later used here\n \n error[E0510]: cannot assign `b` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:157:13\n+  --> $DIR/match-guards-partially-borrow.rs:166:13\n    |\n LL |     match b {\n    |           - value is immutable in match guard\n ...\n LL |             b = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n-...\n-LL |         &b => (),\n-   |         -- borrow later used here\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 9 previous errors\n \n-Some errors occurred: E0503, E0506, E0510.\n-For more information about an error, try `rustc --explain E0503`.\n+Some errors occurred: E0506, E0510.\n+For more information about an error, try `rustc --explain E0506`."}]}