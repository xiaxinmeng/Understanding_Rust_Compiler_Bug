{"sha": "38472e0d5c70596fef584a0e45c4bfadfface4b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NDcyZTBkNWM3MDU5NmZlZjU4NGEwZTQ1YzRiZmFkZmZhY2U0Yjk=", "commit": {"author": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-25T12:43:54Z"}, "committer": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-25T12:43:54Z"}, "message": "Move the check to `unwind_to_block`", "tree": {"sha": "4a49525fb96324d0479880aff2063e1c56f4021c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a49525fb96324d0479880aff2063e1c56f4021c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38472e0d5c70596fef584a0e45c4bfadfface4b9", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niIsEABYIADMWIQRJ2jPMDdiQ+U4U42Z0+n/VuNoUuAUCYKzxChUceWQtaHVhbmdA\nb3V0bG9vay5jb20ACgkQdPp/1bjaFLitSAEA1Fl8iGT0Ec7XGvtQexMwgu+97L94\nOHvZLkqsIcECZWABAPMyQaf6bhM9E5TeK7cXJz8lm3ebZ5cjLfBMQlnluzwE\n=QrIa\n-----END PGP SIGNATURE-----", "payload": "tree 4a49525fb96324d0479880aff2063e1c56f4021c\nparent 116172d1802995b2eb4d1c17a7762d9c8840a198\nauthor hyd-dev <yd-huang@outlook.com> 1621946634 +0800\ncommitter hyd-dev <yd-huang@outlook.com> 1621946634 +0800\n\nMove the check to `unwind_to_block`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38472e0d5c70596fef584a0e45c4bfadfface4b9", "html_url": "https://github.com/rust-lang/rust/commit/38472e0d5c70596fef584a0e45c4bfadfface4b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38472e0d5c70596fef584a0e45c4bfadfface4b9/comments", "author": null, "committer": null, "parents": [{"sha": "116172d1802995b2eb4d1c17a7762d9c8840a198", "url": "https://api.github.com/repos/rust-lang/rust/commits/116172d1802995b2eb4d1c17a7762d9c8840a198", "html_url": "https://github.com/rust-lang/rust/commit/116172d1802995b2eb4d1c17a7762d9c8840a198"}], "stats": {"total": 64, "additions": 34, "deletions": 30}, "files": [{"sha": "f5ceb69c258b2d38aae38b703aabf1b6c1b39566", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/38472e0d5c70596fef584a0e45c4bfadfface4b9/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38472e0d5c70596fef584a0e45c4bfadfface4b9/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=38472e0d5c70596fef584a0e45c4bfadfface4b9", "patch": "@@ -757,13 +757,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// *Unwind* to the given `target` basic block.\n     /// Do *not* use for returning! Use `return_to_block` instead.\n     ///\n-    /// If `target` is `None`, that indicates the function does not need cleanup during\n-    /// unwinding, and we will just keep propagating that upwards.\n-    pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n+    /// If `target` is `StackPopUnwind::Skip`, that indicates the function does not need cleanup\n+    /// during unwinding, and we will just keep propagating that upwards.\n+    ///\n+    /// If `target` is `StackPopUnwind::NotAllowed`, that indicates the function does not allow\n+    /// unwinding, and doing so is UB.\n+    pub fn unwind_to_block(&mut self, target: StackPopUnwind) -> InterpResult<'tcx> {\n         self.frame_mut().loc = match target {\n-            Some(block) => Ok(mir::Location { block, statement_index: 0 }),\n-            None => Err(self.frame_mut().body.span),\n+            StackPopUnwind::Cleanup(block) => Ok(mir::Location { block, statement_index: 0 }),\n+            StackPopUnwind::Skip => Err(self.frame_mut().body.span),\n+            StackPopUnwind::NotAllowed => {\n+                throw_ub_format!(\"unwinding past a frame that does not allow unwinding\")\n+            }\n         };\n+        Ok(())\n     }\n \n     /// Pops the current frame from the stack, deallocating the\n@@ -798,27 +805,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n         }\n \n-        // Where do we jump next?\n-\n-        // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n-        // In that case, we return early. We also avoid validation in that case,\n-        // because this is CTFE and the final value will be thoroughly validated anyway.\n-        let (cleanup, next_block) = match (self.frame().return_to_block, unwinding) {\n-            (StackPopCleanup::Goto { ret, .. }, false) => (true, Some(ret)),\n-            (StackPopCleanup::Goto { unwind, .. }, true) => (\n-                true,\n-                Some(match unwind {\n-                    StackPopUnwind::Cleanup(unwind) => Some(unwind),\n-                    StackPopUnwind::Skip => None,\n-                    StackPopUnwind::NotAllowed => {\n-                        throw_ub_format!(\"unwinding past a frame that does not allow unwinding\")\n-                    }\n-                }),\n-            ),\n-            (StackPopCleanup::None { cleanup, .. }, _) => (cleanup, None),\n-        };\n-\n-        let frame = self.stack_mut().pop().unwrap();\n+        let frame =\n+            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n         if !unwinding {\n             // Copy the return value to the caller's stack frame.\n@@ -831,9 +819,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n+        let return_to_block = frame.return_to_block;\n+\n+        // Now where do we jump next?\n+\n+        // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n+        // In that case, we return early. We also avoid validation in that case,\n+        // because this is CTFE and the final value will be thoroughly validated anyway.\n+        let cleanup = match return_to_block {\n+            StackPopCleanup::Goto { .. } => true,\n+            StackPopCleanup::None { cleanup, .. } => cleanup,\n+        };\n+\n         if !cleanup {\n             assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n-            assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");\n             assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n             // Leak the locals, skip validation, skip machine hook.\n             return Ok(());\n@@ -852,11 +851,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Normal return, figure out where to jump.\n         if unwinding {\n             // Follow the unwind edge.\n-            let unwind = next_block.expect(\"Encountered StackPopCleanup::None when unwinding!\");\n-            self.unwind_to_block(unwind);\n+            let unwind = match return_to_block {\n+                StackPopCleanup::Goto { unwind, .. } => unwind,\n+                StackPopCleanup::None { .. } => {\n+                    panic!(\"Encountered StackPopCleanup::None when unwinding!\")\n+                }\n+            };\n+            self.unwind_to_block(unwind)?;\n         } else {\n             // Follow the normal return edge.\n-            if let Some(ret) = next_block {\n+            if let StackPopCleanup::Goto { ret, .. } = return_to_block {\n                 self.return_to_block(ret)?;\n             }\n         }"}]}