{"sha": "90fb7c4c50a91b12d000b2aa2d063f695d637246", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZmI3YzRjNTBhOTFiMTJkMDAwYjJhYTJkMDYzZjY5NWQ2MzcyNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-13T11:49:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-13T11:49:37Z"}, "message": "Auto merge of #6966 - Jarcho:while_let_on_iterator_fp, r=xFrednet\n\n`while_let_on_iterator` Improvements\n\nfixes: #6491\nfixes: #6231\nfixes: #5844\nfixes: #1924\nfixes: #1033\n\nThe check for whether a field can be borrowed should probably be moved to utils at some point, but it would require some cleanup work and knowing what parts can actually be shared.\n\nchangelog: Suggest `&mut iter` when the iterator is used after the loop.\nchangelog: Suggest `&mut iter` when the iterator is a field in a struct.\nchangelog: Don't lint when the iterator is a field in a struct, and the struct is used in the loop.\nchangelog: Lint when the loop is nested in another loop, but suggest `&mut iter` unless the iterator is from a local declared inside the loop.", "tree": {"sha": "1288a393b2ce3c8e79d5c9ed7c295ca7a4fd8ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1288a393b2ce3c8e79d5c9ed7c295ca7a4fd8ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90fb7c4c50a91b12d000b2aa2d063f695d637246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90fb7c4c50a91b12d000b2aa2d063f695d637246", "html_url": "https://github.com/rust-lang/rust/commit/90fb7c4c50a91b12d000b2aa2d063f695d637246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90fb7c4c50a91b12d000b2aa2d063f695d637246/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa15a5442a975180a367373e563b7f8c626b5344", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa15a5442a975180a367373e563b7f8c626b5344", "html_url": "https://github.com/rust-lang/rust/commit/aa15a5442a975180a367373e563b7f8c626b5344"}, {"sha": "cd0db8a4599619dd43af5f39834a7566d06e5b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd0db8a4599619dd43af5f39834a7566d06e5b50", "html_url": "https://github.com/rust-lang/rust/commit/cd0db8a4599619dd43af5f39834a7566d06e5b50"}], "stats": {"total": 931, "additions": 725, "deletions": 206}, "files": [{"sha": "e67ec4e06c547d3455f6cd83507ddd227d503a3e", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -383,7 +383,7 @@ pub fn strip_doc_comment_decoration(doc: &str, comment_kind: CommentKind, span:\n     let mut no_stars = String::with_capacity(doc.len());\n     for line in doc.lines() {\n         let mut chars = line.chars();\n-        while let Some(c) = chars.next() {\n+        for c in &mut chars {\n             if c.is_whitespace() {\n                 no_stars.push(c);\n             } else {"}, {"sha": "63560047578a16aa0c39f8996745dbd02ab6c246", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 311, "deletions": 134, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -1,170 +1,347 @@\n-use super::utils::{LoopNestVisitor, Nesting};\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{\n-    get_enclosing_block, is_refutable, is_trait_method, last_path_segment, path_to_local, path_to_local_id,\n-};\n+use clippy_utils::{get_enclosing_loop, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, HirId, MatchSource, Node, PatKind};\n+use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Node, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n-use rustc_span::symbol::sym;\n+use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Match(match_expr, arms, MatchSource::WhileLetDesugar) = expr.kind {\n-        let pat = &arms[0].pat.kind;\n-        if let (&PatKind::TupleStruct(ref qpath, pat_args, _), &ExprKind::MethodCall(method_path, _, method_args, _)) =\n-            (pat, &match_expr.kind)\n-        {\n-            let iter_expr = &method_args[0];\n-\n-            // Don't lint when the iterator is recreated on every iteration\n-            if_chain! {\n-                if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n-                if let Some(iter_def_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-                if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n-                then {\n-                    return;\n-                }\n-            }\n+    let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n+        if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind;\n+        // check for `Some(..)` pattern\n+        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = arm.pat.kind;\n+        if let Res::Def(_, pat_did) = pat_path.res;\n+        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        // check for call to `Iterator::next`\n+        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = scrutinee_expr.kind;\n+        if method_name.ident.name == sym::next;\n+        if is_trait_method(cx, scrutinee_expr, sym::Iterator);\n+        if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr);\n+        // get the loop containing the match expression\n+        if let Some((_, Node::Expr(loop_expr))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n+        if !uses_iter(cx, &iter_expr, arm.body);\n+        then {\n+            (scrutinee_expr, iter_expr, some_pat, loop_expr)\n+        } else {\n+            return;\n+        }\n+    };\n \n-            let lhs_constructor = last_path_segment(qpath);\n-            if method_path.ident.name == sym::next\n-                && is_trait_method(cx, match_expr, sym::Iterator)\n-                && lhs_constructor.ident.name == sym::Some\n-                && (pat_args.is_empty()\n-                    || !is_refutable(cx, pat_args[0])\n-                        && !is_used_inside(cx, iter_expr, arms[0].body)\n-                        && !is_iterator_used_after_while_let(cx, iter_expr)\n-                        && !is_nested(cx, expr, &method_args[0]))\n-            {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let iterator = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n-                let loop_var = if pat_args.is_empty() {\n-                    \"_\".to_string()\n-                } else {\n-                    snippet_with_applicability(cx, pat_args[0].span, \"_\", &mut applicability).into_owned()\n-                };\n-                span_lint_and_sugg(\n-                    cx,\n-                    WHILE_LET_ON_ITERATOR,\n-                    expr.span.with_hi(match_expr.span.hi()),\n-                    \"this loop could be written as a `for` loop\",\n-                    \"try\",\n-                    format!(\"for {} in {}\", loop_var, iterator),\n-                    applicability,\n-                );\n-            }\n+    let mut applicability = Applicability::MachineApplicable;\n+    let loop_var = if let Some(some_pat) = some_pat.first() {\n+        if is_refutable(cx, some_pat) {\n+            // Refutable patterns don't work with for loops.\n+            return;\n         }\n-    }\n-}\n+        snippet_with_applicability(cx, some_pat.span, \"..\", &mut applicability)\n+    } else {\n+        \"_\".into()\n+    };\n \n-fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n-    let def_id = match path_to_local(expr) {\n-        Some(id) => id,\n-        None => return false,\n+    // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n+    // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n+    // afterwards a mutable borrow of a field isn't necessary.\n+    let ref_mut = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n+        \"&mut \"\n+    } else {\n+        \"\"\n     };\n-    if let Some(used_mutably) = mutated_variables(container, cx) {\n-        if used_mutably.contains(&def_id) {\n-            return true;\n+\n+    let iterator = snippet_with_applicability(cx, iter_expr.span, \"_\", &mut applicability);\n+    span_lint_and_sugg(\n+        cx,\n+        WHILE_LET_ON_ITERATOR,\n+        expr.span.with_hi(scrutinee_expr.span.hi()),\n+        \"this loop could be written as a `for` loop\",\n+        \"try\",\n+        format!(\"for {} in {}{}\", loop_var, ref_mut, iterator),\n+        applicability,\n+    );\n+}\n+\n+#[derive(Debug)]\n+struct IterExpr {\n+    /// The span of the whole expression, not just the path and fields stored here.\n+    span: Span,\n+    /// The fields used, in order of child to parent.\n+    fields: Vec<Symbol>,\n+    /// The path being used.\n+    path: Res,\n+}\n+/// Parses any expression to find out which field of which variable is used. Will return `None` if\n+/// the expression might have side effects.\n+fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n+    let span = e.span;\n+    let mut fields = Vec::new();\n+    loop {\n+        match e.kind {\n+            ExprKind::Path(ref path) => {\n+                break Some(IterExpr {\n+                    span,\n+                    fields,\n+                    path: cx.qpath_res(path, e.hir_id),\n+                });\n+            },\n+            ExprKind::Field(base, name) => {\n+                fields.push(name.name);\n+                e = base;\n+            },\n+            // Dereferencing a pointer has no side effects and doesn't affect which field is being used.\n+            ExprKind::Unary(UnOp::Deref, base) if cx.typeck_results().expr_ty(base).is_ref() => e = base,\n+\n+            // Shouldn't have side effects, but there's no way to trace which field is used. So forget which fields have\n+            // already been seen.\n+            ExprKind::Index(base, idx) if !idx.can_have_side_effects() => {\n+                fields.clear();\n+                e = base;\n+            },\n+            ExprKind::Unary(UnOp::Deref, base) => {\n+                fields.clear();\n+                e = base;\n+            },\n+\n+            // No effect and doesn't affect which field is being used.\n+            ExprKind::DropTemps(base) | ExprKind::AddrOf(_, _, base) | ExprKind::Type(base, _) => e = base,\n+            _ => break None,\n         }\n     }\n-    false\n }\n \n-fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n-    let def_id = match path_to_local(iter_expr) {\n-        Some(id) => id,\n-        None => return false,\n-    };\n-    let mut visitor = VarUsedAfterLoopVisitor {\n-        def_id,\n-        iter_expr_id: iter_expr.hir_id,\n-        past_while_let: false,\n-        var_used_after_while_let: false,\n-    };\n-    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n-        walk_block(&mut visitor, enclosing_block);\n+fn is_expr_same_field(cx: &LateContext<'_>, mut e: &Expr<'_>, mut fields: &[Symbol], path_res: Res) -> bool {\n+    loop {\n+        match (&e.kind, fields) {\n+            (&ExprKind::Field(base, name), [head_field, tail_fields @ ..]) if name.name == *head_field => {\n+                e = base;\n+                fields = tail_fields;\n+            },\n+            (ExprKind::Path(path), []) => {\n+                break cx.qpath_res(path, e.hir_id) == path_res;\n+            },\n+            (&(ExprKind::DropTemps(base) | ExprKind::AddrOf(_, _, base) | ExprKind::Type(base, _)), _) => e = base,\n+            _ => break false,\n+        }\n     }\n-    visitor.var_used_after_while_let\n }\n \n-fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n-        let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n-        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(parent_node);\n-        then {\n-            return is_loop_nested(cx, loop_expr, iter_expr)\n-        }\n+/// Checks if the given expression is the same field as, is a child of, or is the parent of the\n+/// given field. Used to check if the expression can be used while the given field is borrowed\n+/// mutably. e.g. if checking for `x.y`, then `x.y`, `x.y.z`, and `x` will all return true, but\n+/// `x.z`, and `y` will return false.\n+fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fields: &[Symbol], path_res: Res) -> bool {\n+    match expr.kind {\n+        ExprKind::Field(base, name) => {\n+            if let Some((head_field, tail_fields)) = fields.split_first() {\n+                if name.name == *head_field && is_expr_same_field(cx, base, fields, path_res) {\n+                    return true;\n+                }\n+                // Check if the expression is a parent field\n+                let mut fields_iter = tail_fields.iter();\n+                while let Some(field) = fields_iter.next() {\n+                    if *field == name.name && is_expr_same_field(cx, base, fields_iter.as_slice(), path_res) {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            // Check if the expression is a child field.\n+            let mut e = base;\n+            loop {\n+                match e.kind {\n+                    ExprKind::Field(..) if is_expr_same_field(cx, e, fields, path_res) => break true,\n+                    ExprKind::Field(base, _) | ExprKind::DropTemps(base) | ExprKind::Type(base, _) => e = base,\n+                    ExprKind::Path(ref path) if fields.is_empty() => {\n+                        break cx.qpath_res(path, e.hir_id) == path_res;\n+                    },\n+                    _ => break false,\n+                }\n+            }\n+        },\n+        // If the path matches, this is either an exact match, or the expression is a parent of the field.\n+        ExprKind::Path(ref path) => cx.qpath_res(path, expr.hir_id) == path_res,\n+        ExprKind::DropTemps(base) | ExprKind::Type(base, _) | ExprKind::AddrOf(_, _, base) => {\n+            is_expr_same_child_or_parent_field(cx, base, fields, path_res)\n+        },\n+        _ => false,\n     }\n-    false\n }\n \n-fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n-    let mut id = loop_expr.hir_id;\n-    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n-        id\n-    } else {\n-        return true;\n+/// Strips off all field and path expressions. This will return true if a field or path has been\n+/// skipped. Used to skip them after failing to check for equality.\n+fn skip_fields_and_path(expr: &'tcx Expr<'_>) -> (Option<&'tcx Expr<'tcx>>, bool) {\n+    let mut e = expr;\n+    let e = loop {\n+        match e.kind {\n+            ExprKind::Field(base, _) | ExprKind::DropTemps(base) | ExprKind::Type(base, _) => e = base,\n+            ExprKind::Path(_) => return (None, true),\n+            _ => break e,\n+        }\n     };\n-    loop {\n-        let parent = cx.tcx.hir().get_parent_node(id);\n-        if parent == id {\n-            return false;\n+    (Some(e), e.hir_id != expr.hir_id)\n+}\n+\n+/// Checks if the given expression uses the iterator.\n+fn uses_iter(cx: &LateContext<'tcx>, iter_expr: &IterExpr, container: &'tcx Expr<'_>) -> bool {\n+    struct V<'a, 'b, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        iter_expr: &'b IterExpr,\n+        uses_iter: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, '_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n         }\n-        match cx.tcx.hir().find(parent) {\n-            Some(Node::Expr(expr)) => {\n-                if let ExprKind::Loop(..) = expr.kind {\n-                    return true;\n-                };\n-            },\n-            Some(Node::Block(block)) => {\n-                let mut block_visitor = LoopNestVisitor {\n-                    hir_id: id,\n-                    iterator: iter_id,\n-                    nesting: Nesting::Unknown,\n-                };\n-                walk_block(&mut block_visitor, block);\n-                if block_visitor.nesting == Nesting::RuledOut {\n-                    return false;\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.uses_iter {\n+                // return\n+            } else if is_expr_same_child_or_parent_field(self.cx, e, &self.iter_expr.fields, self.iter_expr.path) {\n+                self.uses_iter = true;\n+            } else if let (e, true) = skip_fields_and_path(e) {\n+                if let Some(e) = e {\n+                    self.visit_expr(e);\n                 }\n-            },\n-            Some(Node::Stmt(_)) => (),\n-            _ => {\n-                return false;\n-            },\n+            } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n+                if is_res_used(self.cx, self.iter_expr.path, id) {\n+                    self.uses_iter = true;\n+                }\n+            } else {\n+                walk_expr(self, e);\n+            }\n         }\n-        id = parent;\n     }\n-}\n \n-struct VarUsedAfterLoopVisitor {\n-    def_id: HirId,\n-    iter_expr_id: HirId,\n-    past_while_let: bool,\n-    var_used_after_while_let: bool,\n+    let mut v = V {\n+        cx,\n+        iter_expr,\n+        uses_iter: false,\n+    };\n+    v.visit_expr(container);\n+    v.uses_iter\n }\n \n-impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n-    type Map = Map<'tcx>;\n+#[allow(clippy::too_many_lines)]\n+fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr: &'tcx Expr<'_>) -> bool {\n+    struct AfterLoopVisitor<'a, 'b, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        iter_expr: &'b IterExpr,\n+        loop_id: HirId,\n+        after_loop: bool,\n+        used_iter: bool,\n+    }\n+    impl Visitor<'tcx> for AfterLoopVisitor<'_, '_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.past_while_let {\n-            if path_to_local_id(expr, self.def_id) {\n-                self.var_used_after_while_let = true;\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.used_iter {\n+                return;\n+            }\n+            if self.after_loop {\n+                if is_expr_same_child_or_parent_field(self.cx, e, &self.iter_expr.fields, self.iter_expr.path) {\n+                    self.used_iter = true;\n+                } else if let (e, true) = skip_fields_and_path(e) {\n+                    if let Some(e) = e {\n+                        self.visit_expr(e);\n+                    }\n+                } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n+                    self.used_iter = is_res_used(self.cx, self.iter_expr.path, id);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            } else if self.loop_id == e.hir_id {\n+                self.after_loop = true;\n+            } else {\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    struct NestedLoopVisitor<'a, 'b, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        iter_expr: &'b IterExpr,\n+        local_id: HirId,\n+        loop_id: HirId,\n+        after_loop: bool,\n+        found_local: bool,\n+        used_after: bool,\n+    }\n+    impl Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_local(&mut self, l: &'tcx Local<'_>) {\n+            if !self.after_loop {\n+                l.pat.each_binding_or_first(&mut |_, id, _, _| {\n+                    if id == self.local_id {\n+                        self.found_local = true;\n+                    }\n+                });\n+            }\n+            if let Some(e) = l.init {\n+                self.visit_expr(e);\n+            }\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.used_after {\n+                return;\n+            }\n+            if self.after_loop {\n+                if is_expr_same_child_or_parent_field(self.cx, e, &self.iter_expr.fields, self.iter_expr.path) {\n+                    self.used_after = true;\n+                } else if let (e, true) = skip_fields_and_path(e) {\n+                    if let Some(e) = e {\n+                        self.visit_expr(e);\n+                    }\n+                } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n+                    self.used_after = is_res_used(self.cx, self.iter_expr.path, id);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            } else if e.hir_id == self.loop_id {\n+                self.after_loop = true;\n+            } else {\n+                walk_expr(self, e);\n             }\n-        } else if self.iter_expr_id == expr.hir_id {\n-            self.past_while_let = true;\n         }\n-        walk_expr(self, expr);\n     }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+\n+    if let Some(e) = get_enclosing_loop(cx.tcx, loop_expr) {\n+        // The iterator expression will be used on the next iteration unless it is declared within the outer\n+        // loop.\n+        let local_id = match iter_expr.path {\n+            Res::Local(id) => id,\n+            _ => return true,\n+        };\n+        let mut v = NestedLoopVisitor {\n+            cx,\n+            iter_expr,\n+            local_id,\n+            loop_id: loop_expr.hir_id,\n+            after_loop: false,\n+            found_local: false,\n+            used_after: false,\n+        };\n+        v.visit_expr(e);\n+        v.used_after || !v.found_local\n+    } else {\n+        let mut v = AfterLoopVisitor {\n+            cx,\n+            iter_expr,\n+            loop_id: loop_expr.hir_id,\n+            after_loop: false,\n+            used_iter: false,\n+        };\n+        v.visit_expr(&cx.tcx.hir().body(cx.enclosing_body.unwrap()).value);\n+        v.used_iter\n     }\n }"}, {"sha": "371fe23bedcd1d33572dac3c4a7adcacbc1d69b5", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -855,6 +855,24 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     })\n }\n \n+/// Gets the loop enclosing the given expression, if any.\n+pub fn get_enclosing_loop(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    let map = tcx.hir();\n+    for (_, node) in map.parent_iter(expr.hir_id) {\n+        match node {\n+            Node::Expr(\n+                e @ Expr {\n+                    kind: ExprKind::Loop(..),\n+                    ..\n+                },\n+            ) => return Some(e),\n+            Node::Expr(_) | Node::Stmt(_) | Node::Block(_) | Node::Local(_) | Node::Arm(_) => (),\n+            _ => break,\n+        }\n+    }\n+    None\n+}\n+\n /// Gets the parent node if it's an impl block.\n pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n     let map = tcx.hir();"}, {"sha": "0c95066175771d6c87c20db69dfece1fbd65072a", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -289,7 +289,7 @@ fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     let mut chars = sugg.as_ref().chars();\n     if let Some('(') = chars.next() {\n         let mut depth = 1;\n-        while let Some(c) = chars.next() {\n+        for c in &mut chars {\n             if c == '(' {\n                 depth += 1;\n             } else if c == ')' {"}, {"sha": "ecdc666b5f690a63ed7aa132a640f7b78361328f", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -1,7 +1,7 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Block, Body, Destination, Expr, ExprKind, HirId, Stmt};\n+use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -218,6 +218,7 @@ impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n     }\n }\n \n+/// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n     node: impl Visitable<'tcx>,\n     f: impl FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>),\n@@ -239,3 +240,36 @@ pub fn visit_break_exprs<'tcx>(\n \n     node.visit(&mut V(f));\n }\n+\n+/// Checks if the given resolved path is used in the given body.\n+pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        res: Res,\n+        found: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.found {\n+                return;\n+            }\n+\n+            if let ExprKind::Path(p) = &e.kind {\n+                if self.cx.qpath_res(p, e.hir_id) == self.res {\n+                    self.found = true;\n+                }\n+            } else {\n+                walk_expr(self, e)\n+            }\n+        }\n+    }\n+\n+    let mut v = V { cx, res, found: false };\n+    v.visit_expr(&cx.tcx.hir().body(body).value);\n+    v.found\n+}"}, {"sha": "c3e2cf0c4a4bd485e8a869e3a1b7f140eacdc9e3", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 143, "deletions": 32, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::while_let_on_iterator)]\n-#![allow(clippy::never_loop, unreachable_code, unused_mut)]\n+#![allow(clippy::never_loop, unreachable_code, unused_mut, dead_code)]\n \n fn base() {\n     let mut iter = 1..20;\n@@ -38,13 +38,6 @@ fn base() {\n         println!(\"next: {:?}\", iter.next());\n     }\n \n-    // or this\n-    let mut iter = 1u32..20;\n-    while let Some(_) = iter.next() {\n-        break;\n-    }\n-    println!(\"Remaining iter {:?}\", iter);\n-\n     // or this\n     let mut iter = 1u32..20;\n     while let Some(_) = iter.next() {\n@@ -135,18 +128,6 @@ fn refutable2() {\n \n fn nested_loops() {\n     let a = [42, 1337];\n-    let mut y = a.iter();\n-    loop {\n-        // x is reused, so don't lint here\n-        while let Some(_) = y.next() {}\n-    }\n-\n-    let mut y = a.iter();\n-    for _ in 0..2 {\n-        while let Some(_) = y.next() {\n-            // y is reused, don't lint\n-        }\n-    }\n \n     loop {\n         let mut y = a.iter();\n@@ -167,10 +148,8 @@ fn issue1121() {\n }\n \n fn issue2965() {\n-    // This should not cause an ICE and suggest:\n-    //\n-    // for _ in values.iter() {}\n-    //\n+    // This should not cause an ICE\n+\n     use std::collections::HashSet;\n     let mut values = HashSet::new();\n     values.insert(1);\n@@ -205,13 +184,145 @@ fn issue1654() {\n     }\n }\n \n+fn issue6491() {\n+    // Used in outer loop, needs &mut\n+    let mut it = 1..40;\n+    while let Some(n) = it.next() {\n+        for m in &mut it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+\n+    // This is fine, inner loop uses a new iterator.\n+    let mut it = 1..40;\n+    for n in it {\n+        let mut it = 1..40;\n+        for m in it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Weird binding shouldn't change anything.\n+        let (mut it, _) = (1..40, 0);\n+        for m in it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Used after the loop, needs &mut.\n+        let mut it = 1..40;\n+        for m in &mut it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"next item {}\", it.next().unwrap());\n+\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue6231() {\n+    // Closure in the outer loop, needs &mut\n+    let mut it = 1..40;\n+    let mut opt = Some(0);\n+    while let Some(n) = opt.take().or_else(|| it.next()) {\n+        for m in &mut it {\n+            if n % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue1924() {\n+    struct S<T>(T);\n+    impl<T: Iterator<Item = u32>> S<T> {\n+        fn f(&mut self) -> Option<u32> {\n+            // Used as a field.\n+            for i in &mut self.0 {\n+                if !(3..=7).contains(&i) {\n+                    return Some(i);\n+                }\n+            }\n+            None\n+        }\n+\n+        fn f2(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.next() {\n+                if i == 1 {\n+                    return self.f();\n+                }\n+            }\n+            None\n+        }\n+    }\n+    impl<T: Iterator<Item = u32>> S<(S<T>, Option<u32>)> {\n+        fn f3(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.0.0.f();\n+                }\n+            }\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.f3();\n+                }\n+            }\n+            // This one is fine, a different field is borrowed\n+            for i in &mut self.0.0.0 {\n+                if i == 1 {\n+                    return self.0.1.take();\n+                } else {\n+                    self.0.1 = Some(i);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    struct S2<T>(T, u32);\n+    impl<T: Iterator<Item = u32>> Iterator for S2<T> {\n+        type Item = u32;\n+        fn next(&mut self) -> Option<u32> {\n+            self.0.next()\n+        }\n+    }\n+\n+    // Don't lint, field of the iterator is accessed in the loop\n+    let mut it = S2(1..40, 0);\n+    while let Some(n) = it.next() {\n+        if n == it.1 {\n+            break;\n+        }\n+    }\n+\n+    // Needs &mut, field of the iterator is accessed after the loop\n+    let mut it = S2(1..40, 0);\n+    for n in &mut it {\n+        if n == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"iterator field {}\", it.1);\n+}\n+\n fn main() {\n-    base();\n-    refutable();\n-    refutable2();\n-    nested_loops();\n-    issue1121();\n-    issue2965();\n-    issue3670();\n-    issue1654();\n+    let mut it = 0..20;\n+    for _ in it {\n+        println!(\"test\");\n+    }\n }"}, {"sha": "1717006a4490e59884b5e6db16858021ada5e383", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 143, "deletions": 32, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::while_let_on_iterator)]\n-#![allow(clippy::never_loop, unreachable_code, unused_mut)]\n+#![allow(clippy::never_loop, unreachable_code, unused_mut, dead_code)]\n \n fn base() {\n     let mut iter = 1..20;\n@@ -38,13 +38,6 @@ fn base() {\n         println!(\"next: {:?}\", iter.next());\n     }\n \n-    // or this\n-    let mut iter = 1u32..20;\n-    while let Some(_) = iter.next() {\n-        break;\n-    }\n-    println!(\"Remaining iter {:?}\", iter);\n-\n     // or this\n     let mut iter = 1u32..20;\n     while let Some(_) = iter.next() {\n@@ -135,18 +128,6 @@ fn refutable2() {\n \n fn nested_loops() {\n     let a = [42, 1337];\n-    let mut y = a.iter();\n-    loop {\n-        // x is reused, so don't lint here\n-        while let Some(_) = y.next() {}\n-    }\n-\n-    let mut y = a.iter();\n-    for _ in 0..2 {\n-        while let Some(_) = y.next() {\n-            // y is reused, don't lint\n-        }\n-    }\n \n     loop {\n         let mut y = a.iter();\n@@ -167,10 +148,8 @@ fn issue1121() {\n }\n \n fn issue2965() {\n-    // This should not cause an ICE and suggest:\n-    //\n-    // for _ in values.iter() {}\n-    //\n+    // This should not cause an ICE\n+\n     use std::collections::HashSet;\n     let mut values = HashSet::new();\n     values.insert(1);\n@@ -205,13 +184,145 @@ fn issue1654() {\n     }\n }\n \n+fn issue6491() {\n+    // Used in outer loop, needs &mut\n+    let mut it = 1..40;\n+    while let Some(n) = it.next() {\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+\n+    // This is fine, inner loop uses a new iterator.\n+    let mut it = 1..40;\n+    while let Some(n) = it.next() {\n+        let mut it = 1..40;\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Weird binding shouldn't change anything.\n+        let (mut it, _) = (1..40, 0);\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Used after the loop, needs &mut.\n+        let mut it = 1..40;\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"next item {}\", it.next().unwrap());\n+\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue6231() {\n+    // Closure in the outer loop, needs &mut\n+    let mut it = 1..40;\n+    let mut opt = Some(0);\n+    while let Some(n) = opt.take().or_else(|| it.next()) {\n+        while let Some(m) = it.next() {\n+            if n % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue1924() {\n+    struct S<T>(T);\n+    impl<T: Iterator<Item = u32>> S<T> {\n+        fn f(&mut self) -> Option<u32> {\n+            // Used as a field.\n+            while let Some(i) = self.0.next() {\n+                if i < 3 || i > 7 {\n+                    return Some(i);\n+                }\n+            }\n+            None\n+        }\n+\n+        fn f2(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.next() {\n+                if i == 1 {\n+                    return self.f();\n+                }\n+            }\n+            None\n+        }\n+    }\n+    impl<T: Iterator<Item = u32>> S<(S<T>, Option<u32>)> {\n+        fn f3(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.0.0.f();\n+                }\n+            }\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.f3();\n+                }\n+            }\n+            // This one is fine, a different field is borrowed\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.0.1.take();\n+                } else {\n+                    self.0.1 = Some(i);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    struct S2<T>(T, u32);\n+    impl<T: Iterator<Item = u32>> Iterator for S2<T> {\n+        type Item = u32;\n+        fn next(&mut self) -> Option<u32> {\n+            self.0.next()\n+        }\n+    }\n+\n+    // Don't lint, field of the iterator is accessed in the loop\n+    let mut it = S2(1..40, 0);\n+    while let Some(n) = it.next() {\n+        if n == it.1 {\n+            break;\n+        }\n+    }\n+\n+    // Needs &mut, field of the iterator is accessed after the loop\n+    let mut it = S2(1..40, 0);\n+    while let Some(n) = it.next() {\n+        if n == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"iterator field {}\", it.1);\n+}\n+\n fn main() {\n-    base();\n-    refutable();\n-    refutable2();\n-    nested_loops();\n-    issue1121();\n-    issue2965();\n-    issue3670();\n-    issue1654();\n+    let mut it = 0..20;\n+    while let Some(..) = it.next() {\n+        println!(\"test\");\n+    }\n }"}, {"sha": "eff559bef7e3b87a3ab9491876558389070393a9", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/90fb7c4c50a91b12d000b2aa2d063f695d637246/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90fb7c4c50a91b12d000b2aa2d063f695d637246/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=90fb7c4c50a91b12d000b2aa2d063f695d637246", "patch": "@@ -19,28 +19,96 @@ LL |     while let Some(_) = iter.next() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:101:9\n+  --> $DIR/while_let_on_iterator.rs:94:9\n    |\n LL |         while let Some([..]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [..] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:108:9\n+  --> $DIR/while_let_on_iterator.rs:101:9\n    |\n LL |         while let Some([_x]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [_x] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:121:9\n+  --> $DIR/while_let_on_iterator.rs:114:9\n    |\n LL |         while let Some(x @ [_]) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x @ [_] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:153:9\n+  --> $DIR/while_let_on_iterator.rs:134:9\n    |\n LL |         while let Some(_) = y.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in y`\n \n-error: aborting due to 7 previous errors\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:191:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:202:5\n+   |\n+LL |     while let Some(n) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:204:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:213:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:222:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:239:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:254:13\n+   |\n+LL |             while let Some(i) = self.0.next() {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/while_let_on_iterator.rs:255:20\n+   |\n+LL |                 if i < 3 || i > 7 {\n+   |                    ^^^^^^^^^^^^^^ help: use: `!(3..=7).contains(&i)`\n+   |\n+   = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:286:13\n+   |\n+LL |             while let Some(i) = self.0.0.0.next() {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0.0.0`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:315:5\n+   |\n+LL |     while let Some(n) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:325:5\n+   |\n+LL |     while let Some(..) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n+\n+error: aborting due to 18 previous errors\n "}]}