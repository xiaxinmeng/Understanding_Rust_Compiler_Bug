{"sha": "a7d440e368395804511fc86ae3a2ef2ae748f308", "node_id": "C_kwDOAAsO6NoAKGE3ZDQ0MGUzNjgzOTU4MDQ1MTFmYzg2YWUzYTJlZjJhZTc0OGYzMDg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-10T15:49:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-10T15:49:03Z"}, "message": "Merge #11662\n\n11662: fix: extract_module selection inside impl r=Veykril a=feniljain\n\nShould close: #11508 \r\n\r\nFrom issue:\r\nConcern 1: Seems to be fixed in latest `rust-analyzer` build\r\nConcern 2 and 3: Should be fixed by this PR\r\nConcern 4: Got fixed in #11472 \r\n\r\nPoints to note:\r\n\r\n- Here I have seperated use items and other items, this is becuase the new `impl` block which we will be creating cannot contain use items as immediate children. As they are the only one item that can be generated by our assist, so seperating them helps in handling their inclusion in new `impl` block inside new `module`\r\n\r\n- There's also a new method added which helps in removing remaning left over indentation after removing `impl` or other `item`\n\nCo-authored-by: vi_mi <fkjainco@gmail.com>", "tree": {"sha": "505838f4e2972d2df4239d933de17945b6ad7cc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/505838f4e2972d2df4239d933de17945b6ad7cc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d440e368395804511fc86ae3a2ef2ae748f308", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiKh3vCRBK7hj4Ov3rIwAA1cAIAFi4n0/Wj/JD56dXLGSE2Kyj\nnUaQg+G84xn7CsxamUnsP2f5H3Gy3CSGeeHwN23/YuVcAzCM6Vsi+k46K4dEgUAK\nZZMRoq++Z/eJRD+CVMOfZQ6hlPFf2dECk891EQ6V9D81Ns43BmmFKkkNtCksiYxl\nKd7V0PkzVkVBapxES/cBdh36Ubm83WF4Fj/wr8tIW/KpriNT64xRULlvG5R06GV9\n/Wy2Al7OjbLle4rAmPbLoOzJ1SIBUEgbUWF1eWxNqDvrDBXLRCTKFshTbe1dZWqb\nuzCIqq6yZ6Hnub+/TLJs8DqvlNU38G0RqX+AEmWJDCX9ZPNBwn0QLxu0J9QDmyY=\n=3Z12\n-----END PGP SIGNATURE-----\n", "payload": "tree 505838f4e2972d2df4239d933de17945b6ad7cc3\nparent 5b51cb835a356cf79cba00cf5c65d51cadeea7f1\nparent 5789caf60e91423df4e16fb8a9778d2bce3b11ed\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646927343 +0000\ncommitter GitHub <noreply@github.com> 1646927343 +0000\n\nMerge #11662\n\n11662: fix: extract_module selection inside impl r=Veykril a=feniljain\n\nShould close: #11508 \r\n\r\nFrom issue:\r\nConcern 1: Seems to be fixed in latest `rust-analyzer` build\r\nConcern 2 and 3: Should be fixed by this PR\r\nConcern 4: Got fixed in #11472 \r\n\r\nPoints to note:\r\n\r\n- Here I have seperated use items and other items, this is becuase the new `impl` block which we will be creating cannot contain use items as immediate children. As they are the only one item that can be generated by our assist, so seperating them helps in handling their inclusion in new `impl` block inside new `module`\r\n\r\n- There's also a new method added which helps in removing remaning left over indentation after removing `impl` or other `item`\n\nCo-authored-by: vi_mi <fkjainco@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d440e368395804511fc86ae3a2ef2ae748f308", "html_url": "https://github.com/rust-lang/rust/commit/a7d440e368395804511fc86ae3a2ef2ae748f308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d440e368395804511fc86ae3a2ef2ae748f308/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b51cb835a356cf79cba00cf5c65d51cadeea7f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b51cb835a356cf79cba00cf5c65d51cadeea7f1", "html_url": "https://github.com/rust-lang/rust/commit/5b51cb835a356cf79cba00cf5c65d51cadeea7f1"}, {"sha": "5789caf60e91423df4e16fb8a9778d2bce3b11ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/5789caf60e91423df4e16fb8a9778d2bce3b11ed", "html_url": "https://github.com/rust-lang/rust/commit/5789caf60e91423df4e16fb8a9778d2bce3b11ed"}], "stats": {"total": 181, "additions": 167, "deletions": 14}, "files": [{"sha": "08bfd10dc798be08c7d6452fdf2fe994c436c3a1", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "modified", "additions": 167, "deletions": 14, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a7d440e368395804511fc86ae3a2ef2ae748f308/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d440e368395804511fc86ae3a2ef2ae748f308/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=a7d440e368395804511fc86ae3a2ef2ae748f308", "patch": "@@ -7,6 +7,7 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     search::{FileReference, SearchScope},\n };\n+use parser::SyntaxKind::WHITESPACE;\n use stdx::format_to;\n use syntax::{\n     algo::find_node_at_range,\n@@ -59,6 +60,20 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n \n+    //If the selection is inside impl block, we need to place new module outside impl block,\n+    //as impl blocks cannot contain modules\n+\n+    let mut impl_parent: Option<ast::Impl> = None;\n+    let mut impl_child_count: usize = 0;\n+    if let Some(parent_assoc_list) = node.parent() {\n+        if let Some(parent_impl) = parent_assoc_list.parent() {\n+            if let Some(impl_) = ast::Impl::cast(parent_impl) {\n+                impl_child_count = parent_assoc_list.children().count();\n+                impl_parent = Some(impl_);\n+            }\n+        }\n+    }\n+\n     let mut curr_parent_module: Option<ast::Module> = None;\n     if let Some(mod_syn_opt) = node.ancestors().find(|it| ast::Module::can_cast(it.kind())) {\n         curr_parent_module = ast::Module::cast(mod_syn_opt);\n@@ -98,18 +113,55 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         \"Extract Module\",\n         module.text_range,\n         |builder| {\n-            let _ = &module;\n+            let mut body_items: Vec<String> = Vec::new();\n+            let mut items_to_be_processed: Vec<ast::Item> = module.body_items.clone();\n+            let mut new_item_indent = old_item_indent + 1;\n \n-            let mut body_items = Vec::new();\n-            let new_item_indent = old_item_indent + 1;\n-            for item in module.body_items {\n+            if impl_parent.is_some() {\n+                new_item_indent = old_item_indent + 2;\n+            } else {\n+                items_to_be_processed = [module.use_items.clone(), items_to_be_processed].concat();\n+            }\n+\n+            for item in items_to_be_processed {\n                 let item = item.indent(IndentLevel(1));\n                 let mut indented_item = String::new();\n                 format_to!(indented_item, \"{}{}\", new_item_indent, item.to_string());\n                 body_items.push(indented_item);\n             }\n \n-            let body = body_items.join(\"\\n\\n\");\n+            let mut body = body_items.join(\"\\n\\n\");\n+\n+            if let Some(impl_) = &impl_parent {\n+                let mut impl_body_def = String::new();\n+\n+                if let Some(self_ty) = impl_.self_ty() {\n+                    format_to!(\n+                        impl_body_def,\n+                        \"{}impl {} {{\\n{}\\n{}}}\",\n+                        old_item_indent + 1,\n+                        self_ty.to_string(),\n+                        body,\n+                        old_item_indent + 1\n+                    );\n+\n+                    body = impl_body_def;\n+\n+                    // Add the import for enum/struct corresponding to given impl block\n+                    if let Some(_) = module.make_use_stmt_of_node_with_super(self_ty.syntax()) {\n+                        for item in module.use_items {\n+                            let mut indented_item = String::new();\n+                            format_to!(\n+                                indented_item,\n+                                \"{}{}\",\n+                                old_item_indent + 1,\n+                                item.to_string()\n+                            );\n+                            body = format!(\"{}\\n\\n{}\", indented_item, body);\n+                        }\n+                    }\n+                }\n+            }\n \n             let mut module_def = String::new();\n \n@@ -135,7 +187,29 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n             for import_path_text_range in import_paths_to_be_removed {\n                 builder.delete(import_path_text_range);\n             }\n-            builder.replace(module.text_range, module_def)\n+\n+            if let Some(impl_) = impl_parent {\n+                let node_to_be_removed;\n+\n+                // Remove complete impl block if it has only one child (as such it will be empty\n+                // after deleting that child)\n+                if impl_child_count == 1 {\n+                    node_to_be_removed = impl_.syntax()\n+                } else {\n+                    //Remove selected node\n+                    node_to_be_removed = &node;\n+                }\n+\n+                builder.delete(node_to_be_removed.text_range());\n+                // Remove preceding indentation from node\n+                if let Some(range) = indent_range_before_given_node(&node_to_be_removed) {\n+                    builder.delete(range);\n+                }\n+\n+                builder.insert(impl_.syntax().text_range().end(), format!(\"\\n\\n{}\", module_def));\n+            } else {\n+                builder.replace(module.text_range, module_def)\n+            }\n         },\n     )\n }\n@@ -144,16 +218,24 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n struct Module {\n     text_range: TextRange,\n     name: String,\n-    body_items: Vec<ast::Item>,\n+    body_items: Vec<ast::Item>, // All items except use items\n+    use_items: Vec<ast::Item>, // Use items are kept separately as they help when the selection is inside an impl block, we can directly take these items and keep them outside generated impl block inside generated module\n }\n \n fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Module> {\n+    let mut use_items = vec![];\n+\n     let mut body_items: Vec<ast::Item> = node\n         .children()\n         .filter_map(|child| {\n-            if let Some(item) = ast::Item::cast(child) {\n-                if selection_range.contains_range(item.syntax().text_range()) {\n-                    return Some(item);\n+            if selection_range.contains_range(child.text_range()) {\n+                let child_kind = child.kind();\n+                if let Some(item) = ast::Item::cast(child) {\n+                    if ast::Use::can_cast(child_kind) {\n+                        use_items.push(item);\n+                    } else {\n+                        return Some(item);\n+                    }\n                 }\n                 return None;\n             }\n@@ -165,7 +247,7 @@ fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Modul\n         body_items.push(node_item);\n     }\n \n-    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items })\n+    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items, use_items })\n }\n \n impl Module {\n@@ -543,23 +625,27 @@ impl Module {\n             let use_ =\n                 make::use_(None, make::use_tree(make::join_paths(use_tree_str), None, None, false));\n             if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n-                self.body_items.insert(0, item);\n+                self.use_items.insert(0, item);\n             }\n         }\n \n         import_path_to_be_removed\n     }\n \n-    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) {\n+    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) -> Option<ast::Item> {\n         let super_path = make::ext::ident_path(\"super\");\n         let node_path = make::ext::ident_path(&node_syntax.to_string());\n         let use_ = make::use_(\n             None,\n             make::use_tree(make::join_paths(vec![super_path, node_path]), None, None, false),\n         );\n+\n         if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n-            self.body_items.insert(0, item);\n+            self.use_items.insert(0, item.clone());\n+            return Some(item);\n         }\n+\n+        return None;\n     }\n \n     fn process_use_stmt_for_import_resolve(\n@@ -859,6 +945,14 @@ fn compare_hir_and_ast_module(\n     return Some(());\n }\n \n+fn indent_range_before_given_node(node: &SyntaxNode) -> Option<TextRange> {\n+    let x = node.siblings_with_tokens(syntax::Direction::Prev).find(|x| {\n+        return x.kind() == WHITESPACE;\n+    })?;\n+\n+    return Some(x.text_range());\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -1435,4 +1529,63 @@ mod modname {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn test_if_inside_impl_block_generate_module_outside() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            struct A {}\n+\n+            impl A {\n+$0fn foo() {}$0\n+                fn bar() {}\n+            }\n+        \",\n+            r\"\n+            struct A {}\n+\n+            impl A {\n+                fn bar() {}\n+            }\n+\n+mod modname {\n+    use super::A;\n+\n+    impl A {\n+        pub(crate) fn foo() {}\n+    }\n+}\n+        \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_if_inside_impl_block_generate_module_outside_but_impl_block_having_one_child() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            struct A {}\n+            struct B {}\n+\n+            impl A {\n+$0fn foo(x: B) {}$0\n+            }\n+        \",\n+            r\"\n+            struct A {}\n+            struct B {}\n+\n+mod modname {\n+    use super::B;\n+\n+    use super::A;\n+\n+    impl A {\n+        pub(crate) fn foo(x: B) {}\n+    }\n+}\n+        \",\n+        )\n+    }\n }"}]}