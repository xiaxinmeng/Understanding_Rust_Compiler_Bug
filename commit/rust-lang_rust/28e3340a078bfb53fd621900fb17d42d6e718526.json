{"sha": "28e3340a078bfb53fd621900fb17d42d6e718526", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZTMzNDBhMDc4YmZiNTNmZDYyMTkwMGZiMTdkNDJkNmU3MTg1MjY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-12T10:42:17Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-12T12:50:56Z"}, "message": "std: migrate path::unix to using Vec internally.", "tree": {"sha": "bd66d5579ac9e4d3a3e37085c8228fdd337322de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd66d5579ac9e4d3a3e37085c8228fdd337322de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28e3340a078bfb53fd621900fb17d42d6e718526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28e3340a078bfb53fd621900fb17d42d6e718526", "html_url": "https://github.com/rust-lang/rust/commit/28e3340a078bfb53fd621900fb17d42d6e718526", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28e3340a078bfb53fd621900fb17d42d6e718526/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecc774f788ca3880ce76e4b87ac0d21a3a16d3ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc774f788ca3880ce76e4b87ac0d21a3a16d3ae", "html_url": "https://github.com/rust-lang/rust/commit/ecc774f788ca3880ce76e4b87ac0d21a3a16d3ae"}], "stats": {"total": 136, "additions": 72, "deletions": 64}, "files": [{"sha": "72cbdccddc03b07753c2033680910c5578681a1b", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28e3340a078bfb53fd621900fb17d42d6e718526/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e3340a078bfb53fd621900fb17d42d6e718526/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=28e3340a078bfb53fd621900fb17d42d6e718526", "patch": "@@ -70,10 +70,10 @@ use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{MaybeOwned, OwnedStr, Str, StrSlice, from_utf8_lossy};\n-use slice;\n-use slice::{CloneableVector, OwnedCloneableVector, OwnedVector, Vector};\n+use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n+use slice::{OwnedCloneableVector, OwnedVector, Vector};\n use slice::{ImmutableEqVector, ImmutableVector};\n+use vec::Vec;\n \n /// Typedef for POSIX file paths.\n /// See `posix::Path` for more info.\n@@ -184,7 +184,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn as_vec<'a>(&'a self) -> &'a [u8];\n \n     /// Converts the Path into an owned byte vector\n-    fn into_vec(self) -> ~[u8];\n+    fn into_vec(self) -> Vec<u8>;\n \n     /// Returns an object that implements `Show` for printing paths\n     ///\n@@ -293,15 +293,15 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name.slice_to(idx).to_owned()),\n+                (Some(idx), 0) => Some(Vec::from_slice(name.slice_to(idx))),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n                         Some(val) => val\n                     };\n \n                     let mut v;\n-                    v = slice::with_capacity(idx + extlen + 1);\n+                    v = Vec::with_capacity(idx + extlen + 1);\n                     v.push_all(name.slice_to(idx));\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n@@ -441,10 +441,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n pub trait BytesContainer {\n     /// Returns a &[u8] representing the receiver\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8];\n-    /// Consumes the receiver and converts it into ~[u8]\n+    /// Consumes the receiver and converts it into Vec<u8>\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n-        self.container_as_bytes().to_owned()\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n+        Vec::from_slice(self.container_as_bytes())\n     }\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]\n@@ -522,10 +522,6 @@ impl BytesContainer for ~str {\n         self.as_bytes()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n-        self.into_bytes()\n-    }\n-    #[inline]\n     fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         Some(self.as_slice())\n     }\n@@ -545,8 +541,15 @@ impl BytesContainer for ~[u8] {\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_slice()\n     }\n+}\n+\n+impl BytesContainer for Vec<u8> {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_slice()\n+    }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self\n     }\n }\n@@ -564,10 +567,6 @@ impl<'a> BytesContainer for str::MaybeOwned<'a> {\n         self.as_slice().as_bytes()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n-        self.into_owned().into_bytes()\n-    }\n-    #[inline]\n     fn container_as_str<'b>(&'b self) -> Option<&'b str> {\n         Some(self.as_slice())\n     }"}, {"sha": "72832f0a44fc0f37b03cda1158a609434ded9f5d", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/28e3340a078bfb53fd621900fb17d42d6e718526/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e3340a078bfb53fd621900fb17d42d6e718526/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=28e3340a078bfb53fd621900fb17d42d6e718526", "patch": "@@ -20,9 +20,10 @@ use iter::{AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n-use slice;\n use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n             ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n+use vec::Vec;\n+\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n@@ -40,7 +41,7 @@ pub type RevStrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n /// Represents a POSIX file path\n #[deriving(Clone)]\n pub struct Path {\n-    repr: ~[u8], // assumed to never be empty or contain NULs\n+    repr: Vec<u8>, // assumed to never be empty or contain NULs\n     sepidx: Option<uint> // index of the final separator in repr\n }\n \n@@ -103,7 +104,7 @@ impl BytesContainer for Path {\n         self.as_vec()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self.into_vec()\n     }\n }\n@@ -119,38 +120,41 @@ impl GenericPathUnsafe for Path {\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let path = Path::normalize(path.container_as_bytes());\n         assert!(!path.is_empty());\n-        let idx = path.rposition_elem(&SEP_BYTE);\n+        let idx = path.as_slice().rposition_elem(&SEP_BYTE);\n         Path{ repr: path, sepidx: idx }\n     }\n \n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr => {\n-                let mut v = slice::with_capacity(3 + filename.len());\n+            None if bytes!(\"..\") == self.repr.as_slice() => {\n+                let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n-                let mut v = slice::with_capacity(self.repr.len() + 1 + filename.len());\n-                v.push_all(self.repr);\n+                let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n+                v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n             Some(idx) => {\n-                let mut v = slice::with_capacity(idx + 1 + filename.len());\n+                let mut v = Vec::with_capacity(idx + 1 + filename.len());\n                 v.push_all(self.repr.slice_to(idx+1));\n                 v.push_all(filename);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n         }\n-        self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n+        self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n     }\n \n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n@@ -159,13 +163,14 @@ impl GenericPathUnsafe for Path {\n             if path[0] == SEP_BYTE {\n                 self.repr = Path::normalize(path);\n             }  else {\n-                let mut v = slice::with_capacity(self.repr.len() + path.len() + 1);\n-                v.push_all(self.repr);\n+                let mut v = Vec::with_capacity(self.repr.len() + path.len() + 1);\n+                v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n                 v.push_all(path);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n-            self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n+            self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n         }\n     }\n }\n@@ -176,13 +181,13 @@ impl GenericPath for Path {\n         self.repr.as_slice()\n     }\n \n-    fn into_vec(self) -> ~[u8] {\n+    fn into_vec(self) -> Vec<u8> {\n         self.repr\n     }\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr => self.repr.as_slice(),\n+            None if bytes!(\"..\") == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => self.repr.slice_to(1),\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n@@ -192,7 +197,8 @@ impl GenericPath for Path {\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => None,\n+            None if bytes!(\".\") == self.repr.as_slice() ||\n+                bytes!(\"..\") == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => None,\n             Some(0) if self.repr.slice_from(1).is_empty() => None,\n@@ -202,20 +208,20 @@ impl GenericPath for Path {\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr => false,\n+            None if bytes!(\".\") == self.repr.as_slice() => false,\n             None => {\n-                self.repr = ~['.' as u8];\n+                self.repr = vec!['.' as u8];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if bytes!(\"/\") == self.repr => false,\n+            Some(0) if bytes!(\"/\") == self.repr.as_slice() => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n+                self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n                 true\n             }\n         }\n@@ -231,7 +237,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        self.repr[0] == SEP_BYTE\n+        *self.repr.get(0) == SEP_BYTE\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n@@ -240,7 +246,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if bytes!(\".\") == self.repr {\n+            if bytes!(\".\") == self.repr.as_slice() {\n                 return match itb.next() {\n                     None => true,\n                     Some(b) => b != bytes!(\"..\")\n@@ -261,6 +267,7 @@ impl GenericPath for Path {\n         }\n     }\n \n+    #[allow(deprecated_owned_vector)]\n     fn path_relative_from(&self, base: &Path) -> Option<Path> {\n         if self.is_absolute() != base.is_absolute() {\n             if self.is_absolute() {\n@@ -271,7 +278,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = base.components();\n-            let mut comps = ~[];\n+            let mut comps = vec![];\n             loop {\n                 match (ita.next(), itb.next()) {\n                     (None, None) => break,\n@@ -295,7 +302,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n+            Some(Path::new(comps.as_slice().connect_vec(&SEP_BYTE)))\n         }\n     }\n \n@@ -334,7 +341,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> ~[u8] {\n+    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n@@ -344,11 +351,11 @@ impl Path {\n                 None => None,\n                 Some(comps) => {\n                     if is_abs && comps.is_empty() {\n-                        Some(~[SEP_BYTE])\n+                        Some(vec![SEP_BYTE])\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n-                        let mut v = slice::with_capacity(n);\n+                        let mut v = Vec::with_capacity(n);\n                         let mut it = comps.move_iter();\n                         if !is_abs {\n                             match it.next() {\n@@ -366,7 +373,7 @@ impl Path {\n             }\n         };\n         match val {\n-            None => v.into_owned(),\n+            None => Vec::from_slice(v.as_slice()),\n             Some(val) => val\n         }\n     }\n@@ -376,7 +383,7 @@ impl Path {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n-        let v = if self.repr[0] == SEP_BYTE {\n+        let v = if *self.repr.get(0) == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n@@ -390,7 +397,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n     pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        let v = if self.repr[0] == SEP_BYTE {\n+        let v = if *self.repr.get(0) == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.rsplit(is_sep_byte);\n@@ -415,11 +422,11 @@ impl Path {\n }\n \n // None result means the byte vector didn't need normalizing\n-fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n+fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     if is_abs && v.as_slice().is_empty() {\n         return None;\n     }\n-    let mut comps: ~[&'a [u8]] = ~[];\n+    let mut comps: Vec<&'a [u8]> = vec![];\n     let mut n_up = 0u;\n     let mut changed = false;\n     for comp in v.split(is_sep_byte) {"}, {"sha": "0693694ceabacca3f1afc44d5ff953da0bc5e1c1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28e3340a078bfb53fd621900fb17d42d6e718526/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e3340a078bfb53fd621900fb17d42d6e718526/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=28e3340a078bfb53fd621900fb17d42d6e718526", "patch": "@@ -24,6 +24,8 @@ use slice::{Vector, OwnedVector, ImmutableVector};\n use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n use str;\n use strbuf::StrBuf;\n+use vec::Vec;\n+\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &str\n@@ -128,7 +130,7 @@ impl BytesContainer for Path {\n         self.as_vec()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self.into_vec()\n     }\n     #[inline]\n@@ -331,8 +333,8 @@ impl GenericPath for Path {\n     }\n \n     #[inline]\n-    fn into_vec(self) -> ~[u8] {\n-        self.repr.into_bytes()\n+    fn into_vec(self) -> Vec<u8> {\n+        Vec::from_slice(self.repr.as_bytes())\n     }\n \n     #[inline]\n@@ -526,7 +528,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.str_components().map(|x|x.unwrap());\n             let mut itb = base.str_components().map(|x|x.unwrap());\n-            let mut comps = ~[];\n+            let mut comps = vec![];\n \n             let a_verb = is_verbatim(self);\n             let b_verb = is_verbatim(base);\n@@ -711,12 +713,12 @@ impl Path {\n             match (comps.is_some(),prefix) {\n                 (false, Some(DiskPrefix)) => {\n                     if s[0] >= 'a' as u8 && s[0] <= 'z' as u8 {\n-                        comps = Some(~[]);\n+                        comps = Some(vec![]);\n                     }\n                 }\n                 (false, Some(VerbatimDiskPrefix)) => {\n                     if s[4] >= 'a' as u8 && s[0] <= 'z' as u8 {\n-                        comps = Some(~[]);\n+                        comps = Some(vec![]);\n                     }\n                 }\n                 _ => ()\n@@ -1023,7 +1025,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n }\n \n // None result means the string didn't need normalizing\n-fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<~[&'a str]>) {\n+fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) {\n     let f = if !prefix_is_verbatim(prefix) { is_sep } else { is_sep_verbatim };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n     let s_ = s.slice_from(prefix_len(prefix));\n@@ -1032,11 +1034,11 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n     if is_abs && s_.is_empty() {\n         return (is_abs, match prefix {\n             Some(DiskPrefix) | None => (if is_sep_verbatim(s.char_at(prefix_len(prefix))) { None }\n-                                        else { Some(~[]) }),\n-            Some(_) => Some(~[]), // need to trim the trailing separator\n+                                        else { Some(vec![]) }),\n+            Some(_) => Some(vec![]), // need to trim the trailing separator\n         });\n     }\n-    let mut comps: ~[&'a str] = ~[];\n+    let mut comps: Vec<&'a str> = vec![];\n     let mut n_up = 0u;\n     let mut changed = false;\n     for comp in s_.split(f) {"}]}