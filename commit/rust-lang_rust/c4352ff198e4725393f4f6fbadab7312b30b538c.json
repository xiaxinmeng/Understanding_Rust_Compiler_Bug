{"sha": "c4352ff198e4725393f4f6fbadab7312b30b538c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MzUyZmYxOThlNDcyNTM5M2Y0ZjZmYmFkYWI3MzEyYjMwYjUzOGM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-13T13:14:43Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-17T20:13:09Z"}, "message": "Turn some functions from `token.rs` into methods on `Ident`", "tree": {"sha": "598a4b72559449ade1a86bd37dce70558fc1de7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/598a4b72559449ade1a86bd37dce70558fc1de7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4352ff198e4725393f4f6fbadab7312b30b538c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4352ff198e4725393f4f6fbadab7312b30b538c", "html_url": "https://github.com/rust-lang/rust/commit/c4352ff198e4725393f4f6fbadab7312b30b538c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4352ff198e4725393f4f6fbadab7312b30b538c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4cbc2388f6a7abace3df9bf97b7758f0dfc0d4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cbc2388f6a7abace3df9bf97b7758f0dfc0d4d", "html_url": "https://github.com/rust-lang/rust/commit/f4cbc2388f6a7abace3df9bf97b7758f0dfc0d4d"}], "stats": {"total": 147, "additions": 80, "deletions": 67}, "files": [{"sha": "940a68e8ce5ca7f6c7d6b9c81520e012d383ec0b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::{token, ParseSess};\n+use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n@@ -1559,7 +1559,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        if token::is_raw_guess(ast::Ident::with_empty_ctxt(name)) {\n+        if name.to_ident().is_raw_guess() {\n             self.s.word(&format!(\"r#{}\", name))?;\n         } else {\n             self.s.word(&name.as_str())?;"}, {"sha": "4f239a0868ebfaa87e49086f779ffae35c2df58d", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -21,7 +21,6 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n@@ -40,14 +39,13 @@ impl<'a> AstValidator<'a> {\n         let valid_names = [keywords::UnderscoreLifetime.name(),\n                            keywords::StaticLifetime.name(),\n                            keywords::Invalid.name()];\n-        if !valid_names.contains(&ident.name) &&\n-            token::is_reserved_ident(ident.without_first_quote()) {\n+        if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n             self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n-        if token::is_reserved_ident(ident.without_first_quote()) {\n+        if ident.without_first_quote().is_reserved() {\n             self.err_handler()\n                 .span_err(ident.span, &format!(\"invalid label name `{}`\", ident.name));\n         }"}, {"sha": "e13e6bc6b745677f9b60009920a89a60626102b5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -58,7 +58,6 @@ use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::feature_gate::{feature_err, GateIssue};\n-use syntax::parse::token;\n use syntax::ptr::P;\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n@@ -3274,7 +3273,7 @@ impl<'a> Resolver<'a> {\n                     // `$crate::a::b`\n                     module = Some(self.resolve_crate_root(ident.span.ctxt(), true));\n                     continue\n-                } else if i == 1 && !token::is_path_segment_keyword(ident) {\n+                } else if i == 1 && !ident.is_path_segment_keyword() {\n                     let prev_name = path[0].name;\n                     if prev_name == keywords::Extern.name() ||\n                        prev_name == keywords::CrateRoot.name() &&"}, {"sha": "16d5d3fa0437f3dec6d0b5e977918d5bc9948ef6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -27,7 +27,6 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{Ident, Name, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n@@ -667,7 +666,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         } else {\n                             Some(self.resolve_crate_root(source.span.ctxt().modern(), false))\n                         }\n-                    } else if is_extern && !token::is_path_segment_keyword(source) {\n+                    } else if is_extern && !source.is_path_segment_keyword() {\n                         let crate_id =\n                             self.resolver.crate_loader.process_use_extern(\n                                 source.name,\n@@ -715,8 +714,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             PathResult::Failed(span, msg, true) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                let is_special = |ident| token::is_path_segment_keyword(ident) &&\n-                                         ident.name != keywords::CrateRoot.name();\n+                let is_special = |ident: Ident| ident.is_path_segment_keyword() &&\n+                                                ident.name != keywords::CrateRoot.name();\n                 if !self_path.is_empty() && !is_special(self_path[0]) &&\n                    !(self_path.len() > 1 && is_special(self_path[1])) {\n                     self_path[0].name = keywords::SelfValue.name();"}, {"sha": "1817726d6a110bfc5367bd1bbd89e07dcf9cd72d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -107,8 +107,7 @@ impl Path {\n     // or starts with something like `self`/`super`/`$crate`/etc.\n     pub fn make_root(&self) -> Option<PathSegment> {\n         if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n-            if ::parse::token::is_path_segment_keyword(ident) &&\n-               ident.name != keywords::Crate.name() {\n+            if ident.is_path_segment_keyword() && ident.name != keywords::Crate.name() {\n                 return None;\n             }\n         }"}, {"sha": "7bef9e34d5a52209ed4bcb072e355e1d732430a0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -1149,7 +1149,7 @@ impl<'a> StringReader<'a> {\n                 return Ok(self.with_str_from(start, |string| {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n                     let ident = self.mk_ident(string);\n-                    if is_raw_ident && (token::is_path_segment_keyword(ident) ||\n+                    if is_raw_ident && (ident.is_path_segment_keyword() ||\n                                         ident.name == keywords::Underscore.name()) {\n                         self.fatal_span_(raw_start, self.pos,\n                             &format!(\"`r#{}` is not currently supported.\", ident.name)"}, {"sha": "5575614a4d482b8b39d66005cd6a1beb5e06f8d3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -15,14 +15,13 @@ pub use self::Lit::*;\n pub use self::Token::*;\n \n use ast::{self};\n-use edition::Edition;\n use parse::ParseSess;\n use print::pprust;\n use ptr::P;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use symbol::keywords;\n use syntax::parse::parse_stream_from_source_str;\n-use syntax_pos::{self, hygiene, Span, FileName};\n+use syntax_pos::{self, Span, FileName};\n use tokenstream::{TokenStream, TokenTree};\n use tokenstream;\n \n@@ -139,48 +138,6 @@ fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n     ].contains(&ident.name)\n }\n \n-pub fn is_path_segment_keyword(id: ast::Ident) -> bool {\n-    id.name == keywords::Super.name() ||\n-    id.name == keywords::SelfValue.name() ||\n-    id.name == keywords::SelfType.name() ||\n-    id.name == keywords::Extern.name() ||\n-    id.name == keywords::Crate.name() ||\n-    id.name == keywords::CrateRoot.name() ||\n-    id.name == keywords::DollarCrate.name()\n-}\n-\n-// We see this identifier in a normal identifier position, like variable name or a type.\n-// How was it written originally? Did it use the raw form? Let's try to guess.\n-pub fn is_raw_guess(ident: ast::Ident) -> bool {\n-    ident.name != keywords::Invalid.name() &&\n-    is_reserved_ident(ident) && !is_path_segment_keyword(ident)\n-}\n-\n-// Returns true for reserved identifiers used internally for elided lifetimes,\n-// unnamed method parameters, crate root module, error recovery etc.\n-pub fn is_special_ident(id: ast::Ident) -> bool {\n-    id.name <= keywords::Underscore.name()\n-}\n-\n-/// Returns `true` if the token is a keyword used in the language.\n-pub fn is_used_keyword(id: ast::Ident) -> bool {\n-    id.name >= keywords::As.name() && id.name <= keywords::While.name()\n-}\n-\n-/// Returns `true` if the token is a keyword reserved for possible future use.\n-pub fn is_unused_keyword(id: ast::Ident) -> bool {\n-    let edition = || id.span.ctxt().outer().expn_info().map_or_else(|| hygiene::default_edition(),\n-                                                                    |einfo| einfo.callee.edition);\n-    id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name() ||\n-    id.name == keywords::Proc.name() && edition() == Edition::Edition2015 ||\n-    id.name == keywords::Async.name() && edition() == Edition::Edition2018\n-}\n-\n-/// Returns `true` if the token is either a special identifier or a keyword.\n-pub fn is_reserved_ident(id: ast::Ident) -> bool {\n-    is_special_ident(id) || is_used_keyword(id) || is_unused_keyword(id)\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -256,7 +213,7 @@ impl Token {\n \n     /// Recovers a `Token` from an `ast::Ident`. This creates a raw identifier if necessary.\n     pub fn from_ast_ident(ident: ast::Ident) -> Token {\n-        Ident(ident, is_raw_guess(ident))\n+        Ident(ident, ident.is_raw_guess())\n     }\n \n     /// Returns `true` if the token starts with '>'.\n@@ -436,7 +393,7 @@ impl Token {\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n         match self.ident() {\n-            Some((id, false)) => is_path_segment_keyword(id),\n+            Some((id, false)) => id.is_path_segment_keyword(),\n             _ => false,\n         }\n     }\n@@ -445,31 +402,31 @@ impl Token {\n     // unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n         match self.ident() {\n-            Some((id, false)) => is_special_ident(id),\n+            Some((id, false)) => id.is_special(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(&self) -> bool {\n         match self.ident() {\n-            Some((id, false)) => is_used_keyword(id),\n+            Some((id, false)) => id.is_used_keyword(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_unused_keyword(&self) -> bool {\n         match self.ident() {\n-            Some((id, false)) => is_unused_keyword(id),\n+            Some((id, false)) => id.is_unused_keyword(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is either a special identifier or a keyword.\n     pub fn is_reserved_ident(&self) -> bool {\n         match self.ident() {\n-            Some((id, false)) => is_reserved_ident(id),\n+            Some((id, false)) => id.is_reserved(),\n             _ => false,\n         }\n     }"}, {"sha": "17f83a09c77b780cff60c42bf48c9d3cd3e21947", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -2374,7 +2374,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n-        if token::is_raw_guess(ident) {\n+        if ident.is_raw_guess() {\n             self.s.word(&format!(\"r#{}\", ident))?;\n         } else {\n             self.s.word(&ident.name.as_str())?;"}, {"sha": "e2656e2236e057db6017640cc0670db3c4f7adfa", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -300,6 +300,12 @@ impl Span {\n         self.ctxt().outer().expn_info().map(|i| i.call_site)\n     }\n \n+    /// Edition of the crate from which this span came.\n+    pub fn edition(self) -> edition::Edition {\n+        self.ctxt().outer().expn_info().map_or_else(|| hygiene::default_edition(),\n+                                                    |einfo| einfo.callee.edition)\n+    }\n+\n     /// Return the source callee.\n     ///\n     /// Returns None if the supplied span has no expansion trace,"}, {"sha": "35c94457e6ef5fe62236ebe7e92c269733420bcf", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4352ff198e4725393f4f6fbadab7312b30b538c/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c4352ff198e4725393f4f6fbadab7312b30b538c", "patch": "@@ -12,6 +12,7 @@\n //! allows bidirectional lookup; i.e. given a value, one can easily find the\n //! type, and vice versa.\n \n+use edition::Edition;\n use hygiene::SyntaxContext;\n use {Span, DUMMY_SP, GLOBALS};\n \n@@ -318,7 +319,7 @@ macro_rules! declare_keywords {(\n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_special_ident`, `is_used_keyword`/`is_unused_keyword`,\n+// After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n // this should be rarely necessary though if the keywords are kept in alphabetic order.\n declare_keywords! {\n     // Special reserved identifiers used internally for elided lifetimes,\n@@ -399,6 +400,60 @@ declare_keywords! {\n     (63, Union,              \"union\")\n }\n \n+impl Symbol {\n+    fn is_unused_keyword_2015(self) -> bool {\n+        self == keywords::Proc.name()\n+    }\n+\n+    fn is_unused_keyword_2018(self) -> bool {\n+        self == keywords::Async.name()\n+    }\n+}\n+\n+impl Ident {\n+    // Returns true for reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n+    pub fn is_special(self) -> bool {\n+        self.name <= keywords::Underscore.name()\n+    }\n+\n+    /// Returns `true` if the token is a keyword used in the language.\n+    pub fn is_used_keyword(self) -> bool {\n+        self.name >= keywords::As.name() && self.name <= keywords::While.name()\n+    }\n+\n+    /// Returns `true` if the token is a keyword reserved for possible future use.\n+    pub fn is_unused_keyword(self) -> bool {\n+        // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n+        self.name >= keywords::Abstract.name() && self.name <= keywords::Yield.name() ||\n+        self.name.is_unused_keyword_2015() && self.span.edition() == Edition::Edition2015 ||\n+        self.name.is_unused_keyword_2018() && self.span.edition() == Edition::Edition2018\n+    }\n+\n+    /// Returns `true` if the token is either a special identifier or a keyword.\n+    pub fn is_reserved(self) -> bool {\n+        self.is_special() || self.is_used_keyword() || self.is_unused_keyword()\n+    }\n+\n+    /// A keyword or reserved identifier that can be used as a path segment.\n+    pub fn is_path_segment_keyword(self) -> bool {\n+        self.name == keywords::Super.name() ||\n+        self.name == keywords::SelfValue.name() ||\n+        self.name == keywords::SelfType.name() ||\n+        self.name == keywords::Extern.name() ||\n+        self.name == keywords::Crate.name() ||\n+        self.name == keywords::CrateRoot.name() ||\n+        self.name == keywords::DollarCrate.name()\n+    }\n+\n+    // We see this identifier in a normal identifier position, like variable name or a type.\n+    // How was it written originally? Did it use the raw form? Let's try to guess.\n+    pub fn is_raw_guess(self) -> bool {\n+        self.name != keywords::Invalid.name() &&\n+        self.is_reserved() && !self.is_path_segment_keyword()\n+    }\n+}\n+\n // If an interner exists, return it. Otherwise, prepare a fresh one.\n #[inline]\n fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {"}]}