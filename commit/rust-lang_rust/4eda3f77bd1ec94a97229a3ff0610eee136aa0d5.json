{"sha": "4eda3f77bd1ec94a97229a3ff0610eee136aa0d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZGEzZjc3YmQxZWM5NGE5NzIyOWEzZmYwNjEwZWVlMTM2YWEwZDU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-09T19:59:15Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-09T23:35:59Z"}, "message": "intra-doc macro resolution should also handle proc macros", "tree": {"sha": "ec805ace661f4e0e0b18b2c8fc70850a6037f972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec805ace661f4e0e0b18b2c8fc70850a6037f972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eda3f77bd1ec94a97229a3ff0610eee136aa0d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eda3f77bd1ec94a97229a3ff0610eee136aa0d5", "html_url": "https://github.com/rust-lang/rust/commit/4eda3f77bd1ec94a97229a3ff0610eee136aa0d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eda3f77bd1ec94a97229a3ff0610eee136aa0d5/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feb3536eba10c2e4585d066629598f03d5ddc7c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/feb3536eba10c2e4585d066629598f03d5ddc7c6", "html_url": "https://github.com/rust-lang/rust/commit/feb3536eba10c2e4585d066629598f03d5ddc7c6"}], "stats": {"total": 63, "additions": 39, "deletions": 24}, "files": [{"sha": "4514a616bd85638d395445f81ab7649a82d8a8cc", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4eda3f77bd1ec94a97229a3ff0610eee136aa0d5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eda3f77bd1ec94a97229a3ff0610eee136aa0d5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4eda3f77bd1ec94a97229a3ff0610eee136aa0d5", "patch": "@@ -122,6 +122,42 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    /// Resolves a string as a macro.\n+    fn macro_resolve(&self, path_str: &str, parent_id: Option<hir::HirId>) -> Option<Res> {\n+        let cx = self.cx;\n+        let path = ast::Path::from_ident(Ident::from_str(path_str));\n+        cx.enter_resolver(|resolver| {\n+            if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n+                &path,\n+                None,\n+                &ParentScope::module(resolver.graph_root()),\n+                false,\n+                false,\n+            ) {\n+                if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n+                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                }\n+            }\n+            if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+            }\n+            if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n+                let module_id = cx.tcx.hir().local_def_id(module_id);\n+                if let Ok((_, res)) =\n+                    resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n+                {\n+                    // don't resolve builtins like `#[derive]`\n+                    if let Res::Def(..) = res {\n+                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                        return Some(res);\n+                    }\n+                }\n+            } else {\n+                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+            }\n+            None\n+        })\n+    }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve(\n@@ -615,7 +651,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     None => {\n                         // Try everything!\n                         let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str)\n+                            macro_ns: self\n+                                .macro_resolve(path_str, base_node)\n                                 .map(|res| (res, extra_fragment.clone())),\n                             type_ns: match self.resolve(\n                                 path_str,\n@@ -684,7 +721,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(res) = macro_resolve(cx, path_str) {\n+                        if let Some(res) = self.macro_resolve(path_str, base_node) {\n                             (res, extra_fragment)\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -727,28 +764,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n-/// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    let path = ast::Path::from_ident(Ident::from_str(path_str));\n-    cx.enter_resolver(|resolver| {\n-        if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path,\n-            None,\n-            &ParentScope::module(resolver.graph_root()),\n-            false,\n-            false,\n-        ) {\n-            if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-            }\n-        }\n-        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-            return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-        }\n-        None\n-    })\n-}\n-\n fn build_diagnostic(\n     cx: &DocContext<'_>,\n     item: &Item,"}]}