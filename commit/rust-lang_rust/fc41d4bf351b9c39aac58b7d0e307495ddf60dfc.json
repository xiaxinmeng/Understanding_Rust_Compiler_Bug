{"sha": "fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "node_id": "C_kwDOAAsO6NoAKGZjNDFkNGJmMzUxYjljMzlhYWM1OGI3ZDBlMzA3NDk1ZGRmNjBkZmM", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-02-17T18:16:04Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-02-21T18:28:22Z"}, "message": "Take CodegenFnAttrs into account when validating asm! register operands\n\nChecking of asm! register operands now properly takes function\nattributes such as #[target_feature] and #[instruction_set] into\naccount.", "tree": {"sha": "5d28b85623dfd71ab7614487cf68a1e2514aee61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d28b85623dfd71ab7614487cf68a1e2514aee61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "html_url": "https://github.com/rust-lang/rust/commit/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ceb104851c2c3054f680d89f9d9333b5e5110be", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ceb104851c2c3054f680d89f9d9333b5e5110be", "html_url": "https://github.com/rust-lang/rust/commit/1ceb104851c2c3054f680d89f9d9333b5e5110be"}], "stats": {"total": 358, "additions": 171, "deletions": 187}, "files": [{"sha": "171cc60dfd77c28b79dca802aa4c81d31b7543ea", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -64,13 +64,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut clobber_abis = FxHashMap::default();\n         if let Some(asm_arch) = asm_arch {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n-                match asm::InlineAsmClobberAbi::parse(\n-                    asm_arch,\n-                    self.sess.relocation_model(),\n-                    &self.sess.target_features,\n-                    &self.sess.target,\n-                    *abi_name,\n-                ) {\n+                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.sess.target, *abi_name) {\n                     Ok(abi) => {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n@@ -130,18 +124,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg, is_clobber| match reg {\n+                let lower_reg = |reg| match reg {\n                     InlineAsmRegOrRegClass::Reg(s) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                sess.relocation_model(),\n-                                &sess.target_features,\n-                                &sess.target,\n-                                is_clobber,\n-                                s,\n-                            )\n-                            .unwrap_or_else(|e| {\n+                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n                                 let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n                                 sess.struct_span_err(*op_sp, &msg).emit();\n                                 asm::InlineAsmReg::Err\n@@ -165,24 +151,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(reg, false),\n+                        reg: lower_reg(reg),\n                         expr: self.lower_expr_mut(expr),\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(reg, expr.is_none()),\n+                        reg: lower_reg(reg),\n                         late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg, false),\n+                            reg: lower_reg(reg),\n                             late,\n                             expr: self.lower_expr_mut(expr),\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(reg, false),\n+                            reg: lower_reg(reg),\n                             late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),"}, {"sha": "deac5dfd3ec1adc43b8e2380446dba99a493eb6e", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -106,6 +106,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     let mut asm_gen = InlineAssemblyGenerator {\n         tcx: fx.tcx,\n         arch: fx.tcx.sess.asm_arch.unwrap(),\n+        enclosing_def_id: fx.instance.def_id(),\n         template,\n         operands,\n         options,\n@@ -169,6 +170,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n struct InlineAssemblyGenerator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     arch: InlineAsmArch,\n+    enclosing_def_id: DefId,\n     template: &'a [InlineAsmTemplatePiece],\n     operands: &'a [InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n@@ -185,7 +187,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         let map = allocatable_registers(\n             self.arch,\n             sess.relocation_model(),\n-            &sess.target_features,\n+            self.tcx.asm_target_features(self.enclosing_def_id),\n             &sess.target,\n         );\n         let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n@@ -318,15 +320,9 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n \n         // Allocate stack slots for saving clobbered registers\n-        let abi_clobber = InlineAsmClobberAbi::parse(\n-            self.arch,\n-            self.tcx.sess.relocation_model(),\n-            &self.tcx.sess.target_features,\n-            &self.tcx.sess.target,\n-            sym::C,\n-        )\n-        .unwrap()\n-        .clobbered_regs();\n+        let abi_clobber = InlineAsmClobberAbi::parse(self.arch, &self.tcx.sess.target, sym::C)\n+            .unwrap()\n+            .clobbered_regs();\n         for (i, reg) in self.registers.iter().enumerate().filter_map(|(i, r)| r.map(|r| (i, r))) {\n             let mut need_save = true;\n             // If the register overlaps with a register clobbered by function call, then"}, {"sha": "069dac969c66e0cdce9bafabbec4e02c9fe86203", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -1046,6 +1046,10 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n+    query asm_target_features(def_id: DefId) -> &'tcx FxHashSet<Symbol> {\n+        desc { |tcx| \"computing target features for inline asm of `{}`\", tcx.def_path_str(def_id) }\n+    }\n+\n     query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n         desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern"}, {"sha": "d7dde157864a499049360dae548cf53b2df1628a", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast::InlineAsmTemplatePiece;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -138,7 +139,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n-        target_features: &[Symbol],\n+        target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n@@ -285,9 +286,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         // (!). In that case we still need the earlier check to verify that the\n         // register class is usable at all.\n         if let Some(feature) = feature {\n-            if !self.tcx.sess.target_features.contains(&feature)\n-                && !target_features.contains(&feature)\n-            {\n+            if !target_features.contains(&feature) {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n                 err.note(&format!(\n@@ -347,7 +346,8 @@ impl<'tcx> ExprVisitor<'tcx> {\n         let hir = self.tcx.hir();\n         let enclosing_id = hir.enclosing_body_owner(hir_id);\n         let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n-        let attrs = self.tcx.codegen_fn_attrs(enclosing_def_id);\n+        let target_features = self.tcx.asm_target_features(enclosing_def_id);\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n         for (idx, (op, op_sp)) in asm.operands.iter().enumerate() {\n             // Validate register classes against currently enabled target\n             // features. We check that at least one type is available for\n@@ -360,16 +360,29 @@ impl<'tcx> ExprVisitor<'tcx> {\n             // Note that this is only possible for explicit register\n             // operands, which cannot be used in the asm string.\n             if let Some(reg) = op.reg() {\n+                // Some explicit registers cannot be used depending on the\n+                // target. Reject those here.\n+                if let InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    if let Err(msg) = reg.validate(\n+                        asm_arch,\n+                        self.tcx.sess.relocation_model(),\n+                        &target_features,\n+                        &self.tcx.sess.target,\n+                        op.is_clobber(),\n+                    ) {\n+                        let msg = format!(\"cannot use register `{}`: {}\", reg.name(), msg);\n+                        self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                        continue;\n+                    }\n+                }\n+\n                 if !op.is_clobber() {\n                     let mut missing_required_features = vec![];\n                     let reg_class = reg.reg_class();\n-                    for &(_, feature) in reg_class.supported_types(self.tcx.sess.asm_arch.unwrap())\n-                    {\n+                    for &(_, feature) in reg_class.supported_types(asm_arch) {\n                         match feature {\n                             Some(feature) => {\n-                                if self.tcx.sess.target_features.contains(&feature)\n-                                    || attrs.target_features.contains(&feature)\n-                                {\n+                                if target_features.contains(&feature) {\n                                     missing_required_features.clear();\n                                     break;\n                                 } else {\n@@ -425,7 +438,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         true,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                 }\n                 hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n@@ -437,7 +450,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             None,\n-                            &attrs.target_features,\n+                            &target_features,\n                         );\n                     }\n                 }\n@@ -449,7 +462,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         false,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                 }\n                 hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n@@ -460,7 +473,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         true,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                     if let Some(out_expr) = out_expr {\n                         self.check_asm_operand_type(\n@@ -470,7 +483,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             Some((in_expr, in_ty)),\n-                            &attrs.target_features,\n+                            &target_features,\n                         );\n                     }\n                 }"}, {"sha": "7fb4dbdf2b181086d3e29a4d2e0efd19a920c95f", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::{Target, RelocModel};\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -73,18 +73,18 @@ impl AArch64InlineAsmRegClass {\n     }\n }\n \n-pub fn reserved_x18(\n+pub fn target_reserves_x18(target: &Target) -> bool {\n+    target.os == \"android\" || target.is_like_fuchsia || target.is_like_osx || target.is_like_windows\n+}\n+\n+fn reserved_x18(\n     _arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    if target.os == \"android\"\n-        || target.is_like_fuchsia\n-        || target.is_like_osx\n-        || target.is_like_windows\n-    {\n+    if target_reserves_x18(target) {\n         Err(\"x18 is a reserved register on this target\")\n     } else {\n         Ok(())"}, {"sha": "5bc4b566daf67f86a241082c544ba75b90a6444d", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 87, "deletions": 113, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -25,7 +25,7 @@ macro_rules! def_reg_class {\n                 }\n             }\n \n-            pub fn parse(_arch: super::InlineAsmArch, name: rustc_span::Symbol) -> Result<Self, &'static str> {\n+            pub fn parse(name: rustc_span::Symbol) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n                         rustc_span::sym::$class => Ok(Self::$class),\n@@ -79,25 +79,38 @@ macro_rules! def_regs {\n                 }\n             }\n \n-            pub fn parse(\n+            pub fn parse(name: &str) -> Result<Self, &'static str> {\n+                match name {\n+                    $(\n+                        $($alias)|* | $reg_name => Ok(Self::$reg),\n+                    )*\n+                    $(\n+                        $($bad_reg)|* => Err($error),\n+                    )*\n+                    _ => Err(\"unknown register\"),\n+                }\n+            }\n+\n+            pub fn validate(self,\n                 _arch: super::InlineAsmArch,\n                 _reloc_model: crate::spec::RelocModel,\n                 _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n                 _target: &crate::spec::Target,\n                 _is_clobber: bool,\n-                name: &str,\n-            ) -> Result<Self, &'static str> {\n-                match name {\n+            ) -> Result<(), &'static str> {\n+                match self {\n                     $(\n-                        $($alias)|* | $reg_name => {\n-                            $($filter(_arch, _reloc_model, _target_features, _target, _is_clobber)?;)?\n-                            Ok(Self::$reg)\n+                        Self::$reg => {\n+                            $($filter(\n+                                _arch,\n+                                _reloc_model,\n+                                _target_features,\n+                                _target,\n+                                _is_clobber\n+                            )?;)?\n+                            Ok(())\n                         }\n                     )*\n-                    $(\n-                        $($bad_reg)|* => Err($error),\n-                    )*\n-                    _ => Err(\"unknown register\"),\n                 }\n             }\n         }\n@@ -297,95 +310,60 @@ impl InlineAsmReg {\n         }\n     }\n \n-    pub fn parse(\n-        arch: InlineAsmArch,\n-        reloc_model: RelocModel,\n-        target_features: &FxHashSet<Symbol>,\n-        target: &Target,\n-        is_clobber: bool,\n-        name: Symbol,\n-    ) -> Result<Self, &'static str> {\n+    pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n         // FIXME: use direct symbol comparison for register names\n         // Use `Symbol::as_str` instead of `Symbol::with` here because `has_feature` may access `Symbol`.\n         let name = name.as_str();\n         Ok(match arch {\n-            InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64 => Self::X86(X86InlineAsmReg::parse(name)?),\n+            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmReg::parse(name)?),\n+            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(name)?),\n+            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                Self::RiscV(RiscVInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Arm => {\n-                Self::Arm(ArmInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n+            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(name)?),\n+            InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n+                Self::PowerPC(PowerPCInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => Self::RiscV(\n-                RiscVInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?,\n-            ),\n-            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => Self::PowerPC(\n-                PowerPCInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?,\n-            ),\n-            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Mips | InlineAsmArch::Mips64 => Self::Mips(MipsInlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => Self::Wasm(WasmInlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Bpf => {\n-                Self::Bpf(BpfInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n+            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n+                Self::Mips(MipsInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Avr => {\n-                Self::Avr(AvrInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(name)?),\n+            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n+                Self::Wasm(WasmInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(\n-                arch,\n-                reloc_model,target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(name)?),\n         })\n     }\n \n+    pub fn validate(\n+        self,\n+        arch: InlineAsmArch,\n+        reloc_model: RelocModel,\n+        target_features: &FxHashSet<Symbol>,\n+        target: &Target,\n+        is_clobber: bool,\n+    ) -> Result<(), &'static str> {\n+        match self {\n+            Self::X86(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Arm(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::AArch64(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::RiscV(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::PowerPC(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Hexagon(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Mips(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::S390x(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Bpf(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Avr(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Msp430(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Err => unreachable!(),\n+        }\n+    }\n+\n     // NOTE: This function isn't used at the moment, but is needed to support\n     // falling back to an external assembler.\n     pub fn emit(\n@@ -587,29 +565,29 @@ impl InlineAsmRegClass {\n     pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmRegClass::parse(arch, name)?)\n+                Self::X86(X86InlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmRegClass::parse(name)?),\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n-                Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n+                Self::RiscV(RiscVInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n-                Self::PowerPC(PowerPCInlineAsmRegClass::parse(arch, name)?)\n+                Self::PowerPC(PowerPCInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n-                Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n+                Self::Mips(MipsInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n-                Self::Wasm(WasmInlineAsmRegClass::parse(arch, name)?)\n+                Self::Wasm(WasmInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(name)?),\n         })\n     }\n \n@@ -857,8 +835,6 @@ impl InlineAsmClobberAbi {\n     /// clobber ABIs for the target.\n     pub fn parse(\n         arch: InlineAsmArch,\n-        reloc_model: RelocModel,\n-        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static [&'static str]> {\n@@ -882,13 +858,11 @@ impl InlineAsmClobberAbi {\n                 _ => Err(&[\"C\", \"system\", \"efiapi\", \"aapcs\"]),\n             },\n             InlineAsmArch::AArch64 => match name {\n-                \"C\" | \"system\" | \"efiapi\" => {\n-                    Ok(if aarch64::reserved_x18(arch, reloc_model, target_features, target, true).is_err() {\n-                        InlineAsmClobberAbi::AArch64NoX18\n-                    } else {\n-                        InlineAsmClobberAbi::AArch64\n-                    })\n-                }\n+                \"C\" | \"system\" | \"efiapi\" => Ok(if aarch64::target_reserves_x18(target) {\n+                    InlineAsmClobberAbi::AArch64NoX18\n+                } else {\n+                    InlineAsmClobberAbi::AArch64\n+                }),\n                 _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n             },\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => match name {"}, {"sha": "c8bcc1d41d39c47d7cfceb63973fd8f03b362a64", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -87,6 +87,7 @@ pub fn provide(providers: &mut Providers) {\n         static_mutability,\n         generator_kind,\n         codegen_fn_attrs,\n+        asm_target_features,\n         collect_mod_item_types,\n         should_inherit_track_caller,\n         ..*providers\n@@ -3255,6 +3256,24 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     codegen_fn_attrs\n }\n \n+/// Computes the set of target features used in a function for the purposes of\n+/// inline assembly.\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> &'tcx FxHashSet<Symbol> {\n+    let mut target_features = tcx.sess.target_features.clone();\n+    let attrs = tcx.codegen_fn_attrs(id);\n+    target_features.extend(&attrs.target_features);\n+    match attrs.instruction_set {\n+        None => {}\n+        Some(InstructionSetAttr::ArmA32) => {\n+            target_features.remove(&sym::thumb_mode);\n+        }\n+        Some(InstructionSetAttr::ArmT32) => {\n+            target_features.insert(sym::thumb_mode);\n+        }\n+    }\n+    tcx.arena.alloc(target_features)\n+}\n+\n /// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {"}, {"sha": "4c4ce8b5e9e493ecd6f22fcc9bd70a9d036b4038", "filename": "src/test/ui/asm/x86_64/bad-reg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -31,8 +31,6 @@ fn main() {\n         //~^ ERROR invalid register `ip`: the instruction pointer cannot be used as an operand\n         asm!(\"\", in(\"k0\") foo);\n         //~^ ERROR invalid register `k0`: the k0 AVX mask register cannot be used as an operand\n-        asm!(\"\", in(\"ah\") foo);\n-        //~^ ERROR invalid register `ah`: high byte registers cannot be used as an operand\n \n         asm!(\"\", in(\"st(2)\") foo);\n         //~^ ERROR register class `x87_reg` can only be used as a clobber, not as an input or output"}, {"sha": "f8b024e1acd62c3b7d8891d4cc80ce558a312f63", "filename": "src/test/ui/asm/x86_64/bad-reg.stderr", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc41d4bf351b9c39aac58b7d0e307495ddf60dfc/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr?ref=fc41d4bf351b9c39aac58b7d0e307495ddf60dfc", "patch": "@@ -70,91 +70,85 @@ error: invalid register `k0`: the k0 AVX mask register cannot be used as an oper\n LL |         asm!(\"\", in(\"k0\") foo);\n    |                  ^^^^^^^^^^^^\n \n-error: invalid register `ah`: high byte registers cannot be used as an operand on x86_64\n-  --> $DIR/bad-reg.rs:34:18\n-   |\n-LL |         asm!(\"\", in(\"ah\") foo);\n-   |                  ^^^^^^^^^^^^\n-\n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:37:18\n+  --> $DIR/bad-reg.rs:35:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:39:18\n+  --> $DIR/bad-reg.rs:37:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:43:20\n+  --> $DIR/bad-reg.rs:41:20\n    |\n LL |         asm!(\"{}\", in(x87_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:45:20\n+  --> $DIR/bad-reg.rs:43:20\n    |\n LL |         asm!(\"{}\", in(mmx_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:47:20\n+  --> $DIR/bad-reg.rs:45:20\n    |\n LL |         asm!(\"{}\", out(x87_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:49:20\n+  --> $DIR/bad-reg.rs:47:20\n    |\n LL |         asm!(\"{}\", out(mmx_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register `al` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:55:33\n+  --> $DIR/bad-reg.rs:53:33\n    |\n LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n    |                  -------------  ^^^^^^^^^^^^ register `al`\n    |                  |\n    |                  register `ax`\n \n error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:57:33\n+  --> $DIR/bad-reg.rs:55:33\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n    |                  |\n    |                  register `ax`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:57:18\n+  --> $DIR/bad-reg.rs:55:18\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  ^^^^^^^^^^^^^\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:60:34\n+  --> $DIR/bad-reg.rs:58:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:62:34\n+  --> $DIR/bad-reg.rs:60:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:62:18\n+  --> $DIR/bad-reg.rs:60:18\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  ^^^^^^^^^^^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n "}]}