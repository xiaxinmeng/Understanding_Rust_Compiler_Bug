{"sha": "54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YWUzNzdlYzI2ZWQ0N2JiYjYyN2JkY2I1OGJiMTA2NThjZjAzYzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-29T18:59:49Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-01T03:39:01Z"}, "message": "librustc: Implement explicit @self and ~self for objects. r=nmatsakis", "tree": {"sha": "1e157d5af47aba7ae8b6901f00141539366b1dbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e157d5af47aba7ae8b6901f00141539366b1dbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "html_url": "https://github.com/rust-lang/rust/commit/54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3afd6c3d79c92c2e182133e447c92765c862b327", "url": "https://api.github.com/repos/rust-lang/rust/commits/3afd6c3d79c92c2e182133e447c92765c862b327", "html_url": "https://github.com/rust-lang/rust/commit/3afd6c3d79c92c2e182133e447c92765c862b327"}], "stats": {"total": 176, "additions": 149, "deletions": 27}, "files": [{"sha": "c8776741c79ef4e313f407ea469fecc36bf0f400", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "patch": "@@ -546,40 +546,85 @@ fn trans_trait_callee_from_llval(bcx: block,\n     let mut llself;\n     debug!(\"(translating trait callee) loading second index from pair\");\n     let llbox = Load(bcx, GEPi(bcx, llpair, [0u, 1u]));\n-    match vstore {\n-        ty::vstore_box | ty::vstore_uniq => {\n-            llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-        }\n-        ty::vstore_slice(_) => {\n-            llself = llbox;\n-        }\n-        ty::vstore_fixed(*) => {\n-            bcx.tcx().sess.bug(~\"vstore_fixed trait\");\n-        }\n-    }\n \n     // Munge `llself` appropriately for the type of `self` in the method.\n+    let self_mode;\n     match explicit_self {\n         ast::sty_static => {\n             bcx.tcx().sess.bug(~\"shouldn't see static method here\");\n         }\n-        ast::sty_by_ref => {}   // Nothing to do.\n+        ast::sty_by_ref => {\n+            // We need to pass a pointer to a pointer to the payload.\n+            match vstore {\n+                ty::vstore_box | ty::vstore_uniq => {\n+                    llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+                }\n+                ty::vstore_slice(_) => {\n+                    llself = llbox;\n+                }\n+                ty::vstore_fixed(*) => {\n+                    bcx.tcx().sess.bug(~\"vstore_fixed trait\");\n+                }\n+            }\n+\n+            self_mode = ast::by_ref;\n+        }\n         ast::sty_value => {\n             bcx.tcx().sess.bug(~\"methods with by-value self should not be \\\n                                called on objects\");\n         }\n         ast::sty_region(_) => {\n+            // As before, we need to pass a pointer to a pointer to the\n+            // payload.\n+            match vstore {\n+                ty::vstore_box | ty::vstore_uniq => {\n+                    llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+                }\n+                ty::vstore_slice(_) => {\n+                    llself = llbox;\n+                }\n+                ty::vstore_fixed(*) => {\n+                    bcx.tcx().sess.bug(~\"vstore_fixed trait\");\n+                }\n+            }\n+\n             let llscratch = alloca(bcx, val_ty(llself));\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n+\n+            self_mode = ast::by_ref;\n         }\n         ast::sty_box(_) => {\n             // Bump the reference count on the box.\n             debug!(\"(translating trait callee) callee type is `%s`\",\n                    bcx.ty_to_str(callee_ty));\n-            bcx = glue::take_ty(bcx, llself, callee_ty);\n+            bcx = glue::take_ty(bcx, llbox, callee_ty);\n+\n+            // Pass a pointer to the box.\n+            match vstore {\n+                ty::vstore_box => llself = llbox,\n+                _ => bcx.tcx().sess.bug(~\"@self receiver with non-@Trait\")\n+            }\n+\n+            let llscratch = alloca(bcx, val_ty(llself));\n+            Store(bcx, llself, llscratch);\n+            llself = llscratch;\n+\n+            self_mode = ast::by_ref;\n+        }\n+        ast::sty_uniq(_) => {\n+            // Pass the unique pointer.\n+            match vstore {\n+                ty::vstore_uniq => llself = llbox,\n+                _ => bcx.tcx().sess.bug(~\"~self receiver with non-~Trait\")\n+            }\n+\n+            let llscratch = alloca(bcx, val_ty(llself));\n+            Store(bcx, llself, llscratch);\n+            llself = llscratch;\n+\n+            self_mode = ast::by_ref;\n         }\n-        ast::sty_uniq(_) => {}  // Nothing to do here.\n     }\n \n     // Load the function from the vtable and cast it to the expected type.\n@@ -594,7 +639,7 @@ fn trans_trait_callee_from_llval(bcx: block,\n             llfn: mptr,\n             llself: llself,\n             self_ty: ty::mk_opaque_box(bcx.tcx()),\n-            self_mode: ast::by_ref, // XXX: is this bogosity?\n+            self_mode: self_mode,\n             /* XXX: Some(llbox) */\n         })\n     };"}, {"sha": "43292f20e79248ef73c8215bd666b68749cf0f9a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "patch": "@@ -140,6 +140,15 @@ struct Candidate {\n     origin: method_origin,\n }\n \n+/**\n+ * Whether the self type should be transformed according to the form of\n+ * explicit self provided by the method.\n+ */\n+enum TransformTypeFlag {\n+    DontTransformType,\n+    TransformType\n+}\n+\n impl LookupContext {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n@@ -402,7 +411,10 @@ impl LookupContext {\n \n                 let (rcvr_ty, rcvr_substs) =\n                     self.create_rcvr_ty_and_substs_for_method(\n-                        method.self_ty, rcvr_ty, move init_substs);\n+                        method.self_ty,\n+                        rcvr_ty,\n+                        move init_substs,\n+                        TransformType);\n \n                 let cand = Candidate {\n                     rcvr_ty: rcvr_ty,\n@@ -461,8 +473,10 @@ impl LookupContext {\n         let rcvr_substs = {self_ty: Some(self_ty), ..*substs};\n \n         let (rcvr_ty, rcvr_substs) =\n-            self.create_rcvr_ty_and_substs_for_method(\n-                method.self_ty, self_ty, move rcvr_substs);\n+            self.create_rcvr_ty_and_substs_for_method(method.self_ty,\n+                                                      self_ty,\n+                                                      move rcvr_substs,\n+                                                      DontTransformType);\n \n         self.inherent_candidates.push(Candidate {\n             rcvr_ty: rcvr_ty,\n@@ -490,7 +504,10 @@ impl LookupContext {\n         let rcvr_substs = { self_ty: Some(self_ty), ..*substs };\n         let (rcvr_ty, rcvr_substs) =\n             self.create_rcvr_ty_and_substs_for_method(\n-                method.self_ty, self_ty, move rcvr_substs);\n+                method.self_ty,\n+                self_ty,\n+                move rcvr_substs,\n+                TransformType);\n \n         self.inherent_candidates.push(Candidate {\n             rcvr_ty: rcvr_ty,\n@@ -542,7 +559,10 @@ impl LookupContext {\n \n         let (impl_ty, impl_substs) =\n             self.create_rcvr_ty_and_substs_for_method(\n-                method.self_type, impl_ty, move impl_substs);\n+                method.self_type,\n+                impl_ty,\n+                move impl_substs,\n+                TransformType);\n \n         candidates.push(Candidate {\n             rcvr_ty: impl_ty,\n@@ -577,7 +597,8 @@ impl LookupContext {\n                 self.create_rcvr_ty_and_substs_for_method(\n                     provided_method_info.method_info.self_type,\n                     self_ty,\n-                    dummy_substs);\n+                    dummy_substs,\n+                    TransformType);\n \n             candidates.push(Candidate {\n                 rcvr_ty: impl_ty,\n@@ -594,8 +615,9 @@ impl LookupContext {\n     fn create_rcvr_ty_and_substs_for_method(&self,\n                                             self_decl: ast::self_ty_,\n                                             self_ty: ty::t,\n-                                            +self_substs: ty::substs)\n-        -> (ty::t, ty::substs) {\n+                                            +self_substs: ty::substs,\n+                                            transform_type: TransformTypeFlag)\n+                                         -> (ty::t, ty::substs) {\n         // If the self type includes a region (like &self), we need to\n         // ensure that the receiver substitutions have a self region.\n         // If the receiver type does not itself contain borrowed\n@@ -624,10 +646,18 @@ impl LookupContext {\n             }\n         };\n \n-        let rcvr_ty =\n-            transform_self_type_for_method(\n-                self.tcx(), rcvr_substs.self_r,\n-                self_ty, self_decl);\n+        let rcvr_ty;\n+        match transform_type {\n+            TransformType => {\n+                rcvr_ty = transform_self_type_for_method(self.tcx(),\n+                                                         rcvr_substs.self_r,\n+                                                         self_ty,\n+                                                         self_decl);\n+            }\n+            DontTransformType => {\n+                rcvr_ty = self_ty;\n+            }\n+        }\n \n         (rcvr_ty, rcvr_substs)\n     }"}, {"sha": "6ada89b1e6714952b2c592cabebf870ee28e1db8", "filename": "src/test/run-pass/explicit-self-objects-box.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-box.rs?ref=54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "patch": "@@ -0,0 +1,24 @@\n+trait Foo {\n+    fn f(@self);\n+}\n+\n+struct S {\n+    x: int\n+}\n+\n+impl S : Foo {\n+    fn f(@self) {\n+        assert self.x == 3;\n+    }\n+}\n+\n+fn main() {\n+    let x = @S { x: 3 };\n+    let y = x as @Foo;\n+    y.f();\n+    y.f();\n+    y.f();\n+    y.f();\n+}\n+\n+"}, {"sha": "26b2f4b8309173de3e746e95db2fdfe2c6b44345", "filename": "src/test/run-pass/explicit-self-objects-uniq.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ae377ec26ed47bbb627bdcb58bb10658cf03c4/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs?ref=54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "patch": "@@ -0,0 +1,23 @@\n+trait Foo {\n+    fn f(~self);\n+}\n+\n+struct S {\n+    x: int\n+}\n+\n+impl S : Foo {\n+    fn f(~self) {\n+        assert self.x == 3;\n+    }\n+}\n+\n+fn main() {\n+    let x = ~S { x: 3 };\n+    let y = x as ~Foo;\n+    y.f();\n+    y.f();\n+    y.f();\n+}\n+\n+"}]}