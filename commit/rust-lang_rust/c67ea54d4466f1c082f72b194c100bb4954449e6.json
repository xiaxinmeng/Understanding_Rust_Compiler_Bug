{"sha": "c67ea54d4466f1c082f72b194c100bb4954449e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2N2VhNTRkNDQ2NmYxYzA4MmY3MmIxOTRjMTAwYmI0OTU0NDQ5ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-04T03:08:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-04T03:08:22Z"}, "message": "Auto merge of #54624 - arielb1:evaluate-outlives, r=nikomatsakis\n\nhandle outlives predicates in trait evaluation\n\nThis handles higher-ranked outlives predicates in trait evaluation the same way they are handled in projection.\n\nFixes #54302. I think this is a more correct fix than #54401 because it fixes the root case in evaluation instead of making evaluation used in less cases. However, we might want to go to a direction closer to @nikomatsakis's solution with Chalk.\n\nr? @nikomatsakis", "tree": {"sha": "43682e32de55f547e989db99d91e3419dc7ad445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43682e32de55f547e989db99d91e3419dc7ad445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c67ea54d4466f1c082f72b194c100bb4954449e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c67ea54d4466f1c082f72b194c100bb4954449e6", "html_url": "https://github.com/rust-lang/rust/commit/c67ea54d4466f1c082f72b194c100bb4954449e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c67ea54d4466f1c082f72b194c100bb4954449e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0787284da6e25a018f2f94fcd3779d33d6150fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0787284da6e25a018f2f94fcd3779d33d6150fc", "html_url": "https://github.com/rust-lang/rust/commit/d0787284da6e25a018f2f94fcd3779d33d6150fc"}, {"sha": "1069c0e38f28539ab29c32921435b3f28eb63808", "url": "https://api.github.com/repos/rust-lang/rust/commits/1069c0e38f28539ab29c32921435b3f28eb63808", "html_url": "https://github.com/rust-lang/rust/commit/1069c0e38f28539ab29c32921435b3f28eb63808"}], "stats": {"total": 333, "additions": 328, "deletions": 5}, "files": [{"sha": "e6bf02cd73e0da09757bd7aea4c33c934ed7c14e", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             ty::Predicate::Trait(ref data) => {\n                 let trait_obligation = obligation.with(data.clone());\n \n-                if data.is_global() && !data.has_late_bound_regions() {\n+                if data.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n                     // FIXME: consider caching errors too.\n                     if self.selcx.infcx().predicate_must_hold(&obligation) {\n@@ -362,6 +362,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                         match binder.no_late_bound_regions() {\n                             // If so, this obligation is an error (for now). Eventually we should be\n                             // able to support additional cases here, like `for<'a> &'a str: 'a`.\n+                            // NOTE: this is duplicate-implemented between here and fulfillment.\n                             None => {\n                                 ProcessResult::Error(CodeSelectionError(Unimplemented))\n                             }"}, {"sha": "860914d1984ecd90de81822eafdaf410b9e629e8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -690,10 +690,92 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n-                // we do not consider region relationships when\n-                // evaluating trait matches\n-                Ok(EvaluatedToOk)\n+            ty::Predicate::TypeOutlives(ref binder) => {\n+                assert!(!binder.has_escaping_regions());\n+                // Check if the type has higher-ranked regions.\n+                if binder.skip_binder().0.has_escaping_regions() {\n+                    // If so, this obligation is an error (for now). Eventually we should be\n+                    // able to support additional cases here, like `for<'a> &'a str: 'a`.\n+\n+                    // NOTE: this hack is implemented in both trait fulfillment and\n+                    // evaluation. If you fix it in one place, make sure you fix it\n+                    // in the other.\n+\n+                    // We don't want to allow this sort of reasoning in intercrate\n+                    // mode, for backwards-compatibility reasons.\n+                    if self.intercrate.is_some() {\n+                        Ok(EvaluatedToAmbig)\n+                    } else {\n+                        Ok(EvaluatedToErr)\n+                    }\n+                } else {\n+                    // If the type has no late bound regions, then if we assign all\n+                    // the inference variables in it to be 'static, then the type\n+                    // will be 'static itself.\n+                    //\n+                    // Therefore, `staticize(T): 'a` holds for any `'a`, so this\n+                    // obligation is fulfilled. Because evaluation works with\n+                    // staticized types (yes I know this is involved with #21974),\n+                    // we are 100% OK here.\n+                    Ok(EvaluatedToOk)\n+                }\n+            }\n+\n+            ty::Predicate::RegionOutlives(ref binder) => {\n+                let ty::OutlivesPredicate(r_a, r_b) = binder.skip_binder();\n+\n+                if r_a == r_b {\n+                    // for<'a> 'a: 'a. OK\n+                    Ok(EvaluatedToOk)\n+                } else if **r_a == ty::ReStatic {\n+                    // 'static: 'x always holds.\n+                    //\n+                    // This special case is handled somewhat inconsistently - if we\n+                    // have an inference variable that is supposed to be equal to\n+                    // `'static`, then we don't allow it to be equated to an LBR,\n+                    // but if we have a literal `'static`, then we *do*.\n+                    //\n+                    // This is actually consistent with how our region inference works.\n+                    //\n+                    // It would appear that this sort of inconsistency would\n+                    // cause \"instability\" problems with evaluation caching. However,\n+                    // evaluation caching is only for trait predicates, and when\n+                    // trait predicates create nested obligations, they contain\n+                    // inference variables for all the regions in the trait - the\n+                    // only way this codepath can be reached from trait predicate\n+                    // evaluation is when the user typed an explicit `where 'static: 'a`\n+                    // lifetime bound (in which case we want to return EvaluatedToOk).\n+                    //\n+                    // If we ever want to handle inference variables that might be\n+                    // equatable with ReStatic, we need to make sure we are not confused by\n+                    // technically-allowed-by-RFC-447-but-probably-should-not-be\n+                    // impls such as\n+                    // ```Rust\n+                    // impl<'a, 's, T> X<'s> for T where T: Debug + 'a, 'a: 's\n+                    // ```\n+                    Ok(EvaluatedToOk)\n+                } else if r_a.is_late_bound() || r_b.is_late_bound() {\n+                    // There is no current way to prove `for<'a> 'a: 'x`\n+                    // unless `'a = 'x`, because there are no bounds involving\n+                    // lifetimes.\n+\n+                    // It might be possible to prove `for<'a> 'x: 'a` by forcing `'x`\n+                    // to be `'static`. However, this is not currently done by type\n+                    // inference unless `'x` is literally ReStatic. See the comment\n+                    // above.\n+\n+                    // We don't want to allow this sort of reasoning in intercrate\n+                    // mode, for backwards-compatibility reasons.\n+                    if self.intercrate.is_some() {\n+                        Ok(EvaluatedToAmbig)\n+                    } else {\n+                        Ok(EvaluatedToErr)\n+                    }\n+                } else {\n+                    // Relating 2 inference variable regions. These will\n+                    // always hold if our query is \"staticized\".\n+                    Ok(EvaluatedToOk)\n+                }\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n@@ -900,6 +982,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\",\n                    stack.fresh_trait_ref);\n+\n             let cycle = stack.iter().skip(1).take(rec_index + 1);\n             let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n             if self.coinductive_match(cycle) {"}, {"sha": "6d1c61c80f06e983d4224e20fb375f4bce55c4eb", "filename": "src/test/ui/issue-54302-cases.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302-cases.rs?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Mirror {\n+    type Image;\n+    fn coerce(self) -> Self::Image;\n+}\n+\n+impl<T> Mirror for T {\n+    type Image = T;\n+    fn coerce(self) -> Self { self }\n+}\n+\n+trait Foo<'x, T> {\n+    fn foo(self) -> &'x T;\n+}\n+\n+impl<'s, 'x, T: 'x> Foo<'x, T> for &'s T where &'s T: Foo2<'x, T> {\n+    fn foo(self) -> &'x T { self.foo2() }\n+}\n+\n+trait Foo2<'x, T> {\n+    fn foo2(self) -> &'x T;\n+}\n+\n+// example 1 - fails leak check\n+impl<'x> Foo2<'x, u32> for &'x u32\n+{\n+    fn foo2(self) -> &'x u32 { self }\n+}\n+\n+// example 2 - OK with this issue\n+impl<'x, 'a: 'x> Foo2<'x, i32> for &'a i32\n+{\n+    fn foo2(self) -> &'x i32 { self }\n+}\n+\n+// example 3 - fails due to issue #XYZ + Leak-check\n+impl<'x, T> Foo2<'x, u64> for T\n+    where T: Mirror<Image=&'x u64>\n+{\n+    fn foo2(self) -> &'x u64 { self.coerce() }\n+}\n+\n+// example 4 - fails due to issue #XYZ\n+impl<'x, 'a: 'x, T> Foo2<'x, i64> for T\n+    where T: Mirror<Image=&'a i64>\n+{\n+    fn foo2(self) -> &'x i64 { self.coerce() }\n+}\n+\n+\n+trait RefFoo<T> {\n+    fn ref_foo(&self) -> &'static T;\n+}\n+\n+impl<T> RefFoo<T> for T where for<'a> &'a T: Foo<'static, T> {\n+    fn ref_foo(&self) -> &'static T {\n+        self.foo()\n+    }\n+}\n+\n+\n+fn coerce_lifetime1(a: &u32) -> &'static u32\n+{\n+    <u32 as RefFoo<u32>>::ref_foo(a)\n+    //~^ ERROR the trait bound `for<'a> &'a u32: Foo2<'_, u32>` is not satisfied\n+}\n+\n+fn coerce_lifetime2(a: &i32) -> &'static i32\n+{\n+    <i32 as RefFoo<i32>>::ref_foo(a)\n+    //~^ ERROR the requirement `for<'a> 'a : ` is not satisfied\n+}\n+\n+fn coerce_lifetime3(a: &u64) -> &'static u64\n+{\n+    <u64 as RefFoo<u64>>::ref_foo(a)\n+    //~^ ERROR type mismatch resolving `for<'a> <&'a u64 as Mirror>::Image == &u64`\n+}\n+\n+fn coerce_lifetime4(a: &i64) -> &'static i64\n+{\n+    <i64 as RefFoo<i64>>::ref_foo(a)\n+    //~^ ERROR type mismatch resolving `for<'a> <&'a i64 as Mirror>::Image == &i64`\n+}\n+\n+fn main() {}"}, {"sha": "9603f7a973c139e3422f833730f00204ca7e28bc", "filename": "src/test/ui/issue-54302-cases.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302-cases.stderr?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -0,0 +1,65 @@\n+error[E0277]: the trait bound `for<'a> &'a u32: Foo2<'_, u32>` is not satisfied\n+  --> $DIR/issue-54302-cases.rs:73:5\n+   |\n+LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> Foo2<'_, u32>` is not implemented for `&'a u32`\n+   |\n+   = help: the following implementations were found:\n+             <&'x u32 as Foo2<'x, u32>>\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, u32>` for `&'a u32`\n+   = note: required because of the requirements on the impl of `RefFoo<u32>` for `u32`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0279]: the requirement `for<'a> 'a : ` is not satisfied (`expected bound lifetime parameter 'a, found concrete lifetime`)\n+  --> $DIR/issue-54302-cases.rs:79:5\n+   |\n+LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, i32>` for `&'a i32`\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, i32>` for `&'a i32`\n+   = note: required because of the requirements on the impl of `RefFoo<i32>` for `i32`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `for<'a> <&'a u64 as Mirror>::Image == &u64`\n+  --> $DIR/issue-54302-cases.rs:85:5\n+   |\n+LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |\n+   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, u64>` for `&'a u64`\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, u64>` for `&'a u64`\n+   = note: required because of the requirements on the impl of `RefFoo<u64>` for `u64`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `for<'a> <&'a i64 as Mirror>::Image == &i64`\n+  --> $DIR/issue-54302-cases.rs:91:5\n+   |\n+LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |\n+   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, i64>` for `&'a i64`\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, i64>` for `&'a i64`\n+   = note: required because of the requirements on the impl of `RefFoo<i64>` for `i64`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors occurred: E0271, E0277, E0279.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "969d19cac2d76d57d86271784f2867a600cd85b9", "filename": "src/test/ui/issue-54302.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302.rs?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Deserialize<'de> {}\n+\n+trait DeserializeOwned: for<'de> Deserialize<'de> {}\n+impl<T> DeserializeOwned for T where T: for<'de> Deserialize<'de> {}\n+\n+// Based on this impl, `&'static str` only implements Deserialize<'static>.\n+// It does not implement for<'de> Deserialize<'de>.\n+impl<'de: 'a, 'a> Deserialize<'de> for &'a str {}\n+\n+fn main() {\n+    // Then why does it implement DeserializeOwned? This compiles.\n+    fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+    assert_deserialize_owned::<&'static str>();\n+    //~^ ERROR the requirement `for<'de> 'de : ` is not satisfied\n+\n+    // It correctly does not implement for<'de> Deserialize<'de>.\n+    //fn assert_hrtb<T: for<'de> Deserialize<'de>>() {}\n+    //assert_hrtb::<&'static str>();\n+}"}, {"sha": "f122daeecf63a7cd4f2e4b58c715cf9b9ea904ea", "filename": "src/test/ui/issue-54302.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Fissue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302.stderr?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -0,0 +1,17 @@\n+error[E0279]: the requirement `for<'de> 'de : ` is not satisfied (`expected bound lifetime parameter 'de, found concrete lifetime`)\n+  --> $DIR/issue-54302.rs:23:5\n+   |\n+LL |     assert_deserialize_owned::<&'static str>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `for<'de> Deserialize<'de>` for `&'static str`\n+   = note: required because of the requirements on the impl of `DeserializeOwned` for `&'static str`\n+note: required by `main::assert_deserialize_owned`\n+  --> $DIR/issue-54302.rs:22:5\n+   |\n+LL |     fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0279`."}, {"sha": "1051bec63079e8f75facc2ab8abaac3fb229bcdf", "filename": "src/test/ui/run-pass/traits/traits-static-outlives-a-where-clause.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Frun-pass%2Ftraits%2Ftraits-static-outlives-a-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67ea54d4466f1c082f72b194c100bb4954449e6/src%2Ftest%2Fui%2Frun-pass%2Ftraits%2Ftraits-static-outlives-a-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Ftraits%2Ftraits-static-outlives-a-where-clause.rs?ref=c67ea54d4466f1c082f72b194c100bb4954449e6", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+\n+trait Foo<'a> {\n+    fn xyz(self);\n+}\n+impl<'a, T> Foo<'a> for T where 'static: 'a {\n+    fn xyz(self) {}\n+}\n+\n+trait Bar {\n+    fn uvw(self);\n+}\n+impl<T> Bar for T where for<'a> T: Foo<'a> {\n+    fn uvw(self) { self.xyz(); }\n+}\n+\n+fn foo<T>(t: T) where T: Bar {\n+    t.uvw();\n+}\n+\n+fn main() {\n+    foo(0);\n+}"}]}