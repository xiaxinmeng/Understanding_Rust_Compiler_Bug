{"sha": "63c5c928561b45dcef5c13881f09e5bc98c1eb9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYzVjOTI4NTYxYjQ1ZGNlZjVjMTM4ODFmMDllNWJjOThjMWViOWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-14T15:29:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-14T15:29:00Z"}, "message": "Merge #7668\n\n7668: Finalize rename infra rewrite r=matklad a=Veykril\n\nThis should be the final PR in regards to rewriting rename stuff, #4290.\r\n\r\nIt addresses 3 things:\r\n\t- Currently renaming import aliases causes some undesired behavior(see #5198) which is why this PR causes us to just return an error if an attempt at renaming an alias is made for the time being. Though this only prevents it from happening when the alias import is renamed, so its not too helpful.\r\n\t- Fixes #6898\r\n\t- If we are inside a macro file simply rename the input name node as there isn't really a way to do any of the fancy shorthand renames and similar things as for that we would have to exactly know what the macro generates and what not.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e338540418eeff1c317d9781ae17dd32c987e9a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e338540418eeff1c317d9781ae17dd32c987e9a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63c5c928561b45dcef5c13881f09e5bc98c1eb9a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgKUG8CRBK7hj4Ov3rIwAAdHIIAGE3QA1RBRGIXIVY7Lsp3bps\ntP5taHfR28+AWdIiCEnCSnegE/hIVSoU3JzBsfEMeMzKY6lyD8tM+Xn6xywokvEN\n7RCxt0wQetY/xdgxW75mtfNYoblB0RIiV1IwJhsN2LrhxfnJSywuex48N0CPvJMT\nFjkdAih7Bz2XPVrR9frg8C6EUHwegfKIS7BX18S8WSdMScRzL5qvnbO5dUlXY5K6\nCC8Dqm5RNN7AMHulWKMDccLYIDrqODxCHUG5UpnyrJiQW3tXtNmxLVJOz9Uu9K1s\nKiujCh7S0W7/S7086xLDMXYIc5gxGsLaX47JFSbFSS7O917d2mKyjH3QCRq30gU=\n=JYJ9\n-----END PGP SIGNATURE-----\n", "payload": "tree e338540418eeff1c317d9781ae17dd32c987e9a2\nparent 8638bcbfe79a19f3c2a75bd35054e90a245af3af\nparent 7b64622780bfa33c593ba856bdb6cfc31b220265\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1613316540 +0000\ncommitter GitHub <noreply@github.com> 1613316540 +0000\n\nMerge #7668\n\n7668: Finalize rename infra rewrite r=matklad a=Veykril\n\nThis should be the final PR in regards to rewriting rename stuff, #4290.\r\n\r\nIt addresses 3 things:\r\n\t- Currently renaming import aliases causes some undesired behavior(see #5198) which is why this PR causes us to just return an error if an attempt at renaming an alias is made for the time being. Though this only prevents it from happening when the alias import is renamed, so its not too helpful.\r\n\t- Fixes #6898\r\n\t- If we are inside a macro file simply rename the input name node as there isn't really a way to do any of the fancy shorthand renames and similar things as for that we would have to exactly know what the macro generates and what not.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63c5c928561b45dcef5c13881f09e5bc98c1eb9a", "html_url": "https://github.com/rust-lang/rust/commit/63c5c928561b45dcef5c13881f09e5bc98c1eb9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63c5c928561b45dcef5c13881f09e5bc98c1eb9a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8638bcbfe79a19f3c2a75bd35054e90a245af3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/8638bcbfe79a19f3c2a75bd35054e90a245af3af", "html_url": "https://github.com/rust-lang/rust/commit/8638bcbfe79a19f3c2a75bd35054e90a245af3af"}, {"sha": "7b64622780bfa33c593ba856bdb6cfc31b220265", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b64622780bfa33c593ba856bdb6cfc31b220265", "html_url": "https://github.com/rust-lang/rust/commit/7b64622780bfa33c593ba856bdb6cfc31b220265"}], "stats": {"total": 184, "additions": 133, "deletions": 51}, "files": [{"sha": "08f16b54df2cf8f93f90f39662e82187dec8c056", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 131, "deletions": 48, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/63c5c928561b45dcef5c13881f09e5bc98c1eb9a/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c5c928561b45dcef5c13881f09e5bc98c1eb9a/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=63c5c928561b45dcef5c13881f09e5bc98c1eb9a", "patch": "@@ -75,8 +75,7 @@ pub(crate) fn rename_with_semantics(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n \n-    let def = find_definition(sema, syntax, position)\n-        .ok_or_else(|| format_err!(\"No references found at position\"))?;\n+    let def = find_definition(sema, syntax, position)?;\n     match def {\n         Definition::ModuleDef(ModuleDef::Module(module)) => rename_mod(&sema, module, new_name),\n         def => rename_reference(sema, def, new_name),\n@@ -149,18 +148,30 @@ fn find_definition(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> Option<Definition> {\n-    let def = match find_name_like(sema, syntax, position)? {\n-        NameLike::Name(name) => NameClass::classify(sema, &name)?.referenced_or_defined(sema.db),\n-        NameLike::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref)?.referenced(sema.db),\n+) -> RenameResult<Definition> {\n+    match find_name_like(sema, syntax, position)\n+        .ok_or_else(|| format_err!(\"No references found at position\"))?\n+    {\n+        // renaming aliases would rename the item being aliased as the HIR doesn't track aliases yet\n+        NameLike::Name(name)\n+            if name.syntax().parent().map_or(false, |it| ast::Rename::can_cast(it.kind())) =>\n+        {\n+            bail!(\"Renaming aliases is currently unsupported\")\n+        }\n+        NameLike::Name(name) => {\n+            NameClass::classify(sema, &name).map(|class| class.referenced_or_defined(sema.db))\n+        }\n+        NameLike::NameRef(name_ref) => {\n+            NameRefClass::classify(sema, &name_ref).map(|class| class.referenced(sema.db))\n+        }\n         NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n             .map(|class| NameRefClass::referenced(class, sema.db))\n             .or_else(|| {\n                 NameClass::classify_lifetime(sema, &lifetime)\n                     .map(|it| it.referenced_or_defined(sema.db))\n-            })?,\n-    };\n-    Some(def)\n+            }),\n+    }\n+    .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n fn source_edit_from_references(\n@@ -173,21 +184,40 @@ fn source_edit_from_references(\n     let mut edit = TextEdit::builder();\n     for reference in references {\n         let (range, replacement) = match &reference.name {\n-            NameLike::Name(_) => (None, format!(\"{}\", new_name)),\n-            NameLike::NameRef(name_ref) => source_edit_from_name_ref(name_ref, new_name, def),\n-            NameLike::Lifetime(_) => (None, format!(\"{}\", new_name)),\n-        };\n-        // FIXME: Some(range) will be incorrect when we are inside macros\n-        edit.replace(range.unwrap_or(reference.range), replacement);\n+            // if the ranges differ then the node is inside a macro call, we can't really attempt\n+            // to make special rewrites like shorthand syntax and such, so just rename the node in\n+            // the macro input\n+            NameLike::NameRef(name_ref) if name_ref.syntax().text_range() == reference.range => {\n+                source_edit_from_name_ref(name_ref, new_name, def)\n+            }\n+            NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n+                source_edit_from_name(name, new_name)\n+            }\n+            _ => None,\n+        }\n+        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n+        edit.replace(range, replacement);\n     }\n     (file_id, edit.finish())\n }\n \n+fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n+        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n+            return Some((\n+                TextRange::empty(ident_pat.syntax().text_range().start()),\n+                format!(\"{}: \", new_name),\n+            ));\n+        }\n+    }\n+    None\n+}\n+\n fn source_edit_from_name_ref(\n     name_ref: &ast::NameRef,\n     new_name: &str,\n     def: Definition,\n-) -> (Option<TextRange>, String) {\n+) -> Option<(TextRange, String)> {\n     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_expr = record_field.expr();\n@@ -197,45 +227,40 @@ fn source_edit_from_name_ref(\n                 if field_name == *name_ref {\n                     if init.text() == new_name {\n                         mark::hit!(test_rename_field_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead\n+                        // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n                         let e = record_field.syntax().text_range().end();\n-                        return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n                     }\n                 } else if init == *name_ref {\n                     if field_name.text() == new_name {\n                         mark::hit!(test_rename_local_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead\n+                        // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n                         let e = record_field.syntax().text_range().end();\n-                        return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n                     }\n                 }\n+                None\n             }\n             // init shorthand\n-            (None, Some(_)) => {\n-                // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-                // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n-                match def {\n-                    Definition::Field(_) => {\n-                        mark::hit!(test_rename_field_in_field_shorthand);\n-                        let s = name_ref.syntax().text_range().start();\n-                        return (Some(TextRange::empty(s)), format!(\"{}: \", new_name));\n-                    }\n-                    Definition::Local(_) => {\n-                        mark::hit!(test_rename_local_in_field_shorthand);\n-                        let s = name_ref.syntax().text_range().end();\n-                        return (Some(TextRange::empty(s)), format!(\": {}\", new_name));\n-                    }\n-                    _ => {}\n-                }\n+            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n+                mark::hit!(test_rename_field_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().start();\n+                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n             }\n-            _ => {}\n+            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n+                mark::hit!(test_rename_local_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().end();\n+                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+            }\n+            _ => None,\n         }\n-    }\n-    if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n+    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_pat = record_field.pat();\n         match (rcf_name_ref, rcf_pat) {\n@@ -244,17 +269,20 @@ fn source_edit_from_name_ref(\n                 // field name is being renamed\n                 if pat.name().map_or(false, |it| it.text() == new_name) {\n                     mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead\n+                    // same names, we can use a shorthand here instead/\n                     // we do not want to erase attributes hence this range start\n                     let s = field_name.syntax().text_range().start();\n                     let e = record_field.syntax().text_range().end();\n-                    return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                    Some((TextRange::new(s, e), pat.to_string()))\n+                } else {\n+                    None\n                 }\n             }\n-            _ => {}\n+            _ => None,\n         }\n+    } else {\n+        None\n     }\n-    (None, format!(\"{}\", new_name))\n }\n \n fn rename_mod(\n@@ -1477,24 +1505,24 @@ fn foo(i: i32) -> Foo {\n     }\n \n     #[test]\n-    fn test_struct_field_destructure_into_shorthand() {\n+    fn test_struct_field_pat_into_shorthand() {\n         mark::check!(test_rename_field_put_init_shorthand_pat);\n         check(\n             \"baz\",\n             r#\"\n struct Foo { i$0: i32 }\n \n fn foo(foo: Foo) {\n-    let Foo { i: baz } = foo;\n-    let _ = baz;\n+    let Foo { i: ref baz @ qux } = foo;\n+    let _ = qux;\n }\n \"#,\n             r#\"\n struct Foo { baz: i32 }\n \n fn foo(foo: Foo) {\n-    let Foo { baz } = foo;\n-    let _ = baz;\n+    let Foo { ref baz @ qux } = foo;\n+    let _ = qux;\n }\n \"#,\n         );\n@@ -1567,6 +1595,27 @@ fn foo(Foo { i: bar }: foo) -> i32 {\n         )\n     }\n \n+    #[test]\n+    fn test_struct_field_complex_ident_pat() {\n+        check(\n+            \"baz\",\n+            r#\"\n+struct Foo { i$0: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { ref i } = foo;\n+}\n+\"#,\n+            r#\"\n+struct Foo { baz: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { baz: ref i } = foo;\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_lifetimes() {\n         mark::check!(rename_lifetime);\n@@ -1671,6 +1720,40 @@ struct Foo;\n impl Foo {\n     fn foo(self) {}\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_rename_field_in_pat_in_macro_doesnt_shorthand() {\n+        // ideally we would be able to make this emit a short hand, but I doubt this is easily possible\n+        check(\n+            \"baz\",\n+            r#\"\n+macro_rules! foo {\n+    ($pattern:pat) => {\n+        let $pattern = loop {};\n+    };\n+}\n+struct Foo {\n+    bar$0: u32,\n+}\n+fn foo() {\n+    foo!(Foo { bar: baz });\n+}\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+    ($pattern:pat) => {\n+        let $pattern = loop {};\n+    };\n+}\n+struct Foo {\n+    baz: u32,\n+}\n+fn foo() {\n+    foo!(Foo { baz: baz });\n+}\n \"#,\n         )\n     }"}, {"sha": "307e150e944b618ffae0cc6b42af7c4a2f195446", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63c5c928561b45dcef5c13881f09e5bc98c1eb9a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c5c928561b45dcef5c13881f09e5bc98c1eb9a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=63c5c928561b45dcef5c13881f09e5bc98c1eb9a", "patch": "@@ -3,12 +3,11 @@\n \n use std::fmt;\n \n-use ast::AttrsOwner;\n use itertools::Itertools;\n use parser::SyntaxKind;\n \n use crate::{\n-    ast::{self, support, AstNode, AstToken, NameOwner, SyntaxNode},\n+    ast::{self, support, AstNode, AstToken, AttrsOwner, NameOwner, SyntaxNode},\n     SmolStr, SyntaxElement, SyntaxToken, T,\n };\n \n@@ -324,7 +323,7 @@ impl ast::RecordPatField {\n \n     pub fn for_field_name(field_name: &ast::Name) -> Option<ast::RecordPatField> {\n         let candidate =\n-            field_name.syntax().ancestors().nth(3).and_then(ast::RecordPatField::cast)?;\n+            field_name.syntax().ancestors().nth(2).and_then(ast::RecordPatField::cast)?;\n         match candidate.field_name()? {\n             NameOrNameRef::Name(name) if name == *field_name => Some(candidate),\n             _ => None,"}]}