{"sha": "0e4b710af83844f4a7c471c5335c99aaaa25a90c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNGI3MTBhZjgzODQ0ZjRhN2M0NzFjNTMzNWM5OWFhYWEyNWE5MGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-28T00:42:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-28T00:42:26Z"}, "message": "introduce hir crate", "tree": {"sha": "a073635942db7431b93e191aa98201a01e3fc2cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a073635942db7431b93e191aa98201a01e3fc2cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e4b710af83844f4a7c471c5335c99aaaa25a90c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e4b710af83844f4a7c471c5335c99aaaa25a90c", "html_url": "https://github.com/rust-lang/rust/commit/0e4b710af83844f4a7c471c5335c99aaaa25a90c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e4b710af83844f4a7c471c5335c99aaaa25a90c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f66e5b6e6b6f7b2b899ef4207dfe46655d77334c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f66e5b6e6b6f7b2b899ef4207dfe46655d77334c", "html_url": "https://github.com/rust-lang/rust/commit/f66e5b6e6b6f7b2b899ef4207dfe46655d77334c"}], "stats": {"total": 2287, "additions": 2270, "deletions": 17}, "files": [{"sha": "d673a58f74d5cf43b3b55ca9eefbfb9bc6f1e58d", "filename": "Cargo.lock", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -656,6 +656,22 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"id-arena 1.0.2 (git+https://github.com/fitzgen/id-arena/?rev=43ecd67)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_db 0.1.0\",\n+ \"ra_editor 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_lsp_server\"\n version = \"0.1.0\""}, {"sha": "a1912e90b5cd6e68b98f727a54d52600fb9a05a8", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -9,15 +9,6 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate salsa;\n \n-macro_rules! ctry {\n-    ($expr:expr) => {\n-        match $expr {\n-            None => return Ok(None),\n-            Some(it) => it,\n-        }\n-    };\n-}\n-\n mod arena;\n mod db;\n mod imp;\n@@ -47,7 +38,7 @@ pub use ra_editor::{\n };\n \n pub use ra_db::{\n-    Canceled, Cancelable,\n+    Canceled, Cancelable, FilePosition,\n     CrateGraph, CrateId, FileId, FileResolver\n };\n \n@@ -119,12 +110,6 @@ impl AnalysisHost {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct FilePosition {\n-    pub file_id: FileId,\n-    pub offset: TextUnit,\n-}\n-\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,"}, {"sha": "33cb0e2ecb8ce6f06989f56376b2ab29fef5a352", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -13,7 +13,7 @@ mod loc2id;\n \n use std::sync::Arc;\n use ra_editor::LineIndex;\n-use ra_syntax::SourceFileNode;\n+use ra_syntax::{TextUnit, SourceFileNode};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct Canceled;\n@@ -81,3 +81,9 @@ fn file_lines(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<LineIndex> {\n     let text = db.file_text(file_id);\n     Arc::new(LineIndex::new(&*text))\n }\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct FilePosition {\n+    pub file_id: FileId,\n+    pub offset: TextUnit,\n+}"}, {"sha": "9bde289e707eeebab90c37765f935fa599cfd07c", "filename": "crates/ra_hir/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+relative-path = \"0.4.0\"\n+salsa = \"0.8.0\"\n+rustc-hash = \"1.0\"\n+parking_lot = \"0.6.4\"\n+id-arena = { git = \"https://github.com/fitzgen/id-arena/\", rev = \"43ecd67\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_editor = { path = \"../ra_editor\" }\n+ra_db = { path = \"../ra_db\" }\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "a752ec0c11b44e8005d11478d62bc28de5071a82", "filename": "crates/ra_hir/src/arena.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Farena.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,66 @@\n+//! A simple id-based arena, similar to https://github.com/fitzgen/id-arena.\n+//! We use our own version for more compact id's and to allow inherent impls\n+//! on Ids.\n+\n+use std::{\n+    fmt,\n+    hash::{Hash, Hasher},\n+    marker::PhantomData,\n+};\n+\n+pub(crate) struct Id<T> {\n+    idx: u32,\n+    _ty: PhantomData<fn() -> T>,\n+}\n+\n+impl<T> fmt::Debug for Id<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"Id\").field(&self.idx).finish()\n+    }\n+}\n+impl<T> Copy for Id<T> {}\n+impl<T> Clone for Id<T> {\n+    fn clone(&self) -> Id<T> {\n+        *self\n+    }\n+}\n+\n+impl<T> PartialEq for Id<T> {\n+    fn eq(&self, other: &Id<T>) -> bool {\n+        self.idx == other.idx\n+    }\n+}\n+\n+impl<T> Eq for Id<T> {}\n+\n+impl<T> Hash for Id<T> {\n+    fn hash<H: Hasher>(&self, h: &mut H) {\n+        self.idx.hash(h);\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ArenaBehavior<T> {\n+    _ty: PhantomData<T>,\n+}\n+\n+impl<T> id_arena::ArenaBehavior for ArenaBehavior<T> {\n+    type Id = Id<T>;\n+    fn new_arena_id() -> usize {\n+        0\n+    }\n+    fn new_id(_arena_id: usize, index: usize) -> Id<T> {\n+        Id {\n+            idx: index as u32,\n+            _ty: PhantomData,\n+        }\n+    }\n+    fn index(id: Id<T>) -> usize {\n+        id.idx as usize\n+    }\n+    fn arena_id(_id: Id<T>) -> usize {\n+        0\n+    }\n+}\n+\n+pub(crate) type Arena<T> = id_arena::Arena<T, ArenaBehavior<T>>;"}, {"sha": "dbf8785fe393a3f299d911e5ae8a5827f989f66e", "filename": "crates/ra_hir/src/db.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,66 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{\n+    SyntaxNode,\n+    ast::FnDefNode,\n+};\n+use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, FileId, Cancelable};\n+\n+use crate::{\n+    DefLoc, DefId, FnId,\n+    SourceFileItems, SourceItemId,\n+    query_definitions,\n+    function::{FnScopes},\n+    module::{ModuleId, ModuleTree, ModuleSource,\n+    nameres::{ItemMap, InputModuleItems}},\n+};\n+\n+salsa::query_group! {\n+\n+pub(crate) trait HirDatabase: SyntaxDatabase\n+    + AsRef<LocationIntener<DefLoc, DefId>>\n+    + AsRef<LocationIntener<SourceItemId, FnId>>\n+{\n+    fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n+        type FnScopesQuery;\n+        use fn query_definitions::fn_scopes;\n+    }\n+    fn fn_syntax(fn_id: FnId) -> FnDefNode {\n+        type FnSyntaxQuery;\n+        // Don't retain syntax trees in memory\n+        storage dependencies;\n+        use fn query_definitions::fn_syntax;\n+    }\n+\n+    fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n+        type SourceFileItemsQuery;\n+        storage dependencies;\n+        use fn query_definitions::file_items;\n+    }\n+\n+    fn file_item(source_item_id: SourceItemId) -> SyntaxNode {\n+        type FileItemQuery;\n+        storage dependencies;\n+        use fn query_definitions::file_item;\n+    }\n+\n+    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module::imp::Submodule>>> {\n+        type SubmodulesQuery;\n+        use fn query_definitions::submodules;\n+    }\n+\n+    fn input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n+        type InputModuleItemsQuery;\n+        use fn query_definitions::input_module_items;\n+    }\n+    fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n+        type ItemMapQuery;\n+        use fn query_definitions::item_map;\n+    }\n+    fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n+        type ModuleTreeQuery;\n+        use fn crate::module::imp::module_tree;\n+    }\n+}\n+\n+}"}, {"sha": "a3ed00f0275662ee6f89d761c177ffdfccfb9908", "filename": "crates/ra_hir/src/function/mod.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,190 @@\n+mod scope;\n+\n+use std::{\n+    cmp::{max, min},\n+    sync::Arc,\n+};\n+\n+use ra_syntax::{\n+    TextRange, TextUnit, SyntaxNodeRef,\n+    ast::{self, AstNode, DocCommentsOwner, NameOwner},\n+};\n+use ra_db::FileId;\n+\n+use crate::{\n+    FnId, HirDatabase, SourceItemId,\n+};\n+\n+pub(crate) use self::scope::FnScopes;\n+\n+impl FnId {\n+    pub(crate) fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of(fn_def.syntax());\n+        let item_id = SourceItemId { file_id, item_id };\n+        FnId::from_loc(db, &item_id)\n+    }\n+}\n+\n+pub(crate) struct Function {\n+    fn_id: FnId,\n+}\n+\n+impl Function {\n+    pub(crate) fn guess_from_source(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        fn_def: ast::FnDef,\n+    ) -> Function {\n+        let fn_id = FnId::get(db, file_id, fn_def);\n+        Function { fn_id }\n+    }\n+\n+    pub(crate) fn guess_for_name_ref(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        name_ref: ast::NameRef,\n+    ) -> Option<Function> {\n+        Function::guess_for_node(db, file_id, name_ref.syntax())\n+    }\n+\n+    pub(crate) fn guess_for_bind_pat(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        bind_pat: ast::BindPat,\n+    ) -> Option<Function> {\n+        Function::guess_for_node(db, file_id, bind_pat.syntax())\n+    }\n+\n+    fn guess_for_node(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        node: SyntaxNodeRef,\n+    ) -> Option<Function> {\n+        let fn_def = node.ancestors().find_map(ast::FnDef::cast)?;\n+        let res = Function::guess_from_source(db, file_id, fn_def);\n+        Some(res)\n+    }\n+\n+    pub(crate) fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n+        db.fn_scopes(self.fn_id)\n+    }\n+\n+    pub(crate) fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n+        let syntax = db.fn_syntax(self.fn_id);\n+        FnSignatureInfo::new(syntax.borrowed())\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct FnSignatureInfo {\n+    pub name: String,\n+    pub label: String,\n+    pub ret_type: Option<String>,\n+    pub params: Vec<String>,\n+    pub doc: Option<String>,\n+}\n+\n+impl FnSignatureInfo {\n+    fn new(node: ast::FnDef) -> Option<Self> {\n+        let name = node.name()?.text().to_string();\n+\n+        let mut doc = None;\n+\n+        // Strip the body out for the label.\n+        let mut label: String = if let Some(body) = node.body() {\n+            let body_range = body.syntax().range();\n+            let label: String = node\n+                .syntax()\n+                .children()\n+                .filter(|child| !child.range().is_subrange(&body_range))\n+                .map(|node| node.text().to_string())\n+                .collect();\n+            label\n+        } else {\n+            node.syntax().text().to_string()\n+        };\n+\n+        if let Some((comment_range, docs)) = FnSignatureInfo::extract_doc_comments(node) {\n+            let comment_range = comment_range\n+                .checked_sub(node.syntax().range().start())\n+                .unwrap();\n+            let start = comment_range.start().to_usize();\n+            let end = comment_range.end().to_usize();\n+\n+            // Remove the comment from the label\n+            label.replace_range(start..end, \"\");\n+\n+            // Massage markdown\n+            let mut processed_lines = Vec::new();\n+            let mut in_code_block = false;\n+            for line in docs.lines() {\n+                if line.starts_with(\"```\") {\n+                    in_code_block = !in_code_block;\n+                }\n+\n+                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n+                    \"```rust\".into()\n+                } else {\n+                    line.to_string()\n+                };\n+\n+                processed_lines.push(line);\n+            }\n+\n+            if !processed_lines.is_empty() {\n+                doc = Some(processed_lines.join(\"\\n\"));\n+            }\n+        }\n+\n+        let params = FnSignatureInfo::param_list(node);\n+        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n+\n+        Some(FnSignatureInfo {\n+            name,\n+            ret_type,\n+            params,\n+            label: label.trim().to_owned(),\n+            doc,\n+        })\n+    }\n+\n+    fn extract_doc_comments(node: ast::FnDef) -> Option<(TextRange, String)> {\n+        if node.doc_comments().count() == 0 {\n+            return None;\n+        }\n+\n+        let comment_text = node.doc_comment_text();\n+\n+        let (begin, end) = node\n+            .doc_comments()\n+            .map(|comment| comment.syntax().range())\n+            .map(|range| (range.start().to_usize(), range.end().to_usize()))\n+            .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n+                (min(acc.0, range.0), max(acc.1, range.1))\n+            });\n+\n+        let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n+\n+        Some((range, comment_text))\n+    }\n+\n+    fn param_list(node: ast::FnDef) -> Vec<String> {\n+        let mut res = vec![];\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                res.push(self_param.syntax().text().to_string())\n+            }\n+\n+            // Maybe use param.pat here? See if we can just extract the name?\n+            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n+            res.extend(\n+                param_list\n+                    .params()\n+                    .filter_map(|p| p.pat())\n+                    .map(|pat| pat.syntax().text().to_string()),\n+            );\n+        }\n+        res\n+    }\n+}"}, {"sha": "c8b6b19345d7ba162301b3e905d54da1659b9f33", "filename": "crates/ra_hir/src/function/scope.rs", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,450 @@\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+use ra_syntax::{\n+    AstNode, SmolStr, SyntaxNodeRef, TextRange,\n+    algo::generate,\n+    ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n+};\n+use ra_db::LocalSyntaxPtr;\n+\n+use crate::{\n+    arena::{Arena, Id},\n+};\n+\n+pub(crate) type ScopeId = Id<ScopeData>;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct FnScopes {\n+    pub(crate) self_param: Option<LocalSyntaxPtr>,\n+    scopes: Arena<ScopeData>,\n+    scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeEntry {\n+    name: SmolStr,\n+    ptr: LocalSyntaxPtr,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ScopeData {\n+    parent: Option<ScopeId>,\n+    entries: Vec<ScopeEntry>,\n+}\n+\n+impl FnScopes {\n+    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n+        let mut scopes = FnScopes {\n+            self_param: fn_def\n+                .param_list()\n+                .and_then(|it| it.self_param())\n+                .map(|it| LocalSyntaxPtr::new(it.syntax())),\n+            scopes: Arena::default(),\n+            scope_for: FxHashMap::default(),\n+        };\n+        let root = scopes.root_scope();\n+        scopes.add_params_bindings(root, fn_def.param_list());\n+        if let Some(body) = fn_def.body() {\n+            compute_block_scopes(body, &mut scopes, root)\n+        }\n+        scopes\n+    }\n+    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n+    }\n+    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n+        generate(self.scope_for(node), move |&scope| {\n+            self.scopes[scope].parent\n+        })\n+    }\n+    pub(crate) fn resolve_local_name<'a>(\n+        &'a self,\n+        name_ref: ast::NameRef,\n+    ) -> Option<&'a ScopeEntry> {\n+        let mut shadowed = FxHashSet::default();\n+        let ret = self\n+            .scope_chain(name_ref.syntax())\n+            .flat_map(|scope| self.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .filter(|entry| entry.name() == &name_ref.text())\n+            .nth(0);\n+        ret\n+    }\n+\n+    pub fn find_all_refs(&self, pat: ast::BindPat) -> Vec<ReferenceDescriptor> {\n+        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n+        let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n+        let refs: Vec<_> = fn_def\n+            .syntax()\n+            .descendants()\n+            .filter_map(ast::NameRef::cast)\n+            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n+                None => false,\n+                Some(entry) => entry.ptr() == name_ptr,\n+            })\n+            .map(|name_ref| ReferenceDescriptor {\n+                name: name_ref.syntax().text().to_string(),\n+                range: name_ref.syntax().range(),\n+            })\n+            .collect();\n+\n+        refs\n+    }\n+\n+    fn root_scope(&mut self) -> ScopeId {\n+        self.scopes.alloc(ScopeData {\n+            parent: None,\n+            entries: vec![],\n+        })\n+    }\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            entries: vec![],\n+        })\n+    }\n+    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n+        let entries = pat\n+            .syntax()\n+            .descendants()\n+            .filter_map(ast::BindPat::cast)\n+            .filter_map(ScopeEntry::new);\n+        self.scopes[scope].entries.extend(entries);\n+    }\n+    fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n+        params\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .filter_map(|it| it.pat())\n+            .for_each(|it| self.add_bindings(scope, it));\n+    }\n+    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n+        self.scope_for.insert(LocalSyntaxPtr::new(node), scope);\n+    }\n+    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n+        node.ancestors()\n+            .map(LocalSyntaxPtr::new)\n+            .filter_map(|it| self.scope_for.get(&it).map(|&scope| scope))\n+            .next()\n+    }\n+}\n+\n+impl ScopeEntry {\n+    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n+        let name = pat.name()?;\n+        let res = ScopeEntry {\n+            name: name.text(),\n+            ptr: LocalSyntaxPtr::new(pat.syntax()),\n+        };\n+        Some(res)\n+    }\n+    pub(crate) fn name(&self) -> &SmolStr {\n+        &self.name\n+    }\n+    pub(crate) fn ptr(&self) -> LocalSyntaxPtr {\n+        self.ptr\n+    }\n+}\n+\n+fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n+    for stmt in block.statements() {\n+        match stmt {\n+            ast::Stmt::LetStmt(stmt) => {\n+                if let Some(expr) = stmt.initializer() {\n+                    scopes.set_scope(expr.syntax(), scope);\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+                scope = scopes.new_scope(scope);\n+                if let Some(pat) = stmt.pat() {\n+                    scopes.add_bindings(scope, pat);\n+                }\n+            }\n+            ast::Stmt::ExprStmt(expr_stmt) => {\n+                if let Some(expr) = expr_stmt.expr() {\n+                    scopes.set_scope(expr.syntax(), scope);\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+            }\n+        }\n+    }\n+    if let Some(expr) = block.expr() {\n+        scopes.set_scope(expr.syntax(), scope);\n+        compute_expr_scopes(expr, scopes, scope);\n+    }\n+}\n+\n+fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n+    match expr {\n+        ast::Expr::IfExpr(e) => {\n+            let cond_scope = e\n+                .condition()\n+                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n+            if let Some(block) = e.then_branch() {\n+                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n+            }\n+            if let Some(block) = e.else_branch() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::BlockExpr(e) => {\n+            if let Some(block) = e.block() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::LoopExpr(e) => {\n+            if let Some(block) = e.loop_body() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::WhileExpr(e) => {\n+            let cond_scope = e\n+                .condition()\n+                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n+            if let Some(block) = e.loop_body() {\n+                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n+            }\n+        }\n+        ast::Expr::ForExpr(e) => {\n+            if let Some(expr) = e.iterable() {\n+                compute_expr_scopes(expr, scopes, scope);\n+            }\n+            let mut scope = scope;\n+            if let Some(pat) = e.pat() {\n+                scope = scopes.new_scope(scope);\n+                scopes.add_bindings(scope, pat);\n+            }\n+            if let Some(block) = e.loop_body() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::LambdaExpr(e) => {\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_params_bindings(scope, e.param_list());\n+            if let Some(body) = e.body() {\n+                scopes.set_scope(body.syntax(), scope);\n+                compute_expr_scopes(body, scopes, scope);\n+            }\n+        }\n+        ast::Expr::CallExpr(e) => {\n+            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n+        }\n+        ast::Expr::MethodCallExpr(e) => {\n+            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n+        }\n+        ast::Expr::MatchExpr(e) => {\n+            if let Some(expr) = e.expr() {\n+                compute_expr_scopes(expr, scopes, scope);\n+            }\n+            for arm in e.match_arm_list().into_iter().flat_map(|it| it.arms()) {\n+                let scope = scopes.new_scope(scope);\n+                for pat in arm.pats() {\n+                    scopes.add_bindings(scope, pat);\n+                }\n+                if let Some(expr) = arm.expr() {\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+            }\n+        }\n+        _ => expr\n+            .syntax()\n+            .children()\n+            .filter_map(ast::Expr::cast)\n+            .for_each(|expr| compute_expr_scopes(expr, scopes, scope)),\n+    };\n+\n+    fn compute_call_scopes(\n+        receiver: Option<ast::Expr>,\n+        arg_list: Option<ast::ArgList>,\n+        scopes: &mut FnScopes,\n+        scope: ScopeId,\n+    ) {\n+        arg_list\n+            .into_iter()\n+            .flat_map(|it| it.args())\n+            .chain(receiver)\n+            .for_each(|expr| compute_expr_scopes(expr, scopes, scope));\n+    }\n+\n+    fn compute_cond_scopes(\n+        cond: ast::Condition,\n+        scopes: &mut FnScopes,\n+        scope: ScopeId,\n+    ) -> Option<ScopeId> {\n+        if let Some(expr) = cond.expr() {\n+            compute_expr_scopes(expr, scopes, scope);\n+        }\n+        if let Some(pat) = cond.pat() {\n+            let s = scopes.new_scope(scope);\n+            scopes.add_bindings(s, pat);\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ReferenceDescriptor {\n+    pub range: TextRange,\n+    pub name: String,\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_editor::find_node_at_offset;\n+    use ra_syntax::SourceFileNode;\n+    use test_utils::extract_offset;\n+\n+    use super::*;\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let (off, code) = extract_offset(code);\n+        let code = {\n+            let mut buf = String::new();\n+            let off = u32::from(off) as usize;\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+        let file = SourceFileNode::parse(&code);\n+        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let scopes = FnScopes::new(fn_def);\n+        let actual = scopes\n+            .scope_chain(marker.syntax())\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name())\n+            .collect::<Vec<_>>();\n+        assert_eq!(actual.as_slice(), expected);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    <|>\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_metod_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    <|>\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        <|>\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    fn do_check_local_name(code: &str, expected_offset: u32) {\n+        let (off, code) = extract_offset(code);\n+        let file = SourceFileNode::parse(&code);\n+        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+\n+        let scopes = FnScopes::new(fn_def);\n+\n+        let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n+        let local_name = local_name_entry.ptr().resolve(&file);\n+        let expected_name =\n+            find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n+        assert_eq!(local_name.range(), expected_name.syntax().range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: i32, y: u32) {\n+                {\n+                    let z = x * 2;\n+                }\n+                {\n+                    let t = x<|> * 3;\n+                }\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+        fn foo(x: String) {\n+            let x : &str = &x;\n+            x<|>\n+        }\",\n+            46,\n+        );\n+    }\n+}"}, {"sha": "7bf06c7f70c0d9fb892e2dd656ed6f5a11a0155e", "filename": "crates/ra_hir/src/lib.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,139 @@\n+//! HIR (previsouly known as descriptors) provides a high-level OO acess to Rust\n+//! code.\n+//!\n+//! The principal difference between HIR and syntax trees is that HIR is bound\n+//! to a particular crate instance. That is, it has cfg flags and features\n+//! applied. So, there relation between syntax and HIR is many-to-one.\n+\n+macro_rules! ctry {\n+    ($expr:expr) => {\n+        match $expr {\n+            None => return Ok(None),\n+            Some(it) => it,\n+        }\n+    };\n+}\n+\n+pub(crate) mod db;\n+mod query_definitions;\n+mod function;\n+mod module;\n+mod path;\n+mod arena;\n+\n+use std::ops::Index;\n+\n+use ra_syntax::{SyntaxNodeRef, SyntaxNode};\n+use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n+\n+use crate::{\n+    db::HirDatabase,\n+    arena::{Arena, Id},\n+};\n+\n+pub(crate) use self::{\n+    path::{Path, PathKind},\n+    module::{Module, ModuleId, Problem},\n+    function::{Function, FnScopes},\n+};\n+\n+pub use self::function::FnSignatureInfo;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct FnId(u32);\n+ra_db::impl_numeric_id!(FnId);\n+\n+impl FnId {\n+    pub(crate) fn from_loc(\n+        db: &impl AsRef<LocationIntener<SourceItemId, FnId>>,\n+        loc: &SourceItemId,\n+    ) -> FnId {\n+        db.as_ref().loc2id(loc)\n+    }\n+    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<SourceItemId, FnId>>) -> SourceItemId {\n+        db.as_ref().id2loc(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct DefId(u32);\n+ra_db::impl_numeric_id!(DefId);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum DefLoc {\n+    Module {\n+        id: ModuleId,\n+        source_root: SourceRootId,\n+    },\n+    Item {\n+        source_item_id: SourceItemId,\n+    },\n+}\n+\n+impl DefId {\n+    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n+        db.as_ref().id2loc(self)\n+    }\n+}\n+\n+impl DefLoc {\n+    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n+        db.as_ref().loc2id(&self)\n+    }\n+}\n+\n+pub(crate) enum Def {\n+    Module(Module),\n+    Item,\n+}\n+\n+impl DefId {\n+    pub(crate) fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n+        let loc = self.loc(db);\n+        let res = match loc {\n+            DefLoc::Module { id, source_root } => {\n+                let descr = Module::new(db, source_root, id)?;\n+                Def::Module(descr)\n+            }\n+            DefLoc::Item { .. } => Def::Item,\n+        };\n+        Ok(res)\n+    }\n+}\n+\n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct SourceItemId {\n+    file_id: FileId,\n+    item_id: SourceFileItemId,\n+}\n+\n+/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n+#[derive(Debug, PartialEq, Eq, Default)]\n+pub(crate) struct SourceFileItems {\n+    arena: Arena<SyntaxNode>,\n+}\n+\n+impl SourceFileItems {\n+    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n+        self.arena.alloc(item)\n+    }\n+    fn id_of(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n+        let (id, _item) = self\n+            .arena\n+            .iter()\n+            .find(|(_id, i)| i.borrowed() == item)\n+            .unwrap();\n+        id\n+    }\n+}\n+\n+impl Index<SourceFileItemId> for SourceFileItems {\n+    type Output = SyntaxNode;\n+    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n+        &self.arena[idx]\n+    }\n+}"}, {"sha": "d55fa3e6b4a4ab00e3e4fb5d4e872e2f082a8f90", "filename": "crates/ra_hir/src/module/imp.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,194 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{\n+    ast::{self, NameOwner},\n+    SmolStr,\n+};\n+use relative_path::RelativePathBuf;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use ra_db::{SourceRoot, SourceRootId, FileResolverImp, Cancelable, FileId,};\n+\n+use crate::{\n+    HirDatabase,\n+};\n+\n+use super::{\n+    LinkData, LinkId, ModuleData, ModuleId, ModuleSource,\n+    ModuleTree, Problem,\n+};\n+\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n+pub(crate) enum Submodule {\n+    Declaration(SmolStr),\n+    Definition(SmolStr, ModuleSource),\n+}\n+\n+impl Submodule {\n+    fn name(&self) -> &SmolStr {\n+        match self {\n+            Submodule::Declaration(name) => name,\n+            Submodule::Definition(name, _) => name,\n+        }\n+    }\n+}\n+\n+pub(crate) fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            Some((name, module))\n+        })\n+}\n+\n+pub(crate) fn module_tree(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ModuleTree>> {\n+    db.check_canceled()?;\n+    let res = create_module_tree(db, source_root)?;\n+    Ok(Arc::new(res))\n+}\n+\n+fn create_module_tree<'a>(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<ModuleTree> {\n+    let mut tree = ModuleTree::default();\n+\n+    let mut roots = FxHashMap::default();\n+    let mut visited = FxHashSet::default();\n+\n+    let source_root = db.source_root(source_root);\n+    for &file_id in source_root.files.iter() {\n+        let source = ModuleSource::SourceFile(file_id);\n+        if visited.contains(&source) {\n+            continue; // TODO: use explicit crate_roots here\n+        }\n+        assert!(!roots.contains_key(&file_id));\n+        let module_id = build_subtree(\n+            db,\n+            &source_root,\n+            &mut tree,\n+            &mut visited,\n+            &mut roots,\n+            None,\n+            source,\n+        )?;\n+        roots.insert(file_id, module_id);\n+    }\n+    Ok(tree)\n+}\n+\n+fn build_subtree(\n+    db: &impl HirDatabase,\n+    source_root: &SourceRoot,\n+    tree: &mut ModuleTree,\n+    visited: &mut FxHashSet<ModuleSource>,\n+    roots: &mut FxHashMap<FileId, ModuleId>,\n+    parent: Option<LinkId>,\n+    source: ModuleSource,\n+) -> Cancelable<ModuleId> {\n+    visited.insert(source);\n+    let id = tree.push_mod(ModuleData {\n+        source,\n+        parent,\n+        children: Vec::new(),\n+    });\n+    for sub in db.submodules(source)?.iter() {\n+        let link = tree.push_link(LinkData {\n+            name: sub.name().clone(),\n+            owner: id,\n+            points_to: Vec::new(),\n+            problem: None,\n+        });\n+\n+        let (points_to, problem) = match sub {\n+            Submodule::Declaration(name) => {\n+                let (points_to, problem) =\n+                    resolve_submodule(source, &name, &source_root.file_resolver);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| match roots.remove(&file_id) {\n+                        Some(module_id) => {\n+                            tree.mods[module_id].parent = Some(link);\n+                            Ok(module_id)\n+                        }\n+                        None => build_subtree(\n+                            db,\n+                            source_root,\n+                            tree,\n+                            visited,\n+                            roots,\n+                            Some(link),\n+                            ModuleSource::SourceFile(file_id),\n+                        ),\n+                    })\n+                    .collect::<Cancelable<Vec<_>>>()?;\n+                (points_to, problem)\n+            }\n+            Submodule::Definition(_name, submodule_source) => {\n+                let points_to = build_subtree(\n+                    db,\n+                    source_root,\n+                    tree,\n+                    visited,\n+                    roots,\n+                    Some(link),\n+                    *submodule_source,\n+                )?;\n+                (vec![points_to], None)\n+            }\n+        };\n+\n+        tree.links[link].points_to = points_to;\n+        tree.links[link].problem = problem;\n+    }\n+    Ok(id)\n+}\n+\n+fn resolve_submodule(\n+    source: ModuleSource,\n+    name: &SmolStr,\n+    file_resolver: &FileResolverImp,\n+) -> (Vec<FileId>, Option<Problem>) {\n+    let file_id = match source {\n+        ModuleSource::SourceFile(it) => it,\n+        ModuleSource::Module(..) => {\n+            // TODO\n+            return (Vec::new(), None);\n+        }\n+    };\n+    let mod_name = file_resolver.file_stem(file_id);\n+    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+\n+    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n+    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n+    let points_to: Vec<FileId>;\n+    let problem: Option<Problem>;\n+    if is_dir_owner {\n+        points_to = [&file_mod, &dir_mod]\n+            .iter()\n+            .filter_map(|path| file_resolver.resolve(file_id, path))\n+            .collect();\n+        problem = if points_to.is_empty() {\n+            Some(Problem::UnresolvedModule {\n+                candidate: file_mod,\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        points_to = Vec::new();\n+        problem = Some(Problem::NotDirOwner {\n+            move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n+            candidate: file_mod,\n+        });\n+    }\n+    (points_to, problem)\n+}"}, {"sha": "81b9f948dca922a5eb1a993985d6e606c4b5fb22", "filename": "crates/ra_hir/src/module/mod.rs", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,378 @@\n+pub(super) mod imp;\n+pub(super) mod nameres;\n+\n+use std::sync::Arc;\n+\n+use ra_editor::find_node_at_offset;\n+\n+use ra_syntax::{\n+    algo::generate,\n+    ast::{self, AstNode, NameOwner},\n+    SmolStr, SyntaxNode,\n+};\n+use ra_db::{SourceRootId, FileId, FilePosition, Cancelable};\n+use relative_path::RelativePathBuf;\n+\n+use crate::{\n+    DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId,\n+    arena::{Arena, Id},\n+};\n+\n+pub(crate) use self::nameres::ModuleScope;\n+\n+/// `Module` is API entry point to get all the information\n+/// about a particular module.\n+#[derive(Debug, Clone)]\n+pub(crate) struct Module {\n+    tree: Arc<ModuleTree>,\n+    source_root_id: SourceRootId,\n+    module_id: ModuleId,\n+}\n+\n+impl Module {\n+    /// Lookup `Module` by `FileId`. Note that this is inherently\n+    /// lossy transformation: in general, a single source might correspond to\n+    /// several modules.\n+    pub fn guess_from_file_id(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+    ) -> Cancelable<Option<Module>> {\n+        Module::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n+    }\n+\n+    /// Lookup `Module` by position in the source code. Note that this\n+    /// is inherently lossy transformation: in general, a single source might\n+    /// correspond to several modules.\n+    pub fn guess_from_position(\n+        db: &impl HirDatabase,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<Module>> {\n+        let file = db.source_file(position.file_id);\n+        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n+        {\n+            Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n+            _ => ModuleSource::SourceFile(position.file_id),\n+        };\n+        Module::guess_from_source(db, position.file_id, module_source)\n+    }\n+\n+    fn guess_from_source(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        module_source: ModuleSource,\n+    ) -> Cancelable<Option<Module>> {\n+        let source_root_id = db.file_source_root(file_id);\n+        let module_tree = db.module_tree(source_root_id)?;\n+\n+        let res = match module_tree.any_module_for_source(module_source) {\n+            None => None,\n+            Some(module_id) => Some(Module {\n+                tree: module_tree,\n+                source_root_id,\n+                module_id,\n+            }),\n+        };\n+        Ok(res)\n+    }\n+\n+    pub(super) fn new(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Cancelable<Module> {\n+        let module_tree = db.module_tree(source_root_id)?;\n+        let res = Module {\n+            tree: module_tree,\n+            source_root_id,\n+            module_id,\n+        };\n+        Ok(res)\n+    }\n+\n+    /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n+    /// Returns `None` for the root module\n+    pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n+        let link = self.module_id.parent_link(&self.tree)?;\n+        let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n+        let src = link.bind_source(&self.tree, db);\n+        Some((file_id, src))\n+    }\n+\n+    pub fn source(&self) -> ModuleSource {\n+        self.module_id.source(&self.tree)\n+    }\n+\n+    /// Parent module. Returns `None` if this is a root module.\n+    pub fn parent(&self) -> Option<Module> {\n+        let parent_id = self.module_id.parent(&self.tree)?;\n+        Some(Module {\n+            module_id: parent_id,\n+            ..self.clone()\n+        })\n+    }\n+\n+    /// The root of the tree this module is part of\n+    pub fn crate_root(&self) -> Module {\n+        let root_id = self.module_id.crate_root(&self.tree);\n+        Module {\n+            module_id: root_id,\n+            ..self.clone()\n+        }\n+    }\n+\n+    /// `name` is `None` for the crate's root module\n+    #[allow(unused)]\n+    pub fn name(&self) -> Option<SmolStr> {\n+        let link = self.module_id.parent_link(&self.tree)?;\n+        Some(link.name(&self.tree))\n+    }\n+\n+    pub fn def_id(&self, db: &impl HirDatabase) -> DefId {\n+        let def_loc = DefLoc::Module {\n+            id: self.module_id,\n+            source_root: self.source_root_id,\n+        };\n+        def_loc.id(db)\n+    }\n+\n+    /// Finds a child module with the specified name.\n+    pub fn child(&self, name: &str) -> Option<Module> {\n+        let child_id = self.module_id.child(&self.tree, name)?;\n+        Some(Module {\n+            module_id: child_id,\n+            ..self.clone()\n+        })\n+    }\n+\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub(crate) fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        let item_map = db.item_map(self.source_root_id)?;\n+        let res = item_map.per_module[&self.module_id].clone();\n+        Ok(res)\n+    }\n+\n+    pub(crate) fn resolve_path(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: Path,\n+    ) -> Cancelable<Option<DefId>> {\n+        let mut curr = match path.kind {\n+            PathKind::Crate => self.crate_root(),\n+            PathKind::Self_ | PathKind::Plain => self.clone(),\n+            PathKind::Super => ctry!(self.parent()),\n+        }\n+        .def_id(db);\n+\n+        let segments = path.segments;\n+        for name in segments.iter() {\n+            let module = match curr.loc(db) {\n+                DefLoc::Module { id, source_root } => Module::new(db, source_root, id)?,\n+                _ => return Ok(None),\n+            };\n+            let scope = module.scope(db)?;\n+            curr = ctry!(ctry!(scope.get(&name)).def_id);\n+        }\n+        Ok(Some(curr))\n+    }\n+\n+    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n+        self.module_id.problems(&self.tree, db)\n+    }\n+}\n+\n+/// Phisically, rust source is organized as a set of files, but logically it is\n+/// organized as a tree of modules. Usually, a single file corresponds to a\n+/// single module, but it is not nessary the case.\n+///\n+/// Module encapsulate the logic of transitioning from the fuzzy world of files\n+/// (which can have multiple parents) to the precise world of modules (which\n+/// always have one parent).\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct ModuleTree {\n+    mods: Arena<ModuleData>,\n+    links: Arena<LinkData>,\n+}\n+\n+impl ModuleTree {\n+    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+        self.mods.iter().map(|(id, _)| id)\n+    }\n+\n+    fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n+        self.mods\n+            .iter()\n+            .filter(|(_idx, it)| it.source == source)\n+            .map(|(idx, _)| idx)\n+            .collect()\n+    }\n+\n+    fn any_module_for_source(&self, source: ModuleSource) -> Option<ModuleId> {\n+        self.modules_for_source(source).pop()\n+    }\n+}\n+\n+/// `ModuleSource` is the syntax tree element that produced this module:\n+/// either a file, or an inlinde module.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum ModuleSource {\n+    SourceFile(FileId),\n+    Module(SourceItemId),\n+}\n+\n+/// An owned syntax node for a module. Unlike `ModuleSource`,\n+/// this holds onto the AST for the whole file.\n+pub(crate) enum ModuleSourceNode {\n+    SourceFile(ast::SourceFileNode),\n+    Module(ast::ModuleNode),\n+}\n+\n+pub(crate) type ModuleId = Id<ModuleData>;\n+type LinkId = Id<LinkData>;\n+\n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Problem {\n+    UnresolvedModule {\n+        candidate: RelativePathBuf,\n+    },\n+    NotDirOwner {\n+        move_to: RelativePathBuf,\n+        candidate: RelativePathBuf,\n+    },\n+}\n+\n+impl ModuleId {\n+    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n+        tree.mods[self].source\n+    }\n+    fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n+        tree.mods[self].parent\n+    }\n+    fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n+        let link = self.parent_link(tree)?;\n+        Some(tree.links[link].owner)\n+    }\n+    fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n+        generate(Some(self), move |it| it.parent(tree))\n+            .last()\n+            .unwrap()\n+    }\n+    fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n+        let link = tree.mods[self]\n+            .children\n+            .iter()\n+            .map(|&it| &tree.links[it])\n+            .find(|it| it.name == name)?;\n+        Some(*link.points_to.first()?)\n+    }\n+    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (SmolStr, ModuleId)> + 'a {\n+        tree.mods[self].children.iter().filter_map(move |&it| {\n+            let link = &tree.links[it];\n+            let module = *link.points_to.first()?;\n+            Some((link.name.clone(), module))\n+        })\n+    }\n+    fn problems(self, tree: &ModuleTree, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n+        tree.mods[self]\n+            .children\n+            .iter()\n+            .filter_map(|&it| {\n+                let p = tree.links[it].problem.clone()?;\n+                let s = it.bind_source(tree, db);\n+                let s = s.borrowed().name().unwrap().syntax().owned();\n+                Some((s, p))\n+            })\n+            .collect()\n+    }\n+}\n+\n+impl LinkId {\n+    fn owner(self, tree: &ModuleTree) -> ModuleId {\n+        tree.links[self].owner\n+    }\n+    fn name(self, tree: &ModuleTree) -> SmolStr {\n+        tree.links[self].name.clone()\n+    }\n+    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n+        let owner = self.owner(tree);\n+        match owner.source(tree).resolve(db) {\n+            ModuleSourceNode::SourceFile(root) => {\n+                let ast = imp::modules(root.borrowed())\n+                    .find(|(name, _)| name == &tree.links[self].name)\n+                    .unwrap()\n+                    .1;\n+                ast.owned()\n+            }\n+            ModuleSourceNode::Module(it) => it,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub(crate) struct ModuleData {\n+    source: ModuleSource,\n+    parent: Option<LinkId>,\n+    children: Vec<LinkId>,\n+}\n+\n+impl ModuleSource {\n+    pub(crate) fn new_inline(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        module: ast::Module,\n+    ) -> ModuleSource {\n+        assert!(!module.has_semi());\n+        let items = db.file_items(file_id);\n+        let item_id = items.id_of(module.syntax());\n+        let id = SourceItemId { file_id, item_id };\n+        ModuleSource::Module(id)\n+    }\n+\n+    pub(crate) fn as_file(self) -> Option<FileId> {\n+        match self {\n+            ModuleSource::SourceFile(f) => Some(f),\n+            ModuleSource::Module(..) => None,\n+        }\n+    }\n+\n+    pub(crate) fn file_id(self) -> FileId {\n+        match self {\n+            ModuleSource::SourceFile(f) => f,\n+            ModuleSource::Module(source_item_id) => source_item_id.file_id,\n+        }\n+    }\n+\n+    pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n+        match self {\n+            ModuleSource::SourceFile(file_id) => {\n+                let syntax = db.source_file(file_id);\n+                ModuleSourceNode::SourceFile(syntax.ast().owned())\n+            }\n+            ModuleSource::Module(item_id) => {\n+                let syntax = db.file_item(item_id);\n+                let syntax = syntax.borrowed();\n+                let module = ast::Module::cast(syntax).unwrap();\n+                ModuleSourceNode::Module(module.owned())\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Hash, Debug, PartialEq, Eq)]\n+struct LinkData {\n+    owner: ModuleId,\n+    name: SmolStr,\n+    points_to: Vec<ModuleId>,\n+    problem: Option<Problem>,\n+}\n+\n+impl ModuleTree {\n+    fn push_mod(&mut self, data: ModuleData) -> ModuleId {\n+        self.mods.alloc(data)\n+    }\n+    fn push_link(&mut self, data: LinkData) -> LinkId {\n+        let owner = data.owner;\n+        let id = self.links.alloc(data);\n+        self.mods[owner].children.push(id);\n+        id\n+    }\n+}"}, {"sha": "513a37646aa6f72668f7d341e938c9b0cb82e1c4", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,444 @@\n+//! Name resolution algorithm. The end result of the algorithm is `ItemMap`: a\n+//! map with maps each module to it's scope: the set of items, visible in the\n+//! module. That is, we only resolve imports here, name resolution of item\n+//! bodies will be done in a separate step.\n+//!\n+//! Like Rustc, we use an interative per-crate algorithm: we start with scopes\n+//! containing only directly defined items, and then iteratively resolve\n+//! imports.\n+//!\n+//! To make this work nicely in the IDE scenarios, we place `InputModuleItems`\n+//! in between raw syntax and name resolution. `InputModuleItems` are computed\n+//! using only the module's syntax, and it is all directly defined items plus\n+//! imports. The plain is to make `InputModuleItems` independent of local\n+//! modifications (that is, typing inside a function shold not change IMIs),\n+//! such that the results of name resolution can be preserved unless the module\n+//! structure itself is modified.\n+use std::{\n+    sync::Arc,\n+};\n+\n+use rustc_hash::FxHashMap;\n+use ra_syntax::{\n+    TextRange,\n+    SmolStr, SyntaxKind::{self, *},\n+    ast::{self, AstNode}\n+};\n+use ra_db::SourceRootId;\n+\n+use crate::{\n+    Cancelable, FileId,\n+    DefId, DefLoc,\n+    SourceItemId, SourceFileItemId, SourceFileItems,\n+    Path, PathKind,\n+    HirDatabase,\n+    module::{ModuleId, ModuleTree},\n+};\n+\n+/// Item map is the result of the name resolution. Item map contains, for each\n+/// module, the set of visible items.\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct ItemMap {\n+    pub(crate) per_module: FxHashMap<ModuleId, ModuleScope>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq, Clone)]\n+pub(crate) struct ModuleScope {\n+    items: FxHashMap<SmolStr, Resolution>,\n+}\n+\n+impl ModuleScope {\n+    pub(crate) fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &Resolution)> + 'a {\n+        self.items.iter()\n+    }\n+    pub(crate) fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n+        self.items.get(name)\n+    }\n+}\n+\n+/// A set of items and imports declared inside a module, without relation to\n+/// other modules.\n+///\n+/// This stands in-between raw syntax and name resolution and alow us to avoid\n+/// recomputing name res: if `InputModuleItems` are the same, we can avoid\n+/// running name resolution.\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub(crate) struct InputModuleItems {\n+    items: Vec<ModuleItem>,\n+    imports: Vec<Import>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct ModuleItem {\n+    id: SourceFileItemId,\n+    name: SmolStr,\n+    kind: SyntaxKind,\n+    vis: Vis,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum Vis {\n+    // Priv,\n+    Other,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+struct Import {\n+    path: Path,\n+    kind: ImportKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(crate) struct NamedImport {\n+    file_item_id: SourceFileItemId,\n+    relative_range: TextRange,\n+}\n+\n+impl NamedImport {\n+    pub(crate) fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n+        let source_item_id = SourceItemId {\n+            file_id,\n+            item_id: self.file_item_id,\n+        };\n+        let syntax = db.file_item(source_item_id);\n+        let offset = syntax.borrowed().range().start();\n+        self.relative_range + offset\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+enum ImportKind {\n+    Glob,\n+    Named(NamedImport),\n+}\n+\n+/// Resolution is basically `DefId` atm, but it should account for stuff like\n+/// multiple namespaces, ambiguity and errors.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct Resolution {\n+    /// None for unresolved\n+    pub(crate) def_id: Option<DefId>,\n+    /// ident by whitch this is imported into local scope.\n+    pub(crate) import: Option<NamedImport>,\n+}\n+\n+// #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+// enum Namespace {\n+//     Types,\n+//     Values,\n+// }\n+\n+// #[derive(Debug)]\n+// struct PerNs<T> {\n+//     types: Option<T>,\n+//     values: Option<T>,\n+// }\n+\n+impl InputModuleItems {\n+    pub(crate) fn new<'a>(\n+        file_items: &SourceFileItems,\n+        items: impl Iterator<Item = ast::ModuleItem<'a>>,\n+    ) -> InputModuleItems {\n+        let mut res = InputModuleItems::default();\n+        for item in items {\n+            res.add_item(file_items, item);\n+        }\n+        res\n+    }\n+\n+    fn add_item(&mut self, file_items: &SourceFileItems, item: ast::ModuleItem) -> Option<()> {\n+        match item {\n+            ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::ImplItem(_) => {\n+                // impls don't define items\n+            }\n+            ast::ModuleItem::UseItem(it) => self.add_use_item(file_items, it),\n+            ast::ModuleItem::ExternCrateItem(_) => {\n+                // TODO\n+            }\n+            ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+        }\n+        Some(())\n+    }\n+\n+    fn add_use_item(&mut self, file_items: &SourceFileItems, item: ast::UseItem) {\n+        let file_item_id = file_items.id_of(item.syntax());\n+        let start_offset = item.syntax().range().start();\n+        Path::expand_use_item(item, |path, range| {\n+            let kind = match range {\n+                None => ImportKind::Glob,\n+                Some(range) => ImportKind::Named(NamedImport {\n+                    file_item_id,\n+                    relative_range: range - start_offset,\n+                }),\n+            };\n+            self.imports.push(Import { kind, path })\n+        })\n+    }\n+}\n+\n+impl ModuleItem {\n+    fn new<'a>(file_items: &SourceFileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n+        let name = item.name()?.text();\n+        let kind = item.syntax().kind();\n+        let vis = Vis::Other;\n+        let id = file_items.id_of(item.syntax());\n+        let res = ModuleItem {\n+            id,\n+            name,\n+            kind,\n+            vis,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+pub(crate) struct Resolver<'a, DB> {\n+    pub db: &'a DB,\n+    pub input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+    pub source_root: SourceRootId,\n+    pub module_tree: Arc<ModuleTree>,\n+    pub result: ItemMap,\n+}\n+\n+impl<'a, DB> Resolver<'a, DB>\n+where\n+    DB: HirDatabase,\n+{\n+    pub(crate) fn resolve(mut self) -> Cancelable<ItemMap> {\n+        for (&module_id, items) in self.input.iter() {\n+            self.populate_module(module_id, items)\n+        }\n+\n+        for &module_id in self.input.keys() {\n+            self.db.check_canceled()?;\n+            self.resolve_imports(module_id);\n+        }\n+        Ok(self.result)\n+    }\n+\n+    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n+        let file_id = module_id.source(&self.module_tree).file_id();\n+\n+        let mut module_items = ModuleScope::default();\n+\n+        for import in input.imports.iter() {\n+            if let Some(name) = import.path.segments.iter().last() {\n+                if let ImportKind::Named(import) = import.kind {\n+                    module_items.items.insert(\n+                        name.clone(),\n+                        Resolution {\n+                            def_id: None,\n+                            import: Some(import),\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+\n+        for item in input.items.iter() {\n+            if item.kind == MODULE {\n+                // handle submodules separatelly\n+                continue;\n+            }\n+            let def_loc = DefLoc::Item {\n+                source_item_id: SourceItemId {\n+                    file_id,\n+                    item_id: item.id,\n+                },\n+            };\n+            let def_id = def_loc.id(self.db);\n+            let resolution = Resolution {\n+                def_id: Some(def_id),\n+                import: None,\n+            };\n+            module_items.items.insert(item.name.clone(), resolution);\n+        }\n+\n+        for (name, mod_id) in module_id.children(&self.module_tree) {\n+            let def_loc = DefLoc::Module {\n+                id: mod_id,\n+                source_root: self.source_root,\n+            };\n+            let def_id = def_loc.id(self.db);\n+            let resolution = Resolution {\n+                def_id: Some(def_id),\n+                import: None,\n+            };\n+            module_items.items.insert(name, resolution);\n+        }\n+\n+        self.result.per_module.insert(module_id, module_items);\n+    }\n+\n+    fn resolve_imports(&mut self, module_id: ModuleId) {\n+        for import in self.input[&module_id].imports.iter() {\n+            self.resolve_import(module_id, import);\n+        }\n+    }\n+\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) {\n+        let ptr = match import.kind {\n+            ImportKind::Glob => return,\n+            ImportKind::Named(ptr) => ptr,\n+        };\n+\n+        let mut curr = match import.path.kind {\n+            // TODO: handle extern crates\n+            PathKind::Plain => return,\n+            PathKind::Self_ => module_id,\n+            PathKind::Super => {\n+                match module_id.parent(&self.module_tree) {\n+                    Some(it) => it,\n+                    // TODO: error\n+                    None => return,\n+                }\n+            }\n+            PathKind::Crate => module_id.crate_root(&self.module_tree),\n+        };\n+\n+        for (i, name) in import.path.segments.iter().enumerate() {\n+            let is_last = i == import.path.segments.len() - 1;\n+\n+            let def_id = match self.result.per_module[&curr].items.get(name) {\n+                None => return,\n+                Some(res) => match res.def_id {\n+                    Some(it) => it,\n+                    None => return,\n+                },\n+            };\n+\n+            if !is_last {\n+                curr = match def_id.loc(self.db) {\n+                    DefLoc::Module { id, .. } => id,\n+                    _ => return,\n+                }\n+            } else {\n+                self.update(module_id, |items| {\n+                    let res = Resolution {\n+                        def_id: Some(def_id),\n+                        import: Some(ptr),\n+                    };\n+                    items.items.insert(name.clone(), res);\n+                })\n+            }\n+        }\n+    }\n+\n+    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n+        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n+        f(module_items)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_db::FilesDatabase;\n+    use crate::{\n+        AnalysisChange,\n+        mock_analysis::{MockAnalysis, analysis_and_position},\n+        hir::{self, HirDatabase},\n+};\n+    use super::*;\n+\n+    fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n+        let db = analysis.imp.db;\n+        let source_root = db.file_source_root(pos.file_id);\n+        let descr = hir::Module::guess_from_position(&*db, pos)\n+            .unwrap()\n+            .unwrap();\n+        let module_id = descr.module_id;\n+        (db.item_map(source_root).unwrap(), module_id)\n+    }\n+\n+    #[test]\n+    fn test_item_map() {\n+        let (item_map, module_id) = item_map(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+            <|>\n+\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+        let name = SmolStr::from(\"Baz\");\n+        let resolution = &item_map.per_module[&module_id].items[&name];\n+        assert!(resolution.def_id.is_some());\n+    }\n+\n+    #[test]\n+    fn typing_inside_a_function_should_not_invalidate_item_map() {\n+        let mock_analysis = MockAnalysis::with_files(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+\n+            fn foo() -> i32 {\n+                1 + 1\n+            }\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+\n+        let file_id = mock_analysis.id_of(\"/lib.rs\");\n+        let mut host = mock_analysis.analysis_host();\n+\n+        let source_root = host.analysis().imp.db.file_source_root(file_id);\n+\n+        {\n+            let db = host.analysis().imp.db;\n+            let events = db.log_executed(|| {\n+                db.item_map(source_root).unwrap();\n+            });\n+            assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n+        }\n+\n+        let mut change = AnalysisChange::new();\n+\n+        change.change_file(\n+            file_id,\n+            \"\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+\n+            fn foo() -> i32 { 92 }\n+        \"\n+            .to_string(),\n+        );\n+\n+        host.apply_change(change);\n+\n+        {\n+            let db = host.analysis().imp.db;\n+            let events = db.log_executed(|| {\n+                db.item_map(source_root).unwrap();\n+            });\n+            assert!(\n+                !format!(\"{:?}\", events).contains(\"_item_map\"),\n+                \"{:#?}\",\n+                events\n+            )\n+        }\n+    }\n+}"}, {"sha": "8279daf4bf6e0a27a549f57c1d3cbbf0895d35f1", "filename": "crates/ra_hir/src/path.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,148 @@\n+use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct Path {\n+    pub(crate) kind: PathKind,\n+    pub(crate) segments: Vec<SmolStr>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(crate) enum PathKind {\n+    Plain,\n+    Self_,\n+    Super,\n+    Crate,\n+}\n+\n+impl Path {\n+    /// Calls `cb` with all paths, represented by this use item.\n+    pub(crate) fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n+        if let Some(tree) = item.use_tree() {\n+            expand_use_tree(None, tree, &mut cb);\n+        }\n+    }\n+\n+    /// Converts an `ast::Path` to `Path`. Works with use trees.\n+    pub(crate) fn from_ast(mut path: ast::Path) -> Option<Path> {\n+        let mut kind = PathKind::Plain;\n+        let mut segments = Vec::new();\n+        loop {\n+            let segment = path.segment()?;\n+            match segment.kind()? {\n+                ast::PathSegmentKind::Name(name) => segments.push(name.text()),\n+                ast::PathSegmentKind::CrateKw => {\n+                    kind = PathKind::Crate;\n+                    break;\n+                }\n+                ast::PathSegmentKind::SelfKw => {\n+                    kind = PathKind::Self_;\n+                    break;\n+                }\n+                ast::PathSegmentKind::SuperKw => {\n+                    kind = PathKind::Super;\n+                    break;\n+                }\n+            }\n+            path = match qualifier(path) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+        }\n+        segments.reverse();\n+        return Some(Path { kind, segments });\n+\n+        fn qualifier(path: ast::Path) -> Option<ast::Path> {\n+            if let Some(q) = path.qualifier() {\n+                return Some(q);\n+            }\n+            // TODO: this bottom up traversal is not too precise.\n+            // Should we handle do a top-down analysiss, recording results?\n+            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+            let use_tree = use_tree_list.parent_use_tree();\n+            use_tree.path()\n+        }\n+    }\n+\n+    /// `true` is this path is a single identifier, like `foo`\n+    pub(crate) fn is_ident(&self) -> bool {\n+        self.kind == PathKind::Plain && self.segments.len() == 1\n+    }\n+}\n+\n+fn expand_use_tree(\n+    prefix: Option<Path>,\n+    tree: ast::UseTree,\n+    cb: &mut impl FnMut(Path, Option<TextRange>),\n+) {\n+    if let Some(use_tree_list) = tree.use_tree_list() {\n+        let prefix = match tree.path() {\n+            None => prefix,\n+            Some(path) => match convert_path(prefix, path) {\n+                Some(it) => Some(it),\n+                None => return, // TODO: report errors somewhere\n+            },\n+        };\n+        for tree in use_tree_list.use_trees() {\n+            expand_use_tree(prefix.clone(), tree, cb);\n+        }\n+    } else {\n+        if let Some(ast_path) = tree.path() {\n+            if let Some(path) = convert_path(prefix, ast_path) {\n+                let range = if tree.has_star() {\n+                    None\n+                } else {\n+                    let range = ast_path.segment().unwrap().syntax().range();\n+                    Some(range)\n+                };\n+                cb(path, range)\n+            }\n+        }\n+    }\n+}\n+\n+fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual)?)\n+    } else {\n+        None\n+    };\n+    let segment = path.segment()?;\n+    let res = match segment.kind()? {\n+        ast::PathSegmentKind::Name(name) => {\n+            let mut res = prefix.unwrap_or_else(|| Path {\n+                kind: PathKind::Plain,\n+                segments: Vec::with_capacity(1),\n+            });\n+            res.segments.push(name.text());\n+            res\n+        }\n+        ast::PathSegmentKind::CrateKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Crate,\n+                segments: Vec::new(),\n+            }\n+        }\n+        ast::PathSegmentKind::SelfKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Self_,\n+                segments: Vec::new(),\n+            }\n+        }\n+        ast::PathSegmentKind::SuperKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Super,\n+                segments: Vec::new(),\n+            }\n+        }\n+    };\n+    Some(res)\n+}"}, {"sha": "6f602878c8d6b747a600525b6942b6ecb1428d1e", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -0,0 +1,154 @@\n+use std::{\n+    sync::Arc,\n+    time::Instant,\n+};\n+\n+use rustc_hash::FxHashMap;\n+use ra_syntax::{\n+    AstNode,  SyntaxNode, SmolStr,\n+    ast::{self, FnDef, FnDefNode, NameOwner, ModuleItemOwner}\n+};\n+use ra_db::{SourceRootId, FileId, Cancelable,};\n+\n+use crate::{\n+        FnId,\n+        SourceFileItems, SourceItemId,\n+        db::HirDatabase,\n+        function::FnScopes,\n+        module::{\n+            ModuleSource, ModuleSourceNode, ModuleId,\n+            imp::Submodule,\n+            nameres::{InputModuleItems, ItemMap, Resolver},\n+        },\n+};\n+\n+/// Resolve `FnId` to the corresponding `SyntaxNode`\n+pub(super) fn fn_syntax(db: &impl HirDatabase, fn_id: FnId) -> FnDefNode {\n+    let item_id = fn_id.loc(db);\n+    let syntax = db.file_item(item_id);\n+    FnDef::cast(syntax.borrowed()).unwrap().owned()\n+}\n+\n+pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n+    let syntax = db.fn_syntax(fn_id);\n+    let res = FnScopes::new(syntax.borrowed());\n+    Arc::new(res)\n+}\n+\n+pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n+    let source_file = db.source_file(file_id);\n+    let source_file = source_file.borrowed();\n+    let mut res = SourceFileItems::default();\n+    source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::ModuleItem::cast)\n+        .map(|it| it.syntax().owned())\n+        .for_each(|it| {\n+            res.alloc(it);\n+        });\n+    Arc::new(res)\n+}\n+\n+pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n+    db.file_items(source_item_id.file_id)[source_item_id.item_id].clone()\n+}\n+\n+pub(crate) fn submodules(\n+    db: &impl HirDatabase,\n+    source: ModuleSource,\n+) -> Cancelable<Arc<Vec<Submodule>>> {\n+    db.check_canceled()?;\n+    let file_id = source.file_id();\n+    let submodules = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => collect_submodules(db, file_id, it.borrowed()),\n+        ModuleSourceNode::Module(it) => it\n+            .borrowed()\n+            .item_list()\n+            .map(|it| collect_submodules(db, file_id, it))\n+            .unwrap_or_else(Vec::new),\n+    };\n+    return Ok(Arc::new(submodules));\n+\n+    fn collect_submodules<'a>(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        root: impl ast::ModuleItemOwner<'a>,\n+    ) -> Vec<Submodule> {\n+        modules(root)\n+            .map(|(name, m)| {\n+                if m.has_semi() {\n+                    Submodule::Declaration(name)\n+                } else {\n+                    let src = ModuleSource::new_inline(db, file_id, m);\n+                    Submodule::Definition(name, src)\n+                }\n+            })\n+            .collect()\n+    }\n+}\n+\n+pub(crate) fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            Some((name, module))\n+        })\n+}\n+\n+pub(super) fn input_module_items(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<InputModuleItems>> {\n+    let module_tree = db.module_tree(source_root)?;\n+    let source = module_id.source(&module_tree);\n+    let file_items = db.file_items(source.file_id());\n+    let res = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => {\n+            let items = it.borrowed().items();\n+            InputModuleItems::new(&file_items, items)\n+        }\n+        ModuleSourceNode::Module(it) => {\n+            let items = it\n+                .borrowed()\n+                .item_list()\n+                .into_iter()\n+                .flat_map(|it| it.items());\n+            InputModuleItems::new(&file_items, items)\n+        }\n+    };\n+    Ok(Arc::new(res))\n+}\n+\n+pub(super) fn item_map(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ItemMap>> {\n+    let start = Instant::now();\n+    let module_tree = db.module_tree(source_root)?;\n+    let input = module_tree\n+        .modules()\n+        .map(|id| {\n+            let items = db.input_module_items(source_root, id)?;\n+            Ok((id, items))\n+        })\n+        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n+    let resolver = Resolver {\n+        db: db,\n+        input: &input,\n+        source_root,\n+        module_tree,\n+        result: ItemMap::default(),\n+    };\n+    let res = resolver.resolve()?;\n+    let elapsed = start.elapsed();\n+    log::info!(\"item_map: {:?}\", elapsed);\n+    Ok(Arc::new(res))\n+}"}]}