{"sha": "48b3c4612681ba7828880aa9e675452c62714bbf", "node_id": "C_kwDOAAsO6NoAKDQ4YjNjNDYxMjY4MWJhNzgyODg4MGFhOWU2NzU0NTJjNjI3MTRiYmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-18T05:04:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-18T05:04:04Z"}, "message": "Auto merge of #105638 - tavianator:fix-50619-again, r=Mark-Simulacrum\n\nfs: Fix #50619 (again) and add a regression test\n\nBug #50619 was fixed by adding an end_of_stream flag in #50630.\nUnfortunately, that fix only applied to the readdir_r() path.  When I\nswitched Linux to use readdir() in #92778, I inadvertently reintroduced\nthe bug on that platform.  Other platforms that had always used\nreaddir() were presumably never fixed.\n\nThis patch enables end_of_stream for all platforms, and adds a\nLinux-specific regression test that should hopefully prevent the bug\nfrom being reintroduced again.", "tree": {"sha": "37dabe79aeb55bb603c8768455128a87ea06632d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37dabe79aeb55bb603c8768455128a87ea06632d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48b3c4612681ba7828880aa9e675452c62714bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48b3c4612681ba7828880aa9e675452c62714bbf", "html_url": "https://github.com/rust-lang/rust/commit/48b3c4612681ba7828880aa9e675452c62714bbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48b3c4612681ba7828880aa9e675452c62714bbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff016a55c24d061a479f9116f9cd8edc5594eb9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff016a55c24d061a479f9116f9cd8edc5594eb9e", "html_url": "https://github.com/rust-lang/rust/commit/ff016a55c24d061a479f9116f9cd8edc5594eb9e"}, {"sha": "9fb7c5ae5e66703240ce4242f55b66a066e0a93c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb7c5ae5e66703240ce4242f55b66a066e0a93c", "html_url": "https://github.com/rust-lang/rust/commit/9fb7c5ae5e66703240ce4242f55b66a066e0a93c"}], "stats": {"total": 85, "additions": 47, "deletions": 38}, "files": [{"sha": "b385ebde439794e9fc1b3fa0e526aec447a15031", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48b3c4612681ba7828880aa9e675452c62714bbf/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48b3c4612681ba7828880aa9e675452c62714bbf/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=48b3c4612681ba7828880aa9e675452c62714bbf", "patch": "@@ -1567,3 +1567,31 @@ fn test_eq_direntry_metadata() {\n         assert_eq!(ft1, ft2);\n     }\n }\n+\n+/// Regression test for https://github.com/rust-lang/rust/issues/50619.\n+#[test]\n+#[cfg(target_os = \"linux\")]\n+fn test_read_dir_infinite_loop() {\n+    use crate::io::ErrorKind;\n+    use crate::process::Command;\n+\n+    // Create a zombie child process\n+    let Ok(mut child) = Command::new(\"echo\").spawn() else { return };\n+\n+    // Make sure the process is (un)dead\n+    match child.kill() {\n+        // InvalidInput means the child already exited\n+        Err(e) if e.kind() != ErrorKind::InvalidInput => return,\n+        _ => {}\n+    }\n+\n+    // open() on this path will succeed, but readdir() will fail\n+    let id = child.id();\n+    let path = format!(\"/proc/{id}/net\");\n+\n+    // Skip the test if we can't open the directory in the first place\n+    let Ok(dir) = fs::read_dir(path) else { return };\n+\n+    // Check for duplicate errors\n+    assert!(dir.filter(|e| e.is_err()).take(2).count() < 2);\n+}"}, {"sha": "d5f50d77911fcafe3ef883f4f85cf3d808d3e223", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/48b3c4612681ba7828880aa9e675452c62714bbf/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48b3c4612681ba7828880aa9e675452c62714bbf/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=48b3c4612681ba7828880aa9e675452c62714bbf", "patch": "@@ -243,17 +243,15 @@ struct InnerReadDir {\n \n pub struct ReadDir {\n     inner: Arc<InnerReadDir>,\n-    #[cfg(not(any(\n-        target_os = \"android\",\n-        target_os = \"linux\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-        target_os = \"fuchsia\",\n-        target_os = \"redox\",\n-    )))]\n     end_of_stream: bool,\n }\n \n+impl ReadDir {\n+    fn new(inner: InnerReadDir) -> Self {\n+        Self { inner: Arc::new(inner), end_of_stream: false }\n+    }\n+}\n+\n struct Dir(*mut libc::DIR);\n \n unsafe impl Send for Dir {}\n@@ -594,6 +592,10 @@ impl Iterator for ReadDir {\n         target_os = \"illumos\"\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        if self.end_of_stream {\n+            return None;\n+        }\n+\n         unsafe {\n             loop {\n                 // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n@@ -604,8 +606,12 @@ impl Iterator for ReadDir {\n                 super::os::set_errno(0);\n                 let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n-                    // null can mean either the end is reached or an error occurred.\n-                    // So we had to clear errno beforehand to check for an error now.\n+                    // We either encountered an error, or reached the end.  Either way,\n+                    // the next call to next() should return None.\n+                    self.end_of_stream = true;\n+\n+                    // To distinguish between errors and end-of-directory, we had to clear\n+                    // errno beforehand to check for an error now.\n                     return match super::os::errno() {\n                         0 => None,\n                         e => Some(Err(Error::from_raw_os_error(e))),\n@@ -1363,18 +1369,7 @@ pub fn readdir(path: &Path) -> io::Result<ReadDir> {\n     } else {\n         let root = path.to_path_buf();\n         let inner = InnerReadDir { dirp: Dir(ptr), root };\n-        Ok(ReadDir {\n-            inner: Arc::new(inner),\n-            #[cfg(not(any(\n-                target_os = \"android\",\n-                target_os = \"linux\",\n-                target_os = \"solaris\",\n-                target_os = \"illumos\",\n-                target_os = \"fuchsia\",\n-                target_os = \"redox\",\n-            )))]\n-            end_of_stream: false,\n-        })\n+        Ok(ReadDir::new(inner))\n     }\n }\n \n@@ -1755,7 +1750,6 @@ mod remove_dir_impl {\n     use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n     use crate::os::unix::prelude::{OwnedFd, RawFd};\n     use crate::path::{Path, PathBuf};\n-    use crate::sync::Arc;\n     use crate::sys::common::small_c_string::run_path_with_cstr;\n     use crate::sys::{cvt, cvt_r};\n \n@@ -1832,21 +1826,8 @@ mod remove_dir_impl {\n         // a valid root is not needed because we do not call any functions involving the full path\n         // of the DirEntrys.\n         let dummy_root = PathBuf::new();\n-        Ok((\n-            ReadDir {\n-                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n-                #[cfg(not(any(\n-                    target_os = \"android\",\n-                    target_os = \"linux\",\n-                    target_os = \"solaris\",\n-                    target_os = \"illumos\",\n-                    target_os = \"fuchsia\",\n-                    target_os = \"redox\",\n-                )))]\n-                end_of_stream: false,\n-            },\n-            new_parent_fd,\n-        ))\n+        let inner = InnerReadDir { dirp, root: dummy_root };\n+        Ok((ReadDir::new(inner), new_parent_fd))\n     }\n \n     #[cfg(any("}]}