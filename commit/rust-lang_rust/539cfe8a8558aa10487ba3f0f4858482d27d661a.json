{"sha": "539cfe8a8558aa10487ba3f0f4858482d27d661a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOWNmZThhODU1OGFhMTA0ODdiYTNmMGY0ODU4NDgyZDI3ZDY2MWE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2011-12-19T19:57:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2011-12-19T19:57:44Z"}, "message": "Merge pull request #1336 from erickt/master\n\nmisc fixes and library functions", "tree": {"sha": "8bf2e125f4922b7429d7b7a45c1b27d7f670b577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bf2e125f4922b7429d7b7a45c1b27d7f670b577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/539cfe8a8558aa10487ba3f0f4858482d27d661a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/539cfe8a8558aa10487ba3f0f4858482d27d661a", "html_url": "https://github.com/rust-lang/rust/commit/539cfe8a8558aa10487ba3f0f4858482d27d661a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/539cfe8a8558aa10487ba3f0f4858482d27d661a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebdf3ef2c0f139f49eaf0ac31407c95688f38a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebdf3ef2c0f139f49eaf0ac31407c95688f38a21", "html_url": "https://github.com/rust-lang/rust/commit/ebdf3ef2c0f139f49eaf0ac31407c95688f38a21"}, {"sha": "02d84d89e029d58469f0ee9d6d7d15a894b5236f", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d84d89e029d58469f0ee9d6d7d15a894b5236f", "html_url": "https://github.com/rust-lang/rust/commit/02d84d89e029d58469f0ee9d6d7d15a894b5236f"}], "stats": {"total": 170, "additions": 143, "deletions": 27}, "files": [{"sha": "95afc2b55cb3d6ed7b710a6e1d21cf0f4f5b7cba", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -321,7 +321,7 @@ mod write {\n  *\n  * There are a few issues to handle:\n  *\n- *  - Linnkers operate on a flat namespace, so we have to flatten names.\n+ *  - Linkers operate on a flat namespace, so we have to flatten names.\n  *    We do this using the C++ namespace-mangling technique. Foo::bar\n  *    symbols and such.\n  *"}, {"sha": "aad31ba2e0994436fb2260b34cc1cb3781e2b94a", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -46,7 +46,7 @@ syn match\trustFloat\t\tdisplay contained \"\\d\\+e[-+]\\=\\d\\+[fl]\\=\\>\"\n syn match   rustCharacter   \"'[^']*'\"\n \n syn case match\n-syn region    rustComment     start=\"/\\*\" end=\"\\*/\"\n+syn region    rustComment     start=\"/\\*\" end=\"\\*/\" contains=rustComment\n syn region    rustComment     start=\"//\" skip=\"\\\\$\" end=\"$\" keepend\n \n hi def link rustString        String\n@@ -59,5 +59,7 @@ hi def link rustComment       Comment\n hi def link rustMacro         Macro\n hi def link rustType          Type\n \n-let b:current_syntax = \"rust\"\n+syn sync minlines=200\n+syn sync maxlines=500\n \n+let b:current_syntax = \"rust\""}, {"sha": "080c7ffc1cf53e772ac068d77c32c91756975575", "filename": "src/libcore/str.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -6,11 +6,11 @@ String manipulation.\n \n export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n        byte_len_range, index,\n-       rindex, find, starts_with, ends_with, substr, slice, split, split_str,\n-       concat, connect, to_upper, replace, char_slice, trim_left, trim_right,\n-       trim, unshift_char, shift_char, pop_char, push_char, is_utf8,\n-       from_chars, to_chars, char_len, char_len_range, char_at, bytes,\n-       is_ascii, shift_byte, pop_byte,\n+       rindex, find, starts_with, ends_with, substr, slice, split, splitn,\n+       split_str, concat, connect, to_upper, replace, char_slice, trim_left,\n+       trim_right, trim, unshift_char, shift_char, pop_char, push_char,\n+       is_utf8, from_chars, to_chars, char_len, char_len_range, char_at,\n+       bytes, is_ascii, shift_byte, pop_byte,\n        unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n        str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n        contains, iter_chars, loop_chars, loop_chars_sub,\n@@ -744,6 +744,32 @@ fn split(s: str, sep: u8) -> [str] {\n     ret v;\n }\n \n+/*\n+Function: splitn\n+\n+Split a string at each occurance of a given separator up to count times.\n+\n+Returns:\n+\n+A vector containing all the strings between each occurance of the separator\n+*/\n+fn splitn(s: str, sep: u8, count: uint) -> [str] {\n+    let v = [];\n+    let accum = \"\";\n+    let n = count;\n+    let ends_with_sep: bool = false;\n+    for c in s {\n+        if n > 0u && c == sep {\n+            n -= 1u;\n+            v += [accum];\n+            accum = \"\";\n+            ends_with_sep = true;\n+        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+    }\n+    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n+    ret v;\n+}\n+\n /*\n Function: split_str\n "}, {"sha": "90e1ff3786491601cc12629df970a6e66030c0b8", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -300,6 +300,15 @@ fn pop<copy T>(&v: [const T]) -> T {\n     ret e;\n }\n \n+/*\n+Function: push\n+\n+Append an element to a vector and return it\n+*/\n+fn push<copy T>(&v: [T], initval: T) {\n+    grow(v, 1u, initval)\n+}\n+\n // TODO: More.\n \n \n@@ -507,6 +516,24 @@ fn any<T>(v: [T], f: block(T) -> bool) -> bool {\n     ret false;\n }\n \n+/*\n+Function: any2\n+\n+Return true if a predicate matches any elements in both vectors.\n+\n+If the vectors contains no elements then false is returned.\n+*/\n+fn any2<T, U>(v0: [T], v1: [U], f: block(T, U) -> bool) -> bool {\n+    let v0_len = len(v0);\n+    let v1_len = len(v1);\n+    let i = 0u;\n+    while i < v0_len && i < v1_len {\n+        if f(v0[i], v1[i]) { ret true; };\n+        i += 1u;\n+    }\n+    ret false;\n+}\n+\n /*\n Function: all\n \n@@ -519,6 +546,21 @@ fn all<T>(v: [T], f: block(T) -> bool) -> bool {\n     ret true;\n }\n \n+/*\n+Function: all2\n+\n+Return true if a predicate matches all elements in both vectors.\n+\n+If the vectors are not the same size then false is returned.\n+*/\n+fn all2<T, U>(v0: [T], v1: [U], f: block(T, U) -> bool) -> bool {\n+    let v0_len = len(v0);\n+    if v0_len != len(v1) { ret false; }\n+    let i = 0u;\n+    while i < v0_len { if !f(v0[i], v1[i]) { ret false; }; i += 1u; }\n+    ret true;\n+}\n+\n /*\n Function: member\n "}, {"sha": "1e354d825ae6300cf1a29f0fb7baa9d24a9ac844", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -149,10 +149,7 @@ fn name_str(nm: name) -> str {\n }\n \n fn find_opt(opts: [opt], nm: name) -> option::t<uint> {\n-    let i = 0u;\n-    let l = vec::len::<opt>(opts);\n-    while i < l { if opts[i].name == nm { ret some::<uint>(i); } i += 1u; }\n-    ret none::<uint>;\n+    vec::position_pred(opts, { |opt| opt.name == nm })\n }\n \n /*"}, {"sha": "eafc5ba0b5d302b30d00a28121d77a1a9898de5a", "filename": "src/test/stdtest/getopts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -444,10 +444,11 @@ fn test_unrecognized_option_short() {\n fn test_combined() {\n     let args =\n         [\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\", \"-f\",\n-         \"-m\", \"40\", \"-m\", \"50\"];\n+         \"-m\", \"40\", \"-m\", \"50\", \"-n\", \"-A B\", \"-n\", \"-60 70\"];\n     let opts =\n         [opt::optopt(\"s\"), opt::optflag(\"flag\"), opt::reqopt(\"long\"),\n-         opt::optflag(\"f\"), opt::optmulti(\"m\"), opt::optopt(\"notpresent\")];\n+         opt::optflag(\"f\"), opt::optmulti(\"m\"), opt::optmulti(\"n\"),\n+         opt::optopt(\"notpresent\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       ok(m) {\n@@ -460,6 +461,8 @@ fn test_combined() {\n         assert (opt::opt_present(m, \"f\"));\n         assert (opt::opt_strs(m, \"m\")[0] == \"40\");\n         assert (opt::opt_strs(m, \"m\")[1] == \"50\");\n+        assert (opt::opt_strs(m, \"n\")[0] == \"-A B\");\n+        assert (opt::opt_strs(m, \"n\")[1] == \"-60 70\");\n         assert (!opt::opt_present(m, \"notpresent\"));\n       }\n       _ { fail; }"}, {"sha": "b70cafe739281875804172437e0368a389e50411", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -41,22 +41,37 @@ fn test_index_and_rindex() {\n \n #[test]\n fn test_split() {\n-    fn t(s: str, c: char, i: int, k: str) {\n-        log \"splitting: \" + s;\n-        log i;\n+    fn t(s: str, c: char, u: [str]) {\n+        log \"split: \" + s;\n         let v = str::split(s, c as u8);\n         log \"split to: \";\n-        for z: str in v { log z; }\n-        log \"comparing: \" + v[i] + \" vs. \" + k;\n-        assert (str::eq(v[i], k));\n+        log v;\n+        assert (vec::all2(v, u, { |a,b| a == b }));\n     }\n-    t(\"abc.hello.there\", '.', 0, \"abc\");\n-    t(\"abc.hello.there\", '.', 1, \"hello\");\n-    t(\"abc.hello.there\", '.', 2, \"there\");\n-    t(\".hello.there\", '.', 0, \"\");\n-    t(\".hello.there\", '.', 1, \"hello\");\n-    t(\"...hello.there.\", '.', 3, \"hello\");\n-    t(\"...hello.there.\", '.', 5, \"\");\n+    t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]);\n+    t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]);\n+    t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+}\n+\n+#[test]\n+fn test_splitn() {\n+    fn t(s: str, c: char, n: uint, u: [str]) {\n+        log \"splitn: \" + s;\n+        let v = str::splitn(s, c as u8, n);\n+        log \"split to: \";\n+        log v;\n+        log \"comparing vs. \";\n+        log u;\n+        assert (vec::all2(v, u, { |a,b| a == b }));\n+    }\n+    t(\"abc.hello.there\", '.', 0u, [\"abc.hello.there\"]);\n+    t(\"abc.hello.there\", '.', 1u, [\"abc\", \"hello.there\"]);\n+    t(\"abc.hello.there\", '.', 2u, [\"abc\", \"hello\", \"there\"]);\n+    t(\"abc.hello.there\", '.', 3u, [\"abc\", \"hello\", \"there\"]);\n+    t(\".hello.there\", '.', 0u, [\".hello.there\"]);\n+    t(\".hello.there\", '.', 1u, [\"\", \"hello.there\"]);\n+    t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]);\n+    t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n }\n \n #[test]"}, {"sha": "9994463ec3c9107ed2bb104900cd930565376cda", "filename": "src/test/stdtest/vec.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539cfe8a8558aa10487ba3f0f4858482d27d661a/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=539cfe8a8558aa10487ba3f0f4858482d27d661a", "patch": "@@ -16,6 +16,8 @@ pure fn is_three(&&n: uint) -> bool { ret n == 3u; }\n \n pure fn is_odd(&&n: uint) -> bool { ret n % 2u == 1u; }\n \n+pure fn is_equal(&&x: uint, &&y:uint) -> bool { ret x == y; }\n+\n fn square_if_odd(&&n: uint) -> option::t<uint> {\n     ret if n % 2u == 1u { some(n * n) } else { none };\n }\n@@ -168,6 +170,21 @@ fn test_pop() {\n     assert (e == 5);\n }\n \n+#[test]\n+fn test_push() {\n+    // Test on-stack push().\n+    let v = [];\n+    vec::push(v, 1);\n+    assert (vec::len(v) == 1u);\n+    assert (v[0] == 1);\n+\n+    // Test on-heap push().\n+    vec::push(v, 2);\n+    assert (vec::len(v) == 2u);\n+    assert (v[0] == 1);\n+    assert (v[1] == 2);\n+}\n+\n #[test]\n fn test_grow() {\n     // Test on-stack grow().\n@@ -401,6 +418,20 @@ fn test_any_and_all() {\n     assert (!vec::all([3u, 3u, 0u, 1u, 2u], is_three));\n }\n \n+#[test]\n+fn test_any2_and_all2() {\n+\n+    assert (vec::any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n+    assert (vec::any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n+    assert (!vec::any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n+    assert (vec::any2([2u, 4u, 6u], [2u, 4u], is_equal));\n+\n+    assert (vec::all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n+    assert (!vec::all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n+    assert (!vec::all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n+    assert (!vec::all2([2u, 4u, 6u], [2u, 4u], is_equal));\n+}\n+\n #[test]\n fn test_zip_unzip() {\n     let v1 = [1, 2, 3];"}]}