{"sha": "25d6f8e0f647f865775158f35408724278145c50", "node_id": "C_kwDOAAsO6NoAKDI1ZDZmOGUwZjY0N2Y4NjU3NzUxNThmMzU0MDg3MjQyNzgxNDVjNTA", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-04-08T15:57:44Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-04-08T15:57:44Z"}, "message": "Avoid looking at the internals of Interned directly", "tree": {"sha": "4dbdc9425e6b2c8df2629d0d1b4088e286790794", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dbdc9425e6b2c8df2629d0d1b4088e286790794"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d6f8e0f647f865775158f35408724278145c50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d6f8e0f647f865775158f35408724278145c50", "html_url": "https://github.com/rust-lang/rust/commit/25d6f8e0f647f865775158f35408724278145c50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d6f8e0f647f865775158f35408724278145c50/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e0ef701c2e8ecb03ccebdc268980ec6d62a4a39", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e0ef701c2e8ecb03ccebdc268980ec6d62a4a39", "html_url": "https://github.com/rust-lang/rust/commit/2e0ef701c2e8ecb03ccebdc268980ec6d62a4a39"}], "stats": {"total": 349, "additions": 150, "deletions": 199}, "files": [{"sha": "c8236ce79c098ad6d85ad5f9d4c741fcbb6b2a3d", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -2,7 +2,6 @@ use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n@@ -164,12 +163,6 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         for outlives_bound in outlives_bounds {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n-                OutlivesBound::RegionSubRegion(\n-                    r_a @ (Region(Interned(ReEarlyBound(_), _)) | Region(Interned(ReFree(_), _))),\n-                    Region(Interned(ReVar(vid_b), _)),\n-                ) => {\n-                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, *vid_b);\n-                }\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n                     self.region_bound_pairs_accum.push((r_a, GenericKind::Param(param_b)));\n                 }\n@@ -178,17 +171,23 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n                         .push((r_a, GenericKind::Projection(projection_b)));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n-                    // In principle, we could record (and take\n-                    // advantage of) every relationship here, but\n-                    // we are also free not to -- it simply means\n-                    // strictly less that we can successfully type\n-                    // check. Right now we only look for things\n-                    // relationships between free regions. (It may\n-                    // also be that we should revise our inference\n-                    // system to be more general and to make use\n-                    // of *every* relationship that arises here,\n-                    // but presently we do not.)\n-                    self.free_region_map.relate_regions(r_a, r_b);\n+                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n+                        infcx\n+                            .expect(\"no infcx provided but region vars found\")\n+                            .add_given(r_a, vid_b);\n+                    } else {\n+                        // In principle, we could record (and take\n+                        // advantage of) every relationship here, but\n+                        // we are also free not to -- it simply means\n+                        // strictly less that we can successfully type\n+                        // check. Right now we only look for things\n+                        // relationships between free regions. (It may\n+                        // also be that we should revise our inference\n+                        // system to be more general and to make use\n+                        // of *every* relationship that arises here,\n+                        // but presently we do not.)\n+                        self.free_region_map.relate_regions(r_a, r_b);\n+                    }\n                 }\n             }\n         }"}, {"sha": "e265bc0fcd2a0d27aa91518bdac35dc4239d02ae", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -5,7 +5,6 @@ use crate::ty::subst::Subst;\n use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::BitSet;\n@@ -503,42 +502,34 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n \n                 // Two non-ZST fields, and they're both scalars.\n-                (\n-                    Some((\n-                        i,\n-                        &TyAndLayout {\n-                            layout: Layout(Interned(&LayoutS { abi: Abi::Scalar(a), .. }, _)),\n-                            ..\n-                        },\n-                    )),\n-                    Some((\n-                        j,\n-                        &TyAndLayout {\n-                            layout: Layout(Interned(&LayoutS { abi: Abi::Scalar(b), .. }, _)),\n-                            ..\n-                        },\n-                    )),\n-                    None,\n-                ) => {\n-                    // Order by the memory placement, not source order.\n-                    let ((i, a), (j, b)) =\n-                        if offsets[i] < offsets[j] { ((i, a), (j, b)) } else { ((j, b), (i, a)) };\n-                    let pair = self.scalar_pair(a, b);\n-                    let pair_offsets = match pair.fields {\n-                        FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                            assert_eq!(memory_index, &[0, 1]);\n-                            offsets\n+                (Some((i, a)), Some((j, b)), None) => {\n+                    match (a.abi, b.abi) {\n+                        (Abi::Scalar(a), Abi::Scalar(b)) => {\n+                            // Order by the memory placement, not source order.\n+                            let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                                ((i, a), (j, b))\n+                            } else {\n+                                ((j, b), (i, a))\n+                            };\n+                            let pair = self.scalar_pair(a, b);\n+                            let pair_offsets = match pair.fields {\n+                                FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                                    assert_eq!(memory_index, &[0, 1]);\n+                                    offsets\n+                                }\n+                                _ => bug!(),\n+                            };\n+                            if offsets[i] == pair_offsets[0]\n+                                && offsets[j] == pair_offsets[1]\n+                                && align == pair.align\n+                                && size == pair.size\n+                            {\n+                                // We can use `ScalarPair` only when it matches our\n+                                // already computed layout (including `#[repr(C)]`).\n+                                abi = pair.abi;\n+                            }\n                         }\n-                        _ => bug!(),\n-                    };\n-                    if offsets[i] == pair_offsets[0]\n-                        && offsets[j] == pair_offsets[1]\n-                        && align == pair.align\n-                        && size == pair.size\n-                    {\n-                        // We can use `ScalarPair` only when it matches our\n-                        // already computed layout (including `#[repr(C)]`).\n-                        abi = pair.abi;\n+                        _ => {}\n                     }\n                 }\n \n@@ -788,10 +779,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     }\n \n                     // Extract the number of elements from the layout of the array field:\n-                    let Ok(TyAndLayout {\n-                        layout: Layout(Interned(LayoutS { fields: FieldsShape::Array { count, .. }, .. }, _)),\n-                        ..\n-                    }) = self.layout_of(f0_ty) else {\n+                    let FieldsShape::Array { count, .. } = self.layout_of(f0_ty)?.layout.fields() else {\n                         return Err(LayoutError::Unknown(ty));\n                     };\n "}, {"sha": "4379adb604e1f29e9d1e24e79413ef2460eedecb", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 76, "deletions": 102, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -3,7 +3,6 @@ use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -1263,71 +1262,52 @@ pub trait PrettyPrinter<'tcx>:\n         let (alloc_id, offset) = ptr.into_parts();\n         match ty.kind() {\n             // Byte strings (&[u8; N])\n-            ty::Ref(\n-                _,\n-                Ty(Interned(\n-                    WithStableHash {\n-                        internee:\n-                            ty::TyS {\n-                                kind:\n-                                    ty::Array(\n-                                        Ty(Interned(\n-                                            WithStableHash {\n-                                                internee:\n-                                                    ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n-                                                ..\n-                                            },\n-                                            _,\n-                                        )),\n-                                        ty::Const(Interned(\n-                                            ty::ConstS {\n-                                                val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n-                                                ..\n-                                            },\n-                                            _,\n-                                        )),\n-                                    ),\n-                                ..\n-                            },\n-                        ..\n-                    },\n-                    _,\n-                )),\n-                _,\n-            ) => match self.tcx().get_global_alloc(alloc_id) {\n-                Some(GlobalAlloc::Memory(alloc)) => {\n-                    let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n-                    let range = AllocRange { start: offset, size: Size::from_bytes(len) };\n-                    if let Ok(byte_str) = alloc.inner().get_bytes(&self.tcx(), range) {\n-                        p!(pretty_print_byte_str(byte_str))\n-                    } else {\n-                        p!(\"<too short allocation>\")\n+            ty::Ref(_, inner, _) => {\n+                if let ty::Array(elem, len) = inner.kind() {\n+                    if let ty::Uint(ty::UintTy::U8) = elem.kind() {\n+                        if let ty::ConstKind::Value(ConstValue::Scalar(int)) = len.val() {\n+                            match self.tcx().get_global_alloc(alloc_id) {\n+                                Some(GlobalAlloc::Memory(alloc)) => {\n+                                    let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n+                                    let range =\n+                                        AllocRange { start: offset, size: Size::from_bytes(len) };\n+                                    if let Ok(byte_str) =\n+                                        alloc.inner().get_bytes(&self.tcx(), range)\n+                                    {\n+                                        p!(pretty_print_byte_str(byte_str))\n+                                    } else {\n+                                        p!(\"<too short allocation>\")\n+                                    }\n+                                }\n+                                // FIXME: for statics and functions, we could in principle print more detail.\n+                                Some(GlobalAlloc::Static(def_id)) => {\n+                                    p!(write(\"<static({:?})>\", def_id))\n+                                }\n+                                Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n+                                None => p!(\"<dangling pointer>\"),\n+                            }\n+                            return Ok(self);\n+                        }\n                     }\n                 }\n-                // FIXME: for statics and functions, we could in principle print more detail.\n-                Some(GlobalAlloc::Static(def_id)) => p!(write(\"<static({:?})>\", def_id)),\n-                Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n-                None => p!(\"<dangling pointer>\"),\n-            },\n+            }\n             ty::FnPtr(_) => {\n                 // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n                 // printing above (which also has to handle pointers to all sorts of things).\n-                match self.tcx().get_global_alloc(alloc_id) {\n-                    Some(GlobalAlloc::Function(instance)) => {\n-                        self = self.typed_value(\n-                            |this| this.print_value_path(instance.def_id(), instance.substs),\n-                            |this| this.print_type(ty),\n-                            \" as \",\n-                        )?;\n-                    }\n-                    _ => self = self.pretty_print_const_pointer(ptr, ty, print_ty)?,\n+                if let Some(GlobalAlloc::Function(instance)) = self.tcx().get_global_alloc(alloc_id)\n+                {\n+                    self = self.typed_value(\n+                        |this| this.print_value_path(instance.def_id(), instance.substs),\n+                        |this| this.print_type(ty),\n+                        \" as \",\n+                    )?;\n+                    return Ok(self);\n                 }\n             }\n-            // Any pointer values not covered by a branch above\n-            _ => {\n-                self = self.pretty_print_const_pointer(ptr, ty, print_ty)?;\n-            }\n+            _ => {}\n         }\n+        // Any pointer values not covered by a branch above\n+        self = self.pretty_print_const_pointer(ptr, ty, print_ty)?;\n         Ok(self)\n     }\n \n@@ -1448,39 +1428,31 @@ pub trait PrettyPrinter<'tcx>:\n \n         match (ct, ty.kind()) {\n             // Byte/string slices, printed as (byte) string literals.\n-            (\n-                ConstValue::Slice { data, start, end },\n-                ty::Ref(\n-                    _,\n-                    Ty(Interned(\n-                        WithStableHash { internee: ty::TyS { kind: ty::Slice(t), .. }, .. },\n-                        _,\n-                    )),\n-                    _,\n-                ),\n-            ) if *t == u8_type => {\n-                // The `inspect` here is okay since we checked the bounds, and there are\n-                // no relocations (we have an active slice reference here). We don't use\n-                // this result to affect interpreter execution.\n-                let byte_str =\n-                    data.inner().inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                self.pretty_print_byte_str(byte_str)\n-            }\n-            (\n-                ConstValue::Slice { data, start, end },\n-                ty::Ref(\n-                    _,\n-                    Ty(Interned(WithStableHash { internee: ty::TyS { kind: ty::Str, .. }, .. }, _)),\n-                    _,\n-                ),\n-            ) => {\n-                // The `inspect` here is okay since we checked the bounds, and there are no\n-                // relocations (we have an active `str` reference here). We don't use this\n-                // result to affect interpreter execution.\n-                let slice =\n-                    data.inner().inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                p!(write(\"{:?}\", String::from_utf8_lossy(slice)));\n-                Ok(self)\n+            (ConstValue::Slice { data, start, end }, ty::Ref(_, inner, _)) => {\n+                match inner.kind() {\n+                    ty::Slice(t) => {\n+                        if *t == u8_type {\n+                            // The `inspect` here is okay since we checked the bounds, and there are\n+                            // no relocations (we have an active slice reference here). We don't use\n+                            // this result to affect interpreter execution.\n+                            let byte_str = data\n+                                .inner()\n+                                .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                            return self.pretty_print_byte_str(byte_str);\n+                        }\n+                    }\n+                    ty::Str => {\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice = data\n+                            .inner()\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                        p!(write(\"{:?}\", String::from_utf8_lossy(slice)));\n+                        return Ok(self);\n+                    }\n+                    _ => {}\n+                }\n             }\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n                 let n = n.val().try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n@@ -1490,7 +1462,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let byte_str = alloc.inner().get_bytes(&self.tcx(), range).unwrap();\n                 p!(\"*\");\n                 p!(pretty_print_byte_str(byte_str));\n-                Ok(self)\n+                return Ok(self);\n             }\n \n             // Aggregates, printed as array/tuple/struct/variant construction syntax.\n@@ -1567,22 +1539,24 @@ pub trait PrettyPrinter<'tcx>:\n                     _ => unreachable!(),\n                 }\n \n-                Ok(self)\n+                return Ok(self);\n             }\n \n-            (ConstValue::Scalar(scalar), _) => self.pretty_print_const_scalar(scalar, ty, print_ty),\n+            (ConstValue::Scalar(scalar), _) => {\n+                return self.pretty_print_const_scalar(scalar, ty, print_ty);\n+            }\n \n             // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n             // their fields instead of just dumping the memory.\n-            _ => {\n-                // fallback\n-                p!(write(\"{:?}\", ct));\n-                if print_ty {\n-                    p!(\": \", print(ty));\n-                }\n-                Ok(self)\n-            }\n+            _ => {}\n         }\n+\n+        // fallback\n+        p!(write(\"{:?}\", ct));\n+        if print_ty {\n+            p!(\": \", print(ty));\n+        }\n+        Ok(self)\n     }\n }\n "}, {"sha": "a9749716ce8927d5eeb8c3e5a93e752fc65ba1a6", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -6,14 +6,12 @@ use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n use crate::ty::{\n-    self, Const, DebruijnIndex, DefIdTree, List, ReEarlyBound, Region, Ty, TyCtxt, TyKind::*,\n-    TypeFoldable,\n+    self, Const, DebruijnIndex, DefIdTree, List, ReEarlyBound, Ty, TyCtxt, TyKind::*, TypeFoldable,\n };\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -423,26 +421,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         let result = iter::zip(item_substs, impl_substs)\n             .filter(|&(_, k)| {\n                 match k.unpack() {\n-                    GenericArgKind::Lifetime(Region(Interned(ReEarlyBound(ref ebr), _))) => {\n-                        !impl_generics.region_param(ebr, self).pure_wrt_drop\n-                    }\n-                    GenericArgKind::Type(Ty(Interned(\n-                        WithStableHash {\n-                            internee: ty::TyS { kind: ty::Param(ref pt), .. }, ..\n-                        },\n-                        _,\n-                    ))) => !impl_generics.type_param(pt, self).pure_wrt_drop,\n-                    GenericArgKind::Const(Const(Interned(\n-                        ty::ConstS { val: ty::ConstKind::Param(ref pc), .. },\n-                        _,\n-                    ))) => !impl_generics.const_param(pc, self).pure_wrt_drop,\n-                    GenericArgKind::Lifetime(_)\n-                    | GenericArgKind::Type(_)\n-                    | GenericArgKind::Const(_) => {\n-                        // Not a type, const or region param: this should be reported\n-                        // as an error.\n-                        false\n-                    }\n+                    GenericArgKind::Lifetime(region) => match region.kind() {\n+                        ReEarlyBound(ref ebr) => {\n+                            !impl_generics.region_param(ebr, self).pure_wrt_drop\n+                        }\n+                        // Error: not a region param\n+                        _ => false,\n+                    },\n+                    GenericArgKind::Type(ty) => match ty.kind() {\n+                        ty::Param(ref pt) => !impl_generics.type_param(pt, self).pure_wrt_drop,\n+                        // Error: not a type param\n+                        _ => false,\n+                    },\n+                    GenericArgKind::Const(ct) => match ct.val() {\n+                        ty::ConstKind::Param(ref pc) => {\n+                            !impl_generics.const_param(pc, self).pure_wrt_drop\n+                        }\n+                        // Error: not a const param\n+                        _ => false,\n+                    },\n                 }\n             })\n             .map(|(item_param, _)| item_param)"}, {"sha": "302b8b791566d0ee96198212face72a018da181b", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -8,7 +8,6 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n-use rustc_data_structures::intern::Interned;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_index::vec::IndexVec;\n@@ -414,14 +413,12 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.recurse_build(self.body_id)?;\n \n         for n in self.nodes.iter() {\n-            if let Node::Leaf(ty::Const(Interned(\n-                ty::ConstS { val: ty::ConstKind::Unevaluated(ct), ty: _ },\n-                _,\n-            ))) = n\n-            {\n-                // `AbstractConst`s should not contain any promoteds as they require references which\n-                // are not allowed.\n-                assert_eq!(ct.promoted, None);\n+            if let Node::Leaf(ct) = n {\n+                if let ty::ConstKind::Unevaluated(ct) = ct.val() {\n+                    // `AbstractConst`s should not contain any promoteds as they require references which\n+                    // are not allowed.\n+                    assert_eq!(ct.promoted, None);\n+                }\n             }\n         }\n "}, {"sha": "5dab0bb7a13755e27ef88e0c39d4822375561459", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -1,7 +1,6 @@\n use crate::check::method::MethodCallee;\n use crate::check::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_ast as ast;\n-use rustc_data_structures::intern::Interned;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -126,9 +125,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ) = index_expr.kind\n         {\n             match adjusted_ty.kind() {\n-                ty::Adt(ty::AdtDef(Interned(ty::AdtDefData { did, .. }, _)), _)\n-                    if self.tcx.is_diagnostic_item(sym::Vec, *did) =>\n-                {\n+                ty::Adt(def, _) if self.tcx.is_diagnostic_item(sym::Vec, def.did()) => {\n                     return self.negative_index(adjusted_ty, index_expr.span, base_expr);\n                 }\n                 ty::Slice(_) | ty::Array(_, _) => {"}, {"sha": "a8f9c189adec88672e722c00c265425ea4acec71", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25d6f8e0f647f865775158f35408724278145c50/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d6f8e0f647f865775158f35408724278145c50/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=25d6f8e0f647f865775158f35408724278145c50", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::intern::Interned;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -56,8 +55,8 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n                 ty::Str => {\n                     return Some(span);\n                 },\n-                ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) => {\n-                    if ctx.tcx.is_diagnostic_item(sym::String, did) {\n+                ty::Adt(def, _) => {\n+                    if ctx.tcx.is_diagnostic_item(sym::String, def.did()) {\n                         return Some(span);\n                     }\n                 },"}]}