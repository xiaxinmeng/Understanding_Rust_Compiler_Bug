{"sha": "ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "node_id": "C_kwDOAAsO6NoAKGRkYjdmYmU4NDM0YmU0ODE2MDdhZTE5OWZlMmFlZTk3NmVlMmZjMmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-29T03:06:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-29T03:06:45Z"}, "message": "Auto merge of #96441 - ChrisDenton:sync-pipes, r=m-ou-se\n\nWindows: Make stdin pipes synchronous\n\nStdin pipes do not need to be used asynchronously within the standard library. This is a first step in making pipes mostly synchronous.\n\nr? `@m-ou-se`", "tree": {"sha": "627e0d2da7fcaa67116ee3ec175754f900f1cae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/627e0d2da7fcaa67116ee3ec175754f900f1cae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "html_url": "https://github.com/rust-lang/rust/commit/ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baaa3b682986879c7784b5733ecea942e9ae7de3", "url": "https://api.github.com/repos/rust-lang/rust/commits/baaa3b682986879c7784b5733ecea942e9ae7de3", "html_url": "https://github.com/rust-lang/rust/commit/baaa3b682986879c7784b5733ecea942e9ae7de3"}, {"sha": "1e7c15634d3b81b595d669382e45e6e136c730e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e7c15634d3b81b595d669382e45e6e136c730e1", "html_url": "https://github.com/rust-lang/rust/commit/1e7c15634d3b81b595d669382e45e6e136c730e1"}], "stats": {"total": 150, "additions": 119, "deletions": 31}, "files": [{"sha": "f3d7be3f95c6b0db39526c217581cc6d3012923c", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "patch": "@@ -198,6 +198,18 @@ impl OwnedHandle {\n         })?;\n         unsafe { Ok(Self::from_raw_handle(ret)) }\n     }\n+\n+    /// Allow child processes to inherit the handle.\n+    pub(crate) fn set_inheritable(&self) -> io::Result<()> {\n+        cvt(unsafe {\n+            c::SetHandleInformation(\n+                self.as_raw_handle(),\n+                c::HANDLE_FLAG_INHERIT,\n+                c::HANDLE_FLAG_INHERIT,\n+            )\n+        })?;\n+        Ok(())\n+    }\n }\n \n impl TryFrom<HandleOrInvalid> for OwnedHandle {"}, {"sha": "0692da1d795192d0e5358e7f2c5dc291293e7545", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "patch": "@@ -1022,6 +1022,12 @@ extern \"system\" {\n         bWaitAll: BOOL,\n         dwMilliseconds: DWORD,\n     ) -> DWORD;\n+    pub fn CreatePipe(\n+        hReadPipe: *mut HANDLE,\n+        hWritePipe: *mut HANDLE,\n+        lpPipeAttributes: *const SECURITY_ATTRIBUTES,\n+        nSize: DWORD,\n+    ) -> BOOL;\n     pub fn CreateNamedPipeW(\n         lpName: LPCWSTR,\n         dwOpenMode: DWORD,"}, {"sha": "3b609825a79da94d435213f249ccc0332a3f3c38", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "patch": "@@ -221,6 +221,10 @@ impl Handle {\n         Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n \n+    pub(crate) fn set_inheritable(&self) -> io::Result<()> {\n+        self.0.set_inheritable()\n+    }\n+\n     /// Performs a synchronous read.\n     ///\n     /// If the handle is opened for asynchronous I/O then this abort the process."}, {"sha": "928bf2439c3e1e1ac6f99b90046dc0f31557a7d8", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "patch": "@@ -18,20 +18,56 @@ use crate::sys_common::IntoInner;\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct AnonPipe {\n-    inner: Handle,\n+// A 64kb pipe capacity is the same as a typical Linux default.\n+const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n+\n+pub enum AnonPipe {\n+    Sync(Handle),\n+    Async(Handle),\n }\n \n impl IntoInner<Handle> for AnonPipe {\n     fn into_inner(self) -> Handle {\n-        self.inner\n+        match self {\n+            Self::Sync(handle) => handle,\n+            Self::Async(handle) => handle,\n+        }\n     }\n }\n \n pub struct Pipes {\n     pub ours: AnonPipe,\n     pub theirs: AnonPipe,\n }\n+impl Pipes {\n+    /// Create a new pair of pipes where both pipes are synchronous.\n+    ///\n+    /// These must not be used asynchronously.\n+    pub fn new_synchronous(\n+        ours_readable: bool,\n+        their_handle_inheritable: bool,\n+    ) -> io::Result<Self> {\n+        unsafe {\n+            // If `CreatePipe` succeeds, these will be our pipes.\n+            let mut read = ptr::null_mut();\n+            let mut write = ptr::null_mut();\n+\n+            if c::CreatePipe(&mut read, &mut write, ptr::null(), PIPE_BUFFER_CAPACITY) == 0 {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                let (ours, theirs) = if ours_readable { (read, write) } else { (write, read) };\n+                let ours = Handle::from_raw_handle(ours);\n+                let theirs = Handle::from_raw_handle(theirs);\n+\n+                if their_handle_inheritable {\n+                    theirs.set_inheritable()?;\n+                }\n+\n+                Ok(Pipes { ours: AnonPipe::Sync(ours), theirs: AnonPipe::Sync(theirs) })\n+            }\n+        }\n+    }\n+}\n \n /// Although this looks similar to `anon_pipe` in the Unix module it's actually\n /// subtly different. Here we'll return two pipes in the `Pipes` return value,\n@@ -53,9 +89,6 @@ pub struct Pipes {\n /// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n /// once at a time (which we do indeed guarantee).\n pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {\n-    // A 64kb pipe capacity is the same as a typical Linux default.\n-    const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n-\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n     // operations. Instead, we create a \"hopefully unique\" name and create a\n@@ -156,12 +189,9 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n         };\n         opts.security_attributes(&mut sa);\n         let theirs = File::open(Path::new(&name), &opts)?;\n-        let theirs = AnonPipe { inner: theirs.into_inner() };\n+        let theirs = AnonPipe::Sync(theirs.into_inner());\n \n-        Ok(Pipes {\n-            ours: AnonPipe { inner: ours },\n-            theirs: AnonPipe { inner: theirs.into_inner() },\n-        })\n+        Ok(Pipes { ours: AnonPipe::Async(ours), theirs })\n     }\n }\n \n@@ -171,12 +201,12 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n /// This is achieved by creating a new set of pipes and spawning a thread that\n /// relays messages between the source and the synchronous pipe.\n pub fn spawn_pipe_relay(\n-    source: &AnonPipe,\n+    source: &Handle,\n     ours_readable: bool,\n     their_handle_inheritable: bool,\n ) -> io::Result<AnonPipe> {\n     // We need this handle to live for the lifetime of the thread spawned below.\n-    let source = source.duplicate()?;\n+    let source = AnonPipe::Async(source.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?);\n \n     // create a new pair of anon pipes.\n     let Pipes { theirs, ours } = anon_pipe(ours_readable, their_handle_inheritable)?;\n@@ -227,19 +257,24 @@ type AlertableIoFn = unsafe extern \"system\" fn(\n \n impl AnonPipe {\n     pub fn handle(&self) -> &Handle {\n-        &self.inner\n+        match self {\n+            Self::Async(ref handle) => handle,\n+            Self::Sync(ref handle) => handle,\n+        }\n     }\n     pub fn into_handle(self) -> Handle {\n-        self.inner\n-    }\n-    fn duplicate(&self) -> io::Result<Self> {\n-        self.inner.duplicate(0, false, c::DUPLICATE_SAME_ACCESS).map(|inner| AnonPipe { inner })\n+        self.into_inner()\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let result = unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n+            match self {\n+                Self::Sync(ref handle) => handle.read(buf),\n+                Self::Async(_) => {\n+                    self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n+                }\n+            }\n         };\n \n         match result {\n@@ -253,28 +288,33 @@ impl AnonPipe {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.inner.read_vectored(bufs)\n+        io::default_read_vectored(|buf| self.read(buf), bufs)\n     }\n \n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        self.inner.is_read_vectored()\n+        false\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n+            match self {\n+                Self::Sync(ref handle) => handle.write(buf),\n+                Self::Async(_) => {\n+                    self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n+                }\n+            }\n         }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.inner.write_vectored(bufs)\n+        io::default_write_vectored(|buf| self.write(buf), bufs)\n     }\n \n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        self.inner.is_write_vectored()\n+        false\n     }\n \n     /// Synchronizes asynchronous reads or writes using our anonymous pipe.\n@@ -346,7 +386,7 @@ impl AnonPipe {\n \n         // Asynchronous read of the pipe.\n         // If successful, `callback` will be called once it completes.\n-        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n+        let result = io(self.handle().as_handle(), buf, len, &mut overlapped, callback);\n         if result == c::FALSE {\n             // We can return here because the call failed.\n             // After this we must not return until the I/O completes."}, {"sha": "cc29d1a72fbf416cbed51c007e396b7002f55813", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7fbe8434be481607ae199fe2aee976ee2fc2e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=ddb7fbe8434be481607ae199fe2aee976ee2fc2e", "patch": "@@ -24,7 +24,7 @@ use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n use crate::sys::path;\n-use crate::sys::pipe::{self, AnonPipe};\n+use crate::sys::pipe::{self, AnonPipe, Pipes};\n use crate::sys::stdio;\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n@@ -173,7 +173,7 @@ pub enum Stdio {\n     Inherit,\n     Null,\n     MakePipe,\n-    Pipe(AnonPipe),\n+    AsyncPipe(Handle),\n     Handle(Handle),\n }\n \n@@ -527,13 +527,33 @@ impl Stdio {\n             },\n \n             Stdio::MakePipe => {\n-                let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n-                let pipes = pipe::anon_pipe(ours_readable, true)?;\n+                // Handles that are passed to a child process must be synchronous\n+                // because they will be read synchronously (see #95759).\n+                // Therefore we prefer to make both ends of a pipe synchronous\n+                // just in case our end of the pipe is passed to another process.\n+                //\n+                // However, we may need to read from both the child's stdout and\n+                // stderr simultaneously when waiting for output. This requires\n+                // async reads so as to avoid blocking either pipe.\n+                //\n+                // The solution used here is to make handles synchronous\n+                // except for our side of the stdout and sterr pipes.\n+                // If our side of those pipes do end up being given to another\n+                // process then we use a \"pipe relay\" to synchronize access\n+                // (see `Stdio::AsyncPipe` below).\n+                let pipes = if stdio_id == c::STD_INPUT_HANDLE {\n+                    // For stdin both sides of the pipe are synchronous.\n+                    Pipes::new_synchronous(false, true)?\n+                } else {\n+                    // For stdout/stderr our side of the pipe is async and their side is synchronous.\n+                    pipe::anon_pipe(true, true)?\n+                };\n                 *pipe = Some(pipes.ours);\n                 Ok(pipes.theirs.into_handle())\n             }\n \n-            Stdio::Pipe(ref source) => {\n+            Stdio::AsyncPipe(ref source) => {\n+                // We need to synchronize asynchronous pipes by using a pipe relay.\n                 let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n                 pipe::spawn_pipe_relay(source, ours_readable, true).map(AnonPipe::into_handle)\n             }\n@@ -562,7 +582,13 @@ impl Stdio {\n \n impl From<AnonPipe> for Stdio {\n     fn from(pipe: AnonPipe) -> Stdio {\n-        Stdio::Pipe(pipe)\n+        // Note that it's very important we don't give async handles to child processes.\n+        // Therefore if the pipe is asynchronous we must have a way to turn it synchronous.\n+        // See #95759.\n+        match pipe {\n+            AnonPipe::Sync(handle) => Stdio::Handle(handle),\n+            AnonPipe::Async(handle) => Stdio::AsyncPipe(handle),\n+        }\n     }\n }\n "}]}