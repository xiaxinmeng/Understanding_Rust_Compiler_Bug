{"sha": "af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMmZkMWQ1M2VlMjAxM2E4ZmViY2VmMGIwNjQ3MzlkMWVkN2Q3NmU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-24T19:15:45Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-24T19:15:45Z"}, "message": "rustbook support", "tree": {"sha": "ee9760c416f7d21878204830227a575870fc13fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee9760c416f7d21878204830227a575870fc13fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "html_url": "https://github.com/rust-lang/rust/commit/af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "328737216147b6107d6d28a405e3fd9cd1ded317", "url": "https://api.github.com/repos/rust-lang/rust/commits/328737216147b6107d6d28a405e3fd9cd1ded317", "html_url": "https://github.com/rust-lang/rust/commit/328737216147b6107d6d28a405e3fd9cd1ded317"}], "stats": {"total": 943, "additions": 672, "deletions": 271}, "files": [{"sha": "5627227744ae5b2ffb83e632cb32b237428c8962", "filename": "FiraSans-Medium.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/FiraSans-Medium.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/FiraSans-Medium.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/FiraSans-Medium.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "9ff40445bf4a6f459c4ba7399555ba89bbf39181", "filename": "FiraSans-Regular.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/FiraSans-Regular.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/FiraSans-Regular.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/FiraSans-Regular.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "b0cebf01de49b61c0f1ec5cb47f2687c64e918c2", "filename": "Heuristica-Italic.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/Heuristica-Italic.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/Heuristica-Italic.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Heuristica-Italic.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "19fd3f232d3e7ea93a7a1a61a27f559cd648d7da", "filename": "README.md", "status": "modified", "additions": 253, "deletions": 2, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "patch": "@@ -1,3 +1,254 @@\n-# The Unsafe Rust Programming Language (Book)\n+% The Unsafe Rust Programming Language\n+\n+**This document is about advanced functionality and low-level development practices\n+in the Rust Programming Language. Most of the things discussed won't matter\n+to the average Rust programmer. However if you wish to correctly write unsafe\n+code in Rust, this text contains invaluable information.**\n+\n+This document seeks to complement [The Rust Programming Language Book][trpl] (TRPL).\n+Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n+the specification of the language, and all the nasty bits necessary to write\n+Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n+the basics of the language and systems programming. We will not explain the\n+stack or heap, we will not explain the syntax.\n+\n+\n+# A Tale Of Two Languages\n+\n+Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust.\n+Any time someone opines the guarantees of Rust, they are almost surely talking about\n+Safe Rust. However Safe Rust is not sufficient to write every program. For that,\n+we need the Unsafe Rust superset.\n+\n+Most fundamentally, writing bindings to other languages\n+(such as the C exposed by your operating system) is never going to be safe. Rust\n+can't control what other languages do to program execution! However Unsafe Rust is\n+also necessary to construct fundamental abstractions where the type system is not\n+sufficient to automatically prove what you're doing is sound.\n+\n+Indeed, the Rust standard library is implemented in Rust, and it makes substantial\n+use of Unsafe Rust for implementing IO, memory allocation, collections,\n+synchronization, and other low-level computational primitives.\n+\n+Upon hearing this, many wonder why they would not simply just use C or C++ in place of\n+Rust (or just use a \"real\" safe language). If we're going to do unsafe things, why not\n+lean on these much more established languages?\n+\n+The most important difference between C++ and Rust is a matter of defaults:\n+Rust is 100% safe by default. Even when you *opt out* of safety in Rust, it is a modular\n+action. In deciding to work with unchecked uninitialized memory, this does not\n+suddenly make dangling or null pointers a problem. When using unchecked indexing on `x`,\n+one does not have to suddenly worry about indexing out of bounds on `y`.\n+C and C++, by contrast, have pervasive unsafety baked into the language. Even the\n+modern best practices like `unique_ptr` have various safety pitfalls.\n+\n+It should also be noted that writing Unsafe Rust should be regarded as an exceptional\n+action. Unsafe Rust is often the domain of *fundamental libraries*. Anything that needs\n+to make FFI bindings or define core abstractions. These fundamental libraries then expose\n+a *safe* interface for intermediate libraries and applications to build upon. And these\n+safe interfaces make an important promise: if your application segfaults, it's not your\n+fault. *They* have a bug.\n+\n+And really, how is that different from *any* safe language? Python, Ruby, and Java libraries\n+can internally do all sorts of nasty things. The languages themselves are no\n+different. Safe languages regularly have bugs that cause critical vulnerabilities.\n+The fact that Rust is written with a healthy spoonful of Unsafe Rust is no different.\n+However it *does* mean that Rust doesn't need to fall back to the pervasive unsafety of\n+C to do the nasty things that need to get done.\n+\n+\n+\n+\n+# What does `unsafe` mean?\n+\n+Rust tries to model memory safety through the `unsafe` keyword. Interestingly,\n+the meaning of `unsafe` largely revolves around what\n+its *absence* means. If the `unsafe` keyword is absent from a program, it should\n+not be possible to violate memory safety under *any* conditions. The presence\n+of `unsafe` means that there are conditions under which this code *could*\n+violate memory safety.\n+\n+To be more concrete, Rust cares about preventing the following things:\n+\n+* Dereferencing null/dangling pointers\n+* Reading uninitialized memory\n+* Breaking the pointer aliasing rules (TBD) (llvm rules + noalias on &mut and & w/o UnsafeCell)\n+* Invoking Undefined Behaviour (in e.g. compiler intrinsics)\n+* Producing invalid primitive values:\n+    * dangling/null references\n+    * a `bool` that isn't 0 or 1\n+    * an undefined `enum` discriminant\n+    * a `char` larger than char::MAX\n+    * A non-utf8 `str`\n+* Unwinding into an FFI function\n+* Causing a data race\n+\n+That's it. That's all the Undefined Behaviour in Rust. Libraries are free to\n+declare arbitrary requirements if they could transitively cause memory safety\n+issues, but it all boils down to the above actions. Rust is otherwise\n+quite permisive with respect to other dubious operations. Rust considers it\n+\"safe\" to:\n+\n+* Deadlock\n+* Leak memory\n+* Fail to call destructors\n+* Access private fields\n+* Overflow integers\n+* Delete the production database\n+\n+However any program that does such a thing is *probably* incorrect. Rust just isn't\n+interested in modeling these problems, as they are much harder to prevent in general,\n+and it's literally impossible to prevent incorrect programs from getting written.\n+\n+There are several places `unsafe` can appear in Rust today, which can largely be\n+grouped into two categories:\n+\n+* There are unchecked contracts here. To declare you understand this, I require\n+you to write `unsafe` elsewhere:\n+    * On functions, `unsafe` is declaring the function to be unsafe to call. Users\n+      of the function must check the documentation to determine what this means,\n+      and then have to write `unsafe` somewhere to identify that they're aware of\n+    the danger.\n+    * On trait declarations, `unsafe` is declaring that *implementing* the trait\n+      is an unsafe operation, as it has contracts that other unsafe code is free to\n+      trust blindly.\n+\n+* I am declaring that I have, to the best of my knowledge, adhered to the\n+unchecked contracts:\n+    * On trait implementations, `unsafe` is declaring that the contract of the\n+      `unsafe` trait has been upheld.\n+    * On blocks, `unsafe` is declaring any unsafety from an unsafe\n+      operation within to be handled, and therefore the parent function is safe.\n+\n+There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n+historical reasons and is in the process of being phased out. See the section on\n+destructors for details.\n+\n+Some examples of unsafe functions:\n+\n+* `slice::get_unchecked` will perform unchecked indexing, allowing memory\n+  safety to be freely violated.\n+* `ptr::offset` in an intrinsic that invokes Undefined Behaviour if it is\n+  not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n+* `mem::transmute` reinterprets some value as having the given type,\n+  bypassing type safety in arbitrary ways. (see the conversions section for details)\n+* All FFI functions are `unsafe` because they can do arbitrary things.\n+  C being an obvious culprit, but generally any language can do something\n+  that Rust isn't happy about. (see the FFI section for details)\n+\n+As of Rust 1.0 there are exactly two unsafe traits:\n+\n+* `Send` is a marker trait (it has no actual API) that promises implementors\n+  are safe to send to another thread.\n+* `Sync` is a marker trait that promises that threads can safely share\n+  implementors through a shared reference.\n+\n+All other traits that declare any kind of contract *really* can't be trusted\n+to adhere to their contract when memory-safety is at stake. For instance Rust has\n+`PartialOrd` and `Ord` to differentiate between types which can \"just\" be\n+compared and those that implement a total ordering. However you can't actually\n+trust an implementor of `Ord` to actually provide a total ordering if failing to\n+do so causes you to e.g. index out of bounds. But if it just makes your program\n+do a stupid thing, then it's \"fine\" to rely on `Ord`.\n+\n+The reason this is the case is that `Ord` is safe to implement, and it should be\n+impossible for bad *safe* code to violate memory safety. Rust has traditionally\n+avoided making traits unsafe because it makes `unsafe` pervasive in the language,\n+which is not desirable. The only reason `Send` and `Sync` are unsafe is because\n+thread safety is a sort of fundamental thing that a program can't really guard\n+against locally (even by-value message passing still requires a notion Send).\n+\n+\n+\n+\n+# Working with unsafe\n+\n+Rust generally only gives us the tools to talk about safety in a scoped and\n+binary manner. Unfortunately reality is significantly more complicated than that.\n+For instance, consider the following toy function:\n+\n+```rust\n+fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n+    if idx < arr.len() {\n+        unsafe {\n+            Some(*arr.get_unchecked(idx))\n+        }\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+Clearly, this function is safe. We check that the index is in bounds, and if it\n+is, index into the array in an unchecked manner. But even in such a trivial\n+function, the scope of the unsafe block is questionable. Consider changing the\n+`<` to a `<=`:\n+\n+```rust\n+fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n+    if idx <= arr.len() {\n+        unsafe {\n+            Some(*arr.get_unchecked(idx))\n+        }\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+This program is now unsound, an yet *we only modified safe code*. This is the\n+fundamental problem of safety: it's non-local. The soundness of our unsafe\n+operations necessarily depends on the state established by \"safe\" operations.\n+Although safety *is* modular (we *still* don't need to worry about about\n+unrelated safety issues like uninitialized memory), it quickly contaminates the\n+surrounding code.\n+\n+Trickier than that is when we get into actual statefulness. Consider a simple\n+implementation of `Vec`:\n+\n+```rust\n+// Note this defintion is insufficient. See the section on lifetimes.\n+struct Vec<T> {\n+    ptr: *mut T,\n+    len: usize,\n+    cap: usize,\n+}\n+\n+// Note this implementation does not correctly handle zero-sized types.\n+// We currently live in a nice imaginary world of only positive fixed-size\n+// types.\n+impl<T> Vec<T> {\n+    fn push(&mut self, elem: T) {\n+        if self.len == self.cap {\n+            // not important for this example\n+            self.reallocate();\n+        }\n+        unsafe {\n+            ptr::write(self.ptr.offset(len as isize), elem);\n+            self.len += 1;\n+        }\n+    }\n+}\n+```\n+\n+This code is simple enough to reasonably audit and verify. Now consider\n+adding the following method:\n+\n+```rust\n+    fn make_room(&mut self) {\n+        // grow the capacity\n+        self.cap += 1;\n+    }\n+```\n+\n+This code is safe, but it is also completely unsound. Changing the capacity\n+violates the invariants of Vec (that `cap` reflects the allocated space in the\n+Vec). This is not something the rest of `Vec` can guard against. It *has* to\n+trust the capacity field because there's no way to verify it.\n+\n+`unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n+Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n+module boundary with privacy.\n+\n+[trpl]: https://doc.rust-lang.org/book/\n \n-[Start at the intro](http://www.cglab.ca/~abeinges/blah/turpl/intro.html)\n\\ No newline at end of file"}, {"sha": "d136ebcebd4e80f934c17b3c18febf6ccaeeee30", "filename": "SUMMARY.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SUMMARY.md?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "patch": "@@ -0,0 +1,9 @@\n+# Summary\n+\n+* [Data Layout](data.md)\n+* [Ownership and Lifetimes](lifetimes.md)\n+* [Conversions](conversions.md)\n+* [Uninitialized Memory](uninitialized.md)\n+* [Ownership-oriented resource management (RAII)](raii.md)\n+* [Concurrency](concurrency.md)\n+* [Example: Implementing Vec](vec.md)\n\\ No newline at end of file"}, {"sha": "5576670903aea90041f214624c8dd1176fdf6081", "filename": "SourceCodePro-Regular.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceCodePro-Regular.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceCodePro-Regular.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SourceCodePro-Regular.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "ca972a11dc428209dd66212e382b884f168e83f7", "filename": "SourceCodePro-Semibold.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceCodePro-Semibold.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceCodePro-Semibold.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SourceCodePro-Semibold.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "ac1b1b3a0bb7a673d52495743d8f86fd55188b44", "filename": "SourceSerifPro-Bold.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceSerifPro-Bold.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceSerifPro-Bold.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SourceSerifPro-Bold.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "e8c43b852e10e1556268d6c17b47bd0644d6edec", "filename": "SourceSerifPro-Regular.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceSerifPro-Regular.woff", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/SourceSerifPro-Regular.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SourceSerifPro-Regular.woff?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e"}, {"sha": "939ba4fa21294204573cbb4c1fef11646220c28a", "filename": "intro.md", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/328737216147b6107d6d28a405e3fd9cd1ded317/intro.md", "raw_url": "https://github.com/rust-lang/rust/raw/328737216147b6107d6d28a405e3fd9cd1ded317/intro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/intro.md?ref=328737216147b6107d6d28a405e3fd9cd1ded317", "patch": "@@ -1,267 +0,0 @@\n-% The Unsafe Rust Programming Language\n-\n-**This document is about advanced functionality and low-level development practices\n-in the Rust Programming Language. Most of the things discussed won't matter\n-to the average Rust programmer. However if you wish to correctly write unsafe\n-code in Rust, this text contains invaluable information.**\n-\n-This document seeks to complement [The Rust Programming Language Book][] (TRPL).\n-Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n-the specification of the language, and all the nasty bits necessary to write\n-Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n-the basics of the language and systems programming. We will not explain the\n-stack or heap, we will not explain the syntax.\n-\n-\n-\n-\n-# Chapters\n-\n-* [Data Layout](data.html)\n-* [Ownership and Lifetimes](lifetimes.html)\n-* [Conversions](conversions.html)\n-* [Uninitialized Memory](uninitialized.html)\n-* [Ownership-oriented resource management (RAII)](raii.html)\n-* [Concurrency](concurrency.html)\n-* [Example: Implementing Vec](vec.html)\n-\n-\n-\n-\n-# A Tale Of Two Languages\n-\n-Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust.\n-Any time someone opines the guarantees of Rust, they are almost surely talking about\n-Safe Rust. However Safe Rust is not sufficient to write every program. For that,\n-we need the Unsafe Rust superset.\n-\n-Most fundamentally, writing bindings to other languages\n-(such as the C exposed by your operating system) is never going to be safe. Rust\n-can't control what other languages do to program execution! However Unsafe Rust is\n-also necessary to construct fundamental abstractions where the type system is not\n-sufficient to automatically prove what you're doing is sound.\n-\n-Indeed, the Rust standard library is implemented in Rust, and it makes substantial\n-use of Unsafe Rust for implementing IO, memory allocation, collections,\n-synchronization, and other low-level computational primitives.\n-\n-Upon hearing this, many wonder why they would not simply just use C or C++ in place of\n-Rust (or just use a \"real\" safe language). If we're going to do unsafe things, why not\n-lean on these much more established languages?\n-\n-The most important difference between C++ and Rust is a matter of defaults:\n-Rust is 100% safe by default. Even when you *opt out* of safety in Rust, it is a modular\n-action. In deciding to work with unchecked uninitialized memory, this does not\n-suddenly make dangling or null pointers a problem. When using unchecked indexing on `x`,\n-one does not have to suddenly worry about indexing out of bounds on `y`.\n-C and C++, by contrast, have pervasive unsafety baked into the language. Even the\n-modern best practices like `unique_ptr` have various safety pitfalls.\n-\n-It should also be noted that writing Unsafe Rust should be regarded as an exceptional\n-action. Unsafe Rust is often the domain of *fundamental libraries*. Anything that needs\n-to make FFI bindings or define core abstractions. These fundamental libraries then expose\n-a *safe* interface for intermediate libraries and applications to build upon. And these\n-safe interfaces make an important promise: if your application segfaults, it's not your\n-fault. *They* have a bug.\n-\n-And really, how is that different from *any* safe language? Python, Ruby, and Java libraries\n-can internally do all sorts of nasty things. The languages themselves are no\n-different. Safe languages regularly have bugs that cause critical vulnerabilities.\n-The fact that Rust is written with a healthy spoonful of Unsafe Rust is no different.\n-However it *does* mean that Rust doesn't need to fall back to the pervasive unsafety of\n-C to do the nasty things that need to get done.\n-\n-\n-\n-\n-# What does `unsafe` mean?\n-\n-Rust tries to model memory safety through the `unsafe` keyword. Interestingly,\n-the meaning of `unsafe` largely revolves around what\n-its *absence* means. If the `unsafe` keyword is absent from a program, it should\n-not be possible to violate memory safety under *any* conditions. The presence\n-of `unsafe` means that there are conditions under which this code *could*\n-violate memory safety.\n-\n-To be more concrete, Rust cares about preventing the following things:\n-\n-* Dereferencing null/dangling pointers\n-* Reading uninitialized memory\n-* Breaking the pointer aliasing rules (TBD) (llvm rules + noalias on &mut and & w/o UnsafeCell)\n-* Invoking Undefined Behaviour (in e.g. compiler intrinsics)\n-* Producing invalid primitive values:\n-    * dangling/null references\n-    * a `bool` that isn't 0 or 1\n-    * an undefined `enum` discriminant\n-    * a `char` larger than char::MAX\n-    * A non-utf8 `str`\n-* Unwinding into an FFI function\n-* Causing a data race\n-\n-That's it. That's all the Undefined Behaviour in Rust. Libraries are free to\n-declare arbitrary requirements if they could transitively cause memory safety\n-issues, but it all boils down to the above actions. Rust is otherwise\n-quite permisive with respect to other dubious operations. Rust considers it\n-\"safe\" to:\n-\n-* Deadlock\n-* Leak memory\n-* Fail to call destructors\n-* Access private fields\n-* Overflow integers\n-* Delete the production database\n-\n-However any program that does such a thing is *probably* incorrect. Rust just isn't\n-interested in modeling these problems, as they are much harder to prevent in general,\n-and it's literally impossible to prevent incorrect programs from getting written.\n-\n-There are several places `unsafe` can appear in Rust today, which can largely be\n-grouped into two categories:\n-\n-* There are unchecked contracts here. To declare you understand this, I require\n-you to write `unsafe` elsewhere:\n-    * On functions, `unsafe` is declaring the function to be unsafe to call. Users\n-      of the function must check the documentation to determine what this means,\n-      and then have to write `unsafe` somewhere to identify that they're aware of\n-    the danger.\n-    * On trait declarations, `unsafe` is declaring that *implementing* the trait\n-      is an unsafe operation, as it has contracts that other unsafe code is free to\n-      trust blindly.\n-\n-* I am declaring that I have, to the best of my knowledge, adhered to the\n-unchecked contracts:\n-    * On trait implementations, `unsafe` is declaring that the contract of the\n-      `unsafe` trait has been upheld.\n-    * On blocks, `unsafe` is declaring any unsafety from an unsafe\n-      operation within to be handled, and therefore the parent function is safe.\n-\n-There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n-historical reasons and is in the process of being phased out. See the section on\n-destructors for details.\n-\n-Some examples of unsafe functions:\n-\n-* `slice::get_unchecked` will perform unchecked indexing, allowing memory\n-  safety to be freely violated.\n-* `ptr::offset` in an intrinsic that invokes Undefined Behaviour if it is\n-  not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n-* `mem::transmute` reinterprets some value as having the given type,\n-  bypassing type safety in arbitrary ways. (see the conversions section for details)\n-* All FFI functions are `unsafe` because they can do arbitrary things.\n-  C being an obvious culprit, but generally any language can do something\n-  that Rust isn't happy about. (see the FFI section for details)\n-\n-As of Rust 1.0 there are exactly two unsafe traits:\n-\n-* `Send` is a marker trait (it has no actual API) that promises implementors\n-  are safe to send to another thread.\n-* `Sync` is a marker trait that promises that threads can safely share\n-  implementors through a shared reference.\n-\n-All other traits that declare any kind of contract *really* can't be trusted\n-to adhere to their contract when memory-safety is at stake. For instance Rust has\n-`PartialOrd` and `Ord` to differentiate between types which can \"just\" be\n-compared and those that implement a total ordering. However you can't actually\n-trust an implementor of `Ord` to actually provide a total ordering if failing to\n-do so causes you to e.g. index out of bounds. But if it just makes your program\n-do a stupid thing, then it's \"fine\" to rely on `Ord`.\n-\n-The reason this is the case is that `Ord` is safe to implement, and it should be\n-impossible for bad *safe* code to violate memory safety. Rust has traditionally\n-avoided making traits unsafe because it makes `unsafe` pervasive in the language,\n-which is not desirable. The only reason `Send` and `Sync` are unsafe is because\n-thread safety is a sort of fundamental thing that a program can't really guard\n-against locally (even by-value message passing still requires a notion Send).\n-\n-\n-\n-\n-# Working with unsafe\n-\n-Rust generally only gives us the tools to talk about safety in a scoped and\n-binary manner. Unfortunately reality is significantly more complicated than that.\n-For instance, consider the following toy function:\n-\n-```rust\n-fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n-    if idx < arr.len() {\n-        unsafe {\n-            Some(*arr.get_unchecked(idx))\n-        }\n-    } else {\n-        None\n-    }\n-}\n-```\n-\n-Clearly, this function is safe. We check that the index is in bounds, and if it\n-is, index into the array in an unchecked manner. But even in such a trivial\n-function, the scope of the unsafe block is questionable. Consider changing the\n-`<` to a `<=`:\n-\n-```rust\n-fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n-    if idx <= arr.len() {\n-        unsafe {\n-            Some(*arr.get_unchecked(idx))\n-        }\n-    } else {\n-        None\n-    }\n-}\n-```\n-\n-This program is now unsound, an yet *we only modified safe code*. This is the\n-fundamental problem of safety: it's non-local. The soundness of our unsafe\n-operations necessarily depends on the state established by \"safe\" operations.\n-Although safety *is* modular (we *still* don't need to worry about about\n-unrelated safety issues like uninitialized memory), it quickly contaminates the\n-surrounding code.\n-\n-Trickier than that is when we get into actual statefulness. Consider a simple\n-implementation of `Vec`:\n-\n-```rust\n-// Note this defintion is insufficient. See the section on lifetimes.\n-struct Vec<T> {\n-    ptr: *mut T,\n-    len: usize,\n-    cap: usize,\n-}\n-\n-// Note this implementation does not correctly handle zero-sized types.\n-// We currently live in a nice imaginary world of only positive fixed-size\n-// types.\n-impl<T> Vec<T> {\n-    fn push(&mut self, elem: T) {\n-        if self.len == self.cap {\n-            // not important for this example\n-            self.reallocate();\n-        }\n-        unsafe {\n-            ptr::write(self.ptr.offset(len as isize), elem);\n-            self.len += 1;\n-        }\n-    }\n-}\n-```\n-\n-This code is simple enough to reasonably audit and verify. Now consider\n-adding the following method:\n-\n-```rust\n-    fn make_room(&mut self) {\n-        // grow the capacity\n-        self.cap += 1;\n-    }\n-```\n-\n-This code is safe, but it is also completely unsound. Changing the capacity\n-violates the invariants of Vec (that `cap` reflects the allocated space in the\n-Vec). This is not something the rest of `Vec` can guard against. It *has* to\n-trust the capacity field because there's no way to verify it.\n-\n-`unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n-Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n-module boundary with privacy.\n-"}, {"sha": "cd158283180a268381a35370837bd968f7753ed8", "filename": "rust.css", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/rust.css", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/rust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust.css?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "patch": "@@ -0,0 +1,407 @@\n+/**\n+ * Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+ * file at the top-level directory of this distribution and at\n+ * http://rust-lang.org/COPYRIGHT.\n+ * With elements taken from Bootstrap v3.0.2 (MIT licensed).\n+ *\n+ * Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+ * http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+ * <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+ * option. This file may not be copied, modified, or distributed\n+ * except according to those terms.\n+ */\n+@font-face {\n+    font-family: 'Fira Sans';\n+    font-style: normal;\n+    font-weight: 400;\n+    src: local('Fira Sans'), url(\"FiraSans-Regular.woff\") format('woff');\n+}\n+@font-face {\n+    font-family: 'Fira Sans';\n+    font-style: normal;\n+    font-weight: 500;\n+    src: local('Fira Sans Medium'), url(\"FiraSans-Medium.woff\") format('woff');\n+}\n+@font-face {\n+    font-family: 'Source Serif Pro';\n+    font-style: normal;\n+    font-weight: 400;\n+    src: local('Source Serif Pro'), url(\"SourceSerifPro-Regular.woff\") format('woff');\n+}\n+@font-face {\n+    font-family: 'Source Serif Pro';\n+    font-style: italic;\n+    font-weight: 400;\n+    src: url(\"Heuristica-Italic.woff\") format('woff');\n+}\n+@font-face {\n+    font-family: 'Source Serif Pro';\n+    font-style: normal;\n+    font-weight: 700;\n+    src: local('Source Serif Pro Bold'), url(\"SourceSerifPro-Bold.woff\") format('woff');\n+}\n+@font-face {\n+    font-family: 'Source Code Pro';\n+    font-style: normal;\n+    font-weight: 400;\n+    src: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+}\n+\n+*:not(body) {\n+  -webkit-box-sizing: border-box;\n+     -moz-box-sizing: border-box;\n+          box-sizing: border-box;\n+}\n+\n+/* General structure */\n+\n+body {\n+    background-color: white;\n+    margin: 0 auto;\n+    padding: 0 15px;\n+    font-family: \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;\n+    font-size: 18px;\n+    color: #333;\n+    line-height: 1.428571429;\n+\n+    -webkit-font-feature-settings: \"kern\", \"liga\";\n+    -moz-font-feature-settings: \"kern\", \"liga\";\n+    font-feature-settings: \"kern\", \"liga\";\n+}\n+@media (min-width: 768px) {\n+    body {\n+        max-width: 750px;\n+    }\n+}\n+\n+h1, h2, h3, h4, h5, h6, nav, #versioninfo {\n+    font-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+}\n+h1, h2, h3, h4, h5, h6 {\n+    color: black;\n+    font-weight: 400;\n+    line-height: 1.1;\n+}\n+h1, h2, h3 {\n+    margin-top: 20px;\n+    margin-bottom: 15px;\n+}\n+h1 {\n+    margin-bottom: 20px;\n+}\n+h4, h5, h6 {\n+    margin-top: 12px;\n+    margin-bottom: 10px;\n+    padding: 5px 10px;\n+}\n+h5, h6 {\n+    text-decoration: underline;\n+}\n+\n+h1 {\n+    font-size: 28px;\n+    font-weight: 500;\n+    padding: .1em .4em;\n+    border-bottom: 2px solid #ddd;\n+}\n+h1.title {\n+    line-height: 1.5em;\n+}\n+h2 {\n+    font-size: 26px;\n+    padding: .2em .5em;\n+    border-bottom: 1px solid #ddd;\n+}\n+h3 {\n+    font-size: 24px;\n+    padding: .2em .7em;\n+    border-bottom: 1px solid #DDE8FC;\n+}\n+h4 {\n+    font-size: 22px;\n+}\n+h5 {\n+    font-size: 20px;\n+}\n+h6 {\n+    font-size: 18px;\n+}\n+@media (min-width: 992px) {\n+    h1 {\n+        font-size: 36px;\n+    }\n+    h2 {\n+        font-size: 30px;\n+    }\n+    h3 {\n+        font-size: 26px;\n+    }\n+}\n+\n+nav {\n+    column-count: 2;\n+    -moz-column-count: 2;\n+    -webkit-column-count: 2;\n+    font-size: 15px;\n+    margin: 0 0 1em 0;\n+}\n+p {\n+    margin: 0 0 1em 0;\n+}\n+\n+strong {\n+    font-weight: bold;\n+}\n+\n+em {\n+    font-style: italic;\n+}\n+\n+footer {\n+    border-top: 1px solid #ddd;\n+    font-size: 14.3px;\n+    font-style: italic;\n+    padding-top: 5px;\n+    margin-top: 3em;\n+    margin-bottom: 1em;\n+}\n+\n+/* Links layout */\n+\n+a {\n+    text-decoration: none;\n+    color: #428BCA;\n+    background: transparent;\n+}\n+a:hover, a:focus {\n+    color: #2A6496;\n+    text-decoration: underline;\n+}\n+a:focus {\n+    outline: thin dotted #333;\n+    outline: 5px auto -webkit-focus-ring-color;\n+    outline-offset: -2px;\n+}\n+a:hover, a:active {\n+    outline: 0;\n+}\n+\n+h1 a:link, h1 a:visited, h2 a:link, h2 a:visited,\n+h3 a:link, h3 a:visited, h4 a:link, h4 a:visited,\n+h5 a:link, h5 a:visited {color: black;}\n+h1 a:hover, h2 a:hover, h3 a:hover, h4 a:hover,\n+h5 a:hover {text-decoration: none;}\n+\n+/* Code */\n+\n+pre, code {\n+    font-family: \"Source Code Pro\", Menlo, Monaco, Consolas, \"DejaVu Sans Mono\", monospace;\n+    word-wrap: break-word;\n+}\n+pre {\n+    border-left: 2px solid #eee;\n+    white-space: pre-wrap;\n+    padding: 14px;\n+    padding-right: 0;\n+    margin: 20px 0;\n+    font-size: 13px;\n+    word-break: break-all;\n+}\n+code {\n+    padding: 0 2px;\n+    color: #8D1A38;\n+}\n+pre code {\n+    padding: 0;\n+    font-size: inherit;\n+    color: inherit;\n+}\n+\n+a > code {\n+    color: #428BCA;\n+}\n+\n+/* Code highlighting */\n+pre.rust .kw { color: #8959A8; }\n+pre.rust .kw-2, pre.rust .prelude-ty { color: #4271AE; }\n+pre.rust .number, pre.rust .string { color: #718C00; }\n+pre.rust .self, pre.rust .boolval, pre.rust .prelude-val,\n+pre.rust .attribute, pre.rust .attribute .ident { color: #C82829; }\n+pre.rust .comment { color: #8E908C; }\n+pre.rust .doccomment { color: #4D4D4C; }\n+pre.rust .macro, pre.rust .macro-nonterminal { color: #3E999F; }\n+pre.rust .lifetime { color: #B76514; }\n+\n+/* The rest */\n+\n+#versioninfo {\n+    text-align: center;\n+    margin: 0.5em;\n+    font-size: 1.1em;\n+}\n+@media (min-width: 992px) {\n+    #versioninfo {\n+        font-size: 0.8em;\n+        position: fixed;\n+        bottom: 0px;\n+        right: 0px;\n+    }\n+    .white-sticker {\n+        background-color: #fff;\n+        margin: 2px;\n+        padding: 0 2px;\n+        border-radius: .2em;\n+    }\n+}\n+#versioninfo a.hash {\n+    color: gray;\n+    font-size: 80%;\n+}\n+\n+blockquote {\n+    color: #000;\n+    margin: 20px 0;\n+    padding: 15px 20px;\n+    background-color: #f2f7f9;\n+    border-top: .1em solid #e5eef2;\n+    border-bottom: .1em solid #e5eef2;\n+}\n+blockquote p {\n+    font-size: 17px;\n+    font-weight: 300;\n+    line-height: 1.4;\n+}\n+blockquote p:last-child {\n+    margin-bottom: 0;\n+}\n+\n+ul, ol {\n+    padding-left: 25px;\n+}\n+ul ul, ol ul, ul ol, ol ol {\n+    margin-bottom: 0;\n+}\n+dl {\n+    margin-bottom: 20px;\n+}\n+dd {\n+    margin-left: 0;\n+}\n+\n+nav ul {\n+    list-style-type: none;\n+    margin: 0;\n+    padding-left: 0px;\n+}\n+\n+/* Only display one level of hierarchy in the TOC */\n+nav ul ul {\n+    display: none;\n+}\n+\n+sub,\n+sup {\n+    font-size: 75%;\n+    line-height: 0;\n+    position: relative;\n+}\n+\n+hr {\n+    margin-top: 20px;\n+    margin-bottom: 20px;\n+    border: 0;\n+    border-top: 1px solid #eeeeee;\n+}\n+\n+table {\n+    border-collapse: collapse;\n+    border-spacing: 0;\n+    overflow-x: auto;\n+    display: block;\n+}\n+\n+table tr.odd {\n+    background: #eee;\n+}\n+\n+table td,\n+table th {\n+    border: 1px solid #ddd;\n+    padding: 5px;\n+}\n+\n+/* Code snippets */\n+\n+.rusttest { display: none; }\n+pre.rust { position: relative; }\n+.test-arrow {\n+    display: inline-block;\n+    position: absolute;\n+    top: 0;\n+    right: 10px;\n+    font-size: 150%;\n+    -webkit-transform: scaleX(-1);\n+    transform: scaleX(-1);\n+}\n+\n+.unstable-feature {\n+    border: 2px solid red;\n+    padding: 5px;\n+}\n+\n+@media (min-width: 1170px) {\n+    pre {\n+        font-size: 15px;\n+    }\n+}\n+\n+@media print {\n+    * {\n+        text-shadow: none !important;\n+        color: #000 !important;\n+        background: transparent !important;\n+        box-shadow: none !important;\n+    }\n+    a, a:visited {\n+        text-decoration: underline;\n+    }\n+    p a[href]:after {\n+        content: \" (\" attr(href) \")\";\n+    }\n+    footer a[href]:after {\n+        content: \"\";\n+    }\n+    a[href^=\"javascript:\"]:after, a[href^=\"#\"]:after {\n+        content: \"\";\n+    }\n+    pre, blockquote {\n+        border: 1px solid #999;\n+        page-break-inside: avoid;\n+    }\n+    @page {\n+        margin: 2cm .5cm;\n+    }\n+    h1:not(.title), h2, h3 {\n+        border-bottom: 0px none;\n+    }\n+    p, h2, h3 {\n+        orphans: 3;\n+        widows: 3;\n+    }\n+    h2, h3 {\n+        page-break-after: avoid;\n+    }\n+    table {\n+        border-collapse: collapse !important;\n+    }\n+    table td, table th {\n+        background-color: #fff !important;\n+    }\n+}\n+\n+#keyword-table-marker + table thead { display: none; }\n+#keyword-table-marker + table td { border: none; }\n+#keyword-table-marker + table {\n+    margin-left: 2em;\n+    margin-bottom: 1em;\n+}"}, {"sha": "71b950b12215a071af3a80cb59cd1c971f4b9061", "filename": "vec.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/vec.md", "raw_url": "https://github.com/rust-lang/rust/raw/af2fd1d53ee2013a8febcef0b064739d1ed7d76e/vec.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/vec.md?ref=af2fd1d53ee2013a8febcef0b064739d1ed7d76e", "patch": "@@ -11,7 +11,7 @@ project will only work on nightly (as of Rust 1.2.0).\n First off, we need to come up with the struct layout. Naively we want this\n design:\n \n-```\n+```rust\n struct Vec<T> {\n     ptr: *mut T,\n     cap: usize,\n@@ -30,7 +30,7 @@ As we saw in the lifetimes chapter, we should use `Unique<T>` in place of `*mut\n when we have a raw pointer to an allocation we own:\n \n \n-```\n+```rust\n #![feature(unique)]\n \n use std::ptr::{Unique, self};\n@@ -474,6 +474,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n         }\n     }\n }\n+```\n \n Because IntoIter takes ownership of its allocation, it needs to implement Drop\n to free it. However it *also* wants to implement Drop to drop any elements it"}]}