{"sha": "825f8edc2fff167304d40c826f136e82967d68f3", "node_id": "C_kwDOAAsO6NoAKDgyNWY4ZWRjMmZmZjE2NzMwNGQ0MGM4MjZmMTM2ZTgyOTY3ZDY4ZjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T05:22:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T05:22:17Z"}, "message": "Auto merge of #103530 - cjgillot:hir-lifetimes-direct, r=estebank\n\nResolve lifetimes independently for each item-like.\n\nNow that the heavy-lifting is done on the AST and during lowering, we do not need to perform HIR lifetime resolution on a full item at once.  Instead, we can treat each item-like independently, and look at `generics_of` the parent exceptionally for associated items.", "tree": {"sha": "b5d53ab8c7a8413ca291535720866e33bd5b4d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5d53ab8c7a8413ca291535720866e33bd5b4d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/825f8edc2fff167304d40c826f136e82967d68f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/825f8edc2fff167304d40c826f136e82967d68f3", "html_url": "https://github.com/rust-lang/rust/commit/825f8edc2fff167304d40c826f136e82967d68f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/825f8edc2fff167304d40c826f136e82967d68f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0c6527912cee113b29a33d7db0e801a58a94de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c6527912cee113b29a33d7db0e801a58a94de5", "html_url": "https://github.com/rust-lang/rust/commit/b0c6527912cee113b29a33d7db0e801a58a94de5"}, {"sha": "6c95805a34a1a3a9c52a3bea7f680373ee07290c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c95805a34a1a3a9c52a3bea7f680373ee07290c", "html_url": "https://github.com/rust-lang/rust/commit/6c95805a34a1a3a9c52a3bea7f680373ee07290c"}], "stats": {"total": 608, "additions": 224, "deletions": 384}, "files": [{"sha": "837ff0bdf3e35401f38db801d96d286d0b67874a", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -117,7 +117,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n-    let node = tcx.hir().expect_owner(def_id);\n+    let node = tcx.hir().owner(def_id);\n     match node {\n         hir::OwnerNode::Crate(_) => {}\n         hir::OwnerNode::Item(item) => check_item(tcx, item),"}, {"sha": "0e7a5ebf5ab6245e205951a36c1d8765212f3ec3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -644,40 +644,39 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n         }\n \n-        // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-            origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n-            ..\n-        }) => {}\n-\n         // Don't call `type_of` on opaque types, since that depends on type\n         // checking function bodies. `check_item_type` ensures that it's called\n         // instead.\n         hir::ItemKind::OpaqueTy(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n             tcx.ensure().explicit_item_bounds(def_id);\n+            tcx.ensure().item_bounds(def_id);\n         }\n-        hir::ItemKind::TyAlias(..)\n-        | hir::ItemKind::Static(..)\n-        | hir::ItemKind::Const(..)\n-        | hir::ItemKind::Fn(..) => {\n+\n+        hir::ItemKind::TyAlias(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            match it.kind {\n-                hir::ItemKind::Fn(..) => tcx.ensure().fn_sig(def_id),\n-                hir::ItemKind::OpaqueTy(..) => tcx.ensure().item_bounds(def_id),\n-                hir::ItemKind::Const(ty, ..) | hir::ItemKind::Static(ty, ..) => {\n-                    if !is_suggestable_infer_ty(ty) {\n-                        let mut visitor = HirPlaceholderCollector::default();\n-                        visitor.visit_item(it);\n-                        placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n-                    }\n-                }\n-                _ => (),\n+        }\n+\n+        hir::ItemKind::Static(ty, ..) | hir::ItemKind::Const(ty, ..) => {\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n+            if !is_suggestable_infer_ty(ty) {\n+                let mut visitor = HirPlaceholderCollector::default();\n+                visitor.visit_item(it);\n+                placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n             }\n         }\n+\n+        hir::ItemKind::Fn(..) => {\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n+            tcx.ensure().fn_sig(def_id);\n+        }\n     }\n }\n "}, {"sha": "6ee7aa9cdac6b8ebc65b56a45732131aedc85768", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 103, "deletions": 216, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -94,11 +94,6 @@ struct LifetimeContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n-\n-    /// Indicates that we only care about the definition of a trait. This should\n-    /// be false if the `Item` we are resolving lifetimes for is not a trait or\n-    /// we eventually need lifetimes resolve for trait items.\n-    trait_definition_only: bool,\n }\n \n #[derive(Debug)]\n@@ -166,7 +161,9 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    Root,\n+    Root {\n+        opt_parent_item: Option<LocalDefId>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -214,95 +211,58 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n-            Scope::Root => f.debug_struct(\"Root\").finish(),\n+            Scope::Root { opt_parent_item } => {\n+                f.debug_struct(\"Root\").field(\"opt_parent_item\", &opt_parent_item).finish()\n+            }\n         }\n     }\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;\n \n-const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n-\n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes_trait_definition,\n         resolve_lifetimes,\n \n-        named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n+        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Like `resolve_lifetimes`, but does not resolve lifetimes for trait items.\n-/// Also does not generate any diagnostics.\n-///\n-/// This is ultimately a subset of the `resolve_lifetimes` work. It effectively\n-/// resolves lifetimes only within the trait \"header\" -- that is, the trait\n-/// and supertrait list. In contrast, `resolve_lifetimes` resolves all the\n-/// lifetimes within the trait and its items. There is room to refactor this,\n-/// for example to resolve lifetimes for each trait item in separate queries,\n-/// but it's convenient to do the entire trait at once because the lifetimes\n-/// from the trait definition are in scope within the trait items as well.\n-///\n-/// The reason for this separate call is to resolve what would otherwise\n-/// be a cycle. Consider this example:\n-///\n-/// ```ignore UNSOLVED (maybe @jackh726 knows what lifetime parameter to give Sub)\n-/// trait Base<'a> {\n-///     type BaseItem;\n-/// }\n-/// trait Sub<'b>: for<'a> Base<'a> {\n-///    type SubItem: Sub<BaseItem = &'b u32>;\n-/// }\n-/// ```\n-///\n-/// When we resolve `Sub` and all its items, we also have to resolve `Sub<BaseItem = &'b u32>`.\n-/// To figure out the index of `'b`, we have to know about the supertraits\n-/// of `Sub` so that we can determine that the `for<'a>` will be in scope.\n-/// (This is because we -- currently at least -- flatten all the late-bound\n-/// lifetimes into a single binder.) This requires us to resolve the\n-/// *trait definition* of `Sub`; basically just enough lifetime information\n-/// to look at the supertraits.\n-#[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes_trait_definition(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, true))\n-}\n-\n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, false))\n-}\n-\n-fn do_resolve(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-    trait_definition_only: bool,\n-) -> NamedRegionMap {\n-    let item = tcx.hir().expect_item(local_def_id);\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n     let mut named_region_map =\n         NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n-        scope: ROOT_SCOPE,\n-        trait_definition_only,\n+        scope: &Scope::Root { opt_parent_item: None },\n     };\n-    visitor.visit_item(item);\n-\n-    named_region_map\n-}\n+    match tcx.hir().owner(local_def_id) {\n+        hir::OwnerNode::Item(item) => visitor.visit_item(item),\n+        hir::OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n+        hir::OwnerNode::TraitItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_trait_item(item)\n+        }\n+        hir::OwnerNode::ImplItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_impl_item(item)\n+        }\n+        hir::OwnerNode::Crate(_) => {}\n+    }\n \n-fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n@@ -319,53 +279,6 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n     rl\n }\n \n-/// Given `any` owner (structs, traits, trait methods, etc.), does lifetime resolution.\n-/// There are two important things this does.\n-/// First, we have to resolve lifetimes for\n-/// the entire *`Item`* that contains this owner, because that's the largest \"scope\"\n-/// where we can have relevant lifetimes.\n-/// Second, if we are asking for lifetimes in a trait *definition*, we use `resolve_lifetimes_trait_definition`\n-/// instead of `resolve_lifetimes`, which does not descend into the trait items and does not emit diagnostics.\n-/// This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner\n-/// other than the trait itself (like the trait methods or associated types), then we just use the regular\n-/// `resolve_lifetimes`.\n-fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n-    let item_id = item_for(tcx, def_id.def_id);\n-    let local_def_id = item_id.owner_id.def_id;\n-    if item_id.owner_id == def_id {\n-        let item = tcx.hir().item(item_id);\n-        match item.kind {\n-            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n-            _ => tcx.resolve_lifetimes(local_def_id),\n-        }\n-    } else {\n-        tcx.resolve_lifetimes(local_def_id)\n-    }\n-}\n-\n-/// Finds the `Item` that contains the given `LocalDefId`\n-fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> hir::ItemId {\n-    match tcx.hir().find_by_def_id(local_def_id) {\n-        Some(Node::Item(item)) => {\n-            return item.item_id();\n-        }\n-        _ => {}\n-    }\n-    let item = {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-        let mut parent_iter = tcx.hir().parent_iter(hir_id);\n-        loop {\n-            let node = parent_iter.next().map(|n| n.1);\n-            match node {\n-                Some(hir::Node::Item(item)) => break item.item_id(),\n-                Some(hir::Node::Crate(_)) | None => bug!(\"Called `item_for` on an Item.\"),\n-                _ => {}\n-            }\n-        }\n-    };\n-    item\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -383,7 +296,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut supertrait_lifetimes = vec![];\n         loop {\n             match scope {\n-                Scope::Body { .. } | Scope::Root => {\n+                Scope::Body { .. } | Scope::Root { .. } => {\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n@@ -414,21 +327,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n+    type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n         self.tcx.hir()\n     }\n \n-    // We want to nest trait/impl items in their parent, but nothing else.\n-    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n-\n-    fn visit_trait_item_ref(&mut self, ii: &'tcx hir::TraitItemRef) {\n-        if !self.trait_definition_only {\n-            intravisit::walk_trait_item_ref(self, ii)\n-        }\n-    }\n-\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let body = self.tcx.hir().body(body);\n         self.with(Scope::Body { id: body.id(), s: self.scope }, |this| {\n@@ -548,7 +452,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item)\n                 });\n             }\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::TyAlias, ..\n+            }) => {\n                 // Opaque types are visited when we visit the\n                 // `TyKind::OpaqueDef`, so that they have the lifetimes from\n                 // their parent opaque_ty in scope.\n@@ -557,34 +463,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in self.tcx.hir().parent_iter(item.owner_id.into()) {\n-                    match node {\n-                        hir::Node::Item(parent_item) => {\n-                            let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n-                                item_for(self.tcx, parent_item.owner_id.def_id).owner_id.def_id,\n-                            );\n-                            // We need to add *all* deps, since opaque tys may want them from *us*\n-                            for (&owner, defs) in resolved_lifetimes.defs.iter() {\n-                                defs.iter().for_each(|(&local_id, region)| {\n-                                    self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n-                                });\n-                            }\n-                            for (&owner, late_bound_vars) in\n-                                resolved_lifetimes.late_bound_vars.iter()\n-                            {\n-                                late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n-                                    self.record_late_bound_vars(\n-                                        hir::HirId { owner, local_id },\n-                                        late_bound_vars.clone(),\n-                                    );\n-                                });\n-                            }\n-                            break;\n+                let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n+                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                // We need to add *all* deps, since opaque tys may want them from *us*\n+                for (&owner, defs) in resolved_lifetimes.defs.iter() {\n+                    defs.iter().for_each(|(&local_id, region)| {\n+                        self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n+                    });\n+                }\n+                for (&owner, late_bound_vars) in resolved_lifetimes.late_bound_vars.iter() {\n+                    late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n+                        self.record_late_bound_vars(\n+                            hir::HirId { owner, local_id },\n+                            late_bound_vars.clone(),\n+                        );\n+                    });\n+                }\n+            }\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                generics,\n+                ..\n+            }) => {\n+                // We want to start our early-bound indices at the end of the parent scope,\n+                // not including any parent `impl Trait`s.\n+                let mut lifetimes = FxIndexMap::default();\n+                debug!(?generics.params);\n+                for param in generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n+                            lifetimes.insert(def_id, reg);\n                         }\n-                        hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n-                        _ => {}\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n+\n+                let scope = Scope::Binder {\n+                    hir_id: item.hir_id(),\n+                    lifetimes,\n+                    s: self.scope,\n+                    scope_type: BinderScopeType::Normal,\n+                    where_bound_origin: None,\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |this| intravisit::walk_item(this, item))\n+                });\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n@@ -609,7 +534,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n                     scope_type: BinderScopeType::Normal,\n-                    s: ROOT_SCOPE,\n+                    s: self.scope,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -712,7 +637,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n                 let opaque_ty = self.tcx.hir().item(item_id);\n-                let (generics, bounds) = match opaque_ty.kind {\n+                match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::TyAlias,\n                         ..\n@@ -733,10 +658,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n-                        ref generics,\n-                        bounds,\n                         ..\n-                    }) => (generics, bounds),\n+                    }) => {}\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n@@ -766,65 +689,28 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // Ensure that the parent of the def is an item, not HRTB\n                     let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                     if !parent_id.is_owner() {\n-                        if !self.trait_definition_only {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                lifetime.span,\n-                                E0657,\n-                                \"`impl Trait` can only capture lifetimes \\\n-                                    bound at the fn or impl level\"\n-                            )\n-                            .emit();\n-                        }\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            lifetime.span,\n+                            E0657,\n+                            \"`impl Trait` can only capture lifetimes bound at the fn or impl level\"\n+                        )\n+                        .emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                     if let hir::Node::Item(hir::Item {\n                         kind: hir::ItemKind::OpaqueTy { .. }, ..\n                     }) = self.tcx.hir().get(parent_id)\n                     {\n-                        if !self.trait_definition_only {\n-                            let mut err = self.tcx.sess.struct_span_err(\n-                                lifetime.span,\n-                                \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n-                            );\n-                            err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n-                            err.emit();\n-                        }\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            lifetime.span,\n+                            \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n+                        );\n+                        err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n+                        err.emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                 }\n-\n-                // We want to start our early-bound indices at the end of the parent scope,\n-                // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n-                debug!(?generics.params);\n-                for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n-                            lifetimes.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n-                }\n-                self.record_late_bound_vars(ty.hir_id, vec![]);\n-\n-                let scope = Scope::Binder {\n-                    hir_id: ty.hir_id,\n-                    lifetimes,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n-                self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| {\n-                        this.visit_generics(generics);\n-                        for bound in bounds {\n-                            this.visit_param_bound(bound);\n-                        }\n-                    })\n-                });\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }\n@@ -1193,12 +1079,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext {\n-            tcx: *tcx,\n-            map,\n-            scope: &wrap_scope,\n-            trait_definition_only: self.trait_definition_only,\n-        };\n+        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1303,7 +1184,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root => {\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                    {\n+                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                    }\n                     break None;\n                 }\n \n@@ -1417,7 +1304,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     err.emit();\n                     return;\n                 }\n-                Scope::Root => break,\n+                Scope::Root { .. } => break,\n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n@@ -1495,7 +1382,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let mut scope = self.scope;\n                 loop {\n                     match *scope {\n-                        Scope::Root => break false,\n+                        Scope::Root { .. } => break false,\n \n                         Scope::Body { .. } => break true,\n \n@@ -1732,7 +1619,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n "}, {"sha": "efae2669006347a639c77c7243dddf9453d09e6c", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -163,7 +163,7 @@ fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLe\n         // Otherwise, we need to visit the attributes in source code order, so we fetch HIR and do\n         // a standard visit.\n         // FIXME(#102522) Just iterate on attrs once that iteration order matches HIR's.\n-        _ => match tcx.hir().expect_owner(owner) {\n+        _ => match tcx.hir().owner(owner) {\n             hir::OwnerNode::Item(item) => levels.visit_item(item),\n             hir::OwnerNode::ForeignItem(item) => levels.visit_foreign_item(item),\n             hir::OwnerNode::TraitItem(item) => levels.visit_trait_item(item),"}, {"sha": "14f50ae87de0639fc4c58f88dfbc5c89c6ec9e21", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -353,6 +353,10 @@ impl<'hir> Map<'hir> {\n         node.node.generics()\n     }\n \n+    pub fn owner(self, id: OwnerId) -> OwnerNode<'hir> {\n+        self.tcx.hir_owner(id).unwrap_or_else(|| bug!(\"expected owner for {:?}\", id)).node\n+    }\n+\n     pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n         self.tcx.hir_owner(id.owner_id).unwrap().node.expect_item()\n     }\n@@ -822,8 +826,11 @@ impl<'hir> Map<'hir> {\n         )\n     }\n \n-    pub fn expect_owner(self, id: OwnerId) -> OwnerNode<'hir> {\n-        self.tcx.hir_owner(id).unwrap_or_else(|| bug!(\"expected owner for {:?}\", id)).node\n+    pub fn expect_owner(self, def_id: LocalDefId) -> OwnerNode<'hir> {\n+        self.tcx\n+            .hir_owner(OwnerId { def_id })\n+            .unwrap_or_else(|| bug!(\"expected owner for {:?}\", def_id))\n+            .node\n     }\n \n     pub fn expect_item(self, id: LocalDefId) -> &'hir Item<'hir> {"}, {"sha": "1564cf414bd251bda3ccd4f26b815986b8aa8141", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -1614,19 +1614,10 @@ rustc_queries! {\n         desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }\n \n-    /// Does lifetime resolution, but does not descend into trait items. This\n-    /// should only be used for resolving lifetimes of on trait definitions,\n-    /// and is used to avoid cycles. Importantly, `resolve_lifetimes` still visits\n-    /// the same lifetimes and is responsible for diagnostics.\n-    /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes_trait_definition(_: LocalDefId) -> ResolveLifetimes {\n-        arena_cache\n-        desc { \"resolving lifetimes for a trait definition\" }\n-    }\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n+    query resolve_lifetimes(_: hir::OwnerId) -> ResolveLifetimes {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }"}, {"sha": "f67410986e5590c6e3556c9765296f7977032f31", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -132,12 +132,15 @@ where\n }\n \n fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> {\n+    //~^ ERROR the value of the associated type `Item` (from trait `Iterator`) is already specified [E0719]\n     iter::empty()\n }\n fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> {\n+    //~^ ERROR the value of the associated type `Item` (from trait `Iterator`) is already specified [E0719]\n     iter::empty()\n }\n fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> {\n+    //~^ ERROR the value of the associated type `Item` (from trait `Iterator`) is already specified [E0719]\n     iter::empty()\n }\n fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}"}, {"sha": "c3061327f566e2410ca53b4904d24bcc3fc4225a", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -191,293 +191,317 @@ LL |     T: Iterator<Item: 'static, Item: 'static>,\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:143:40\n+  --> $DIR/duplicate.rs:134:42\n+   |\n+LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> {\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n+  --> $DIR/duplicate.rs:138:42\n+   |\n+LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> {\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n+  --> $DIR/duplicate.rs:142:45\n+   |\n+LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> {\n+   |                              -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n+  --> $DIR/duplicate.rs:146:40\n    |\n LL | fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:145:40\n+  --> $DIR/duplicate.rs:148:40\n    |\n LL | fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:147:43\n+  --> $DIR/duplicate.rs:150:43\n    |\n LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:150:35\n+  --> $DIR/duplicate.rs:153:35\n    |\n LL | type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:152:35\n+  --> $DIR/duplicate.rs:155:35\n    |\n LL | type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:154:38\n+  --> $DIR/duplicate.rs:157:38\n    |\n LL | type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:158:29\n+  --> $DIR/duplicate.rs:161:29\n    |\n LL |     T: Iterator<Item: Copy, Item: Send>,\n    |                 ----------  ^^^^^^^^^^ re-bound here\n    |                 |\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:163:29\n+  --> $DIR/duplicate.rs:166:29\n    |\n LL |     T: Iterator<Item: Copy, Item: Copy>,\n    |                 ----------  ^^^^^^^^^^ re-bound here\n    |                 |\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:168:32\n+  --> $DIR/duplicate.rs:171:32\n    |\n LL |     T: Iterator<Item: 'static, Item: 'static>,\n    |                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                 |\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:172:36\n+  --> $DIR/duplicate.rs:175:36\n    |\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:174:36\n+  --> $DIR/duplicate.rs:177:36\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:176:39\n+  --> $DIR/duplicate.rs:179:39\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:178:40\n+  --> $DIR/duplicate.rs:181:40\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:180:40\n+  --> $DIR/duplicate.rs:183:40\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:182:43\n+  --> $DIR/duplicate.rs:185:43\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:185:36\n+  --> $DIR/duplicate.rs:188:36\n    |\n LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:187:36\n+  --> $DIR/duplicate.rs:190:36\n    |\n LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:189:39\n+  --> $DIR/duplicate.rs:192:39\n    |\n LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:191:34\n+  --> $DIR/duplicate.rs:194:34\n    |\n LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:193:34\n+  --> $DIR/duplicate.rs:196:34\n    |\n LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:195:37\n+  --> $DIR/duplicate.rs:198:37\n    |\n LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:199:29\n+  --> $DIR/duplicate.rs:202:29\n    |\n LL |     T: Iterator<Item: Copy, Item: Send>,\n    |                 ----------  ^^^^^^^^^^ re-bound here\n    |                 |\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:205:29\n+  --> $DIR/duplicate.rs:208:29\n    |\n LL |     T: Iterator<Item: Copy, Item: Copy>,\n    |                 ----------  ^^^^^^^^^^ re-bound here\n    |                 |\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:211:32\n+  --> $DIR/duplicate.rs:214:32\n    |\n LL |     T: Iterator<Item: 'static, Item: 'static>,\n    |                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                 |\n    |                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:217:32\n+  --> $DIR/duplicate.rs:220:32\n    |\n LL |     Self: Iterator<Item: Copy, Item: Send>,\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:217:32\n+  --> $DIR/duplicate.rs:220:32\n    |\n LL |     Self: Iterator<Item: Copy, Item: Send>,\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:224:32\n+  --> $DIR/duplicate.rs:227:32\n    |\n LL |     Self: Iterator<Item: Copy, Item: Copy>,\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:224:32\n+  --> $DIR/duplicate.rs:227:32\n    |\n LL |     Self: Iterator<Item: Copy, Item: Copy>,\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:231:35\n+  --> $DIR/duplicate.rs:234:35\n    |\n LL |     Self: Iterator<Item: 'static, Item: 'static>,\n    |                    -------------  ^^^^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:231:35\n+  --> $DIR/duplicate.rs:234:35\n    |\n LL |     Self: Iterator<Item: 'static, Item: 'static>,\n    |                    -------------  ^^^^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:249:40\n+  --> $DIR/duplicate.rs:252:40\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:251:44\n+  --> $DIR/duplicate.rs:254:44\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:253:43\n+  --> $DIR/duplicate.rs:256:43\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:237:34\n+  --> $DIR/duplicate.rs:240:34\n    |\n LL |     type A: Iterator<Item: Copy, Item: Send>;\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:241:34\n+  --> $DIR/duplicate.rs:244:34\n    |\n LL |     type A: Iterator<Item: Copy, Item: Copy>;\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:245:37\n+  --> $DIR/duplicate.rs:248:37\n    |\n LL |     type A: Iterator<Item: 'static, Item: 'static>;\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error: aborting due to 60 previous errors\n+error: aborting due to 63 previous errors\n \n For more information about this error, try `rustc --explain E0719`."}, {"sha": "df2ca025705d3955fae6c9b1a0d7333e29f39684", "filename": "src/test/ui/async-await/issues/issue-65159.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -6,7 +6,6 @@ async fn copy() -> Result<()>\n //~^ ERROR this enum takes 2 generic arguments\n {\n     Ok(())\n-    //~^ ERROR type annotations needed\n }\n \n fn main() { }"}, {"sha": "45f5ec40cd758b08f914aabdce72e0d85bd7996f", "filename": "src/test/ui/async-await/issues/issue-65159.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -16,18 +16,6 @@ help: add missing generic argument\n LL | async fn copy() -> Result<(), E>\n    |                             +++\n \n-error[E0282]: type annotations needed\n-  --> $DIR/issue-65159.rs:8:5\n-   |\n-LL |     Ok(())\n-   |     ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n-   |\n-help: consider specifying the generic arguments\n-   |\n-LL |     Ok::<(), E>(())\n-   |       +++++++++\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0107, E0282.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "dd0320bc53ba7d79d1151e7b34ea1ba3e85d845a", "filename": "src/test/ui/borrowck/issue-82126-mismatched-subst-and-hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -17,7 +17,6 @@ async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_> {\n     //~^ ERROR this struct takes 0 lifetime arguments but 1 lifetime argument was supplied\n     //~^^ ERROR this struct takes 1 generic argument but 0 generic arguments were supplied\n     LockedMarket(generator.lock().unwrap().buy())\n-    //~^ ERROR cannot return value referencing temporary\n }\n \n struct LockedMarket<T>(T);"}, {"sha": "d2b927fb664c66b1958dbdfd914b771b95b1d2d1", "filename": "src/test/ui/borrowck/issue-82126-mismatched-subst-and-hir.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.stderr?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -7,7 +7,7 @@ LL | async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_>\n    |                                                           expected 0 lifetime arguments\n    |\n note: struct defined here, with 0 lifetime parameters\n-  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:23:8\n+  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:22:8\n    |\n LL | struct LockedMarket<T>(T);\n    |        ^^^^^^^^^^^^\n@@ -19,7 +19,7 @@ LL | async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_>\n    |                                                           ^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: struct defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:23:8\n+  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:22:8\n    |\n LL | struct LockedMarket<T>(T);\n    |        ^^^^^^^^^^^^ -\n@@ -28,16 +28,6 @@ help: add missing generic argument\n LL | async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_, T> {\n    |                                                                          +++\n \n-error[E0515]: cannot return value referencing temporary value\n-  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:19:5\n-   |\n-LL |     LockedMarket(generator.lock().unwrap().buy())\n-   |     ^^^^^^^^^^^^^-------------------------^^^^^^^\n-   |     |            |\n-   |     |            temporary value created here\n-   |     returns a value referencing data owned by the current function\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0107, E0515.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "7fb69032e6fc48b2e4cd6fc8a3accde632b753ef", "filename": "src/test/ui/const-generics/min_const_generics/macro-fail.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -14,7 +14,6 @@ impl<const N: usize> Marker<N> for Example<N> {}\n fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n   //~^ ERROR: type provided when a constant was expected\n   Example::<gimme_a_const!(marker)>\n-  //~^ ERROR: type provided when a constant was expected\n }\n \n fn from_marker(_: impl Marker<{\n@@ -34,9 +33,7 @@ fn main() {\n   }>;\n \n   let _fail = Example::<external_macro!()>;\n-  //~^ ERROR: type provided when a constant was expected\n \n   let _fail = Example::<gimme_a_const!()>;\n-  //~^ ERROR: type provided when a constant was expected\n-  //~| ERROR unexpected end of macro invocation\n+  //~^ ERROR unexpected end of macro invocation\n }"}, {"sha": "2b75c19774842c410714d6ee14752aa0cf2023de", "filename": "src/test/ui/const-generics/min_const_generics/macro-fail.stderr", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.stderr?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -1,5 +1,5 @@\n error: expected type, found `{`\n-  --> $DIR/macro-fail.rs:29:27\n+  --> $DIR/macro-fail.rs:28:27\n    |\n LL | fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n    |                                 ----------------------\n@@ -13,7 +13,7 @@ LL |       ($rusty: ident) => {{ let $rusty = 3; *&$rusty }}\n    = note: this error originates in the macro `gimme_a_const` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected type, found `{`\n-  --> $DIR/macro-fail.rs:29:27\n+  --> $DIR/macro-fail.rs:28:27\n    |\n LL |   Example::<gimme_a_const!(marker)>\n    |             ----------------------\n@@ -46,7 +46,7 @@ LL |     let _fail = Example::<external_macro!()>;\n    = note: this error originates in the macro `external_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-fail.rs:39:25\n+  --> $DIR/macro-fail.rs:37:25\n    |\n LL |     macro_rules! gimme_a_const {\n    |     -------------------------- when calling this macro\n@@ -60,24 +60,6 @@ error[E0747]: type provided when a constant was expected\n LL | fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0747]: type provided when a constant was expected\n-  --> $DIR/macro-fail.rs:16:13\n-   |\n-LL |   Example::<gimme_a_const!(marker)>\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0747]: type provided when a constant was expected\n-  --> $DIR/macro-fail.rs:36:25\n-   |\n-LL |   let _fail = Example::<external_macro!()>;\n-   |                         ^^^^^^^^^^^^^^^^^\n-\n-error[E0747]: type provided when a constant was expected\n-  --> $DIR/macro-fail.rs:39:25\n-   |\n-LL |   let _fail = Example::<gimme_a_const!()>;\n-   |                         ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0747`."}, {"sha": "30fbba168689be02fd3588d9646ce5772e6ddaa2", "filename": "src/test/ui/impl-trait/generic-with-implicit-hrtb-without-dyn.edition2021.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fgeneric-with-implicit-hrtb-without-dyn.edition2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fgeneric-with-implicit-hrtb-without-dyn.edition2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fgeneric-with-implicit-hrtb-without-dyn.edition2021.stderr?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -9,13 +9,6 @@ help: add `dyn` keyword before this trait\n LL | fn ice() -> impl AsRef<dyn Fn(&())> {\n    |                        +++\n \n-error[E0277]: the trait bound `(): AsRef<(dyn for<'a> Fn(&'a ()) + 'static)>` is not satisfied\n-  --> $DIR/generic-with-implicit-hrtb-without-dyn.rs:6:13\n-   |\n-LL | fn ice() -> impl AsRef<Fn(&())> {\n-   |             ^^^^^^^^^^^^^^^^^^^ the trait `AsRef<(dyn for<'a> Fn(&'a ()) + 'static)>` is not implemented for `()`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0277, E0782.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0782`."}, {"sha": "bed81c4bca76e1cea701a48f00320655638d7772", "filename": "src/test/ui/impl-trait/generic-with-implicit-hrtb-without-dyn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fgeneric-with-implicit-hrtb-without-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fgeneric-with-implicit-hrtb-without-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fgeneric-with-implicit-hrtb-without-dyn.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -4,8 +4,8 @@\n #![allow(warnings)]\n \n fn ice() -> impl AsRef<Fn(&())> {\n-    //~^ ERROR: the trait bound `(): AsRef<(dyn for<'a> Fn(&'a ()) + 'static)>` is not satisfied [E0277]\n-    //[edition2021]~| ERROR: trait objects must include the `dyn` keyword [E0782]\n+    //[edition2015]~^ ERROR: the trait bound `(): AsRef<(dyn for<'a> Fn(&'a ()) + 'static)>` is not satisfied [E0277]\n+    //[edition2021]~^^ ERROR: trait objects must include the `dyn` keyword [E0782]\n     todo!()\n }\n "}, {"sha": "61303a5b2cb4a80379be44f06477414e50716e26", "filename": "src/test/ui/impl-trait/impl-fn-parsing-ambiguities.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-fn-parsing-ambiguities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-fn-parsing-ambiguities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-fn-parsing-ambiguities.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -3,7 +3,7 @@ use std::fmt::Debug;\n \n fn a() -> impl Fn(&u8) -> impl Debug + '_ {\n     //~^ ERROR ambiguous `+` in a type\n-    //~^^ ERROR higher kinded lifetime bounds on nested opaque types are not supported yet\n+    //~| ERROR higher kinded lifetime bounds on nested opaque types are not supported yet\n     |x| x\n }\n "}, {"sha": "4a89238d07e605de576d761c77569cb5b6bbbc45", "filename": "src/test/ui/impl-trait/issues/issue-92305.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -4,11 +4,10 @@ use std::iter;\n \n fn f<T>(data: &[T]) -> impl Iterator<Item = Vec> {\n     //~^ ERROR: missing generics for struct `Vec` [E0107]\n-    iter::empty() //~ ERROR: type annotations needed [E0282]\n+    iter::empty()\n }\n \n fn g<T>(data: &[T], target: T) -> impl Iterator<Item = Vec<T>> {\n-    //~^ ERROR: type annotations needed [E0282]\n     f(data).filter(|x| x == target)\n }\n "}, {"sha": "34d5c2d61dc41148c07043a0c698f8b8352b7550", "filename": "src/test/ui/impl-trait/issues/issue-92305.stderr", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -14,24 +14,6 @@ help: add missing generic argument\n LL | fn f<T>(data: &[T]) -> impl Iterator<Item = Vec<T>> {\n    |                                             ~~~~~~\n \n-error[E0282]: type annotations needed\n-  --> $DIR/issue-92305.rs:7:5\n-   |\n-LL |     iter::empty()\n-   |     ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `empty`\n-   |\n-help: consider specifying the generic argument\n-   |\n-LL |     iter::empty::<T>()\n-   |                +++++\n-\n-error[E0282]: type annotations needed\n-  --> $DIR/issue-92305.rs:10:35\n-   |\n-LL | fn g<T>(data: &[T], target: T) -> impl Iterator<Item = Vec<T>> {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0107, E0282.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "a5db10d3a220c663cc2ed93423f238d9dfd39260", "filename": "src/test/ui/impl-trait/nested-rpit-hrtb.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-rpit-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825f8edc2fff167304d40c826f136e82967d68f3/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-rpit-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-rpit-hrtb.rs?ref=825f8edc2fff167304d40c826f136e82967d68f3", "patch": "@@ -35,26 +35,26 @@ fn one_hrtb_outlives_uses() -> impl for<'a> Bar<'a, Assoc = impl Sized + 'a> {}\n fn one_hrtb_trait_param_uses() -> impl for<'a> Bar<'a, Assoc = impl Qux<'a>> {}\n //~^ ERROR higher kinded lifetime bounds on nested opaque types are not supported yet\n \n-// This should pass.\n+// This should resolve.\n fn one_hrtb_mention_fn_trait_param<'b>() -> impl for<'a> Foo<'a, Assoc = impl Qux<'b>> {}\n \n-// This should pass.\n+// This should resolve.\n fn one_hrtb_mention_fn_outlives<'b>() -> impl for<'a> Foo<'a, Assoc = impl Sized + 'b> {}\n \n-// This should pass.\n+// This should resolve.\n fn one_hrtb_mention_fn_trait_param_uses<'b>() -> impl for<'a> Bar<'a, Assoc = impl Qux<'b>> {}\n \n-// This should pass.\n+// This should resolve.\n fn one_hrtb_mention_fn_outlives_uses<'b>() -> impl for<'a> Bar<'a, Assoc = impl Sized + 'b> {}\n \n-// This should pass.\n+// This should resolve.\n fn two_htrb_trait_param() -> impl for<'a> Foo<'a, Assoc = impl for<'b> Qux<'b>> {}\n \n // `'b` is not in scope for the outlives bound.\n fn two_htrb_outlives() -> impl for<'a> Foo<'a, Assoc = impl for<'b> Sized + 'b> {}\n //~^ ERROR use of undeclared lifetime name `'b` [E0261]\n \n-// This should pass.\n+// This should resolve.\n fn two_htrb_trait_param_uses() -> impl for<'a> Bar<'a, Assoc = impl for<'b> Qux<'b>> {}\n \n // `'b` is not in scope for the outlives bound."}]}