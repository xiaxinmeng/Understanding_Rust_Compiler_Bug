{"sha": "b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZjFjODMyZTNjODgzYTJlZjJmNWI0N2E2OGRiNzlmMzNmNWZiMjU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-23T02:31:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-23T02:33:07Z"}, "message": "rustc: Perform explicit type substitution as requested by the programmer", "tree": {"sha": "6dd2833fb72f26b09e5d1659e5deb081d3f7e11e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd2833fb72f26b09e5d1659e5deb081d3f7e11e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25", "html_url": "https://github.com/rust-lang/rust/commit/b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a7271a026248c88ebefff6c5b585245a5151eb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7271a026248c88ebefff6c5b585245a5151eb1", "html_url": "https://github.com/rust-lang/rust/commit/3a7271a026248c88ebefff6c5b585245a5151eb1"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "8f19e3ad4d14c3dcbfa86275094ca1ec90f865f8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b6f1c832e3c883a2ef2f5b47a68db79f33f5fb25", "patch": "@@ -25,6 +25,7 @@ import middle.ty.type_is_scalar;\n import std._str;\n import std._uint;\n import std._vec;\n+import std.map;\n import std.map.hashmap;\n import std.option;\n import std.option.none;\n@@ -78,6 +79,65 @@ fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     ret ty.fold_ty(generalizer, t);\n }\n \n+// Substitutes the user's explicit types for the parameters in a path\n+// expression.\n+fn substitute_ty_params(&@crate_ctxt ccx,\n+                        @ty.t typ,\n+                        vec[@ast.ty] supplied,\n+                        &span sp) -> @ty.t {\n+    state obj ty_substituter(@crate_ctxt ccx,\n+                             @mutable uint i,\n+                             vec[@ast.ty] supplied,\n+                             @hashmap[int,@ty.t] substs) {\n+        fn fold_simple_ty(@ty.t typ) -> @ty.t {\n+            alt (typ.struct) {\n+                case (ty.ty_var(?vid)) {\n+                    alt (substs.find(vid)) {\n+                        case (some[@ty.t](?resolved_ty)) {\n+                            ret resolved_ty;\n+                        }\n+                        case (none[@ty.t]) {\n+                            if (i >= _vec.len[@ast.ty](supplied)) {\n+                                // Just leave it as an unresolved parameter\n+                                // for now. (We will error out later.)\n+                                ret typ;\n+                            }\n+\n+                            auto result = ast_ty_to_ty_crate(ccx,\n+                                                             supplied.(*i));\n+                            *i += 1u;\n+                            substs.insert(vid, result);\n+                            ret result;\n+                        }\n+                    }\n+                }\n+                case (_) { ret typ; }\n+            }\n+        }\n+    }\n+\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+    auto substs = @map.mk_hashmap[int,@ty.t](hasher, eqer);\n+\n+    auto subst_count = @mutable 0u;\n+    auto substituter = ty_substituter(ccx, subst_count, supplied, substs);\n+\n+    auto result = ty.fold_ty(substituter, typ);\n+\n+    auto supplied_len = _vec.len[@ast.ty](supplied);\n+    if ((*subst_count) != supplied_len) {\n+        ccx.sess.span_err(sp, \"expected \" + _uint.to_str(*subst_count, 10u) +\n+                          \" type parameter(s) but found \" +\n+                          _uint.to_str(supplied_len, 10u) + \" parameter(s)\");\n+        fail;\n+    }\n+\n+    ret result;\n+}\n+\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n@@ -1445,6 +1505,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n+            // Substitute type parameters if the user provided some.\n+            if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n+                t = substitute_ty_params(fcx.ccx, t, pth.node.types,\n+                                         expr.span);\n+            }\n+\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_path(pth, defopt,\n                                                       ast.ann_type(t)));"}]}