{"sha": "8fa24bbc5729f356ea372b196f019b7568e17158", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYTI0YmJjNTcyOWYzNTZlYTM3MmIxOTZmMDE5Yjc1NjhlMTcxNTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-01T14:22:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-12T04:32:42Z"}, "message": "generate reborrow constraints at type check time", "tree": {"sha": "6a87c1ef57dfb10a4f3311443bf9d05f3b97d859", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a87c1ef57dfb10a4f3311443bf9d05f3b97d859"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fa24bbc5729f356ea372b196f019b7568e17158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa24bbc5729f356ea372b196f019b7568e17158", "html_url": "https://github.com/rust-lang/rust/commit/8fa24bbc5729f356ea372b196f019b7568e17158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fa24bbc5729f356ea372b196f019b7568e17158/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbb73063472eafeb056cd7d08b5376a703e4d95f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb73063472eafeb056cd7d08b5376a703e4d95f", "html_url": "https://github.com/rust-lang/rust/commit/fbb73063472eafeb056cd7d08b5376a703e4d95f"}], "stats": {"total": 306, "additions": 154, "deletions": 152}, "files": [{"sha": "9dcdf7de31455179a47153055bfd1519b7701670", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 137, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=8fa24bbc5729f356ea372b196f019b7568e17158", "patch": "@@ -13,14 +13,11 @@ use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::type_check::AtLocation;\n-use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::Place::Projection;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n+use rustc::mir::{Local, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n@@ -41,7 +38,6 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         regioncx,\n         location_table,\n         all_facts,\n-        mir,\n     };\n \n     cg.add_region_liveness_constraints_from_type_check(liveness_set_from_typeck);\n@@ -57,7 +53,6 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n-    mir: &'cg Mir<'tcx>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n@@ -184,41 +179,6 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_terminator(block, terminator, location);\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n-\n-        match rvalue {\n-            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                // In some cases, e.g. when borrowing from an unsafe\n-                // place, we don't bother to create a loan, since\n-                // there are no conditions to validate.\n-                if let Some(all_facts) = self.all_facts {\n-                    if let Some(borrow_index) = self.borrow_set.location_map.get(&location) {\n-                        let region_vid = region.to_region_vid();\n-                        all_facts.borrow_region.push((\n-                            region_vid,\n-                            *borrow_index,\n-                            self.location_table.mid_index(location),\n-                        ));\n-                    }\n-                }\n-\n-                // Look for an rvalue like:\n-                //\n-                //     & L\n-                //\n-                // where L is the path that is borrowed. In that case, we have\n-                // to add the reborrow constraints (which don't fall out\n-                // naturally from the type-checker).\n-                self.add_reborrow_constraint(location, region, borrowed_place);\n-            }\n-\n-            _ => {}\n-        }\n-\n-        self.super_rvalue(rvalue, location);\n-    }\n-\n     fn visit_user_assert_ty(\n         &mut self,\n         _c_ty: &CanonicalTy<'tcx>,\n@@ -285,100 +245,4 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                 self.regioncx.add_live_point(vid, location);\n             });\n     }\n-\n-    // Add the reborrow constraint at `location` so that `borrowed_place`\n-    // is valid for `borrow_region`.\n-    fn add_reborrow_constraint(\n-        &mut self,\n-        location: Location,\n-        borrow_region: ty::Region<'tcx>,\n-        borrowed_place: &Place<'tcx>,\n-    ) {\n-        let mut borrowed_place = borrowed_place;\n-\n-        debug!(\n-            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n-            location, borrow_region, borrowed_place\n-        );\n-        while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n-            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n-\n-            match *elem {\n-                ProjectionElem::Deref => {\n-                    let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n-\n-                    debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n-                    match base_ty.sty {\n-                        ty::TyRef(ref_region, _, mutbl) => {\n-                            self.regioncx.add_outlives(\n-                                location.boring(),\n-                                ref_region.to_region_vid(),\n-                                borrow_region.to_region_vid(),\n-                            );\n-\n-                            if let Some(all_facts) = self.all_facts {\n-                                all_facts.outlives.push((\n-                                    ref_region.to_region_vid(),\n-                                    borrow_region.to_region_vid(),\n-                                    self.location_table.mid_index(location),\n-                                ));\n-                            }\n-\n-                            match mutbl {\n-                                hir::Mutability::MutImmutable => {\n-                                    // Immutable reference. We don't need the base\n-                                    // to be valid for the entire lifetime of\n-                                    // the borrow.\n-                                    break;\n-                                }\n-                                hir::Mutability::MutMutable => {\n-                                    // Mutable reference. We *do* need the base\n-                                    // to be valid, because after the base becomes\n-                                    // invalid, someone else can use our mutable deref.\n-\n-                                    // This is in order to make the following function\n-                                    // illegal:\n-                                    // ```\n-                                    // fn unsafe_deref<'a, 'b>(x: &'a &'b mut T) -> &'b mut T {\n-                                    //     &mut *x\n-                                    // }\n-                                    // ```\n-                                    //\n-                                    // As otherwise you could clone `&mut T` using the\n-                                    // following function:\n-                                    // ```\n-                                    // fn bad(x: &mut T) -> (&mut T, &mut T) {\n-                                    //     let my_clone = unsafe_deref(&'a x);\n-                                    //     ENDREGION 'a;\n-                                    //     (my_clone, x)\n-                                    // }\n-                                    // ```\n-                                }\n-                            }\n-                        }\n-                        ty::TyRawPtr(..) => {\n-                            // deref of raw pointer, guaranteed to be valid\n-                            break;\n-                        }\n-                        ty::TyAdt(def, _) if def.is_box() => {\n-                            // deref of `Box`, need the base to be valid - propagate\n-                        }\n-                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n-                    }\n-                }\n-                ProjectionElem::Field(..)\n-                | ProjectionElem::Downcast(..)\n-                | ProjectionElem::Index(..)\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Subslice { .. } => {\n-                    // other field access\n-                }\n-            }\n-\n-            // The \"propagate\" case. We need to check that our base is valid\n-            // for the borrow's lifetime.\n-            borrowed_place = base;\n-        }\n-    }\n }"}, {"sha": "1891cac268c527455d3834300c4815d54c0c9f92", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=8fa24bbc5729f356ea372b196f019b7568e17158", "patch": "@@ -108,6 +108,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         def_id,\n         &universal_regions,\n         location_table,\n+        borrow_set,\n         &liveness,\n         &mut all_facts,\n         flow_inits,"}, {"sha": "8cae1fd2a4f9fbbe9f475882f8c491ec7e6fe44b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8fa24bbc5729f356ea372b196f019b7568e17158", "patch": "@@ -333,17 +333,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.liveness_constraints.add_element(v, element)\n     }\n \n-    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n-    pub(super) fn add_outlives(&mut self, locations: Locations, sup: RegionVid, sub: RegionVid) {\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        self.constraints.push(OutlivesConstraint {\n-            locations,\n-            sup,\n-            sub,\n-            next: None,\n-        })\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any."}, {"sha": "0203349ffab8848b6534326ea9eceaf4a3dc9c44", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 152, "deletions": 4, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa24bbc5729f356ea372b196f019b7568e17158/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8fa24bbc5729f356ea372b196f019b7568e17158", "patch": "@@ -11,14 +11,17 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraint_set::ConstraintSet;\n+use borrow_check::nll::constraint_set::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::GenericKind;\n@@ -103,6 +106,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n     location_table: &LocationTable,\n+    borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n@@ -119,6 +123,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         Some(BorrowCheckContext {\n             universal_regions,\n             location_table,\n+            borrow_set,\n             all_facts,\n         }),\n         &mut |cx| {\n@@ -141,6 +146,7 @@ fn type_check_internal<'gcx, 'tcx>(\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let mut checker = TypeChecker::new(\n         infcx,\n+        mir,\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -592,6 +598,7 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n+    mir: &'a Mir<'tcx>,\n     mir_def_id: DefId,\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -604,6 +611,7 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n     all_facts: &'a mut Option<AllFacts>,\n+    borrow_set: &'a BorrowSet<'tcx>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -704,6 +712,7 @@ impl Locations {\n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -713,6 +722,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         TypeChecker {\n             infcx,\n             last_span: DUMMY_SP,\n+            mir,\n             mir_def_id,\n             param_env,\n             region_bound_pairs,\n@@ -857,8 +867,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::UserAssertTy(ref c_ty, ref local) => {\n                 let local_ty = mir.local_decls()[*local].ty;\n-                let (ty, _) = self\n-                    .infcx\n+                let (ty, _) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(stmt.source_info.span, c_ty);\n                 debug!(\n                     \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n@@ -1400,9 +1409,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 CastKind::Misc => {}\n             },\n \n+            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n+                self.add_reborrow_constraint(location, region, borrowed_place);\n+            }\n+\n             // FIXME: These other cases have to be implemented in future PRs\n             Rvalue::Use(..)\n-            | Rvalue::Ref(..)\n             | Rvalue::Len(..)\n             | Rvalue::BinaryOp(..)\n             | Rvalue::CheckedBinaryOp(..)\n@@ -1457,6 +1469,142 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Add the constraints that arise from a borrow expression `&'a P` at the location `L`.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `location`: the location `L` where the borrow expression occurs\n+    /// - `borrow_region`: the region `'a` associated with the borrow\n+    /// - `borrowed_place`: the place `P` being borrowed\n+    fn add_reborrow_constraint(\n+        &mut self,\n+        location: Location,\n+        borrow_region: ty::Region<'tcx>,\n+        borrowed_place: &Place<'tcx>,\n+    ) {\n+        // These constraints are only meaningful during borrowck:\n+        let BorrowCheckContext {\n+            borrow_set,\n+            location_table,\n+            all_facts,\n+            ..\n+        } = match &mut self.borrowck_context {\n+            Some(borrowck_context) => borrowck_context,\n+            None => return,\n+        };\n+\n+        // In Polonius mode, we also push a `borrow_region` fact\n+        // linking the loan to the region (in some cases, though,\n+        // there is no loan associated with this borrow expression --\n+        // that occurs when we are borrowing an unsafe place, for\n+        // example).\n+        if let Some(all_facts) = all_facts {\n+            if let Some(borrow_index) = borrow_set.location_map.get(&location) {\n+                let region_vid = borrow_region.to_region_vid();\n+                all_facts.borrow_region.push((\n+                    region_vid,\n+                    *borrow_index,\n+                    location_table.mid_index(location),\n+                ));\n+            }\n+        }\n+\n+        // If we are reborrowing the referent of another reference, we\n+        // need to add outlives relationships. In a case like `&mut\n+        // *p`, where the `p` has type `&'b mut Foo`, for example, we\n+        // need to ensure that `'b: 'a`.\n+\n+        let mut borrowed_place = borrowed_place;\n+\n+        debug!(\n+            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+            location, borrow_region, borrowed_place\n+        );\n+        while let Place::Projection(box PlaceProjection { base, elem }) = borrowed_place {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n+\n+            match *elem {\n+                ProjectionElem::Deref => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+\n+                    debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n+                    match base_ty.sty {\n+                        ty::TyRef(ref_region, _, mutbl) => {\n+                            self.constraints\n+                                .outlives_constraints\n+                                .push(OutlivesConstraint {\n+                                    sup: ref_region.to_region_vid(),\n+                                    sub: borrow_region.to_region_vid(),\n+                                    locations: location.boring(),\n+                                    next: None,\n+                                });\n+\n+                            if let Some(all_facts) = all_facts {\n+                                all_facts.outlives.push((\n+                                    ref_region.to_region_vid(),\n+                                    borrow_region.to_region_vid(),\n+                                    location_table.mid_index(location),\n+                                ));\n+                            }\n+\n+                            match mutbl {\n+                                hir::Mutability::MutImmutable => {\n+                                    // Immutable reference. We don't need the base\n+                                    // to be valid for the entire lifetime of\n+                                    // the borrow.\n+                                    break;\n+                                }\n+                                hir::Mutability::MutMutable => {\n+                                    // Mutable reference. We *do* need the base\n+                                    // to be valid, because after the base becomes\n+                                    // invalid, someone else can use our mutable deref.\n+\n+                                    // This is in order to make the following function\n+                                    // illegal:\n+                                    // ```\n+                                    // fn unsafe_deref<'a, 'b>(x: &'a &'b mut T) -> &'b mut T {\n+                                    //     &mut *x\n+                                    // }\n+                                    // ```\n+                                    //\n+                                    // As otherwise you could clone `&mut T` using the\n+                                    // following function:\n+                                    // ```\n+                                    // fn bad(x: &mut T) -> (&mut T, &mut T) {\n+                                    //     let my_clone = unsafe_deref(&'a x);\n+                                    //     ENDREGION 'a;\n+                                    //     (my_clone, x)\n+                                    // }\n+                                    // ```\n+                                }\n+                            }\n+                        }\n+                        ty::TyRawPtr(..) => {\n+                            // deref of raw pointer, guaranteed to be valid\n+                            break;\n+                        }\n+                        ty::TyAdt(def, _) if def.is_box() => {\n+                            // deref of `Box`, need the base to be valid - propagate\n+                        }\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n+                    }\n+                }\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n+                    // other field access\n+                }\n+            }\n+\n+            // The \"propagate\" case. We need to check that our base is valid\n+            // for the borrow's lifetime.\n+            borrowed_place = base;\n+        }\n+    }\n+\n     fn prove_aggregate_predicates(\n         &mut self,\n         aggregate_kind: &AggregateKind<'tcx>,"}]}