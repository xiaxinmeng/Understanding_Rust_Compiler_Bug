{"sha": "0c47632898ff480804c53bcccd21a5715d2804d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNDc2MzI4OThmZjQ4MDgwNGM1M2JjY2NkMjFhNTcxNWQyODA0ZDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-30T02:56:24Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-13T04:03:17Z"}, "message": "Rewrite rusti", "tree": {"sha": "3235d7c1b0dc15bdd1fa9182ba2a510e96dcc429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3235d7c1b0dc15bdd1fa9182ba2a510e96dcc429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c47632898ff480804c53bcccd21a5715d2804d7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c47632898ff480804c53bcccd21a5715d2804d7", "html_url": "https://github.com/rust-lang/rust/commit/0c47632898ff480804c53bcccd21a5715d2804d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c47632898ff480804c53bcccd21a5715d2804d7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c45160f19cff60e8956491eabe9e4704735c0eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c45160f19cff60e8956491eabe9e4704735c0eb", "html_url": "https://github.com/rust-lang/rust/commit/6c45160f19cff60e8956491eabe9e4704735c0eb"}], "stats": {"total": 939, "additions": 777, "deletions": 162}, "files": [{"sha": "513baa67ac1ca833665d7e407465459a6e29b0cf", "filename": "src/librusti/program.rs", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/0c47632898ff480804c53bcccd21a5715d2804d7/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c47632898ff480804c53bcccd21a5715d2804d7/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=0c47632898ff480804c53bcccd21a5715d2804d7", "patch": "@@ -0,0 +1,434 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast;\n+use std::hashmap::HashMap;\n+use std::local_data;\n+use std::sys;\n+\n+use syntax::ast;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+use rustc::middle::ty;\n+use rustc::util::ppaux;\n+\n+use utils::*;\n+\n+/// This structure keeps track of the state of the world for the code being\n+/// executed in rusti.\n+struct Program {\n+    /// All known local variables\n+    local_vars: HashMap<~str, LocalVariable>,\n+    /// New variables which will be present (learned from typechecking)\n+    newvars: HashMap<~str, LocalVariable>,\n+    /// All known view items (use statements), distinct because these must\n+    /// follow extern mods\n+    view_items: ~str,\n+    /// All known 'extern mod' statements (must always come first)\n+    externs: ~str,\n+    /// All known structs defined. These need to have\n+    /// #[deriving(Encodable,Decodable)] to be at all useful in rusti\n+    structs: HashMap<~str, ~str>,\n+    /// All other items, can all be intermingled. Duplicate definitions of the\n+    /// same name have the previous one overwritten.\n+    items: HashMap<~str, ~str>,\n+}\n+\n+/// Represents a local variable that the program is currently using.\n+struct LocalVariable {\n+    /// Should this variable be locally declared as mutable?\n+    mutable: bool,\n+    /// This is the type of the serialized data below\n+    ty: ~str,\n+    /// This is the serialized version of the variable\n+    data: ~[u8],\n+    /// When taking borrowed pointers or slices, care must be taken to ensure\n+    /// that the deserialization produces what we'd expect. If some magic is in\n+    /// order, the first element of this pair is the actual type of the local\n+    /// variable (which can be different from the deserialized type), and the\n+    /// second element are the '&'s which need to be prepended.\n+    alterations: Option<(~str, ~str)>,\n+}\n+\n+type LocalCache = @mut HashMap<~str, @~[u8]>;\n+fn tls_key(_k: @LocalCache) {}\n+\n+impl Program {\n+    pub fn new() -> Program {\n+        Program {\n+            local_vars: HashMap::new(),\n+            newvars: HashMap::new(),\n+            view_items: ~\"\",\n+            externs: ~\"\",\n+            structs: HashMap::new(),\n+            items: HashMap::new(),\n+        }\n+    }\n+\n+    /// Clears all local bindings about variables, items, externs, etc.\n+    pub fn clear(&mut self) {\n+        *self = Program::new();\n+    }\n+\n+    /// Creates a block of code to be fed to rustc. This code is not meant to\n+    /// run, but rather it is meant to learn about the input given. This will\n+    /// assert that the types of all bound local variables are encodable,\n+    /// along with checking syntax and other rust-related things. The reason\n+    /// that we only check for encodability is that some super-common types\n+    /// (like &'static str) are not decodable, but are encodable. By doing some\n+    /// mild approximation when decoding, we can emulate at least &str and &[T].\n+    ///\n+    /// Once this code has been fed to rustc, it is intended that the code()\n+    /// function is used to actually generate code to fully compile and run.\n+    pub fn test_code(&self, user_input: &str, to_print: &Option<~str>,\n+                     new_locals: &[(~str, bool)]) -> ~str {\n+        let mut code = self.program_header();\n+        code.push_str(\"\n+    fn assert_encodable<T: Encodable<::extra::ebml::writer::Encoder>>(t: &T) {}\n+        \");\n+\n+        code.push_str(\"fn main() {\\n\");\n+        // It's easy to initialize things if we don't run things...\n+        for self.local_vars.each |name, var| {\n+            let mt = var.mt();\n+            code.push_str(fmt!(\"let%s %s: %s = fail!();\\n\", mt, *name, var.ty));\n+            var.alter(*name, &mut code);\n+        }\n+        code.push_str(\"{\\n\");\n+        code.push_str(user_input);\n+        code.push_char('\\n');\n+        match *to_print {\n+            Some(ref s) => {\n+                code.push_str(*s);\n+                code.push_char('\\n');\n+            }\n+            None => {}\n+        }\n+\n+        for new_locals.each |p| {\n+            code.push_str(fmt!(\"assert_encodable(&%s);\\n\", *p.first_ref()));\n+        }\n+        code.push_str(\"};}\");\n+        return code;\n+    }\n+\n+    /// Creates a program to be fed into rustc. This program is structured to\n+    /// deserialize all bindings into local variables, run the code input, and\n+    /// then reserialize all the variables back out.\n+    ///\n+    /// This program (unlike test_code) is meant to run to actually execute the\n+    /// user's input\n+    pub fn code(&mut self, user_input: &str, to_print: &Option<~str>) -> ~str {\n+        let mut code = self.program_header();\n+        code.push_str(\"\n+            fn main() {\n+        \");\n+\n+        let key: sys::Closure = unsafe {\n+            let tls_key: &'static fn(@LocalCache) = tls_key;\n+            cast::transmute(tls_key)\n+        };\n+        // First, get a handle to the tls map which stores all the local\n+        // variables. This works by totally legitimately using the 'code'\n+        // pointer of the 'tls_key' function as a uint, and then casting it back\n+        // up to a function\n+        code.push_str(fmt!(\"\n+            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe {\n+                let key = ::std::sys::Closure{ code: %? as *(),\n+                                               env: ::std::ptr::null() };\n+                let key = ::std::cast::transmute(key);\n+                *::std::local_data::local_data_get(key).unwrap()\n+            };\\n\", key.code as uint));\n+\n+        // Using this __tls_map handle, deserialize each variable binding that\n+        // we know about\n+        for self.local_vars.each |name, var| {\n+            let mt = var.mt();\n+            code.push_str(fmt!(\"let%s %s: %s = {\n+                let data = __tls_map.get_copy(&~\\\"%s\\\");\n+                let doc = ::extra::ebml::reader::Doc(data);\n+                let mut decoder = ::extra::ebml::reader::Decoder(doc);\n+                ::extra::serialize::Decodable::decode(&mut decoder)\n+            };\\n\", mt, *name, var.ty, *name));\n+            var.alter(*name, &mut code);\n+        }\n+\n+        // After all that, actually run the user's code.\n+        code.push_str(user_input);\n+        code.push_char('\\n');\n+\n+        match *to_print {\n+            Some(ref s) => { code.push_str(fmt!(\"pp({\\n%s\\n});\", *s)); }\n+            None => {}\n+        }\n+\n+        do self.newvars.consume |name, var| {\n+            self.local_vars.insert(name, var);\n+        }\n+\n+        // After the input code is run, we can re-serialize everything back out\n+        // into tls map (to be read later on by this task)\n+        for self.local_vars.each |name, var| {\n+            code.push_str(fmt!(\"{\n+                let local: %s = %s;\n+                let bytes = do ::std::io::with_bytes_writer |io| {\n+                    let mut enc = ::extra::ebml::writer::Encoder(io);\n+                    local.encode(&mut enc);\n+                };\n+                __tls_map.insert(~\\\"%s\\\", @bytes);\n+            }\\n\", var.real_ty(), *name, *name));\n+        }\n+\n+        // Close things up, and we're done.\n+        code.push_str(\"}\");\n+        return code;\n+    }\n+\n+    /// Creates the header of the programs which are generated to send to rustc\n+    fn program_header(&self) -> ~str {\n+        // up front, disable lots of annoying lints, then include all global\n+        // state such as items, view items, and extern mods.\n+        let mut code = fmt!(\"\n+            #[allow(ctypes)];\n+            #[allow(heap_memory)];\n+            #[allow(implicit_copies)];\n+            #[allow(managed_heap_memory)];\n+            #[allow(non_camel_case_types)];\n+            #[allow(owned_heap_memory)];\n+            #[allow(path_statement)];\n+            #[allow(unrecognized_lint)];\n+            #[allow(unused_imports)];\n+            #[allow(while_true)];\n+            #[allow(unused_variable)];\n+            #[allow(dead_assignment)];\n+            #[allow(unused_unsafe)];\n+            #[allow(unused_mut)];\n+            #[allow(unreachable_code)];\n+\n+            extern mod extra;\n+            %s // extern mods\n+\n+            use extra::serialize::*;\n+            %s // view items\n+        \", self.externs, self.view_items);\n+        for self.structs.each_value |s| {\n+            // The structs aren't really useful unless they're encodable\n+            code.push_str(\"#[deriving(Encodable, Decodable)]\");\n+            code.push_str(*s);\n+            code.push_str(\"\\n\");\n+        }\n+        for self.items.each_value |s| {\n+            code.push_str(*s);\n+            code.push_str(\"\\n\");\n+        }\n+        code.push_str(\"fn pp<T>(t: T) { println(fmt!(\\\"%?\\\", t)); }\\n\");\n+        return code;\n+    }\n+\n+    /// Initializes the task-local cache of all local variables known to the\n+    /// program. This will be used to read local variables out of once the\n+    /// program starts\n+    pub fn set_cache(&self) {\n+        let map = @mut HashMap::new();\n+        for self.local_vars.each |name, value| {\n+            map.insert(copy *name, @copy value.data);\n+        }\n+        unsafe {\n+            local_data::local_data_set(tls_key, @map);\n+        }\n+    }\n+\n+    /// Once the program has finished running, this function will consume the\n+    /// task-local cache of local variables. After the program finishes running,\n+    /// it updates this cache with the new values of each local variable.\n+    pub fn consume_cache(&mut self) {\n+        let map = unsafe {\n+            local_data::local_data_pop(tls_key).expect(\"tls is empty\")\n+        };\n+        do map.consume |name, value| {\n+            match self.local_vars.find_mut(&name) {\n+                Some(v) => { v.data = copy *value; }\n+                None => { fail!(\"unknown variable %s\", name) }\n+            }\n+        }\n+    }\n+\n+    // Simple functions to record various global things (as strings)\n+\n+    pub fn record_view_item(&mut self, vi: &str) {\n+        self.view_items.push_str(vi);\n+        self.view_items.push_char('\\n');\n+    }\n+\n+    pub fn record_struct(&mut self, name: &str, s: ~str) {\n+        let name = name.to_owned();\n+        self.items.remove(&name);\n+        self.structs.insert(name, s);\n+    }\n+\n+    pub fn record_item(&mut self, name: &str, it: ~str) {\n+        let name = name.to_owned();\n+        self.structs.remove(&name);\n+        self.items.insert(name, it);\n+    }\n+\n+    pub fn record_extern(&mut self, name: &str) {\n+        self.externs.push_str(name);\n+        self.externs.push_char('\\n');\n+    }\n+\n+    /// This monster function is responsible for reading the main function\n+    /// generated by test_code() to determine the type of each local binding\n+    /// created by the user's input.\n+    ///\n+    /// Once the types are known, they are inserted into the local_vars map in\n+    /// this Program (to be deserialized later on\n+    pub fn register_new_vars(&mut self, blk: &ast::blk, tcx: ty::ctxt) {\n+        debug!(\"looking for new variables\");\n+        let newvars = @mut HashMap::new();\n+        do each_user_local(blk) |local| {\n+            let mutable = local.node.is_mutbl;\n+            do each_binding(local) |path, id| {\n+                let name = do with_pp(token::get_ident_interner()) |pp, _| {\n+                    pprust::print_path(pp, path, false);\n+                };\n+                let mut t = ty::node_id_to_type(tcx, id);\n+                let mut tystr = ~\"\";\n+                let mut lvar = LocalVariable {\n+                    ty: ~\"\",\n+                    data: ~[],\n+                    mutable: mutable,\n+                    alterations: None,\n+                };\n+                // This loop is responsible for figuring out what \"alterations\"\n+                // are necessary for this local variable.\n+                loop {\n+                    match ty::get(t).sty {\n+                        // &T encoded will decode to T, so we need to be sure to\n+                        // re-take a loan after decoding\n+                        ty::ty_rptr(_, mt) => {\n+                            if mt.mutbl == ast::m_mutbl {\n+                                tystr.push_str(\"&mut \");\n+                            } else {\n+                                tystr.push_str(\"&\");\n+                            }\n+                            t = mt.ty;\n+                        }\n+                        // Literals like [1, 2, 3] and (~[0]).slice() will both\n+                        // be serialized to ~[T], whereas it's requested to be a\n+                        // &[T] instead.\n+                        ty::ty_evec(mt, ty::vstore_slice(*)) |\n+                        ty::ty_evec(mt, ty::vstore_fixed(*)) => {\n+                            let vty = ppaux::ty_to_str(tcx, mt.ty);\n+                            let derefs = copy tystr;\n+                            lvar.ty = tystr + \"~[\" + vty + \"]\";\n+                            lvar.alterations = Some((tystr + \"&[\" + vty + \"]\",\n+                                                     derefs));\n+                            break;\n+                        }\n+                        // Similar to vectors, &str serializes to ~str, so a\n+                        // borrow must be taken\n+                        ty::ty_estr(ty::vstore_slice(*)) => {\n+                            let derefs = copy tystr;\n+                            lvar.ty = tystr + \"~str\";\n+                            lvar.alterations = Some((tystr + \"&str\", derefs));\n+                            break;\n+                        }\n+                        // Don't generate extra stuff if there's no borrowing\n+                        // going on here\n+                        _ if \"\" == tystr => {\n+                            lvar.ty = ppaux::ty_to_str(tcx, t);\n+                            break;\n+                        }\n+                        // If we're just borrowing (no vectors or strings), then\n+                        // we just need to record how many borrows there were.\n+                        _ => {\n+                            let derefs = copy tystr;\n+                            let tmptystr = ppaux::ty_to_str(tcx, t);\n+                            lvar.alterations = Some((tystr + tmptystr, derefs));\n+                            lvar.ty = tmptystr;\n+                            break;\n+                        }\n+                    }\n+                }\n+                newvars.insert(name, lvar);\n+            }\n+        }\n+\n+        // I'm not an @ pointer, so this has to be done outside.\n+        do newvars.consume |k, v| {\n+            self.newvars.insert(k, v);\n+        }\n+\n+        // helper functions to perform ast iteration\n+        fn each_user_local(blk: &ast::blk, f: &fn(@ast::local)) {\n+            do find_user_block(blk) |blk| {\n+                for blk.node.stmts.each |stmt| {\n+                    match stmt.node {\n+                        ast::stmt_decl(d, _) => {\n+                            match d.node {\n+                                ast::decl_local(l) => { f(l); }\n+                                _ => {}\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn find_user_block(blk: &ast::blk, f: &fn(&ast::blk)) {\n+            for blk.node.stmts.each |stmt| {\n+                match stmt.node {\n+                    ast::stmt_semi(e, _) => {\n+                        match e.node {\n+                            ast::expr_block(ref blk) => { return f(blk); }\n+                            _ => {}\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            fail!(\"couldn't find user block\");\n+        }\n+    }\n+}\n+\n+impl LocalVariable {\n+    /// Performs alterations to the code provided, given the name of this\n+    /// variable.\n+    fn alter(&self, name: &str, code: &mut ~str) {\n+        match self.alterations {\n+            Some((ref real_ty, ref prefix)) => {\n+                code.push_str(fmt!(\"let%s %s: %s = %s%s;\\n\",\n+                                   self.mt(), name,\n+                                   *real_ty, *prefix, name));\n+            }\n+            None => {}\n+        }\n+    }\n+\n+    fn real_ty<'a>(&'a self) -> &'a str {\n+        match self.alterations {\n+            Some((ref real_ty, _)) => {\n+                let ret: &'a str = *real_ty;\n+                return ret;\n+            }\n+            None => {\n+                let ret: &'a str = self.ty;\n+                return ret;\n+            }\n+        }\n+    }\n+\n+    fn mt(&self) -> &'static str {\n+        if self.mutable {\" mut\"} else {\"\"}\n+    }\n+}"}, {"sha": "90a5a350b7fa4b2b9af68edf50731d70f8ea4c28", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 298, "deletions": 132, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/0c47632898ff480804c53bcccd21a5715d2804d7/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0c47632898ff480804c53bcccd21a5715d2804d7/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=0c47632898ff480804c53bcccd21a5715d2804d7", "patch": "@@ -8,7 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// rusti - REPL using the JIT backend\n+/*!\n+ * rusti - A REPL using the JIT backend\n+ *\n+ * Rusti works by serializing state between lines of input. This means that each\n+ * line can be run in a separate task, and the only limiting factor is that all\n+ * local bound variables are encodable.\n+ *\n+ * This is accomplished by feeding in generated input to rustc for execution in\n+ * the JIT compiler. Currently input actually gets fed in three times to get\n+ * information about the program.\n+ *\n+ * - Pass #1\n+ *   In this pass, the input is simply thrown at the parser and the input comes\n+ *   back. This validates the structure of the program, and at this stage the\n+ *   global items (fns, structs, impls, traits, etc.) are filtered from the\n+ *   input into the \"global namespace\". These declarations shadow all previous\n+ *   declarations of an item by the same name.\n+ *\n+ * - Pass #2\n+ *   After items have been stripped, the remaining input is passed to rustc\n+ *   along with all local variables declared (initialized to nothing). This pass\n+ *   runs up to typechecking. From this, we can learn about the types of each\n+ *   bound variable, what variables are bound, and also ensure that all the\n+ *   types are encodable (the input can actually be run).\n+ *\n+ * - Pass #3\n+ *   Finally, a program is generated to deserialize the local variable state,\n+ *   run the code input, and then reserialize all bindings back into a local\n+ *   hash map. Once this code runs, the input has fully been run and the REPL\n+ *   waits for new input.\n+ *\n+ * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n+ * ~[u8] maintaining the values of each local binding (by name).\n+ */\n \n #[link(name = \"rusti\",\n        vers = \"0.7-pre\",\n@@ -18,24 +51,25 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[no_std];\n-\n-extern mod core(name = \"std\");\n-extern mod std(name = \"extra\");\n-\n+extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use core::prelude::*;\n-use core::*;\n+use std::{libc, io, os, task, vec};\n+use std::cell::Cell;\n+use extra::rl;\n \n-use core::cell::Cell;\n use rustc::driver::{driver, session};\n use syntax::{ast, diagnostic};\n use syntax::ast_util::*;\n use syntax::parse::token;\n-use syntax::print::{pp, pprust};\n-use std::rl;\n+use syntax::print::pprust;\n+\n+use program::Program;\n+use utils::*;\n+\n+mod program;\n+pub mod utils;\n \n /**\n  * A structure shared across REPL instances for storing history\n@@ -45,9 +79,9 @@ pub struct Repl {\n     prompt: ~str,\n     binary: ~str,\n     running: bool,\n-    view_items: ~str,\n     lib_search_paths: ~[~str],\n-    stmts: ~str\n+\n+    program: Program,\n }\n \n // Action to do after reading a :command\n@@ -56,67 +90,9 @@ enum CmdAction {\n     action_run_line(~str),\n }\n \n-/// A utility function that hands off a pretty printer to a callback.\n-fn with_pp(intr: @token::ident_interner,\n-           cb: &fn(@pprust::ps, @io::Writer)) -> ~str {\n-    do io::with_str_writer |writer| {\n-        let pp = pprust::rust_printer(writer, intr);\n-\n-        cb(pp, writer);\n-        pp::eof(pp.s);\n-    }\n-}\n-\n-/**\n- * The AST (or the rest of rustc) are not sendable yet,\n- * so recorded things are printed to strings. A terrible hack that\n- * needs changes to rustc in order to be outed. This is unfortunately\n- * going to cause the REPL to regress in parser performance,\n- * because it has to parse the statements and view_items on each\n- * input.\n- */\n-fn record(mut repl: Repl, blk: &ast::blk, intr: @token::ident_interner) -> Repl {\n-    if blk.node.view_items.len() > 0 {\n-        let new_view_items = do with_pp(intr) |pp, writer| {\n-            for blk.node.view_items.each |view_item| {\n-                pprust::print_view_item(pp, *view_item);\n-                writer.write_line(\"\");\n-            }\n-        };\n-\n-        debug!(\"new view items %s\", new_view_items);\n-\n-        repl.view_items = repl.view_items + \"\\n\" + new_view_items\n-    }\n-    if blk.node.stmts.len() > 0 {\n-        let new_stmts = do with_pp(intr) |pp, writer| {\n-            for blk.node.stmts.each |stmt| {\n-                match stmt.node {\n-                    ast::stmt_decl(*) | ast::stmt_mac(*) => {\n-                        pprust::print_stmt(pp, *stmt);\n-                        writer.write_line(\"\");\n-                    }\n-                    ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n-                        match expr.node {\n-                            ast::expr_assign(*) |\n-                            ast::expr_assign_op(*) |\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-\n-        debug!(\"new stmts %s\", new_stmts);\n-\n-        repl.stmts = repl.stmts + \"\\n\" + new_stmts\n-    }\n-\n-    return repl;\n-}\n-\n /// Run an input string in a Repl, returning the new Repl.\n-fn run(repl: Repl, input: ~str) -> Repl {\n+fn run(mut repl: Repl, input: ~str) -> Repl {\n+    // Build some necessary rustc boilerplate for compiling things\n     let binary = repl.binary.to_managed();\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n@@ -125,56 +101,165 @@ fn run(repl: Repl, input: ~str) -> Repl {\n         jit: true,\n         .. copy *session::basic_options()\n     };\n+    // Because we assume that everything is encodable (and assert so), add some\n+    // extra helpful information if the error crops up. Otherwise people are\n+    // bound to be very confused when they find out code is running that they\n+    // never typed in...\n+    let sess = driver::build_session(options, |cm, msg, lvl| {\n+        diagnostic::emit(cm, msg, lvl);\n+        if msg.contains(\"failed to find an implementation of trait\") &&\n+           msg.contains(\"extra::serialize::Encodable\") {\n+            diagnostic::emit(cm,\n+                             \"Currrently rusti serializes bound locals between \\\n+                              different lines of input. This means that all \\\n+                              values of local variables need to be encodable, \\\n+                              and this type isn't encodable\",\n+                             diagnostic::note);\n+        }\n+    });\n+    let intr = token::get_ident_interner();\n+\n+    //\n+    // Stage 1: parse the input and filter it into the program (as necessary)\n+    //\n+    debug!(\"parsing: %s\", input);\n+    let crate = parse_input(sess, binary, input);\n+    let mut to_run = ~[];       // statements to run (emitted back into code)\n+    let new_locals = @mut ~[];  // new locals being defined\n+    let mut result = None;      // resultant expression (to print via pp)\n+    do find_main(crate, sess) |blk| {\n+        // Fish out all the view items, be sure to record 'extern mod' items\n+        // differently beause they must appear before all 'use' statements\n+        for blk.node.view_items.each |vi| {\n+            let s = do with_pp(intr) |pp, _| {\n+                pprust::print_view_item(pp, *vi);\n+            };\n+            match vi.node {\n+                ast::view_item_extern_mod(*) => {\n+                    repl.program.record_extern(s);\n+                }\n+                ast::view_item_use(*) => { repl.program.record_view_item(s); }\n+            }\n+        }\n \n-    debug!(\"building driver input\");\n-    let head = include_str!(\"wrapper.rs\").to_owned();\n-    let foot = fmt!(\"fn main() {\\n%s\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n-                    repl.view_items, repl.stmts, input);\n-    let wrapped = driver::str_input((head + foot).to_managed());\n+        // Iterate through all of the block's statements, inserting them into\n+        // the correct portions of the program\n+        for blk.node.stmts.each |stmt| {\n+            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n+            match stmt.node {\n+                ast::stmt_decl(d, _) => {\n+                    match d.node {\n+                        ast::decl_item(it) => {\n+                            let name = sess.str_of(it.ident);\n+                            match it.node {\n+                                // Structs are treated specially because to make\n+                                // them at all usable they need to be decorated\n+                                // with #[deriving(Encoable, Decodable)]\n+                                ast::item_struct(*) => {\n+                                    repl.program.record_struct(name, s);\n+                                }\n+                                // Item declarations are hoisted out of main()\n+                                _ => { repl.program.record_item(name, s); }\n+                            }\n+                        }\n \n-    debug!(\"inputting %s\", head + foot);\n+                        // Local declarations must be specially dealt with,\n+                        // record all local declarations for use later on\n+                        ast::decl_local(l) => {\n+                            let mutbl = l.node.is_mutbl;\n+                            do each_binding(l) |path, _| {\n+                                let s = do with_pp(intr) |pp, _| {\n+                                    pprust::print_path(pp, path, false);\n+                                };\n+                                new_locals.push((s, mutbl));\n+                            }\n+                            to_run.push(s);\n+                        }\n+                    }\n+                }\n \n-    debug!(\"building a driver session\");\n-    let sess = driver::build_session(options, diagnostic::emit);\n+                // run statements with expressions (they have effects)\n+                ast::stmt_mac(*) | ast::stmt_semi(*) | ast::stmt_expr(*) => {\n+                    to_run.push(s);\n+                }\n+            }\n+        }\n+        result = do blk.node.expr.map_consume |e| {\n+            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n+        };\n+    }\n+    // return fast for empty inputs\n+    if to_run.len() == 0 && result.is_none() {\n+        return repl;\n+    }\n \n-    debug!(\"building driver configuration\");\n-    let cfg = driver::build_configuration(sess,\n-                                          binary,\n-                                          &wrapped);\n+    //\n+    // Stage 2: run everything up to typeck to learn the types of the new\n+    //          variables introduced into the program\n+    //\n+    info!(\"Learning about the new types in the program\");\n+    repl.program.set_cache(); // before register_new_vars (which changes them)\n+    let input = to_run.connect(\"\\n\");\n+    let test = repl.program.test_code(input, &result, *new_locals);\n+    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n+    let dinput = driver::str_input(test.to_managed());\n+    let cfg = driver::build_configuration(sess, binary, &dinput);\n+    let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n+    let (crate, tcx) = driver::compile_upto(sess, copy cfg, &dinput,\n+                                            driver::cu_typeck, Some(outputs));\n+    // Once we're typechecked, record the types of all local variables defined\n+    // in this input\n+    do find_main(crate.expect(\"crate after cu_typeck\"), sess) |blk| {\n+        repl.program.register_new_vars(blk, tcx.expect(\"tcx after cu_typeck\"));\n+    }\n \n-    let outputs = driver::build_output_filenames(&wrapped, &None, &None, [], sess);\n-    debug!(\"calling compile_upto\");\n+    //\n+    // Stage 3: Actually run the code in the JIT\n+    //\n+    info!(\"actually running code\");\n+    let code = repl.program.code(input, &result);\n+    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n+    let input = driver::str_input(code.to_managed());\n+    let cfg = driver::build_configuration(sess, binary, &input);\n+    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n+    let sess = driver::build_session(options, diagnostic::emit);\n+    driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n+                         Some(outputs));\n \n-    let crate = driver::parse_input(sess, copy cfg, &wrapped);\n-    driver::compile_rest(sess, cfg, driver::compile_upto { from: driver::cu_parse,\n-                                                           to: driver::cu_everything },\n-                          Some(outputs), Some(crate));\n+    //\n+    // Stage 4: Inform the program that computation is done so it can update all\n+    //          local variable bindings.\n+    //\n+    info!(\"cleaning up after code\");\n+    repl.program.consume_cache();\n \n-    let mut opt = None;\n+    return repl;\n \n-    for crate.node.module.items.each |item| {\n-        match item.node {\n-            ast::item_fn(_, _, _, _, ref blk) => {\n-                if item.ident == sess.ident_of(\"main\") {\n-                    opt = blk.node.expr;\n-                }\n-            }\n-            _ => {}\n-        }\n+    fn parse_input(sess: session::Session, binary: @str,\n+                   input: &str) -> @ast::crate {\n+        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n+        let input = driver::str_input(code.to_managed());\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n+        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+                                              driver::cu_parse, Some(outputs));\n+        crate.expect(\"parsing should return a crate\")\n     }\n \n-    let e = opt.unwrap();\n-    let blk = match e.node {\n-        ast::expr_call(_, ref exprs, _) => {\n-            match exprs[0].node {\n-                ast::expr_block(ref blk) => blk,\n-                _ => fail!()\n+    fn find_main(crate: @ast::crate, sess: session::Session,\n+                 f: &fn(&ast::blk)) {\n+        for crate.node.module.items.each |item| {\n+            match item.node {\n+                ast::item_fn(_, _, _, _, ref blk) => {\n+                    if item.ident == sess.ident_of(\"main\") {\n+                        return f(blk);\n+                    }\n+                }\n+                _ => {}\n             }\n         }\n-        _ => fail!()\n-    };\n-    debug!(\"recording input into repl history\");\n-    record(repl, blk, token::get_ident_interner())\n+        fail!(\"main function was expected somewhere...\");\n+    }\n }\n \n // Compiles a crate given by the filename as a library if the compiled\n@@ -265,8 +350,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n     match cmd {\n         ~\"exit\" => repl.running = false,\n         ~\"clear\" => {\n-            repl.view_items = ~\"\";\n-            repl.stmts = ~\"\";\n+            repl.program.clear();\n \n             // XXX: Win32 version of linenoise can't do this\n             //rl::clear();\n@@ -296,12 +380,9 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for loaded_crates.each |crate| {\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n-                let crate_name = crate_path.filename().get();\n-                if !repl.view_items.contains(*crate) {\n-                    repl.view_items += fmt!(\"extern mod %s;\\n\", crate_name);\n-                    if !repl.lib_search_paths.contains(&crate_dir) {\n-                        repl.lib_search_paths.push(crate_dir);\n-                    }\n+                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n+                if !repl.lib_search_paths.contains(&crate_dir) {\n+                    repl.lib_search_paths.push(crate_dir);\n                 }\n             }\n             if loaded_crates.is_empty() {\n@@ -340,7 +421,7 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n     -> Option<Repl> {\n     if line.starts_with(\":\") {\n         // FIXME #5898: conflicts with Cell.take(), so can't be at the top level\n-        use core::iterator::IteratorUtil;\n+        use std::iterator::IteratorUtil;\n \n         // drop the : and the \\n (one byte each)\n         let full = line.slice(1, line.len() - 1);\n@@ -388,9 +469,9 @@ pub fn main() {\n         prompt: ~\"rusti> \",\n         binary: copy args[0],\n         running: true,\n-        view_items: ~\"\",\n         lib_search_paths: ~[],\n-        stmts: ~\"\"\n+\n+        program: Program::new(),\n     };\n \n     let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n@@ -434,23 +515,24 @@ pub fn main() {\n \n #[cfg(test)]\n mod tests {\n+    use std::io;\n+    use std::iterator::IteratorUtil;\n+    use program::Program;\n     use super::*;\n-    use core::io;\n \n     fn repl() -> Repl {\n         Repl {\n             prompt: ~\"rusti> \",\n             binary: ~\"rusti\",\n             running: true,\n-            view_items: ~\"\",\n             lib_search_paths: ~[],\n-            stmts: ~\"\"\n+            program: Program::new(),\n         }\n     }\n \n-    fn run_cmds(cmds: &[&str]) {\n+    fn run_program(prog: &str) {\n         let mut r = repl();\n-        for cmds.each |&cmd| {\n+        for prog.split_iter('\\n').advance |cmd| {\n             let result = run_line(&mut r, io::stdin(), io::stdout(),\n                                   cmd.to_owned(), false);\n             r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n@@ -469,18 +551,102 @@ mod tests {\n         // To get some interesting output, run with RUST_LOG=rusti::tests\n \n         debug!(\"hopefully this runs\");\n-        run_cmds([\"\"]);\n+        run_program(\"\");\n \n         debug!(\"regression test for #5937\");\n-        run_cmds([\"use std;\", \"\"]);\n+        run_program(\"use std::hashmap;\");\n \n         debug!(\"regression test for #5784\");\n-        run_cmds([\"let a = 1;\"]);\n+        run_program(\"let a = 3;\");\n \n         // XXX: can't spawn new tasks because the JIT code is cleaned up\n         //      after the main function is done.\n         // debug!(\"regression test for #5803\");\n-        // run_cmds([\"spawn( || println(\\\"Please don't segfault\\\") );\",\n-        //           \"do spawn { println(\\\"Please?\\\"); }\"]);\n+        // run_program(\"\n+        //     spawn( || println(\\\"Please don't segfault\\\") );\n+        //     do spawn { println(\\\"Please?\\\"); }\n+        // \");\n+\n+        debug!(\"inferred integers are usable\");\n+        run_program(\"let a = 2;\\n()\\n\");\n+        run_program(\"\n+            let a = 3;\n+            let b = 4u;\n+            assert!((a as uint) + b == 7)\n+        \");\n+\n+        debug!(\"local variables can be shadowed\");\n+        run_program(\"\n+            let a = 3;\n+            let a = 5;\n+            assert!(a == 5)\n+        \");\n+\n+        debug!(\"strings are usable\");\n+        run_program(\"\n+            let a = ~\\\"\\\";\n+            let b = \\\"\\\";\n+            let c = @\\\"\\\";\n+            let d = a + b + c;\n+            assert!(d.len() == 0);\n+        \");\n+\n+        debug!(\"vectors are usable\");\n+        run_program(\"\n+            let a = ~[1, 2, 3];\n+            let b = &[1, 2, 3];\n+            let c = @[1, 2, 3];\n+            let d = a + b + c;\n+            assert!(d.len() == 9);\n+            let e: &[int] = [];\n+        \");\n+\n+        debug!(\"structs are usable\");\n+        run_program(\"\n+            struct A{ a: int }\n+            let b = A{ a: 3 };\n+            assert!(b.a == 3)\n+        \");\n+\n+        debug!(\"mutable variables\");\n+        run_program(\"\n+            let mut a = 3;\n+            a = 5;\n+            let mut b = std::hashmap::HashSet::new::<int>();\n+            b.insert(a);\n+            assert!(b.contains(&5))\n+            assert!(b.len() == 1)\n+        \");\n+\n+        debug!(\"functions are cached\");\n+        run_program(\"\n+            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n+            let a = fib(3);\n+            let a = a + fib(4);\n+            assert!(a == 5)\n+        \");\n+\n+        debug!(\"modules are cached\");\n+        run_program(\"\n+            mod b { pub fn foo() -> uint { 3 } }\n+            assert!(b::foo() == 3)\n+        \");\n+\n+        debug!(\"multiple function definitions are allowed\");\n+        run_program(\"\n+            fn f() {}\n+            fn f() {}\n+            f()\n+        \");\n+\n+        debug!(\"multiple item definitions are allowed\");\n+        run_program(\"\n+            fn f() {}\n+            mod f {}\n+            struct f;\n+            enum f {}\n+            fn f() {}\n+            f()\n+        \");\n     }\n }"}, {"sha": "0ac0f5a3c4cb44c39cf7038f935c1ca86eaec6b6", "filename": "src/librusti/utils.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0c47632898ff480804c53bcccd21a5715d2804d7/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c47632898ff480804c53bcccd21a5715d2804d7/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=0c47632898ff480804c53bcccd21a5715d2804d7", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io;\n+use syntax::ast;\n+use syntax::print::pp;\n+use syntax::print::pprust;\n+use syntax::parse::token;\n+\n+pub fn each_binding(l: @ast::local, f: @fn(@ast::Path, ast::node_id)) {\n+    use syntax::visit;\n+\n+    let vt = visit::mk_simple_visitor(\n+        @visit::SimpleVisitor {\n+            visit_pat: |pat| {\n+                match pat.node {\n+                    ast::pat_ident(_, path, _) => {\n+                        f(path, pat.id);\n+                    }\n+                    _ => {}\n+                }\n+            },\n+            .. *visit::default_simple_visitor()\n+        }\n+    );\n+    (vt.visit_pat)(l.node.pat, ((), vt));\n+}\n+\n+/// A utility function that hands off a pretty printer to a callback.\n+pub fn with_pp(intr: @token::ident_interner,\n+               cb: &fn(@pprust::ps, @io::Writer)) -> ~str {\n+    do io::with_str_writer |writer| {\n+        let pp = pprust::rust_printer(writer, intr);\n+\n+        cb(pp, writer);\n+        pp::eof(pp.s);\n+    }\n+}"}, {"sha": "664e5e3b246397a72b36e2b9f1fef4bac03a550c", "filename": "src/librusti/wrapper.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6c45160f19cff60e8956491eabe9e4704735c0eb/src%2Flibrusti%2Fwrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c45160f19cff60e8956491eabe9e4704735c0eb/src%2Flibrusti%2Fwrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fwrapper.rs?ref=6c45160f19cff60e8956491eabe9e4704735c0eb", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(ctypes)];\n-#[allow(heap_memory)];\n-#[allow(implicit_copies)];\n-#[allow(managed_heap_memory)];\n-#[allow(non_camel_case_types)];\n-#[allow(owned_heap_memory)];\n-#[allow(path_statement)];\n-#[allow(unrecognized_lint)];\n-#[allow(unused_imports)];\n-#[allow(while_true)];\n-#[allow(unused_variable)];\n-#[allow(dead_assignment)];\n-#[allow(unused_unsafe)];\n-#[allow(unused_mut)];\n-\n-extern mod std;\n-\n-fn print<T>(result: T) {\n-    println(fmt!(\"%?\", result));\n-}"}]}