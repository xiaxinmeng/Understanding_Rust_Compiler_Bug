{"sha": "3e0a1c09108b52e41113520c7fa516480a8b67f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMGExYzA5MTA4YjUyZTQxMTEzNTIwYzdmYTUxNjQ4MGE4YjY3Zjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-26T16:44:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-26T16:44:52Z"}, "message": "Auto merge of #67592 - matthewjasper:cleanup-match, r=Centril\n\nPrepare for lowering or-patterns\n\nThis is probably best reviewed commit-by-commit.\n\n* Rustfmt `rustc_mir::build::{self, matches}`\n* Remove `-Znll-dont-emit-read-for-match`\n* Split `match_expr` into smaller functions\n* Feature gate or-patterns in const contexts\n\ncc https://github.com/rust-lang/rust/issues/54883\n\nr? @Centril", "tree": {"sha": "cde4767122be8c1a4911b229b5371f204d45b97c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cde4767122be8c1a4911b229b5371f204d45b97c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e0a1c09108b52e41113520c7fa516480a8b67f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0a1c09108b52e41113520c7fa516480a8b67f9", "html_url": "https://github.com/rust-lang/rust/commit/3e0a1c09108b52e41113520c7fa516480a8b67f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e0a1c09108b52e41113520c7fa516480a8b67f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ac40b69c75929dac5115b6a49eb4f1ecc352416", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac40b69c75929dac5115b6a49eb4f1ecc352416", "html_url": "https://github.com/rust-lang/rust/commit/3ac40b69c75929dac5115b6a49eb4f1ecc352416"}, {"sha": "0a14cbea98b5e047281b2bbaa241d60ec57d6ea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a14cbea98b5e047281b2bbaa241d60ec57d6ea1", "html_url": "https://github.com/rust-lang/rust/commit/0a14cbea98b5e047281b2bbaa241d60ec57d6ea1"}], "stats": {"total": 411, "additions": 276, "deletions": 135}, "files": [{"sha": "e99e00a366d378ffb719888bb157db7acbb741d5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -1370,19 +1370,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.borrowck_mode().migrate()\n     }\n \n-    /// If `true`, make MIR codegen for `match` emit a temp that holds a\n-    /// borrow of the input to the match expression.\n-    pub fn generate_borrow_of_any_match_input(&self) -> bool {\n-        self.emit_read_for_match()\n-    }\n-\n-    /// If `true`, make MIR codegen for `match` emit FakeRead\n-    /// statements (which simulate the maximal effect of executing the\n-    /// patterns in a match arm).\n-    pub fn emit_read_for_match(&self) -> bool {\n-        !self.sess.opts.debugging_opts.nll_dont_emit_read_for_match\n-    }\n-\n     /// What mode(s) of borrowck should we run? AST? MIR? both?\n     /// (Also considers the `#![feature(nll)]` setting.)\n     pub fn borrowck_mode(&self) -> BorrowckMode {"}, {"sha": "e611c2d504e3f17b2b21236028aa1e9156ac6502", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 165, "deletions": 114, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -65,32 +65,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// We generate MIR in the following steps:\n     ///\n-    /// 1. Evaluate the scrutinee and add the fake read of it.\n-    /// 2. Create the prebinding and otherwise blocks.\n-    /// 3. Create the decision tree and record the places that we bind or test.\n-    /// 4. Determine the fake borrows that are needed from the above places.\n-    ///    Create the required temporaries for them.\n-    /// 5. Create everything else: the guards and the arms.\n-    ///\n-    /// ## Fake Reads and borrows\n-    ///\n-    /// Match exhaustiveness checking is not able to handle the case where the\n-    /// place being matched on is mutated in the guards. There is an AST check\n-    /// that tries to stop this but it is buggy and overly restrictive. Instead\n-    /// we add \"fake borrows\" to the guards that prevent any mutation of the\n-    /// place being matched. There are a some subtleties:\n-    ///\n-    /// 1. Borrowing `*x` doesn't prevent assigning to `x`. If `x` is a shared\n-    ///    refence, the borrow isn't even tracked. As such we have to add fake\n-    ///    borrows of any prefixes of a place\n-    /// 2. We don't want `match x { _ => (), }` to conflict with mutable\n-    ///    borrows of `x`, so we only add fake borrows for places which are\n-    ///    bound or tested by the match.\n-    /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n-    ///    so we use a special BorrowKind for them.\n-    /// 4. The fake borrows may be of places in inactive variants, so it would\n-    ///    be UB to generate code for them. They therefore have to be removed\n-    ///    by a MIR pass run after borrow checking.\n+    /// 1. Evaluate the scrutinee and add the fake read of it ([Builder::lower_scrutinee]).\n+    /// 2. Create the prebinding and otherwise blocks ([Builder::create_match_candidates]).\n+    /// 3. Create the decision tree ([Builder::lower_match_tree]).\n+    /// 4. Determine the fake borrows that are needed from the places that were\n+    ///    matched against and create the required temporaries for them\n+    ///    ([Builder::calculate_fake_borrows]).\n+    /// 5. Create everything else: the guards and the arms ([Builder::lower_match_arms]).\n     ///\n     /// ## False edges\n     ///\n@@ -108,13 +89,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scrutinee: ExprRef<'tcx>,\n         arms: Vec<Arm<'tcx>>,\n     ) -> BlockAnd<()> {\n-        let tcx = self.hir.tcx();\n+        let scrutinee_span = scrutinee.span();\n+        let scrutinee_place =\n+            unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        // Step 1. Evaluate the scrutinee and add the fake read of it.\n+        let mut arm_candidates = self.create_match_candidates(&scrutinee_place, &arms);\n \n-        let scrutinee_span = scrutinee.span();\n-        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n+        let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n+        let candidates =\n+            arm_candidates.iter_mut().flat_map(|(_, candidates)| candidates).collect::<Vec<_>>();\n \n+        let fake_borrow_temps =\n+            self.lower_match_tree(block, scrutinee_span, match_has_guard, candidates);\n+\n+        self.lower_match_arms(\n+            &destination,\n+            scrutinee_place,\n+            scrutinee_span,\n+            arm_candidates,\n+            self.source_info(span),\n+            fake_borrow_temps,\n+        )\n+    }\n+\n+    /// Evaluate the scrutinee and add the fake read of it.\n+    fn lower_scrutinee(\n+        &mut self,\n+        mut block: BasicBlock,\n+        scrutinee: ExprRef<'tcx>,\n+        scrutinee_span: Span,\n+    ) -> BlockAnd<Place<'tcx>> {\n+        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n         // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n@@ -130,37 +135,38 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // uninhabited value. If we get never patterns, those will check that\n         // the place is initialized, and so this read would only be used to\n         // check safety.\n-\n-        let source_info = self.source_info(scrutinee_span);\n         let cause_matched_place = FakeReadCause::ForMatchedPlace;\n+        let source_info = self.source_info(scrutinee_span);\n         self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place.clone());\n \n-        // Step 2. Create the otherwise and prebinding blocks.\n+        block.and(scrutinee_place)\n+    }\n \n-        // create binding start block for link them by false edges\n+    /// Create the initial `Candidate`s for a `match` expression.\n+    fn create_match_candidates<'pat>(\n+        &mut self,\n+        scrutinee: &Place<'tcx>,\n+        arms: &'pat [Arm<'tcx>],\n+    ) -> Vec<(&'pat Arm<'tcx>, Vec<Candidate<'pat, 'tcx>>)> {\n         let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> =\n             (0..candidate_count).map(|_| self.cfg.start_new_block()).collect();\n \n-        let mut match_has_guard = false;\n-\n         let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n         let mut next_candidate_pre_binding_blocks = pre_binding_blocks.iter().skip(1);\n \n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n-        let mut arm_candidates: Vec<_> = arms\n-            .iter()\n+        arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                match_has_guard |= arm_has_guard;\n                 let arm_candidates: Vec<_> = arm\n                     .top_pats_hack()\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n                     .map(|(pattern, pre_binding_block)| Candidate {\n                         span: pattern.span,\n-                        match_pairs: smallvec![MatchPair::new(scrutinee_place.clone(), pattern),],\n+                        match_pairs: smallvec![MatchPair::new(scrutinee.clone(), pattern)],\n                         bindings: vec![],\n                         ascriptions: vec![],\n                         otherwise_block: if arm_has_guard {\n@@ -176,54 +182,66 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .collect();\n                 (arm, arm_candidates)\n             })\n-            .collect();\n-\n-        // Step 3. Create the decision tree and record the places that we bind or test.\n+            .collect()\n+    }\n \n+    /// Create the decision tree for the match expression, starting from `block`.\n+    ///\n+    /// Modifies `candidates` to store the bindings and type ascriptions for\n+    /// that candidate.\n+    ///\n+    /// Returns the places that need fake borrows because we bind or test them.\n+    fn lower_match_tree<'pat>(\n+        &mut self,\n+        block: BasicBlock,\n+        scrutinee_span: Span,\n+        match_has_guard: bool,\n+        mut candidates: Vec<&mut Candidate<'pat, 'tcx>>,\n+    ) -> Vec<(Place<'tcx>, Local)> {\n         // The set of places that we are creating fake borrows of. If there are\n         // no match guards then we don't need any fake borrows, so don't track\n         // them.\n-        let mut fake_borrows = if match_has_guard && tcx.generate_borrow_of_any_match_input() {\n-            Some(FxHashSet::default())\n-        } else {\n-            None\n-        };\n+        let mut fake_borrows = if match_has_guard { Some(FxHashSet::default()) } else { None };\n \n-        // These candidates are kept sorted such that the highest priority\n-        // candidate comes first in the list. (i.e., same order as in source)\n-        // As we gnerate the decision tree,\n-        let candidates = &mut arm_candidates\n-            .iter_mut()\n-            .flat_map(|(_, candidates)| candidates)\n-            .collect::<Vec<_>>();\n-\n-        let outer_source_info = self.source_info(span);\n-\n-        // this will generate code to test scrutinee_place and\n+        // This will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n         self.match_candidates(\n             scrutinee_span,\n             &mut Some(block),\n             None,\n-            candidates,\n+            &mut candidates,\n             &mut fake_borrows,\n         );\n \n-        // Step 4. Determine the fake borrows that are needed from the above\n-        // places. Create the required temporaries for them.\n-\n-        let fake_borrow_temps = if let Some(ref borrows) = fake_borrows {\n+        if let Some(ref borrows) = fake_borrows {\n             self.calculate_fake_borrows(borrows, scrutinee_span)\n         } else {\n             Vec::new()\n-        };\n+        }\n+    }\n \n-        // Step 5. Create everything else: the guards and the arms.\n+    /// Lower the bindings, guards and arm bodies of a `match` expression.\n+    ///\n+    /// The decision tree should have already been created\n+    /// (by [Builder::lower_match_tree]).\n+    ///\n+    /// `outer_source_info` is the SourceInfo for the whole match.\n+    fn lower_match_arms(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        scrutinee_place: Place<'tcx>,\n+        scrutinee_span: Span,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Vec<Candidate<'_, 'tcx>>)>,\n+        outer_source_info: SourceInfo,\n+        fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n+    ) -> BlockAnd<()> {\n         let match_scope = self.scopes.topmost();\n \n         let arm_end_blocks: Vec<_> = arm_candidates\n             .into_iter()\n-            .map(|(arm, mut candidates)| {\n+            .map(|(arm, candidates)| {\n+                debug!(\"lowering arm {:?}\\ncanidates = {:?}\", arm, candidates);\n+\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n@@ -236,29 +254,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Some((Some(&scrutinee_place), scrutinee_span)),\n                     );\n \n-                    let arm_block;\n-                    if candidates.len() == 1 {\n-                        arm_block = this.bind_and_guard_matched_candidate(\n-                            candidates.pop().unwrap(),\n-                            arm.guard.clone(),\n-                            &fake_borrow_temps,\n-                            scrutinee_span,\n-                            match_scope,\n-                        );\n-                    } else {\n-                        arm_block = this.cfg.start_new_block();\n-                        for candidate in candidates {\n-                            this.clear_top_scope(arm.scope);\n-                            let binding_end = this.bind_and_guard_matched_candidate(\n-                                candidate,\n-                                arm.guard.clone(),\n-                                &fake_borrow_temps,\n-                                scrutinee_span,\n-                                match_scope,\n-                            );\n-                            this.cfg.goto(binding_end, source_info, arm_block);\n-                        }\n-                    }\n+                    let arm_block = this.bind_pattern(\n+                        outer_source_info,\n+                        candidates,\n+                        arm.guard.as_ref().map(|g| (g, match_scope)),\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        arm.scope,\n+                    );\n \n                     if let Some(source_scope) = scope {\n                         this.source_scope = source_scope;\n@@ -281,6 +284,44 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         end_block.unit()\n     }\n \n+    /// Binds the variables and ascribes types for a given `match` arm.\n+    ///\n+    /// Also check if the guard matches, if it's provided.\n+    fn bind_pattern(\n+        &mut self,\n+        outer_source_info: SourceInfo,\n+        mut candidates: Vec<Candidate<'_, 'tcx>>,\n+        guard: Option<(&Guard<'tcx>, region::Scope)>,\n+        fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n+        scrutinee_span: Span,\n+        arm_scope: region::Scope,\n+    ) -> BasicBlock {\n+        if candidates.len() == 1 {\n+            // Avoid generating another `BasicBlock` when we only have one\n+            // candidate.\n+            self.bind_and_guard_matched_candidate(\n+                candidates.pop().unwrap(),\n+                guard,\n+                fake_borrow_temps,\n+                scrutinee_span,\n+            )\n+        } else {\n+            let arm_block = self.cfg.start_new_block();\n+            for candidate in candidates {\n+                // Avoid scheduling drops multiple times.\n+                self.clear_top_scope(arm_scope);\n+                let binding_end = self.bind_and_guard_matched_candidate(\n+                    candidate,\n+                    guard,\n+                    fake_borrow_temps,\n+                    scrutinee_span,\n+                );\n+                self.cfg.goto(binding_end, outer_source_info, arm_block);\n+            }\n+            arm_block\n+        }\n+    }\n+\n     pub(super) fn expr_into_pattern(\n         &mut self,\n         mut block: BasicBlock,\n@@ -1157,13 +1198,33 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.perform_test(block, &match_place, &test, make_target_blocks);\n     }\n \n-    // Determine the fake borrows that are needed to ensure that the place\n-    // will evaluate to the same thing until an arm has been chosen.\n+    /// Determine the fake borrows that are needed from a set of places that\n+    /// have to be stable across match guards.\n+    ///\n+    /// Returns a list of places that need a fake borrow and the temporary\n+    /// that's used to store the fake borrow.\n+    ///\n+    /// Match exhaustiveness checking is not able to handle the case where the\n+    /// place being matched on is mutated in the guards. We add \"fake borrows\"\n+    /// to the guards that prevent any mutation of the place being matched.\n+    /// There are a some subtleties:\n+    ///\n+    /// 1. Borrowing `*x` doesn't prevent assigning to `x`. If `x` is a shared\n+    ///    reference, the borrow isn't even tracked. As such we have to add fake\n+    ///    borrows of any prefixes of a place\n+    /// 2. We don't want `match x { _ => (), }` to conflict with mutable\n+    ///    borrows of `x`, so we only add fake borrows for places which are\n+    ///    bound or tested by the match.\n+    /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n+    ///    so we use a special BorrowKind for them.\n+    /// 4. The fake borrows may be of places in inactive variants, so it would\n+    ///    be UB to generate code for them. They therefore have to be removed\n+    ///    by a MIR pass run after borrow checking.\n     fn calculate_fake_borrows<'b>(\n         &mut self,\n         fake_borrows: &'b FxHashSet<Place<'tcx>>,\n         temp_span: Span,\n-    ) -> Vec<(PlaceRef<'b, 'tcx>, Local)> {\n+    ) -> Vec<(Place<'tcx>, Local)> {\n         let tcx = self.hir.tcx();\n \n         debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n@@ -1195,14 +1256,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         all_fake_borrows\n             .into_iter()\n-            .map(|matched_place| {\n-                let fake_borrow_deref_ty = Place::ty_from(\n-                    matched_place.base,\n-                    matched_place.projection,\n-                    &self.local_decls,\n-                    tcx,\n-                )\n-                .ty;\n+            .map(|matched_place_ref| {\n+                let matched_place = Place {\n+                    base: matched_place_ref.base.clone(),\n+                    projection: tcx.intern_place_elems(matched_place_ref.projection),\n+                };\n+                let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n                 let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n                 let fake_borrow_temp =\n                     self.local_decls.push(LocalDecl::new_temp(fake_borrow_ty, temp_span));\n@@ -1228,10 +1287,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_and_guard_matched_candidate<'pat>(\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n-        guard: Option<Guard<'tcx>>,\n-        fake_borrows: &Vec<(PlaceRef<'_, 'tcx>, Local)>,\n+        guard: Option<(&Guard<'tcx>, region::Scope)>,\n+        fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n-        region_scope: region::Scope,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1341,7 +1399,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //      the reference that we create for the arm.\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n-        if let Some(guard) = guard {\n+        if let Some((guard, region_scope)) = guard {\n             let tcx = self.hir.tcx();\n \n             self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n@@ -1358,21 +1416,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let re_erased = tcx.lifetimes.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n             for (place, temp) in fake_borrows {\n-                let borrow = Rvalue::Ref(\n-                    re_erased,\n-                    BorrowKind::Shallow,\n-                    Place {\n-                        base: place.base.clone(),\n-                        projection: tcx.intern_place_elems(place.projection),\n-                    },\n-                );\n+                let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, place.clone());\n                 self.cfg.push_assign(block, scrutinee_source_info, &Place::from(*temp), borrow);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = match guard {\n-                Guard::If(e) => self.hir.mirror(e),\n+                Guard::If(e) => self.hir.mirror(e.clone()),\n             };\n             let source_info = self.source_info(guard.span);\n             let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));"}, {"sha": "5ecf393179ce63281956f77ff4d4584419bcc675", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -616,7 +616,7 @@ where\n         // RustCall pseudo-ABI untuples the last argument.\n         spread_arg = Some(Local::new(arguments.len()));\n     }\n-    info!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n+    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;"}, {"sha": "a0aead9891101ad9ba6f14847235e97aa6a9699e", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -27,13 +27,15 @@ use std::fmt;\n enum NonConstExpr {\n     Loop(hir::LoopSource),\n     Match(hir::MatchSource),\n+    OrPattern,\n }\n \n impl NonConstExpr {\n-    fn name(self) -> &'static str {\n+    fn name(self) -> String {\n         match self {\n-            Self::Loop(src) => src.name(),\n-            Self::Match(src) => src.name(),\n+            Self::Loop(src) => format!(\"`{}`\", src.name()),\n+            Self::Match(src) => format!(\"`{}`\", src.name()),\n+            Self::OrPattern => format!(\"or-pattern\"),\n         }\n     }\n \n@@ -44,7 +46,8 @@ impl NonConstExpr {\n         let gates: &[_] = match self {\n             Self::Match(Normal)\n             | Self::Match(IfDesugar { .. })\n-            | Self::Match(IfLetDesugar { .. }) => &[sym::const_if_match],\n+            | Self::Match(IfLetDesugar { .. })\n+            | Self::OrPattern => &[sym::const_if_match],\n \n             Self::Loop(Loop) => &[sym::const_loop],\n \n@@ -144,7 +147,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n         let const_kind = self\n             .const_kind\n             .expect(\"`const_check_violated` may only be called inside a const context\");\n-        let msg = format!(\"`{}` is not allowed in a `{}`\", expr.name(), const_kind);\n+        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind);\n \n         let required_gates = required_gates.unwrap_or(&[]);\n         let missing_gates: Vec<_> =\n@@ -211,6 +214,15 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         self.recurse_into(kind, |this| hir::intravisit::walk_body(this, body));\n     }\n \n+    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+        if self.const_kind.is_some() {\n+            if let hir::PatKind::Or { .. } = p.kind {\n+                self.const_check_violated(NonConstExpr::OrPattern, p.span);\n+            }\n+        }\n+        hir::intravisit::walk_pat(self, p)\n+    }\n+\n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         match &e.kind {\n             // Skip the following checks if we are not currently in a const context."}, {"sha": "38c17bbbde7973d226e8978bffeafd3282f999be", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -872,8 +872,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],\n                        \"dump facts from NLL analysis into side files\"),\n-    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n-        \"in match codegen, do not include FakeRead statements (used by mir-borrowck)\"),\n     dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n         \"emit diagnostics rather than buffering (breaks NLL error downgrading, sorting).\"),\n     polonius: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "d73dcf26666483b388192b96ec1cafd49f601aaf", "filename": "src/test/ui/or-patterns/feature-gate-const-fn.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.rs?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -0,0 +1,36 @@\n+#![feature(or_patterns)]\n+#![allow(incomplete_features)]\n+\n+const fn foo((Ok(a) | Err(a)): Result<i32, i32>) {\n+    //~^ ERROR or-pattern is not allowed in a `const fn`\n+    let x = Ok(3);\n+    let Ok(y) | Err(y) = x;\n+    //~^ ERROR or-pattern is not allowed in a `const fn`\n+}\n+\n+const X: () = {\n+    let x = Ok(3);\n+    let Ok(y) | Err(y) = x;\n+    //~^ ERROR or-pattern is not allowed in a `const`\n+};\n+\n+static Y: () = {\n+    let x = Ok(3);\n+    let Ok(y) | Err(y) = x;\n+    //~^ ERROR or-pattern is not allowed in a `static`\n+};\n+\n+static mut Z: () = {\n+    let x = Ok(3);\n+    let Ok(y) | Err(y) = x;\n+    //~^ ERROR or-pattern is not allowed in a `static mut`\n+};\n+\n+fn main() {\n+    let _: [(); {\n+        let x = Ok(3);\n+        let Ok(y) | Err(y) = x;\n+        //~^ ERROR or-pattern is not allowed in a `const`\n+        2\n+    }];\n+}"}, {"sha": "26143d2f19d335f3268b96f1bfea0e71ec7adbed", "filename": "src/test/ui/or-patterns/feature-gate-const-fn.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e0a1c09108b52e41113520c7fa516480a8b67f9/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.stderr?ref=3e0a1c09108b52e41113520c7fa516480a8b67f9", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: or-pattern is not allowed in a `const fn`\n+  --> $DIR/feature-gate-const-fn.rs:4:15\n+   |\n+LL | const fn foo((Ok(a) | Err(a)): Result<i32, i32>) {\n+   |               ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n+   = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+\n+error[E0658]: or-pattern is not allowed in a `const fn`\n+  --> $DIR/feature-gate-const-fn.rs:7:9\n+   |\n+LL |     let Ok(y) | Err(y) = x;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n+   = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+\n+error[E0658]: or-pattern is not allowed in a `const`\n+  --> $DIR/feature-gate-const-fn.rs:13:9\n+   |\n+LL |     let Ok(y) | Err(y) = x;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n+   = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+\n+error[E0658]: or-pattern is not allowed in a `static`\n+  --> $DIR/feature-gate-const-fn.rs:19:9\n+   |\n+LL |     let Ok(y) | Err(y) = x;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n+   = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+\n+error[E0658]: or-pattern is not allowed in a `static mut`\n+  --> $DIR/feature-gate-const-fn.rs:25:9\n+   |\n+LL |     let Ok(y) | Err(y) = x;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n+   = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+\n+error[E0658]: or-pattern is not allowed in a `const`\n+  --> $DIR/feature-gate-const-fn.rs:32:13\n+   |\n+LL |         let Ok(y) | Err(y) = x;\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n+   = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}]}