{"sha": "7130fc54e05e247f93c7ecc2d10f56b314c97831", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMzBmYzU0ZTA1ZTI0N2Y5M2M3ZWNjMmQxMGY1NmIzMTRjOTc4MzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T22:04:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T22:04:23Z"}, "message": "Auto merge of #64972 - Centril:rollup-gcawast, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #63416 (apfloat: improve doc comments)\n - #64820 (BTreeSet intersection, is_subset & difference optimizations)\n - #64910 (syntax: cleanup param, method, and misc parsing)\n - #64912 (Remove unneeded `fn main` blocks from docs)\n - #64933 (Fixes #64919. Suggest fix based on operator precendence.)\n - #64943 (Add lower bound doctests for `saturating_{add,sub}` signed ints)\n - #64950 (Simplify interners)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "978f8c357723da483f92ac6791f82f5f55172f74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/978f8c357723da483f92ac6791f82f5f55172f74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7130fc54e05e247f93c7ecc2d10f56b314c97831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7130fc54e05e247f93c7ecc2d10f56b314c97831", "html_url": "https://github.com/rust-lang/rust/commit/7130fc54e05e247f93c7ecc2d10f56b314c97831", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7130fc54e05e247f93c7ecc2d10f56b314c97831/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702b45e409495a41afcccbe87a251a692b0cefab", "url": "https://api.github.com/repos/rust-lang/rust/commits/702b45e409495a41afcccbe87a251a692b0cefab", "html_url": "https://github.com/rust-lang/rust/commit/702b45e409495a41afcccbe87a251a692b0cefab"}, {"sha": "adc0dc5871ac49543ae94827e7c4d411756e3d47", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc0dc5871ac49543ae94827e7c4d411756e3d47", "html_url": "https://github.com/rust-lang/rust/commit/adc0dc5871ac49543ae94827e7c4d411756e3d47"}], "stats": {"total": 2185, "additions": 1093, "deletions": 1092}, "files": [{"sha": "b2789a535fe498827bd78573e1fdf20d3b34efc3", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -29,10 +29,8 @@\n //!     Nil,\n //! }\n //!\n-//! fn main() {\n-//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n-//!     println!(\"{:?}\", list);\n-//! }\n+//! let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n+//! println!(\"{:?}\", list);\n //! ```\n //!\n //! This will print `Cons(1, Cons(2, Nil))`.\n@@ -375,14 +373,12 @@ impl<T: ?Sized> Box<T> {\n     /// ```\n     /// #![feature(box_into_raw_non_null)]\n     ///\n-    /// fn main() {\n-    ///     let x = Box::new(5);\n-    ///     let ptr = Box::into_raw_non_null(x);\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw_non_null(x);\n     ///\n-    ///     // Clean up the memory by converting the NonNull pointer back\n-    ///     // into a Box and letting the Box be dropped.\n-    ///     let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n-    /// }\n+    /// // Clean up the memory by converting the NonNull pointer back\n+    /// // into a Box and letting the Box be dropped.\n+    /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -428,23 +424,19 @@ impl<T: ?Sized> Box<T> {\n     /// Simple usage:\n     ///\n     /// ```\n-    /// fn main() {\n-    ///     let x = Box::new(41);\n-    ///     let static_ref: &'static mut usize = Box::leak(x);\n-    ///     *static_ref += 1;\n-    ///     assert_eq!(*static_ref, 42);\n-    /// }\n+    /// let x = Box::new(41);\n+    /// let static_ref: &'static mut usize = Box::leak(x);\n+    /// *static_ref += 1;\n+    /// assert_eq!(*static_ref, 42);\n     /// ```\n     ///\n     /// Unsized data:\n     ///\n     /// ```\n-    /// fn main() {\n-    ///     let x = vec![1, 2, 3].into_boxed_slice();\n-    ///     let static_ref = Box::leak(x);\n-    ///     static_ref[0] = 4;\n-    ///     assert_eq!(*static_ref, [4, 2, 3]);\n-    /// }\n+    /// let x = vec![1, 2, 3].into_boxed_slice();\n+    /// let static_ref = Box::leak(x);\n+    /// static_ref[0] = 4;\n+    /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n     #[inline]\n@@ -780,11 +772,9 @@ impl Box<dyn Any> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Box::new(my_string));\n-    ///     print_if_string(Box::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Box::new(my_string));\n+    /// print_if_string(Box::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n         if self.is::<T>() {\n@@ -814,11 +804,9 @@ impl Box<dyn Any + Send> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Box::new(my_string));\n-    ///     print_if_string(Box::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Box::new(my_string));\n+    /// print_if_string(Box::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n         <Box<dyn Any>>::downcast(self).map_err(|s| unsafe {"}, {"sha": "83fd4485f7321dbc6e15693d78fa8ac04f7e4ff8", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -2226,14 +2226,12 @@ impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # fn main() {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n     /// map.entry(\"poneyland\").or_default();\n     ///\n     /// assert_eq!(map[\"poneyland\"], None);\n-    /// # }\n     /// ```\n     pub fn or_default(self) -> &'a mut V {\n         match self {"}, {"sha": "8250fc38ccd1c7a0b4d556294b128d5d8d699714", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 155, "deletions": 75, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -122,13 +122,16 @@ pub struct Difference<'a, T: 'a> {\n }\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n+        // iterate all of self and some of other, spotting matches along the way\n         self_iter: Iter<'a, T>,\n         other_iter: Peekable<Iter<'a, T>>,\n     },\n     Search {\n+        // iterate a small set, look up in the large set\n         self_iter: Iter<'a, T>,\n         other_set: &'a BTreeSet<T>,\n     },\n+    Iterate(Iter<'a, T>), // simply stream self's elements\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -147,6 +150,7 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n                 self_iter,\n                 other_set: _,\n             } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n+            DifferenceInner::Iterate(iter) => f.debug_tuple(\"Difference\").field(&iter).finish(),\n         }\n     }\n }\n@@ -187,13 +191,16 @@ pub struct Intersection<'a, T: 'a> {\n }\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n+        // iterate similarly sized sets jointly, spotting matches along the way\n         a: Iter<'a, T>,\n         b: Iter<'a, T>,\n     },\n     Search {\n+        // iterate a small set, look up in the large set\n         small_iter: Iter<'a, T>,\n         large_set: &'a BTreeSet<T>,\n     },\n+    Answer(Option<&'a T>), // return a specific value or emptiness\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -212,6 +219,9 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n                 small_iter,\n                 large_set: _,\n             } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n+            IntersectionInner::Answer(answer) => {\n+                f.debug_tuple(\"Intersection\").field(&answer).finish()\n+            }\n         }\n     }\n }\n@@ -314,24 +324,51 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Self is bigger than or not much smaller than other set.\n-            // Iterate both sets jointly, spotting matches along the way.\n-            Difference {\n-                inner: DifferenceInner::Stitch {\n-                    self_iter: self.iter(),\n-                    other_iter: other.iter().peekable(),\n-                },\n-            }\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n         } else {\n-            // Self is much smaller than other set, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            Difference {\n-                inner: DifferenceInner::Search {\n-                    self_iter: self.iter(),\n-                    other_set: other,\n-                },\n-            }\n+            return Difference {\n+                inner: DifferenceInner::Iterate(self.iter()),\n+            };\n+        };\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n+        } else {\n+            return Difference {\n+                inner: DifferenceInner::Iterate(self.iter()),\n+            };\n+        };\n+        Difference {\n+            inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n+                (Greater, _) | (_, Less) => DifferenceInner::Iterate(self.iter()),\n+                (Equal, _) => {\n+                    let mut self_iter = self.iter();\n+                    self_iter.next();\n+                    DifferenceInner::Iterate(self_iter)\n+                }\n+                (_, Equal) => {\n+                    let mut self_iter = self.iter();\n+                    self_iter.next_back();\n+                    DifferenceInner::Iterate(self_iter)\n+                }\n+                _ => {\n+                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+                        DifferenceInner::Search {\n+                            self_iter: self.iter(),\n+                            other_set: other,\n+                        }\n+                    } else {\n+                        DifferenceInner::Stitch {\n+                            self_iter: self.iter(),\n+                            other_iter: other.iter().peekable(),\n+                        }\n+                    }\n+                }\n+            },\n         }\n     }\n \n@@ -387,29 +424,48 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        let (small, other) = if self.len() <= other.len() {\n-            (self, other)\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n         } else {\n-            (other, self)\n+            return Intersection {\n+                inner: IntersectionInner::Answer(None),\n+            };\n         };\n-        if small.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Small set is not much smaller than other set.\n-            // Iterate both sets jointly, spotting matches along the way.\n-            Intersection {\n-                inner: IntersectionInner::Stitch {\n-                    a: small.iter(),\n-                    b: other.iter(),\n-                },\n-            }\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n         } else {\n-            // Big difference in number of elements, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            Intersection {\n-                inner: IntersectionInner::Search {\n-                    small_iter: small.iter(),\n-                    large_set: other,\n-                },\n-            }\n+            return Intersection {\n+                inner: IntersectionInner::Answer(None),\n+            };\n+        };\n+        Intersection {\n+            inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n+                (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n+                (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n+                (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n+                _ => {\n+                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+                        IntersectionInner::Search {\n+                            small_iter: self.iter(),\n+                            large_set: other,\n+                        }\n+                    } else if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+                        IntersectionInner::Search {\n+                            small_iter: other.iter(),\n+                            large_set: self,\n+                        }\n+                    } else {\n+                        IntersectionInner::Stitch {\n+                            a: self.iter(),\n+                            b: other.iter(),\n+                        }\n+                    }\n+                }\n+            },\n         }\n     }\n \n@@ -544,43 +600,61 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Same result as self.difference(other).next().is_none()\n-        // but the 3 paths below are faster (in order: hugely, 20%, 5%).\n+        // but the code below is faster (hugely in some cases).\n         if self.len() > other.len() {\n-            false\n-        } else if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Self is not much smaller than other set.\n-            // Stolen from TreeMap\n-            let mut x = self.iter();\n-            let mut y = other.iter();\n-            let mut a = x.next();\n-            let mut b = y.next();\n-            while a.is_some() {\n-                if b.is_none() {\n+            return false;\n+        }\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n+        } else {\n+            return true; // self is empty\n+        };\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n+        } else {\n+            return false; // other is empty\n+        };\n+        let mut self_iter = self.iter();\n+        match self_min.cmp(other_min) {\n+            Less => return false,\n+            Equal => {\n+                self_iter.next();\n+            }\n+            Greater => (),\n+        }\n+        match self_max.cmp(other_max) {\n+            Greater => return false,\n+            Equal => {\n+                self_iter.next_back();\n+            }\n+            Less => (),\n+        }\n+        if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Big difference in number of elements.\n+            for next in self_iter {\n+                if !other.contains(next) {\n                     return false;\n                 }\n-\n-                let a1 = a.unwrap();\n-                let b1 = b.unwrap();\n-\n-                match b1.cmp(a1) {\n-                    Less => (),\n-                    Greater => return false,\n-                    Equal => a = x.next(),\n-                }\n-\n-                b = y.next();\n             }\n-            true\n         } else {\n-            // Big difference in number of elements, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            for next in self {\n-                if !other.contains(next) {\n-                    return false;\n+            // Self is not much smaller than other set.\n+            let mut other_iter = other.iter();\n+            other_iter.next();\n+            other_iter.next_back();\n+            let mut self_next = self_iter.next();\n+            while let Some(self1) = self_next {\n+                match other_iter.next().map_or(Less, |other1| self1.cmp(other1)) {\n+                    Less => return false,\n+                    Equal => self_next = self_iter.next(),\n+                    Greater => (),\n                 }\n             }\n-            true\n         }\n+        true\n     }\n \n     /// Returns `true` if the set is a superset of another,\n@@ -1120,6 +1194,7 @@ impl<T> Clone for Difference<'_, T> {\n                     self_iter: self_iter.clone(),\n                     other_set,\n                 },\n+                DifferenceInner::Iterate(iter) => DifferenceInner::Iterate(iter.clone()),\n             },\n         }\n     }\n@@ -1138,7 +1213,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                 loop {\n                     match other_iter\n                         .peek()\n-                        .map_or(Less, |other_next| Ord::cmp(self_next, other_next))\n+                        .map_or(Less, |other_next| self_next.cmp(other_next))\n                     {\n                         Less => return Some(self_next),\n                         Equal => {\n@@ -1160,19 +1235,21 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                     return Some(self_next);\n                 }\n             },\n+            DifferenceInner::Iterate(iter) => iter.next(),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (self_len, other_len) = match &self.inner {\n             DifferenceInner::Stitch {\n                 self_iter,\n-                other_iter\n+                other_iter,\n             } => (self_iter.len(), other_iter.len()),\n             DifferenceInner::Search {\n                 self_iter,\n-                other_set\n+                other_set,\n             } => (self_iter.len(), other_set.len()),\n+            DifferenceInner::Iterate(iter) => (iter.len(), 0),\n         };\n         (self_len.saturating_sub(other_len), Some(self_len))\n     }\n@@ -1234,6 +1311,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(answer.clone()),\n             },\n         }\n     }\n@@ -1251,7 +1329,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                 let mut a_next = a.next()?;\n                 let mut b_next = b.next()?;\n                 loop {\n-                    match Ord::cmp(a_next, b_next) {\n+                    match a_next.cmp(b_next) {\n                         Less => a_next = a.next()?,\n                         Greater => b_next = b.next()?,\n                         Equal => return Some(a_next),\n@@ -1267,15 +1345,17 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                     return Some(small_next);\n                 }\n             },\n+            IntersectionInner::Answer(answer) => answer.take(),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let min_len = match &self.inner {\n-            IntersectionInner::Stitch { a, b } => min(a.len(), b.len()),\n-            IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n-        };\n-        (0, Some(min_len))\n+        match &self.inner {\n+            IntersectionInner::Stitch { a, b } => (0, Some(min(a.len(), b.len()))),\n+            IntersectionInner::Search { small_iter, .. } => (0, Some(small_iter.len())),\n+            IntersectionInner::Answer(None) => (0, Some(0)),\n+            IntersectionInner::Answer(Some(_)) => (1, Some(1)),\n+        }\n     }\n }\n "}, {"sha": "a28c6d22abb9537ddf6f97357748978dc67bca35", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -861,11 +861,9 @@ impl Rc<dyn Any> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Rc::new(my_string));\n-    ///     print_if_string(Rc::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Rc::new(my_string));\n+    /// print_if_string(Rc::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {"}, {"sha": "4e4a285c21dab65eadc6914768f8fb2518f82bae", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -412,20 +412,15 @@ impl<T> [T] {\n     ///\n     /// ```\n     /// #![feature(repeat_generic_slice)]\n-    ///\n-    /// fn main() {\n-    ///     assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n-    /// }\n+    /// assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n     /// ```\n     ///\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n     /// #![feature(repeat_generic_slice)]\n-    /// fn main() {\n-    ///     // this will panic at runtime\n-    ///     b\"0123456789abcdef\".repeat(usize::max_value());\n-    /// }\n+    /// // this will panic at runtime\n+    /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[unstable(feature = \"repeat_generic_slice\",\n                reason = \"it's on str, why not on slice?\","}, {"sha": "9231c2d3f1d56e40546f002128b3cd412bd08243", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -500,10 +500,8 @@ impl str {\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n-    /// fn main() {\n-    ///     // this will panic at runtime\n-    ///     \"0123456789abcdef\".repeat(usize::max_value());\n-    /// }\n+    /// // this will panic at runtime\n+    /// \"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {"}, {"sha": "639124e26cc20e80ae8f873943f28035fd6a65ef", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -164,10 +164,8 @@ use crate::vec::Vec;\n ///\n /// fn example_func<A: TraitExample>(example_arg: A) {}\n ///\n-/// fn main() {\n-///     let example_string = String::from(\"example_string\");\n-///     example_func(&example_string);\n-/// }\n+/// let example_string = String::from(\"example_string\");\n+/// example_func(&example_string);\n /// ```\n ///\n /// There are two options that would work instead. The first would be to"}, {"sha": "5977e69b7fa0f297125b1ecab3e81374505dd4ce", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -1244,11 +1244,9 @@ impl Arc<dyn Any + Send + Sync> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Arc::new(my_string));\n-    ///     print_if_string(Arc::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Arc::new(my_string));\n+    /// print_if_string(Arc::new(0i8));\n     /// ```\n     pub fn downcast<T>(self) -> Result<Arc<T>, Self>\n     where"}, {"sha": "5c611fd21d21bedf9584bca4119adf662ecd17f6", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 92, "deletions": 18, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -48,7 +48,9 @@ fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n     f(&set_a,\n       &set_b,\n       &mut |&x| {\n-          assert_eq!(x, expected[i]);\n+          if i < expected.len() {\n+              assert_eq!(x, expected[i]);\n+          }\n           i += 1;\n           true\n       });\n@@ -74,31 +76,36 @@ fn test_intersection() {\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n     check_intersection(&[-1], &large, &[]);\n     check_intersection(&large, &[-1], &[]);\n     check_intersection(&[0], &large, &[0]);\n     check_intersection(&large, &[0], &[0]);\n-    check_intersection(&[999], &large, &[999]);\n-    check_intersection(&large, &[999], &[999]);\n-    check_intersection(&[1000], &large, &[]);\n-    check_intersection(&large, &[1000], &[]);\n-    check_intersection(&[11, 5000, 1, 3, 77, 8924, 103],\n+    check_intersection(&[99], &large, &[99]);\n+    check_intersection(&large, &[99], &[99]);\n+    check_intersection(&[100], &large, &[]);\n+    check_intersection(&large, &[100], &[]);\n+    check_intersection(&[11, 5000, 1, 3, 77, 8924],\n                        &large,\n-                       &[1, 3, 11, 77, 103]);\n+                       &[1, 3, 11, 77]);\n }\n \n #[test]\n fn test_intersection_size_hint() {\n     let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n     let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n     let mut iter = x.intersection(&y);\n-    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n     assert_eq!(iter.next(), Some(&3));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n+\n+    iter = y.intersection(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n }\n \n #[test]\n@@ -111,6 +118,9 @@ fn test_difference() {\n     check_difference(&[1, 12], &[], &[1, 12]);\n     check_difference(&[], &[1, 2, 3, 9], &[]);\n     check_difference(&[1, 3, 5, 9, 11], &[3, 9], &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[3, 6, 9], &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[0, 1], &[3, 5, 9, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[11, 12], &[1, 3, 5, 9]);\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n@@ -119,18 +129,82 @@ fn test_difference() {\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n     check_difference(&[0], &large, &[]);\n-    check_difference(&[999], &large, &[]);\n-    check_difference(&[1000], &large, &[1000]);\n-    check_difference(&[11, 5000, 1, 3, 77, 8924, 103],\n+    check_difference(&[99], &large, &[]);\n+    check_difference(&[100], &large, &[100]);\n+    check_difference(&[11, 5000, 1, 3, 77, 8924],\n                      &large,\n                      &[5000, 8924]);\n     check_difference(&large, &[], &large);\n     check_difference(&large, &[-1], &large);\n-    check_difference(&large, &[1000], &large);\n+    check_difference(&large, &[100], &large);\n+}\n+\n+#[test]\n+fn test_difference_size_hint() {\n+    let s246: BTreeSet<i32> = [2, 4, 6].iter().copied().collect();\n+    let s23456: BTreeSet<i32> = (2..=6).collect();\n+    let mut iter = s246.difference(&s23456);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s12345: BTreeSet<i32> = (1..=5).collect();\n+    iter = s246.difference(&s12345);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&6));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s34567: BTreeSet<i32> = (3..=7).collect();\n+    iter = s246.difference(&s34567);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s1: BTreeSet<i32> = (-9..=1).collect();\n+    iter = s246.difference(&s1);\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n+\n+    let s2: BTreeSet<i32> = (-9..=2).collect();\n+    iter = s246.difference(&s2);\n+    assert_eq!(iter.size_hint(), (2, Some(2)));\n+    assert_eq!(iter.next(), Some(&4));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s23: BTreeSet<i32> = (2..=3).collect();\n+    iter = s246.difference(&s23);\n+    assert_eq!(iter.size_hint(), (1, Some(3)));\n+    assert_eq!(iter.next(), Some(&4));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s4: BTreeSet<i32> = (4..=4).collect();\n+    iter = s246.difference(&s4);\n+    assert_eq!(iter.size_hint(), (2, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+    assert_eq!(iter.next(), Some(&6));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s56: BTreeSet<i32> = (5..=6).collect();\n+    iter = s246.difference(&s56);\n+    assert_eq!(iter.size_hint(), (1, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+\n+    let s6: BTreeSet<i32> = (6..=19).collect();\n+    iter = s246.difference(&s6);\n+    assert_eq!(iter.size_hint(), (2, Some(2)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s7: BTreeSet<i32> = (7..=19).collect();\n+    iter = s246.difference(&s7);\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n }\n \n #[test]\n@@ -188,23 +262,23 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n     assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n     assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 11, 34, 22, 38, 33, 42, 39, 40]),\n+                         &[-12, -5, 11, 14, 22, 23, 33, 34, 38, 39, 40, 42]),\n                true);\n     assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 34, 38, 22, 11]),\n+                         &[-12, -5, 11, 14, 22, 23, 34, 38]),\n                false);\n \n     if cfg!(miri) { // Miri is too slow\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n     assert_eq!(is_subset(&[-1], &large), false);\n     assert_eq!(is_subset(&[0], &large), true);\n     assert_eq!(is_subset(&[1, 2], &large), true);\n-    assert_eq!(is_subset(&[999, 1000], &large), false);\n+    assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n #[test]"}, {"sha": "6350b189c5faa47294fafd8193ced9a7d81802d0", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -389,28 +389,26 @@ impl<T> Vec<T> {\n     /// use std::ptr;\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let mut v = vec![1, 2, 3];\n-    ///\n-    ///     // Pull out the various important pieces of information about `v`\n-    ///     let p = v.as_mut_ptr();\n-    ///     let len = v.len();\n-    ///     let cap = v.capacity();\n+    /// let mut v = vec![1, 2, 3];\n     ///\n-    ///     unsafe {\n-    ///         // Cast `v` into the void: no destructor run, so we are in\n-    ///         // complete control of the allocation to which `p` points.\n-    ///         mem::forget(v);\n+    /// // Pull out the various important pieces of information about `v`\n+    /// let p = v.as_mut_ptr();\n+    /// let len = v.len();\n+    /// let cap = v.capacity();\n     ///\n-    ///         // Overwrite memory with 4, 5, 6\n-    ///         for i in 0..len as isize {\n-    ///             ptr::write(p.offset(i), 4 + i);\n-    ///         }\n+    /// unsafe {\n+    ///     // Cast `v` into the void: no destructor run, so we are in\n+    ///     // complete control of the allocation to which `p` points.\n+    ///     mem::forget(v);\n     ///\n-    ///         // Put everything back together into a Vec\n-    ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, [4, 5, 6]);\n+    ///     // Overwrite memory with 4, 5, 6\n+    ///     for i in 0..len as isize {\n+    ///         ptr::write(p.offset(i), 4 + i);\n     ///     }\n+    ///\n+    ///     // Put everything back together into a Vec\n+    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n+    ///     assert_eq!(rebuilt, [4, 5, 6]);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1391,12 +1389,10 @@ impl<T> Vec<T> {\n     /// ```\n     /// #![feature(vec_leak)]\n     ///\n-    /// fn main() {\n-    ///     let x = vec![1, 2, 3];\n-    ///     let static_ref: &'static mut [usize] = Vec::leak(x);\n-    ///     static_ref[0] += 1;\n-    ///     assert_eq!(static_ref, &[2, 2, 3]);\n-    /// }\n+    /// let x = vec![1, 2, 3];\n+    /// let static_ref: &'static mut [usize] = Vec::leak(x);\n+    /// static_ref[0] += 1;\n+    /// assert_eq!(static_ref, &[2, 2, 3]);\n     /// ```\n     #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n     #[inline]"}, {"sha": "85b59162620fab9791541adcc7ef63c8f82c12bb", "filename": "src/libcore/any.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -87,10 +87,8 @@ pub trait Any: 'static {\n     ///     TypeId::of::<String>() == s.type_id()\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n+    /// assert_eq!(is_string(&0), false);\n+    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"get_type_id\", since = \"1.34.0\")]\n     fn type_id(&self) -> TypeId;\n@@ -145,10 +143,8 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -179,10 +175,8 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -210,16 +204,14 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -250,10 +242,8 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -276,10 +266,8 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -300,16 +288,14 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -334,10 +320,8 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -360,10 +344,8 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -384,16 +366,14 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -437,10 +417,8 @@ impl TypeId {\n     ///     TypeId::of::<String>() == TypeId::of::<T>()\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n+    /// assert_eq!(is_string(&0), false);\n+    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature=\"const_type_id\")]"}, {"sha": "c456e14db12d4f311f43177458301a9c316dd2a1", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -111,11 +111,9 @@ impl From<char> for u32 {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let c = 'c';\n-    ///     let u = u32::from(c);\n-    ///     assert!(4 == mem::size_of_val(&u))\n-    /// }\n+    /// let c = 'c';\n+    /// let u = u32::from(c);\n+    /// assert!(4 == mem::size_of_val(&u))\n     /// ```\n     #[inline]\n     fn from(c: char) -> Self {\n@@ -150,11 +148,9 @@ impl From<u8> for char {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let u = 32 as u8;\n-    ///     let c = char::from(u);\n-    ///     assert!(4 == mem::size_of_val(&c))\n-    /// }\n+    /// let u = 32 as u8;\n+    /// let c = char::from(u);\n+    /// assert!(4 == mem::size_of_val(&c))\n     /// ```\n     #[inline]\n     fn from(i: u8) -> Self {"}, {"sha": "b71c9c2c40b37878c3253e1469f367218b1d062d", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -31,39 +31,41 @@ pub struct DecodeUtf16Error {\n /// ```\n /// use std::char::decode_utf16;\n ///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [\n+///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+/// ];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///                            .collect::<Vec<_>>(),\n-///                vec![Ok('\ud834\udd1e'),\n-///                     Ok('m'), Ok('u'), Ok('s'),\n-///                     Err(0xDD1E),\n-///                     Ok('i'), Ok('c'),\n-///                     Err(0xD834)]);\n-/// }\n+/// assert_eq!(\n+///     decode_utf16(v.iter().cloned())\n+///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+///         .collect::<Vec<_>>(),\n+///     vec![\n+///         Ok('\ud834\udd1e'),\n+///         Ok('m'), Ok('u'), Ok('s'),\n+///         Err(0xDD1E),\n+///         Ok('i'), Ok('c'),\n+///         Err(0xD834)\n+///     ]\n+/// );\n /// ```\n ///\n /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n ///\n /// ```\n /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n ///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [\n+///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+/// ];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///                    .collect::<String>(),\n-///                \"\ud834\udd1emus\ufffdic\ufffd\");\n-/// }\n+/// assert_eq!(\n+///     decode_utf16(v.iter().cloned())\n+///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///        .collect::<String>(),\n+///     \"\ud834\udd1emus\ufffdic\ufffd\"\n+/// );\n /// ```\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]"}, {"sha": "5dfdd1623061e19e7fb8fb0d307bfdd0ed6f9068", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -1532,12 +1532,10 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n-    ///     assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n-    ///     assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n-    ///     assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n-    /// }\n+    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n+    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n+    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n+    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n     /// ```\n     #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n     pub fn align(&self) -> Option<Alignment> {"}, {"sha": "83ffa8f8a842ec97f5571c1a48f4d934bebea400", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -938,7 +938,9 @@ Basic usage:\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n-\"::max_value());\",\n+\"::max_value());\n+assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_add(-1), \", stringify!($SelfT),\n+\"::min_value());\",\n $EndFeature, \"\n ```\"),\n \n@@ -952,7 +954,6 @@ $EndFeature, \"\n             }\n         }\n \n-\n         doc_comment! {\n             concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n numeric bounds instead of overflowing.\n@@ -964,7 +965,9 @@ Basic usage:\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n-\"::min_value());\",\n+\"::min_value());\n+assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_sub(-1), \", stringify!($SelfT),\n+\"::max_value());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "933919185956e54c5fb65aa810c2d671327a3350", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -2732,31 +2732,29 @@ impl<T: ?Sized> Eq for *mut T {}\n /// impl Trait for Wrapper {}\n /// impl Trait for i32 {}\n ///\n-/// fn main() {\n-///     let wrapper = Wrapper { member: 10 };\n-///\n-///     // Pointers have equal addresses.\n-///     assert!(std::ptr::eq(\n-///         &wrapper as *const Wrapper as *const u8,\n-///         &wrapper.member as *const i32 as *const u8\n-///     ));\n-///\n-///     // Objects have equal addresses, but `Trait` has different implementations.\n-///     assert!(!std::ptr::eq(\n-///         &wrapper as &dyn Trait,\n-///         &wrapper.member as &dyn Trait,\n-///     ));\n-///     assert!(!std::ptr::eq(\n-///         &wrapper as &dyn Trait as *const dyn Trait,\n-///         &wrapper.member as &dyn Trait as *const dyn Trait,\n-///     ));\n-///\n-///     // Converting the reference to a `*const u8` compares by address.\n-///     assert!(std::ptr::eq(\n-///         &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n-///         &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n-///     ));\n-/// }\n+/// let wrapper = Wrapper { member: 10 };\n+///\n+/// // Pointers have equal addresses.\n+/// assert!(std::ptr::eq(\n+///     &wrapper as *const Wrapper as *const u8,\n+///     &wrapper.member as *const i32 as *const u8\n+/// ));\n+///\n+/// // Objects have equal addresses, but `Trait` has different implementations.\n+/// assert!(!std::ptr::eq(\n+///     &wrapper as &dyn Trait,\n+///     &wrapper.member as &dyn Trait,\n+/// ));\n+/// assert!(!std::ptr::eq(\n+///     &wrapper as &dyn Trait as *const dyn Trait,\n+///     &wrapper.member as &dyn Trait as *const dyn Trait,\n+/// ));\n+///\n+/// // Converting the reference to a `*const u8` compares by address.\n+/// assert!(std::ptr::eq(\n+///     &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n+///     &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n+/// ));\n /// ```\n #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n #[inline]"}, {"sha": "87b9917f340da3e9debbac2100c0d0bc90135a23", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 22, "deletions": 47, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -2189,90 +2189,65 @@ impl<'tcx> Borrow<[Goal<'tcx>]> for Interned<'tcx, List<Goal<'tcx>>> {\n     }\n }\n \n-macro_rules! intern_method {\n-    ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n-                                            $alloc_method:expr,\n-                                            $alloc_to_key:expr) -> $ty:ty) => {\n-        impl<$lt_tcx> TyCtxt<$lt_tcx> {\n-            pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n-                let key = ($alloc_to_key)(&v);\n-\n-                self.interners.$name.intern_ref(key, || {\n-                    Interned($alloc_method(&self.interners.arena, v))\n-\n-                }).0\n-            }\n-        }\n-    }\n-}\n-\n macro_rules! direct_interners {\n-    ($lt_tcx:tt, $($name:ident: $method:ident($ty:ty)),+) => {\n-        $(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n+    ($($name:ident: $method:ident($ty:ty)),+) => {\n+        $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n             }\n         }\n \n-        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n+        impl<'tcx> Eq for Interned<'tcx, $ty> {}\n \n-        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n+        impl<'tcx> Hash for Interned<'tcx, $ty> {\n             fn hash<H: Hasher>(&self, s: &mut H) {\n                 self.0.hash(s)\n             }\n         }\n \n-        intern_method!(\n-            $lt_tcx,\n-            $name: $method($ty,\n-                           |a: &$lt_tcx SyncDroplessArena, v| -> &$lt_tcx $ty { a.alloc(v) },\n-                           |x| x) -> $ty);)+\n+        impl<'tcx> TyCtxt<'tcx> {\n+            pub fn $method(self, v: $ty) -> &'tcx $ty {\n+                self.interners.$name.intern_ref(&v, || {\n+                    Interned(self.interners.arena.alloc(v))\n+                }).0\n+            }\n+        })+\n     }\n }\n \n pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n     x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n }\n \n-direct_interners!('tcx,\n+direct_interners!(\n     region: mk_region(RegionKind),\n     goal: mk_goal(GoalKind<'tcx>),\n     const_: mk_const(Const<'tcx>)\n );\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n-        $(intern_method!( 'tcx, $field: $method(\n-            &[$ty],\n-            |a, v| List::from_arena(a, v),\n-            Deref::deref) -> List<$ty>);)+\n+        $(impl<'tcx> TyCtxt<'tcx> {\n+            pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n+                self.interners.$field.intern_ref(v, || {\n+                    Interned(List::from_arena(&self.interners.arena, v))\n+                }).0\n+            }\n+        })+\n     );\n }\n \n slice_interners!(\n-    existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n-    predicates: _intern_predicates(Predicate<'tcx>),\n     type_list: _intern_type_list(Ty<'tcx>),\n     substs: _intern_substs(GenericArg<'tcx>),\n+    canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo),\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n+    predicates: _intern_predicates(Predicate<'tcx>),\n     clauses: _intern_clauses(Clause<'tcx>),\n     goal_list: _intern_goals(Goal<'tcx>),\n     projs: _intern_projs(ProjectionKind)\n );\n \n-// This isn't a perfect fit: `CanonicalVarInfo` slices are always\n-// allocated in the global arena, so this `intern_method!` macro is\n-// overly general. However, we just return `false` for the code that checks\n-// whether they belong in the thread-local arena, so no harm done, and\n-// seems better than open-coding the rest.\n-intern_method! {\n-    'tcx,\n-    canonical_var_infos: _intern_canonical_var_infos(\n-        &[CanonicalVarInfo],\n-        |a, v| List::from_arena(a, v),\n-        Deref::deref\n-    ) -> List<CanonicalVarInfo>\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n     /// that is, a `fn` type that is equivalent in every way for being"}, {"sha": "5efe4fda8ccf85f47f5764b5be18d9413d144769", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -555,12 +555,13 @@ pub trait Float\n     fn ilogb(self) -> ExpInt;\n \n     /// Returns: self * 2<sup>exp</sup> for integral exponents.\n+    /// Equivalent to C standard library function `ldexp`.\n     fn scalbn_r(self, exp: ExpInt, round: Round) -> Self;\n     fn scalbn(self, exp: ExpInt) -> Self {\n         self.scalbn_r(exp, Round::NearestTiesToEven)\n     }\n \n-    /// Equivalent of C standard library function.\n+    /// Equivalent to C standard library function with the same name.\n     ///\n     /// While the C standard says exp is an unspecified value for infinity and nan,\n     /// this returns INT_MAX for infinities, and INT_MIN for NaNs (see `ilogb`)."}, {"sha": "720d31310a13d936a3d9543a08caa8dde85784d3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -128,6 +128,7 @@ use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::source_map::{DUMMY_SP, original_sp};\n use syntax::symbol::{kw, sym};\n+use syntax::util::parser::ExprPrecedence;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::hash_map::Entry;\n@@ -4345,7 +4346,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let max_len = receiver.rfind(\".\").unwrap();\n                                 format!(\"{}{}\", &receiver[..max_len], method_call)\n                             } else {\n-                                format!(\"{}{}\", receiver, method_call)\n+                                if expr.precedence().order() < ExprPrecedence::MethodCall.order() {\n+                                    format!(\"({}){}\", receiver, method_call)\n+                                } else {\n+                                    format!(\"{}{}\", receiver, method_call)\n+                                }\n                             };\n                             Some(if is_struct_pat_shorthand_field {\n                                 format!(\"{}: {}\", receiver, sugg)"}, {"sha": "ff50051ef504043d673d3f3bdec1466093fa0850", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -192,14 +192,9 @@ use crate::sys;\n /// ```\n /// use std::collections::HashMap;\n ///\n-/// fn main() {\n-///     let timber_resources: HashMap<&str, i32> =\n-///     [(\"Norway\", 100),\n-///      (\"Denmark\", 50),\n-///      (\"Iceland\", 10)]\n-///      .iter().cloned().collect();\n-///     // use the values stored in map\n-/// }\n+/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n+///     .iter().cloned().collect();\n+/// // use the values stored in map\n /// ```\n \n #[derive(Clone)]"}, {"sha": "092fb443468483c043786407a14d2043a80be742", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -93,11 +93,9 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// fn main() {\n-///     let viking_names: HashSet<&'static str> =\n-///         [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n-///     // use the values stored in the set\n-/// }\n+/// let viking_names: HashSet<&'static str> =\n+///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n+/// // use the values stored in the set\n /// ```\n ///\n /// [`Cell`]: ../../std/cell/struct.Cell.html"}, {"sha": "f9255b82fc83e399299ec5c09686115cd0bcaf95", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -217,11 +217,9 @@ impl SocketAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n     ///\n-    /// fn main() {\n-    ///     let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    ///     assert_eq!(socket.is_ipv4(), true);\n-    ///     assert_eq!(socket.is_ipv6(), false);\n-    /// }\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), true);\n+    /// assert_eq!(socket.is_ipv6(), false);\n     /// ```\n     #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n@@ -244,12 +242,9 @@ impl SocketAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n     ///\n-    /// fn main() {\n-    ///     let socket = SocketAddr::new(\n-    ///                      IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n-    ///     assert_eq!(socket.is_ipv4(), false);\n-    ///     assert_eq!(socket.is_ipv6(), true);\n-    /// }\n+    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), false);\n+    /// assert_eq!(socket.is_ipv6(), true);\n     /// ```\n     #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {"}, {"sha": "70b68d134855087a8f83ea9a9b4aa7bf21c99db4", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 102, "deletions": 135, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -197,11 +197,8 @@ impl IpAddr {\n     ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(),\n-    ///                true);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n     /// ```\n     pub fn is_global(&self) -> bool {\n         match self {\n@@ -251,11 +248,11 @@ impl IpAddr {\n     ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0))\n-    ///                       .is_documentation(), true);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n+    ///     true\n+    /// );\n     /// ```\n     pub fn is_documentation(&self) -> bool {\n         match self {\n@@ -275,11 +272,8 @@ impl IpAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(),\n-    ///                false);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n     /// ```\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n@@ -300,11 +294,8 @@ impl IpAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(),\n-    ///                true);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n     /// ```\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n@@ -526,48 +517,46 @@ impl Ipv4Addr {\n     ///\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     // private addresses are not global\n-    ///     assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    /// // private addresses are not global\n+    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n     ///\n-    ///     // the 0.0.0.0/8 block is not global\n-    ///     assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n-    ///     // in particular, the unspecified address is not global\n-    ///     assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n+    /// // the 0.0.0.0/8 block is not global\n+    /// assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n+    /// // in particular, the unspecified address is not global\n+    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n     ///\n-    ///     // the loopback address is not global\n-    ///     assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n+    /// // the loopback address is not global\n+    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n     ///\n-    ///     // link local addresses are not global\n-    ///     assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n+    /// // link local addresses are not global\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n     ///\n-    ///     // the broadcast address is not global\n-    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n+    /// // the broadcast address is not global\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n     ///\n-    ///     // the broadcast address is not global\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n+    /// // the broadcast address is not global\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n     ///\n-    ///     // shared addresses are not global\n-    ///     assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n+    /// // shared addresses are not global\n+    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n     ///\n-    ///     // addresses reserved for protocol assignment are not global\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n+    /// // addresses reserved for protocol assignment are not global\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n     ///\n-    ///     // addresses reserved for future use are not global\n-    ///     assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n+    /// // addresses reserved for future use are not global\n+    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n     ///\n-    ///     // addresses reserved for network devices benchmarking are not global\n-    ///     assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n+    /// // addresses reserved for network devices benchmarking are not global\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n     ///\n-    ///     // All the other addresses are global\n-    ///     assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n-    ///     assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n-    /// }\n+    /// // All the other addresses are global\n+    /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n+    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n     /// ```\n     pub fn is_global(&self) -> bool {\n         // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n@@ -600,11 +589,9 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n-    ///     assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n-    ///     assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n     /// ```\n     pub fn is_shared(&self) -> bool {\n         self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n@@ -631,14 +618,12 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n-    ///     assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n+    /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n     /// ```\n     pub fn is_ietf_protocol_assignment(&self) -> bool {\n         self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n@@ -658,12 +643,10 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n-    ///     assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n-    ///     assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n-    ///     assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n     /// ```\n     pub fn is_benchmarking(&self) -> bool {\n         self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n@@ -690,15 +673,12 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n-    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n+    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n     ///\n-    ///     assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n-    ///     // The broadcast address is not considered as reserved for future use by this\n-    ///     // implementation\n-    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n+    /// // The broadcast address is not considered as reserved for future use by this implementation\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n     /// ```\n     pub fn is_reserved(&self) -> bool {\n         self.octets()[0] & 240 == 240 && !self.is_broadcast()\n@@ -788,8 +768,10 @@ impl Ipv4Addr {\n     /// ```\n     /// use std::net::{Ipv4Addr, Ipv6Addr};\n     ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n-    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767));\n+    /// assert_eq!(\n+    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n+    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767)\n+    /// );\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n@@ -1161,11 +1143,9 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n     /// ```\n     pub fn is_global(&self) -> bool {\n         match self.multicast_scope() {\n@@ -1189,11 +1169,8 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n     /// ```\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n@@ -1223,21 +1200,19 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local_strict());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local_strict());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n-    ///     assert!(ip.is_unicast_link_local_strict());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n+    /// assert!(ip.is_unicast_link_local_strict());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n-    ///     assert!(ip.is_unicast_link_local());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n+    /// assert!(!ip.is_unicast_link_local_strict());\n+    /// assert!(ip.is_unicast_link_local());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n-    ///     assert!(ip.is_unicast_link_local());\n-    /// }\n+    /// let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(!ip.is_unicast_link_local_strict());\n+    /// assert!(ip.is_unicast_link_local());\n     /// ```\n     ///\n     /// # See also\n@@ -1284,21 +1259,19 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n-    ///     assert!(ip.is_unicast_link_local());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n+    /// assert!(ip.is_unicast_link_local());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local());\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local());\n+    /// assert!(!ip.is_unicast_link_local_strict());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local());\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n-    /// }\n+    /// let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local());\n+    /// assert!(!ip.is_unicast_link_local_strict());\n     /// ```\n     ///\n     /// # See also\n@@ -1336,11 +1309,11 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_site_local(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n-    /// }\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_site_local(),\n+    ///     false\n+    /// );\n+    /// assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n     /// ```\n     ///\n     /// # Warning\n@@ -1369,11 +1342,8 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n     /// ```\n     pub fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n@@ -1407,11 +1377,8 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(),\n-    ///                true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n     /// ```\n     pub fn is_unicast_global(&self) -> bool {\n         !self.is_multicast()\n@@ -1431,11 +1398,11 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n-    ///                              Some(Ipv6MulticastScope::Global));\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n-    /// }\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n+    ///     Some(Ipv6MulticastScope::Global)\n+    /// );\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n     /// ```\n     pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n         if self.is_multicast() {"}, {"sha": "a72951c03461083a4bae1960c0b6cef616c198c9", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -426,14 +426,12 @@ mod prim_unit { }\n ///\n /// use std::mem;\n ///\n-/// fn main() {\n-///     unsafe {\n-///         let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>()) as *mut i32;\n-///         if my_num.is_null() {\n-///             panic!(\"failed to allocate memory\");\n-///         }\n-///         libc::free(my_num as *mut libc::c_void);\n+/// unsafe {\n+///     let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>()) as *mut i32;\n+///     if my_num.is_null() {\n+///         panic!(\"failed to allocate memory\");\n ///     }\n+///     libc::free(my_num as *mut libc::c_void);\n /// }\n /// ```\n ///"}, {"sha": "e8d7b7663ed5211a99390aa9826006f3acfaa589", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -1180,7 +1180,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn expected_semi_or_open_brace(&mut self) -> PResult<'a, ast::TraitItem> {\n+    crate fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n         let token_str = self.this_token_descr();\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n         err.span_label(self.token.span, \"expected `;` or `{`\");"}, {"sha": "95f84d5cb3314ebe2120ccb8c7bca5d369938cfc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 330, "deletions": 325, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -511,13 +511,15 @@ impl<'a> Parser<'a> {\n         is_present\n     }\n \n+    /// If the next token is the given keyword, returns `true` without eating it.\n+    /// An expectation is also added for diagnostics purposes.\n     fn check_keyword(&mut self, kw: Symbol) -> bool {\n         self.expected_tokens.push(TokenType::Keyword(kw));\n         self.token.is_keyword(kw)\n     }\n \n-    /// If the next token is the given keyword, eats it and returns\n-    /// `true`. Otherwise, returns `false`.\n+    /// If the next token is the given keyword, eats it and returns `true`.\n+    /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.\n     pub fn eat_keyword(&mut self, kw: Symbol) -> bool {\n         if self.check_keyword(kw) {\n             self.bump();\n@@ -547,40 +549,38 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn check_ident(&mut self) -> bool {\n-        if self.token.is_ident() {\n+    fn check_or_expected(&mut self, ok: bool, typ: TokenType) -> bool {\n+        if ok {\n             true\n         } else {\n-            self.expected_tokens.push(TokenType::Ident);\n+            self.expected_tokens.push(typ);\n             false\n         }\n     }\n \n+    crate fn check_ident(&mut self) -> bool {\n+        self.check_or_expected(self.token.is_ident(), TokenType::Ident)\n+    }\n+\n     fn check_path(&mut self) -> bool {\n-        if self.token.is_path_start() {\n-            true\n-        } else {\n-            self.expected_tokens.push(TokenType::Path);\n-            false\n-        }\n+        self.check_or_expected(self.token.is_path_start(), TokenType::Path)\n     }\n \n     fn check_type(&mut self) -> bool {\n-        if self.token.can_begin_type() {\n-            true\n-        } else {\n-            self.expected_tokens.push(TokenType::Type);\n-            false\n-        }\n+        self.check_or_expected(self.token.can_begin_type(), TokenType::Type)\n     }\n \n     fn check_const_arg(&mut self) -> bool {\n-        if self.token.can_begin_const_arg() {\n-            true\n-        } else {\n-            self.expected_tokens.push(TokenType::Const);\n-            false\n-        }\n+        self.check_or_expected(self.token.can_begin_const_arg(), TokenType::Const)\n+    }\n+\n+    /// Checks to see if the next token is either `+` or `+=`.\n+    /// Otherwise returns `false`.\n+    fn check_plus(&mut self) -> bool {\n+        self.check_or_expected(\n+            self.token.is_like_plus(),\n+            TokenType::Token(token::BinOp(token::Plus)),\n+        )\n     }\n \n     /// Expects and consumes a `+`. if `+=` is seen, replaces it with a `=`\n@@ -604,18 +604,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Checks to see if the next token is either `+` or `+=`.\n-    /// Otherwise returns `false`.\n-    fn check_plus(&mut self) -> bool {\n-        if self.token.is_like_plus() {\n-            true\n-        }\n-        else {\n-            self.expected_tokens.push(TokenType::Token(token::BinOp(token::Plus)));\n-            false\n-        }\n-    }\n-\n     /// Expects and consumes an `&`. If `&&` is seen, replaces it with a single\n     /// `&` and continues. If an `&` is not seen, signals an error.\n     fn expect_and(&mut self) -> PResult<'a, ()> {\n@@ -910,15 +898,15 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.clear();\n     }\n \n-    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where\n-        F: FnOnce(&Token) -> R,\n-    {\n+    /// Look-ahead `dist` tokens of `self.token` and get access to that token there.\n+    /// When `dist == 0` then the current token is looked at.\n+    pub fn look_ahead<R>(&self, dist: usize, looker: impl FnOnce(&Token) -> R) -> R {\n         if dist == 0 {\n-            return f(&self.token);\n+            return looker(&self.token);\n         }\n \n         let frame = &self.token_cursor.frame;\n-        f(&match frame.tree_cursor.look_ahead(dist - 1) {\n+        looker(&match frame.tree_cursor.look_ahead(dist - 1) {\n             Some(tree) => match tree {\n                 TokenTree::Token(token) => token,\n                 TokenTree::Delimited(dspan, delim, _) =>\n@@ -954,109 +942,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_named_argument(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n-                _ => 0,\n-            }\n-            token::BinOp(token::And) | token::AndAnd => 1,\n-            _ if self.token.is_keyword(kw::Mut) => 1,\n-            _ => 0,\n-        };\n-\n-        self.look_ahead(offset, |t| t.is_ident()) &&\n-        self.look_ahead(offset + 1, |t| t == &token::Colon)\n-    }\n-\n-    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n-    /// error.\n-    /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(\n-        &mut self,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n-        allow_c_variadic: bool,\n-        is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Param> {\n-        let lo = self.token.span;\n-        let attrs = self.parse_outer_attributes()?;\n-\n-        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n-        if let Some(mut param) = self.parse_self_param()? {\n-            param.attrs = attrs.into();\n-            return if is_self_allowed {\n-                Ok(param)\n-            } else {\n-                self.recover_bad_self_param(param, is_trait_item)\n-            };\n-        }\n-\n-        let is_name_required = is_name_required(&self.token);\n-        let (pat, ty) = if is_name_required || self.is_named_argument() {\n-            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n-\n-            let pat = self.parse_fn_param_pat()?;\n-            if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.parameter_without_type(\n-                    &mut err,\n-                    pat,\n-                    is_name_required,\n-                    is_trait_item,\n-                ) {\n-                    err.emit();\n-                    return Ok(dummy_arg(ident));\n-                } else {\n-                    return Err(err);\n-                }\n-            }\n-\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n-        } else {\n-            debug!(\"parse_param_general ident_to_pat\");\n-            let parser_snapshot_before_ty = self.clone();\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n-            if ty.is_ok() && self.token != token::Comma &&\n-               self.token != token::CloseDelim(token::Paren) {\n-                // This wasn't actually a type, but a pattern looking like a type,\n-                // so we are going to rollback and re-parse for recovery.\n-                ty = self.unexpected();\n-            }\n-            match ty {\n-                Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n-                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n-                    (pat, ty)\n-                }\n-                Err(mut err) => {\n-                    // If this is a C-variadic argument and we hit an error, return the\n-                    // error.\n-                    if self.token == token::DotDotDot {\n-                        return Err(err);\n-                    }\n-                    // Recover from attempting to parse the argument as a type without pattern.\n-                    err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n-                    self.recover_arg_parse()?\n-                }\n-            }\n-        };\n-\n-        let span = lo.to(self.token.span);\n-\n-        Ok(Param {\n-            attrs: attrs.into(),\n-            id: ast::DUMMY_NODE_ID,\n-            is_placeholder: false,\n-            pat,\n-            span,\n-            ty,\n-        })\n-    }\n-\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) {\n@@ -1066,6 +951,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Possibly parses mutability (`const` or `mut`).\n+    fn parse_const_or_mut(&mut self) -> Option<Mutability> {\n+        if self.eat_keyword(kw::Mut) {\n+            Some(Mutability::Mutable)\n+        } else if self.eat_keyword(kw::Const) {\n+            Some(Mutability::Immutable)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n         if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) =\n                 self.token.kind {\n@@ -1100,9 +996,10 @@ impl<'a> Parser<'a> {\n         Ok((delim, tts.into()))\n     }\n \n-    fn parse_or_use_outer_attributes(&mut self,\n-                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                                     -> PResult<'a, ThinVec<Attribute>> {\n+    fn parse_or_use_outer_attributes(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, ThinVec<Attribute>> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n@@ -1189,53 +1086,52 @@ impl<'a> Parser<'a> {\n     /// Evaluates the closure with restrictions in place.\n     ///\n     /// Afters the closure is evaluated, restrictions are reset.\n-    fn with_res<F, T>(&mut self, r: Restrictions, f: F) -> T\n-        where F: FnOnce(&mut Self) -> T\n-    {\n+    fn with_res<T>(&mut self, res: Restrictions, f: impl FnOnce(&mut Self) -> T) -> T {\n         let old = self.restrictions;\n-        self.restrictions = r;\n-        let r = f(self);\n+        self.restrictions = res;\n+        let res = f(self);\n         self.restrictions = old;\n-        return r;\n-\n+        res\n     }\n \n-    fn parse_fn_params(&mut self, named_params: bool, allow_c_variadic: bool)\n-                     -> PResult<'a, Vec<Param>> {\n+    fn parse_fn_params(\n+        &mut self,\n+        named_params: bool,\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, Vec<Param>> {\n         let sp = self.token.span;\n+        let do_not_enforce_named_params_for_c_variadic = |token: &token::Token| {\n+            match token.kind {\n+                token::DotDotDot => false,\n+                _ => named_params,\n+            }\n+        };\n         let mut c_variadic = false;\n-        let (params, _): (Vec<Option<Param>>, _) = self.parse_paren_comma_seq(|p| {\n-            let do_not_enforce_named_arguments_for_c_variadic =\n-                |token: &token::Token| -> bool {\n-                    if token == &token::DotDotDot {\n-                        false\n-                    } else {\n-                        named_params\n-                    }\n-                };\n+        let (params, _) = self.parse_paren_comma_seq(|p| {\n             match p.parse_param_general(\n                 false,\n                 false,\n                 allow_c_variadic,\n-                do_not_enforce_named_arguments_for_c_variadic\n+                do_not_enforce_named_params_for_c_variadic,\n             ) {\n-                Ok(param) => {\n+                Ok(param) => Ok(\n                     if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n                         if p.token != token::CloseDelim(token::Paren) {\n-                            let span = p.token.span;\n-                            p.span_err(span,\n-                                \"`...` must be the last argument of a C-variadic function\");\n+                            p.span_err(\n+                                p.token.span,\n+                                \"`...` must be the last argument of a C-variadic function\",\n+                            );\n                             // FIXME(eddyb) this should probably still push `CVarArgs`.\n                             // Maybe AST validation/HIR lowering should emit the above error?\n-                            Ok(None)\n+                            None\n                         } else {\n-                            Ok(Some(param))\n+                            Some(param)\n                         }\n                     } else {\n-                        Ok(Some(param))\n+                        Some(param)\n                     }\n-                },\n+                ),\n                 Err(mut e) => {\n                     e.emit();\n                     let lo = p.prev_span;\n@@ -1251,26 +1147,169 @@ impl<'a> Parser<'a> {\n         let params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n \n         if c_variadic && params.len() <= 1 {\n-            self.span_err(sp,\n-                          \"C-variadic function must be declared with at least one named argument\");\n+            self.span_err(\n+                sp,\n+                \"C-variadic function must be declared with at least one named argument\",\n+            );\n         }\n \n         Ok(params)\n     }\n \n+    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n+    fn parse_fn_decl_with_self(\n+        &mut self,\n+        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n+        // Parse the arguments, starting out with `self` being allowed...\n+        let mut is_self_allowed = true;\n+        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n+            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n+            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n+            is_self_allowed = false;\n+            res\n+        })?;\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut inputs);\n+\n+        Ok(P(FnDecl {\n+            inputs,\n+            output: self.parse_ret_ty(true)?,\n+        }))\n+    }\n+\n+    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n+    /// error.\n+    /// This version of parse param doesn't necessarily require identifier names.\n+    fn parse_param_general(\n+        &mut self,\n+        is_self_allowed: bool,\n+        is_trait_item: bool,\n+        allow_c_variadic: bool,\n+        is_name_required: impl Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, Param> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_outer_attributes()?;\n+\n+        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n+        if let Some(mut param) = self.parse_self_param()? {\n+            param.attrs = attrs.into();\n+            return if is_self_allowed {\n+                Ok(param)\n+            } else {\n+                self.recover_bad_self_param(param, is_trait_item)\n+            };\n+        }\n+\n+        let is_name_required = is_name_required(&self.token);\n+        let (pat, ty) = if is_name_required || self.is_named_param() {\n+            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n+\n+            let pat = self.parse_fn_param_pat()?;\n+            if let Err(mut err) = self.expect(&token::Colon) {\n+                if let Some(ident) = self.parameter_without_type(\n+                    &mut err,\n+                    pat,\n+                    is_name_required,\n+                    is_trait_item,\n+                ) {\n+                    err.emit();\n+                    return Ok(dummy_arg(ident));\n+                } else {\n+                    return Err(err);\n+                }\n+            }\n+\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n+        } else {\n+            debug!(\"parse_param_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n+            if ty.is_ok() && self.token != token::Comma &&\n+               self.token != token::CloseDelim(token::Paren) {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n+                    (pat, ty)\n+                }\n+                // If this is a C-variadic argument and we hit an error, return the error.\n+                Err(err) if self.token == token::DotDotDot => return Err(err),\n+                // Recover from attempting to parse the argument as a type without pattern.\n+                Err(mut err) => {\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    self.recover_arg_parse()?\n+                }\n+            }\n+        };\n+\n+        let span = lo.to(self.token.span);\n+\n+        Ok(Param {\n+            attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n+            is_placeholder: false,\n+            pat,\n+            span,\n+            ty,\n+        })\n+    }\n+\n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n     ///\n     /// See `parse_self_param_with_attrs` to collect attributes.\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n-        let expect_ident = |this: &mut Self| match this.token.kind {\n-            // Preserve hygienic context.\n-            token::Ident(name, _) =>\n-                { let span = this.token.span; this.bump(); Ident::new(name, span) }\n-            _ => unreachable!()\n+        // Extract an identifier *after* having confirmed that the token is one.\n+        let expect_self_ident = |this: &mut Self| {\n+            match this.token.kind {\n+                // Preserve hygienic context.\n+                token::Ident(name, _) => {\n+                    let span = this.token.span;\n+                    this.bump();\n+                    Ident::new(name, span)\n+                }\n+                _ => unreachable!(),\n+            }\n+        };\n+        // Is `self` `n` tokens ahead?\n+        let is_isolated_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::SelfLower])\n+            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n-        let isolated_self = |this: &mut Self, n| {\n-            this.look_ahead(n, |t| t.is_keyword(kw::SelfLower)) &&\n-            this.look_ahead(n + 1, |t| t != &token::ModSep)\n+        // Is `mut self` `n` tokens ahead?\n+        let is_isolated_mut_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::Mut])\n+            && is_isolated_self(this, n + 1)\n+        };\n+        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n+        let parse_self_possibly_typed = |this: &mut Self, m| {\n+            let eself_ident = expect_self_ident(this);\n+            let eself_hi = this.prev_span;\n+            let eself = if this.eat(&token::Colon) {\n+                SelfKind::Explicit(this.parse_ty()?, m)\n+            } else {\n+                SelfKind::Value(m)\n+            };\n+            Ok((eself, eself_ident, eself_hi))\n+        };\n+        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n+        let recover_self_ptr = |this: &mut Self| {\n+            let msg = \"cannot pass `self` by raw pointer\";\n+            let span = this.token.span;\n+            this.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .emit();\n+\n+            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n         };\n \n         // Parse optional `self` parameter of a method.\n@@ -1279,88 +1318,54 @@ impl<'a> Parser<'a> {\n         let eself_lo = self.token.span;\n         let (eself, eself_ident, eself_hi) = match self.token.kind {\n             token::BinOp(token::And) => {\n-                // `&self`\n-                // `&mut self`\n-                // `&'lt self`\n-                // `&'lt mut self`\n-                // `&not_self`\n-                (if isolated_self(self, 1) {\n+                let eself = if is_isolated_self(self, 1) {\n+                    // `&self`\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.is_keyword_ahead(1, &[kw::Mut]) &&\n-                          isolated_self(self, 2) {\n+                } else if is_isolated_mut_self(self, 1) {\n+                    // `&mut self`\n                     self.bump();\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Mutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          isolated_self(self, 2) {\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n+                    // `&'lt self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          self.is_keyword_ahead(2, &[kw::Mut]) &&\n-                          isolated_self(self, 3) {\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n+                    // `&'lt mut self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     self.bump();\n                     SelfKind::Region(Some(lt), Mutability::Mutable)\n                 } else {\n+                    // `&not_self`\n                     return Ok(None);\n-                }, expect_ident(self), self.prev_span)\n+                };\n+                (eself, expect_self_ident(self), self.prev_span)\n             }\n-            token::BinOp(token::Star) => {\n-                // `*self`\n-                // `*const self`\n-                // `*mut self`\n-                // `*not_self`\n-                // Emit special error for `self` cases.\n-                let msg = \"cannot pass `self` by raw pointer\";\n-                (if isolated_self(self, 1) {\n-                    self.bump();\n-                    self.struct_span_err(self.token.span, msg)\n-                        .span_label(self.token.span, msg)\n-                        .emit();\n-                    SelfKind::Value(Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_mutability()) &&\n-                          isolated_self(self, 2) {\n-                    self.bump();\n-                    self.bump();\n-                    self.struct_span_err(self.token.span, msg)\n-                        .span_label(self.token.span, msg)\n-                        .emit();\n-                    SelfKind::Value(Mutability::Immutable)\n-                } else {\n-                    return Ok(None);\n-                }, expect_ident(self), self.prev_span)\n+            // `*self`\n+            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n+                self.bump();\n+                recover_self_ptr(self)?\n             }\n-            token::Ident(..) => {\n-                if isolated_self(self, 0) {\n-                    // `self`\n-                    // `self: TYPE`\n-                    let eself_ident = expect_ident(self);\n-                    let eself_hi = self.prev_span;\n-                    (if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty()?;\n-                        SelfKind::Explicit(ty, Mutability::Immutable)\n-                    } else {\n-                        SelfKind::Value(Mutability::Immutable)\n-                    }, eself_ident, eself_hi)\n-                } else if self.token.is_keyword(kw::Mut) &&\n-                          isolated_self(self, 1) {\n-                    // `mut self`\n-                    // `mut self: TYPE`\n-                    self.bump();\n-                    let eself_ident = expect_ident(self);\n-                    let eself_hi = self.prev_span;\n-                    (if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty()?;\n-                        SelfKind::Explicit(ty, Mutability::Mutable)\n-                    } else {\n-                        SelfKind::Value(Mutability::Mutable)\n-                    }, eself_ident, eself_hi)\n-                } else {\n-                    return Ok(None);\n-                }\n+            // `*mut self` and `*const self`\n+            token::BinOp(token::Star) if\n+                self.look_ahead(1, |t| t.is_mutability())\n+                && is_isolated_self(self, 2) =>\n+            {\n+                self.bump();\n+                self.bump();\n+                recover_self_ptr(self)?\n+            }\n+            // `self` and `self: TYPE`\n+            token::Ident(..) if is_isolated_self(self, 0) => {\n+                parse_self_possibly_typed(self, Mutability::Immutable)?\n+            }\n+            // `mut self` and `mut self: TYPE`\n+            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n+                self.bump();\n+                parse_self_possibly_typed(self, Mutability::Mutable)?\n             }\n             _ => return Ok(None),\n         };\n@@ -1369,27 +1374,19 @@ impl<'a> Parser<'a> {\n         Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n     }\n \n-    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self(\n-        &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        // Parse the arguments, starting out with `self` being allowed...\n-        let mut is_self_allowed = true;\n-        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n-            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n-            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n-            is_self_allowed = false;\n-            res\n-        })?;\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut inputs);\n+    fn is_named_param(&self) -> bool {\n+        let offset = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n+                _ => 0,\n+            }\n+            token::BinOp(token::And) | token::AndAnd => 1,\n+            _ if self.token.is_keyword(kw::Mut) => 1,\n+            _ => 0,\n+        };\n \n-        Ok(P(FnDecl {\n-            inputs,\n-            output: self.parse_ret_ty(true)?,\n-        }))\n+        self.look_ahead(offset, |t| t.is_ident()) &&\n+        self.look_ahead(offset + 1, |t| t == &token::Colon)\n     }\n \n     fn is_crate_vis(&self) -> bool {\n@@ -1423,100 +1420,107 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.is_keyword_ahead(1, &[kw::Crate]) &&\n-                self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n+            if self.is_keyword_ahead(1, &[kw::Crate])\n+                && self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n-                // `pub(crate)`\n+                // Parse `pub(crate)`.\n                 self.bump(); // `(`\n                 self.bump(); // `crate`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(\n-                    lo.to(self.prev_span),\n-                    VisibilityKind::Crate(CrateSugar::PubCrate),\n-                );\n-                return Ok(vis)\n+                let vis = VisibilityKind::Crate(CrateSugar::PubCrate);\n+                return Ok(respan(lo.to(self.prev_span), vis));\n             } else if self.is_keyword_ahead(1, &[kw::In]) {\n-                // `pub(in path)`\n+                // Parse `pub(in path)`.\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?; // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+                let vis = VisibilityKind::Restricted {\n                     path: P(path),\n                     id: ast::DUMMY_NODE_ID,\n-                });\n-                return Ok(vis)\n-            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n+                };\n+                return Ok(respan(lo.to(self.prev_span), vis));\n+            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren))\n+                && self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n-                // `pub(self)` or `pub(super)`\n+                // Parse `pub(self)` or `pub(super)`.\n                 self.bump(); // `(`\n                 let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+                let vis = VisibilityKind::Restricted {\n                     path: P(path),\n                     id: ast::DUMMY_NODE_ID,\n-                });\n-                return Ok(vis)\n-            } else if !can_take_tuple {  // Provide this diagnostic if this is not a tuple struct\n-                // `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n-                self.bump(); // `(`\n-                let msg = \"incorrect visibility restriction\";\n-                let suggestion = r##\"some possible visibility restrictions are:\n-`pub(crate)`: visible only on the current crate\n-`pub(super)`: visible only in the current module's parent\n-`pub(in path::to::module)`: visible only on the specified path\"##;\n-                let path = self.parse_path(PathStyle::Mod)?;\n-                let sp = path.span;\n-                let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n-                self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg)\n-                    .help(suggestion)\n-                    .span_suggestion(\n-                        sp,\n-                        &help_msg,\n-                        format!(\"in {}\", path),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit(); // Emit diagnostic, but continue with public visibility.\n+                };\n+                return Ok(respan(lo.to(self.prev_span), vis));\n+            } else if !can_take_tuple { // Provide this diagnostic if this is not a tuple struct.\n+                self.recover_incorrect_vis_restriction()?;\n+                // Emit diagnostic, but continue with public visibility.\n             }\n         }\n \n         Ok(respan(lo, VisibilityKind::Public))\n     }\n \n+    /// Recovery for e.g. `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n+    fn recover_incorrect_vis_restriction(&mut self) -> PResult<'a, ()> {\n+        self.bump(); // `(`\n+        let path = self.parse_path(PathStyle::Mod)?;\n+        self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n+\n+        let msg = \"incorrect visibility restriction\";\n+        let suggestion = r##\"some possible visibility restrictions are:\n+`pub(crate)`: visible only on the current crate\n+`pub(super)`: visible only in the current module's parent\n+`pub(in path::to::module)`: visible only on the specified path\"##;\n+\n+        struct_span_err!(self.sess.span_diagnostic, path.span, E0704, \"{}\", msg)\n+            .help(suggestion)\n+            .span_suggestion(\n+                path.span,\n+                &format!(\"make this visible only to module `{}` with `in`\", path),\n+                format!(\"in {}\", path),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+\n+        Ok(())\n+    }\n+\n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n     /// the `extern` keyword, if one is found.\n     fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n         match self.token.kind {\n             token::Literal(token::Lit { kind: token::Str, symbol, suffix }) |\n             token::Literal(token::Lit { kind: token::StrRaw(..), symbol, suffix }) => {\n-                let sp = self.token.span;\n-                self.expect_no_suffix(sp, \"an ABI spec\", suffix);\n+                self.expect_no_suffix(self.token.span, \"an ABI spec\", suffix);\n                 self.bump();\n                 match abi::lookup(&symbol.as_str()) {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n-                        let prev_span = self.prev_span;\n-                        struct_span_err!(\n-                            self.sess.span_diagnostic,\n-                            prev_span,\n-                            E0703,\n-                            \"invalid ABI: found `{}`\",\n-                            symbol\n-                        )\n-                        .span_label(prev_span, \"invalid ABI\")\n-                        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-                        .emit();\n+                        self.error_on_invalid_abi(symbol);\n                         Ok(None)\n                     }\n                 }\n             }\n-\n             _ => Ok(None),\n         }\n     }\n \n+    /// Emit an error where `symbol` is an invalid ABI.\n+    fn error_on_invalid_abi(&self, symbol: Symbol) {\n+        let prev_span = self.prev_span;\n+        struct_span_err!(\n+            self.sess.span_diagnostic,\n+            prev_span,\n+            E0703,\n+            \"invalid ABI: found `{}`\",\n+            symbol\n+        )\n+        .span_label(prev_span, \"invalid ABI\")\n+        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+        .emit();\n+    }\n+\n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n     fn ban_async_in_2015(&self, async_span: Span) {\n         if async_span.rust_2015() {\n@@ -1530,9 +1534,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n-        where F: FnOnce(&mut Self) -> PResult<'a, R>\n-    {\n+    fn collect_tokens<R>(\n+        &mut self,\n+        f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n+    ) -> PResult<'a, (R, TokenStream)> {\n         // Record all tokens we parse when parsing this item.\n         let mut tokens = Vec::new();\n         let prev_collecting = match self.token_cursor.frame.last_token {"}, {"sha": "c00a5807d52c5d56a125715f45eace6b4adc33b8", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 162, "deletions": 231, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -7,7 +7,7 @@ use crate::ast::{\n     Item, ItemKind, ImplItem, TraitItem, TraitItemKind,\n     UseTree, UseTreeKind, PathSegment,\n     IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n-    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader,\n+    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n     ForeignItem, ForeignItemKind,\n     Ty, TyKind, Generics, GenericBounds, TraitRef,\n     EnumDef, VariantData, StructField, AnonConst,\n@@ -18,7 +18,7 @@ use crate::parse::token;\n use crate::parse::parser::maybe_append;\n use crate::parse::diagnostics::Error;\n use crate::tokenstream::{TokenTree, TokenStream};\n-use crate::source_map::{respan, Span, Spanned};\n+use crate::source_map::{respan, Span};\n use crate::symbol::{kw, sym};\n \n use std::mem;\n@@ -122,19 +122,13 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM\n                 let fn_span = self.prev_span;\n-                let abi = opt_abi.unwrap_or(Abi::C);\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(Unsafety::Normal,\n-                                       respan(fn_span, IsAsync::NotAsync),\n-                                       respan(fn_span, Constness::NotConst),\n-                                       abi)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                return Ok(Some(item));\n+                let header = FnHeader {\n+                    unsafety: Unsafety::Normal,\n+                    asyncness: respan(fn_span, IsAsync::NotAsync),\n+                    constness: respan(fn_span, Constness::NotConst),\n+                    abi: opt_abi.unwrap_or(Abi::C),\n+                };\n+                return self.parse_item_fn(lo, visibility, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return Ok(Some(\n                     self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n@@ -149,13 +143,9 @@ impl<'a> Parser<'a> {\n             // STATIC ITEM\n             let m = self.parse_mutability();\n             let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.eat_keyword(kw::Const) {\n             let const_span = self.prev_span;\n@@ -165,18 +155,13 @@ impl<'a> Parser<'a> {\n                 // CONST FUNCTION ITEM\n                 let unsafety = self.parse_unsafety();\n                 self.bump();\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety,\n-                                       respan(const_span, IsAsync::NotAsync),\n-                                       respan(const_span, Constness::Const),\n-                                       Abi::Rust)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                return Ok(Some(item));\n+                let header = FnHeader {\n+                    unsafety,\n+                    asyncness: respan(const_span, IsAsync::NotAsync),\n+                    constness: respan(const_span, Constness::Const),\n+                    abi: Abi::Rust,\n+                };\n+                return self.parse_item_fn(lo, visibility, attrs, header);\n             }\n \n             // CONST ITEM\n@@ -193,13 +178,9 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n \n         // Parses `async unsafe? fn`.\n@@ -213,22 +194,18 @@ impl<'a> Parser<'a> {\n                 let unsafety = self.parse_unsafety(); // `unsafe`?\n                 self.expect_keyword(kw::Fn)?; // `fn`\n                 let fn_span = self.prev_span;\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety,\n-                                    respan(async_span, IsAsync::Async {\n-                                        closure_id: DUMMY_NODE_ID,\n-                                        return_impl_trait_id: DUMMY_NODE_ID,\n-                                    }),\n-                                    respan(fn_span, Constness::NotConst),\n-                                    Abi::Rust)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n+                let asyncness = respan(async_span, IsAsync::Async {\n+                    closure_id: DUMMY_NODE_ID,\n+                    return_impl_trait_id: DUMMY_NODE_ID,\n+                });\n                 self.ban_async_in_2015(async_span);\n-                return Ok(Some(item));\n+                let header = FnHeader {\n+                    unsafety,\n+                    asyncness,\n+                    constness: respan(fn_span, Constness::NotConst),\n+                    abi: Abi::Rust,\n+                };\n+                return self.parse_item_fn(lo, visibility, attrs, header);\n             }\n         }\n         if self.check_keyword(kw::Unsafe) &&\n@@ -243,15 +220,10 @@ impl<'a> Parser<'a> {\n                 self.expect_keyword(kw::Trait)?;\n                 IsAuto::Yes\n             };\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n@@ -262,27 +234,22 @@ impl<'a> Parser<'a> {\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n+            let (ident, item_, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n             let span = lo.to(self.prev_span);\n-            return Ok(Some(self.mk_item(span, ident, item, visibility,\n-                                        maybe_append(attrs, extra_attrs))));\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.check_keyword(kw::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n             let fn_span = self.prev_span;\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Normal,\n-                                   respan(fn_span, IsAsync::NotAsync),\n-                                   respan(fn_span, Constness::NotConst),\n-                                   Abi::Rust)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let header = FnHeader {\n+                unsafety: Unsafety::Normal,\n+                asyncness: respan(fn_span, IsAsync::NotAsync),\n+                constness: respan(fn_span, Constness::NotConst),\n+                abi: Abi::Rust,\n+            };\n+            return self.parse_item_fn(lo, visibility, attrs, header);\n         }\n         if self.check_keyword(kw::Unsafe)\n             && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n@@ -297,30 +264,20 @@ impl<'a> Parser<'a> {\n             };\n             self.expect_keyword(kw::Fn)?;\n             let fn_span = self.prev_span;\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Unsafe,\n-                                   respan(fn_span, IsAsync::NotAsync),\n-                                   respan(fn_span, Constness::NotConst),\n-                                   abi)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let header = FnHeader {\n+                unsafety: Unsafety::Unsafe,\n+                asyncness: respan(fn_span, IsAsync::NotAsync),\n+                constness: respan(fn_span, Constness::NotConst),\n+                abi,\n+            };\n+            return self.parse_item_fn(lo, visibility, attrs, header);\n         }\n         if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(&attrs[..])?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item_, extra_attrs) = self.parse_item_mod(&attrs[..])?;\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if let Some(type_) = self.eat_type() {\n             let (ident, alias, generics) = type_?;\n@@ -329,24 +286,15 @@ impl<'a> Parser<'a> {\n                 AliasKind::Weak(ty) => ItemKind::TyAlias(ty, generics),\n                 AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n             };\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n@@ -360,38 +308,25 @@ impl<'a> Parser<'a> {\n                 IsAuto::Yes\n             };\n             // TRAIT ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, Unsafety::Normal)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Normal)?;\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.is_union_item() {\n             // UNION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_union()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n             return Ok(Some(macro_def));\n@@ -848,29 +783,37 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n-                         -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n+    fn parse_impl_method(\n+        &mut self,\n+        vis: &Visibility,\n+        at_end: &mut bool\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n         // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n-            Ok((Ident::invalid(), vec![], Generics::default(),\n-                ast::ImplItemKind::Macro(mac)))\n+            Ok((Ident::invalid(), vec![], Generics::default(), ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-            let decl = self.parse_fn_decl_with_self(|_| true)?;\n-            generics.where_clause = self.parse_where_clause()?;\n+            let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n-                ast::MethodSig { header, decl },\n-                body\n-            )))\n+            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n         }\n     }\n \n+    /// Parse the \"signature\", including the identifier, parameters, and generics\n+    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n+    fn parse_method_sig(\n+        &mut self,\n+        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let (ident, mut generics) = self.parse_fn_header()?;\n+        let decl = self.parse_fn_decl_with_self(is_name_required)?;\n+        let sig = MethodSig { header, decl };\n+        generics.where_clause = self.parse_where_clause()?;\n+        Ok((ident, sig, generics))\n+    }\n+\n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n     /// and including the `fn` keyword:\n     ///\n@@ -879,14 +822,7 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc.\n-    fn parse_fn_front_matter(&mut self)\n-        -> PResult<'a, (\n-            Spanned<Constness>,\n-            Unsafety,\n-            Spanned<IsAsync>,\n-            Abi\n-        )>\n-    {\n+    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n         let is_const_fn = self.eat_keyword(kw::Const);\n         let const_span = self.prev_span;\n         let asyncness = self.parse_asyncness();\n@@ -911,7 +847,7 @@ impl<'a> Parser<'a> {\n             // account for this.\n             if !self.expect_one_of(&[], &[])? { unreachable!() }\n         }\n-        Ok((constness, unsafety, asyncness, abi))\n+        Ok(FnHeader { constness, unsafety, asyncness, abi })\n     }\n \n     /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n@@ -1025,59 +961,12 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), ast::TraitItemKind::Macro(mac), Generics::default())\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-\n             // This is somewhat dubious; We don't want to allow\n             // argument names to be left off if there is a definition...\n             //\n             // We don't allow argument names to be left off in edition 2018.\n-            let decl = self.parse_fn_decl_with_self(|t| t.span.rust_2018())?;\n-            generics.where_clause = self.parse_where_clause()?;\n-\n-            let sig = ast::MethodSig {\n-                header: FnHeader {\n-                    unsafety,\n-                    constness,\n-                    abi,\n-                    asyncness,\n-                },\n-                decl,\n-            };\n-\n-            let body = match self.token.kind {\n-                token::Semi => {\n-                    self.bump();\n-                    *at_end = true;\n-                    debug!(\"parse_trait_methods(): parsing required method\");\n-                    None\n-                }\n-                token::OpenDelim(token::Brace) => {\n-                    debug!(\"parse_trait_methods(): parsing provided method\");\n-                    *at_end = true;\n-                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n-                }\n-                token::Interpolated(ref nt) => {\n-                    match **nt {\n-                        token::NtBlock(..) => {\n-                            *at_end = true;\n-                            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                            attrs.extend(inner_attrs.iter().cloned());\n-                            Some(body)\n-                        }\n-                        _ => {\n-                            return self.expected_semi_or_open_brace();\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    return self.expected_semi_or_open_brace();\n-                }\n-            };\n+            let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n+            let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n             (ident, ast::TraitItemKind::Method(sig, body), generics)\n         };\n \n@@ -1092,6 +981,43 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parse the \"body\" of a method in a trait item definition.\n+    /// This can either be `;` when there's no body,\n+    /// or e.g. a block when the method is a provided one.\n+    fn parse_trait_method_body(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, Option<P<Block>>> {\n+        Ok(match self.token.kind {\n+            token::Semi => {\n+                debug!(\"parse_trait_method_body(): parsing required method\");\n+                self.bump();\n+                *at_end = true;\n+                None\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                *at_end = true;\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                attrs.extend(inner_attrs.iter().cloned());\n+                Some(body)\n+            }\n+            token::Interpolated(ref nt) => {\n+                match **nt {\n+                    token::NtBlock(..) => {\n+                        *at_end = true;\n+                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n+                    _ => return self.expected_semi_or_open_brace(),\n+                }\n+            }\n+            _ => return self.expected_semi_or_open_brace(),\n+        })\n+    }\n+\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n@@ -1261,18 +1187,29 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(\n         &mut self,\n-        unsafety: Unsafety,\n-        asyncness: Spanned<IsAsync>,\n-        constness: Spanned<Constness>,\n-        abi: Abi\n-    ) -> PResult<'a, ItemInfo> {\n+        lo: Span,\n+        vis: Visibility,\n+        attrs: Vec<Attribute>,\n+        header: FnHeader,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let allow_c_variadic = header.abi == Abi::C && header.unsafety == Unsafety::Unsafe;\n+        let (ident, decl, generics) = self.parse_fn_sig(allow_c_variadic)?;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let span = lo.to(self.prev_span);\n+        let kind = ItemKind::Fn(decl, header, generics, body);\n+        let attrs = maybe_append(attrs, Some(inner_attrs));\n+        Ok(Some(self.mk_item(span, ident, kind, vis, attrs)))\n+    }\n+\n+    /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n+    fn parse_fn_sig(\n+        &mut self,\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n-        let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n         let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let header = FnHeader { unsafety, asyncness, constness, abi };\n-        Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n+        Ok((ident, decl, generics))\n     }\n \n     /// Parses the name and optional generic types of a function header.\n@@ -1282,14 +1219,11 @@ impl<'a> Parser<'a> {\n         Ok((id, generics))\n     }\n \n-    /// Parses the argument list and result type of a function declaration.\n+    /// Parses the parameter list and result type of a function declaration.\n     fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n-        let args = self.parse_fn_params(true, allow_c_variadic)?;\n-        let ret_ty = self.parse_ret_ty(true)?;\n-\n         Ok(P(FnDecl {\n-            inputs: args,\n-            output: ret_ty,\n+            inputs: self.parse_fn_params(true, allow_c_variadic)?,\n+            output: self.parse_ret_ty(true)?,\n         }))\n     }\n \n@@ -1397,18 +1331,15 @@ impl<'a> Parser<'a> {\n         extern_sp: Span,\n     ) -> PResult<'a, ForeignItem> {\n         self.expect_keyword(kw::Fn)?;\n-\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(true)?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        let hi = self.token.span;\n+        let (ident, decl, generics) = self.parse_fn_sig(true)?;\n+        let span = lo.to(self.token.span);\n         self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n         Ok(ast::ForeignItem {\n             ident,\n             attrs,\n             kind: ForeignItemKind::Fn(decl, generics),\n             id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n+            span,\n             vis,\n         })\n     }"}, {"sha": "41ee2a1599d74028ab9a9d092792e591fb56eb7f", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -231,19 +231,15 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n-        let mutbl = if self.eat_keyword(kw::Mut) {\n-            Mutability::Mutable\n-        } else if self.eat_keyword(kw::Const) {\n-            Mutability::Immutable\n-        } else {\n+        let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n             let span = self.prev_span;\n             let msg = \"expected mut or const in raw pointer type\";\n             self.struct_span_err(span, msg)\n                 .span_label(span, msg)\n                 .help(\"use `*mut T` or `*const T` as appropriate\")\n                 .emit();\n             Mutability::Immutable\n-        };\n+        });\n         let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl })\n     }"}, {"sha": "7633825eb32ab167f1ee6894bb66ab3edeef10ad", "filename": "src/test/ui/async-await/edition-deny-async-fns-2015.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -10,18 +10,18 @@ error[E0670]: `async fn` is not permitted in the 2015 edition\n LL | fn baz() { async fn foo() {} }\n    |            ^^^^^\n \n-error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:8:5\n-   |\n-LL |     async fn bar() {}\n-   |     ^^^^^\n-\n error[E0670]: `async fn` is not permitted in the 2015 edition\n   --> $DIR/edition-deny-async-fns-2015.rs:7:1\n    |\n LL | async fn async_baz() {\n    | ^^^^^\n \n+error[E0670]: `async fn` is not permitted in the 2015 edition\n+  --> $DIR/edition-deny-async-fns-2015.rs:8:5\n+   |\n+LL |     async fn bar() {}\n+   |     ^^^^^\n+\n error[E0670]: `async fn` is not permitted in the 2015 edition\n   --> $DIR/edition-deny-async-fns-2015.rs:14:5\n    |"}, {"sha": "5c666afb89a33ff8d20ea6449054a3fda641201c", "filename": "src/test/ui/conversion-methods.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fconversion-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fconversion-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconversion-methods.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -41,7 +41,7 @@ LL |     let _prove_piercing_earnest: Vec<usize> = &[1, 2, 3];\n    |                                               ^^^^^^^^^^\n    |                                               |\n    |                                               expected struct `std::vec::Vec`, found reference\n-   |                                               help: try using a conversion method: `&[1, 2, 3].to_vec()`\n+   |                                               help: try using a conversion method: `(&[1, 2, 3]).to_vec()`\n    |\n    = note: expected type `std::vec::Vec<usize>`\n               found type `&[{integer}; 3]`"}, {"sha": "f4567554d0dbbe160d701dd2834f56019d877257", "filename": "src/test/ui/infinite/infinite-autoderef.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -5,7 +5,7 @@ LL |         x = box x;\n    |             ^^^^^\n    |             |\n    |             cyclic type of infinite size\n-   |             help: try using a conversion method: `box x.to_string()`\n+   |             help: try using a conversion method: `(box x).to_string()`\n \n error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n   --> $DIR/infinite-autoderef.rs:25:5"}, {"sha": "9a5c183ca342881384d2ae5cd587cf3e0ed531cd", "filename": "src/test/ui/mismatched_types/abridged.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -50,4 +50,13 @@ fn e() -> X<X<String, String>, String> {\n     x //~ ERROR mismatched types\n }\n \n+fn f() -> String {\n+    1+2 //~ ERROR mismatched types\n+}\n+\n+\n+fn g() -> String {\n+    -2 //~ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "ded12d89c099dda001fd03cc4778c5a067dec54d", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -66,6 +66,34 @@ LL |     x\n    = note: expected type `X<X<_, std::string::String>, _>`\n               found type `X<X<_, {integer}>, _>`\n \n-error: aborting due to 6 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:54:5\n+   |\n+LL | fn f() -> String {\n+   |           ------ expected `std::string::String` because of return type\n+LL |     1+2\n+   |     ^^^\n+   |     |\n+   |     expected struct `std::string::String`, found integer\n+   |     help: try using a conversion method: `(1+2).to_string()`\n+   |\n+   = note: expected type `std::string::String`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:59:5\n+   |\n+LL | fn g() -> String {\n+   |           ------ expected `std::string::String` because of return type\n+LL |     -2\n+   |     ^^\n+   |     |\n+   |     expected struct `std::string::String`, found integer\n+   |     help: try using a conversion method: `(-2).to_string()`\n+   |\n+   = note: expected type `std::string::String`\n+              found type `{integer}`\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "7f93697c6f7a75977e318b829b0eece7be122e1c", "filename": "src/test/ui/occurs-check-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Foccurs-check-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Foccurs-check-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foccurs-check-2.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -5,7 +5,7 @@ LL |     f = box g;\n    |         ^^^^^\n    |         |\n    |         cyclic type of infinite size\n-   |         help: try using a conversion method: `box g.to_string()`\n+   |         help: try using a conversion method: `(box g).to_string()`\n \n error: aborting due to previous error\n "}, {"sha": "01e2b1f7749108e1a97645a5a8429e6cbdec5b4c", "filename": "src/test/ui/occurs-check.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Foccurs-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Foccurs-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foccurs-check.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -5,7 +5,7 @@ LL |     f = box f;\n    |         ^^^^^\n    |         |\n    |         cyclic type of infinite size\n-   |         help: try using a conversion method: `box f.to_string()`\n+   |         help: try using a conversion method: `(box f).to_string()`\n \n error: aborting due to previous error\n "}, {"sha": "0d15a2a753ed0f78c27c2b9c51a07b13a3be9bc6", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7130fc54e05e247f93c7ecc2d10f56b314c97831/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=7130fc54e05e247f93c7ecc2d10f56b314c97831", "patch": "@@ -44,7 +44,7 @@ LL |     f = box f;\n    |         ^^^^^\n    |         |\n    |         cyclic type of infinite size\n-   |         help: try using a conversion method: `box f.to_string()`\n+   |         help: try using a conversion method: `(box f).to_string()`\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:21:9"}]}