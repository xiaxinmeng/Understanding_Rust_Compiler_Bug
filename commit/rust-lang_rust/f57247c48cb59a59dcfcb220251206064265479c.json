{"sha": "f57247c48cb59a59dcfcb220251206064265479c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NzI0N2M0OGNiNTlhNTlkY2ZjYjIyMDI1MTIwNjA2NDI2NTQ3OWM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-10-24T04:57:09Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-11-28T17:27:11Z"}, "message": "Ensure that Rusdoc discovers all necessary auto trait bounds\n\nFixes #50159\n\nThis commit makes several improvements to AutoTraitFinder:\n\n* Call infcx.resolve_type_vars_if_possible before processing new\npredicates. This ensures that we eliminate inference variables wherever\npossible.\n* Process all nested obligations we get from a vtable, not just ones\nwith depth=1.\n  * The 'depth=1' check was a hack to work around issues processing\ncertain predicates. The other changes in this commit allow us to\nproperly process all predicates that we encounter, so the check is no\nlonger necessary,\n* Ensure that we only display predicates *without* inference variables\nto the user, and only attempt to unify predicates that *have* an\ninference variable as their type.\n\nAdditionally, the internal helper method is_of_param now operates\ndirectly on a type, rather than taking a Substs. This allows us to use\nthe 'self_ty' method, rather than directly dealing with Substs.", "tree": {"sha": "7362cb867659c1715c24a77d090f3d0ccac5c279", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7362cb867659c1715c24a77d090f3d0ccac5c279"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f57247c48cb59a59dcfcb220251206064265479c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlv+z+8ACgkQtAh+UQ6Y\nsWQ4SA//atgMfqx3nPpnLlbEMTDIVjDpEQH+xNJCjzr42CB3UHHPJTZHBO8mFjQw\nKCqnrEejetT7YaXf4aJJ5Mts74k1NM200VwKZbagS1EC/opDAFsT245GzSuTEe7k\n0L4TP+8IhMVGYy5Cwk2mUDe5y23ZKkX4v97IiC0P4UbTmo4Yn3Q/sa7m9OthpSy/\n4dedXHZBtzpzTZWR0lOZaYPPsrdBXP3gEtrpbmrHvHwZ2QenhBxhuGL3jNfLQ+c1\nQShC7wwO+ibE4KW3K4lr3jA+qMWQ8YfTKnhzdr3Trp9P2E8EC0iz4/lgYZyuH2AQ\nEekGV7WX8dWgw4J0I2I/zuaKjRjBT34o6iR7jbUXnz5QMqahCl9A8Y4TJB+ppYUN\nr4/Yflcw5KHYhAhEJG8aWfx6DWYpAfm5FxMhBByyqWfLtnk48ZPC/MBrOMatm7CR\nYi/OQt7Fh7VOQ7FZEKIh2u+TDVZbZY+u/OijRrqIkGYi5mj12l86bOQwVvqlTmui\nueWQeZuHpclro7jeHvFMu6bS9lCKehFx6zn2Zc6t/QYAVgTFZvSITkySjJPQMGIg\n+kTWKEJZ8itJoXcSkaykYaLuwAUhmAGRfycTmxH99o2zXe44eg7etJVsXlebdCZB\ncovKrNbal5CiU2V1GdGHc/CVtb8ukXLIseWV/OtkcRYyvkgm1P4=\n=U11y\n-----END PGP SIGNATURE-----", "payload": "tree 7362cb867659c1715c24a77d090f3d0ccac5c279\nparent b68fc18c45350e1cdcd83cecf0f12e294e55af56\nauthor Aaron Hill <aa1ronham@gmail.com> 1540357029 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1543426031 -0500\n\nEnsure that Rusdoc discovers all necessary auto trait bounds\n\nFixes #50159\n\nThis commit makes several improvements to AutoTraitFinder:\n\n* Call infcx.resolve_type_vars_if_possible before processing new\npredicates. This ensures that we eliminate inference variables wherever\npossible.\n* Process all nested obligations we get from a vtable, not just ones\nwith depth=1.\n  * The 'depth=1' check was a hack to work around issues processing\ncertain predicates. The other changes in this commit allow us to\nproperly process all predicates that we encounter, so the check is no\nlonger necessary,\n* Ensure that we only display predicates *without* inference variables\nto the user, and only attempt to unify predicates that *have* an\ninference variable as their type.\n\nAdditionally, the internal helper method is_of_param now operates\ndirectly on a type, rather than taking a Substs. This allows us to use\nthe 'self_ty' method, rather than directly dealing with Substs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f57247c48cb59a59dcfcb220251206064265479c", "html_url": "https://github.com/rust-lang/rust/commit/f57247c48cb59a59dcfcb220251206064265479c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f57247c48cb59a59dcfcb220251206064265479c/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b68fc18c45350e1cdcd83cecf0f12e294e55af56", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68fc18c45350e1cdcd83cecf0f12e294e55af56", "html_url": "https://github.com/rust-lang/rust/commit/b68fc18c45350e1cdcd83cecf0f12e294e55af56"}], "stats": {"total": 99, "additions": 82, "deletions": 17}, "files": [{"sha": "6279788adc019341f52e7d1ce5ba2b2d64f15b94", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f57247c48cb59a59dcfcb220251206064265479c/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f57247c48cb59a59dcfcb220251206064265479c/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=f57247c48cb59a59dcfcb220251206064265479c", "patch": "@@ -334,7 +334,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 continue;\n             }\n \n-            let result = select.select(&Obligation::new(dummy_cause.clone(), new_env, pred));\n+            // Call infcx.resolve_type_vars_if_possible to see if we can\n+            // get rid of any inference variables.\n+            let obligation = infcx.resolve_type_vars_if_possible(\n+                &Obligation::new(dummy_cause.clone(), new_env, pred)\n+            );\n+            let result = select.select(&obligation);\n \n             match &result {\n                 &Ok(Some(ref vtable)) => {\n@@ -369,7 +374,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 &Ok(None) => {}\n                 &Err(SelectionError::Unimplemented) => {\n-                    if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n+                    if self.is_of_param(pred.skip_binder().self_ty()) {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n@@ -631,14 +636,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         finished_map\n     }\n \n-    pub fn is_of_param(&self, substs: &Substs<'_>) -> bool {\n-        if substs.is_noop() {\n-            return false;\n-        }\n-\n-        return match substs.type_at(0).sty {\n+    pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n+        return match ty.sty {\n             ty::Param(_) => true,\n-            ty::Projection(p) => self.is_of_param(p.substs),\n+            ty::Projection(p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         };\n     }\n@@ -661,28 +662,61 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     ) -> bool {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n \n-        for (obligation, predicate) in nested\n-            .filter(|o| o.recursion_depth == 1)\n+        for (obligation, mut predicate) in nested\n             .map(|o| (o.clone(), o.predicate.clone()))\n         {\n             let is_new_pred =\n                 fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n \n+            // Resolve any inference variables that we can, to help selection succeed\n+            predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n+\n+            // We only add a predicate as a user-displayable bound if\n+            // it involves a generic parameter, and doesn't contain\n+            // any inference variables.\n+            //\n+            // Displaying a bound involving a concrete type (instead of a generic\n+            // parameter) would be pointless, since it's always true\n+            // (e.g. u8: Copy)\n+            // Displaying an inference variable is impossible, since they're\n+            // an internal compiler detail without a defined visual representation\n+            //\n+            // We check this by calling is_of_param on the relevant types\n+            // from the various possible predicates\n             match &predicate {\n                 &ty::Predicate::Trait(ref p) => {\n-                    let substs = &p.skip_binder().trait_ref.substs;\n+                    if self.is_of_param(p.skip_binder().self_ty())\n+                        && !only_projections\n+                        && is_new_pred {\n \n-                    if self.is_of_param(substs) && !only_projections && is_new_pred {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n                     predicates.push_back(p.clone());\n                 }\n                 &ty::Predicate::Projection(p) => {\n-                    // If the projection isn't all type vars, then\n-                    // we don't want to add it as a bound\n-                    if self.is_of_param(p.skip_binder().projection_ty.substs) && is_new_pred {\n+                    debug!(\"evaluate_nested_obligations: examining projection predicate {:?}\",\n+                           predicate);\n+\n+                    // As described above, we only want to display\n+                    // bounds which include a generic parameter but don't include\n+                    // an inference variable.\n+                    // Additionally, we check if we've seen this predicate before,\n+                    // to avoid rendering duplicate bounds to the user.\n+                    if self.is_of_param(p.skip_binder().projection_ty.self_ty())\n+                        && !p.ty().skip_binder().is_ty_infer()\n+                        && is_new_pred {\n+                            debug!(\"evaluate_nested_obligations: adding projection predicate\\\n+                            to computed_preds: {:?}\", predicate);\n+\n                         self.add_user_pred(computed_preds, predicate);\n-                    } else {\n+                    }\n+\n+                    // We can only call poly_project_and_unify_type when our predicate's\n+                    // Ty is an inference variable - otherwise, there won't be anything to\n+                    // unify\n+                    if p.ty().skip_binder().is_ty_infer() {\n+                        debug!(\"Projecting and unifying projection predicate {:?}\",\n+                               predicate);\n                         match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n                             Err(e) => {\n                                 debug!("}, {"sha": "3055c721624529d7397fc63636a9dede3489bcf3", "filename": "src/test/rustdoc/issue-50159.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f57247c48cb59a59dcfcb220251206064265479c/src%2Ftest%2Frustdoc%2Fissue-50159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f57247c48cb59a59dcfcb220251206064265479c/src%2Ftest%2Frustdoc%2Fissue-50159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-50159.rs?ref=f57247c48cb59a59dcfcb220251206064265479c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub trait Signal {\n+    type Item;\n+}\n+\n+pub trait Signal2 {\n+    type Item2;\n+}\n+\n+impl<B, C> Signal2 for B where B: Signal<Item = C> {\n+    type Item2 = C;\n+}\n+\n+// @has issue_50159/struct.Switch.html\n+// @has - '//code' 'impl<B> Send for Switch<B> where <B as Signal>::Item: Send'\n+// @has - '//code' 'impl<B> Sync for Switch<B> where <B as Signal>::Item: Sync'\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 0\n+// @count - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]' 2\n+pub struct Switch<B: Signal> {\n+    pub inner: <B as Signal2>::Item2,\n+}"}]}