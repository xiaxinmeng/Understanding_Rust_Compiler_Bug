{"sha": "5bb4a12900969b3250c490a5e0682c658fe65ba8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYjRhMTI5MDA5NjliMzI1MGM0OTBhNWUwNjgyYzY1OGZlNjViYTg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-20T22:06:17Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-20T23:23:19Z"}, "message": "[1/4 for #2365, #2671] Fix create/kill race with schedulers and tasks during rust_kernel::fail", "tree": {"sha": "9fee7318849691fd35658af7363dfdd8d433b0c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fee7318849691fd35658af7363dfdd8d433b0c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bb4a12900969b3250c490a5e0682c658fe65ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bb4a12900969b3250c490a5e0682c658fe65ba8", "html_url": "https://github.com/rust-lang/rust/commit/5bb4a12900969b3250c490a5e0682c658fe65ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bb4a12900969b3250c490a5e0682c658fe65ba8/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55999fd7a03b4f876e69e94e491d3c30bf0c076", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55999fd7a03b4f876e69e94e491d3c30bf0c076", "html_url": "https://github.com/rust-lang/rust/commit/f55999fd7a03b4f876e69e94e491d3c30bf0c076"}], "stats": {"total": 101, "additions": 69, "deletions": 32}, "files": [{"sha": "7b1adf3ef4cf8c02b1c871aa8ade1853cfd79624", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -19,6 +19,7 @@ rust_kernel::rust_kernel(rust_env *env) :\n     max_port_id(1),\n     rval(0),\n     max_sched_id(1),\n+    killed(false),\n     sched_reaper(this),\n     osmain_driver(NULL),\n     non_weak_tasks(0),\n@@ -103,7 +104,8 @@ rust_kernel::create_scheduler(rust_sched_launcher_factory *launchfac,\n         id = max_sched_id++;\n         assert(id != INTPTR_MAX && \"Hit the maximum scheduler id\");\n         sched = new (this, \"rust_scheduler\")\n-            rust_scheduler(this, num_threads, id, allow_exit, launchfac);\n+            rust_scheduler(this, num_threads, id, allow_exit, killed,\n+                           launchfac);\n         bool is_new = sched_table\n             .insert(std::pair<rust_sched_id,\n                               rust_scheduler*>(id, sched)).second;\n@@ -197,6 +199,10 @@ rust_kernel::fail() {\n #endif\n     // Copy the list of schedulers so that we don't hold the lock while\n     // running kill_all_tasks.\n+    // I think this only needs to be done by one task ever; as it is,\n+    // multiple tasks invoking kill_all might get here. Currently libcore\n+    // ensures only one task will ever invoke it, but this would really be\n+    // fine either way, so I'm leaving it as it is. -- bblum\n     // FIXME (#2671): There's a lot that happens under kill_all_tasks,\n     // and I don't know that holding sched_lock here is ok, but we need\n     // to hold the sched lock to prevent the scheduler from being\n@@ -205,15 +211,13 @@ rust_kernel::fail() {\n     std::vector<rust_scheduler*> scheds;\n     {\n         scoped_lock with(sched_lock);\n+        killed = true;\n         for (sched_map::iterator iter = sched_table.begin();\n              iter != sched_table.end(); iter++) {\n             scheds.push_back(iter->second);\n         }\n     }\n \n-    // FIXME (#2671): This is not a foolproof way to kill all tasks\n-    // while ensuring that no new tasks or schedulers are created in the\n-    // meantime that keep the scheduler alive.\n     for (std::vector<rust_scheduler*>::iterator iter = scheds.begin();\n          iter != scheds.end(); iter++) {\n         (*iter)->kill_all_tasks();"}, {"sha": "00c78dea2f9c77a32b73ceb19f5b7c16b9ee5dcd", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -72,7 +72,7 @@ class rust_kernel {\n     lock_and_signal rval_lock;\n     int rval;\n \n-    // Protects max_sched_id and sched_table, join_list\n+    // Protects max_sched_id and sched_table, join_list, killed\n     lock_and_signal sched_lock;\n     // The next scheduler id\n     rust_sched_id max_sched_id;\n@@ -81,6 +81,10 @@ class rust_kernel {\n     sched_map sched_table;\n     // A list of scheduler ids that are ready to exit\n     std::vector<rust_sched_id> join_list;\n+    // Whether or not the runtime has to die (triggered when the root/main\n+    // task group fails). This propagates to all new schedulers and tasks\n+    // created after it is set.\n+    bool killed;\n \n     rust_sched_reaper sched_reaper;\n     // The single-threaded scheduler that uses the main thread"}, {"sha": "9dfa06800b6db3ae819f2998390bda90a9de750c", "filename": "src/rt/rust_sched_launcher.cpp", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_launcher.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_launcher.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.cpp?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -4,33 +4,36 @@\n \n const size_t SCHED_STACK_SIZE = 1024*100;\n \n-rust_sched_launcher::rust_sched_launcher(rust_scheduler *sched, int id)\n+rust_sched_launcher::rust_sched_launcher(rust_scheduler *sched, int id,\n+                                         bool killed)\n     : kernel(sched->kernel),\n-      sched_loop(sched, id),\n+      sched_loop(sched, id, killed),\n       driver(&sched_loop) {\n }\n \n rust_thread_sched_launcher::rust_thread_sched_launcher(rust_scheduler *sched,\n-                                                       int id)\n-    : rust_sched_launcher(sched, id),\n+                                                       int id, bool killed)\n+    : rust_sched_launcher(sched, id, killed),\n       rust_thread(SCHED_STACK_SIZE) {\n }\n \n rust_manual_sched_launcher::rust_manual_sched_launcher(rust_scheduler *sched,\n-                                                       int id)\n-    : rust_sched_launcher(sched, id) {\n+                                                       int id, bool killed)\n+    : rust_sched_launcher(sched, id, killed) {\n }\n \n rust_sched_launcher *\n-rust_thread_sched_launcher_factory::create(rust_scheduler *sched, int id) {\n+rust_thread_sched_launcher_factory::create(rust_scheduler *sched, int id,\n+                                           bool killed) {\n     return new(sched->kernel, \"rust_thread_sched_launcher\")\n-        rust_thread_sched_launcher(sched, id);\n+        rust_thread_sched_launcher(sched, id, killed);\n }\n \n rust_sched_launcher *\n-rust_manual_sched_launcher_factory::create(rust_scheduler *sched, int id) {\n+rust_manual_sched_launcher_factory::create(rust_scheduler *sched, int id,\n+                                           bool killed) {\n     assert(launcher == NULL && \"I can only track one sched_launcher\");\n     launcher = new(sched->kernel, \"rust_manual_sched_launcher\")\n-        rust_manual_sched_launcher(sched, id);\n+        rust_manual_sched_launcher(sched, id, killed);\n     return launcher;\n }"}, {"sha": "72c9fd2dd36fa9ae8229476e1b2e1ec696448b93", "filename": "src/rt/rust_sched_launcher.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_launcher.h", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_launcher.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.h?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -17,7 +17,7 @@ class rust_sched_launcher : public kernel_owned<rust_sched_launcher> {\n     rust_sched_driver driver;\n \n public:\n-    rust_sched_launcher(rust_scheduler *sched, int id);\n+    rust_sched_launcher(rust_scheduler *sched, int id, bool killed);\n     virtual ~rust_sched_launcher() { }\n \n     virtual void start() = 0;\n@@ -29,15 +29,15 @@ class rust_thread_sched_launcher\n   :public rust_sched_launcher,\n    private rust_thread {\n public:\n-    rust_thread_sched_launcher(rust_scheduler *sched, int id);\n+    rust_thread_sched_launcher(rust_scheduler *sched, int id, bool killed);\n     virtual void start() { rust_thread::start(); }\n     virtual void join() { rust_thread::join(); }\n     virtual void run() { driver.start_main_loop(); }\n };\n \n class rust_manual_sched_launcher : public rust_sched_launcher {\n public:\n-    rust_manual_sched_launcher(rust_scheduler *sched, int id);\n+    rust_manual_sched_launcher(rust_scheduler *sched, int id, bool killed);\n     virtual void start() { }\n     virtual void join() { }\n     rust_sched_driver *get_driver() { return &driver; };\n@@ -47,13 +47,14 @@ class rust_sched_launcher_factory {\n public:\n     virtual ~rust_sched_launcher_factory() { }\n     virtual rust_sched_launcher *\n-    create(rust_scheduler *sched, int id) = 0;\n+    create(rust_scheduler *sched, int id, bool killed) = 0;\n };\n \n class rust_thread_sched_launcher_factory\n     : public rust_sched_launcher_factory {\n public:\n-    virtual rust_sched_launcher *create(rust_scheduler *sched, int id);\n+    virtual rust_sched_launcher *create(rust_scheduler *sched, int id,\n+                                        bool killed);\n };\n \n class rust_manual_sched_launcher_factory\n@@ -62,7 +63,8 @@ class rust_manual_sched_launcher_factory\n     rust_manual_sched_launcher *launcher;\n public:\n     rust_manual_sched_launcher_factory() : launcher(NULL) { }\n-    virtual rust_sched_launcher *create(rust_scheduler *sched, int id);\n+    virtual rust_sched_launcher *create(rust_scheduler *sched, int id,\n+                                        bool killed);\n     rust_sched_driver *get_driver() {\n         assert(launcher != NULL);\n         return launcher->get_driver();"}, {"sha": "aa2c62c630d9aa8dff4bee4dd05f177a8cbf3196", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -13,12 +13,13 @@ const size_t C_STACK_SIZE = 1024*1024;\n \n bool rust_sched_loop::tls_initialized = false;\n \n-rust_sched_loop::rust_sched_loop(rust_scheduler *sched,int id) :\n+rust_sched_loop::rust_sched_loop(rust_scheduler *sched, int id, bool killed) :\n     _log(this),\n     id(id),\n     should_exit(false),\n     cached_c_stack(NULL),\n     dead_task(NULL),\n+    killed(killed),\n     pump_signal(NULL),\n     kernel(sched->kernel),\n     sched(sched),\n@@ -63,6 +64,8 @@ rust_sched_loop::kill_all_tasks() {\n \n     {\n         scoped_lock with(lock);\n+        // Any task created after this will be killed. See transition, below.\n+        killed = true;\n \n         for (size_t i = 0; i < running_tasks.length(); i++) {\n             all_tasks.push_back(running_tasks[i]);\n@@ -319,6 +322,11 @@ rust_sched_loop::transition(rust_task *task,\n     }\n     task->set_state(dst, cond, cond_name);\n \n+    // If the entire runtime is failing, newborn tasks must be doomed.\n+    if (src == task_state_newborn && killed) {\n+        task->kill_inner();\n+    }\n+\n     pump_loop();\n }\n "}, {"sha": "eb70fe07b7e39fe726c149032b3a5cf9c426b1ee", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -60,6 +60,7 @@ struct rust_sched_loop\n     rust_task_list running_tasks;\n     rust_task_list blocked_tasks;\n     rust_task *dead_task;\n+    bool killed;\n \n     rust_signal *pump_signal;\n \n@@ -91,7 +92,7 @@ struct rust_sched_loop\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_sched_loop(rust_scheduler *sched, int id);\n+    rust_sched_loop(rust_scheduler *sched, int id, bool killed);\n     void activate(rust_task *task);\n     rust_log & get_log();\n     void fail();\n@@ -107,6 +108,7 @@ struct rust_sched_loop\n     void log_state();\n \n     void kill_all_tasks();\n+    bool doomed();\n \n     rust_task *create_task(rust_task *spawner, const char *name);\n "}, {"sha": "dc662b009ac1232b40fa43b3207c51a5229df86c", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -9,6 +9,7 @@ rust_scheduler::rust_scheduler(rust_kernel *kernel,\n                                size_t num_threads,\n                                rust_sched_id id,\n                                bool allow_exit,\n+                               bool killed,\n                                rust_sched_launcher_factory *launchfac) :\n     kernel(kernel),\n     live_threads(num_threads),\n@@ -18,7 +19,7 @@ rust_scheduler::rust_scheduler(rust_kernel *kernel,\n     num_threads(num_threads),\n     id(id)\n {\n-    create_task_threads(launchfac);\n+    create_task_threads(launchfac, killed);\n }\n \n rust_scheduler::~rust_scheduler() {\n@@ -27,8 +28,8 @@ rust_scheduler::~rust_scheduler() {\n \n rust_sched_launcher *\n rust_scheduler::create_task_thread(rust_sched_launcher_factory *launchfac,\n-                                   int id) {\n-    rust_sched_launcher *thread = launchfac->create(this, id);\n+                                   int id, bool killed) {\n+    rust_sched_launcher *thread = launchfac->create(this, id, killed);\n     KLOG(kernel, kern, \"created task thread: \" PTR \", id: %d\",\n           thread, id);\n     return thread;\n@@ -41,11 +42,12 @@ rust_scheduler::destroy_task_thread(rust_sched_launcher *thread) {\n }\n \n void\n-rust_scheduler::create_task_threads(rust_sched_launcher_factory *launchfac) {\n+rust_scheduler::create_task_threads(rust_sched_launcher_factory *launchfac,\n+                                    bool killed) {\n     KLOG(kernel, kern, \"Using %d scheduler threads.\", num_threads);\n \n     for(size_t i = 0; i < num_threads; ++i) {\n-        threads.push(create_task_thread(launchfac, i));\n+        threads.push(create_task_thread(launchfac, i, killed));\n     }\n }\n "}, {"sha": "699354f6d78e9522bcab87970e72b16fdc9dbcdf", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -34,18 +34,20 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n \n     rust_sched_id id;\n \n-    void create_task_threads(rust_sched_launcher_factory *launchfac);\n+    void create_task_threads(rust_sched_launcher_factory *launchfac,\n+                             bool killed);\n     void destroy_task_threads();\n \n     rust_sched_launcher *\n-    create_task_thread(rust_sched_launcher_factory *launchfac, int id);\n+    create_task_thread(rust_sched_launcher_factory *launchfac, int id,\n+                       bool killed);\n     void destroy_task_thread(rust_sched_launcher *thread);\n \n     void exit();\n \n public:\n     rust_scheduler(rust_kernel *kernel, size_t num_threads,\n-                   rust_sched_id id, bool allow_exit,\n+                   rust_sched_id id, bool allow_exit, bool killed,\n                    rust_sched_launcher_factory *launchfac);\n     ~rust_scheduler();\n "}, {"sha": "c28e3350bf28fbaa2763c84a77a857e72f65798c", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -257,8 +257,17 @@ rust_task::yield(bool *killed) {\n void\n rust_task::kill() {\n     scoped_lock with(lifecycle_lock);\n+    kill_inner();\n+}\n+\n+void rust_task::kill_inner() {\n+    lifecycle_lock.must_have_lock();\n \n-    // XXX: bblum: kill/kill race\n+    // Multiple kills should be able to safely race, but check anyway.\n+    if (killed) {\n+        LOG(this, task, \"task %s @0x%\" PRIxPTR \" already killed\", name, this);\n+        return;\n+    }\n \n     // Note the distinction here: kill() is when you're in an upcall\n     // from task A and want to force-fail task B, you do B->kill()."}, {"sha": "e9538a5abd54d8ee27f8b458b8964fc257ce156c", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/5bb4a12900969b3250c490a5e0682c658fe65ba8/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=5bb4a12900969b3250c490a5e0682c658fe65ba8", "patch": "@@ -264,6 +264,7 @@ rust_task : public kernel_owned<rust_task>\n \n     // Fail this task (assuming caller-on-stack is different task).\n     void kill();\n+    void kill_inner();\n \n     // Indicates that we've been killed and now is an apropriate\n     // time to fail as a result"}]}