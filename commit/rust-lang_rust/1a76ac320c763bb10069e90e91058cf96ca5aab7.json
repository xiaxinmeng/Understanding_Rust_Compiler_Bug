{"sha": "1a76ac320c763bb10069e90e91058cf96ca5aab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNzZhYzMyMGM3NjNiYjEwMDY5ZTkwZTkxMDU4Y2Y5NmNhNWFhYjc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-20T11:36:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:54Z"}, "message": "rustc: de-@ trans::_match.", "tree": {"sha": "669a7295d3b048e6d3d4a6c43249bb9aba07e7e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669a7295d3b048e6d3d4a6c43249bb9aba07e7e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a76ac320c763bb10069e90e91058cf96ca5aab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a76ac320c763bb10069e90e91058cf96ca5aab7", "html_url": "https://github.com/rust-lang/rust/commit/1a76ac320c763bb10069e90e91058cf96ca5aab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a76ac320c763bb10069e90e91058cf96ca5aab7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075ab306505ccaaf350a70a56130b45bab6f2a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/075ab306505ccaaf350a70a56130b45bab6f2a21", "html_url": "https://github.com/rust-lang/rust/commit/075ab306505ccaaf350a70a56130b45bab6f2a21"}], "stats": {"total": 201, "additions": 91, "deletions": 110}, "files": [{"sha": "6c71cf86e8e93b145de08a01f9114e41b83606b5", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 91, "deletions": 110, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/1a76ac320c763bb10069e90e91058cf96ca5aab7/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a76ac320c763bb10069e90e91058cf96ca5aab7/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1a76ac320c763bb10069e90e91058cf96ca5aab7", "patch": "@@ -417,15 +417,10 @@ struct BindingInfo {\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n-struct ArmData<'a,'b> {\n+struct ArmData<'a, 'b> {\n     bodycx: &'b Block<'b>,\n     arm: &'a ast::Arm,\n-    bindings_map: @BindingsMap\n-}\n-\n-// FIXME #11820: method resolution is unreliable with &\n-impl<'a,'b> Clone for ArmData<'a, 'b> {\n-    fn clone(&self) -> ArmData<'a, 'b> { *self }\n+    bindings_map: BindingsMap\n }\n \n /**\n@@ -434,14 +429,13 @@ impl<'a,'b> Clone for ArmData<'a, 'b> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n-#[deriving(Clone)]\n-struct Match<'a,'b> {\n-    pats: Vec<@ast::Pat> ,\n-    data: ArmData<'a,'b>,\n+struct Match<'a, 'b> {\n+    pats: Vec<@ast::Pat>,\n+    data: &'a ArmData<'a, 'b>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n \n-impl<'a,'b> Repr for Match<'a,'b> {\n+impl<'a, 'b> Repr for Match<'a, 'b> {\n     fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -462,12 +456,12 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'r,'b>(\n+fn expand_nested_bindings<'a, 'b>(\n                           bcx: &'b Block<'b>,\n-                          m: &[Match<'r,'b>],\n+                          m: &'a [Match<'a, 'b>],\n                           col: uint,\n                           val: ValueRef)\n-                          -> Vec<Match<'r,'b>> {\n+                          -> Vec<Match<'a, 'b>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -482,15 +476,19 @@ fn expand_nested_bindings<'r,'b>(\n                            .append((vec!(inner))\n                                    .append(br.pats.slice(col + 1u, br.pats.len())).as_slice());\n \n-                let mut res = Match {\n+                let mut bound_ptrs = br.bound_ptrs.clone();\n+                bound_ptrs.push((path_to_ident(path), val));\n+                Match {\n                     pats: pats,\n-                    data: br.data.clone(),\n-                    bound_ptrs: br.bound_ptrs.clone()\n-                };\n-                res.bound_ptrs.push((path_to_ident(path), val));\n-                res\n+                    data: &*br.data,\n+                    bound_ptrs: bound_ptrs\n+                }\n+            }\n+            _ => Match {\n+                pats: br.pats.clone(),\n+                data: &*br.data,\n+                bound_ptrs: br.bound_ptrs.clone()\n             }\n-            _ => (*br).clone(),\n         }\n     }).collect()\n }\n@@ -506,62 +504,54 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n \n type enter_pat<'a> = |@ast::Pat|: 'a -> Option<Vec<@ast::Pat>>;\n \n-fn enter_match<'r,'b>(\n+fn enter_match<'a, 'b>(\n                bcx: &'b Block<'b>,\n                dm: &DefMap,\n-               m: &[Match<'r,'b>],\n+               m: &'a [Match<'a, 'b>],\n                col: uint,\n                val: ValueRef,\n                e: enter_pat)\n-               -> Vec<Match<'r,'b>> {\n+               -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let mut result = Vec::new();\n-    for br in m.iter() {\n-        match e(*br.pats.get(col)) {\n-            Some(sub) => {\n-                let pats = sub.append(br.pats.slice(0u, col))\n-                              .append(br.pats.slice(col + 1u, br.pats.len()));\n-\n-                let this = *br.pats.get(col);\n-                let mut bound_ptrs = br.bound_ptrs.clone();\n-                match this.node {\n-                    ast::PatIdent(_, ref path, None) => {\n-                        if pat_is_binding(dm, this) {\n-                            bound_ptrs.push((path_to_ident(path), val));\n-                        }\n+    m.iter().filter_map(|br| {\n+        e(*br.pats.get(col)).map(|sub| {\n+            let pats = sub.append(br.pats.slice(0u, col))\n+                            .append(br.pats.slice(col + 1u, br.pats.len()));\n+\n+            let this = *br.pats.get(col);\n+            let mut bound_ptrs = br.bound_ptrs.clone();\n+            match this.node {\n+                ast::PatIdent(_, ref path, None) => {\n+                    if pat_is_binding(dm, this) {\n+                        bound_ptrs.push((path_to_ident(path), val));\n                     }\n-                    _ => {}\n                 }\n-\n-                result.push(Match {\n-                    pats: pats,\n-                    data: br.data.clone(),\n-                    bound_ptrs: bound_ptrs\n-                });\n+                _ => {}\n             }\n-            None => ()\n-        }\n-    }\n-\n-    debug!(\"result={}\", result.repr(bcx.tcx()));\n \n-    return result;\n+            Match {\n+                pats: pats,\n+                data: br.data,\n+                bound_ptrs: bound_ptrs\n+            }\n+        })\n+    }).collect()\n }\n \n-fn enter_default<'r,'b>(\n+fn enter_default<'a, 'b>(\n                  bcx: &'b Block<'b>,\n                  dm: &DefMap,\n-                 m: &[Match<'r,'b>],\n+                 m: &'a [Match<'a, 'b>],\n                  col: uint,\n                  val: ValueRef,\n                  chk: &FailureHandler)\n-                 -> Vec<Match<'r,'b>> {\n+                 -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -625,14 +615,14 @@ fn enter_default<'r,'b>(\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-fn enter_opt<'r,'b>(\n+fn enter_opt<'a, 'b>(\n              bcx: &'b Block<'b>,\n-             m: &[Match<'r,'b>],\n+             m: &'a [Match<'a, 'b>],\n              opt: &Opt,\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> Vec<Match<'r,'b>> {\n+             -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -799,14 +789,14 @@ fn enter_opt<'r,'b>(\n     })\n }\n \n-fn enter_rec_or_struct<'r,'b>(\n+fn enter_rec_or_struct<'a, 'b>(\n                        bcx: &'b Block<'b>,\n                        dm: &DefMap,\n-                       m: &[Match<'r,'b>],\n+                       m: &'a [Match<'a, 'b>],\n                        col: uint,\n                        fields: &[ast::Ident],\n                        val: ValueRef)\n-                       -> Vec<Match<'r,'b>> {\n+                       -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -835,14 +825,14 @@ fn enter_rec_or_struct<'r,'b>(\n     })\n }\n \n-fn enter_tup<'r,'b>(\n+fn enter_tup<'a, 'b>(\n              bcx: &'b Block<'b>,\n              dm: &DefMap,\n-             m: &[Match<'r,'b>],\n+             m: &'a [Match<'a, 'b>],\n              col: uint,\n              val: ValueRef,\n              n_elts: uint)\n-             -> Vec<Match<'r,'b>> {\n+             -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -868,14 +858,14 @@ fn enter_tup<'r,'b>(\n     })\n }\n \n-fn enter_tuple_struct<'r,'b>(\n+fn enter_tuple_struct<'a, 'b>(\n                       bcx: &'b Block<'b>,\n                       dm: &DefMap,\n-                      m: &[Match<'r,'b>],\n+                      m: &'a [Match<'a, 'b>],\n                       col: uint,\n                       val: ValueRef,\n                       n_elts: uint)\n-                      -> Vec<Match<'r,'b>> {\n+                      -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -897,13 +887,13 @@ fn enter_tuple_struct<'r,'b>(\n     })\n }\n \n-fn enter_uniq<'r,'b>(\n+fn enter_uniq<'a, 'b>(\n               bcx: &'b Block<'b>,\n               dm: &DefMap,\n-              m: &[Match<'r,'b>],\n+              m: &'a [Match<'a, 'b>],\n               col: uint,\n               val: ValueRef)\n-              -> Vec<Match<'r,'b>> {\n+              -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -925,14 +915,13 @@ fn enter_uniq<'r,'b>(\n     })\n }\n \n-fn enter_region<'r,\n-                'b>(\n+fn enter_region<'a, 'b>(\n                 bcx: &'b Block<'b>,\n                 dm: &DefMap,\n-                m: &[Match<'r,'b>],\n+                m: &'a [Match<'a, 'b>],\n                 col: uint,\n                 val: ValueRef)\n-                -> Vec<Match<'r,'b>> {\n+                -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1424,12 +1413,11 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n     bcx\n }\n \n-fn compile_guard<'r,\n-                 'b>(\n+fn compile_guard<'a, 'b>(\n                  bcx: &'b Block<'b>,\n                  guard_expr: &ast::Expr,\n                  data: &ArmData,\n-                 m: &[Match<'r,'b>],\n+                 m: &'a [Match<'a, 'b>],\n                  vals: &[ValueRef],\n                  chk: &FailureHandler)\n                  -> &'b Block<'b> {\n@@ -1445,9 +1433,9 @@ fn compile_guard<'r,\n     let temp_scope = bcx.fcx.push_custom_cleanup_scope();\n \n     let mut bcx = bcx;\n-    bcx = store_non_ref_bindings(bcx, data.bindings_map,\n+    bcx = store_non_ref_bindings(bcx, &data.bindings_map,\n                                  Some(cleanup::CustomScope(temp_scope)));\n-    bcx = insert_lllocals(bcx, data.bindings_map,\n+    bcx = insert_lllocals(bcx, &data.bindings_map,\n                           cleanup::CustomScope(temp_scope));\n \n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n@@ -1482,10 +1470,9 @@ fn compile_guard<'r,\n     }\n }\n \n-fn compile_submatch<'r,\n-                    'b>(\n+fn compile_submatch<'a, 'b>(\n                     bcx: &'b Block<'b>,\n-                    m: &[Match<'r,'b>],\n+                    m: &'a [Match<'a, 'b>],\n                     vals: &[ValueRef],\n                     chk: &FailureHandler) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n@@ -1514,7 +1501,7 @@ fn compile_submatch<'r,\n             Some(guard_expr) => {\n                 bcx = compile_guard(bcx,\n                                     guard_expr,\n-                                    &m[0].data,\n+                                    m[0].data,\n                                     m.slice(1, m.len()),\n                                     vals,\n                                     chk);\n@@ -1541,10 +1528,9 @@ fn compile_submatch<'r,\n     }\n }\n \n-fn compile_submatch_continue<'r,\n-                             'b>(\n+fn compile_submatch_continue<'a, 'b>(\n                              mut bcx: &'b Block<'b>,\n-                             m: &[Match<'r,'b>],\n+                             m: &'a [Match<'a, 'b>],\n                              vals: &[ValueRef],\n                              chk: &FailureHandler,\n                              col: uint,\n@@ -1933,26 +1919,6 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         return bcx;\n     }\n \n-    let mut arm_datas = Vec::new();\n-    let mut matches = Vec::new();\n-    for arm in arms.iter() {\n-        let body = fcx.new_id_block(\"case_body\", arm.body.id);\n-        let bindings_map = create_bindings_map(bcx, *arm.pats.get(0));\n-        let arm_data = ArmData {\n-            bodycx: body,\n-            arm: arm,\n-            bindings_map: @bindings_map\n-        };\n-        arm_datas.push(arm_data.clone());\n-        for p in arm.pats.iter() {\n-            matches.push(Match {\n-                pats: vec!(*p),\n-                data: arm_data.clone(),\n-                bound_ptrs: Vec::new(),\n-            });\n-        }\n-    }\n-\n     let t = node_id_type(bcx, discr_expr.id);\n     let chk = {\n         if ty::type_is_empty(tcx, t) {\n@@ -1970,8 +1936,23 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n             Infallible\n         }\n     };\n-    let lldiscr = discr_datum.val;\n-    compile_submatch(bcx, matches.as_slice(), [lldiscr], &chk);\n+\n+    let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n+        bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n+        arm: arm,\n+        bindings_map: create_bindings_map(bcx, *arm.pats.get(0))\n+    }).collect();\n+\n+    let mut matches = Vec::new();\n+    for arm_data in arm_datas.iter() {\n+        matches.extend(arm_data.arm.pats.iter().map(|p| Match {\n+            pats: vec!(*p),\n+            data: arm_data,\n+            bound_ptrs: Vec::new(),\n+        }));\n+    }\n+\n+    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1982,12 +1963,12 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         // is just to reduce code space.  See extensive comment at the start\n         // of the file for more details.\n         if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, arm_data.bindings_map, None);\n+            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n         let cleanup_scope = fcx.push_custom_cleanup_scope();\n-        bcx = insert_lllocals(bcx, arm_data.bindings_map,\n+        bcx = insert_lllocals(bcx, &arm_data.bindings_map,\n                               cleanup::CustomScope(cleanup_scope));\n         bcx = expr::trans_into(bcx, arm_data.arm.body, dest);\n         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);"}]}