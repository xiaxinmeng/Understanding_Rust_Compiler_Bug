{"sha": "bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNjFhZDc1NmNjMGE3YmZlYWE1ZGFlODFhYzVhYjUwYTJlNzE2OTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-11T15:30:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-11T15:30:05Z"}, "message": "Merge #4849\n\n4849: Make known paths use `core` instead of `std` r=matklad a=jonas-schievink\n\nI'm not sure if this causes problems today, but it seems like it easily could, if rust-analyzer processes the libstd sources for the right `--target` and that target is a `#![no_std]`-only target.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "382ff970758f62c2d4322c6daf2071b8543133f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382ff970758f62c2d4322c6daf2071b8543133f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4k39CRBK7hj4Ov3rIwAAdHIIABx3X81PLXPb7CrjXaT/XAUC\nlsHaEC114wOUNOHvaDyhhpRyvExsTjclu0aJ+4TtiXVjdzvGGVcxnDcJ7CeMfUpO\n+jLiYt93lHd7DinoVsAWyM+eCnQkvd7UW0h2j/0M0U3XEIaOoc0FxUIGIvag/SaG\n3iJ7C7Se77rLocvcCKOic5rsexfyBkGKG2biMkrdbwJ7V/fhLg5ZxN0tpX9muuaq\nDgpW6yrqEzMUrP67KQLYZhHtqySmCchFlRbLzV3+Q8gcz2pv0meJDf35JDXDl7cB\nqaFhq7rNTHMcha4fqrBzkduWuvYVEqzbZ3AdQ3yj+PXzOGnmpEUHcvlvykyF+w4=\n=ww+t\n-----END PGP SIGNATURE-----\n", "payload": "tree 382ff970758f62c2d4322c6daf2071b8543133f0\nparent 7c617000b832354ea405a9543276505c1c7e6a0a\nparent 215e229dd1a495cda6541371c75145ba03f62de5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1591889405 +0000\ncommitter GitHub <noreply@github.com> 1591889405 +0000\n\nMerge #4849\n\n4849: Make known paths use `core` instead of `std` r=matklad a=jonas-schievink\n\nI'm not sure if this causes problems today, but it seems like it easily could, if rust-analyzer processes the libstd sources for the right `--target` and that target is a `#![no_std]`-only target.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "html_url": "https://github.com/rust-lang/rust/commit/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c617000b832354ea405a9543276505c1c7e6a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c617000b832354ea405a9543276505c1c7e6a0a", "html_url": "https://github.com/rust-lang/rust/commit/7c617000b832354ea405a9543276505c1c7e6a0a"}, {"sha": "215e229dd1a495cda6541371c75145ba03f62de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/215e229dd1a495cda6541371c75145ba03f62de5", "html_url": "https://github.com/rust-lang/rust/commit/215e229dd1a495cda6541371c75145ba03f62de5"}], "stats": {"total": 138, "additions": 65, "deletions": 73}, "files": [{"sha": "53599e74a26643d9c4352ec8709216468685d4d3", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -99,7 +99,7 @@ impl FunctionData {\n }\n \n fn desugar_future_path(orig: TypeRef) -> Path {\n-    let path = path![std::future::Future];\n+    let path = path![core::future::Future];\n     let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n     let mut last = GenericArgs::empty();\n     last.bindings.push(AssociatedTypeBinding {"}, {"sha": "ba16442bd5177d966ba5289b4b5c2c9b49d9ec3f", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -323,16 +323,16 @@ pub use hir_expand::name as __name;\n \n #[macro_export]\n macro_rules! __known_path {\n-    (std::iter::IntoIterator) => {};\n-    (std::result::Result) => {};\n-    (std::ops::Range) => {};\n-    (std::ops::RangeFrom) => {};\n-    (std::ops::RangeFull) => {};\n-    (std::ops::RangeTo) => {};\n-    (std::ops::RangeToInclusive) => {};\n-    (std::ops::RangeInclusive) => {};\n-    (std::future::Future) => {};\n-    (std::ops::Try) => {};\n+    (core::iter::IntoIterator) => {};\n+    (core::result::Result) => {};\n+    (core::ops::Range) => {};\n+    (core::ops::RangeFrom) => {};\n+    (core::ops::RangeFull) => {};\n+    (core::ops::RangeTo) => {};\n+    (core::ops::RangeToInclusive) => {};\n+    (core::ops::RangeInclusive) => {};\n+    (core::future::Future) => {};\n+    (core::ops::Try) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")\n     };"}, {"sha": "7db928dded28396bdd39b0819172299d816eb393", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -226,17 +226,19 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = path![std::result::Result];\n+        let core_result_path = path![core::result::Result];\n \n         let resolver = self.func.resolver(db.upcast());\n-        let std_result_enum = match resolver.resolve_known_enum(db.upcast(), &std_result_path) {\n+        let core_result_enum = match resolver.resolve_known_enum(db.upcast(), &core_result_path) {\n             Some(it) => it,\n             _ => return,\n         };\n \n-        let std_result_ctor = TypeCtor::Adt(AdtId::EnumId(std_result_enum));\n+        let core_result_ctor = TypeCtor::Adt(AdtId::EnumId(core_result_enum));\n         let params = match &mismatch.expected {\n-            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n+            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &core_result_ctor => {\n+                parameters\n+            }\n             _ => return,\n         };\n "}, {"sha": "3719f76a6e21af67df1aadba1450b2259b0ddc21", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -555,13 +555,13 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = path![std::iter::IntoIterator];\n+        let path = path![core::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        let path = path![std::ops::Try];\n+        let path = path![core::ops::Try];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Ok])\n     }\n@@ -587,37 +587,37 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeFull];\n+        let path = path![core::ops::RangeFull];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n-        let path = path![std::ops::Range];\n+        let path = path![core::ops::Range];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeInclusive];\n+        let path = path![core::ops::RangeInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeFrom];\n+        let path = path![core::ops::RangeFrom];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeTo];\n+        let path = path![core::ops::RangeTo];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeToInclusive];\n+        let path = path![core::ops::RangeToInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }"}, {"sha": "37659cd02c8171281a953addbe3ce2b5dc696a07", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -95,7 +95,7 @@ fn foo() {\n fn infer_ranges() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n fn test() {\n     let a = ..;\n     let b = 1..;\n@@ -108,7 +108,7 @@ fn test() {\n     t<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use prelude::*;\n mod prelude {}\n "}, {"sha": "e81193a3c30af12e6a06cf0821f8f9e49b239d46", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -10,7 +10,7 @@ use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n fn infer_await() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n struct IntFuture;\n \n@@ -24,7 +24,7 @@ fn test() {\n     v<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use future::*;\n mod future {\n     #[lang = \"future_trait\"]\n@@ -42,7 +42,7 @@ mod future {\n fn infer_async() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n async fn foo() -> u64 {\n     128\n@@ -54,7 +54,7 @@ fn test() {\n     v<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use future::*;\n mod future {\n     #[lang = \"future_trait\"]\n@@ -72,7 +72,7 @@ mod future {\n fn infer_desugar_async() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n async fn foo() -> u64 {\n     128\n@@ -83,7 +83,7 @@ fn test() {\n     r<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use future::*;\n mod future {\n     trait Future {\n@@ -100,15 +100,15 @@ mod future {\n fn infer_try() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n \n #[prelude_import] use ops::*;\n mod ops {\n@@ -140,9 +140,9 @@ mod result {\n fn infer_for_loop() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core,alloc\n \n-use std::collections::Vec;\n+use alloc::collections::Vec;\n \n fn test() {\n     let v = Vec::new();\n@@ -152,7 +152,7 @@ fn test() {\n     }\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n \n #[prelude_import] use iter::*;\n mod iter {\n@@ -161,14 +161,16 @@ mod iter {\n     }\n }\n \n+//- /alloc.rs crate:alloc deps:core\n+\n mod collections {\n     struct Vec<T> {}\n     impl<T> Vec<T> {\n         fn new() -> Self { Vec {} }\n         fn push(&mut self, t: T) { }\n     }\n \n-    impl<T> crate::iter::IntoIterator for Vec<T> {\n+    impl<T> IntoIterator for Vec<T> {\n         type Item=T;\n     }\n }\n@@ -2846,12 +2848,12 @@ fn test() {\n fn integer_range_iterate() {\n     let t = type_at(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n fn test() {\n     for x in 0..100 { x<|>; }\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n pub mod ops {\n     pub struct Range<Idx> {\n         pub start: Idx,"}, {"sha": "f44feaf697b72ccc82ae48985ceb4c2772d6f516", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=bd61ad756cc0a7bfeaa5dae81ac5ab50a2e71697", "patch": "@@ -321,29 +321,26 @@ mod tests {\n     fn test_wrap_return_type() {\n         let before = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            fn div(x: i32, y: i32) -> Result<i32, String> {\n+            fn div(x: i32, y: i32) -> Result<i32, ()> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 x / y<|>\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n         let after = r#\"\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            fn div(x: i32, y: i32) -> Result<i32, String> {\n+            fn div(x: i32, y: i32) -> Result<i32, ()> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 Ok(x / y)\n             }\n@@ -355,7 +352,7 @@ mod tests {\n     fn test_wrap_return_type_handles_generic_functions() {\n         let before = r#\"\n             //- /main.rs\n-            use std::result::Result::{self, Ok, Err};\n+            use core::result::Result::{self, Ok, Err};\n \n             fn div<T>(x: T) -> Result<T, i32> {\n                 if x == 0 {\n@@ -364,13 +361,13 @@ mod tests {\n                 <|>x\n             }\n \n-            //- /std/lib.rs\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n         let after = r#\"\n-            use std::result::Result::{self, Ok, Err};\n+            use core::result::Result::{self, Ok, Err};\n \n             fn div<T>(x: T) -> Result<T, i32> {\n                 if x == 0 {\n@@ -386,32 +383,29 @@ mod tests {\n     fn test_wrap_return_type_handles_type_aliases() {\n         let before = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            type MyResult<T> = Result<T, String>;\n+            type MyResult<T> = Result<T, ()>;\n \n             fn div(x: i32, y: i32) -> MyResult<i32> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 x <|>/ y\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n         let after = r#\"\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            type MyResult<T> = Result<T, String>;\n+            type MyResult<T> = Result<T, ()>;\n             fn div(x: i32, y: i32) -> MyResult<i32> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 Ok(x / y)\n             }\n@@ -423,16 +417,13 @@ mod tests {\n     fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n         let content = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            fn foo() -> Result<String, i32> {\n+            fn foo() -> Result<(), i32> {\n                 0<|>\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n@@ -444,7 +435,7 @@ mod tests {\n     fn test_wrap_return_type_not_applicable_when_return_type_is_not_result() {\n         let content = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n             enum SomeOtherEnum {\n                 Ok(i32),\n@@ -455,10 +446,7 @@ mod tests {\n                 0<|>\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }"}]}