{"sha": "e81e81f234731a31fad9afdc2045bef3fbdf1109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MWU4MWYyMzQ3MzFhMzFmYWQ5YWZkYzIwNDViZWYzZmJkZjExMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T01:41:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T01:41:13Z"}, "message": "auto merge of #8387 : brson/rust/nooldrt, r=brson", "tree": {"sha": "f15c93f7989462a768b7c333e6dec0445c62472d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f15c93f7989462a768b7c333e6dec0445c62472d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e81e81f234731a31fad9afdc2045bef3fbdf1109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e81e81f234731a31fad9afdc2045bef3fbdf1109", "html_url": "https://github.com/rust-lang/rust/commit/e81e81f234731a31fad9afdc2045bef3fbdf1109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e81e81f234731a31fad9afdc2045bef3fbdf1109/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "html_url": "https://github.com/rust-lang/rust/commit/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338"}, {"sha": "b75915d0ca20c6d066a7368ad53491a55a5a57d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75915d0ca20c6d066a7368ad53491a55a5a57d2", "html_url": "https://github.com/rust-lang/rust/commit/b75915d0ca20c6d066a7368ad53491a55a5a57d2"}], "stats": {"total": 6722, "additions": 276, "deletions": 6446}, "files": [{"sha": "0aeeec3b487e80f2bc05ca0cc9f1c627dd388d70", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -66,30 +66,21 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/sync/timer.cpp \\\n               rt/sync/lock_and_signal.cpp \\\n               rt/sync/rust_thread.cpp \\\n-              rt/rust.cpp \\\n               rt/rust_builtin.cpp \\\n               rt/rust_run_program.cpp \\\n               rt/rust_env.cpp \\\n               rt/rust_rng.cpp \\\n-              rt/rust_sched_loop.cpp \\\n-              rt/rust_sched_launcher.cpp \\\n-              rt/rust_sched_driver.cpp \\\n-              rt/rust_scheduler.cpp \\\n-              rt/rust_sched_reaper.cpp \\\n-              rt/rust_task.cpp \\\n               rt/rust_stack.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n               rt/rust_crate_map.cpp \\\n-              rt/rust_log.cpp \\\n               rt/rust_gc_metadata.cpp \\\n               rt/rust_util.cpp \\\n+              rt/rust_log.cpp \\\n               rt/rust_exchange_alloc.cpp \\\n               rt/isaac/randport.cpp \\\n               rt/miniz.cpp \\\n-              rt/rust_kernel.cpp \\\n               rt/rust_abi.cpp \\\n-              rt/rust_debug.cpp \\\n               rt/memory_region.cpp \\\n               rt/boxed_region.cpp \\\n               rt/arch/$$(HOST_$(1))/context.cpp \\"}, {"sha": "5f00f1abae0eb26ca07ad866c6d233d8b1387aa4", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -596,14 +596,14 @@ mod tests {\n             let (c,p) = (Cell::new(c), Cell::new(p));\n             do task::spawn || {\n                 // wait until parent gets in\n-                comm::recv_one(p.take());\n+                p.take().recv();\n                 do arc2.access_cond |state, cond| {\n                     *state = true;\n                     cond.signal();\n                 }\n             }\n             do arc.access_cond |state, cond| {\n-                comm::send_one(c.take(), ());\n+                c.take().send(());\n                 assert!(!*state);\n                 while !*state {\n                     cond.wait();"}, {"sha": "391e4baa8c9da417c67561447cdec71dd8dbbbd6", "filename": "src/libextra/future.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -28,7 +28,7 @@\n \n use std::cast;\n use std::cell::Cell;\n-use std::comm::{PortOne, oneshot, send_one, recv_one};\n+use std::comm::{PortOne, oneshot};\n use std::task;\n use std::util::replace;\n \n@@ -123,7 +123,7 @@ pub fn from_port<A:Send>(port: PortOne<A>) -> Future<A> {\n \n     let port = Cell::new(port);\n     do from_fn {\n-        recv_one(port.take())\n+        port.take().recv()\n     }\n }\n \n@@ -152,7 +152,7 @@ pub fn spawn<A:Send>(blk: ~fn() -> A) -> Future<A> {\n     let chan = Cell::new(chan);\n     do task::spawn {\n         let chan = chan.take();\n-        send_one(chan, blk());\n+        chan.send(blk());\n     }\n \n     return from_port(port);\n@@ -163,7 +163,7 @@ mod test {\n     use future::*;\n \n     use std::cell::Cell;\n-    use std::comm::{oneshot, send_one};\n+    use std::comm::oneshot;\n     use std::task;\n \n     #[test]\n@@ -175,7 +175,7 @@ mod test {\n     #[test]\n     fn test_from_port() {\n         let (po, ch) = oneshot();\n-        send_one(ch, ~\"whale\");\n+        ch.send(~\"whale\");\n         let mut f = from_port(po);\n         assert_eq!(f.get(), ~\"whale\");\n     }"}, {"sha": "f2a9914cc91a76b2a41658ad053da7d90460a8de", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -19,6 +19,7 @@\n use std::borrow;\n use std::comm;\n use std::comm::SendDeferred;\n+use std::comm::{GenericPort, Peekable};\n use std::task;\n use std::unstable::sync::{Exclusive, UnsafeAtomicRcBox};\n use std::unstable::atomics;\n@@ -111,7 +112,7 @@ impl<Q:Send> Sem<Q> {\n             /* do 1000.times { task::yield(); } */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n-                let _ = comm::recv_one(waiter_nobe.unwrap());\n+                let _ = waiter_nobe.unwrap().recv();\n             }\n         }\n     }\n@@ -235,7 +236,7 @@ impl<'self> Condvar<'self> {\n                 do (|| {\n                     unsafe {\n                         do task::rekillable {\n-                            let _ = comm::recv_one(WaitEnd.take_unwrap());\n+                            let _ = WaitEnd.take_unwrap().recv();\n                         }\n                     }\n                 }).finally {"}, {"sha": "f1bf9e81c7251238224989d37622efa4afe6770f", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -14,7 +14,7 @@\n /// parallelism.\n \n \n-use std::comm::Chan;\n+use std::comm::{Chan, GenericChan, GenericPort};\n use std::comm;\n use std::task::SchedMode;\n use std::task;"}, {"sha": "bd811aa0f90d742d1f7f98bdb9b6e5a3d831c800", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -29,7 +29,7 @@ use time::precise_time_ns;\n use treemap::TreeMap;\n \n use std::clone::Clone;\n-use std::comm::{stream, SharedChan};\n+use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::libc;\n use std::either;\n use std::io;"}, {"sha": "61af5cd783929b241e481b8ee978c0248eb8b34a", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -18,7 +18,7 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n \n use std::cell::Cell;\n-use std::comm::{PortOne, oneshot, send_one, recv_one};\n+use std::comm::{PortOne, oneshot};\n use std::either::{Either, Left, Right};\n use std::io;\n use std::run;\n@@ -331,7 +331,7 @@ impl<'self> Prep<'self> {\n                     };\n                     let chan = chan.take();\n                     let v = blk(&exe);\n-                    send_one(chan, (exe, v));\n+                    chan.send((exe, v));\n                 }\n                 Right(port)\n             }\n@@ -355,7 +355,7 @@ impl<'self, T:Send +\n             None => fail!(),\n             Some(Left(v)) => v,\n             Some(Right(port)) => {\n-                let (exe, v) = recv_one(port);\n+                let (exe, v) = port.recv();\n                 let s = json_encode(&v);\n                 do prep.ctxt.db.write |db| {\n                     db.cache(prep.fn_name,"}, {"sha": "786548c06423445192f73721797031a487ebc8a6", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -275,24 +275,11 @@ pub mod raw {\n         }\n \n         fn local_realloc(ptr: *(), size: uint) -> *() {\n-            use rt;\n-            use rt::OldTaskContext;\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            if rt::context() == OldTaskContext {\n-                unsafe {\n-                    return rust_local_realloc(ptr, size as libc::size_t);\n-                }\n-\n-                extern {\n-                    #[fast_ffi]\n-                    fn rust_local_realloc(ptr: *(), size: libc::size_t) -> *();\n-                }\n-            } else {\n-                do Local::borrow::<Task, *()> |task| {\n-                    task.heap.realloc(ptr as *libc::c_void, size) as *()\n-                }\n+            do Local::borrow::<Task, *()> |task| {\n+                task.heap.realloc(ptr as *libc::c_void, size) as *()\n             }\n         }\n     }"}, {"sha": "7c2348a3533df83f9748ab5e07683f3e40faffd3", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -56,13 +56,8 @@ unsafe fn each_live_alloc(read_next_before: bool,\n \n #[cfg(unix)]\n fn debug_mem() -> bool {\n-    use rt;\n-    use rt::OldTaskContext;\n     // XXX: Need to port the environment struct to newsched\n-    match rt::context() {\n-        OldTaskContext => ::rt::env::get().debug_mem,\n-        _ => false\n-    }\n+    false\n }\n \n #[cfg(windows)]\n@@ -147,15 +142,3 @@ pub unsafe fn annihilate() {\n         dbg.write_str(\"\\n\");\n     }\n }\n-\n-/// Bindings to the runtime\n-pub mod rustrt {\n-    use libc::c_void;\n-\n-    #[link_name = \"rustrt\"]\n-    extern {\n-        #[rust_stack]\n-        // FIXME (#4386): Unable to make following method private.\n-        pub fn rust_get_task() -> *c_void;\n-    }\n-}"}, {"sha": "18c7674873f1685f4ff7cbe823ab3bda5f51e1c7", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 86, "deletions": 556, "changes": 642, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -14,13 +14,11 @@ Message passing\n \n #[allow(missing_doc)];\n \n-use either::{Either, Left, Right};\n+use clone::Clone;\n use kinds::Send;\n-use option::{Option, Some};\n-use unstable::sync::Exclusive;\n+use option::Option;\n pub use rt::comm::SendDeferred;\n use rtcomm = rt::comm;\n-use rt;\n \n /// A trait for things that can send multiple messages.\n pub trait GenericChan<T> {\n@@ -52,614 +50,146 @@ pub trait Peekable<T> {\n     fn peek(&self) -> bool;\n }\n \n-/// An endpoint that can send many messages.\n-pub struct Chan<T> {\n-    inner: Either<pipesy::Chan<T>, rtcomm::Chan<T>>\n-}\n-\n-/// An endpoint that can receive many messages.\n-pub struct Port<T> {\n-    inner: Either<pipesy::Port<T>, rtcomm::Port<T>>\n-}\n-\n-/** Creates a `(Port, Chan)` pair.\n-\n-These allow sending or receiving an unlimited number of messages.\n-\n-*/\n-pub fn stream<T:Send>() -> (Port<T>, Chan<T>) {\n-    let (port, chan) = match rt::context() {\n-        rt::OldTaskContext => match pipesy::stream() {\n-            (p, c) => (Left(p), Left(c))\n-        },\n-        _ => match rtcomm::stream() {\n-            (p, c) => (Right(p), Right(c))\n-        }\n-    };\n-    let port = Port { inner: port };\n-    let chan = Chan { inner: chan };\n-    return (port, chan);\n-}\n+pub struct PortOne<T> { x: rtcomm::PortOne<T> }\n+pub struct ChanOne<T> { x: rtcomm::ChanOne<T> }\n \n-impl<T: Send> GenericChan<T> for Chan<T> {\n-    fn send(&self, x: T) {\n-        match self.inner {\n-            Left(ref chan) => chan.send(x),\n-            Right(ref chan) => chan.send(x)\n-        }\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for Chan<T> {\n-    fn try_send(&self, x: T) -> bool {\n-        match self.inner {\n-            Left(ref chan) => chan.try_send(x),\n-            Right(ref chan) => chan.try_send(x)\n-        }\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for Chan<T> {\n-    fn send_deferred(&self, x: T) {\n-        match self.inner {\n-            Left(ref chan) => chan.send(x),\n-            Right(ref chan) => chan.send_deferred(x)\n-        }\n-    }\n-    fn try_send_deferred(&self, x: T) -> bool {\n-        match self.inner {\n-            Left(ref chan) => chan.try_send(x),\n-            Right(ref chan) => chan.try_send_deferred(x)\n-        }\n-    }\n+pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n+    let (p, c) = rtcomm::oneshot();\n+    (PortOne { x: p }, ChanOne { x: c })\n }\n \n-impl<T: Send> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        match self.inner {\n-            Left(ref port) => port.recv(),\n-            Right(ref port) => port.recv()\n-        }\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        match self.inner {\n-            Left(ref port) => port.try_recv(),\n-            Right(ref port) => port.try_recv()\n-        }\n-    }\n-}\n+pub struct Port<T> { x: rtcomm::Port<T> }\n+pub struct Chan<T> { x: rtcomm::Chan<T> }\n \n-impl<T: Send> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool {\n-        match self.inner {\n-            Left(ref port) => port.peek(),\n-            Right(ref port) => port.peek()\n-        }\n-    }\n+pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n+    let (p, c) = rtcomm::stream();\n+    (Port { x: p }, Chan { x: c })\n }\n \n-/// A channel that can be shared between many senders.\n-pub struct SharedChan<T> {\n-    inner: Either<Exclusive<pipesy::Chan<T>>, rtcomm::SharedChan<T>>\n-}\n+pub struct SharedChan<T> { x: rtcomm::SharedChan<T> }\n \n impl<T: Send> SharedChan<T> {\n-    /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n-        let Chan { inner } = c;\n-        let c = match inner {\n-            Left(c) => Left(Exclusive::new(c)),\n-            Right(c) => Right(rtcomm::SharedChan::new(c))\n-        };\n-        SharedChan { inner: c }\n+        let Chan { x: c } = c;\n+        SharedChan { x: rtcomm::SharedChan::new(c) }\n     }\n }\n \n-impl<T: Send> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, x: T) {\n-        match self.inner {\n-            Left(ref chan) => {\n-                unsafe {\n-                    let mut xx = Some(x);\n-                    do chan.with_imm |chan| {\n-                        chan.send(xx.take_unwrap())\n-                    }\n-                }\n-            }\n-            Right(ref chan) => chan.send(x)\n-        }\n+impl<T: Send> ChanOne<T> {\n+    pub fn send(self, val: T) {\n+        let ChanOne { x: c } = self;\n+        c.send(val)\n     }\n-}\n \n-impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, x: T) -> bool {\n-        match self.inner {\n-            Left(ref chan) => {\n-                unsafe {\n-                    let mut xx = Some(x);\n-                    do chan.with_imm |chan| {\n-                        chan.try_send(xx.take_unwrap())\n-                    }\n-                }\n-            }\n-            Right(ref chan) => chan.try_send(x)\n-        }\n+    pub fn try_send(self, val: T) -> bool {\n+        let ChanOne { x: c } = self;\n+        c.try_send(val)\n     }\n-}\n \n-impl<T: Send> ::clone::Clone for SharedChan<T> {\n-    fn clone(&self) -> SharedChan<T> {\n-        SharedChan { inner: self.inner.clone() }\n+    pub fn send_deferred(self, val: T) {\n+        let ChanOne { x: c } = self;\n+        c.send_deferred(val)\n     }\n-}\n \n-pub struct PortOne<T> {\n-    inner: Either<pipesy::PortOne<T>, rtcomm::PortOne<T>>\n-}\n-\n-pub struct ChanOne<T> {\n-    inner: Either<pipesy::ChanOne<T>, rtcomm::ChanOne<T>>\n-}\n-\n-pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n-    let (port, chan) = match rt::context() {\n-        rt::OldTaskContext => match pipesy::oneshot() {\n-            (p, c) => (Left(p), Left(c)),\n-        },\n-        _ => match rtcomm::oneshot() {\n-            (p, c) => (Right(p), Right(c))\n-        }\n-    };\n-    let port = PortOne { inner: port };\n-    let chan = ChanOne { inner: chan };\n-    return (port, chan);\n+    pub fn try_send_deferred(self, val: T) -> bool {\n+        let ChanOne{ x: c } = self;\n+        c.try_send_deferred(val)\n+    }\n }\n \n impl<T: Send> PortOne<T> {\n     pub fn recv(self) -> T {\n-        let PortOne { inner } = self;\n-        match inner {\n-            Left(p) => p.recv(),\n-            Right(p) => p.recv()\n-        }\n+        let PortOne { x: p } = self;\n+        p.recv()\n     }\n \n     pub fn try_recv(self) -> Option<T> {\n-        let PortOne { inner } = self;\n-        match inner {\n-            Left(p) => p.try_recv(),\n-            Right(p) => p.try_recv()\n-        }\n+        let PortOne { x: p } = self;\n+        p.try_recv()\n     }\n }\n \n-impl<T: Send> ChanOne<T> {\n-    pub fn send(self, data: T) {\n-        let ChanOne { inner } = self;\n-        match inner {\n-            Left(p) => p.send(data),\n-            Right(p) => p.send(data)\n-        }\n-    }\n-\n-    pub fn try_send(self, data: T) -> bool {\n-        let ChanOne { inner } = self;\n-        match inner {\n-            Left(p) => p.try_send(data),\n-            Right(p) => p.try_send(data)\n-        }\n-    }\n-    pub fn send_deferred(self, data: T) {\n-        let ChanOne { inner } = self;\n-        match inner {\n-            Left(p) => p.send(data),\n-            Right(p) => p.send_deferred(data)\n-        }\n-    }\n-    pub fn try_send_deferred(self, data: T) -> bool {\n-        let ChanOne { inner } = self;\n-        match inner {\n-            Left(p) => p.try_send(data),\n-            Right(p) => p.try_send_deferred(data)\n-        }\n+impl<T: Send> Peekable<T>  for PortOne<T> {\n+    fn peek(&self) -> bool {\n+        let &PortOne { x: ref p } = self;\n+        p.peek()\n     }\n }\n \n-pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n-    let PortOne { inner } = port;\n-    match inner {\n-        Left(p) => pipesy::recv_one(p),\n-        Right(p) => p.recv()\n+impl<T: Send> GenericChan<T> for Chan<T> {\n+    fn send(&self, val: T) {\n+        let &Chan { x: ref c } = self;\n+        c.send(val)\n     }\n }\n \n-pub fn try_recv_one<T: Send>(port: PortOne<T>) -> Option<T> {\n-    let PortOne { inner } = port;\n-    match inner {\n-        Left(p) => pipesy::try_recv_one(p),\n-        Right(p) => p.try_recv()\n+impl<T: Send> GenericSmartChan<T> for Chan<T> {\n+    fn try_send(&self, val: T) -> bool {\n+        let &Chan { x: ref c } = self;\n+        c.try_send(val)\n     }\n }\n \n-pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n-    let ChanOne { inner } = chan;\n-    match inner {\n-        Left(c) => pipesy::send_one(c, data),\n-        Right(c) => c.send(data)\n+impl<T: Send> SendDeferred<T> for Chan<T> {\n+    fn send_deferred(&self, val: T) {\n+        let &Chan { x: ref c } = self;\n+        c.send_deferred(val)\n     }\n-}\n \n-pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T) -> bool {\n-    let ChanOne { inner } = chan;\n-    match inner {\n-        Left(c) => pipesy::try_send_one(c, data),\n-        Right(c) => c.try_send(data)\n+    fn try_send_deferred(&self, val: T) -> bool {\n+        let &Chan { x: ref c } = self;\n+        c.try_send_deferred(val)\n     }\n }\n \n-mod pipesy {\n-\n-    use kinds::Send;\n-    use option::{Option, Some, None};\n-    use pipes::{recv, try_recv, peek};\n-    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n-    use cast::transmute_mut;\n-\n-    /*proto! oneshot (\n-        Oneshot:send<T:Send> {\n-            send(T) -> !\n-        }\n-    )*/\n-\n-    #[allow(non_camel_case_types)]\n-    pub mod oneshot {\n-        use std::kinds::Send;\n-        use ptr::to_mut_unsafe_ptr;\n-\n-        pub fn init<T: Send>() -> (server::Oneshot<T>, client::Oneshot<T>) {\n-            pub use std::pipes::HasBuffer;\n-\n-            let buffer = ~::std::pipes::Buffer {\n-                header: ::std::pipes::BufferHeader(),\n-                data: __Buffer {\n-                    Oneshot: ::std::pipes::mk_packet::<Oneshot<T>>()\n-                },\n-            };\n-            do ::std::pipes::entangle_buffer(buffer) |buffer, data| {\n-                data.Oneshot.set_buffer(buffer);\n-                to_mut_unsafe_ptr(&mut data.Oneshot)\n-            }\n-        }\n-        #[allow(non_camel_case_types)]\n-        pub enum Oneshot<T> { pub send(T), }\n-        #[allow(non_camel_case_types)]\n-        pub struct __Buffer<T> {\n-            Oneshot: ::std::pipes::Packet<Oneshot<T>>,\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub mod client {\n-\n-            use std::kinds::Send;\n-\n-            #[allow(non_camel_case_types)]\n-            pub fn try_send<T: Send>(pipe: Oneshot<T>, x_0: T) ->\n-                ::std::option::Option<()> {\n-                {\n-                    use super::send;\n-                    let message = send(x_0);\n-                    if ::std::pipes::send(pipe, message) {\n-                        ::std::pipes::rt::make_some(())\n-                    } else { ::std::pipes::rt::make_none() }\n-                }\n-            }\n-\n-            #[allow(non_camel_case_types)]\n-            pub fn send<T: Send>(pipe: Oneshot<T>, x_0: T) {\n-                {\n-                    use super::send;\n-                    let message = send(x_0);\n-                    ::std::pipes::send(pipe, message);\n-                }\n-            }\n-\n-            #[allow(non_camel_case_types)]\n-            pub type Oneshot<T> =\n-                ::std::pipes::SendPacketBuffered<super::Oneshot<T>,\n-            super::__Buffer<T>>;\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub mod server {\n-            #[allow(non_camel_case_types)]\n-            pub type Oneshot<T> =\n-                ::std::pipes::RecvPacketBuffered<super::Oneshot<T>,\n-            super::__Buffer<T>>;\n-        }\n-    }\n-\n-    /// The send end of a oneshot pipe.\n-    pub struct ChanOne<T> {\n-        contents: oneshot::client::Oneshot<T>\n-    }\n-\n-    impl<T> ChanOne<T> {\n-        pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n-            ChanOne {\n-                contents: contents\n-            }\n-        }\n-    }\n-\n-    /// The receive end of a oneshot pipe.\n-    pub struct PortOne<T> {\n-        contents: oneshot::server::Oneshot<T>\n-    }\n-\n-    impl<T> PortOne<T> {\n-        pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n-            PortOne {\n-                contents: contents\n-            }\n-        }\n-    }\n-\n-    /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-    pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n-        let (port, chan) = oneshot::init();\n-        (PortOne::new(port), ChanOne::new(chan))\n-    }\n-\n-    impl<T: Send> PortOne<T> {\n-        pub fn recv(self) -> T { recv_one(self) }\n-        pub fn try_recv(self) -> Option<T> { try_recv_one(self) }\n-        pub fn unwrap(self) -> oneshot::server::Oneshot<T> {\n-            match self {\n-                PortOne { contents: s } => s\n-            }\n-        }\n-    }\n-\n-    impl<T: Send> ChanOne<T> {\n-        pub fn send(self, data: T) { send_one(self, data) }\n-        pub fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n-        pub fn unwrap(self) -> oneshot::client::Oneshot<T> {\n-            match self {\n-                ChanOne { contents: s } => s\n-            }\n-        }\n-    }\n-\n-    /**\n-    * Receive a message from a oneshot pipe, failing if the connection was\n-    * closed.\n-    */\n-    pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n-        match port {\n-            PortOne { contents: port } => {\n-                let oneshot::send(message) = recv(port);\n-                message\n-            }\n-        }\n-    }\n-\n-    /// Receive a message from a oneshot pipe unless the connection was closed.\n-    pub fn try_recv_one<T: Send> (port: PortOne<T>) -> Option<T> {\n-        match port {\n-            PortOne { contents: port } => {\n-                let message = try_recv(port);\n-\n-                if message.is_none() {\n-                    None\n-                } else {\n-                    let oneshot::send(message) = message.unwrap();\n-                    Some(message)\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Send a message on a oneshot pipe, failing if the connection was closed.\n-    pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n-        match chan {\n-            ChanOne { contents: chan } => oneshot::client::send(chan, data),\n-        }\n-    }\n-\n-    /**\n-    * Send a message on a oneshot pipe, or return false if the connection was\n-    * closed.\n-    */\n-    pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T) -> bool {\n-        match chan {\n-            ChanOne { contents: chan } => {\n-                oneshot::client::try_send(chan, data).is_some()\n-            }\n-        }\n-    }\n-\n-    // Streams - Make pipes a little easier in general.\n-\n-    /*proto! streamp (\n-        Open:send<T: Send> {\n-            data(T) -> Open<T>\n-        }\n-    )*/\n-\n-    #[allow(non_camel_case_types)]\n-    pub mod streamp {\n-        use std::kinds::Send;\n-\n-        pub fn init<T: Send>() -> (server::Open<T>, client::Open<T>) {\n-            pub use std::pipes::HasBuffer;\n-            ::std::pipes::entangle()\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub enum Open<T> { pub data(T, server::Open<T>), }\n-\n-        #[allow(non_camel_case_types)]\n-        pub mod client {\n-            use std::kinds::Send;\n-\n-            #[allow(non_camel_case_types)]\n-            pub fn try_data<T: Send>(pipe: Open<T>, x_0: T) ->\n-                ::std::option::Option<Open<T>> {\n-                {\n-                    use super::data;\n-                    let (s, c) = ::std::pipes::entangle();\n-                    let message = data(x_0, s);\n-                    if ::std::pipes::send(pipe, message) {\n-                        ::std::pipes::rt::make_some(c)\n-                    } else { ::std::pipes::rt::make_none() }\n-                }\n-            }\n-\n-            #[allow(non_camel_case_types)]\n-            pub fn data<T: Send>(pipe: Open<T>, x_0: T) -> Open<T> {\n-                {\n-                    use super::data;\n-                    let (s, c) = ::std::pipes::entangle();\n-                    let message = data(x_0, s);\n-                    ::std::pipes::send(pipe, message);\n-                    c\n-                }\n-            }\n-\n-            #[allow(non_camel_case_types)]\n-            pub type Open<T> = ::std::pipes::SendPacket<super::Open<T>>;\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub mod server {\n-            #[allow(non_camel_case_types)]\n-            pub type Open<T> = ::std::pipes::RecvPacket<super::Open<T>>;\n-        }\n-    }\n-\n-    /// An endpoint that can send many messages.\n-    #[unsafe_mut_field(endp)]\n-    pub struct Chan<T> {\n-        endp: Option<streamp::client::Open<T>>\n+impl<T: Send> GenericPort<T> for Port<T> {\n+    fn recv(&self) -> T {\n+        let &Port { x: ref p } = self;\n+        p.recv()\n     }\n \n-    /// An endpoint that can receive many messages.\n-    #[unsafe_mut_field(endp)]\n-    pub struct Port<T> {\n-        endp: Option<streamp::server::Open<T>>,\n+    fn try_recv(&self) -> Option<T> {\n+        let &Port { x: ref p } = self;\n+        p.try_recv()\n     }\n+}\n \n-    /** Creates a `(Port, Chan)` pair.\n-\n-    These allow sending or receiving an unlimited number of messages.\n-\n-    */\n-    pub fn stream<T:Send>() -> (Port<T>, Chan<T>) {\n-        let (s, c) = streamp::init();\n-\n-        (Port {\n-            endp: Some(s)\n-        }, Chan {\n-            endp: Some(c)\n-        })\n+impl<T: Send> Peekable<T> for Port<T> {\n+    fn peek(&self) -> bool {\n+        let &Port { x: ref p } = self;\n+        p.peek()\n     }\n+}\n \n-    impl<T: Send> GenericChan<T> for Chan<T> {\n-        #[inline]\n-        fn send(&self, x: T) {\n-            unsafe {\n-                let self_endp = transmute_mut(&self.endp);\n-                *self_endp = Some(streamp::client::data(self_endp.take_unwrap(), x))\n-            }\n-        }\n+impl<T: Send> GenericChan<T> for SharedChan<T> {\n+    fn send(&self, val: T) {\n+        let &SharedChan { x: ref c } = self;\n+        c.send(val)\n     }\n+}\n \n-    impl<T: Send> GenericSmartChan<T> for Chan<T> {\n-        #[inline]\n-        fn try_send(&self, x: T) -> bool {\n-            unsafe {\n-                let self_endp = transmute_mut(&self.endp);\n-                match streamp::client::try_data(self_endp.take_unwrap(), x) {\n-                    Some(next) => {\n-                        *self_endp = Some(next);\n-                        true\n-                    }\n-                    None => false\n-                }\n-            }\n-        }\n+impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n+    fn try_send(&self, val: T) -> bool {\n+        let &SharedChan { x: ref c } = self;\n+        c.try_send(val)\n     }\n+}\n \n-    impl<T: Send> GenericPort<T> for Port<T> {\n-        #[inline]\n-        fn recv(&self) -> T {\n-            unsafe {\n-                let self_endp = transmute_mut(&self.endp);\n-                let endp = self_endp.take();\n-                let streamp::data(x, endp) = recv(endp.unwrap());\n-                *self_endp = Some(endp);\n-                x\n-            }\n-        }\n-\n-        #[inline]\n-        fn try_recv(&self) -> Option<T> {\n-            unsafe {\n-                let self_endp = transmute_mut(&self.endp);\n-                let endp = self_endp.take();\n-                match try_recv(endp.unwrap()) {\n-                    Some(streamp::data(x, endp)) => {\n-                        *self_endp = Some(endp);\n-                        Some(x)\n-                    }\n-                    None => None\n-                }\n-            }\n-        }\n+impl<T: Send> SendDeferred<T> for SharedChan<T> {\n+    fn send_deferred(&self, val: T) {\n+        let &SharedChan { x: ref c } = self;\n+        c.send_deferred(val)\n     }\n \n-    impl<T: Send> Peekable<T> for Port<T> {\n-        #[inline]\n-        fn peek(&self) -> bool {\n-            unsafe {\n-                let self_endp = transmute_mut(&self.endp);\n-                let mut endp = self_endp.take();\n-                let peek = match endp {\n-                    Some(ref mut endp) => peek(endp),\n-                    None => fail!(\"peeking empty stream\")\n-                };\n-                *self_endp = endp;\n-                peek\n-            }\n-        }\n+    fn try_send_deferred(&self, val: T) -> bool {\n+        let &SharedChan { x: ref c } = self;\n+        c.try_send_deferred(val)\n     }\n-\n }\n \n-#[cfg(test)]\n-mod test {\n-    use either::Right;\n-    use super::{Chan, Port, oneshot, stream};\n-\n-    #[test]\n-    fn test_oneshot() {\n-        let (p, c) = oneshot();\n-\n-        c.send(());\n-\n-        p.recv()\n-    }\n-\n-    #[test]\n-    fn test_peek_terminated() {\n-        let (port, chan): (Port<int>, Chan<int>) = stream();\n-\n-        {\n-            // Destroy the channel\n-            let _chan = chan;\n-        }\n-\n-        assert!(!port.peek());\n+impl<T> Clone for SharedChan<T> {\n+    fn clone(&self) -> SharedChan<T> {\n+        let &SharedChan { x: ref c } = self;\n+        SharedChan { x: c.clone() }\n     }\n }"}, {"sha": "7de55f48317a556d8c66067fc0b010e5552779ca", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -14,18 +14,11 @@ use option::*;\n use os;\n use either::*;\n use rt;\n-use rt::OldTaskContext;\n use rt::logging::{Logger, StdErrLogger};\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n-    if rt::context() == OldTaskContext {\n-        unsafe {\n-            rustrt::rust_log_console_on();\n-        }\n-    } else {\n-        rt::logging::console_on();\n-    }\n+    rt::logging::console_on();\n }\n \n /**\n@@ -41,45 +34,24 @@ pub fn console_off() {\n         return;\n     }\n \n-    if rt::context() == OldTaskContext {\n-        unsafe {\n-            rustrt::rust_log_console_off();\n-        }\n-    } else {\n-        rt::logging::console_off();\n-    }\n+    rt::logging::console_off();\n }\n \n #[cfg(not(test))]\n #[lang=\"log_type\"]\n #[allow(missing_doc)]\n-pub fn log_type<T>(level: u32, object: &T) {\n-    use cast;\n-    use container::Container;\n+pub fn log_type<T>(_level: u32, object: &T) {\n     use io;\n-    use libc;\n     use repr;\n-    use rt;\n     use str;\n-    use vec;\n \n     let bytes = do io::with_bytes_writer |writer| {\n         repr::write_repr(writer, object);\n     };\n \n-    match rt::context() {\n-        rt::OldTaskContext => {\n-            unsafe {\n-                let len = bytes.len() as libc::size_t;\n-                rustrt::rust_log_str(level, cast::transmute(vec::raw::to_ptr(bytes)), len);\n-            }\n-        }\n-        _ => {\n-            // XXX: Bad allocation\n-            let msg = str::from_bytes(bytes);\n-            newsched_log_str(msg);\n-        }\n-    }\n+    // XXX: Bad allocation\n+    let msg = str::from_bytes(bytes);\n+    newsched_log_str(msg);\n }\n \n fn newsched_log_str(msg: ~str) {\n@@ -100,15 +72,3 @@ fn newsched_log_str(msg: ~str) {\n         }\n     }\n }\n-\n-pub mod rustrt {\n-    use libc;\n-\n-    extern {\n-        pub fn rust_log_console_on();\n-        pub fn rust_log_console_off();\n-        pub fn rust_log_str(level: u32,\n-                            string: *libc::c_char,\n-                            size: libc::size_t);\n-    }\n-}"}, {"sha": "dc0313f6bf6a00b4b6d77e48f0991d7c20e0b031", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -61,11 +61,8 @@ pub mod rustrt {\n     use libc;\n \n     extern {\n-        pub fn rust_get_argc() -> c_int;\n-        pub fn rust_get_argv() -> **c_char;\n         pub fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n         pub fn rust_path_exists(path: *libc::c_char) -> c_int;\n-        pub fn rust_set_exit_status(code: libc::intptr_t);\n     }\n }\n \n@@ -1104,15 +1101,7 @@ pub fn last_os_error() -> ~str {\n  */\n pub fn set_exit_status(code: int) {\n     use rt;\n-    use rt::OldTaskContext;\n-\n-    if rt::context() == OldTaskContext {\n-        unsafe {\n-            rustrt::rust_set_exit_status(code as libc::intptr_t);\n-        }\n-    } else {\n-        rt::util::set_exit_status(code);\n-    }\n+    rt::util::set_exit_status(code);\n }\n \n unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n@@ -1142,19 +1131,10 @@ pub fn real_args() -> ~[~str] {\n #[cfg(target_os = \"freebsd\")]\n pub fn real_args() -> ~[~str] {\n     use rt;\n-    use rt::NewRtContext;\n \n-    if rt::context() == NewRtContext {\n-        match rt::args::clone() {\n-            Some(args) => args,\n-            None => fail!(\"process arguments not initialized\")\n-        }\n-    } else {\n-        unsafe {\n-            let argc = rustrt::rust_get_argc();\n-            let argv = rustrt::rust_get_argv();\n-            load_argc_and_argv(argc, argv)\n-        }\n+    match rt::args::clone() {\n+        Some(args) => args,\n+        None => fail!(\"process arguments not initialized\")\n     }\n }\n "}, {"sha": "78f937e058a41bb43bbd19d075f072c91ac2fb73", "filename": "src/libstd/pipes.rs", "status": "removed", "additions": 0, "deletions": 870, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,870 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Runtime support for message passing with protocol enforcement.\n-\n-\n-Pipes consist of two endpoints. One endpoint can send messages and\n-the other can receive messages. The set of legal messages and which\n-directions they can flow at any given point are determined by a\n-protocol. Below is an example protocol.\n-\n-~~~ {.rust}\n-proto! pingpong (\n-    ping: send {\n-        ping -> pong\n-    }\n-    pong: recv {\n-        pong -> ping\n-    }\n-)\n-~~~\n-\n-The `proto!` syntax extension will convert this into a module called\n-`pingpong`, which includes a set of types and functions that can be\n-used to write programs that follow the pingpong protocol.\n-\n-*/\n-\n-/* IMPLEMENTATION NOTES\n-\n-The initial design for this feature is available at:\n-\n-https://github.com/eholk/rust/wiki/Proposal-for-channel-contracts\n-\n-Much of the design in that document is still accurate. There are\n-several components for the pipe implementation. First of all is the\n-syntax extension. To see how that works, it is best see comments in\n-libsyntax/ext/pipes.rs.\n-\n-This module includes two related pieces of the runtime\n-implementation: support for unbounded and bounded\n-protocols. The main difference between the two is the type of the\n-buffer that is carried along in the endpoint data structures.\n-\n-\n-The heart of the implementation is the packet type. It contains a\n-header and a payload field. Much of the code in this module deals with\n-the header field. This is where the synchronization information is\n-stored. In the case of a bounded protocol, the header also includes a\n-pointer to the buffer the packet is contained in.\n-\n-Packets represent a single message in a protocol. The payload field\n-gets instatiated at the type of the message, which is usually an enum\n-generated by the pipe compiler. Packets are conceptually single use,\n-although in bounded protocols they are reused each time around the\n-loop.\n-\n-\n-Packets are usually handled through a send_packet_buffered or\n-recv_packet_buffered object. Each packet is referenced by one\n-send_packet and one recv_packet, and these wrappers enforce that only\n-one end can send and only one end can receive. The structs also\n-include a destructor that marks packets are terminated if the sender\n-or receiver destroys the object before sending or receiving a value.\n-\n-The *_packet_buffered structs take two type parameters. The first is\n-the message type for the current packet (or state). The second\n-represents the type of the whole buffer. For bounded protocols, the\n-protocol compiler generates a struct with a field for each protocol\n-state. This generated struct is used as the buffer type parameter. For\n-unbounded protocols, the buffer is simply one packet, so there is a\n-shorthand struct called send_packet and recv_packet, where the buffer\n-type is just `packet<T>`. Using the same underlying structure for both\n-bounded and unbounded protocols allows for less code duplication.\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use container::Container;\n-use cast::{forget, transmute, transmute_copy, transmute_mut};\n-use either::{Either, Left, Right};\n-use iterator::{Iterator, IteratorUtil};\n-use kinds::Send;\n-use libc;\n-use ops::Drop;\n-use option::{None, Option, Some};\n-use unstable::finally::Finally;\n-use unstable::intrinsics;\n-use ptr;\n-use ptr::RawPtr;\n-use task;\n-use vec::{OwnedVector, MutableVector};\n-use util::replace;\n-\n-static SPIN_COUNT: uint = 0;\n-\n-#[deriving(Eq)]\n-enum State {\n-    Empty,\n-    Full,\n-    Blocked,\n-    Terminated\n-}\n-\n-pub struct BufferHeader {\n-    // Tracks whether this buffer needs to be freed. We can probably\n-    // get away with restricting it to 0 or 1, if we're careful.\n-    ref_count: int,\n-\n-    // We may want a drop, and to be careful about stringing this\n-    // thing along.\n-}\n-\n-pub fn BufferHeader() -> BufferHeader {\n-    BufferHeader {\n-        ref_count: 0\n-    }\n-}\n-\n-// This is for protocols to associate extra data to thread around.\n-pub struct Buffer<T> {\n-    header: BufferHeader,\n-    data: T,\n-}\n-\n-pub struct PacketHeader {\n-    state: State,\n-    blocked_task: *rust_task,\n-\n-    // This is a transmute_copy of a ~buffer, that can also be cast\n-    // to a buffer_header if need be.\n-    buffer: *libc::c_void,\n-}\n-\n-pub fn PacketHeader() -> PacketHeader {\n-    PacketHeader {\n-        state: Empty,\n-        blocked_task: ptr::null(),\n-        buffer: ptr::null()\n-    }\n-}\n-\n-impl PacketHeader {\n-    // Returns the old state.\n-    pub unsafe fn mark_blocked(&mut self, this: *rust_task) -> State {\n-        rustrt::rust_task_ref(this);\n-        let old_task = swap_task(&mut self.blocked_task, this);\n-        assert!(old_task.is_null());\n-        swap_state_acq(&mut self.state, Blocked)\n-    }\n-\n-    pub unsafe fn unblock(&mut self) {\n-        let old_task = swap_task(&mut self.blocked_task, ptr::null());\n-        if !old_task.is_null() {\n-            rustrt::rust_task_deref(old_task)\n-        }\n-        match swap_state_acq(&mut self.state, Empty) {\n-          Empty | Blocked => (),\n-          Terminated => self.state = Terminated,\n-          Full => self.state = Full\n-        }\n-    }\n-\n-    // unsafe because this can do weird things to the space/time\n-    // continuum. It ends making multiple unique pointers to the same\n-    // thing. You'll probably want to forget them when you're done.\n-    pub unsafe fn buf_header(&mut self) -> ~BufferHeader {\n-        assert!(self.buffer.is_not_null());\n-        transmute_copy(&self.buffer)\n-    }\n-\n-    pub fn set_buffer<T:Send>(&mut self, b: ~Buffer<T>) {\n-        unsafe {\n-            self.buffer = transmute_copy(&b);\n-        }\n-    }\n-}\n-\n-pub struct Packet<T> {\n-    header: PacketHeader,\n-    payload: Option<T>,\n-}\n-\n-pub trait HasBuffer {\n-    fn set_buffer(&mut self, b: *libc::c_void);\n-}\n-\n-impl<T:Send> HasBuffer for Packet<T> {\n-    fn set_buffer(&mut self, b: *libc::c_void) {\n-        self.header.buffer = b;\n-    }\n-}\n-\n-pub fn mk_packet<T:Send>() -> Packet<T> {\n-    Packet {\n-        header: PacketHeader(),\n-        payload: None,\n-    }\n-}\n-fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n-    let mut b = ~Buffer {\n-        header: BufferHeader(),\n-        data: Packet {\n-            header: PacketHeader(),\n-            payload: None,\n-        }\n-    };\n-\n-    unsafe {\n-        b.data.header.buffer = transmute_copy(&b);\n-    }\n-    b\n-}\n-\n-pub fn packet<T>() -> *mut Packet<T> {\n-    let mut b = unibuffer();\n-    let p = ptr::to_mut_unsafe_ptr(&mut b.data);\n-    // We'll take over memory management from here.\n-    unsafe {\n-        forget(b);\n-    }\n-    p\n-}\n-\n-pub fn entangle_buffer<T:Send,Tstart:Send>(\n-    mut buffer: ~Buffer<T>,\n-    init: &fn(*libc::c_void, x: &mut T) -> *mut Packet<Tstart>)\n-    -> (RecvPacketBuffered<Tstart, T>, SendPacketBuffered<Tstart, T>) {\n-    unsafe {\n-        let p = init(transmute_copy(&buffer), &mut buffer.data);\n-        forget(buffer);\n-        (RecvPacketBuffered(p), SendPacketBuffered(p))\n-    }\n-}\n-\n-pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n-    // It might be worth making both acquire and release versions of\n-    // this.\n-    unsafe {\n-        transmute(intrinsics::atomic_xchg(transmute(dst), src as int))\n-    }\n-}\n-\n-#[allow(non_camel_case_types)]\n-pub type rust_task = libc::c_void;\n-\n-pub mod rustrt {\n-    use libc;\n-    use super::rust_task;\n-\n-    extern {\n-        #[rust_stack]\n-        pub fn rust_get_task() -> *rust_task;\n-        #[rust_stack]\n-        pub fn rust_task_ref(task: *rust_task);\n-        pub fn rust_task_deref(task: *rust_task);\n-\n-        #[rust_stack]\n-        pub fn task_clear_event_reject(task: *rust_task);\n-\n-        pub fn task_wait_event(this: *rust_task, killed: &mut *libc::c_void)\n-                               -> bool;\n-        pub fn task_signal_event(target: *rust_task, event: *libc::c_void);\n-    }\n-}\n-\n-fn wait_event(this: *rust_task) -> *libc::c_void {\n-    unsafe {\n-        let mut event = ptr::null();\n-\n-        let killed = rustrt::task_wait_event(this, &mut event);\n-        if killed && !task::failing() {\n-            fail!(\"killed\")\n-        }\n-        event\n-    }\n-}\n-\n-fn swap_state_acq(dst: &mut State, src: State) -> State {\n-    unsafe {\n-        transmute(intrinsics::atomic_xchg_acq(transmute(dst), src as int))\n-    }\n-}\n-\n-fn swap_state_rel(dst: &mut State, src: State) -> State {\n-    unsafe {\n-        transmute(intrinsics::atomic_xchg_rel(transmute(dst), src as int))\n-    }\n-}\n-\n-pub unsafe fn get_buffer<T>(p: *mut PacketHeader) -> ~Buffer<T> {\n-    transmute((*p).buf_header())\n-}\n-\n-// This could probably be done with SharedMutableState to avoid move_it!().\n-struct BufferResource<T> {\n-    buffer: ~Buffer<T>,\n-\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for BufferResource<T> {\n-    fn drop(&self) {\n-        unsafe {\n-            // FIXME(#4330) Need self by value to get mutability.\n-            let this: &mut BufferResource<T> = transmute_mut(self);\n-\n-            let null_buffer: ~Buffer<T> = transmute(ptr::null::<Buffer<T>>());\n-            let mut b = replace(&mut this.buffer, null_buffer);\n-\n-            //let p = ptr::to_unsafe_ptr(*b);\n-            //error!(\"drop %?\", p);\n-            let old_count = intrinsics::atomic_xsub_rel(\n-                &mut b.header.ref_count,\n-                1);\n-            //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n-            if old_count == 1 {\n-                // The new count is 0.\n-\n-                // go go gadget drop glue\n-            }\n-            else {\n-                forget(b)\n-            }\n-        }\n-    }\n-}\n-\n-fn BufferResource<T>(mut b: ~Buffer<T>) -> BufferResource<T> {\n-    //let p = ptr::to_unsafe_ptr(*b);\n-    //error!(\"take %?\", p);\n-    unsafe {\n-        intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1);\n-    }\n-\n-    BufferResource {\n-        // tjc: ????\n-        buffer: b\n-    }\n-}\n-\n-pub fn send<T,Tbuffer>(mut p: SendPacketBuffered<T,Tbuffer>,\n-                       payload: T)\n-                       -> bool {\n-    let header = p.header();\n-    let p_ = p.unwrap();\n-    let p = unsafe { &mut *p_ };\n-    assert_eq!(ptr::to_unsafe_ptr(&(p.header)), header);\n-    assert!(p.payload.is_none());\n-    p.payload = Some(payload);\n-    let old_state = swap_state_rel(&mut p.header.state, Full);\n-    match old_state {\n-        Empty => {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            //unsafe { forget(p); }\n-            return true;\n-        }\n-        Full => fail!(\"duplicate send\"),\n-        Blocked => {\n-            debug!(\"waking up task for %?\", p_);\n-            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-            if !old_task.is_null() {\n-                unsafe {\n-                    rustrt::task_signal_event(\n-                        old_task,\n-                        ptr::to_unsafe_ptr(&(p.header)) as *libc::c_void);\n-                    rustrt::rust_task_deref(old_task);\n-                }\n-            }\n-\n-            // The receiver will eventually clean this up.\n-            //unsafe { forget(p); }\n-            return true;\n-        }\n-        Terminated => {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-            return false;\n-        }\n-    }\n-}\n-\n-/** Receives a message from a pipe.\n-\n-Fails if the sender closes the connection.\n-\n-*/\n-pub fn recv<T:Send,Tbuffer:Send>(\n-    p: RecvPacketBuffered<T, Tbuffer>) -> T {\n-    try_recv(p).expect(\"connection closed\")\n-}\n-\n-/** Attempts to receive a message from a pipe.\n-\n-Returns `None` if the sender has closed the connection without sending\n-a message, or `Some(T)` if a message was received.\n-\n-*/\n-pub fn try_recv<T:Send,Tbuffer:Send>(mut p: RecvPacketBuffered<T, Tbuffer>)\n-                                       -> Option<T> {\n-    let p_ = p.unwrap();\n-    let p = unsafe { &mut *p_ };\n-\n-    do (|| {\n-        try_recv_(p)\n-    }).finally {\n-        unsafe {\n-            if task::failing() {\n-                p.header.state = Terminated;\n-                let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-                if !old_task.is_null() {\n-                    rustrt::rust_task_deref(old_task);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn try_recv_<T:Send>(p: &mut Packet<T>) -> Option<T> {\n-    // optimistic path\n-    match p.header.state {\n-      Full => {\n-        let payload = p.payload.take();\n-        p.header.state = Empty;\n-        return Some(payload.unwrap())\n-      },\n-      Terminated => return None,\n-      _ => {}\n-    }\n-\n-    // regular path\n-    let this = unsafe { rustrt::rust_get_task() };\n-    unsafe {\n-        rustrt::task_clear_event_reject(this);\n-        rustrt::rust_task_ref(this);\n-    };\n-    debug!(\"blocked = %x this = %x\", p.header.blocked_task as uint,\n-           this as uint);\n-    let old_task = swap_task(&mut p.header.blocked_task, this);\n-    debug!(\"blocked = %x this = %x old_task = %x\",\n-           p.header.blocked_task as uint,\n-           this as uint, old_task as uint);\n-    assert!(old_task.is_null());\n-    let mut first = true;\n-    let mut count = SPIN_COUNT;\n-    loop {\n-        unsafe {\n-            rustrt::task_clear_event_reject(this);\n-        }\n-\n-        let old_state = swap_state_acq(&mut p.header.state,\n-                                       Blocked);\n-        match old_state {\n-          Empty => {\n-            debug!(\"no data available on %?, going to sleep.\", p);\n-            if count == 0 {\n-                wait_event(this);\n-            }\n-            else {\n-                count -= 1;\n-                // FIXME (#524): Putting the yield here destroys a lot\n-                // of the benefit of spinning, since we still go into\n-                // the scheduler at every iteration. However, without\n-                // this everything spins too much because we end up\n-                // sometimes blocking the thing we are waiting on.\n-                task::yield();\n-            }\n-            debug!(\"woke up, p.state = %?\", p.header.state);\n-          }\n-          Blocked => if first {\n-            fail!(\"blocking on already blocked packet\")\n-          },\n-          Full => {\n-            let payload = p.payload.take();\n-            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-            if !old_task.is_null() {\n-                unsafe {\n-                    rustrt::rust_task_deref(old_task);\n-                }\n-            }\n-            p.header.state = Empty;\n-            return Some(payload.unwrap())\n-          }\n-          Terminated => {\n-            // This assert detects when we've accidentally unsafely\n-            // casted too big of a number to a state.\n-            assert_eq!(old_state, Terminated);\n-\n-            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-            if !old_task.is_null() {\n-                unsafe {\n-                    rustrt::rust_task_deref(old_task);\n-                }\n-            }\n-            return None;\n-          }\n-        }\n-        first = false;\n-    }\n-}\n-\n-/// Returns true if messages are available.\n-pub fn peek<T:Send,Tb:Send>(p: &mut RecvPacketBuffered<T, Tb>) -> bool {\n-    unsafe {\n-        match (*p.header()).state {\n-            Empty | Terminated => false,\n-            Blocked => fail!(\"peeking on blocked packet\"),\n-            Full => true\n-        }\n-    }\n-}\n-\n-fn sender_terminate<T:Send>(p: *mut Packet<T>) {\n-    let p = unsafe {\n-        &mut *p\n-    };\n-    match swap_state_rel(&mut p.header.state, Terminated) {\n-      Empty => {\n-        // The receiver will eventually clean up.\n-      }\n-      Blocked => {\n-        // wake up the target\n-        let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-        if !old_task.is_null() {\n-            unsafe {\n-                rustrt::task_signal_event(\n-                    old_task,\n-                    ptr::to_unsafe_ptr(&(p.header)) as *libc::c_void);\n-                rustrt::rust_task_deref(old_task);\n-            }\n-        }\n-        // The receiver will eventually clean up.\n-      }\n-      Full => {\n-        // This is impossible\n-        fail!(\"you dun goofed\")\n-      }\n-      Terminated => {\n-        assert!(p.header.blocked_task.is_null());\n-        // I have to clean up, use drop_glue\n-      }\n-    }\n-}\n-\n-fn receiver_terminate<T:Send>(p: *mut Packet<T>) {\n-    let p = unsafe {\n-        &mut *p\n-    };\n-    match swap_state_rel(&mut p.header.state, Terminated) {\n-      Empty => {\n-        assert!(p.header.blocked_task.is_null());\n-        // the sender will clean up\n-      }\n-      Blocked => {\n-        let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-        if !old_task.is_null() {\n-            unsafe {\n-                rustrt::rust_task_deref(old_task);\n-                assert_eq!(old_task, rustrt::rust_get_task());\n-            }\n-        }\n-      }\n-      Terminated | Full => {\n-        assert!(p.header.blocked_task.is_null());\n-        // I have to clean up, use drop_glue\n-      }\n-    }\n-}\n-\n-/** Returns when one of the packet headers reports data is available.\n-\n-This function is primarily intended for building higher level waiting\n-functions, such as `select`, `select2`, etc.\n-\n-It takes a vector slice of packet_headers and returns an index into\n-that vector. The index points to an endpoint that has either been\n-closed by the sender or has a message waiting to be received.\n-\n-*/\n-pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n-    let this = unsafe {\n-        rustrt::rust_get_task()\n-    };\n-\n-    unsafe {\n-        rustrt::task_clear_event_reject(this);\n-    }\n-\n-    let mut data_avail = false;\n-    let mut ready_packet = pkts.len();\n-    for (i, p) in pkts.mut_iter().enumerate() {\n-        unsafe {\n-            let p = &mut *p.header();\n-            let old = p.mark_blocked(this);\n-            match old {\n-                Full | Terminated => {\n-                    data_avail = true;\n-                    ready_packet = i;\n-                    (*p).state = old;\n-                    break;\n-                }\n-                Blocked => fail!(\"blocking on blocked packet\"),\n-                Empty => ()\n-            }\n-        }\n-    }\n-\n-    while !data_avail {\n-        debug!(\"sleeping on %? packets\", pkts.len());\n-        let event = wait_event(this) as *PacketHeader;\n-\n-        let mut pos = None;\n-        for (i, p) in pkts.mut_iter().enumerate() {\n-            if p.header() == event {\n-                pos = Some(i);\n-                break;\n-            }\n-        };\n-\n-        match pos {\n-          Some(i) => {\n-            ready_packet = i;\n-            data_avail = true;\n-          }\n-          None => debug!(\"ignoring spurious event, %?\", event)\n-        }\n-    }\n-\n-    debug!(\"%?\", &mut pkts[ready_packet]);\n-\n-    for p in pkts.mut_iter() {\n-        unsafe {\n-            (*p.header()).unblock()\n-        }\n-    }\n-\n-    debug!(\"%?, %?\", ready_packet, &mut pkts[ready_packet]);\n-\n-    unsafe {\n-        assert!((*pkts[ready_packet].header()).state == Full\n-                     || (*pkts[ready_packet].header()).state == Terminated);\n-    }\n-\n-    ready_packet\n-}\n-\n-/** The sending end of a pipe. It can be used to send exactly one\n-message.\n-\n-*/\n-pub type SendPacket<T> = SendPacketBuffered<T, Packet<T>>;\n-\n-pub fn SendPacket<T>(p: *mut Packet<T>) -> SendPacket<T> {\n-    SendPacketBuffered(p)\n-}\n-\n-pub struct SendPacketBuffered<T, Tbuffer> {\n-    p: Option<*mut Packet<T>>,\n-    buffer: Option<BufferResource<Tbuffer>>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T:Send,Tbuffer:Send> Drop for SendPacketBuffered<T,Tbuffer> {\n-    fn drop(&self) {\n-        unsafe {\n-            let this: &mut SendPacketBuffered<T,Tbuffer> = transmute(self);\n-            if this.p != None {\n-                sender_terminate(this.p.take_unwrap());\n-            }\n-        }\n-    }\n-}\n-\n-pub fn SendPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n-                                     -> SendPacketBuffered<T,Tbuffer> {\n-    SendPacketBuffered {\n-        p: Some(p),\n-        buffer: unsafe {\n-            Some(BufferResource(get_buffer(&mut (*p).header)))\n-        }\n-    }\n-}\n-\n-impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n-    pub fn unwrap(&mut self) -> *mut Packet<T> {\n-        self.p.take_unwrap()\n-    }\n-\n-    pub fn header(&mut self) -> *mut PacketHeader {\n-        match self.p {\n-            Some(packet) => unsafe {\n-                let packet = &mut *packet;\n-                let header = ptr::to_mut_unsafe_ptr(&mut packet.header);\n-                header\n-            },\n-            None => fail!(\"packet already consumed\")\n-        }\n-    }\n-\n-    pub fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n-        //error!(\"send reuse_buffer\");\n-        self.buffer.take_unwrap()\n-    }\n-}\n-\n-/// Represents the receive end of a pipe. It can receive exactly one\n-/// message.\n-pub type RecvPacket<T> = RecvPacketBuffered<T, Packet<T>>;\n-\n-pub fn RecvPacket<T>(p: *mut Packet<T>) -> RecvPacket<T> {\n-    RecvPacketBuffered(p)\n-}\n-\n-pub struct RecvPacketBuffered<T, Tbuffer> {\n-    p: Option<*mut Packet<T>>,\n-    buffer: Option<BufferResource<Tbuffer>>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T:Send,Tbuffer:Send> Drop for RecvPacketBuffered<T,Tbuffer> {\n-    fn drop(&self) {\n-        unsafe {\n-            let this: &mut RecvPacketBuffered<T,Tbuffer> = transmute(self);\n-            if this.p != None {\n-                receiver_terminate(this.p.take_unwrap())\n-            }\n-        }\n-    }\n-}\n-\n-impl<T:Send,Tbuffer:Send> RecvPacketBuffered<T, Tbuffer> {\n-    pub fn unwrap(&mut self) -> *mut Packet<T> {\n-        self.p.take_unwrap()\n-    }\n-\n-    pub fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n-        self.buffer.take_unwrap()\n-    }\n-}\n-\n-impl<T:Send,Tbuffer:Send> Selectable for RecvPacketBuffered<T, Tbuffer> {\n-    fn header(&mut self) -> *mut PacketHeader {\n-        match self.p {\n-            Some(packet) => unsafe {\n-                let packet = &mut *packet;\n-                let header = ptr::to_mut_unsafe_ptr(&mut packet.header);\n-                header\n-            },\n-            None => fail!(\"packet already consumed\")\n-        }\n-    }\n-}\n-\n-pub fn RecvPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n-                                     -> RecvPacketBuffered<T,Tbuffer> {\n-    RecvPacketBuffered {\n-        p: Some(p),\n-        buffer: unsafe {\n-            Some(BufferResource(get_buffer(&mut (*p).header)))\n-        }\n-    }\n-}\n-\n-pub fn entangle<T>() -> (RecvPacket<T>, SendPacket<T>) {\n-    let p = packet();\n-    (RecvPacket(p), SendPacket(p))\n-}\n-\n-/** Receives a message from one of two endpoints.\n-\n-The return value is `left` if the first endpoint received something,\n-or `right` if the second endpoint receives something. In each case,\n-the result includes the other endpoint as well so it can be used\n-again. Below is an example of using `select2`.\n-\n-~~~ {.rust}\n-match select2(a, b) {\n-    left((none, b)) {\n-        // endpoint a was closed.\n-    }\n-    right((a, none)) {\n-        // endpoint b was closed.\n-    }\n-    left((Some(_), b)) {\n-        // endpoint a received a message\n-    }\n-    right(a, Some(_)) {\n-        // endpoint b received a message.\n-    }\n-}\n-~~~\n-\n-Sometimes messages will be available on both endpoints at once. In\n-this case, `select2` may return either `left` or `right`.\n-\n-*/\n-pub fn select2<A:Send,Ab:Send,B:Send,Bb:Send>(\n-    mut a: RecvPacketBuffered<A, Ab>,\n-    mut b: RecvPacketBuffered<B, Bb>)\n-    -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n-              (RecvPacketBuffered<A, Ab>, Option<B>)> {\n-    let mut endpoints = [ a.header(), b.header() ];\n-    let i = wait_many(endpoints);\n-    match i {\n-        0 => Left((try_recv(a), b)),\n-        1 => Right((a, try_recv(b))),\n-        _ => fail!(\"select2 return an invalid packet\")\n-    }\n-}\n-\n-pub trait Selectable {\n-    fn header(&mut self) -> *mut PacketHeader;\n-}\n-\n-impl Selectable for *mut PacketHeader {\n-    fn header(&mut self) -> *mut PacketHeader { *self }\n-}\n-\n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T:Selectable>(endpoints: &mut [T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable,B:Selectable>(a: &mut A, b: &mut B)\n-                                           -> Either<(), ()> {\n-    let mut endpoints = [ a.header(), b.header() ];\n-    match wait_many(endpoints) {\n-        0 => Left(()),\n-        1 => Right(()),\n-        _ => fail!(\"wait returned unexpected index\")\n-    }\n-}\n-\n-/// Waits on a set of endpoints. Returns a message, its index, and a\n-/// list of the remaining endpoints.\n-pub fn select<T:Send,Tb:Send>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n-                                -> (uint,\n-                                    Option<T>,\n-                                    ~[RecvPacketBuffered<T, Tb>]) {\n-    let mut endpoint_headers = ~[];\n-    for endpoint in endpoints.mut_iter() {\n-        endpoint_headers.push(endpoint.header());\n-    }\n-\n-    let ready = wait_many(endpoint_headers);\n-    let mut remaining = endpoints;\n-    let port = remaining.swap_remove(ready);\n-    let result = try_recv(port);\n-    (ready, result, remaining)\n-}\n-\n-pub mod rt {\n-    use option::{None, Option, Some};\n-\n-    // These are used to hide the option constructors from the\n-    // compiler because their names are changing\n-    pub fn make_some<T>(val: T) -> Option<T> { Some(val) }\n-    pub fn make_none<T>() -> Option<T> { None }\n-}"}, {"sha": "afbb0fcb56750fbfafef29feac71da08268d22aa", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 7, "deletions": 43, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use cast::transmute;\n-use libc::{c_char, c_void, size_t, STDERR_FILENO};\n+use libc::{c_char, size_t, STDERR_FILENO};\n use io;\n use io::{Writer, WriterUtil};\n use option::{Option, None, Some};\n@@ -20,9 +20,6 @@ use sys;\n use unstable::raw;\n use vec::ImmutableVector;\n \n-#[allow(non_camel_case_types)]\n-type rust_task = c_void;\n-\n pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n@@ -35,34 +32,12 @@ struct BorrowRecord {\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    unsafe {\n-        let cur_task: *rust_task = rust_try_get_task();\n-        if cur_task.is_not_null() {\n-            let ptr = rust_take_task_borrow_list(cur_task);\n-            if ptr.is_null() {\n-                None\n-            } else {\n-                let v: ~[BorrowRecord] = transmute(ptr);\n-                Some(v)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n+    // XXX\n+    None\n }\n \n-fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n-    unsafe {\n-        let cur_task: *rust_task = rust_try_get_task();\n-        if cur_task.is_not_null() {\n-            let mut borrow_list: ~[BorrowRecord] = {\n-                let ptr = rust_take_task_borrow_list(cur_task);\n-                if ptr.is_null() { ~[] } else { transmute(ptr) }\n-            };\n-            borrow_list = f(borrow_list);\n-            rust_set_task_borrow_list(cur_task, transmute(borrow_list));\n-        }\n-    }\n+fn swap_task_borrow_list(_f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n+    // XXX\n }\n \n pub unsafe fn clear_task_borrow_list() {\n@@ -113,7 +88,8 @@ unsafe fn debug_borrow<T>(tag: &'static str,\n     //! A useful debugging function that prints a pointer + tag + newline\n     //! without allocating memory.\n \n-    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n+    // XXX\n+    if false {\n         debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n     }\n \n@@ -269,15 +245,3 @@ pub unsafe fn check_not_borrowed(a: *u8,\n         fail_borrowed(a, file, line);\n     }\n }\n-\n-\n-extern {\n-    #[rust_stack]\n-    pub fn rust_take_task_borrow_list(task: *rust_task) -> *c_void;\n-\n-    #[rust_stack]\n-    pub fn rust_set_task_borrow_list(task: *rust_task, map: *c_void);\n-\n-    #[rust_stack]\n-    pub fn rust_try_get_task() -> *rust_task;\n-}"}, {"sha": "3ca39acbfcdf4c8f05bc25a213186c619bbd2040", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -11,50 +11,9 @@\n //! Runtime environment settings\n \n use from_str::FromStr;\n-use libc::{size_t, c_char, c_int};\n use option::{Some, None};\n use os;\n \n-// OLD RT stuff\n-\n-pub struct Environment {\n-    /// The number of threads to use by default\n-    num_sched_threads: size_t,\n-    /// The minimum size of a stack segment\n-    min_stack_size: size_t,\n-    /// The maximum amount of total stack per task before aborting\n-    max_stack_size: size_t,\n-    /// The default logging configuration\n-    logspec: *c_char,\n-    /// Record and report detailed information about memory leaks\n-    detailed_leaks: bool,\n-    /// Seed the random number generator\n-    rust_seed: *c_char,\n-    /// Poison allocations on free\n-    poison_on_free: bool,\n-    /// The argc value passed to main\n-    argc: c_int,\n-    /// The argv value passed to main\n-    argv: **c_char,\n-    /// Print GC debugging info (true if env var RUST_DEBUG_MEM is set)\n-    debug_mem: bool,\n-    /// Print GC debugging info (true if env var RUST_DEBUG_BORROW is set)\n-    debug_borrow: bool,\n-}\n-\n-/// Get the global environment settings\n-/// # Safety Note\n-/// This will abort the process if run outside of task context\n-pub fn get() -> &Environment {\n-    unsafe { rust_get_rt_env() }\n-}\n-\n-extern {\n-    fn rust_get_rt_env() -> &Environment;\n-}\n-\n-// NEW RT stuff\n-\n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n "}, {"sha": "6a3e44b2a4d7009a3c914c08a4de7530501c3cae", "filename": "src/libstd/rt/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use option::Option;\n+use comm::{GenericPort, GenericChan};\n use super::{Reader, Writer};\n \n struct PortReader<P>;"}, {"sha": "11afd03033a90fdf05ad93a4b93722ba672e589c", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -13,9 +13,6 @@\n use libc;\n use libc::{c_void, uintptr_t, size_t};\n use ops::Drop;\n-use option::{Some, None};\n-use rt;\n-use rt::OldTaskContext;\n use rt::local::Local;\n use rt::task::Task;\n use unstable::raw;\n@@ -87,32 +84,14 @@ impl Drop for LocalHeap {\n \n // A little compatibility function\n pub unsafe fn local_free(ptr: *libc::c_char) {\n-    // XXX: Unsafe borrow for speed. Lame.\n-    match Local::try_unsafe_borrow::<Task>() {\n-        Some(task) => {\n-            (*task).heap.free(ptr as *libc::c_void);\n-        }\n-        None => {\n-            rust_upcall_free_noswitch(ptr);\n-\n-            extern {\n-                #[fast_ffi]\n-                fn rust_upcall_free_noswitch(ptr: *libc::c_char);\n-            }\n-        }\n+    do Local::borrow::<Task,()> |task| {\n+        task.heap.free(ptr as *libc::c_void);\n     }\n }\n \n pub fn live_allocs() -> *raw::Box<()> {\n-    let region = match rt::context() {\n-        OldTaskContext => {\n-            unsafe { rust_current_boxed_region() }\n-        }\n-        _ => {\n-            do Local::borrow::<Task, *BoxedRegion> |task| {\n-                task.heap.boxed_region\n-            }\n-        }\n+    let region = do Local::borrow::<Task, *BoxedRegion> |task| {\n+        task.heap.boxed_region\n     };\n \n     return unsafe { (*region).live_allocs };\n@@ -140,8 +119,6 @@ extern {\n                                  size: size_t) -> *OpaqueBox;\n     #[fast_ffi]\n     fn rust_boxed_region_free(region: *BoxedRegion, box: *OpaqueBox);\n-    #[fast_ffi]\n-    fn rust_current_boxed_region() -> *BoxedRegion;\n }\n \n #[cfg(test)]"}, {"sha": "348345f61fcd7f1a8c385aa1d4f197019d4eb82c", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -120,7 +120,7 @@ mod context;\n /// Bindings to system threading libraries.\n mod thread;\n \n-/// The runtime configuration, read from environment variables\n+/// The runtime configuration, read from environment variables.\n pub mod env;\n \n /// The local, managed heap\n@@ -401,35 +401,6 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     }\n }\n \n-/// Possible contexts in which Rust code may be executing.\n-/// Different runtime services are available depending on context.\n-/// Mostly used for determining if we're using the new scheduler\n-/// or the old scheduler.\n-#[deriving(Eq)]\n-pub enum RuntimeContext {\n-    // Running in an old-style task\n-    OldTaskContext,\n-    // Not old task context\n-    NewRtContext\n-}\n-\n-/// Determine the current RuntimeContext\n-pub fn context() -> RuntimeContext {\n-\n-    use task::rt::rust_task;\n-\n-    if unsafe { rust_try_get_task().is_not_null() } {\n-        return OldTaskContext;\n-    } else {\n-        return NewRtContext;\n-    }\n-\n-    extern {\n-        #[rust_stack]\n-        pub fn rust_try_get_task() -> *rust_task;\n-    }\n-}\n-\n pub fn in_sched_context() -> bool {\n     unsafe {\n         match Local::try_unsafe_borrow::<Task>() {\n@@ -456,4 +427,4 @@ pub fn in_green_task_context() -> bool {\n             None => false\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b50e794cce0f34b6de9850c58acc8695746b9339", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -515,8 +515,8 @@ mod test {\n \n         do run_in_newsched_task {\n             let (port, chan) = oneshot();\n-            send_one(chan, 10);\n-            assert!(recv_one(port) == 10);\n+            chan.send(10);\n+            assert!(port.recv() == 10);\n         }\n     }\n "}, {"sha": "a06247a103601ee337d3c84c1f23dbacce6592df", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -448,13 +448,6 @@ pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n     return rust_uv_get_len_from_buf(buf);\n }\n-pub unsafe fn malloc_buf_base_of(suggested_size: size_t) -> *u8 {\n-    return rust_uv_malloc_buf_base_of(suggested_size);\n-}\n-pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n-    rust_uv_free_base_of_buf(buf);\n-}\n-\n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::to_unsafe_ptr(&err);\n@@ -558,8 +551,6 @@ extern {\n                            repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n \n-    fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;\n-    fn rust_uv_free_base_of_buf(buf: uv_buf_t);\n     fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n     fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n     fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;"}, {"sha": "f6946d1e924e60714829a204e8f7e4fbb9d2bfce", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -164,7 +164,6 @@ pub mod trie;\n \n pub mod task;\n pub mod comm;\n-pub mod pipes;\n pub mod local_data;\n \n \n@@ -213,7 +212,6 @@ mod std {\n     pub use kinds;\n     pub use local_data;\n     pub use sys;\n-    pub use pipes;\n     pub use unstable;\n     pub use str;\n     pub use os;"}, {"sha": "cf34bd3261aff484676b36bdc85193f7adaa50ac", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 30, "deletions": 50, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -21,15 +21,6 @@ use str::StrSlice;\n use str;\n use unstable::intrinsics;\n \n-pub mod rustrt {\n-    use libc::{c_char, size_t};\n-\n-    extern {\n-        #[rust_stack]\n-        pub fn rust_upcall_fail(expr: *c_char, file: *c_char, line: size_t);\n-    }\n-}\n-\n /// Returns the size of a type\n #[inline]\n pub fn size_of<T>() -> uint {\n@@ -136,55 +127,44 @@ impl FailWithCause for &'static str {\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use either::Left;\n     use option::{Some, None};\n-    use rt::{context, OldTaskContext, in_green_task_context};\n+    use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n     use rt::logging::Logger;\n     use str::Str;\n \n-    let context = context();\n-    match context {\n-        OldTaskContext => {\n-            unsafe {\n-                rustrt::rust_upcall_fail(msg, file, line);\n-                cast::transmute(())\n+    unsafe {\n+        // XXX: Bad re-allocations. fail! needs some refactoring\n+        let msg = str::raw::from_c_str(msg);\n+        let file = str::raw::from_c_str(file);\n+\n+        // XXX: Logging doesn't work correctly in non-task context because it\n+        // invokes the local heap\n+        if in_green_task_context() {\n+            // XXX: Logging doesn't work here - the check to call the log\n+            // function never passes - so calling the log function directly.\n+            do Local::borrow::<Task, ()> |task| {\n+                let msg = match task.name {\n+                    Some(ref name) =>\n+                    fmt!(\"task '%s' failed at '%s', %s:%i\",\n+                         name.as_slice(), msg, file, line as int),\n+                    None =>\n+                    fmt!(\"task <unnamed> failed at '%s', %s:%i\",\n+                         msg, file, line as int)\n+                };\n+\n+                task.logger.log(Left(msg));\n             }\n+        } else {\n+            rterrln!(\"failed in non-task context at '%s', %s:%i\",\n+                     msg, file, line as int);\n         }\n-        _ => {\n-            unsafe {\n-                // XXX: Bad re-allocations. fail! needs some refactoring\n-                let msg = str::raw::from_c_str(msg);\n-                let file = str::raw::from_c_str(file);\n-\n-                // XXX: Logging doesn't work correctly in non-task context because it\n-                // invokes the local heap\n-                if in_green_task_context() {\n-                    // XXX: Logging doesn't work here - the check to call the log\n-                    // function never passes - so calling the log function directly.\n-                    do Local::borrow::<Task, ()> |task| {\n-                        let msg = match task.name {\n-                            Some(ref name) =>\n-                                fmt!(\"task '%s' failed at '%s', %s:%i\",\n-                                     name.as_slice(), msg, file, line as int),\n-                            None =>\n-                                fmt!(\"task <unnamed> failed at '%s', %s:%i\",\n-                                     msg, file, line as int)\n-                        };\n-\n-                        task.logger.log(Left(msg));\n-                    }\n-                } else {\n-                    rterrln!(\"failed in non-task context at '%s', %s:%i\",\n-                             msg, file, line as int);\n-                }\n-\n-                let task = Local::unsafe_borrow::<Task>();\n-                if (*task).unwinder.unwinding {\n-                    rtabort!(\"unwinding again\");\n-                }\n-                (*task).unwinder.begin_unwind();\n-            }\n+\n+        let task = Local::unsafe_borrow::<Task>();\n+        if (*task).unwinder.unwinding {\n+            rtabort!(\"unwinding again\");\n         }\n+        (*task).unwinder.begin_unwind();\n     }\n }\n "}, {"sha": "3a11dee3138168fbb4a2c5303823d85746001601", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -15,32 +15,21 @@ use libc;\n use local_data;\n use prelude::*;\n use ptr;\n-use task::rt;\n use unstable::raw;\n use util;\n \n-use super::rt::rust_task;\n use rt::task::{Task, LocalStorage};\n \n pub enum Handle {\n-    OldHandle(*rust_task),\n     NewHandle(*mut LocalStorage)\n }\n \n impl Handle {\n     pub fn new() -> Handle {\n-        use rt::{context, OldTaskContext};\n         use rt::local::Local;\n         unsafe {\n-            match context() {\n-                OldTaskContext => {\n-                    OldHandle(rt::rust_get_task())\n-                }\n-                _ => {\n-                    let task = Local::unsafe_borrow::<Task>();\n-                    NewHandle(&mut (*task).storage)\n-                }\n-            }\n+            let task = Local::unsafe_borrow::<Task>();\n+            NewHandle(&mut (*task).storage)\n         }\n     }\n }\n@@ -109,26 +98,6 @@ fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n \n-    unsafe fn oldsched_map(task: *rust_task) -> &mut TaskLocalMap {\n-        extern fn cleanup_extern_cb(map_ptr: *libc::c_void) {\n-            cleanup_task_local_map(map_ptr);\n-        }\n-\n-        // Relies on the runtime initialising the pointer to null.\n-        // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n-        // into the tls slot for this task, and then mutable loans are taken\n-        // from this slot to modify the map.\n-        let map_ptr = rt::rust_get_task_local_data(task);\n-        if (*map_ptr).is_null() {\n-            // First time TLS is used, create a new map and set up the necessary\n-            // TLS information for its safe destruction\n-            let map: TaskLocalMap = ~[];\n-            *map_ptr = cast::transmute(map);\n-            rt::rust_task_local_data_atexit(task, cleanup_extern_cb);\n-        }\n-        return cast::transmute(map_ptr);\n-    }\n-\n     unsafe fn newsched_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n         // This is based on the same idea as the oldsched code above.\n         match &mut *local {\n@@ -152,7 +121,6 @@ unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n     }\n \n     match handle {\n-        OldHandle(task) => oldsched_map(task),\n         NewHandle(local_storage) => newsched_map(local_storage)\n     }\n }"}, {"sha": "09431c05e22515f138b050fd308142ebadc66ed5", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 30, "deletions": 80, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -42,7 +42,7 @@ use cmp::Eq;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use result::Result;\n use result;\n-use rt::{context, OldTaskContext, in_green_task_context};\n+use rt::in_green_task_context;\n use rt::local::Local;\n use unstable::finally::Finally;\n use util;\n@@ -54,7 +54,6 @@ use util;\n #[cfg(test)] use task;\n \n mod local_data_priv;\n-pub mod rt;\n pub mod spawn;\n \n /**\n@@ -535,35 +534,21 @@ pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n             }\n         }\n     } else {\n-        fail!(\"no task name exists in %?\", context())\n+        fail!(\"no task name exists in non-green task context\")\n     }\n }\n \n pub fn yield() {\n     //! Yield control to the task scheduler\n \n-    use rt::{context, OldTaskContext};\n     use rt::local::Local;\n     use rt::sched::Scheduler;\n \n-    unsafe {\n-        match context() {\n-            OldTaskContext => {\n-                let task_ = rt::rust_get_task();\n-                let killed = rt::rust_task_yield(task_);\n-                if killed && !failing() {\n-                    fail!(\"killed\");\n-                }\n-            }\n-            _ => {\n-                // XXX: What does yield really mean in newsched?\n-                // FIXME(#7544): Optimize this, since we know we won't block.\n-                let sched = Local::take::<Scheduler>();\n-                do sched.deschedule_running_task_and_then |sched, task| {\n-                    sched.enqueue_blocked_task(task);\n-                }\n-            }\n-        }\n+    // XXX: What does yield really mean in newsched?\n+    // FIXME(#7544): Optimize this, since we know we won't block.\n+    let sched = Local::take::<Scheduler>();\n+    do sched.deschedule_running_task_and_then |sched, task| {\n+        sched.enqueue_blocked_task(task);\n     }\n }\n \n@@ -572,17 +557,8 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    match context() {\n-        OldTaskContext => {\n-            unsafe {\n-                rt::rust_task_is_unwinding(rt::rust_get_task())\n-            }\n-        }\n-        _ => {\n-            do Local::borrow::<Task, bool> |local| {\n-                local.unwinder.unwinding\n-            }\n-        }\n+    do Local::borrow::<Task, bool> |local| {\n+        local.unwinder.unwinding\n     }\n }\n \n@@ -605,29 +581,19 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;\n \n     unsafe {\n-        match context() {\n-            OldTaskContext => {\n-                let t = rt::rust_get_task();\n-                do (|| {\n-                    rt::rust_task_inhibit_kill(t);\n-                    f()\n-                }).finally {\n-                    rt::rust_task_allow_kill(t);\n-                }\n-            }\n-            _ if in_green_task_context() => {\n-                // The inhibits/allows might fail and need to borrow the task.\n-                let t = Local::unsafe_borrow::<Task>();\n-                do (|| {\n-                    (*t).death.inhibit_kill((*t).unwinder.unwinding);\n-                    f()\n-                }).finally {\n-                    (*t).death.allow_kill((*t).unwinder.unwinding);\n-                }\n+        if in_green_task_context() {\n+            // The inhibits/allows might fail and need to borrow the task.\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n+                f()\n+            }).finally {\n+                (*t).death.allow_kill((*t).unwinder.unwinding);\n             }\n+        } else {\n             // FIXME(#3095): This should be an rtabort as soon as the scheduler\n             // no longer uses a workqueue implemented with an Exclusive.\n-            _ => f()\n+            f()\n         }\n     }\n }\n@@ -636,27 +602,17 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;\n \n-    match context() {\n-        OldTaskContext => {\n-            let t = rt::rust_get_task();\n-            do (|| {\n-                rt::rust_task_allow_kill(t);\n-                f()\n-            }).finally {\n-                rt::rust_task_inhibit_kill(t);\n-            }\n-        }\n-        _ if in_green_task_context() => {\n-            let t = Local::unsafe_borrow::<Task>();\n-            do (|| {\n-                (*t).death.allow_kill((*t).unwinder.unwinding);\n-                f()\n-            }).finally {\n-                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n-            }\n+    if in_green_task_context() {\n+        let t = Local::unsafe_borrow::<Task>();\n+        do (|| {\n+            (*t).death.allow_kill((*t).unwinder.unwinding);\n+            f()\n+        }).finally {\n+            (*t).death.inhibit_kill((*t).unwinder.unwinding);\n         }\n+    } else {\n         // FIXME(#3095): As in unkillable().\n-        _ => f()\n+        f()\n     }\n }\n \n@@ -1034,14 +990,8 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    if context() == OldTaskContext {\n-        unsafe {\n-            rt::rust_get_sched_id() as int\n-        }\n-    } else {\n-        do Local::borrow::<::rt::sched::Scheduler, int> |sched| {\n-            sched.sched_id() as int\n-        }\n+    do Local::borrow::<::rt::sched::Scheduler, int> |sched| {\n+        sched.sched_id() as int\n     }\n }\n "}, {"sha": "13c51230dc237d5322beb0e694f18388c8af4d12", "filename": "src/libstd/task/rt.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Flibstd%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Flibstd%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Frt.rs?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The task interface to the runtime\n-\n-*/\n-\n-#[doc(hidden)];\n-\n-use libc;\n-\n-#[allow(non_camel_case_types)] // runtime type\n-pub type sched_id = int;\n-#[allow(non_camel_case_types)] // runtime type\n-pub type task_id = int;\n-\n-// These are both opaque runtime/compiler types that we don't know the\n-// structure of and should only deal with via unsafe pointer\n-#[allow(non_camel_case_types)] // runtime type\n-pub type rust_task = libc::c_void;\n-#[allow(non_camel_case_types)] // runtime type\n-pub type rust_closure = libc::c_void;\n-\n-extern {\n-    #[rust_stack]\n-    pub fn rust_task_yield(task: *rust_task) -> bool;\n-\n-    pub fn rust_get_sched_id() -> sched_id;\n-    pub fn rust_new_sched(num_threads: libc::uintptr_t) -> sched_id;\n-\n-    pub fn get_task_id() -> task_id;\n-    #[rust_stack]\n-    pub fn rust_get_task() -> *rust_task;\n-\n-    pub fn new_task() -> *rust_task;\n-    pub fn rust_new_task_in_sched(id: sched_id) -> *rust_task;\n-\n-    pub fn start_task(task: *rust_task, closure: *rust_closure);\n-\n-    pub fn rust_task_is_unwinding(task: *rust_task) -> bool;\n-    pub fn rust_osmain_sched_id() -> sched_id;\n-    #[rust_stack]\n-    pub fn rust_task_inhibit_kill(t: *rust_task);\n-    #[rust_stack]\n-    pub fn rust_task_allow_kill(t: *rust_task);\n-    #[rust_stack]\n-    pub fn rust_task_inhibit_yield(t: *rust_task);\n-    #[rust_stack]\n-    pub fn rust_task_allow_yield(t: *rust_task);\n-    pub fn rust_task_kill_other(task: *rust_task);\n-    pub fn rust_task_kill_all(task: *rust_task);\n-\n-    #[rust_stack]\n-    pub fn rust_get_task_local_data(task: *rust_task) -> *mut *libc::c_void;\n-    #[rust_stack]\n-    pub fn rust_task_local_data_atexit(task: *rust_task, cleanup_fn: *u8);\n-}"}, {"sha": "1a38dfc3d888841e446dbbc68b02eb8f605b7b07", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 16, "deletions": 127, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -81,17 +81,14 @@ use container::MutableMap;\n use comm::{Chan, GenericChan, oneshot};\n use hashmap::{HashSet, HashSetConsumeIterator};\n use local_data;\n-use task::local_data_priv::{local_get, local_set, OldHandle};\n-use task::rt::rust_task;\n-use task::rt;\n use task::{Failure, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult};\n use task::unkillable;\n use to_bytes::IterBytes;\n use uint;\n use util;\n use unstable::sync::Exclusive;\n-use rt::{OldTaskContext, NewRtContext, context, in_green_task_context};\n+use rt::in_green_task_context;\n use rt::local::Local;\n use rt::task::{Task, Sched};\n use rt::kill::KillHandle;\n@@ -107,14 +104,12 @@ use rt::work_queue::WorkQueue;\n // Transitionary.\n #[deriving(Eq)]\n enum TaskHandle {\n-    OldTask(*rust_task),\n     NewTask(KillHandle),\n }\n \n impl Clone for TaskHandle {\n     fn clone(&self) -> TaskHandle {\n         match *self {\n-            OldTask(x) => OldTask(x),\n             NewTask(ref x) => NewTask(x.clone()),\n         }\n     }\n@@ -123,7 +118,6 @@ impl Clone for TaskHandle {\n impl IterBytes for TaskHandle {\n     fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n         match *self {\n-            OldTask(ref x) => x.iter_bytes(lsb0, f),\n             NewTask(ref x) => x.iter_bytes(lsb0, f),\n         }\n     }\n@@ -498,7 +492,6 @@ struct RuntimeGlue;\n impl RuntimeGlue {\n     unsafe fn kill_task(task: TaskHandle) {\n         match task {\n-            OldTask(ptr) => rt::rust_task_kill_other(ptr),\n             NewTask(handle) => {\n                 let mut handle = handle;\n                 do handle.kill().map_move |killed_task| {\n@@ -513,57 +506,31 @@ impl RuntimeGlue {\n \n     unsafe fn kill_all_tasks(task: &TaskHandle) {\n         match *task {\n-            OldTask(ptr) => rt::rust_task_kill_all(ptr),\n             // FIXME(#7544): Remove the kill_all feature entirely once the\n             // oldsched goes away.\n             NewTask(ref _handle) => rtabort!(\"can't kill_all in newsched\"),\n         }\n     }\n \n     fn with_task_handle_and_failing(blk: &fn(TaskHandle, bool)) {\n-        match context() {\n-            OldTaskContext => unsafe {\n-                let me = rt::rust_get_task();\n-                blk(OldTask(me), rt::rust_task_is_unwinding(me))\n-            },\n-            NewRtContext if in_green_task_context() => unsafe {\n+        if in_green_task_context() {\n+            unsafe {\n                 // Can't use safe borrow, because the taskgroup destructor needs to\n                 // access the scheduler again to send kill signals to other tasks.\n                 let me = Local::unsafe_borrow::<Task>();\n                 // FIXME(#7544): Get rid of this clone by passing by-ref.\n                 // Will probably have to wait until the old rt is gone.\n                 blk(NewTask((*me).death.kill_handle.get_ref().clone()),\n                     (*me).unwinder.unwinding)\n-            },\n-            NewRtContext => rtabort!(\"task dying in bad context\"),\n+            }\n+        } else {\n+            rtabort!(\"task dying in bad context\")\n         }\n     }\n \n     fn with_my_taskgroup<U>(blk: &fn(&Taskgroup) -> U) -> U {\n-        match context() {\n-            OldTaskContext => unsafe {\n-                let me = rt::rust_get_task();\n-                do local_get(OldHandle(me), taskgroup_key()) |g| {\n-                    match g {\n-                        None => {\n-                            // Main task, doing first spawn ever. Lazily initialise here.\n-                            let mut members = TaskSet::new();\n-                            members.insert(OldTask(me));\n-                            let tasks = Exclusive::new(Some(TaskGroupData {\n-                                members: members,\n-                                descendants: TaskSet::new(),\n-                            }));\n-                            // Main task/group has no ancestors, no notifier, etc.\n-                            let group = @@mut Taskgroup(tasks, AncestorList(None),\n-                                                        true, None);\n-                            local_set(OldHandle(me), taskgroup_key(), group);\n-                            blk(&**group)\n-                        }\n-                        Some(&group) => blk(&**group)\n-                    }\n-                }\n-            },\n-            NewRtContext if in_green_task_context() => unsafe {\n+        if in_green_task_context() {\n+            unsafe {\n                 // Can't use safe borrow, because creating new hashmaps for the\n                 // tasksets requires an rng, which needs to borrow the sched.\n                 let me = Local::unsafe_borrow::<Task>();\n@@ -587,8 +554,9 @@ impl RuntimeGlue {\n                     }\n                     Some(ref group) => group,\n                 })\n-            },\n-            NewRtContext => rtabort!(\"spawning in bad context\"),\n+            }\n+        } else {\n+            rtabort!(\"spawning in bad context\")\n         }\n     }\n }\n@@ -598,7 +566,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     -> Option<(TaskGroupArc, AncestorList, bool)> {\n     // FIXME(#7544): Not safe to lazily initialize in the old runtime. Remove\n     // this context check once 'spawn_raw_oldsched' is gone.\n-    if context() == OldTaskContext || linked || supervised {\n+    if linked || supervised {\n         // with_my_taskgroup will lazily initialize the parent's taskgroup if\n         // it doesn't yet exist. We don't want to call it in the unlinked case.\n         do RuntimeGlue::with_my_taskgroup |spawner_group| {\n@@ -665,10 +633,10 @@ fn enlist_many(child: TaskHandle, child_arc: &TaskGroupArc,\n }\n \n pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n-    match context() {\n-        OldTaskContext => spawn_raw_oldsched(opts, f),\n-        _ if in_green_task_context() => spawn_raw_newsched(opts, f),\n-        _ => fail!(\"can't spawn from this context\")\n+    if in_green_task_context() {\n+        spawn_raw_newsched(opts, f)\n+    } else {\n+        fail!(\"can't spawn from this context\")\n     }\n }\n \n@@ -810,85 +778,6 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n \n }\n \n-fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n-\n-    let (child_tg, ancestors, is_main) =\n-        gen_child_taskgroup(opts.linked, opts.supervised).expect(\"old runtime needs TG\");\n-\n-    unsafe {\n-        let child_data = Cell::new((child_tg, ancestors, f));\n-        // Being killed with the unsafe task/closure pointers would leak them.\n-        do unkillable {\n-            let (child_tg, ancestors, f) = child_data.take(); // :(\n-            // Create child task.\n-            let new_task = match opts.sched.mode {\n-                DefaultScheduler => rt::new_task(),\n-                _ => new_task_in_sched()\n-            };\n-            assert!(!new_task.is_null());\n-            // Getting killed after here would leak the task.\n-            let child_wrapper = make_child_wrapper(new_task, child_tg,\n-                  ancestors, is_main, opts.notify_chan.take(), f);\n-\n-            let closure = cast::transmute(&child_wrapper);\n-\n-            // Getting killed between these two calls would free the child's\n-            // closure. (Reordering them wouldn't help - then getting killed\n-            // between them would leak.)\n-            rt::start_task(new_task, closure);\n-            cast::forget(child_wrapper);\n-        }\n-    }\n-\n-    // This function returns a closure-wrapper that we pass to the child task.\n-    // (1) It sets up the notification channel.\n-    // (2) It attempts to enlist in the child's group and all ancestor groups.\n-    // (3a) If any of those fails, it leaves all groups, and does nothing.\n-    // (3b) Otherwise it builds a task control structure and puts it in TLS,\n-    // (4) ...and runs the provided body function.\n-    fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n-                          ancestors: AncestorList, is_main: bool,\n-                          notify_chan: Option<Chan<TaskResult>>,\n-                          f: ~fn())\n-                       -> ~fn() {\n-        let child_data = Cell::new((notify_chan, child_arc, ancestors));\n-        let result: ~fn() = || {\n-            let (notify_chan, child_arc, ancestors) = child_data.take(); // :(\n-            let mut ancestors = ancestors;\n-            // Child task runs this code.\n-\n-            // Even if the below code fails to kick the child off, we must\n-            // send Something on the notify channel.\n-\n-            let notifier = notify_chan.map_move(|c| AutoNotify(c));\n-\n-            if enlist_many(OldTask(child), &child_arc, &mut ancestors) {\n-                let group = @@mut Taskgroup(child_arc, ancestors, is_main, notifier);\n-                unsafe {\n-                    local_set(OldHandle(child), taskgroup_key(), group);\n-                }\n-\n-                // Run the child's body.\n-                f();\n-\n-                // TLS cleanup code will exit the taskgroup.\n-            }\n-\n-            // Run the box annihilator.\n-            // FIXME #4428: Crashy.\n-            // unsafe { cleanup::annihilate(); }\n-        };\n-        return result;\n-    }\n-\n-    fn new_task_in_sched() -> *rust_task {\n-        unsafe {\n-            let sched_id = rt::rust_new_sched(1);\n-            rt::rust_new_task_in_sched(sched_id)\n-        }\n-    }\n-}\n-\n #[test]\n fn test_spawn_raw_simple() {\n     let (po, ch) = stream();"}, {"sha": "455877687b9e8974998db88bc87bcfaa10222b07", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 12, "deletions": 46, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -11,34 +11,13 @@\n //! Runtime calls emitted by the compiler.\n \n use cast::transmute;\n-use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n-use option::{Some, None};\n+use libc::{c_char, c_uchar, c_void, size_t, uintptr_t};\n use str;\n use sys;\n use rt::task::Task;\n use rt::local::Local;\n use rt::borrowck;\n \n-#[allow(non_camel_case_types)]\n-pub type rust_task = c_void;\n-\n-pub mod rustrt {\n-    use unstable::lang::rust_task;\n-    use libc::{c_char, uintptr_t};\n-\n-    extern {\n-        #[rust_stack]\n-        pub fn rust_upcall_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n-        #[rust_stack]\n-        pub fn rust_upcall_free(ptr: *c_char);\n-        #[fast_ffi]\n-        pub fn rust_upcall_malloc_noswitch(td: *c_char, size: uintptr_t)\n-                                           -> *c_char;\n-        #[rust_stack]\n-        pub fn rust_try_get_task() -> *rust_task;\n-    }\n-}\n-\n #[lang=\"fail_\"]\n pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n     sys::begin_unwind_(expr, file, line);\n@@ -56,15 +35,14 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n \n #[lang=\"malloc\"]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    // XXX: Unsafe borrow for speed. Lame.\n-    match Local::try_unsafe_borrow::<Task>() {\n-        Some(task) => {\n-            (*task).heap.alloc(td as *c_void, size as uint) as *c_char\n-        }\n-        None => {\n-            rustrt::rust_upcall_malloc_noswitch(td, size)\n-        }\n+    let mut alloc = ::ptr::null();\n+    do Local::borrow::<Task,()> |task| {\n+        rtdebug!(\"task pointer: %x, heap pointer: %x\",\n+                 ::borrow::to_uint(task),\n+                 ::borrow::to_uint(&task.heap));\n+        alloc = task.heap.alloc(td as *c_void, size as uint) as *c_char;\n     }\n+    return alloc;\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -129,23 +107,11 @@ pub unsafe fn annihilate() {\n pub fn start(main: *u8, argc: int, argv: **c_char,\n              crate_map: *u8) -> int {\n     use rt;\n-    use os;\n \n     unsafe {\n-        let use_old_rt = os::getenv(\"RUST_OLDRT\").is_some();\n-        if use_old_rt {\n-            return rust_start(main as *c_void, argc as c_int, argv,\n-                              crate_map as *c_void) as int;\n-        } else {\n-            return do rt::start(argc, argv as **u8, crate_map) {\n-                let main: extern \"Rust\" fn() = transmute(main);\n-                main();\n-            };\n-        }\n-    }\n-\n-    extern {\n-        fn rust_start(main: *c_void, argc: c_int, argv: **c_char,\n-                      crate_map: *c_void) -> c_int;\n+        return do rt::start(argc, argv as **u8, crate_map) {\n+            let main: extern \"Rust\" fn() = transmute(main);\n+            main();\n+        };\n     }\n }"}, {"sha": "a9dded41683a9718676ee863d2986197aecc8192", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -280,39 +280,19 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n // FIXME(#8140) should not be pub\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;\n-    use task::rt;\n     use rt::local::Local;\n-    use rt::{context, OldTaskContext};\n-\n-    match context() {\n-        OldTaskContext => {\n-            let t = rt::rust_get_task();\n-            do (|| {\n-                rt::rust_task_inhibit_kill(t);\n-                rt::rust_task_inhibit_yield(t);\n-                f()\n-            }).finally {\n-                rt::rust_task_allow_yield(t);\n-                rt::rust_task_allow_kill(t);\n-            }\n-        }\n-        _ => {\n-            let t = Local::try_unsafe_borrow::<Task>();\n-            match t {\n-                Some(t) => {\n-                    do (|| {\n-                        (*t).death.inhibit_yield();\n-                        f()\n-                    }).finally {\n-                        (*t).death.allow_yield();\n-                    }\n-                }\n-                None => {\n-                    // FIXME(#3095): As in unkillable().\n-                    f()\n-                }\n-            }\n+    use rt::in_green_task_context;\n+\n+    if in_green_task_context() {\n+        let t = Local::unsafe_borrow::<Task>();\n+        do (|| {\n+            (*t).death.inhibit_yield();\n+            f()\n+        }).finally {\n+            (*t).death.allow_yield();\n         }\n+    } else {\n+        f()\n     }\n }\n "}, {"sha": "0d3d6c019f89f025a0e5aee8747ec94d40daf272", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#include \"memory_region.h\"\n #include \"boxed_region.h\"\n #include \"rust_globals.h\"\n-#include \"rust_task.h\"\n #include \"rust_env.h\"\n #include \"rust_util.h\"\n "}, {"sha": "803da32cbc8ac7cffa5c8c6631ce5fdc31b69bee", "filename": "src/rt/rust.cpp", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,76 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/**\n- * Main entry point into the Rust runtime. Here we initialize the kernel,\n- * create the initial scheduler and run the main task.\n- */\n-\n-#include \"rust_globals.h\"\n-#include \"rust_kernel.h\"\n-#include \"rust_util.h\"\n-#include \"rust_scheduler.h\"\n-#include \"rust_gc_metadata.h\"\n-\n-void* global_crate_map = NULL;\n-\n-/**\n-   The runtime entrypoint. The (C ABI) main function generated by rustc calls\n-   `rust_start`, providing the address of the Rust ABI main function, the\n-   platform argument vector, and a `crate_map` the provides some logging\n-   metadata.\n-*/\n-extern \"C\" CDECL int\n-rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n-\n-    // Load runtime configuration options from the environment.\n-    // FIXME #1497: Should provide a way to get these from the command\n-    // line as well.\n-    rust_env *env = load_env(argc, argv);\n-\n-    global_crate_map = crate_map;\n-\n-    update_gc_metadata(crate_map);\n-\n-    update_log_settings(crate_map, env->logspec);\n-\n-    rust_kernel *kernel = new rust_kernel(env);\n-\n-    // Create the main task\n-    rust_sched_id sched_id = kernel->main_sched_id();\n-    rust_scheduler *sched = kernel->get_scheduler_by_id(sched_id);\n-    assert(sched != NULL);\n-    rust_task *root_task = sched->create_task(NULL, \"main\");\n-\n-    // Schedule the main Rust task\n-    root_task->start((spawn_fn)main_fn, NULL, NULL);\n-\n-    // At this point the task lifecycle is responsible for it\n-    // and our pointer may not be valid\n-    root_task = NULL;\n-\n-    // Run the kernel until all schedulers exit\n-    int ret = kernel->run();\n-\n-    delete kernel;\n-    free_env(env);\n-\n-    return ret;\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0729cc1958bc9bd512e6d1c111938dd16e03e5d5", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 19, "deletions": 237, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -10,14 +10,16 @@\n \n /* Foreign builtins. */\n \n-#include \"rust_sched_loop.h\"\n-#include \"rust_task.h\"\n #include \"rust_util.h\"\n-#include \"rust_scheduler.h\"\n #include \"sync/timer.h\"\n #include \"sync/rust_thread.h\"\n+#include \"sync/lock_and_signal.h\"\n+#include \"memory_region.h\"\n+#include \"boxed_region.h\"\n #include \"rust_abi.h\"\n+#include \"rust_rng.h\"\n #include \"vg/valgrind.h\"\n+#include \"sp.h\"\n \n #include <time.h>\n \n@@ -68,12 +70,6 @@ rust_env_pairs() {\n }\n #endif\n \n-extern \"C\" CDECL void *\n-rust_local_realloc(rust_opaque_box *ptr, size_t size) {\n-    rust_task *task = rust_get_current_task();\n-    return task->boxed.realloc(ptr, size);\n-}\n-\n extern \"C\" CDECL size_t\n rand_seed_size() {\n     return rng_seed_size();\n@@ -150,12 +146,6 @@ debug_static_mut_check_four() {\n     assert(debug_static_mut == 4);\n }\n \n-extern \"C\" CDECL void *\n-debug_get_stk_seg() {\n-    rust_task *task = rust_get_current_task();\n-    return task->stk;\n-}\n-\n extern \"C\" CDECL char*\n #if defined(__WIN32__)\n rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {\n@@ -383,162 +373,25 @@ rust_mktime(rust_tm* timeptr) {\n     return mktime(&t);\n }\n \n-extern \"C\" CDECL rust_sched_id\n-rust_get_sched_id() {\n-    rust_task *task = rust_get_current_task();\n-    return task->sched->get_id();\n-}\n-\n-extern \"C\" CDECL int\n-rust_get_argc() {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->env->argc;\n-}\n-\n-extern \"C\" CDECL char**\n-rust_get_argv() {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->env->argv;\n-}\n-\n-extern \"C\" CDECL rust_sched_id\n-rust_new_sched(uintptr_t threads) {\n-    rust_task *task = rust_get_current_task();\n-    assert(threads > 0 && \"Can't create a scheduler with no threads, silly!\");\n-    return task->kernel->create_scheduler(threads);\n-}\n-\n-extern \"C\" CDECL rust_task_id\n-get_task_id() {\n-    rust_task *task = rust_get_current_task();\n-    return task->id;\n-}\n-\n-static rust_task*\n-new_task_common(rust_scheduler *sched, rust_task *parent) {\n-    return sched->create_task(parent, NULL);\n-}\n-\n-extern \"C\" CDECL rust_task*\n-new_task() {\n-    rust_task *task = rust_get_current_task();\n-    rust_sched_id sched_id = task->kernel->main_sched_id();\n-    rust_scheduler *sched = task->kernel->get_scheduler_by_id(sched_id);\n-    assert(sched != NULL && \"should always have a main scheduler\");\n-    return new_task_common(sched, task);\n-}\n-\n-extern \"C\" CDECL rust_task*\n-rust_new_task_in_sched(rust_sched_id id) {\n-    rust_task *task = rust_get_current_task();\n-    rust_scheduler *sched = task->kernel->get_scheduler_by_id(id);\n-    if (sched == NULL)\n-        return NULL;\n-    return new_task_common(sched, task);\n-}\n-\n-extern \"C\" rust_task *\n-rust_get_task() {\n-    return rust_get_current_task();\n-}\n-\n-extern \"C\" rust_task *\n-rust_try_get_task() {\n-    return rust_try_get_current_task();\n-}\n-\n-extern \"C\" CDECL stk_seg *\n-rust_get_stack_segment() {\n-    return rust_get_current_task()->stk;\n-}\n-\n-extern \"C\" CDECL stk_seg *\n-rust_get_c_stack() {\n-    return rust_get_current_task()->get_c_stack();\n-}\n-\n-extern \"C\" CDECL void\n-start_task(rust_task *target, fn_env_pair *f) {\n-    target->start(f->f, f->env, NULL);\n-}\n-\n-// This is called by an intrinsic on the Rust stack and must run\n-// entirely in the red zone. Do not call on the C stack.\n-extern \"C\" CDECL MUST_CHECK bool\n-rust_task_yield(rust_task *task, bool *killed) {\n-    return task->yield();\n-}\n-\n-extern \"C\" CDECL void\n-rust_set_exit_status(intptr_t code) {\n-    rust_task *task = rust_get_current_task();\n-    task->kernel->set_exit_status((int)code);\n-}\n-\n-extern void log_console_on();\n+static lock_and_signal log_lock;\n+static bool log_to_console = true;\n \n extern \"C\" CDECL void\n rust_log_console_on() {\n-    log_console_on();\n+    scoped_lock with(log_lock);\n+    log_to_console = true;\n }\n \n-extern void log_console_off();\n-\n extern \"C\" CDECL void\n rust_log_console_off() {\n-    log_console_off();\n+    scoped_lock with(log_lock);\n+    log_to_console = false;\n }\n \n-extern bool should_log_console();\n-\n extern \"C\" CDECL uintptr_t\n rust_should_log_console() {\n-    return (uintptr_t)should_log_console();\n-}\n-\n-extern \"C\" CDECL rust_sched_id\n-rust_osmain_sched_id() {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->osmain_sched_id();\n-}\n-\n-extern \"C\" void\n-rust_task_inhibit_kill(rust_task *task) {\n-    task->inhibit_kill();\n-}\n-\n-extern \"C\" void\n-rust_task_allow_kill(rust_task *task) {\n-    task->allow_kill();\n-}\n-\n-extern \"C\" void\n-rust_task_inhibit_yield(rust_task *task) {\n-    task->inhibit_yield();\n-}\n-\n-extern \"C\" void\n-rust_task_allow_yield(rust_task *task) {\n-    task->allow_yield();\n-}\n-\n-extern \"C\" void\n-rust_task_kill_other(rust_task *task) { /* Used for linked failure */\n-    task->kill();\n-}\n-\n-extern \"C\" void\n-rust_task_kill_all(rust_task *task) { /* Used for linked failure */\n-    task->fail_sched_loop();\n-    // This must not happen twice.\n-    static bool main_taskgroup_failed = false;\n-    assert(!main_taskgroup_failed);\n-    main_taskgroup_failed = true;\n-}\n-\n-extern \"C\" CDECL\n-bool rust_task_is_unwinding(rust_task *rt) {\n-    return rt->unwinding;\n+    scoped_lock with(log_lock);\n+    return log_to_console;\n }\n \n extern \"C\" lock_and_signal*\n@@ -561,71 +414,6 @@ rust_unlock_little_lock(lock_and_signal *lock) {\n     lock->unlock();\n }\n \n-// get/atexit task_local_data can run on the rust stack for speed.\n-extern \"C\" void **\n-rust_get_task_local_data(rust_task *task) {\n-    return &task->task_local_data;\n-}\n-extern \"C\" void\n-rust_task_local_data_atexit(rust_task *task, void (*cleanup_fn)(void *data)) {\n-    task->task_local_data_cleanup = cleanup_fn;\n-}\n-\n-// set/get/atexit task_borrow_list can run on the rust stack for speed.\n-extern \"C\" void *\n-rust_take_task_borrow_list(rust_task *task) {\n-    void *r = task->borrow_list;\n-    task->borrow_list = NULL;\n-    return r;\n-}\n-extern \"C\" void\n-rust_set_task_borrow_list(rust_task *task, void *data) {\n-    assert(task->borrow_list == NULL);\n-    assert(data != NULL);\n-    task->borrow_list = data;\n-}\n-\n-extern \"C\" void\n-task_clear_event_reject(rust_task *task) {\n-    task->clear_event_reject();\n-}\n-\n-// Waits on an event, returning the pointer to the event that unblocked this\n-// task.\n-extern \"C\" MUST_CHECK bool\n-task_wait_event(rust_task *task, void **result) {\n-    // Maybe (if not too slow) assert that the passed in task is the currently\n-    // running task. We wouldn't want to wait some other task.\n-\n-    return task->wait_event(result);\n-}\n-\n-extern \"C\" void\n-task_signal_event(rust_task *target, void *event) {\n-    target->signal_event(event);\n-}\n-\n-// Can safely run on the rust stack.\n-extern \"C\" void\n-rust_task_ref(rust_task *task) {\n-    task->ref();\n-}\n-\n-// Don't run on the rust stack!\n-extern \"C\" void\n-rust_task_deref(rust_task *task) {\n-    task->deref();\n-}\n-\n-// Don't run on the Rust stack!\n-extern \"C\" void\n-rust_log_str(uint32_t level, const char *str, size_t size) {\n-    rust_task *task = rust_get_current_task();\n-    task->sched_loop->get_log().log(task, level, \"%.*s\", (int)size, str);\n-}\n-\n-extern \"C\" CDECL void      record_sp_limit(void *limit);\n-\n class raw_thread: public rust_thread {\n public:\n     fn_env_pair fn;\n@@ -684,12 +472,6 @@ rust_readdir() {\n \n #endif\n \n-extern \"C\" rust_env*\n-rust_get_rt_env() {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->env;\n-}\n-\n #ifndef _WIN32\n pthread_key_t rt_key = -1;\n #else\n@@ -737,12 +519,6 @@ rust_delete_memory_region(memory_region *region) {\n     delete region;\n }\n \n-extern \"C\" CDECL boxed_region*\n-rust_current_boxed_region() {\n-    rust_task *task = rust_get_current_task();\n-    return &task->boxed;\n-}\n-\n extern \"C\" CDECL boxed_region*\n rust_new_boxed_region(memory_region *region,\n                       uintptr_t poison_on_free) {\n@@ -848,6 +624,12 @@ rust_drop_change_dir_lock() {\n     change_dir_lock.unlock();\n }\n \n+// Used by i386 __morestack\n+extern \"C\" CDECL uintptr_t\n+rust_get_task() {\n+    return 0;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "80b969d6f6d7d7ebf6a728a00b2609afc71a59ab", "filename": "src/rt/rust_crate_map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_crate_map.h", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_crate_map.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_map.h?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -11,7 +11,7 @@\n #ifndef RUST_CRATE_MAP_H\n #define RUST_CRATE_MAP_H\n \n-#include \"rust_log.h\"\n+#include \"rust_globals.h\"\n #include <stdint.h>\n \n struct mod_entry {"}, {"sha": "f403b0434b649c01dd2fa49fab9c4e569fb2ce2d", "filename": "src/rt/rust_debug.cpp", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_debug.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_debug.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_debug.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Routines useful when debugging the Rust runtime.\n-\n-#include \"rust_globals.h\"\n-#include \"rust_abi.h\"\n-#include \"rust_debug.h\"\n-#include \"rust_task.h\"\n-\n-#include <iostream>\n-#include <string>\n-#include <sstream>\n-\n-namespace {\n-\n-debug::flag track_origins(\"RUST_TRACK_ORIGINS\");\n-\n-}   // end anonymous namespace\n-\n-namespace debug {\n-\n-void\n-maybe_track_origin(rust_task *task, void *ptr) {\n-    if (!*track_origins)\n-        return;\n-    task->debug.origins[ptr] =\n-        stack_walk::symbolicate(stack_walk::backtrace());\n-}\n-\n-void\n-maybe_untrack_origin(rust_task *task, void *ptr) {\n-    if (!*track_origins)\n-        return;\n-    task->debug.origins.erase(ptr);\n-}\n-\n-// This function is intended to be called by the debugger.\n-void\n-dump_origin(rust_task *task, void *ptr) {\n-    if (!*track_origins) {\n-        std::cerr << \"Try again with RUST_TRACK_ORIGINS=1.\" << std::endl;\n-    } else if (task->debug.origins.find(ptr) == task->debug.origins.end()) {\n-        std::cerr << \"Pointer \" << std::hex << (uintptr_t)ptr <<\n-                     \" does not have a tracked origin.\" << std::endl;\n-    } else {\n-        std::cerr << \"Origin of pointer \" << std::hex << (uintptr_t)ptr <<\n-                     \":\" << std::endl << task->debug.origins[ptr] <<\n-                     std::endl;\n-    }\n-}\n-\n-}   // end namespace debug"}, {"sha": "951d2c36cb8b15d51020fa5543e77d9bacdc7645", "filename": "src/rt/rust_debug.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_debug.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_debug.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_debug.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Routines useful when debugging the Rust runtime.\n-\n-#ifndef RUST_DEBUG_H\n-#define RUST_DEBUG_H\n-\n-#include <map>\n-#include <string>\n-#include <cstdlib>\n-\n-struct rust_task;\n-\n-namespace debug {\n-\n-class flag {\n-private:\n-    const char *name;\n-    bool valid;\n-    bool value;\n-\n-public:\n-    flag(const char *in_name) : name(in_name), valid(false) {}\n-\n-    bool operator*() {\n-        // FIXME (#2689): We ought to lock this.\n-        if (!valid) {\n-            char *ev = getenv(name);\n-            value = ev && ev[0] != '\\0' && ev[0] != '0';\n-            valid = true;\n-        }\n-        return value;\n-    }\n-};\n-\n-class task_debug_info {\n-public:\n-    std::map<void *,std::string> origins;\n-};\n-\n-std::string backtrace();\n-\n-void maybe_track_origin(rust_task *task, void *ptr);\n-void maybe_untrack_origin(rust_task *task, void *ptr);\n-\n-// This function is intended to be called by the debugger.\n-void dump_origin(rust_task *task, void *ptr);\n-\n-}   // end namespace debug\n-\n-#endif"}, {"sha": "814cfbb310a79aa3d2c608411d436fab953d3814", "filename": "src/rt/rust_kernel.cpp", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,322 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-\n-#include \"rust_kernel.h\"\n-#include \"rust_util.h\"\n-#include \"rust_scheduler.h\"\n-#include \"rust_sched_launcher.h\"\n-#include <algorithm>\n-\n-#define KLOG_(...)                              \\\n-    KLOG(this, kern, __VA_ARGS__)\n-#define KLOG_ERR_(field, ...)                   \\\n-    KLOG_LVL(this, field, log_err, __VA_ARGS__)\n-\n-rust_kernel::rust_kernel(rust_env *env) :\n-    _log(NULL),\n-    max_task_id(INIT_TASK_ID-1), // sync_add_and_fetch increments first\n-    rval(0),\n-    max_sched_id(1),\n-    killed(false),\n-    already_exiting(false),\n-    sched_reaper(this),\n-    osmain_driver(NULL),\n-    non_weak_tasks(0),\n-    env(env)\n-{\n-    // Create the single threaded scheduler that will run on the platform's\n-    // main thread\n-    rust_manual_sched_launcher_factory *osmain_launchfac =\n-        new rust_manual_sched_launcher_factory();\n-    osmain_scheduler = create_scheduler(osmain_launchfac, 1, false);\n-    osmain_driver = osmain_launchfac->get_driver();\n-\n-    // Create the primary scheduler\n-    rust_thread_sched_launcher_factory *main_launchfac =\n-        new rust_thread_sched_launcher_factory();\n-    main_scheduler = create_scheduler(main_launchfac,\n-                                      env->num_sched_threads,\n-                                      false);\n-\n-    sched_reaper.start();\n-}\n-\n-void\n-rust_kernel::log(uint32_t level, char const *fmt, ...) {\n-    char buf[BUF_BYTES];\n-    va_list args;\n-    va_start(args, fmt);\n-    vsnprintf(buf, sizeof(buf), fmt, args);\n-    _log.trace_ln(NULL, level, buf);\n-    va_end(args);\n-}\n-\n-void\n-rust_kernel::fatal(char const *fmt, ...) {\n-    char buf[BUF_BYTES];\n-    va_list args;\n-    va_start(args, fmt);\n-    vsnprintf(buf, sizeof(buf), fmt, args);\n-    _log.trace_ln(NULL, (uint32_t)0, buf);\n-    exit(1);\n-    va_end(args);\n-}\n-\n-void *\n-rust_kernel::malloc(size_t size, const char *tag) {\n-    return exchange_alloc.malloc(size);\n-}\n-\n-void *\n-rust_kernel::realloc(void *mem, size_t size) {\n-    return exchange_alloc.realloc(mem, size);\n-}\n-\n-void rust_kernel::free(void *mem) {\n-    exchange_alloc.free(mem);\n-}\n-\n-rust_sched_id\n-rust_kernel::create_scheduler(size_t num_threads) {\n-    rust_thread_sched_launcher_factory *launchfac =\n-        new rust_thread_sched_launcher_factory();\n-    return create_scheduler(launchfac, num_threads, true);\n-}\n-\n-rust_sched_id\n-rust_kernel::create_scheduler(rust_sched_launcher_factory *launchfac,\n-                              size_t num_threads, bool allow_exit) {\n-    rust_sched_id id;\n-    rust_scheduler *sched;\n-    {\n-        scoped_lock with(sched_lock);\n-\n-        /*if (sched_table.size() == 2) {\n-            // The main and OS main schedulers may not exit while there are\n-            // other schedulers\n-            KLOG_(\"Disallowing main scheduler to exit\");\n-            rust_scheduler *main_sched =\n-                get_scheduler_by_id_nolock(main_scheduler);\n-            assert(main_sched != NULL);\n-            main_sched->disallow_exit();\n-        }\n-        if (sched_table.size() == 1) {\n-            KLOG_(\"Disallowing osmain scheduler to exit\");\n-            rust_scheduler *osmain_sched =\n-                get_scheduler_by_id_nolock(osmain_scheduler);\n-            assert(osmain_sched != NULL);\n-            osmain_sched->disallow_exit();\n-            }*/\n-\n-        id = max_sched_id++;\n-        assert(id != INTPTR_MAX && \"Hit the maximum scheduler id\");\n-        sched = new (this, \"rust_scheduler\")\n-            rust_scheduler(this, num_threads, id, allow_exit, killed,\n-                           launchfac);\n-        bool is_new = sched_table\n-            .insert(std::pair<rust_sched_id,\n-                              rust_scheduler*>(id, sched)).second;\n-        assert(is_new && \"Reusing a sched id?\");\n-    }\n-    sched->start_task_threads();\n-    return id;\n-}\n-\n-rust_scheduler *\n-rust_kernel::get_scheduler_by_id(rust_sched_id id) {\n-    scoped_lock with(sched_lock);\n-    return get_scheduler_by_id_nolock(id);\n-}\n-\n-rust_scheduler *\n-rust_kernel::get_scheduler_by_id_nolock(rust_sched_id id) {\n-    if (id == 0) {\n-        return NULL;\n-    }\n-    sched_lock.must_have_lock();\n-    sched_map::iterator iter = sched_table.find(id);\n-    if (iter != sched_table.end()) {\n-        return iter->second;\n-    } else {\n-        return NULL;\n-    }\n-}\n-\n-void\n-rust_kernel::release_scheduler_id(rust_sched_id id) {\n-    scoped_lock with(sched_lock);\n-    join_list.push_back(id);\n-    sched_lock.signal();\n-}\n-\n-/*\n-Called by rust_sched_reaper to join every terminating scheduler thread,\n-so that we can be sure they have completely exited before the process exits.\n-If we don't join them then we can see valgrind errors due to un-freed pthread\n-memory.\n- */\n-void\n-rust_kernel::wait_for_schedulers()\n-{\n-    scoped_lock with(sched_lock);\n-    while (!sched_table.empty()) {\n-        while (!join_list.empty()) {\n-            rust_sched_id id = join_list.back();\n-            KLOG_(\"Deleting scheduler %d\", id);\n-            join_list.pop_back();\n-            sched_map::iterator iter = sched_table.find(id);\n-            assert(iter != sched_table.end());\n-            rust_scheduler *sched = iter->second;\n-            sched_table.erase(iter);\n-            sched->join_task_threads();\n-            sched->deref();\n-            /*if (sched_table.size() == 2) {\n-                KLOG_(\"Allowing main scheduler to exit\");\n-                // It's only the main schedulers left. Tell them to exit\n-                rust_scheduler *main_sched =\n-                    get_scheduler_by_id_nolock(main_scheduler);\n-                assert(main_sched != NULL);\n-                main_sched->allow_exit();\n-            }\n-            if (sched_table.size() == 1) {\n-                KLOG_(\"Allowing osmain scheduler to exit\");\n-                rust_scheduler *osmain_sched =\n-                    get_scheduler_by_id_nolock(osmain_scheduler);\n-                assert(osmain_sched != NULL);\n-                osmain_sched->allow_exit();\n-            }*/\n-        }\n-        if (!sched_table.empty()) {\n-            sched_lock.wait();\n-        }\n-    }\n-}\n-\n-/* Called on the main thread to run the osmain scheduler to completion,\n-   then wait for schedulers to exit */\n-int\n-rust_kernel::run() {\n-    assert(osmain_driver != NULL);\n-    osmain_driver->start_main_loop();\n-    sched_reaper.join();\n-    return rval;\n-}\n-\n-void\n-rust_kernel::fail() {\n-    // FIXME (#908): On windows we're getting \"Application has\n-    // requested the Runtime to terminate it in an unusual way\" when\n-    // trying to shutdown cleanly.\n-    set_exit_status(PROC_FAIL_CODE);\n-#if defined(__WIN32__)\n-    exit(rval);\n-#endif\n-    // I think this only needs to be done by one task ever; as it is,\n-    // multiple tasks invoking kill_all might get here. Currently libcore\n-    // ensures only one task will ever invoke it, but this would really be\n-    // fine either way, so I'm leaving it as it is. -- bblum\n-\n-    // Copy the list of schedulers so that we don't hold the lock while\n-    // running kill_all_tasks. Refcount to ensure they stay alive.\n-    std::vector<rust_scheduler*> scheds;\n-    {\n-        scoped_lock with(sched_lock);\n-        // All schedulers created after this flag is set will be doomed.\n-        killed = true;\n-        for (sched_map::iterator iter = sched_table.begin();\n-             iter != sched_table.end(); iter++) {\n-            iter->second->ref();\n-            scheds.push_back(iter->second);\n-        }\n-    }\n-\n-    for (std::vector<rust_scheduler*>::iterator iter = scheds.begin();\n-         iter != scheds.end(); iter++) {\n-        (*iter)->kill_all_tasks();\n-        (*iter)->deref();\n-    }\n-}\n-\n-rust_task_id\n-rust_kernel::generate_task_id() {\n-    rust_task_id id = sync::increment(max_task_id);\n-    assert(id != INTPTR_MAX && \"Hit the maximum task id\");\n-    return id;\n-}\n-\n-void\n-rust_kernel::set_exit_status(int code) {\n-    scoped_lock with(rval_lock);\n-    // If we've already failed then that's the code we're going to use\n-    if (rval != PROC_FAIL_CODE) {\n-        rval = code;\n-    }\n-}\n-\n-void\n-rust_kernel::inc_live_count() {\n-    uintptr_t new_non_weak_tasks = sync::increment(non_weak_tasks);\n-    KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n-}\n-\n-void\n-rust_kernel::dec_live_count() {\n-    uintptr_t new_non_weak_tasks = sync::decrement(non_weak_tasks);\n-    KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n-    if (new_non_weak_tasks == 0) {\n-        begin_shutdown();\n-    }\n-}\n-\n-void\n-rust_kernel::allow_scheduler_exit() {\n-    scoped_lock with(sched_lock);\n-\n-    KLOG_(\"Allowing main scheduler to exit\");\n-    // It's only the main schedulers left. Tell them to exit\n-    rust_scheduler *main_sched =\n-        get_scheduler_by_id_nolock(main_scheduler);\n-    assert(main_sched != NULL);\n-    main_sched->allow_exit();\n-\n-    KLOG_(\"Allowing osmain scheduler to exit\");\n-    rust_scheduler *osmain_sched =\n-        get_scheduler_by_id_nolock(osmain_scheduler);\n-    assert(osmain_sched != NULL);\n-    osmain_sched->allow_exit();\n-}\n-\n-void\n-rust_kernel::begin_shutdown() {\n-    {\n-        scoped_lock with(sched_lock);\n-        // FIXME #4410: This shouldn't be necessary, but because of\n-        // unweaken_task this may end up getting called multiple times.\n-        if (already_exiting) {\n-            return;\n-        } else {\n-            already_exiting = true;\n-        }\n-    }\n-\n-    allow_scheduler_exit();\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0fe3f7610403f776c7da2af200e8b5ffd82164c3", "filename": "src/rt/rust_kernel.h", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,167 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-/**\n-   A single runtime instance.\n-\n-   The kernel is primarily responsible for managing the lifetime of\n-   schedulers, which in turn run rust tasks. It provides a memory\n-   allocator and logging service for use by other runtime components,\n-   it creates unique task ids.\n-\n-   The kernel runs until there are no live schedulers.\n-\n-   The kernel internally runs an additional, special scheduler called\n-   the 'osmain' (or platform) scheduler, which schedules tasks on the\n-   thread that is running the kernel (normally the thread on which the\n-   C main function was called). This scheduler may be used by Rust\n-   code for interacting with platform APIs that insist on being called\n-   from the main thread.\n-\n-   The requirements of the osmain scheduler has resulted in a complex\n-   process for creating and running scheduler loops that involves\n-   a thing called a 'rust_sched_launcher_factory' whose function I've\n-   already forgotten. rust_scheduler is the main scheduler class,\n-   and tasks are scheduled on individual threads by rust_sched_loop.\n-\n-   Ideally all the in-memory Rust state is encapsulated by a kernel\n-   instance, but there is still some truly global data in the runtime\n-   (like the check claims flag).\n- */\n-\n-#ifndef RUST_KERNEL_H\n-#define RUST_KERNEL_H\n-\n-#include \"rust_globals.h\"\n-\n-#include <map>\n-#include <vector>\n-\n-#include \"rust_exchange_alloc.h\"\n-#include \"rust_log.h\"\n-#include \"rust_sched_reaper.h\"\n-#include \"rust_type.h\"\n-#include \"sync/lock_and_signal.h\"\n-\n-class rust_scheduler;\n-class rust_sched_driver;\n-class rust_sched_launcher_factory;\n-struct rust_task_thread;\n-\n-// Scheduler, task handles. These uniquely identify within a\n-// single kernel instance the objects they represent.\n-typedef intptr_t rust_sched_id;\n-typedef intptr_t rust_task_id;\n-\n-typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n-\n-class rust_kernel {\n-    rust_exchange_alloc exchange_alloc;\n-    rust_log _log;\n-\n-    // The next task id\n-    rust_task_id max_task_id;\n-\n-    lock_and_signal rval_lock;\n-    int rval;\n-\n-    // Protects max_sched_id and sched_table, join_list, killed,\n-    // already_exiting\n-    lock_and_signal sched_lock;\n-    // The next scheduler id\n-    rust_sched_id max_sched_id;\n-    // A map from scheduler ids to schedulers. When this is empty\n-    // the kernel terminates\n-    sched_map sched_table;\n-    // A list of scheduler ids that are ready to exit\n-    std::vector<rust_sched_id> join_list;\n-    // Whether or not the runtime has to die (triggered when the root/main\n-    // task group fails). This propagates to all new schedulers and tasks\n-    // created after it is set.\n-    bool killed;\n-    bool already_exiting;\n-\n-\n-    rust_sched_reaper sched_reaper;\n-\n-    // The primary scheduler\n-    rust_sched_id main_scheduler;\n-    // The single-threaded scheduler that uses the main thread\n-    rust_sched_id osmain_scheduler;\n-    // Runs the single-threaded scheduler that executes tasks\n-    // on the main thread\n-    rust_sched_driver *osmain_driver;\n-\n-    // An atomically updated count of the live, 'non-weak' tasks\n-    uintptr_t non_weak_tasks;\n-\n-    rust_scheduler* get_scheduler_by_id_nolock(rust_sched_id id);\n-    void allow_scheduler_exit();\n-    void begin_shutdown();\n-\n-public:\n-    struct rust_env *env;\n-\n-    rust_kernel(rust_env *env);\n-\n-    void log(uint32_t level, char const *fmt, ...);\n-    void fatal(char const *fmt, ...);\n-\n-    void *malloc(size_t size, const char *tag);\n-    void *realloc(void *mem, size_t size);\n-    void free(void *mem);\n-    rust_exchange_alloc *region() { return &exchange_alloc; }\n-\n-    void fail();\n-\n-    rust_sched_id create_scheduler(size_t num_threads);\n-    rust_sched_id create_scheduler(rust_sched_launcher_factory *launchfac,\n-                                   size_t num_threads, bool allow_exit);\n-    rust_scheduler* get_scheduler_by_id(rust_sched_id id);\n-    // Called by a scheduler to indicate that it is terminating\n-    void release_scheduler_id(rust_sched_id id);\n-    void wait_for_schedulers();\n-    int run();\n-\n-    rust_task_id generate_task_id();\n-\n-    void set_exit_status(int code);\n-\n-    rust_sched_id main_sched_id() { return main_scheduler; }\n-    rust_sched_id osmain_sched_id() { return osmain_scheduler; }\n-\n-    void inc_live_count();\n-    void dec_live_count();\n-\n-};\n-\n-template <typename T> struct kernel_owned {\n-    inline void *operator new(size_t size, rust_kernel *kernel,\n-                              const char *tag) {\n-        return kernel->malloc(size, tag);\n-    }\n-\n-    void operator delete(void *ptr) {\n-        ((T *)ptr)->kernel->free(ptr);\n-    }\n-};\n-\n-#endif /* RUST_KERNEL_H */\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "25b246c69f51a10a0877d9d72f0e781308f42495", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -17,161 +17,6 @@\n #include \"rust_crate_map.h\"\n #include \"util/array_list.h\"\n #include \"rust_util.h\"\n-#include \"rust_task.h\"\n-\n-/**\n- * Synchronizes access to the underlying logging mechanism.\n- */\n-static lock_and_signal _log_lock;\n-/**\n- * Indicates whether we are outputting to the console.\n- * Protected by _log_lock;\n- */\n-static bool _log_to_console = true;\n-\n-/*\n- * Request that console logging be turned on.\n- */\n-void\n-log_console_on() {\n-    scoped_lock with(_log_lock);\n-    _log_to_console = true;\n-}\n-\n-/*\n- * Request that console logging be turned off. Can be\n- * overridden by the environment.\n- */\n-void\n-log_console_off() {\n-    scoped_lock with(_log_lock);\n-    _log_to_console = false;\n-}\n-\n-bool\n-should_log_console() {\n-    scoped_lock with(_log_lock);\n-    return _log_to_console;\n-}\n-\n-rust_log::rust_log(rust_sched_loop *sched_loop) :\n-    _sched_loop(sched_loop) {\n-}\n-\n-rust_log::~rust_log() {\n-\n-}\n-\n-const uint16_t\n-hash(uintptr_t ptr) {\n-#   if(ULONG_MAX == 0xFFFFFFFF)\n-    // Robert Jenkins' 32 bit integer hash function\n-    ptr = (ptr + 0x7ed55d16) + (ptr << 12);\n-    ptr = (ptr ^ 0xc761c23c) ^ (ptr >> 19);\n-    ptr = (ptr + 0x165667b1) + (ptr << 5);\n-    ptr = (ptr + 0xd3a2646c) ^ (ptr << 9);\n-    ptr = (ptr + 0xfd7046c5) + (ptr << 3);\n-    ptr = (ptr ^ 0xb55a4f09) ^ (ptr >> 16);\n-#   elif(ULONG_MAX == 0xFFFFFFFFFFFFFFFF)\n-    // \"hash64shift()\" from http://www.concentric.net/~Ttwang/tech/inthash.htm\n-    ptr = (~ptr) + (ptr << 21); // ptr = (ptr << 21) - ptr - 1;\n-    ptr = ptr ^ (ptr >> 24);\n-    ptr = (ptr + (ptr << 3)) + (ptr << 8); // ptr * 265\n-    ptr = ptr ^ (ptr >> 14);\n-    ptr = (ptr + (ptr << 2)) + (ptr << 4); // ptr * 21\n-    ptr = ptr ^ (ptr >> 28);\n-    ptr = ptr + (ptr << 31);\n-#   else\n-#   error \"hash() not defined for this pointer size\"\n-#   endif\n-    return (uint16_t) ptr;\n-}\n-\n-char *\n-copy_string(char *dst, const char *src, size_t length) {\n-    return strncpy(dst, src, length) + length;\n-}\n-\n-char *\n-append_string(char *buffer, const char *format, ...) {\n-    if (buffer != NULL && format) {\n-        va_list args;\n-        va_start(args, format);\n-        size_t off = strlen(buffer);\n-        vsnprintf(buffer + off, BUF_BYTES - off, format, args);\n-        va_end(args);\n-    }\n-    return buffer;\n-}\n-\n-void\n-rust_log::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n-    char buf[BUF_BYTES];\n-    va_list args;\n-    va_start(args, fmt);\n-    int formattedbytes = vsnprintf(buf, sizeof(buf), fmt, args);\n-    if( formattedbytes and (unsigned)formattedbytes > BUF_BYTES ){\n-        const char truncatedstr[] = \"[...]\";\n-        memcpy( &buf[BUF_BYTES-sizeof(truncatedstr)],\n-                truncatedstr,\n-                sizeof(truncatedstr));\n-    }\n-    trace_ln(task, level, buf);\n-    va_end(args);\n-}\n-\n-void\n-rust_log::trace_ln(char *prefix, char *message) {\n-    char buffer[BUF_BYTES] = \"\";\n-    _log_lock.lock();\n-    append_string(buffer, \"%s\", prefix);\n-    append_string(buffer, \"%s\", message);\n-    if (_log_to_console) {\n-        fprintf(stderr, \"rust: %s\\n\", buffer);\n-        fflush(stderr);\n-    }\n-    _log_lock.unlock();\n-}\n-\n-void\n-rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n-\n-    if (task) {\n-        // There is not enough room to be logging on the rust stack\n-        assert(!task->on_rust_stack() && \"logging on rust stack\");\n-    }\n-\n-    // FIXME (#2672): The scheduler and task names used to have meaning,\n-    // but they are always equal to 'main' currently\n-#if 0\n-\n-#if defined(__WIN32__)\n-    uint32_t thread_id = 0;\n-#else\n-    uint32_t thread_id = hash((uintptr_t) pthread_self());\n-#endif\n-\n-    char prefix[BUF_BYTES] = \"\";\n-    if (_sched_loop && _sched_loop-.name) {\n-        append_string(prefix, \"%04\" PRIxPTR \":%.10s:\",\n-                      thread_id, _sched_loop->name);\n-    } else {\n-        append_string(prefix, \"%04\" PRIxPTR \":0x%08\" PRIxPTR \":\",\n-                      thread_id, (uintptr_t) _sched_loop);\n-    }\n-    if (task) {\n-        if (task->name) {\n-            append_string(prefix, \"%.10s:\", task->name);\n-        } else {\n-            append_string(prefix, \"0x%08\" PRIxPTR \":\", (uintptr_t) task);\n-        }\n-    }\n-#else\n-    char prefix[BUF_BYTES] = \"\";\n-#endif\n-\n-    trace_ln(prefix, message);\n-}\n \n // Reading log directives and setting log level vars\n "}, {"sha": "e3d61b8ab5d5a7c829ea5bcbcf5f2f622ec5f1f4", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -18,53 +18,6 @@ const uint32_t log_warn = 2;\n const uint32_t log_info = 3;\n const uint32_t log_debug = 4;\n \n-#define LOG(task, field, ...)                                   \\\n-    DLOG_LVL(log_debug, task, task->sched_loop, field, __VA_ARGS__)\n-#define LOG_ERR(task, field, ...)                               \\\n-    DLOG_LVL(log_err, task, task->sched_loop, field, __VA_ARGS__)\n-#define DLOG(sched_loop, field, ...)                                   \\\n-    DLOG_LVL(log_debug, NULL, sched_loop, field, __VA_ARGS__)\n-#define DLOG_ERR(sched_loop, field, ...)                               \\\n-    DLOG_LVL(log_err, NULL, sched_loop, field, __VA_ARGS__)\n-#define LOGPTR(sched_loop, msg, ptrval)                                \\\n-    DLOG_LVL(log_debug, NULL, sched_loop, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n-#define DLOG_LVL(lvl, task, sched_loop, field, ...)                    \\\n-    do {                                                        \\\n-        rust_sched_loop* _d_ = sched_loop;                      \\\n-        if (log_rt_##field >= lvl && _d_->log_lvl >= lvl) {     \\\n-            _d_->get_log().log(task, lvl, __VA_ARGS__);         \\\n-        }                                                       \\\n-    } while (0)\n-\n-#define KLOG(k, field, ...) \\\n-    KLOG_LVL(k, field, log_debug, __VA_ARGS__)\n-#define KLOG_LVL(k, field, lvl, ...)                          \\\n-    do {                                                      \\\n-        if (log_rt_##field >= lvl) {                          \\\n-            (k)->log(lvl, __VA_ARGS__);                       \\\n-        }                                                     \\\n-    } while (0)\n-\n-struct rust_sched_loop;\n-struct rust_task;\n-\n-class rust_log {\n-\n-public:\n-    rust_log(rust_sched_loop *sched_loop);\n-    virtual ~rust_log();\n-\n-    void log(rust_task* task, uint32_t level, char const *fmt, ...);\n-    void trace_ln(rust_task *task, uint32_t level, char *message);\n-    void trace_ln(char *prefix, char *message);\n-    bool is_tracing(uint32_t type_bits);\n-\n-private:\n-    rust_sched_loop *_sched_loop;\n-    bool _use_labels;\n-    void trace_ln(rust_task *task, char *message);\n-};\n-\n void update_log_settings(void* crate_map, char* settings);\n \n extern uint32_t log_rt_mem;"}, {"sha": "25cbaf822f04f80e98433fec9031eb06213fd31e", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#include \"rust_kernel.h\"\n+#include \"rust_globals.h\"\n \n #ifdef __APPLE__\n #include <crt_externs.h>"}, {"sha": "c8f59b11ff3ca5c79590aee117e683102e75f758", "filename": "src/rt/rust_sched_driver.cpp", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_driver.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_driver.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_driver.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_globals.h\"\n-#include \"rust_sched_driver.h\"\n-#include \"rust_sched_loop.h\"\n-\n-rust_sched_driver::rust_sched_driver(rust_sched_loop *sched_loop)\n-    : sched_loop(sched_loop),\n-      signalled(false) {\n-\n-    assert(sched_loop != NULL);\n-    sched_loop->on_pump_loop(this);\n-}\n-\n-/**\n- * Starts the main scheduler loop which performs task scheduling for this\n- * domain.\n- *\n- * Returns once no more tasks can be scheduled and all task ref_counts\n- * drop to zero.\n- */\n-void\n-rust_sched_driver::start_main_loop() {\n-    assert(sched_loop != NULL);\n-\n-#ifdef __APPLE__\n-    {\n-        char buf[64];\n-        snprintf(buf, sizeof(buf), \"scheduler loop %d\", sched_loop->get_id());\n-        // pthread_setname_np seems to have a different signature and\n-        // different behavior on different platforms. Thus, this is\n-        // only for Mac at the moment. There are equivalent versions\n-        // for Linux that we can add if needed.\n-        pthread_setname_np(buf);\n-    }\n-#endif\n-\n-    rust_sched_loop_state state = sched_loop_state_keep_going;\n-    while (state != sched_loop_state_exit) {\n-        DLOG(sched_loop, dom, \"pumping scheduler\");\n-        state = sched_loop->run_single_turn();\n-\n-        if (state == sched_loop_state_block) {\n-            scoped_lock with(lock);\n-            if (!signalled) {\n-                DLOG(sched_loop, dom, \"blocking scheduler\");\n-                lock.wait();\n-            }\n-            signalled = false;\n-        }\n-    }\n-}\n-\n-void\n-rust_sched_driver::signal() {\n-    scoped_lock with(lock);\n-    signalled = true;\n-    lock.signal();\n-}"}, {"sha": "9824c5ee3d21f01ff319056ca642914b3731c0c2", "filename": "src/rt/rust_sched_driver.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_driver.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_driver.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_driver.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_SCHED_DRIVER_H\n-#define RUST_SCHED_DRIVER_H\n-\n-#include \"sync/lock_and_signal.h\"\n-#include \"rust_signal.h\"\n-\n-struct rust_sched_loop;\n-\n-class rust_sched_driver : public rust_signal {\n-private:\n-    rust_sched_loop *sched_loop;\n-    lock_and_signal lock;\n-    bool signalled;\n-\n-public:\n-    rust_sched_driver(rust_sched_loop *sched_loop);\n-\n-    void start_main_loop();\n-\n-    virtual void signal();\n-};\n-\n-#endif /* RUST_SCHED_DRIVER_H */"}, {"sha": "a95145343d4145ea30fdfc92e848aa49d2dfc0fa", "filename": "src/rt/rust_sched_launcher.cpp", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_launcher.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_launcher.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_sched_launcher.h\"\n-#include \"rust_scheduler.h\"\n-\n-const size_t SCHED_STACK_SIZE = 1024*100;\n-\n-rust_sched_launcher::rust_sched_launcher(rust_scheduler *sched, int id,\n-                                         bool killed)\n-    : kernel(sched->kernel),\n-      sched_loop(sched, id, killed),\n-      driver(&sched_loop) {\n-}\n-\n-rust_thread_sched_launcher::rust_thread_sched_launcher(rust_scheduler *sched,\n-                                                       int id, bool killed)\n-    : rust_sched_launcher(sched, id, killed),\n-      rust_thread(SCHED_STACK_SIZE) {\n-}\n-\n-rust_manual_sched_launcher::rust_manual_sched_launcher(rust_scheduler *sched,\n-                                                       int id, bool killed)\n-    : rust_sched_launcher(sched, id, killed) {\n-}\n-\n-rust_sched_launcher *\n-rust_thread_sched_launcher_factory::create(rust_scheduler *sched, int id,\n-                                           bool killed) {\n-    return new(sched->kernel, \"rust_thread_sched_launcher\")\n-        rust_thread_sched_launcher(sched, id, killed);\n-}\n-\n-rust_sched_launcher *\n-rust_manual_sched_launcher_factory::create(rust_scheduler *sched, int id,\n-                                           bool killed) {\n-    assert(launcher == NULL && \"I can only track one sched_launcher\");\n-    launcher = new(sched->kernel, \"rust_manual_sched_launcher\")\n-        rust_manual_sched_launcher(sched, id, killed);\n-    return launcher;\n-}"}, {"sha": "a981fad24f85a506251d609051ecc40d4b1746ae", "filename": "src/rt/rust_sched_launcher.h", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_launcher.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_launcher.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_SCHED_LAUNCHER_H\n-#define RUST_SCHED_LAUNCHER_H\n-\n-#include \"sync/rust_thread.h\"\n-#include \"rust_sched_driver.h\"\n-#include \"rust_kernel.h\"\n-#include \"rust_sched_loop.h\"\n-\n-class rust_sched_launcher : public kernel_owned<rust_sched_launcher> {\n-public:\n-    rust_kernel *kernel;\n-\n-private:\n-    rust_sched_loop sched_loop;\n-\n-private:\n-    // private and undefined to disable copying\n-    rust_sched_launcher(const rust_sched_launcher& rhs);\n-    rust_sched_launcher& operator=(const rust_sched_launcher& rhs);\n-\n-protected:\n-    rust_sched_driver driver;\n-\n-public:\n-    rust_sched_launcher(rust_scheduler *sched, int id, bool killed);\n-    virtual ~rust_sched_launcher() { }\n-\n-    virtual void start() = 0;\n-    virtual void join() = 0;\n-    rust_sched_loop *get_loop() { return &sched_loop; }\n-};\n-\n-class rust_thread_sched_launcher\n-  :public rust_sched_launcher,\n-   private rust_thread {\n-public:\n-    rust_thread_sched_launcher(rust_scheduler *sched, int id, bool killed);\n-    virtual void start() { rust_thread::start(); }\n-    virtual void join() { rust_thread::join(); }\n-    virtual void run() { driver.start_main_loop(); }\n-};\n-\n-class rust_manual_sched_launcher : public rust_sched_launcher {\n-public:\n-    rust_manual_sched_launcher(rust_scheduler *sched, int id, bool killed);\n-    virtual void start() { }\n-    virtual void join() { }\n-    rust_sched_driver *get_driver() { return &driver; };\n-};\n-\n-class rust_sched_launcher_factory {\n-public:\n-    virtual ~rust_sched_launcher_factory() { }\n-    virtual rust_sched_launcher *\n-    create(rust_scheduler *sched, int id, bool killed) = 0;\n-};\n-\n-class rust_thread_sched_launcher_factory\n-    : public rust_sched_launcher_factory {\n-public:\n-    virtual rust_sched_launcher *create(rust_scheduler *sched, int id,\n-                                        bool killed);\n-};\n-\n-class rust_manual_sched_launcher_factory\n-    : public rust_sched_launcher_factory {\n-private:\n-    rust_manual_sched_launcher *launcher;\n-public:\n-    rust_manual_sched_launcher_factory() : launcher(NULL) { }\n-    virtual rust_sched_launcher *create(rust_scheduler *sched, int id,\n-                                        bool killed);\n-    rust_sched_driver *get_driver() {\n-        assert(launcher != NULL);\n-        return launcher->get_driver();\n-    }\n-};\n-\n-#endif // RUST_SCHED_LAUNCHER_H"}, {"sha": "1f718df32aac9bebf5cbc3d71f4742d4441402f6", "filename": "src/rt/rust_sched_loop.cpp", "status": "removed", "additions": 0, "deletions": 431, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,431 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_sched_loop.h\"\n-#include \"rust_util.h\"\n-#include \"rust_scheduler.h\"\n-\n-#ifndef _WIN32\n-pthread_key_t rust_sched_loop::task_key;\n-#else\n-DWORD rust_sched_loop::task_key;\n-#endif\n-\n-const size_t C_STACK_SIZE = 2*1024*1024;\n-\n-bool rust_sched_loop::tls_initialized = false;\n-\n-rust_sched_loop::rust_sched_loop(rust_scheduler *sched, int id, bool killed) :\n-    _log(this),\n-    id(id),\n-    should_exit(false),\n-    cached_c_stack(NULL),\n-    extra_c_stack(NULL),\n-    cached_big_stack(NULL),\n-    extra_big_stack(NULL),\n-    dead_task(NULL),\n-    killed(killed),\n-    pump_signal(NULL),\n-    kernel(sched->kernel),\n-    sched(sched),\n-    log_lvl(log_debug),\n-    min_stack_size(kernel->env->min_stack_size),\n-    local_region(false, kernel->env->detailed_leaks, kernel->env->poison_on_free),\n-    // FIXME #2891: calculate a per-scheduler name.\n-    name(\"main\")\n-{\n-    LOGPTR(this, \"new dom\", (uintptr_t)this);\n-    rng_init(&rng, kernel->env->rust_seed, NULL, 0);\n-\n-    if (!tls_initialized)\n-        init_tls();\n-}\n-\n-void\n-rust_sched_loop::activate(rust_task *task) {\n-    lock.must_have_lock();\n-    task->ctx.next = &c_context;\n-    DLOG(this, task, \"descheduling...\");\n-    lock.unlock();\n-    prepare_c_stack(task);\n-    task->ctx.swap(c_context);\n-    task->cleanup_after_turn();\n-    unprepare_c_stack();\n-    lock.lock();\n-    DLOG(this, task, \"task has returned\");\n-}\n-\n-\n-void\n-rust_sched_loop::fail() {\n-    _log.log(NULL, log_err, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n-        name, this);\n-    kernel->fail();\n-}\n-\n-void\n-rust_sched_loop::kill_all_tasks() {\n-    std::vector<rust_task*> all_tasks;\n-\n-    {\n-        scoped_lock with(lock);\n-        // Any task created after this will be killed. See transition, below.\n-        killed = true;\n-\n-        for (size_t i = 0; i < running_tasks.length(); i++) {\n-            rust_task *t = running_tasks[i];\n-            t->ref();\n-            all_tasks.push_back(t);\n-        }\n-\n-        for (size_t i = 0; i < blocked_tasks.length(); i++) {\n-            rust_task *t = blocked_tasks[i];\n-            t->ref();\n-            all_tasks.push_back(t);\n-        }\n-    }\n-\n-    while (!all_tasks.empty()) {\n-        rust_task *task = all_tasks.back();\n-        all_tasks.pop_back();\n-        task->kill();\n-        task->deref();\n-    }\n-}\n-\n-size_t\n-rust_sched_loop::number_of_live_tasks() {\n-    lock.must_have_lock();\n-    return running_tasks.length() + blocked_tasks.length();\n-}\n-\n-/**\n- * Delete any dead tasks.\n- */\n-void\n-rust_sched_loop::reap_dead_tasks() {\n-    lock.must_have_lock();\n-\n-    if (dead_task == NULL) {\n-        return;\n-    }\n-\n-    // Dereferencing the task will probably cause it to be released\n-    // from the scheduler, which may end up trying to take this lock\n-    lock.unlock();\n-\n-    dead_task->delete_all_stacks();\n-    // Deref the task, which may cause it to request us to release it\n-    dead_task->deref();\n-    dead_task = NULL;\n-\n-    lock.lock();\n-}\n-\n-void\n-rust_sched_loop::release_task(rust_task *task) {\n-    // Nobody should have a ref to the task at this point\n-    assert(task->get_ref_count() == 0);\n-    // Now delete the task, which will require using this thread's\n-    // memory region.\n-    delete task;\n-    // Now release the task from the scheduler, which may trigger this\n-    // thread to exit\n-    sched->release_task();\n-}\n-\n-/**\n- * Schedules a running task for execution. Only running tasks can be\n- * activated.  Blocked tasks have to be unblocked before they can be\n- * activated.\n- *\n- * Returns NULL if no tasks can be scheduled.\n- */\n-rust_task *\n-rust_sched_loop::schedule_task() {\n-    lock.must_have_lock();\n-    size_t tasks = running_tasks.length();\n-    if (tasks > 0) {\n-        size_t i = (tasks > 1) ? (rng_gen_u32(&rng) % tasks) : 0;\n-        return running_tasks[i];\n-    }\n-    return NULL;\n-}\n-\n-void\n-rust_sched_loop::log_state() {\n-    if (log_rt_task < log_debug) return;\n-\n-    if (!running_tasks.is_empty()) {\n-        _log.log(NULL, log_debug, \"running tasks:\");\n-        for (size_t i = 0; i < running_tasks.length(); i++) {\n-            _log.log(NULL, log_debug, \"\\t task: %s @0x%\" PRIxPTR,\n-                running_tasks[i]->name,\n-                running_tasks[i]);\n-        }\n-    }\n-\n-    if (!blocked_tasks.is_empty()) {\n-        _log.log(NULL, log_debug, \"blocked tasks:\");\n-        for (size_t i = 0; i < blocked_tasks.length(); i++) {\n-            _log.log(NULL, log_debug, \"\\t task: %s @0x%\" PRIxPTR\n-                \", blocked on: 0x%\" PRIxPTR \" '%s'\",\n-                blocked_tasks[i]->name, blocked_tasks[i],\n-                blocked_tasks[i]->get_cond(),\n-                blocked_tasks[i]->get_cond_name());\n-        }\n-    }\n-}\n-\n-void\n-rust_sched_loop::on_pump_loop(rust_signal *signal) {\n-    assert(pump_signal == NULL);\n-    assert(signal != NULL);\n-    pump_signal = signal;\n-}\n-\n-void\n-rust_sched_loop::pump_loop() {\n-    assert(pump_signal != NULL);\n-    pump_signal->signal();\n-}\n-\n-rust_sched_loop_state\n-rust_sched_loop::run_single_turn() {\n-    DLOG(this, task,\n-         \"scheduler %d resuming ...\", id);\n-\n-    lock.lock();\n-\n-    if (!should_exit) {\n-        assert(dead_task == NULL && \"Tasks should only die after running\");\n-\n-        DLOG(this, dom, \"worker %d, number_of_live_tasks = %d\",\n-             id, number_of_live_tasks());\n-\n-        rust_task *scheduled_task = schedule_task();\n-\n-        if (scheduled_task == NULL) {\n-            log_state();\n-            DLOG(this, task,\n-                 \"all tasks are blocked, scheduler id %d yielding ...\",\n-                 id);\n-\n-            lock.unlock();\n-            return sched_loop_state_block;\n-        }\n-\n-        scheduled_task->assert_is_running();\n-\n-        DLOG(this, task,\n-             \"activating task %s 0x%\" PRIxPTR\n-             \", state: %s\",\n-             scheduled_task->name,\n-             (uintptr_t)scheduled_task,\n-             state_name(scheduled_task->get_state()));\n-\n-        place_task_in_tls(scheduled_task);\n-\n-        DLOG(this, task,\n-             \"Running task %p on worker %d\",\n-             scheduled_task, id);\n-        activate(scheduled_task);\n-\n-        DLOG(this, task,\n-             \"returned from task %s @0x%\" PRIxPTR\n-             \" in state '%s', worker id=%d\" PRIxPTR,\n-             scheduled_task->name,\n-             (uintptr_t)scheduled_task,\n-             state_name(scheduled_task->get_state()),\n-             id);\n-\n-        reap_dead_tasks();\n-\n-        lock.unlock();\n-        return sched_loop_state_keep_going;\n-    } else {\n-        assert(running_tasks.is_empty() && \"Should have no running tasks\");\n-        assert(blocked_tasks.is_empty() && \"Should have no blocked tasks\");\n-        assert(dead_task == NULL && \"Should have no dead tasks\");\n-\n-        DLOG(this, dom, \"finished main-loop %d\", id);\n-\n-        lock.unlock();\n-\n-        assert(!extra_c_stack);\n-        if (cached_c_stack) {\n-            destroy_exchange_stack(kernel->region(), cached_c_stack);\n-            cached_c_stack = NULL;\n-        }\n-        assert(!extra_big_stack);\n-        if (cached_big_stack) {\n-            destroy_exchange_stack(kernel->region(), cached_big_stack);\n-            cached_big_stack = NULL;\n-        }\n-\n-        sched->release_task_thread();\n-        return sched_loop_state_exit;\n-    }\n-}\n-\n-rust_task *\n-rust_sched_loop::create_task(rust_task *spawner, const char *name) {\n-    rust_task *task =\n-        new (this->kernel, \"rust_task\")\n-        rust_task(this, task_state_newborn,\n-                  name, kernel->env->min_stack_size);\n-    DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n-                        task, spawner ? spawner->name : \"(none)\", name);\n-\n-    task->id = kernel->generate_task_id();\n-    return task;\n-}\n-\n-rust_task_list *\n-rust_sched_loop::state_list(rust_task_state state) {\n-    switch (state) {\n-    case task_state_running:\n-        return &running_tasks;\n-    case task_state_blocked:\n-        return &blocked_tasks;\n-    default:\n-        return NULL;\n-    }\n-}\n-\n-const char *\n-rust_sched_loop::state_name(rust_task_state state) {\n-    switch (state) {\n-    case task_state_newborn:\n-        return \"newborn\";\n-    case task_state_running:\n-        return \"running\";\n-    case task_state_blocked:\n-        return \"blocked\";\n-    case task_state_dead:\n-        return \"dead\";\n-    default:\n-        assert(false);\n-        return \"\";\n-    }\n-}\n-\n-void\n-rust_sched_loop::transition(rust_task *task,\n-                             rust_task_state src, rust_task_state dst,\n-                             rust_cond *cond, const char* cond_name) {\n-    scoped_lock with(lock);\n-    DLOG(this, task,\n-         \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n-         name, (uintptr_t)this, state_name(src), state_name(dst),\n-         state_name(task->get_state()));\n-    assert(task->get_state() == src);\n-    rust_task_list *src_list = state_list(src);\n-    if (src_list) {\n-        src_list->remove(task);\n-    }\n-    rust_task_list *dst_list = state_list(dst);\n-    if (dst_list) {\n-        dst_list->append(task);\n-    }\n-    if (dst == task_state_dead) {\n-        assert(dead_task == NULL);\n-        dead_task = task;\n-    }\n-    task->set_state(dst, cond, cond_name);\n-\n-    // If the entire runtime is failing, newborn tasks must be doomed.\n-    if (src == task_state_newborn && killed) {\n-        task->kill_inner();\n-    }\n-\n-    pump_loop();\n-}\n-\n-#ifndef _WIN32\n-void\n-rust_sched_loop::init_tls() {\n-    int result = pthread_key_create(&task_key, NULL);\n-    assert(!result && \"Couldn't create the TLS key!\");\n-    tls_initialized = true;\n-}\n-\n-void\n-rust_sched_loop::place_task_in_tls(rust_task *task) {\n-    int result = pthread_setspecific(task_key, task);\n-    assert(!result && \"Couldn't place the task in TLS!\");\n-    task->record_stack_limit();\n-}\n-#else\n-void\n-rust_sched_loop::init_tls() {\n-    task_key = TlsAlloc();\n-    assert(task_key != TLS_OUT_OF_INDEXES && \"Couldn't create the TLS key!\");\n-    tls_initialized = true;\n-}\n-\n-void\n-rust_sched_loop::place_task_in_tls(rust_task *task) {\n-    BOOL result = TlsSetValue(task_key, task);\n-    assert(result && \"Couldn't place the task in TLS!\");\n-    task->record_stack_limit();\n-}\n-#endif\n-\n-void\n-rust_sched_loop::exit() {\n-    scoped_lock with(lock);\n-    DLOG(this, dom, \"Requesting exit for thread %d\", id);\n-    should_exit = true;\n-    pump_loop();\n-}\n-\n-// Before activating each task, make sure we have a C stack available.\n-// It needs to be allocated ahead of time (while we're on our own\n-// stack), because once we're on the Rust stack we won't have enough\n-// room to do the allocation\n-void\n-rust_sched_loop::prepare_c_stack(rust_task *task) {\n-    assert(!extra_c_stack);\n-    if (!cached_c_stack && !task->have_c_stack()) {\n-        cached_c_stack = create_exchange_stack(kernel->region(),\n-                                               C_STACK_SIZE);\n-    }\n-    assert(!extra_big_stack);\n-    if (!cached_big_stack) {\n-        cached_big_stack = create_exchange_stack(kernel->region(),\n-                                                 C_STACK_SIZE +\n-                                                 (C_STACK_SIZE * 2));\n-        cached_big_stack->is_big = 1;\n-    }\n-}\n-\n-void\n-rust_sched_loop::unprepare_c_stack() {\n-    if (extra_c_stack) {\n-        destroy_exchange_stack(kernel->region(), extra_c_stack);\n-        extra_c_stack = NULL;\n-    }\n-    if (extra_big_stack) {\n-        destroy_exchange_stack(kernel->region(), extra_big_stack);\n-        extra_big_stack = NULL;\n-    }\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 70;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "e0101c46fb9903cf3509d7eab88fa52832cbf65f", "filename": "src/rt/rust_sched_loop.h", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,252 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_SCHED_LOOP_H\n-#define RUST_SCHED_LOOP_H\n-\n-#include \"rust_globals.h\"\n-#include \"rust_log.h\"\n-#include \"rust_rng.h\"\n-#include \"rust_stack.h\"\n-#include \"rust_signal.h\"\n-#include \"context.h\"\n-#include \"util/indexed_list.h\"\n-\n-enum rust_task_state {\n-    task_state_newborn,\n-    task_state_running,\n-    task_state_blocked,\n-    task_state_dead\n-};\n-\n-/*\n-The result of every turn of the scheduler loop. Instructs the loop\n-driver how to proceed.\n- */\n-enum rust_sched_loop_state {\n-    sched_loop_state_keep_going,\n-    sched_loop_state_block,\n-    sched_loop_state_exit\n-};\n-\n-class rust_kernel;\n-class rust_scheduler;\n-struct rust_task;\n-\n-typedef indexed_list<rust_task> rust_task_list;\n-\n-struct rust_sched_loop\n-{\n-private:\n-\n-    lock_and_signal lock;\n-\n-    // Fields known only by the runtime:\n-    rust_log _log;\n-\n-    const int id;\n-\n-    static bool tls_initialized;\n-\n-#ifndef __WIN32__\n-    static pthread_key_t task_key;\n-#else\n-    static DWORD task_key;\n-#endif\n-\n-    context c_context;\n-    rust_rng rng;\n-    bool should_exit;\n-\n-    stk_seg *cached_c_stack;\n-    stk_seg *extra_c_stack;\n-    stk_seg *cached_big_stack;\n-    stk_seg *extra_big_stack;\n-\n-    rust_task_list running_tasks;\n-    rust_task_list blocked_tasks;\n-    rust_task *dead_task;\n-    bool killed;\n-\n-    rust_signal *pump_signal;\n-\n-    void prepare_c_stack(rust_task *task);\n-    void unprepare_c_stack();\n-\n-    rust_task_list *state_list(rust_task_state state);\n-    const char *state_name(rust_task_state state);\n-\n-    void pump_loop();\n-\n-private:\n-    // private and undefined to disable copying\n-    rust_sched_loop(const rust_sched_loop& rhs);\n-    rust_sched_loop& operator=(const rust_sched_loop& rhs);\n-\n-public:\n-    rust_kernel *kernel;\n-    rust_scheduler *sched;\n-\n-    // NB: this is used to filter *runtime-originating* debug\n-    // logging, on a per-scheduler basis. It's not likely what\n-    // you want to expose to the user in terms of per-task\n-    // or per-module logging control. By default all schedulers\n-    // are set to debug-level logging here, and filtered by\n-    // runtime category using the pseudo-modules ::rt::foo.\n-    uint32_t log_lvl;\n-\n-    size_t min_stack_size;\n-    memory_region local_region;\n-\n-    const char *const name; // Used for debugging\n-\n-    // Only a pointer to 'name' is kept, so it must live as long as this\n-    // domain.\n-    rust_sched_loop(rust_scheduler *sched, int id, bool killed);\n-    void activate(rust_task *task);\n-    rust_log & get_log();\n-    void fail();\n-\n-    size_t number_of_live_tasks();\n-\n-    void reap_dead_tasks();\n-    rust_task *schedule_task();\n-\n-    void on_pump_loop(rust_signal *signal);\n-    rust_sched_loop_state run_single_turn();\n-\n-    void log_state();\n-\n-    void kill_all_tasks();\n-    bool doomed();\n-\n-    rust_task *create_task(rust_task *spawner, const char *name);\n-\n-    void transition(rust_task *task,\n-                    rust_task_state src, rust_task_state dst,\n-                    rust_cond *cond, const char* cond_name);\n-\n-    void init_tls();\n-    void place_task_in_tls(rust_task *task);\n-\n-    static rust_task *get_task_tls();\n-    static rust_task *try_get_task_tls();\n-\n-    // Called by each task when they are ready to be destroyed\n-    void release_task(rust_task *task);\n-\n-    // Tells the scheduler to exit it's scheduling loop and thread\n-    void exit();\n-\n-    // Called by tasks when they need a stack on which to run C code\n-    stk_seg *borrow_c_stack();\n-    void return_c_stack(stk_seg *stack);\n-\n-    // Called by tasks when they need a big stack\n-    stk_seg *borrow_big_stack();\n-    void return_big_stack(stk_seg *stack);\n-\n-    int get_id() { return this->id; }\n-};\n-\n-inline rust_log &\n-rust_sched_loop::get_log() {\n-    return _log;\n-}\n-\n-inline rust_task* rust_sched_loop::try_get_task_tls()\n-{\n-    if (!tls_initialized)\n-        return NULL;\n-#ifdef __WIN32__\n-    rust_task *task = reinterpret_cast<rust_task *>\n-        (TlsGetValue(task_key));\n-#else\n-    rust_task *task = reinterpret_cast<rust_task *>\n-        (pthread_getspecific(task_key));\n-#endif\n-    return task;\n-}\n-\n-inline rust_task* rust_sched_loop::get_task_tls()\n-{\n-    rust_task *task = try_get_task_tls();\n-    assert(task && \"Couldn't get the task from TLS!\");\n-    return task;\n-}\n-\n-// NB: Runs on the Rust stack\n-inline stk_seg *\n-rust_sched_loop::borrow_c_stack() {\n-    assert(cached_c_stack);\n-    stk_seg *your_stack;\n-    if (extra_c_stack) {\n-        your_stack = extra_c_stack;\n-        extra_c_stack = NULL;\n-    } else {\n-        your_stack = cached_c_stack;\n-        cached_c_stack = NULL;\n-    }\n-    return your_stack;\n-}\n-\n-// NB: Runs on the Rust stack\n-inline void\n-rust_sched_loop::return_c_stack(stk_seg *stack) {\n-    assert(!extra_c_stack);\n-    if (!cached_c_stack) {\n-        cached_c_stack = stack;\n-    } else {\n-        extra_c_stack = stack;\n-    }\n-}\n-\n-// NB: Runs on the Rust stack. Might return NULL!\n-inline stk_seg *\n-rust_sched_loop::borrow_big_stack() {\n-    stk_seg *your_stack;\n-    if (extra_big_stack) {\n-        your_stack = extra_big_stack;\n-        extra_big_stack = NULL;\n-    } else {\n-        // NB: This may be null if we're asking for a *second*\n-        // big stack, in which case the caller will fall back to a slow path\n-        your_stack = cached_big_stack;\n-        cached_big_stack = NULL;\n-    }\n-    return your_stack;\n-}\n-\n-// NB: Runs on the Rust stack\n-inline void\n-rust_sched_loop::return_big_stack(stk_seg *stack) {\n-    assert(!extra_big_stack);\n-    assert(stack);\n-    if (!cached_big_stack)\n-        cached_big_stack = stack;\n-    else\n-        extra_big_stack = stack;\n-}\n-\n-// this is needed to appease the circular dependency gods\n-#include \"rust_task.h\"\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//\n-\n-#endif /* RUST_SCHED_LOOP_H */"}, {"sha": "1aef9cd5588b88b7311357f217eff45d70c3ca2b", "filename": "src/rt/rust_sched_reaper.cpp", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_reaper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_reaper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_reaper.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_kernel.h\"\n-#include \"rust_sched_reaper.h\"\n-\n-// NB: We're using a very small stack here\n-const size_t STACK_SIZE = 1024*20;\n-\n-rust_sched_reaper::rust_sched_reaper(rust_kernel *kernel)\n-    : rust_thread(STACK_SIZE), kernel(kernel) {\n-}\n-\n-void\n-rust_sched_reaper::run() {\n-    kernel->wait_for_schedulers();\n-}"}, {"sha": "75a8d18c0abcebdc6b68bc48df980bb450afdfc5", "filename": "src/rt/rust_sched_reaper.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_reaper.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_sched_reaper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_reaper.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_SCHED_REAPER_H\n-#define RUST_SCHED_REAPER_H\n-\n-#include \"sync/rust_thread.h\"\n-\n-class rust_kernel;\n-\n-/* Responsible for joining with rust_schedulers */\n-class rust_sched_reaper : public rust_thread {\n-private:\n-    rust_kernel *kernel;\n-public:\n-    rust_sched_reaper(rust_kernel *kernel);\n-    virtual void run();\n-};\n-\n-#endif /* RUST_SCHED_REAPER_H */"}, {"sha": "e3a5d9db91ffa628234c038431f7dd031d1d28bf", "filename": "src/rt/rust_scheduler.cpp", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,203 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_globals.h\"\n-#include \"rust_scheduler.h\"\n-#include \"rust_task.h\"\n-#include \"rust_util.h\"\n-#include \"rust_sched_launcher.h\"\n-\n-rust_scheduler::rust_scheduler(rust_kernel *kernel,\n-                               size_t max_num_threads,\n-                               rust_sched_id id,\n-                               bool allow_exit,\n-                               bool killed,\n-                               rust_sched_launcher_factory *launchfac) :\n-    ref_count(1),\n-    kernel(kernel),\n-    live_threads(0),\n-    live_tasks(0),\n-    cur_thread(0),\n-    may_exit(allow_exit),\n-    killed(killed),\n-    launchfac(launchfac),\n-    max_num_threads(max_num_threads),\n-    id(id)\n-{\n-    // Create the first thread\n-    scoped_lock with(lock);\n-    threads.push(create_task_thread(0));\n-}\n-\n-void rust_scheduler::delete_this() {\n-    destroy_task_threads();\n-    delete launchfac;\n-    delete this;\n-}\n-\n-rust_sched_launcher *\n-rust_scheduler::create_task_thread(int id) {\n-    lock.must_have_lock();\n-    live_threads++;\n-    rust_sched_launcher *thread = launchfac->create(this, id, killed);\n-    KLOG(kernel, kern, \"created task thread: \" PTR\n-         \", id: %d, live_threads: %d\",\n-         thread, id, live_threads);\n-    return thread;\n-}\n-\n-void\n-rust_scheduler::destroy_task_thread(rust_sched_launcher *thread) {\n-    KLOG(kernel, kern, \"deleting task thread: \" PTR, thread);\n-    delete thread;\n-}\n-\n-void\n-rust_scheduler::destroy_task_threads() {\n-    scoped_lock with(lock);\n-    for(size_t i = 0; i < threads.size(); ++i) {\n-        destroy_task_thread(threads[i]);\n-    }\n-}\n-\n-void\n-rust_scheduler::start_task_threads()\n-{\n-    scoped_lock with(lock);\n-    for(size_t i = 0; i < threads.size(); ++i) {\n-        rust_sched_launcher *thread = threads[i];\n-        thread->start();\n-    }\n-}\n-\n-void\n-rust_scheduler::join_task_threads()\n-{\n-    scoped_lock with(lock);\n-    for(size_t i = 0; i < threads.size(); ++i) {\n-        rust_sched_launcher *thread = threads[i];\n-        thread->join();\n-    }\n-}\n-\n-void\n-rust_scheduler::kill_all_tasks() {\n-    array_list<rust_sched_launcher *> copied_threads;\n-    {\n-        scoped_lock with(lock);\n-        killed = true;\n-        for (size_t i = 0; i < threads.size(); ++i) {\n-            copied_threads.push(threads[i]);\n-        }\n-    }\n-    for(size_t i = 0; i < copied_threads.size(); ++i) {\n-        rust_sched_launcher *thread = copied_threads[i];\n-        thread->get_loop()->kill_all_tasks();\n-    }\n-}\n-\n-rust_task *\n-rust_scheduler::create_task(rust_task *spawner, const char *name) {\n-    size_t thread_no;\n-    {\n-        scoped_lock with(lock);\n-        live_tasks++;\n-\n-        if (cur_thread < threads.size()) {\n-            thread_no = cur_thread;\n-        } else {\n-            assert(threads.size() < max_num_threads);\n-            thread_no = threads.size();\n-            rust_sched_launcher *thread = create_task_thread(thread_no);\n-            thread->start();\n-            threads.push(thread);\n-        }\n-        cur_thread = (thread_no + 1) % max_num_threads;\n-    }\n-    KLOG(kernel, kern, \"Creating task %s, on thread %d.\", name, thread_no);\n-    kernel->inc_live_count();\n-    rust_sched_launcher *thread = threads[thread_no];\n-    return thread->get_loop()->create_task(spawner, name);\n-}\n-\n-void\n-rust_scheduler::release_task() {\n-    bool need_exit = false;\n-    {\n-        scoped_lock with(lock);\n-        live_tasks--;\n-        if (live_tasks == 0 && may_exit) {\n-            need_exit = true;\n-        }\n-    }\n-    kernel->dec_live_count();\n-    if (need_exit) {\n-        exit();\n-    }\n-}\n-\n-void\n-rust_scheduler::exit() {\n-    // Take a copy of the number of threads. After the last thread exits this\n-    // scheduler will get destroyed, and our fields will cease to exist.\n-    //\n-    // This is also the reason we can't use the lock here (as in the other\n-    // cases when accessing `threads`), after the loop the lock won't exist\n-    // anymore. This is safe because this method is only called when all the\n-    // task are dead, so there is no chance of a task trying to create new\n-    // threads.\n-    size_t current_num_threads = threads.size();\n-    for(size_t i = 0; i < current_num_threads; ++i) {\n-        threads[i]->get_loop()->exit();\n-    }\n-}\n-\n-size_t\n-rust_scheduler::max_number_of_threads() {\n-    return max_num_threads;\n-}\n-\n-size_t\n-rust_scheduler::number_of_threads() {\n-    scoped_lock with(lock);\n-    return threads.size();\n-}\n-\n-void\n-rust_scheduler::release_task_thread() {\n-    uintptr_t new_live_threads;\n-    {\n-        scoped_lock with(lock);\n-        new_live_threads = --live_threads;\n-    }\n-    if (new_live_threads == 0) {\n-        kernel->release_scheduler_id(id);\n-    }\n-}\n-\n-void\n-rust_scheduler::allow_exit() {\n-    bool need_exit = false;\n-    {\n-        scoped_lock with(lock);\n-        may_exit = true;\n-        need_exit = live_tasks == 0;\n-    }\n-    if (need_exit) {\n-        exit();\n-    }\n-}\n-\n-void\n-rust_scheduler::disallow_exit() {\n-    scoped_lock with(lock);\n-    may_exit = false;\n-}"}, {"sha": "30e0626ddd3762c068a9d96ad2bdb44ae52251ad", "filename": "src/rt/rust_scheduler.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/**\n-   The rust scheduler. Schedulers may be added to the kernel\n-   dynamically and they run until there are no more tasks to\n-   schedule. Most of the scheduler work is carried out in worker\n-   threads by rust_sched_loop.\n- */\n-\n-#ifndef RUST_SCHEDULER_H\n-#define RUST_SCHEDULER_H\n-\n-#include \"rust_globals.h\"\n-#include \"util/array_list.h\"\n-#include \"rust_kernel.h\"\n-#include \"rust_refcount.h\"\n-\n-class rust_sched_launcher;\n-class rust_sched_launcher_factory;\n-\n-class rust_scheduler : public kernel_owned<rust_scheduler> {\n-    RUST_ATOMIC_REFCOUNT();\n-    // FIXME (#2693): Make these private\n-public:\n-    rust_kernel *kernel;\n-private:\n-    // Protects live_threads, live_tasks, cur_thread, may_exit\n-    lock_and_signal lock;\n-    // When this hits zero we'll tell the kernel to release us\n-    uintptr_t live_threads;\n-    // When this hits zero we'll tell the threads to exit\n-    uintptr_t live_tasks;\n-    size_t cur_thread;\n-    bool may_exit;\n-    bool killed;\n-\n-    rust_sched_launcher_factory *launchfac;\n-    array_list<rust_sched_launcher *> threads;\n-    const size_t max_num_threads;\n-\n-    rust_sched_id id;\n-\n-    void destroy_task_threads();\n-\n-    rust_sched_launcher *create_task_thread(int id);\n-    void destroy_task_thread(rust_sched_launcher *thread);\n-\n-    void exit();\n-\n-    // Called when refcount reaches zero\n-    void delete_this();\n-\n-private:\n-    // private and undefined to disable copying\n-    rust_scheduler(const rust_scheduler& rhs);\n-    rust_scheduler& operator=(const rust_scheduler& rhs);\n-\n-public:\n-    rust_scheduler(rust_kernel *kernel, size_t max_num_threads,\n-                   rust_sched_id id, bool allow_exit, bool killed,\n-                   rust_sched_launcher_factory *launchfac);\n-\n-    void start_task_threads();\n-    void join_task_threads();\n-    void kill_all_tasks();\n-    rust_task* create_task(rust_task *spawner, const char *name);\n-\n-    void release_task();\n-\n-    size_t max_number_of_threads();\n-    size_t number_of_threads();\n-    // Called by each thread when it terminates. When all threads\n-    // terminate the scheduler does as well.\n-    void release_task_thread();\n-\n-    rust_sched_id get_id() { return id; }\n-    // Tells the scheduler that as soon as it runs out of tasks\n-    // to run it should exit\n-    void allow_exit();\n-    void disallow_exit();\n-};\n-\n-#endif /* RUST_SCHEDULER_H */"}, {"sha": "2f6b8acb0725c3c12996f5c08a7b6d0991ab3af8", "filename": "src/rt/rust_task.cpp", "status": "removed", "additions": 0, "deletions": 742, "changes": 742, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,742 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#ifndef __WIN32__\n-#ifdef __ANDROID__\n-#include \"rust_android_dummy.h\"\n-#else\n-#include <execinfo.h>\n-#endif\n-#endif\n-#include <iostream>\n-#include <algorithm>\n-\n-#include \"rust_task.h\"\n-#include \"rust_env.h\"\n-#include \"rust_globals.h\"\n-#include \"rust_crate_map.h\"\n-\n-// Tasks\n-rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n-                     const char *name, size_t init_stack_sz) :\n-    ref_count(1),\n-    id(0),\n-    stk(NULL),\n-    runtime_sp(0),\n-    sched(sched_loop->sched),\n-    sched_loop(sched_loop),\n-    kernel(sched_loop->kernel),\n-    name(name),\n-    list_index(-1),\n-    boxed(&local_region, sched_loop->kernel->env->poison_on_free),\n-    local_region(&sched_loop->local_region),\n-    unwinding(false),\n-    total_stack_sz(0),\n-    task_local_data(NULL),\n-    task_local_data_cleanup(NULL),\n-    borrow_list(NULL),\n-    state(state),\n-    cond(NULL),\n-    cond_name(\"none\"),\n-    event_reject(false),\n-    event(NULL),\n-    killed(false),\n-    reentered_rust_stack(false),\n-    disallow_kill(0),\n-    disallow_yield(0),\n-    c_stack(NULL),\n-    next_c_sp(0),\n-    next_rust_sp(0)\n-{\n-    LOGPTR(sched_loop, \"new task\", (uintptr_t)this);\n-    DLOG(sched_loop, task, \"sizeof(task) = %d (0x%x)\",\n-         sizeof *this, sizeof *this);\n-\n-    new_stack(init_stack_sz);\n-}\n-\n-// NB: This does not always run on the task's scheduler thread\n-void\n-rust_task::delete_this()\n-{\n-    DLOG(sched_loop, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n-         name, (uintptr_t)this, ref_count);\n-\n-    /* FIXME (#2677): tighten this up, there are some more\n-       assertions that hold at task-lifecycle events. */\n-    assert(ref_count == 0); // ||\n-    //   (ref_count == 1 && this == sched->root_task));\n-\n-    // The borrow list should be freed in the task annihilator\n-    assert(!borrow_list);\n-\n-    sched_loop->release_task(this);\n-}\n-\n-// All failure goes through me. Put your breakpoints here!\n-extern \"C\" void\n-rust_task_fail(rust_task *task,\n-               char const *expr,\n-               char const *file,\n-               size_t line) {\n-    assert(task != NULL);\n-    task->begin_failure(expr, file, line);\n-}\n-\n-struct spawn_args {\n-    rust_task *task;\n-    spawn_fn f;\n-    rust_opaque_box *envptr;\n-    void *argptr;\n-};\n-\n-struct cleanup_args {\n-    spawn_args *spargs;\n-    bool threw_exception;\n-};\n-\n-void\n-annihilate_boxes(rust_task *task);\n-\n-void\n-cleanup_task(cleanup_args *args) {\n-    spawn_args *a = args->spargs;\n-    bool threw_exception = args->threw_exception;\n-    rust_task *task = a->task;\n-\n-    {\n-        scoped_lock with(task->lifecycle_lock);\n-        if (task->killed && !threw_exception) {\n-            LOG(task, task, \"Task killed during termination\");\n-            threw_exception = true;\n-        }\n-    }\n-\n-    // Clean up TLS. This will only be set if TLS was used to begin with.\n-    // Because this is a crust function, it must be called from the C stack.\n-    if (task->task_local_data_cleanup != NULL) {\n-        // This assert should hold but it's not our job to ensure it (and\n-        // the condition might change). Handled in libcore/task.rs.\n-        // assert(task->task_local_data != NULL);\n-        task->task_local_data_cleanup(task->task_local_data);\n-        task->task_local_data = NULL;\n-    } else if (threw_exception && task->id == INIT_TASK_ID) {\n-        // Edge case: If main never spawns any tasks, but fails anyway, TLS\n-        // won't be around to take down the kernel (task.rs:kill_taskgroup,\n-        // rust_task_kill_all). Do it here instead.\n-        // (Note that children tasks can not init their TLS if they were\n-        // killed too early, so we need to check main's task id too.)\n-        task->fail_sched_loop();\n-        // This must not happen twice.\n-        static bool main_task_failed_without_spawning = false;\n-        assert(!main_task_failed_without_spawning);\n-        main_task_failed_without_spawning = true;\n-    }\n-\n-    // Call the box annihilator.\n-    cratemap* map = reinterpret_cast<cratemap*>(global_crate_map);\n-    task->call_on_rust_stack(NULL, const_cast<void*>(map->annihilate_fn()));\n-\n-    task->die();\n-\n-#ifdef __WIN32__\n-    assert(!threw_exception && \"No exception-handling yet on windows builds\");\n-#endif\n-}\n-\n-// This runs on the Rust stack\n-void task_start_wrapper(spawn_args *a)\n-{\n-    rust_task *task = a->task;\n-\n-    bool threw_exception = false;\n-    try {\n-        a->f(a->envptr, a->argptr);\n-    } catch (rust_task *ex) {\n-        assert(ex == task && \"Expected this task to be thrown for unwinding\");\n-        threw_exception = true;\n-\n-        if (task->c_stack) {\n-            task->return_c_stack();\n-        }\n-\n-        // Since we call glue code below we need to make sure we\n-        // have the stack limit set up correctly\n-        task->reset_stack_limit();\n-    }\n-\n-    // We should have returned any C stack by now\n-    assert(task->c_stack == NULL);\n-\n-    rust_opaque_box* env = a->envptr;\n-    if(env) {\n-        // free the environment (which should be a unique closure).\n-        const type_desc *td = env->td;\n-        td->drop_glue(NULL,\n-                      box_body(env));\n-        task->kernel->region()->free(env);\n-    }\n-\n-    // The cleanup work needs lots of stack\n-    cleanup_args ca = {a, threw_exception};\n-    task->call_on_c_stack(&ca, (void*)cleanup_task);\n-\n-    task->ctx.next->swap(task->ctx);\n-}\n-\n-void\n-rust_task::start(spawn_fn spawnee_fn,\n-                 rust_opaque_box *envptr,\n-                 void *argptr)\n-{\n-    LOG(this, task, \"starting task from fn 0x%\" PRIxPTR\n-        \" with env 0x%\" PRIxPTR \" and arg 0x%\" PRIxPTR,\n-        spawnee_fn, envptr, argptr);\n-\n-    assert(stk->data != NULL);\n-\n-    char *sp = (char *)stk->end;\n-\n-    sp -= sizeof(spawn_args);\n-\n-    spawn_args *a = (spawn_args *)sp;\n-\n-    a->task = this;\n-    a->envptr = envptr;\n-    a->argptr = argptr;\n-    a->f = spawnee_fn;\n-\n-    ctx.call((void *)task_start_wrapper, a, sp);\n-\n-    this->start();\n-}\n-\n-void rust_task::start()\n-{\n-    transition(task_state_newborn, task_state_running, NULL, \"none\");\n-}\n-\n-bool\n-rust_task::must_fail_from_being_killed() {\n-    scoped_lock with(lifecycle_lock);\n-    return must_fail_from_being_killed_inner();\n-}\n-\n-bool\n-rust_task::must_fail_from_being_killed_inner() {\n-    lifecycle_lock.must_have_lock();\n-    return killed && !reentered_rust_stack && disallow_kill == 0;\n-}\n-\n-void rust_task_yield_fail(rust_task *task) {\n-    LOG_ERR(task, task, \"task %\" PRIxPTR \" yielded in an atomic section\",\n-            task);\n-    task->fail();\n-}\n-\n-// Only run this on the rust stack\n-MUST_CHECK bool rust_task::yield() {\n-    bool killed = false;\n-\n-    if (disallow_yield > 0) {\n-        call_on_c_stack(this, (void *)rust_task_yield_fail);\n-    }\n-\n-    // This check is largely superfluous; it's the one after the context swap\n-    // that really matters. This one allows us to assert a useful invariant.\n-\n-    // NB: This takes lifecycle_lock three times, and I believe that none of\n-    // them are actually necessary, as per #3213. Removing the locks here may\n-    // cause *harmless* races with a killer... but I didn't observe any\n-    // substantial performance improvement from removing them, even with\n-    // msgsend-ring-pipes, and also it's my last day, so I'm not about to\n-    // remove them.  -- bblum\n-    if (must_fail_from_being_killed()) {\n-        {\n-            scoped_lock with(lifecycle_lock);\n-            assert(!(state == task_state_blocked));\n-        }\n-        killed = true;\n-    }\n-\n-    // Return to the scheduler.\n-    ctx.next->swap(ctx);\n-\n-    if (must_fail_from_being_killed()) {\n-        killed = true;\n-    }\n-    return killed;\n-}\n-\n-void\n-rust_task::kill() {\n-    scoped_lock with(lifecycle_lock);\n-    kill_inner();\n-}\n-\n-void rust_task::kill_inner() {\n-    lifecycle_lock.must_have_lock();\n-\n-    // Multiple kills should be able to safely race, but check anyway.\n-    if (killed) {\n-        LOG(this, task, \"task %s @0x%\" PRIxPTR \" already killed\", name, this);\n-        return;\n-    }\n-\n-    // Note the distinction here: kill() is when you're in an upcall\n-    // from task A and want to force-fail task B, you do B->kill().\n-    // If you want to fail yourself you do self->fail().\n-    LOG(this, task, \"killing task %s @0x%\" PRIxPTR, name, this);\n-    // When the task next goes to yield or resume it will fail\n-    killed = true;\n-    // Unblock the task so it can unwind.\n-\n-    if (state == task_state_blocked &&\n-        must_fail_from_being_killed_inner()) {\n-        wakeup_inner(cond);\n-    }\n-\n-    LOG(this, task, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n-}\n-\n-void\n-rust_task::fail() {\n-    // See note in ::kill() regarding who should call this.\n-    fail(NULL, NULL, 0);\n-}\n-\n-void\n-rust_task::fail(char const *expr, char const *file, size_t line) {\n-    rust_task_fail(this, expr, file, line);\n-}\n-\n-// Called only by rust_task_fail\n-void\n-rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n-\n-    if (expr) {\n-        LOG_ERR(this, task, \"task failed at '%s', %s:%\" PRIdPTR,\n-                expr, file, line);\n-    }\n-\n-    DLOG(sched_loop, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n-    backtrace();\n-    unwinding = true;\n-#ifndef __WIN32__\n-    throw this;\n-#else\n-    die();\n-    // FIXME (#908): Need unwinding on windows. This will end up aborting\n-    fail_sched_loop();\n-#endif\n-}\n-\n-void rust_task::fail_sched_loop() {\n-    sched_loop->fail();\n-}\n-\n-void rust_task::assert_is_running()\n-{\n-    scoped_lock with(lifecycle_lock);\n-    assert(state == task_state_running);\n-}\n-\n-// FIXME (#2851) Remove this code when rust_port goes away?\n-bool\n-rust_task::blocked_on(rust_cond *on)\n-{\n-    lifecycle_lock.must_have_lock();\n-    return cond == on;\n-}\n-\n-void *\n-rust_task::malloc(size_t sz, const char *tag, type_desc *td)\n-{\n-    return local_region.malloc(sz, tag);\n-}\n-\n-void *\n-rust_task::realloc(void *data, size_t sz)\n-{\n-    return local_region.realloc(data, sz);\n-}\n-\n-void\n-rust_task::free(void *p)\n-{\n-    local_region.free(p);\n-}\n-\n-void\n-rust_task::transition(rust_task_state src, rust_task_state dst,\n-                      rust_cond *cond, const char* cond_name) {\n-    scoped_lock with(lifecycle_lock);\n-    transition_inner(src, dst, cond, cond_name);\n-}\n-\n-void rust_task::transition_inner(rust_task_state src, rust_task_state dst,\n-                                  rust_cond *cond, const char* cond_name) {\n-    lifecycle_lock.must_have_lock();\n-    sched_loop->transition(this, src, dst, cond, cond_name);\n-}\n-\n-void\n-rust_task::set_state(rust_task_state state,\n-                     rust_cond *cond, const char* cond_name) {\n-    lifecycle_lock.must_have_lock();\n-    this->state = state;\n-    this->cond = cond;\n-    this->cond_name = cond_name;\n-}\n-\n-bool\n-rust_task::block(rust_cond *on, const char* name) {\n-    scoped_lock with(lifecycle_lock);\n-    return block_inner(on, name);\n-}\n-\n-bool\n-rust_task::block_inner(rust_cond *on, const char* name) {\n-    if (must_fail_from_being_killed_inner()) {\n-        // We're already going to die. Don't block. Tell the task to fail\n-        return false;\n-    }\n-\n-    LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n-                         (uintptr_t) on, (uintptr_t) cond);\n-    assert(cond == NULL && \"Cannot block an already blocked task.\");\n-    assert(on != NULL && \"Cannot block on a NULL object.\");\n-\n-    transition_inner(task_state_running, task_state_blocked, on, name);\n-\n-    return true;\n-}\n-\n-void\n-rust_task::wakeup(rust_cond *from) {\n-    scoped_lock with(lifecycle_lock);\n-    wakeup_inner(from);\n-}\n-\n-void\n-rust_task::wakeup_inner(rust_cond *from) {\n-    assert(cond != NULL && \"Cannot wake up unblocked task.\");\n-    LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n-                        (uintptr_t) cond, (uintptr_t) from);\n-    assert(cond == from && \"Cannot wake up blocked task on wrong condition.\");\n-\n-    transition_inner(task_state_blocked, task_state_running, NULL, \"none\");\n-}\n-\n-void\n-rust_task::die() {\n-    transition(task_state_running, task_state_dead, NULL, \"none\");\n-}\n-\n-void\n-rust_task::backtrace() {\n-    if (log_rt_backtrace <= log_err) return;\n-#ifndef __WIN32__\n-    void *call_stack[256];\n-    int nframes = ::backtrace(call_stack, 256);\n-    backtrace_symbols_fd(call_stack + 1, nframes - 1, 2);\n-#endif\n-}\n-\n-size_t\n-rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n-    LOG(this, mem, \"calculating new stack size for 0x%\" PRIxPTR, this);\n-    LOG(this, mem,\n-        \"min: %\" PRIdPTR \" current: %\" PRIdPTR \" requested: %\" PRIdPTR,\n-        min, current, requested);\n-\n-    // Allocate at least enough to accomodate the next frame, plus a little\n-    // slack to avoid thrashing\n-    size_t sz = std::max(min, requested + (requested / 2));\n-\n-    // And double the stack size each allocation\n-    const size_t max = 1024 * 1024;\n-    size_t next = std::min(max, current * 2);\n-\n-    sz = std::max(sz, next);\n-\n-    LOG(this, mem, \"next stack size: %\" PRIdPTR, sz);\n-    assert(requested <= sz);\n-    return sz;\n-}\n-\n-void\n-rust_task::free_stack(stk_seg *stk) {\n-    LOGPTR(sched_loop, \"freeing stk segment\", (uintptr_t)stk);\n-    total_stack_sz -= user_stack_size(stk);\n-    destroy_stack(&local_region, stk);\n-}\n-\n-void\n-new_stack_slow(new_stack_args *args) {\n-    args->task->new_stack(args->requested_sz);\n-}\n-\n-void\n-rust_task::new_stack(size_t requested_sz) {\n-    LOG(this, mem, \"creating new stack for task %\" PRIxPTR, this);\n-    if (stk) {\n-        ::check_stack_canary(stk);\n-    }\n-\n-    // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = sched_loop->min_stack_size;\n-\n-    // Try to reuse an existing stack segment\n-    while (stk != NULL && stk->next != NULL) {\n-        size_t next_sz = user_stack_size(stk->next);\n-        if (min_sz <= next_sz && requested_sz <= next_sz) {\n-            LOG(this, mem, \"reusing existing stack\");\n-            stk = stk->next;\n-            return;\n-        } else {\n-            LOG(this, mem, \"existing stack is not big enough\");\n-            stk_seg *new_next = stk->next->next;\n-            free_stack(stk->next);\n-            stk->next = new_next;\n-            if (new_next) {\n-                new_next->prev = stk;\n-            }\n-        }\n-    }\n-\n-    // The size of the current stack segment, excluding red zone\n-    size_t current_sz = 0;\n-    if (stk != NULL) {\n-        current_sz = user_stack_size(stk);\n-    }\n-    // The calculated size of the new stack, excluding red zone\n-    size_t rust_stk_sz = get_next_stack_size(min_sz,\n-                                             current_sz, requested_sz);\n-\n-    size_t max_stack = kernel->env->max_stack_size;\n-    size_t used_stack = total_stack_sz + rust_stk_sz;\n-\n-    // Don't allow stacks to grow forever. During unwinding we have to allow\n-    // for more stack than normal in order to allow destructors room to run,\n-    // arbitrarily selected as 2x the maximum stack size.\n-    if (!unwinding && used_stack > max_stack) {\n-        LOG_ERR(this, task, \"task %\" PRIxPTR \" ran out of stack\", this);\n-        abort();\n-    } else if (unwinding && used_stack > max_stack * 2) {\n-        LOG_ERR(this, task,\n-                \"task %\" PRIxPTR \" ran out of stack during unwinding\", this);\n-        abort();\n-    }\n-\n-    size_t sz = rust_stk_sz + RED_ZONE_SIZE;\n-    stk_seg *new_stk = create_stack(&local_region, sz);\n-    LOGPTR(sched_loop, \"new stk\", (uintptr_t)new_stk);\n-    new_stk->task = this;\n-    new_stk->next = NULL;\n-    new_stk->prev = stk;\n-    if (stk) {\n-        stk->next = new_stk;\n-    }\n-    LOGPTR(sched_loop, \"stk end\", new_stk->end);\n-\n-    stk = new_stk;\n-    total_stack_sz += user_stack_size(new_stk);\n-}\n-\n-void\n-rust_task::cleanup_after_turn() {\n-    // Delete any spare stack segments that were left\n-    // behind by calls to prev_stack\n-    assert(stk);\n-\n-    while (stk->next) {\n-        stk_seg *new_next = stk->next->next;\n-        assert (!stk->next->is_big);\n-        free_stack(stk->next);\n-\n-        stk->next = new_next;\n-    }\n-}\n-\n-// NB: Runs on the Rust stack. Returns true if we successfully allocated the big\n-// stack and false otherwise.\n-bool\n-rust_task::new_big_stack() {\n-    assert(stk);\n-\n-    stk_seg *borrowed_big_stack = sched_loop->borrow_big_stack();\n-    if (!borrowed_big_stack) {\n-        return false;\n-    }\n-\n-    borrowed_big_stack->task = this;\n-    borrowed_big_stack->next = stk->next;\n-    if (borrowed_big_stack->next)\n-        borrowed_big_stack->next->prev = borrowed_big_stack;\n-    borrowed_big_stack->prev = stk;\n-    stk->next = borrowed_big_stack;\n-\n-    stk = borrowed_big_stack;\n-\n-    return true;\n-}\n-\n-static bool\n-sp_in_stk_seg(uintptr_t sp, stk_seg *stk) {\n-    // Not positive these bounds for sp are correct.  I think that the first\n-    // possible value for esp on a new stack is stk->end, which points to the\n-    // address before the first value to be pushed onto a new stack. The last\n-    // possible address we can push data to is stk->data.  Regardless, there's\n-    // so much slop at either end that we should never hit one of these\n-    // boundaries.\n-    return (uintptr_t)stk->data <= sp && sp <= stk->end;\n-}\n-\n-/*\n-Called by landing pads during unwinding to figure out which stack segment we\n-are currently running on and record the stack limit (which was not restored\n-when unwinding through __morestack).\n- */\n-void\n-rust_task::reset_stack_limit() {\n-    uintptr_t sp = get_sp();\n-    bool reseted = false;\n-    while (!sp_in_stk_seg(sp, stk)) {\n-        reseted = true;\n-        prev_stack();\n-        assert(stk != NULL && \"Failed to find the current stack\");\n-    }\n-\n-    // Each call to prev_stack will record the stack limit. If we *didn't*\n-    // call prev_stack then we still need to record it now to catch a corner case:\n-    // the throw to initiate unwinding starts on the C stack while sp limit is 0.\n-    // If we don't set the limit here then the rust code run subsequently will\n-    // will veer into the red zone. Lame!\n-    if (!reseted) {\n-        record_stack_limit();\n-    }\n-}\n-\n-void\n-rust_task::check_stack_canary() {\n-    ::check_stack_canary(stk);\n-}\n-\n-void\n-rust_task::delete_all_stacks() {\n-    assert(!on_rust_stack());\n-    // Delete all the stacks. There may be more than one if the task failed\n-    // and no landing pads stopped to clean up.\n-    assert(stk->next == NULL);\n-    while (stk != NULL) {\n-        stk_seg *prev = stk->prev;\n-\n-        if (stk->is_big)\n-            sched_loop->return_big_stack(stk);\n-        else\n-            free_stack(stk);\n-\n-        stk = prev;\n-    }\n-}\n-\n-/*\n-Returns true if we're currently running on the Rust stack\n- */\n-bool\n-rust_task::on_rust_stack() {\n-    if (stk == NULL) {\n-        // This only happens during construction\n-        return false;\n-    }\n-\n-    uintptr_t sp = get_sp();\n-    bool in_first_segment = sp_in_stk_seg(sp, stk);\n-    if (in_first_segment) {\n-        return true;\n-    } else if (stk->prev != NULL) {\n-        // This happens only when calling the upcall to delete\n-        // a stack segment\n-        bool in_second_segment = sp_in_stk_seg(sp, stk->prev);\n-        return in_second_segment;\n-    } else {\n-        return false;\n-    }\n-}\n-\n-// NB: In inhibit_kill and allow_kill, helgrind would complain that we need to\n-// hold lifecycle_lock while accessing disallow_kill. Even though another\n-// killing task may access disallow_kill concurrently, this is not racy\n-// because the killer only cares if this task is blocking, and block() already\n-// uses proper locking. See https://github.com/mozilla/rust/issues/3213 .\n-\n-void\n-rust_task::inhibit_kill() {\n-    // Here might be good, though not mandatory, to check if we have to die.\n-    disallow_kill++;\n-}\n-\n-void\n-rust_task::allow_kill() {\n-    assert(disallow_kill > 0 && \"Illegal allow_kill(): already killable!\");\n-    disallow_kill--;\n-}\n-\n-void rust_task::inhibit_yield() {\n-    disallow_yield++;\n-}\n-\n-void rust_task::allow_yield() {\n-    assert(disallow_yield > 0 && \"Illegal allow_yield(): already yieldable!\");\n-    disallow_yield--;\n-}\n-\n-MUST_CHECK bool rust_task::wait_event(void **result) {\n-    bool killed = false;\n-    scoped_lock with(lifecycle_lock);\n-\n-    if(!event_reject) {\n-        block_inner(&event_cond, \"waiting on event\");\n-        lifecycle_lock.unlock();\n-        killed = yield();\n-        lifecycle_lock.lock();\n-    } else if (must_fail_from_being_killed_inner()) {\n-        // If the deschedule was rejected, yield won't do our killed check for\n-        // us. For thoroughness, do it here. FIXME (#524)\n-        killed = true;\n-    }\n-\n-    event_reject = false;\n-    *result = event;\n-    return killed;\n-}\n-\n-void\n-rust_task::signal_event(void *event) {\n-    scoped_lock with(lifecycle_lock);\n-\n-    this->event = event;\n-    event_reject = true;\n-    if(task_state_blocked == state) {\n-        wakeup_inner(&event_cond);\n-    }\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "1735d35b0652366a33d7ae91177cadadd7de913a", "filename": "src/rt/rust_task.h", "status": "removed", "additions": 0, "deletions": 681, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,681 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/**\n-   The rust task is a cooperatively-scheduled green thread that executes\n-   Rust code on a segmented stack.\n-\n-   This class has too many responsibilities:\n-\n-   * Working with the scheduler loop to signal and respond to state changes,\n-   and dealing with all the thread synchronization issues involved\n-\n-   * Managing the dynamically resizing list of Rust stack segments\n-\n-   * Switching between running Rust code on the Rust segmented stack and\n-   foreign C code on large stacks owned by the scheduler\n-\n-   # Lifetime\n-\n-   The lifetime of a rust_task object closely mirrors that of a running Rust\n-   task object, but they are not identical. In particular, the rust_task is an\n-   atomically reference counted object that might be accessed from arbitrary\n-   threads at any time. This may keep the task from being destroyed even after\n-   the task is dead from a Rust task lifecycle perspective. The rust_tasks are\n-   reference counted in the following places:\n-\n-   * By the task's lifetime (i.e., running tasks hold a reference to themself)\n-\n-   * In the rust_task_kill_all -> rust_kernel::fail ->\n-     rust_sched_loop::kill_all_tasks path. When a task brings down the whole\n-     runtime, each sched_loop must use refcounts to take a 'snapshot' of all\n-     existing tasks so it can be sure to kill all of them.\n-\n-   * In core::pipes, tasks that use select() use reference counts to avoid\n-     use-after-free races with multiple different signallers.\n-\n-   # Death\n-\n-   All task death goes through a single central path: The task invokes\n-   rust_task::die(), which invokes transition(task_state_dead), which pumps\n-   the scheduler loop, which switches to rust_sched_loop::run_single_turn(),\n-   which calls reap_dead_tasks(), which cleans up the task's stack segments\n-   and drops the reference count.\n-\n-   When a task's reference count hits zero, rust_sched_loop::release_task()\n-   is called. This frees the memory and deregisters the task from the kernel,\n-   which may trigger the sched_loop, the scheduler, and/or the kernel to exit\n-   completely in the case it was the last task alive.\n-\n-   die() is called from two places: the successful exit path, in cleanup_task,\n-   and on failure (on linux, this is also in cleanup_task, after unwinding\n-   completes; on windows, it is in begin_failure).\n-\n-   Tasks do not force-quit other tasks; a task die()s only itself. However...\n-\n-   # Killing\n-\n-   Tasks may kill each other. This happens when propagating failure between\n-   tasks (see the task::spawn options interface). The code path for this is\n-   rust_task_kill_other() -> rust_task::kill().\n-\n-   It also happens when the main (\"root\") task (or any task in that task's\n-   linked-failure-group) fails: this brings down the whole runtime, and kills\n-   all tasks in all groups. The code path for this is rust_task_kill_all() ->\n-   rust_kernel::fail() -> rust_scheduler::kill_all_tasks() ->\n-   rust_sched_loop::kill_all_tasks() -> rust_task::kill().\n-\n-   In either case, killing a task involves, under the protection of its\n-   lifecycle_lock, (a) setting the 'killed' flag, and (b) checking if it is\n-   'blocked'* and if so punting it awake.\n-   (* and also isn't unkillable, which may happen via task::unkillable()\n-   or via calling an extern rust function from C.)\n-\n-   The killed task will then (wake up if it was asleep, and) eventually call\n-   yield() (or wait_event()), which will check the killed flag, see that it is\n-   true, and then invoke 'fail', which begins the death process described\n-   above.\n-\n-   Three things guarantee concurrency safety in this whole affair:\n-\n-   * The lifecycle_lock protects tasks accessing each other's state: it makes\n-     killing-and-waking up atomic with respect to a task in block() deciding\n-     whether it's allowed to go to sleep, so tasks can't 'escape' being woken.\n-\n-   * In the case of linked failure propagation, we ensure (in task.rs) that\n-     tasks can only see another task's rust_task pointer if that task is\n-     already alive. Even before entering the runtime failure path, a task will\n-     access (locked) the linked-failure data structures to remove its task\n-     pointer so that no subsequently-failing tasks will do a use-after-free.\n-\n-   * In the case of bringing down the whole runtime, each sched_loop takes an\n-     \"atomic snapshot\" of all its tasks, protected by the sched_loop's lock,\n-     and also sets a 'failing' flag so that any subsequently-failing task will\n-     know that it must fail immediately upon creation (which is also checked\n-     under the same lock). A similar process exists at the one-step-higher\n-     level of the kernel killing all the schedulers (the kernel snapshots all\n-     the schedulers and sets a 'failing' flag in the scheduler table).\n- */\n-\n-#ifndef RUST_TASK_H\n-#define RUST_TASK_H\n-\n-#include <map>\n-\n-#include \"rust_globals.h\"\n-#include \"util/array_list.h\"\n-#include \"context.h\"\n-#include \"rust_debug.h\"\n-#include \"rust_kernel.h\"\n-#include \"boxed_region.h\"\n-#include \"rust_stack.h\"\n-#include \"rust_type.h\"\n-#include \"rust_sched_loop.h\"\n-#include \"sp.h\"\n-\n-// The amount of extra space at the end of each stack segment, available\n-// to the rt, compiler and dynamic linker for running small functions\n-// FIXME (#1509): We want this to be 128 but need to slim the red zone calls\n-// down, disable lazy symbol relocation, and other things we haven't\n-// discovered yet\n-#define RZ_LINUX_32 (1024*2)\n-#define RZ_LINUX_64 (1024*2)\n-#define RZ_MAC_32   (1024*20)\n-#define RZ_MAC_64   (1024*20)\n-#define RZ_WIN_32   (1024*20)\n-#define RZ_BSD_32   (1024*20)\n-#define RZ_BSD_64   (1024*20)\n-\n-// The threshold beyond which we switch to the C stack.\n-#define STACK_THRESHOLD (1024 * 1024)\n-\n-#ifdef __linux__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_LINUX_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_LINUX_64\n-#endif\n-#ifdef __mips__\n-#define RED_ZONE_SIZE RZ_MAC_32\n-#endif\n-#ifdef __arm__\n-#define RED_ZONE_SIZE RZ_LINUX_32\n-#endif\n-#endif\n-#ifdef __APPLE__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_MAC_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_MAC_64\n-#endif\n-#endif\n-#ifdef __WIN32__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_WIN_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_WIN_64\n-#endif\n-#endif\n-#ifdef __FreeBSD__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_BSD_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_BSD_64\n-#endif\n-#endif\n-#ifdef __ANDROID__\n-#define RED_ZONE_SIZE RZ_MAC_32\n-#endif\n-\n-#ifndef RED_ZONE_SIZE\n-# error \"Red zone not defined for this platform\"\n-#endif\n-\n-struct frame_glue_fns {\n-    uintptr_t mark_glue_off;\n-    uintptr_t drop_glue_off;\n-    uintptr_t reloc_glue_off;\n-};\n-\n-// std::lib::task::task_result\n-typedef unsigned long task_result;\n-#define tr_success 0\n-#define tr_failure 1\n-\n-struct spawn_args;\n-struct cleanup_args;\n-struct reset_args;\n-struct new_stack_args;\n-\n-// std::lib::task::task_notification\n-//\n-// since it's currently a unary tag, we only add the fields.\n-struct task_notification {\n-    rust_task_id id;\n-    task_result result; // task_result\n-};\n-\n-extern \"C\" void\n-rust_task_fail(rust_task *task,\n-               char const *expr,\n-               char const *file,\n-               size_t line);\n-\n-struct\n-rust_task : public kernel_owned<rust_task>\n-{\n-    RUST_ATOMIC_REFCOUNT();\n-\n-    rust_task_id id;\n-\n-    context ctx;\n-    stk_seg *stk;\n-    uintptr_t runtime_sp;      // Runtime sp while task running.\n-    rust_scheduler *sched;\n-    rust_sched_loop *sched_loop;\n-\n-    // Fields known only to the runtime.\n-    rust_kernel *kernel;\n-    const char *const name;\n-    int32_t list_index;\n-\n-    boxed_region boxed;\n-    memory_region local_region;\n-\n-    // Indicates that fail() has been called and we are cleaning up.\n-    // We use this to suppress the \"killed\" flag during calls to yield.\n-    bool unwinding;\n-\n-    bool propagate_failure;\n-\n-    debug::task_debug_info debug;\n-\n-    // The amount of stack we're using, excluding red zones\n-    size_t total_stack_sz;\n-\n-    // Used by rust task management routines in libcore/task.rs.\n-    void *task_local_data;\n-    void (*task_local_data_cleanup)(void *data);\n-\n-    // Contains a ~[BorrowRecord] pointer, or NULL.\n-    //\n-    // Used by borrow management code in libcore/unstable/lang.rs.\n-    void *borrow_list;\n-\n-private:\n-\n-    // Protects state, cond, cond_name\n-    // Protects the killed flag, disallow_kill flag, reentered_rust_stack\n-    lock_and_signal lifecycle_lock;\n-    rust_task_state state;\n-    rust_cond *cond;\n-    const char *cond_name;\n-\n-    bool event_reject;\n-    rust_cond event_cond;\n-    void *event;\n-\n-    // Indicates that the task was killed and needs to unwind\n-    bool killed;\n-    // Indicates that we've called back into Rust from C\n-    bool reentered_rust_stack;\n-    unsigned long disallow_kill;\n-    unsigned long disallow_yield;\n-\n-    // The stack used for running C code, borrowed from the scheduler thread\n-    stk_seg *c_stack;\n-    uintptr_t next_c_sp;\n-    uintptr_t next_rust_sp;\n-\n-    // Called when the atomic refcount reaches zero\n-    void delete_this();\n-\n-    bool new_big_stack();\n-    void new_stack_fast(size_t requested_sz);\n-    void new_stack(size_t requested_sz);\n-    void free_stack(stk_seg *stk);\n-    size_t get_next_stack_size(size_t min, size_t current, size_t requested);\n-\n-    void return_c_stack();\n-\n-    void transition(rust_task_state src, rust_task_state dst,\n-                    rust_cond *cond, const char* cond_name);\n-    void transition_inner(rust_task_state src, rust_task_state dst,\n-                           rust_cond *cond, const char* cond_name);\n-\n-    bool must_fail_from_being_killed_inner();\n-    // Called by rust_task_fail to unwind on failure\n-    void begin_failure(char const *expr,\n-                       char const *file,\n-                       size_t line);\n-\n-    friend void task_start_wrapper(spawn_args *a);\n-    friend void cleanup_task(cleanup_args *a);\n-    friend void reset_stack_limit_on_c_stack(reset_args *a);\n-    friend void new_stack_slow(new_stack_args *a);\n-    friend void rust_task_fail(rust_task *task,\n-                               char const *expr,\n-                               char const *file,\n-                               size_t line);\n-\n-    bool block_inner(rust_cond *on, const char* name);\n-    void wakeup_inner(rust_cond *from);\n-    bool blocked_on(rust_cond *cond);\n-\n-private:\n-    // private and undefined to disable copying\n-    rust_task(const rust_task& rhs);\n-    rust_task& operator=(const rust_task& rhs);\n-\n-public:\n-\n-    // Only a pointer to 'name' is kept, so it must live as long as this task.\n-    rust_task(rust_sched_loop *sched_loop,\n-              rust_task_state state,\n-              const char *name,\n-              size_t init_stack_sz);\n-\n-    void start(spawn_fn spawnee_fn,\n-               rust_opaque_box *env,\n-               void *args);\n-    void start();\n-    void assert_is_running();\n-\n-    void *malloc(size_t sz, const char *tag, type_desc *td=0);\n-    void *realloc(void *data, size_t sz);\n-    void free(void *p);\n-\n-    void set_state(rust_task_state state,\n-                   rust_cond *cond, const char* cond_name);\n-\n-    bool block(rust_cond *on, const char* name);\n-    void wakeup(rust_cond *from);\n-    void die();\n-\n-    // Print a backtrace, if the \"bt\" logging option is on.\n-    void backtrace();\n-\n-    // Yields control to the scheduler. Called from the Rust stack\n-    // Returns TRUE if the task was killed and needs to fail.\n-    MUST_CHECK bool yield();\n-\n-    // Fail this task (assuming caller-on-stack is different task).\n-    void kill();\n-    void kill_inner();\n-\n-    // Indicates that we've been killed and now is an apropriate\n-    // time to fail as a result\n-    bool must_fail_from_being_killed();\n-\n-    // Fail self, assuming caller-on-stack is this task.\n-    void fail();\n-    void fail(char const *expr, char const *file, size_t line);\n-\n-    // Propagate failure to the entire rust runtime.\n-    void fail_sched_loop();\n-\n-    void *calloc(size_t size, const char *tag);\n-\n-    // Use this function sparingly. Depending on the ref count is generally\n-    // not at all safe.\n-    intptr_t get_ref_count() const { return ref_count; }\n-\n-    void *next_stack(size_t stk_sz, void *args_addr, size_t args_sz);\n-    void prev_stack();\n-    void record_stack_limit();\n-    void reset_stack_limit();\n-\n-    bool on_rust_stack();\n-    void check_stack_canary();\n-    void delete_all_stacks();\n-\n-    void call_on_c_stack(void *args, void *fn_ptr);\n-    void call_on_rust_stack(void *args, void *fn_ptr);\n-    bool have_c_stack() { return c_stack != NULL; }\n-    stk_seg *get_c_stack() { return c_stack; }\n-\n-    rust_task_state get_state() { return state; }\n-    rust_cond *get_cond() { return cond; }\n-    const char *get_cond_name() { return cond_name; }\n-\n-    void clear_event_reject() {\n-        this->event_reject = false;\n-    }\n-\n-    // Returns TRUE if the task was killed and needs to fail.\n-    MUST_CHECK bool wait_event(void **result);\n-    void signal_event(void *event);\n-\n-    void cleanup_after_turn();\n-\n-    void inhibit_kill();\n-    void allow_kill();\n-    void inhibit_yield();\n-    void allow_yield();\n-};\n-\n-template <typename T> struct task_owned {\n-    inline void *operator new(size_t size, rust_task *task,\n-                                             const char *tag) {\n-        return task->malloc(size, tag);\n-    }\n-\n-    inline void *operator new[](size_t size, rust_task *task,\n-                                               const char *tag) {\n-        return task->malloc(size, tag);\n-    }\n-\n-    inline void *operator new(size_t size, rust_task &task,\n-                                             const char *tag) {\n-        return task.malloc(size, tag);\n-    }\n-\n-    inline void *operator new[](size_t size, rust_task &task,\n-                                               const char *tag) {\n-        return task.malloc(size, tag);\n-    }\n-\n-    void operator delete(void *ptr) {\n-        ((T *)ptr)->task->free(ptr);\n-    }\n-};\n-\n-// This is the function that switches between the C and the Rust stack by\n-// calling another function with a single void* argument while changing the\n-// stack pointer. It has a funny name because gdb doesn't normally like to\n-// backtrace through split stacks (thinks it indicates a bug), but has a\n-// special case to allow functions named __morestack to move the stack pointer\n-// around.\n-extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n-\n-inline static uintptr_t\n-sanitize_next_sp(uintptr_t next_sp) {\n-\n-    // Since I'm not precisely sure where the next stack pointer sits in\n-    // relation to where the context switch actually happened, nor in relation\n-    // to the amount of stack needed for calling __morestack I've added some\n-    // extra bytes here.\n-\n-    // FIXME (#2698): On the rust stack this potentially puts is quite far\n-    // into the red zone. Might want to just allocate a new rust stack every\n-    // time we switch back to rust.\n-    const uintptr_t padding = 16;\n-\n-    return align_down(next_sp - padding);\n-}\n-\n-inline void\n-rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n-    // Too expensive to check\n-    // assert(on_rust_stack());\n-\n-    // The shim functions generated by rustc contain the morestack prologue,\n-    // so we need to let them know they have enough stack.\n-    record_sp_limit(0);\n-\n-    uintptr_t prev_rust_sp = next_rust_sp;\n-    next_rust_sp = get_sp();\n-\n-    bool borrowed_a_c_stack = false;\n-    uintptr_t sp;\n-    if (c_stack == NULL) {\n-        c_stack = sched_loop->borrow_c_stack();\n-        next_c_sp = align_down(c_stack->end);\n-        sp = next_c_sp;\n-        borrowed_a_c_stack = true;\n-    } else {\n-        sp = sanitize_next_sp(next_c_sp);\n-    }\n-\n-    __morestack(args, fn_ptr, sp);\n-\n-    // Note that we may not actually get here if we threw an exception,\n-    // in which case we will return the c stack when the exception is caught.\n-    if (borrowed_a_c_stack) {\n-        return_c_stack();\n-    }\n-\n-    next_rust_sp = prev_rust_sp;\n-\n-    record_stack_limit();\n-}\n-\n-inline void\n-rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n-    // Too expensive to check\n-    // assert(!on_rust_stack());\n-\n-    // Because of the hack in the other function that disables the stack limit\n-    // when entering the C stack, here we restore the stack limit again.\n-    record_stack_limit();\n-\n-    assert(get_sp_limit() != 0 && \"Stack must be configured\");\n-    assert(next_rust_sp);\n-\n-    // Unlocked access. Might \"race\" a killer, but harmlessly. This code is\n-    // only run by the task itself, so cannot race itself. See the comment\n-    // above inhibit_kill (or #3213) in rust_task.cpp for justification.\n-    bool had_reentered_rust_stack = reentered_rust_stack;\n-    reentered_rust_stack = true;\n-\n-    uintptr_t prev_c_sp = next_c_sp;\n-    next_c_sp = get_sp();\n-\n-    uintptr_t sp = sanitize_next_sp(next_rust_sp);\n-\n-    // FIXME (#2047): There are times when this is called and needs\n-    // to be able to throw, and we don't account for that.\n-    __morestack(args, fn_ptr, sp);\n-\n-    next_c_sp = prev_c_sp;\n-    reentered_rust_stack = had_reentered_rust_stack;\n-\n-    record_sp_limit(0);\n-}\n-\n-inline void\n-rust_task::return_c_stack() {\n-    // Too expensive to check\n-    // assert(on_rust_stack());\n-    assert(c_stack != NULL);\n-    sched_loop->return_c_stack(c_stack);\n-    c_stack = NULL;\n-    next_c_sp = 0;\n-}\n-\n-// NB: This runs on the Rust stack\n-inline void *\n-rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n-    new_stack_fast(stk_sz + args_sz);\n-    assert(stk->end - (uintptr_t)stk->data >= stk_sz + args_sz\n-      && \"Did not receive enough stack\");\n-    uint8_t *new_sp = (uint8_t*)stk->end;\n-    // Push the function arguments to the new stack\n-    new_sp = align_down(new_sp - args_sz);\n-\n-    // I don't know exactly where the region ends that valgrind needs us\n-    // to mark accessible. On x86_64 these extra bytes aren't needed, but\n-    // on i386 we get errors without.\n-    const int fudge_bytes = 16;\n-    reuse_valgrind_stack(stk, new_sp - fudge_bytes);\n-\n-    memcpy(new_sp, args_addr, args_sz);\n-    record_stack_limit();\n-    return new_sp;\n-}\n-\n-// The amount of stack in a segment available to Rust code\n-inline size_t\n-user_stack_size(stk_seg *stk) {\n-    return (size_t)(stk->end\n-                    - (uintptr_t)&stk->data[0]\n-                    - RED_ZONE_SIZE);\n-}\n-\n-struct new_stack_args {\n-    rust_task *task;\n-    size_t requested_sz;\n-};\n-\n-void\n-new_stack_slow(new_stack_args *args);\n-\n-// NB: This runs on the Rust stack\n-// This is the new stack fast path, in which we\n-// reuse the next cached stack segment\n-inline void\n-rust_task::new_stack_fast(size_t requested_sz) {\n-    // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = sched_loop->min_stack_size;\n-\n-    if (requested_sz > STACK_THRESHOLD) {\n-        if (new_big_stack())\n-            return;\n-    }\n-\n-    // Try to reuse an existing stack segment\n-    if (stk != NULL && stk->next != NULL) {\n-        size_t next_sz = user_stack_size(stk->next);\n-        if (min_sz <= next_sz && requested_sz <= next_sz) {\n-            stk = stk->next;\n-            return;\n-        }\n-    }\n-\n-    new_stack_args args = {this, requested_sz};\n-    call_on_c_stack(&args, (void*)new_stack_slow);\n-}\n-\n-// NB: This runs on the Rust stack\n-inline void\n-rust_task::prev_stack() {\n-    // We're not going to actually delete anything now because that would\n-    // require switching to the C stack and be costly. Instead we'll just move\n-    // up the link list and clean up later, either in new_stack or after our\n-    // turn ends on the scheduler.\n-    if (stk->is_big) {\n-        stk_seg *ss = stk;\n-        stk = stk->prev;\n-\n-        // Unlink the big stack.\n-        if (ss->next)\n-            ss->next->prev = ss->prev;\n-        if (ss->prev)\n-            ss->prev->next = ss->next;\n-\n-        sched_loop->return_big_stack(ss);\n-    } else {\n-        stk = stk->prev;\n-    }\n-\n-    record_stack_limit();\n-}\n-\n-// The LLVM-generated segmented-stack function prolog compares the amount of\n-// stack needed for each frame to the end-of-stack pointer stored in the\n-// TCB. As an optimization, when the frame size is less than 256 bytes, it\n-// will simply compare %esp to the stack limit instead of subtracting the\n-// frame size. As a result we need our stack limit to account for those 256\n-// bytes.\n-const unsigned LIMIT_OFFSET = 256;\n-\n-inline void\n-rust_task::record_stack_limit() {\n-    assert(stk);\n-    assert((uintptr_t)stk->end - RED_ZONE_SIZE\n-      - (uintptr_t)stk->data >= LIMIT_OFFSET\n-           && \"Stack size must be greater than LIMIT_OFFSET\");\n-    record_sp_limit(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n-}\n-\n-inline rust_task* rust_try_get_current_task() {\n-    uintptr_t sp_limit = get_sp_limit();\n-\n-    // FIXME (#1226) - Because of a hack in upcall_call_shim_on_c_stack this\n-    // value is sometimes inconveniently set to 0, so we can't use this\n-    // method of retreiving the task pointer and need to fall back to TLS.\n-    if (sp_limit == 0)\n-        return rust_sched_loop::try_get_task_tls();\n-\n-    // The stack pointer boundary is stored in a quickly-accessible location\n-    // in the TCB. From that we can calculate the address of the stack segment\n-    // structure it belongs to, and in that structure is a pointer to the task\n-    // that owns it.\n-    uintptr_t seg_addr =\n-        sp_limit - RED_ZONE_SIZE - LIMIT_OFFSET - sizeof(stk_seg);\n-    stk_seg *stk = (stk_seg*) seg_addr;\n-\n-    // Make sure we've calculated the right address\n-    ::check_stack_canary(stk);\n-    assert(stk->task != NULL && \"task pointer not in stack structure\");\n-    return stk->task;\n-}\n-\n-inline rust_task* rust_get_current_task() {\n-    rust_task* task = rust_try_get_current_task();\n-    assert(task != NULL && \"no current task\");\n-    return task;\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//\n-\n-#endif /* RUST_TASK_H */"}, {"sha": "b0aab9672ea8f2b64109c93aa208ddf9ff7c6a8b", "filename": "src/rt/rust_test_helpers.cpp", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_test_helpers.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_test_helpers.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -10,12 +10,10 @@\n \n // Helper functions used only in tests\n \n-#include \"rust_sched_loop.h\"\n-#include \"rust_task.h\"\n #include \"rust_util.h\"\n-#include \"rust_scheduler.h\"\n #include \"sync/timer.h\"\n #include \"sync/rust_thread.h\"\n+#include \"sync/lock_and_signal.h\"\n #include \"rust_abi.h\"\n \n // These functions are used in the unit tests for C ABI calls."}, {"sha": "f1b31e89df8ca0c219810832b1d75a155a402220", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 9, "deletions": 234, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -17,8 +17,6 @@\n  */\n \n #include \"rust_globals.h\"\n-#include \"rust_task.h\"\n-#include \"rust_sched_loop.h\"\n #include \"rust_upcall.h\"\n #include \"rust_util.h\"\n \n@@ -29,28 +27,6 @@ typedef int _Unwind_Action;\n struct _Unwind_Context;\n struct _Unwind_Exception;\n \n-#ifdef __GNUC__\n-#define LOG_UPCALL_ENTRY(task)                            \\\n-    LOG(task, upcall,                                     \\\n-        \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n-        \" retpc: x%\" PRIxPTR,                             \\\n-        __FUNCTION__,                                     \\\n-        (task)->name, (task),                             \\\n-        __builtin_return_address(0));\n-#else\n-#define LOG_UPCALL_ENTRY(task)                            \\\n-    LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n-        (task)->name, (task));\n-#endif\n-\n-#define UPCALL_SWITCH_STACK(T, A, F) \\\n-    call_upcall_on_c_stack(T, (void*)A, (void*)F)\n-\n-inline void\n-call_upcall_on_c_stack(rust_task *task, void *args, void *fn_ptr) {\n-    task->call_on_c_stack(args, fn_ptr);\n-}\n-\n typedef void (*CDECL stack_switch_shim)(void*);\n \n /**********************************************************************\n@@ -62,21 +38,8 @@ typedef void (*CDECL stack_switch_shim)(void*);\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_try_get_current_task();\n-\n-    if (task) {\n-        // We're running in task context, do a stack switch\n-        try {\n-            task->call_on_c_stack(args, fn_ptr);\n-        } catch (...) {\n-            // Logging here is not reliable\n-            assert(false && \"Foreign code threw an exception\");\n-        }\n-    } else {\n-        // There's no task. Call the function and hope for the best\n-        stack_switch_shim f = (stack_switch_shim)fn_ptr;\n-        f(args);\n-    }\n+    stack_switch_shim f = (stack_switch_shim)fn_ptr;\n+    f(args);\n }\n \n /*\n@@ -85,171 +48,9 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_try_get_current_task();\n-\n-    if (task) {\n-        try {\n-            task->call_on_rust_stack(args, fn_ptr);\n-        } catch (...) {\n-            // We can't count on being able to unwind through arbitrary\n-            // code. Our best option is to just fail hard.\n-            // Logging here is not reliable\n-            assert(false\n-                   && \"Rust task failed after reentering the Rust stack\");\n-        }\n-    } else {\n-        // There's no task. Call the function and hope for the best\n-        stack_switch_shim f = (stack_switch_shim)fn_ptr;\n-        f(args);\n-    }\n-}\n-\n-/**********************************************************************/\n-\n-struct s_fail_args {\n-    rust_task *task;\n-    char const *expr;\n-    char const *file;\n-    size_t line;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_fail(s_fail_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-    task->fail(args->expr, args->file, args->line);\n-}\n-\n-extern \"C\" CDECL void\n-upcall_fail(char const *expr,\n-            char const *file,\n-            size_t line) {\n-    rust_task *task = rust_try_get_current_task();\n-    if (task == NULL) {\n-        // FIXME #5161: Need to think about what to do here\n-        printf(\"failure outside of a task\");\n-        abort();\n-    }\n-    s_fail_args args = {task,expr,file,line};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_fail);\n-}\n-\n-// FIXME (#2861): Alias used by libcore/rt.rs to avoid naming conflicts with\n-// autogenerated wrappers for upcall_fail. Remove this when we fully move away\n-// away from the C upcall path.\n-extern \"C\" CDECL void\n-rust_upcall_fail(char const *expr,\n-                 char const *file,\n-                 size_t line) {\n-    upcall_fail(expr, file, line);\n-}\n-\n-struct s_trace_args {\n-    rust_task *task;\n-    char const *msg;\n-    char const *file;\n-    size_t line;\n-};\n-\n-/**********************************************************************\n- * Allocate an object in the task-local heap.\n- */\n-\n-struct s_malloc_args {\n-    rust_task *task;\n-    uintptr_t retval;\n-    type_desc *td;\n-    uintptr_t size;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_malloc(s_malloc_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-    LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n-\n-    rust_opaque_box *box = task->boxed.malloc(args->td, args->size);\n-    void *body = box_body(box);\n-\n-    debug::maybe_track_origin(task, box);\n-\n-    LOG(task, mem,\n-        \"upcall malloc(0x%\" PRIxPTR \") = box 0x%\" PRIxPTR\n-        \" with body 0x%\" PRIxPTR,\n-        args->td, (uintptr_t)box, (uintptr_t)body);\n-\n-    args->retval = (uintptr_t)box;\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-upcall_malloc(type_desc *td, uintptr_t size) {\n-    rust_task *task = rust_get_current_task();\n-    s_malloc_args args = {task, 0, td, size};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_malloc);\n-    return args.retval;\n-}\n-\n-// FIXME (#2861): Alias used by libcore/rt.rs to avoid naming conflicts with\n-// autogenerated wrappers for upcall_malloc. Remove this when we fully move\n-// away from the C upcall path.\n-extern \"C\" CDECL uintptr_t\n-rust_upcall_malloc(type_desc *td, uintptr_t size) {\n-    return upcall_malloc(td, size);\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-rust_upcall_malloc_noswitch(type_desc *td, uintptr_t size) {\n-    rust_task *task = rust_get_current_task();\n-    s_malloc_args args = {task, 0, td, size};\n-    upcall_s_malloc(&args);\n-    return args.retval;\n-}\n-\n-/**********************************************************************\n- * Called whenever an object in the task-local heap is freed.\n- */\n-\n-struct s_free_args {\n-    rust_task *task;\n-    void *ptr;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_free(s_free_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-\n-    rust_sched_loop *sched_loop = task->sched_loop;\n-    DLOG(sched_loop, mem,\n-             \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n-             (uintptr_t)args->ptr);\n-\n-    debug::maybe_untrack_origin(task, args->ptr);\n-\n-    rust_opaque_box *box = (rust_opaque_box*) args->ptr;\n-    task->boxed.free(box);\n-}\n-\n-extern \"C\" CDECL void\n-upcall_free(void* ptr) {\n-    rust_task *task = rust_get_current_task();\n-    s_free_args args = {task,ptr};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_free);\n-}\n-\n-// FIXME (#2861): Alias used by libcore/rt.rs to avoid naming conflicts with\n-// autogenerated wrappers for upcall_free. Remove this when we fully move away\n-// away from the C upcall path.\n-extern \"C\" CDECL void\n-rust_upcall_free(void* ptr) {\n-    upcall_free(ptr);\n-}\n-\n-extern \"C\" CDECL void\n-rust_upcall_free_noswitch(void* ptr) {\n-    rust_task *task = rust_get_current_task();\n-    s_free_args args = {task,ptr};\n-    upcall_s_free(&args);\n+    // There's no task. Call the function and hope for the best\n+    stack_switch_shim f = (stack_switch_shim)fn_ptr;\n+    f(args);\n }\n \n /**********************************************************************/\n@@ -293,41 +94,21 @@ upcall_rust_personality(int version,\n     s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n                                     version, actions, exception_class,\n                                     ue_header, context};\n-    rust_task *task = rust_try_get_current_task();\n-\n-    if (task == NULL) {\n-        // Assuming we're running with the new scheduler\n-        upcall_s_rust_personality(&args);\n-        return args.retval;\n-    }\n-\n-    // The personality function is run on the stack of the\n-    // last function that threw or landed, which is going\n-    // to sometimes be the C stack. If we're on the Rust stack\n-    // then switch to the C stack.\n-\n-    if (task->on_rust_stack()) {\n-        UPCALL_SWITCH_STACK(task, &args, upcall_s_rust_personality);\n-    } else {\n-        upcall_s_rust_personality(&args);\n-    }\n+    upcall_s_rust_personality(&args);\n     return args.retval;\n }\n \n // NB: This needs to be blazing fast. Don't switch stacks\n extern \"C\" CDECL void *\n upcall_new_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n-    rust_task *task = rust_get_current_task();\n-    return task->next_stack(stk_sz,\n-                            args_addr,\n-                            args_sz);\n+    assert(false && \"newsched shouldn't be growing the stack\");\n+    return NULL;\n }\n \n // NB: This needs to be blazing fast. Don't switch stacks\n extern \"C\" CDECL void\n upcall_del_stack() {\n-    rust_task *task = rust_get_current_task();\n-    task->prev_stack();\n+    assert(false && \"newsched shouldn't be growing the stack\");\n }\n \n // Landing pads need to call this to insert the\n@@ -336,12 +117,6 @@ upcall_del_stack() {\n // needs to acquire the value of the stack pointer\n extern \"C\" CDECL void\n upcall_reset_stack_limit() {\n-    rust_task *task = rust_try_get_current_task();\n-    if (task != NULL) {\n-        task->reset_stack_limit();\n-    } else {\n-        // We must be in a newsched task\n-    }\n }\n \n //"}, {"sha": "30d4fcbdc49664e7090f96c09a6ec988361d2528", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -12,7 +12,8 @@\n #define RUST_UTIL_H\n \n #include <limits.h>\n-#include \"rust_task.h\"\n+#include \"rust_exchange_alloc.h\"\n+#include \"rust_type.h\"\n #include \"rust_env.h\"\n \n extern struct type_desc str_body_tydesc;"}, {"sha": "f537e866dfcabf0baec19051b2553cc3054c715c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -16,8 +16,6 @@\n #include \"uv.h\"\n \n #include \"rust_globals.h\"\n-#include \"rust_task.h\"\n-#include \"rust_log.h\"\n \n // extern fn pointers\n typedef void (*extern_async_op_cb)(uv_loop_t* loop, void* data,\n@@ -35,43 +33,6 @@ struct handle_data {\n     extern_close_cb close_cb;\n };\n \n-// helpers\n-static void*\n-current_kernel_malloc(size_t size, const char* tag) {\n-  void* ptr = rust_get_current_task()->kernel->malloc(size, tag);\n-  return ptr;\n-}\n-\n-static void\n-current_kernel_free(void* ptr) {\n-  rust_get_current_task()->kernel->free(ptr);\n-}\n-\n-static handle_data*\n-new_handle_data_from(uint8_t* buf, extern_simple_cb cb) {\n-    handle_data* data = (handle_data*)current_kernel_malloc(\n-            sizeof(handle_data),\n-            \"handle_data\");\n-    memcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n-    data->cb = cb;\n-    return data;\n-}\n-\n-// libuv callback impls\n-static void\n-foreign_extern_async_op_cb(uv_async_t* handle, int status) {\n-    extern_async_op_cb cb = (extern_async_op_cb)handle->data;\n-    void* loop_data = handle->loop->data;\n-    cb(handle->loop, loop_data, handle);\n-}\n-\n-static void\n-foreign_async_cb(uv_async_t* handle, int status) {\n-    handle_data* handle_d = (handle_data*)handle->data;\n-    void* loop_data = handle->loop->data;\n-    handle_d->cb(handle_d->id_buf, loop_data);\n-}\n-\n static void\n foreign_timer_cb(uv_timer_t* handle, int status) {\n     handle_data* handle_d = (handle_data*)handle->data;\n@@ -84,18 +45,6 @@ foreign_close_cb(uv_handle_t* handle) {\n     handle_data* data = (handle_data*)handle->data;\n     data->close_cb(data->id_buf, handle, handle->loop->data);\n }\n-\n-static void\n-foreign_close_op_cb(uv_handle_t* op_handle) {\n-    current_kernel_free(op_handle);\n-    // uv_run() should return after this..\n-}\n-\n-// foreign fns bound in rust\n-extern \"C\" void\n-rust_uv_free(void* ptr) {\n-    current_kernel_free(ptr);\n-}\n extern \"C\" void*\n rust_uv_loop_new() {\n     return (void*)uv_loop_new();\n@@ -127,24 +76,6 @@ rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;\n }\n \n-extern \"C\" void*\n-rust_uv_bind_op_cb(uv_loop_t* loop, extern_async_op_cb cb) {\n-    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-            sizeof(uv_async_t),\n-            \"uv_async_t\");\n-    uv_async_init(loop, async, foreign_extern_async_op_cb);\n-    async->data = (void*)cb;\n-    // decrement the ref count, so that our async bind\n-    // doesn't count towards keeping the loop alive\n-    //uv_unref(loop);\n-    return async;\n-}\n-\n-extern \"C\" void\n-rust_uv_stop_op_cb(uv_handle_t* op_handle) {\n-    uv_close(op_handle, foreign_close_op_cb);\n-}\n-\n extern \"C\" void\n rust_uv_run(uv_loop_t* loop) {\n     uv_run(loop, UV_RUN_DEFAULT);\n@@ -167,18 +98,6 @@ rust_uv_hilvl_close(uv_handle_t* handle, extern_close_cb cb) {\n     uv_close(handle, foreign_close_cb);\n }\n \n-extern \"C\" void\n-rust_uv_hilvl_close_async(uv_async_t* handle) {\n-    current_kernel_free(handle->data);\n-    current_kernel_free(handle);\n-}\n-\n-extern \"C\" void\n-rust_uv_hilvl_close_timer(uv_async_t* handle) {\n-    current_kernel_free(handle->data);\n-    current_kernel_free(handle);\n-}\n-\n extern \"C\" void\n rust_uv_async_send(uv_async_t* handle) {\n     uv_async_send(handle);\n@@ -191,32 +110,6 @@ rust_uv_async_init(uv_loop_t* loop_handle,\n     return uv_async_init(loop_handle, async_handle, cb);\n }\n \n-extern \"C\" void*\n-rust_uv_hilvl_async_init(uv_loop_t* loop, extern_simple_cb cb,\n-        uint8_t* buf) {\n-    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-            sizeof(uv_async_t),\n-            \"uv_async_t\");\n-    uv_async_init(loop, async, foreign_async_cb);\n-    handle_data* data = new_handle_data_from(buf, cb);\n-    async->data = data;\n-\n-    return async;\n-}\n-\n-extern \"C\" void*\n-rust_uv_hilvl_timer_init(uv_loop_t* loop, extern_simple_cb cb,\n-        uint8_t* buf) {\n-    uv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n-            sizeof(uv_timer_t),\n-            \"uv_timer_t\");\n-    uv_timer_init(loop, new_timer);\n-    handle_data* data = new_handle_data_from(buf, cb);\n-    new_timer->data = data;\n-\n-    return new_timer;\n-}\n-\n extern \"C\" void\n rust_uv_hilvl_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n         uint32_t repeat) {\n@@ -469,15 +362,6 @@ rust_uv_get_stream_handle_from_write_req(uv_write_t* write_req) {\n     return write_req->handle;\n }\n \n-extern \"C\" uv_buf_t\n-current_kernel_malloc_alloc_cb(uv_handle_t* handle,\n-        size_t suggested_size) {\n-    char* base_ptr = (char*)current_kernel_malloc(sizeof(char)\n-            * suggested_size,\n-            \"uv_buf_t_base_val\");\n-    return uv_buf_init(base_ptr, suggested_size);\n-}\n-\n extern \"C\" void\n rust_uv_buf_init(uv_buf_t* out_buf, char* base, size_t len) {\n     *out_buf = uv_buf_init(base, len);\n@@ -563,16 +447,6 @@ rust_uv_read_stop(uv_stream_t* stream) {\n     return uv_read_stop(stream);\n }\n \n-extern \"C\" char*\n-rust_uv_malloc_buf_base_of(size_t suggested_size) {\n-    return (char*) current_kernel_malloc(sizeof(char)*suggested_size,\n-            \"uv_buf_t base\");\n-}\n-extern \"C\" void\n-rust_uv_free_base_of_buf(uv_buf_t buf) {\n-    current_kernel_free(buf.base);\n-}\n-\n extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {\n     struct sockaddr_in addr = uv_ip4_addr(ip, port);\n@@ -639,16 +513,6 @@ rust_uv_ip6_port(struct sockaddr_in6* src) {\n     return ntohs(src->sin6_port);\n }\n \n-extern \"C\" void*\n-rust_uv_current_kernel_malloc(size_t size) {\n-    return current_kernel_malloc(size, \"rust_uv_current_kernel_malloc\");\n-}\n-\n-extern \"C\" void\n-rust_uv_current_kernel_free(void* mem) {\n-    current_kernel_free(mem);\n-}\n-\n extern  \"C\" int\n rust_uv_getaddrinfo(uv_loop_t* loop, uv_getaddrinfo_t* handle,\n                     uv_getaddrinfo_cb cb,"}, {"sha": "b5ce0400c1e940514766f3e4c4142a5b571254a9", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -1,27 +1,19 @@\n-debug_get_stk_seg\n debug_abi_1\n debug_abi_2\n debug_static_mut\n debug_static_mut_check_four\n-get_task_id\n get_time\n rust_tzset\n rust_gmtime\n rust_localtime\n rust_timegm\n rust_mktime\n-new_task\n precise_time_ns\n rand_free\n rand_new_seeded\n rand_seed_size\n rand_gen_seed\n rand_next\n-rust_get_sched_id\n-rust_get_argc\n-rust_get_argv\n-rust_new_sched\n-rust_new_task_in_sched\n rust_path_is_dir\n rust_path_exists\n rust_get_stdin\n@@ -35,55 +27,26 @@ rust_log_console_off\n rust_should_log_console\n rust_set_environ\n rust_unset_sigprocmask\n-rust_set_exit_status\n-rust_start\n rust_env_pairs\n-rust_task_yield\n-rust_task_is_unwinding\n-rust_get_task\n-rust_try_get_task\n-rust_get_stack_segment\n-rust_get_c_stack\n-rust_log_str\n-start_task\n-rust_local_realloc\n-task_clear_event_reject\n-task_wait_event\n-task_signal_event\n-upcall_fail\n-upcall_free\n-upcall_malloc\n upcall_rust_personality\n upcall_call_shim_on_c_stack\n upcall_call_shim_on_rust_stack\n upcall_new_stack\n upcall_del_stack\n upcall_reset_stack_limit\n-rust_upcall_fail\n-rust_upcall_free\n-rust_upcall_free_noswitch\n-rust_upcall_malloc\n-rust_upcall_malloc_noswitch\n rust_uv_loop_new\n rust_uv_loop_delete\n rust_uv_walk\n rust_uv_loop_set_data\n-rust_uv_bind_op_cb\n-rust_uv_stop_op_cb\n rust_uv_run\n rust_uv_close\n rust_uv_hilvl_close\n-rust_uv_hilvl_close_async\n-rust_uv_hilvl_close_timer\n rust_uv_async_send\n rust_uv_async_init\n-rust_uv_hilvl_async_init\n-rust_uv_hilvl_timer_init\n rust_uv_hilvl_timer_start\n rust_uv_timer_init\n rust_uv_timer_start\n rust_uv_timer_stop\n-rust_uv_free\n rust_uv_tcp_init\n rust_uv_buf_init\n rust_uv_last_error\n@@ -124,8 +87,6 @@ rust_uv_accept\n rust_uv_write\n rust_uv_read_start\n rust_uv_read_stop\n-rust_uv_malloc_buf_base_of\n-rust_uv_free_base_of_buf\n rust_uv_is_ipv4_addrinfo\n rust_uv_is_ipv6_addrinfo\n rust_uv_get_next_addrinfo\n@@ -155,8 +116,6 @@ rust_uv_get_data_for_req\n rust_uv_set_data_for_req\n rust_uv_get_base_from_buf\n rust_uv_get_len_from_buf\n-rust_uv_current_kernel_malloc\n-rust_uv_current_kernel_free\n rust_uv_getaddrinfo\n rust_uv_freeaddrinfo\n rust_uv_idle_new\n@@ -172,21 +131,10 @@ rust_dbg_lock_wait\n rust_dbg_lock_signal\n rust_dbg_call\n rust_dbg_do_nothing\n-rust_osmain_sched_id\n-rust_task_inhibit_kill\n-rust_task_allow_kill\n-rust_task_inhibit_yield\n-rust_task_allow_yield\n-rust_task_kill_other\n-rust_task_kill_all\n rust_create_little_lock\n rust_destroy_little_lock\n rust_lock_little_lock\n rust_unlock_little_lock\n-rust_get_task_local_data\n-rust_task_local_data_atexit\n-rust_task_ref\n-rust_task_deref\n tdefl_compress_mem_to_heap\n tinfl_decompress_mem_to_heap\n rust_gc_metadata\n@@ -221,7 +169,6 @@ rust_dbg_extern_return_TwoU32s\n rust_dbg_extern_return_TwoU64s\n rust_dbg_extern_identity_double\n rust_dbg_extern_identity_u8\n-rust_get_rt_env\n rust_uv_handle_size\n rust_uv_req_size\n rust_uv_handle_type_max\n@@ -241,8 +188,6 @@ rust_boxed_region_realloc\n rust_boxed_region_free\n rust_try\n rust_begin_unwind\n-rust_take_task_borrow_list\n-rust_set_task_borrow_list\n rust_valgrind_stack_register\n rust_valgrind_stack_deregister\n rust_take_env_lock\n@@ -251,11 +196,11 @@ rust_update_log_settings\n rust_running_on_valgrind\n rust_get_num_cpus\n rust_get_global_args_ptr\n-rust_current_boxed_region\n rust_take_global_args_lock\n rust_drop_global_args_lock\n rust_set_exit_status_newrt\n rust_get_exit_status_newrt\n rust_take_change_dir_lock\n rust_drop_change_dir_lock\n rust_get_test_int\n+rust_get_task\n\\ No newline at end of file"}, {"sha": "c5d13c81b7c5928c6aae80adc9967028f2907fa3", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod stream {\n-    pub enum Stream<T:Send> { send(T, ::stream::server::Stream<T>), }\n-    pub mod server {\n-        use std::option;\n-        use std::pipes;\n-\n-        impl<T:Send> Stream<T> {\n-            pub fn recv() -> extern fn(v: Stream<T>) -> ::stream::Stream<T> {\n-              // resolve really should report just one error here.\n-              // Change the test case when it changes.\n-              pub fn recv(pipe: Stream<T>) -> ::stream::Stream<T> { //~ ERROR attempt to use a type argument out of scope\n-                //~^ ERROR use of undeclared type name\n-                //~^^ ERROR attempt to use a type argument out of scope\n-                //~^^^ ERROR use of undeclared type name\n-                    pipes::recv(pipe).unwrap()\n-                }\n-                recv\n-            }\n-        }\n-\n-        pub type Stream<T:Send> = pipes::RecvPacket<::stream::Stream<T>>;\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "4bfdb20d9f2b9f2884ab3e6cde5e826bda1c9b4e", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -81,17 +81,6 @@ fn test_ptr() {\n     }\n }\n \n-mod test {\n-    use std::libc;\n-\n-    #[abi = \"cdecl\"]\n-    #[nolink]\n-    extern {\n-        pub fn rust_get_sched_id() -> libc::intptr_t;\n-        pub fn get_task_id() -> libc::intptr_t;\n-    }\n-}\n-\n #[deriving(Eq)]\n struct p {\n   x: int,"}, {"sha": "85e22cfecb4286e287be8146243bd0d81de7d7b1", "filename": "src/test/run-pass/c-stack-as-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -15,12 +15,12 @@ mod rustrt {\n \n     #[abi = \"cdecl\"]\n     extern {\n-        pub fn get_task_id() -> libc::intptr_t;\n+        pub fn rust_get_test_int() -> libc::intptr_t;\n     }\n }\n \n pub fn main() {\n     unsafe {\n-        let _foo = rustrt::get_task_id;\n+        let _foo = rustrt::rust_get_test_int;\n     }\n }"}, {"sha": "a78a10e20e8b0c4d01a99bf535e3ef52df85c4e5", "filename": "src/test/run-pass/issue-1251.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fissue-1251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fissue-1251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1251.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[link(name = \"get_task_id\")];\n+#[link(name = \"rust_get_test_int\")];\n \n mod rustrt {\n     use std::libc;\n \n     extern {\n-        pub fn get_task_id() -> libc::intptr_t;\n+        pub fn rust_get_test_int() -> libc::intptr_t;\n     }\n }\n "}, {"sha": "accf7c4e6cd2d7fc64fb65473ce778302aca1d91", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{pipes, io, task, comm};\n-\n fn main() {\n-    let (port, chan) = comm::stream();\n+    let (port, chan) = stream();\n \n-    do task::spawn {\n-        io::println(port.recv());\n+    do spawn {\n+        println(port.recv());\n     }\n \n     chan.send(\"hello, world\");"}, {"sha": "2d2a82ddb1b18108f9890de2cf2b77c54c214091", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -174,7 +174,7 @@ mod test_foreign_items {\n             #[attr];\n \n             #[attr]\n-            fn get_task_id() -> libc::intptr_t;\n+            fn rust_get_test_int() -> libc::intptr_t;\n         }\n     }\n }"}]}