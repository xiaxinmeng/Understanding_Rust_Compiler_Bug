{"sha": "26334b64a29612be8190bedfbd507fa6ac6f8eb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MzM0YjY0YTI5NjEyYmU4MTkwYmVkZmJkNTA3ZmE2YWM2ZjhlYjU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-13T22:58:24Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-13T22:58:24Z"}, "message": "Merge pull request #4411 from wting/4203_rename_memcpy\n\nRename memcpy, memmove, memset", "tree": {"sha": "230f918604ae646421c70820013bb7e1a3bd8f27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/230f918604ae646421c70820013bb7e1a3bd8f27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26334b64a29612be8190bedfbd507fa6ac6f8eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26334b64a29612be8190bedfbd507fa6ac6f8eb5", "html_url": "https://github.com/rust-lang/rust/commit/26334b64a29612be8190bedfbd507fa6ac6f8eb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26334b64a29612be8190bedfbd507fa6ac6f8eb5/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb399a6d67511fc30d9d25b62fd9cb7101434c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb399a6d67511fc30d9d25b62fd9cb7101434c1", "html_url": "https://github.com/rust-lang/rust/commit/9bb399a6d67511fc30d9d25b62fd9cb7101434c1"}, {"sha": "5cfde77bca32bd956be4a0db65887d9efd333d2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cfde77bca32bd956be4a0db65887d9efd333d2b", "html_url": "https://github.com/rust-lang/rust/commit/5cfde77bca32bd956be4a0db65887d9efd333d2b"}], "stats": {"total": 58, "additions": 29, "deletions": 29}, "files": [{"sha": "9b5f271a61121f248c0d6167eeee151932686bfc", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=26334b64a29612be8190bedfbd507fa6ac6f8eb5", "patch": "@@ -530,7 +530,7 @@ impl BytesReader: Reader {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n \n         let view = vec::view(self.bytes, self.pos, self.bytes.len());\n-        vec::bytes::memcpy(bytes, view, count);\n+        vec::bytes::copy_memory(bytes, view, count);\n \n         self.pos += count;\n \n@@ -1007,7 +1007,7 @@ impl BytesWriter: Writer {\n \n             {\n                 let view = vec::mut_view(bytes, self.pos, count);\n-                vec::bytes::memcpy(view, v, v_len);\n+                vec::bytes::copy_memory(view, v, v_len);\n             }\n \n             self.pos += v_len;"}, {"sha": "30f9f9ac7fdc682445ba1ba6a38d49095d39e86f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=26334b64a29612be8190bedfbd507fa6ac6f8eb5", "patch": "@@ -122,7 +122,7 @@ pub pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may not overlap.\n  */\n #[inline(always)]\n-pub unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memcpy(dst as *mut c_void, src as *c_void, n as size_t);\n }\n@@ -134,13 +134,13 @@ pub unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n  * and destination may overlap.\n  */\n #[inline(always)]\n-pub unsafe fn memmove<T>(dst: *mut T, src: *const T, count: uint) {\n+pub unsafe fn copy_overlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memmove(dst as *mut c_void, src as *c_void, n as size_t);\n }\n \n #[inline(always)]\n-pub unsafe fn memset<T>(dst: *mut T, c: int, count: uint) {\n+pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memset(dst as *mut c_void, c as libc::c_int, n as size_t);\n }\n@@ -326,13 +326,13 @@ pub fn test() {\n         let mut v0 = ~[32000u16, 32001u16, 32002u16];\n         let mut v1 = ~[0u16, 0u16, 0u16];\n \n-        ptr::memcpy(ptr::mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n+        ptr::copy_memory(ptr::mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n                     ptr::offset(vec::raw::to_ptr(v0), 1u), 1u);\n         assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-        ptr::memcpy(vec::raw::to_mut_ptr(v1),\n+        ptr::copy_memory(vec::raw::to_mut_ptr(v1),\n                     ptr::offset(vec::raw::to_ptr(v0), 2u), 1u);\n         assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-        ptr::memcpy(ptr::mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n+        ptr::copy_memory(ptr::mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n                     vec::raw::to_ptr(v0), 1u);\n         assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n     }"}, {"sha": "f32dc746e1286ade8c93cad724265f16472b291b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=26334b64a29612be8190bedfbd507fa6ac6f8eb5", "patch": "@@ -169,7 +169,7 @@ pub fn push_str_no_overallocate(lhs: &mut ~str, rhs: &str) {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n                 let dst = ::cast::transmute_mut_unsafe(dst);\n-                ptr::memcpy(dst, rbuf, rlen);\n+                ptr::copy_memory(dst, rbuf, rlen);\n             }\n         }\n         raw::set_len(lhs, llen + rlen);\n@@ -186,7 +186,7 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n                 let dst = ::cast::transmute_mut_unsafe(dst);\n-                ptr::memcpy(dst, rbuf, rlen);\n+                ptr::copy_memory(dst, rbuf, rlen);\n             }\n         }\n         raw::set_len(lhs, llen + rlen);\n@@ -1967,7 +1967,7 @@ pub mod raw {\n     pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         vec::as_mut_buf(v, |vbuf, _len| {\n-            ptr::memcpy(vbuf, buf as *u8, len)\n+            ptr::copy_memory(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(&mut v, len);\n         v.push(0u8);\n@@ -2024,7 +2024,7 @@ pub mod raw {\n                 do vec::as_imm_buf(v) |vbuf, _vlen| {\n                     let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n                     let src = ptr::offset(sbuf, begin);\n-                    ptr::memcpy(vbuf, src, end - begin);\n+                    ptr::copy_memory(vbuf, src, end - begin);\n                 }\n                 vec::raw::set_len(&mut v, end - begin);\n                 v.push(0u8);"}, {"sha": "e47fe6cd00f3a86d839faa57ad9cafeaa7b084af", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=26334b64a29612be8190bedfbd507fa6ac6f8eb5", "patch": "@@ -471,20 +471,20 @@ pub fn shift<T>(v: &mut ~[T]) -> T unsafe {\n     // We still should have room to work where what last element was\n     assert capacity(v) >= ln;\n     // Pretend like we have the original length so we can use\n-    // the vector memcpy to overwrite the hole we just made\n+    // the vector copy_memory to overwrite the hole we just made\n     raw::set_len(v, ln);\n \n     // Memcopy the head element (the one we want) to the location we just\n     // popped. For the moment it unsafely exists at both the head and last\n     // positions\n     let first_slice = view(*v, 0, 1);\n     let last_slice = mut_view(*v, next_ln, ln);\n-    raw::memcpy(last_slice, first_slice, 1);\n+    raw::copy_memory(last_slice, first_slice, 1);\n \n     // Memcopy everything to the left one element\n     let init_slice = mut_view(*v, 0, next_ln);\n     let tail_slice = view(*v, 1, ln);\n-    raw::memcpy(init_slice, tail_slice, next_ln);\n+    raw::copy_memory(init_slice, tail_slice, next_ln);\n \n     // Set the new length. Now the vector is back to normal\n     raw::set_len(v, next_ln);\n@@ -2075,7 +2075,7 @@ pub mod raw {\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n-        as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n+        as_mut_buf(dst, |p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n         dst\n     }\n \n@@ -2085,13 +2085,13 @@ pub mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    pub unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n+    pub unsafe fn copy_memory<T>(dst: &[mut T], src: &[const T], count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n-                ptr::memcpy(p_dst, p_src, count)\n+                ptr::copy_memory(p_dst, p_src, count)\n             }\n         }\n     }\n@@ -2102,13 +2102,13 @@ pub mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    pub unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n+    pub unsafe fn copy_overlapping_memory<T>(dst: &[mut T], src: &[const T], count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n-                ptr::memmove(p_dst, p_src, count)\n+                ptr::copy_overlapping_memory(p_dst, p_src, count)\n             }\n         }\n     }\n@@ -2167,9 +2167,9 @@ pub mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may not overlap.\n       */\n-    pub fn memcpy(dst: &[mut u8], src: &[const u8], count: uint) {\n-        // Bound checks are done at vec::raw::memcpy.\n-        unsafe { vec::raw::memcpy(dst, src, count) }\n+    pub fn copy_memory(dst: &[mut u8], src: &[const u8], count: uint) {\n+        // Bound checks are done at vec::raw::copy_memory.\n+        unsafe { vec::raw::copy_memory(dst, src, count) }\n     }\n \n     /**\n@@ -2178,9 +2178,9 @@ pub mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    pub fn memmove(dst: &[mut u8], src: &[const u8], count: uint) {\n-        // Bound checks are done at vec::raw::memmove.\n-        unsafe { vec::raw::memmove(dst, src, count) }\n+    pub fn copy_overlapping_memory(dst: &[mut u8], src: &[const u8], count: uint) {\n+        // Bound checks are done at vec::raw::copy_overlapping_memory.\n+        unsafe { vec::raw::copy_overlapping_memory(dst, src, count) }\n     }\n }\n \n@@ -3896,10 +3896,10 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn test_memcpy_oob() unsafe {\n+    fn test_copy_memory_oob() unsafe {\n         let a = [mut 1, 2, 3, 4];\n         let b = [1, 2, 3, 4, 5];\n-        raw::memcpy(a, b, 5);\n+        raw::copy_memory(a, b, 5);\n     }\n \n }"}, {"sha": "9e0dc0ff12e0b832aebd070ec1793e4ee1d0ad46", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26334b64a29612be8190bedfbd507fa6ac6f8eb5/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=26334b64a29612be8190bedfbd507fa6ac6f8eb5", "patch": "@@ -827,7 +827,7 @@ impl TcpSocketBuf: io::Reader {\n         let mut data = ~[];\n         self.data.buf <-> data;\n \n-        vec::bytes::memcpy(buf, vec::view(data, 0, data.len()), count);\n+        vec::bytes::copy_memory(buf, vec::view(data, 0, data.len()), count);\n \n         self.data.buf.push_all(vec::view(data, count, data.len()));\n "}]}