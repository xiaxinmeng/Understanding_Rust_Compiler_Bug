{"sha": "047520153878ade5b0136bc151fc53a43419b1c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzUyMDE1Mzg3OGFkZTViMDEzNmJjMTUxZmM1M2E0MzQxOWIxYzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:18:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:19:51Z"}, "message": "internal: switch some tests to minicore", "tree": {"sha": "e048cbcca058e71a183146e13d3c062be9ac73c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e048cbcca058e71a183146e13d3c062be9ac73c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/047520153878ade5b0136bc151fc53a43419b1c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/047520153878ade5b0136bc151fc53a43419b1c9", "html_url": "https://github.com/rust-lang/rust/commit/047520153878ade5b0136bc151fc53a43419b1c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/047520153878ade5b0136bc151fc53a43419b1c9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f841369fee0f49125c83046340b228b032ebc702", "url": "https://api.github.com/repos/rust-lang/rust/commits/f841369fee0f49125c83046340b228b032ebc702", "html_url": "https://github.com/rust-lang/rust/commit/f841369fee0f49125c83046340b228b032ebc702"}], "stats": {"total": 310, "additions": 129, "deletions": 181}, "files": [{"sha": "eca6ae1fe85c0f2f58f0bfd89559d55021b58db1", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 129, "deletions": 181, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/047520153878ade5b0136bc151fc53a43419b1c9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047520153878ade5b0136bc151fc53a43419b1c9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=047520153878ade5b0136bc151fc53a43419b1c9", "patch": "@@ -630,25 +630,19 @@ fn coerce_placeholder_ref() {\n fn coerce_unsize_array() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        fn test() {\n-            let f: &[usize] = &[1, 2, 3];\n-        }\n+//- minicore: coerce_unsized\n+fn test() {\n+    let f: &[usize] = &[1, 2, 3];\n+}\n         \"#,\n         expect![[r#\"\n-            161..198 '{     ... 3]; }': ()\n-            171..172 'f': &[usize]\n-            185..195 '&[1, 2, 3]': &[usize; 3]\n-            186..195 '[1, 2, 3]': [usize; 3]\n-            187..188 '1': usize\n-            190..191 '2': usize\n-            193..194 '3': usize\n+            10..47 '{     ... 3]; }': ()\n+            20..21 'f': &[usize]\n+            34..44 '&[1, 2, 3]': &[usize; 3]\n+            35..44 '[1, 2, 3]': [usize; 3]\n+            36..37 '1': usize\n+            39..40 '2': usize\n+            42..43 '3': usize\n         \"#]],\n     );\n }\n@@ -657,42 +651,34 @@ fn coerce_unsize_array() {\n fn coerce_unsize_trait_object_simple() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        trait Foo<T, U> {}\n-        trait Bar<U, T, X>: Foo<T, U> {}\n-        trait Baz<T, X>: Bar<usize, T, X> {}\n+//- minicore: coerce_unsized\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n \n-        struct S<T, X>;\n-        impl<T, X> Foo<T, usize> for S<T, X> {}\n-        impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-        impl<T, X> Baz<T, X> for S<T, X> {}\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n \n-        fn test() {\n-            let obj: &dyn Baz<i8, i16> = &S;\n-            let obj: &dyn Bar<_, i8, i16> = &S;\n-            let obj: &dyn Foo<i8, _> = &S;\n-        }\n-        \"#,\n-        expect![[r\"\n-            424..539 '{     ... &S; }': ()\n-            434..437 'obj': &dyn Baz<i8, i16>\n-            459..461 '&S': &S<i8, i16>\n-            460..461 'S': S<i8, i16>\n-            471..474 'obj': &dyn Bar<usize, i8, i16>\n-            499..501 '&S': &S<i8, i16>\n-            500..501 'S': S<i8, i16>\n-            511..514 'obj': &dyn Foo<i8, usize>\n-            534..536 '&S': &S<i8, {unknown}>\n-            535..536 'S': S<i8, {unknown}>\n-        \"]],\n+fn test() {\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, i8, i16> = &S;\n+    let obj: &dyn Foo<i8, _> = &S;\n+}\n+\"#,\n+        expect![[r#\"\n+            236..351 '{     ... &S; }': ()\n+            246..249 'obj': &dyn Baz<i8, i16>\n+            271..273 '&S': &S<i8, i16>\n+            272..273 'S': S<i8, i16>\n+            283..286 'obj': &dyn Bar<usize, i8, i16>\n+            311..313 '&S': &S<i8, i16>\n+            312..313 'S': S<i8, i16>\n+            323..326 'obj': &dyn Foo<i8, usize>\n+            346..348 '&S': &S<i8, {unknown}>\n+            347..348 'S': S<i8, {unknown}>\n+        \"#]],\n     );\n }\n \n@@ -717,49 +703,41 @@ fn coerce_unsize_trait_object_to_trait_object() {\n     //     602..606 'obj2': &dyn Baz<i8, i16>\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        trait Foo<T, U> {}\n-        trait Bar<U, T, X>: Foo<T, U> {}\n-        trait Baz<T, X>: Bar<usize, T, X> {}\n+//- minicore: coerce_unsized\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n \n-        struct S<T, X>;\n-        impl<T, X> Foo<T, usize> for S<T, X> {}\n-        impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-        impl<T, X> Baz<T, X> for S<T, X> {}\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n \n-        fn test() {\n-            let obj: &dyn Baz<i8, i16> = &S;\n-            let obj: &dyn Bar<_, _, _> = obj;\n-            let obj: &dyn Foo<_, _> = obj;\n-            let obj2: &dyn Baz<i8, i16> = &S;\n-            let _: &dyn Foo<_, _> = obj2;\n-        }\n-        \"#,\n+fn test() {\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, _, _> = obj;\n+    let obj: &dyn Foo<_, _> = obj;\n+    let obj2: &dyn Baz<i8, i16> = &S;\n+    let _: &dyn Foo<_, _> = obj2;\n+}\n+\"#,\n         expect![[r#\"\n-            424..609 '{     ...bj2; }': ()\n-            434..437 'obj': &dyn Baz<i8, i16>\n-            459..461 '&S': &S<i8, i16>\n-            460..461 'S': S<i8, i16>\n-            471..474 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            496..499 'obj': &dyn Baz<i8, i16>\n-            509..512 'obj': &dyn Foo<{unknown}, {unknown}>\n-            531..534 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            544..548 'obj2': &dyn Baz<i8, i16>\n-            570..572 '&S': &S<i8, i16>\n-            571..572 'S': S<i8, i16>\n-            582..583 '_': &dyn Foo<{unknown}, {unknown}>\n-            602..606 'obj2': &dyn Baz<i8, i16>\n-            496..499: expected &dyn Bar<{unknown}, {unknown}, {unknown}>, got &dyn Baz<i8, i16>\n-            531..534: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            602..606: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Baz<i8, i16>\n+            236..421 '{     ...bj2; }': ()\n+            246..249 'obj': &dyn Baz<i8, i16>\n+            271..273 '&S': &S<i8, i16>\n+            272..273 'S': S<i8, i16>\n+            283..286 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n+            308..311 'obj': &dyn Baz<i8, i16>\n+            321..324 'obj': &dyn Foo<{unknown}, {unknown}>\n+            343..346 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n+            356..360 'obj2': &dyn Baz<i8, i16>\n+            382..384 '&S': &S<i8, i16>\n+            383..384 'S': S<i8, i16>\n+            394..395 '_': &dyn Foo<{unknown}, {unknown}>\n+            414..418 'obj2': &dyn Baz<i8, i16>\n+            308..311: expected &dyn Bar<{unknown}, {unknown}, {unknown}>, got &dyn Baz<i8, i16>\n+            343..346: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Bar<{unknown}, {unknown}, {unknown}>\n+            414..418: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Baz<i8, i16>\n         \"#]],\n     );\n }\n@@ -768,40 +746,32 @@ fn coerce_unsize_trait_object_to_trait_object() {\n fn coerce_unsize_super_trait_cycle() {\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        trait A {}\n-        trait B: C + A {}\n-        trait C: B {}\n-        trait D: C\n-\n-        struct S;\n-        impl A for S {}\n-        impl B for S {}\n-        impl C for S {}\n-        impl D for S {}\n+//- minicore: coerce_unsized\n+trait A {}\n+trait B: C + A {}\n+trait C: B {}\n+trait D: C\n \n-        fn test() {\n-            let obj: &dyn D = &S;\n-            let obj: &dyn A = &S;\n-        }\n-        \"#,\n-        expect![[r\"\n-            328..383 '{     ... &S; }': ()\n-            338..341 'obj': &dyn D\n-            352..354 '&S': &S\n-            353..354 'S': S\n-            364..367 'obj': &dyn A\n-            378..380 '&S': &S\n-            379..380 'S': S\n-        \"]],\n+struct S;\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+impl D for S {}\n+\n+fn test() {\n+    let obj: &dyn D = &S;\n+    let obj: &dyn A = &S;\n+}\n+\"#,\n+        expect![[r#\"\n+            140..195 '{     ... &S; }': ()\n+            150..153 'obj': &dyn D\n+            164..166 '&S': &S\n+            165..166 'S': S\n+            176..179 'obj': &dyn A\n+            190..192 '&S': &S\n+            191..192 'S': S\n+        \"#]],\n     );\n }\n \n@@ -810,41 +780,35 @@ fn coerce_unsize_generic() {\n     // FIXME: fix the type mismatches here\n     check_infer_with_mismatches(\n         r#\"\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-        struct Foo<T> { t: T };\n-        struct Bar<T>(Foo<T>);\n+//- minicore: coerce_unsized\n+struct Foo<T> { t: T };\n+struct Bar<T>(Foo<T>);\n \n-        fn test() {\n-            let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n-            let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n-        }\n-        \"#,\n+fn test() {\n+    let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+    let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+}\n+\"#,\n         expect![[r#\"\n-            209..317 '{     ... }); }': ()\n-            219..220 '_': &Foo<[usize]>\n-            238..259 '&Foo {..., 3] }': &Foo<[usize]>\n-            239..259 'Foo { ..., 3] }': Foo<[usize]>\n-            248..257 '[1, 2, 3]': [usize; 3]\n-            249..250 '1': usize\n-            252..253 '2': usize\n-            255..256 '3': usize\n-            269..270 '_': &Bar<[usize]>\n-            288..314 '&Bar(F... 3] })': &Bar<[i32; 3]>\n-            289..292 'Bar': Bar<[i32; 3]>(Foo<[i32; 3]>) -> Bar<[i32; 3]>\n-            289..314 'Bar(Fo... 3] })': Bar<[i32; 3]>\n-            293..313 'Foo { ..., 3] }': Foo<[i32; 3]>\n-            302..311 '[1, 2, 3]': [i32; 3]\n-            303..304 '1': i32\n-            306..307 '2': i32\n-            309..310 '3': i32\n-            248..257: expected [usize], got [usize; 3]\n-            288..314: expected &Bar<[usize]>, got &Bar<[i32; 3]>\n+            58..166 '{     ... }); }': ()\n+            68..69 '_': &Foo<[usize]>\n+            87..108 '&Foo {..., 3] }': &Foo<[usize]>\n+            88..108 'Foo { ..., 3] }': Foo<[usize]>\n+            97..106 '[1, 2, 3]': [usize; 3]\n+            98..99 '1': usize\n+            101..102 '2': usize\n+            104..105 '3': usize\n+            118..119 '_': &Bar<[usize]>\n+            137..163 '&Bar(F... 3] })': &Bar<[i32; 3]>\n+            138..141 'Bar': Bar<[i32; 3]>(Foo<[i32; 3]>) -> Bar<[i32; 3]>\n+            138..163 'Bar(Fo... 3] })': Bar<[i32; 3]>\n+            142..162 'Foo { ..., 3] }': Foo<[i32; 3]>\n+            151..160 '[1, 2, 3]': [i32; 3]\n+            152..153 '1': i32\n+            155..156 '2': i32\n+            158..159 '3': i32\n+            97..106: expected [usize], got [usize; 3]\n+            137..163: expected &Bar<[usize]>, got &Bar<[i32; 3]>\n         \"#]],\n     );\n }\n@@ -854,28 +818,20 @@ fn coerce_unsize_apit() {\n     // FIXME: #8984\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n+//- minicore: coerce_unsized\n trait Foo {}\n \n fn test(f: impl Foo) {\n     let _: &dyn Foo = &f;\n }\n         \"#,\n         expect![[r#\"\n-            210..211 'f': impl Foo\n-            223..252 '{     ... &f; }': ()\n-            233..234 '_': &dyn Foo\n-            247..249 '&f': &impl Foo\n-            248..249 'f': impl Foo\n-            247..249: expected &dyn Foo, got &impl Foo\n+            22..23 'f': impl Foo\n+            35..64 '{     ... &f; }': ()\n+            45..46 '_': &dyn Foo\n+            59..61 '&f': &impl Foo\n+            60..61 'f': impl Foo\n+            59..61: expected &dyn Foo, got &impl Foo\n         \"#]],\n     );\n }\n@@ -971,15 +927,7 @@ fn main() {\n fn coerce_unsize_expected_type() {\n     check_no_mismatches(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n+//- minicore: coerce_unsized\n fn main() {\n     let foo: &[u32] = &[1, 2];\n     let foo: &[u32] = match true {"}]}