{"sha": "e9c12ab1d019b42e5427e31bfa49f1f799e84165", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YzEyYWIxZDAxOWI0MmU1NDI3ZTMxYmZhNDlmMWY3OTllODQxNjU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-09T10:40:09Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-11T10:32:37Z"}, "message": "Rewrite comp/middle/resolve.rs\n\n * Cleans up the algorithm\n * Move first pass to walk (second still folds)\n * Support part of a type/value namespace split\n   (crate metadata and module indices still need to be taught about this)\n * Remove a few blatant inefficiencies (import tables being recreated for\n   every lookup, most importantly)", "tree": {"sha": "7f7ce69c7619060559d2da99fb78fa49c4467aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f7ce69c7619060559d2da99fb78fa49c4467aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9c12ab1d019b42e5427e31bfa49f1f799e84165", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c12ab1d019b42e5427e31bfa49f1f799e84165", "html_url": "https://github.com/rust-lang/rust/commit/e9c12ab1d019b42e5427e31bfa49f1f799e84165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9c12ab1d019b42e5427e31bfa49f1f799e84165/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4c32873674ce31f0ace47e7ac08266f3e86d6a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c32873674ce31f0ace47e7ac08266f3e86d6a0", "html_url": "https://github.com/rust-lang/rust/commit/e4c32873674ce31f0ace47e7ac08266f3e86d6a0"}], "stats": {"total": 1229, "additions": 571, "deletions": 658}, "files": [{"sha": "71d187ff02acaf970fc02cfd0e138260a296b381", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -403,7 +403,7 @@ type variant = spanned[variant_];\n type view_item = spanned[view_item_];\n tag view_item_ {\n     view_item_use(ident, vec[@meta_item], def_id, Option.t[int]);\n-    view_item_import(ident, vec[ident], def_id, Option.t[def]);\n+    view_item_import(ident, vec[ident], def_id);\n     view_item_export(ident);\n }\n \n@@ -432,7 +432,7 @@ fn index_view_item(mod_index index, @view_item it) {\n         case(ast.view_item_use(?id, _, _, _)) {\n             index.insert(id, ast.mie_view_item(it));\n         }\n-        case(ast.view_item_import(?def_ident,_,_,_)) {\n+        case(ast.view_item_import(?def_ident,_,_)) {\n             index.insert(def_ident, ast.mie_view_item(it));\n         }\n         case(ast.view_item_export(_)) {\n@@ -488,7 +488,7 @@ fn index_native_item(native_mod_index index, @native_item it) {\n \n fn index_native_view_item(native_mod_index index, @view_item it) {\n     alt (it.node) {\n-        case(ast.view_item_import(?def_ident,_,_,_)) {\n+        case(ast.view_item_import(?def_ident,_,_)) {\n             index.insert(def_ident, ast.nmie_view_item(it));\n         }\n         case(ast.view_item_export(_)) {"}, {"sha": "dd913b53b8a371d4bfff4f4ebddacac84b486f42", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -635,14 +635,8 @@ fn list_crate_metadata(vec[u8] bytes, IO.writer out) {\n \n fn describe_def(&EBML.doc items, ast.def_id id) -> str {\n     if (id._0 != 0) {ret \"external\";}\n-    alt (maybe_find_item(id._1 as int, items)) {\n-        case (Option.some[EBML.doc](?item)) {\n-            ret item_kind_to_str(item_kind(item));\n-        }\n-        case (Option.none[EBML.doc]) {\n-            ret \"??\"; // Native modules don't seem to get item entries.\n-        }\n-    }\n+    auto item = find_item(id._1, items);\n+    ret item_kind_to_str(item_kind(item));\n }\n \n fn item_kind_to_str(u8 kind) -> str {"}, {"sha": "46cad2fd8dc4a14f4cfbf47cda1b66d5d4659276", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -2309,8 +2309,7 @@ fn parse_rest_import_name(parser p, ast.ident first,\n         }\n     }\n     auto import_decl = ast.view_item_import(defined_id, identifiers,\n-                                            p.next_def_id(),\n-                                            none[ast.def]);\n+                                            p.next_def_id());\n     ret @spanned(lo, hi, import_decl);\n }\n "}, {"sha": "62521067c91068e74ae7bc420bc5b9d275107e30", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -291,8 +291,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp, &ident i,\n          &vec[ident] idents,\n-         &def_id id,\n-         &Option.t[def]) -> @view_item)           fold_view_item_import,\n+         &def_id id) -> @view_item)               fold_view_item_import,\n \n      (fn(&ENV e, &span sp,\n          &ident i) -> @view_item)                 fold_view_item_export,\n@@ -981,10 +980,9 @@ fn fold_view_item[ENV](&ENV env, &ast_fold[ENV] fld, &@view_item vi)\n             ret fld.fold_view_item_use(env_, vi.span, ident, meta_items,\n                                        def_id, cnum);\n         }\n-        case (ast.view_item_import(?def_ident, ?idents, ?def_id,\n-                                   ?target_def)) {\n+        case (ast.view_item_import(?def_ident, ?idents, ?def_id)) {\n             ret fld.fold_view_item_import(env_, vi.span, def_ident, idents,\n-                                          def_id, target_def);\n+                                          def_id);\n         }\n \n         case (ast.view_item_export(?def_ident)) {\n@@ -1538,10 +1536,9 @@ fn identity_fold_view_item_use[ENV](&ENV e, &span sp, &ident i,\n }\n \n fn identity_fold_view_item_import[ENV](&ENV e, &span sp, &ident i,\n-                                       &vec[ident] is, &def_id id,\n-                                       &Option.t[def] target_def)\n+                                       &vec[ident] is, &def_id id)\n     -> @view_item {\n-    ret @respan(sp, ast.view_item_import(i, is, id, target_def));\n+    ret @respan(sp, ast.view_item_import(i, is, id));\n }\n \n fn identity_fold_view_item_export[ENV](&ENV e, &span sp, &ident i)\n@@ -1747,7 +1744,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_view_item_use =\n              bind identity_fold_view_item_use[ENV](_,_,_,_,_,_),\n          fold_view_item_import =\n-             bind identity_fold_view_item_import[ENV](_,_,_,_,_,_),\n+             bind identity_fold_view_item_import[ENV](_,_,_,_,_),\n          fold_view_item_export =\n              bind identity_fold_view_item_export[ENV](_,_,_),\n "}, {"sha": "eedff3bfcddac7dff7974e025447654777cc6fb8", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -513,7 +513,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n             encode_kind(ebml_w, 'm' as u8);\n             EBML.end_tag(ebml_w);\n         }\n-        case (ast.item_native_mod(_, _, ?did)) {\n+        case (ast.item_native_mod(?id, _, ?did)) {\n             EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'n' as u8);"}, {"sha": "92248ed919c5aa0aa8a551fe24d2a6c97e6d7d01", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 539, "deletions": 631, "changes": 1170, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -1,13 +1,15 @@\n import front.ast;\n import front.ast.ident;\n import front.ast.def;\n+import front.ast.def_id;\n import front.ast.ann;\n import front.creader;\n-import driver.session;\n+import driver.session.session;\n import util.common.new_def_hash;\n import util.common.span;\n import util.typestate_ann.ts_ann;\n import std.Map.hashmap;\n+import std.List;\n import std.List.list;\n import std.List.nil;\n import std.List.cons;\n@@ -17,787 +19,693 @@ import std.Option.none;\n import std.Str;\n import std.Vec;\n \n+// Resolving happens in two passes. The first pass collects defids of all\n+// (internal) imports and modules, so that they can be looked up when needed,\n+// and then uses this information to resolve the imports. The second pass\n+// locates all names (in expressions, types, and alt patterns) and resolves\n+// them, storing the resulting def in the AST nodes.\n+\n tag scope {\n     scope_crate(@ast.crate);\n     scope_item(@ast.item);\n     scope_native_item(@ast.native_item);\n-    scope_external_mod(ast.def_id, vec[ast.ident]);\n     scope_loop(@ast.decl); // there's only 1 decl per loop.\n     scope_block(ast.block);\n     scope_arm(ast.arm);\n }\n \n-type env = rec(list[scope] scopes,\n-               session.session sess);\n+tag wrap_mod {\n+    wmod(ast._mod);\n+    wnmod(ast.native_mod);\n+}\n+tag import_state {\n+    todo(@ast.view_item, list[scope]);\n+    resolving(span);\n+    resolved(Option.t[def] /* value */, Option.t[def] /* type */);\n+}\n+        \n+type env = rec(std.Map.hashmap[def_id,import_state] imports,\n+               std.Map.hashmap[def_id,@wrap_mod] mod_map,\n+               std.Map.hashmap[def_id,vec[ident]] ext_map,\n+               session sess);\n+\n+// Used to distinguish between lookups from outside and from inside modules,\n+// since export restrictions should only be applied for the former.\n+tag dir { inside; outside; }\n \n tag namespace {\n     ns_value;\n     ns_type;\n }\n \n-// This indicates whether we're searching up the scope chain or whether we've\n-// found a path component and started following it back down, which has an\n-// effect on export visibility\n-tag direction {\n-    up;\n-    down;\n-}\n-\n-type import_map = std.Map.hashmap[ast.def_id,def_wrap];\n-\n-// A simple wrapper over defs that stores a bit more information about modules\n-// and uses so that we can use the regular lookup_name when resolving imports.\n-tag def_wrap {\n-    def_wrap_use(@ast.view_item);\n-    def_wrap_import(@ast.view_item);\n-    def_wrap_mod(@ast.item);\n-    def_wrap_native_mod(@ast.item);\n-    def_wrap_external_mod(ast.def_id);\n-    def_wrap_external_native_mod(ast.def_id);\n-    def_wrap_other(def);\n-    def_wrap_expr_field(uint, def);\n-    def_wrap_resolving;\n+fn resolve_crate(session sess, @ast.crate crate) -> @ast.crate {\n+    auto e = @rec(imports = new_def_hash[import_state](),\n+                  mod_map = new_def_hash[@wrap_mod](),\n+                  ext_map = new_def_hash[vec[ident]](),\n+                  sess = sess);\n+    map_crate(e, *crate);\n+    resolve_imports(*e);\n+    ret resolve_names(e, *crate);\n }\n \n-fn unwrap_def(def_wrap d) -> def {\n-    alt (d) {\n-        case (def_wrap_use(?it)) {\n-            alt (it.node) {\n-                case (ast.view_item_use(_, _, ?id, _)) {\n-                    ret ast.def_use(id);\n-                }\n-            }\n-        }\n-        case (def_wrap_import(?it)) {\n-            alt (it.node) {\n-                case (ast.view_item_import(_, _, ?id, ?target_def)) {\n-                    alt (target_def) {\n-                        case (some[def](?d)) {\n-                            ret d;\n-                        }\n-                        case (none[def]) {\n-                            fail;\n-                        }\n-                    }\n-                }\n+// Locate all modules and imports and index them, so that the next passes can\n+// resolve through them.\n+\n+fn map_crate(&@env e, &ast.crate c) {\n+    auto cell = @mutable nil[scope];\n+    auto v = rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n+                 visit_crate_post = bind pop_env_for_crate(cell, _),\n+                 visit_view_item_pre = bind visit_view_item(e, cell, _),\n+                 visit_item_pre = bind push_env_for_item_map_mod(e, cell, _),\n+                 visit_item_post = bind pop_env_for_item(cell, _)\n+                 with walk.default_visitor());\n+    walk.walk_crate(v, c);\n+\n+    // Helpers for this pass.\n+    fn push_env_for_crate(@mutable list[scope] sc, &ast.crate c) {\n+        *sc = cons[scope](scope_crate(@c), @*sc);\n+    }\n+    fn pop_env_for_crate(@mutable list[scope] sc, &ast.crate c) {\n+        *sc = List.cdr(*sc);\n+    }\n+    fn push_env_for_item_map_mod(@env e, @mutable list[scope] sc,\n+                                 &@ast.item i) {\n+        *sc = cons[scope](scope_item(i), @*sc);\n+        alt (i.node) {\n+            case (ast.item_mod(_, ?md, ?defid)) {\n+                e.mod_map.insert(defid, @wmod(md));\n             }\n-        }\n-        case (def_wrap_mod(?m)) {\n-            alt (m.node) {\n-                case (ast.item_mod(_, _, ?id)) {\n-                    ret ast.def_mod(id);\n-                }\n+            case (ast.item_native_mod(_, ?nmd, ?defid)) {\n+                e.mod_map.insert(defid, @wnmod(nmd));\n             }\n+            case (_) {}\n         }\n-        case (def_wrap_native_mod(?m)) {\n-            alt (m.node) {\n-                case (ast.item_native_mod(_, _, ?id)) {\n-                    ret ast.def_native_mod(id);\n-                }\n+    }\n+    fn pop_env_for_item(@mutable list[scope] sc, &@ast.item i) {\n+        *sc = List.cdr(*sc);\n+    }\n+    fn visit_view_item(@env e, @mutable list[scope] sc, &@ast.view_item i) {\n+        alt (i.node) {\n+            case (ast.view_item_import(_, ?ids, ?defid)) {\n+                e.imports.insert(defid, todo(i, *sc));\n             }\n-        }\n-        case (def_wrap_external_mod(?mod_id)) {\n-            ret ast.def_mod(mod_id);\n-        }\n-        case (def_wrap_external_native_mod(?mod_id)) {\n-            ret ast.def_native_mod(mod_id);\n-        }\n-        case (def_wrap_other(?d)) {\n-            ret d;\n-        }\n-        case (def_wrap_expr_field(_, ?d)) {\n-            ret d;\n+            case (_) {}\n         }\n     }\n }\n \n-fn lookup_external_def(session.session sess, int cnum, vec[ident] idents)\n-        -> Option.t[def_wrap] {\n-    alt (creader.lookup_def(sess, cnum, idents)) {\n-        case (none[ast.def]) {\n-            ret none[def_wrap];\n-        }\n-        case (some[ast.def](?def)) {\n-            auto dw;\n-            alt (def) {\n-                case (ast.def_mod(?mod_id)) {\n-                    dw = def_wrap_external_mod(mod_id);\n-                }\n-                case (ast.def_native_mod(?mod_id)) {\n-                    dw = def_wrap_external_native_mod(mod_id);\n-                }\n-                case (_) {\n-                    dw = def_wrap_other(def);\n-                }\n+fn resolve_imports(&env e) {\n+    for each (@tup(def_id, import_state) it in e.imports.items()) {\n+        alt (it._1) {\n+            case (todo(?item, ?sc)) {\n+                resolve_import(e, item, sc);\n             }\n-            ret some[def_wrap](dw);\n+            case (resolved(_, _)) {}\n         }\n     }\n }\n \n-// Follow the path of an import and return what it ultimately points to.\n-\n-// If used after imports are resolved, import_id is none.\n-\n-fn find_final_def(&env e, import_map index,\n-                  &span sp, vec[ident] idents, namespace ns,\n-                  Option.t[ast.def_id] import_id) -> def_wrap {\n-\n-    // We are given a series of identifiers (p.q.r) and we know that\n-    // in the environment 'e' the identifier 'p' was resolved to 'd'. We\n-    // should return what p.q.r points to in the end.\n-    fn found_something(&env e, import_map index,\n-                       &span sp, vec[ident] idents, namespace ns,\n-                       def_wrap d) -> def_wrap {\n-\n-        fn found_mod(&env e, &import_map index, &span sp,\n-                     vec[ident] idents, namespace ns,\n-                     @ast.item i) -> def_wrap {\n-            auto len = Vec.len[ident](idents);\n-            auto rest_idents = Vec.slice[ident](idents, 1u, len);\n-            auto empty_e = rec(scopes = nil[scope],\n-                               sess = e.sess);\n-            auto tmp_e = update_env_for_item(empty_e, i);\n-            auto next_i = rest_idents.(0);\n-            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns, down);\n-            alt (next_) {\n-                case (none[tup(@env, def_wrap)]) {\n-                    e.sess.span_err(sp, \"unresolved name: \" + next_i);\n-                    fail;\n-                }\n-                case (some[tup(@env, def_wrap)](?next)) {\n-                    auto combined_e = update_env_for_item(e, i);\n-                    ret found_something(combined_e, index, sp,\n-                                        rest_idents, ns, next._1);\n-                }\n-            }\n-        }\n-\n-        // TODO: Refactor with above.\n-        fn found_external_mod(&env e, &import_map index, &span sp,\n-                              vec[ident] idents, namespace ns,\n-                              ast.def_id mod_id)\n-                -> def_wrap {\n-            auto len = Vec.len[ident](idents);\n-            auto rest_idents = Vec.slice[ident](idents, 1u, len);\n-            auto empty_e = rec(scopes = nil[scope],\n-                               sess = e.sess);\n-            auto tmp_e = update_env_for_external_mod(empty_e, mod_id, idents);\n-            auto next_i = rest_idents.(0);\n-            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns, down);\n-            alt (next_) {\n-                case (none[tup(@env, def_wrap)]) {\n-                    e.sess.span_err(sp, \"unresolved name: \" + next_i);\n-                    fail;\n-                }\n-                case (some[tup(@env, def_wrap)](?next)) {\n-                    auto combined_e = update_env_for_external_mod(e,\n-                                                                  mod_id,\n-                                                                  idents);\n-                    ret found_something(combined_e, index, sp,\n-                                        rest_idents, ns, next._1);\n-                }\n-            }\n-        }\n-\n-        fn found_crate(&env e, &import_map index, &span sp,\n-                       vec[ident] idents, int cnum) -> def_wrap {\n-            auto len = Vec.len[ident](idents);\n-            auto rest_idents = Vec.slice[ident](idents, 1u, len);\n-            alt (lookup_external_def(e.sess, cnum, rest_idents)) {\n-                case (none[def_wrap]) {\n-                    e.sess.span_err(sp, #fmt(\"unbound name '%s'\",\n-                                             Str.connect(idents, \".\")));\n-                    fail;\n-                }\n-                case (some[def_wrap](?dw)) { ret dw; }\n-            }\n-        }\n-\n-        alt (d) {\n-            case (def_wrap_import(?imp)) {\n-                alt (imp.node) {\n-                    case (ast.view_item_import(_, ?new_idents, ?d, _)) {\n-                        auto x = find_final_def(e, index, sp, new_idents, ns,\n-                                                some(d));\n-                        ret found_something(e, index, sp, idents, ns, x);\n-                    }\n-                }\n-            }\n-            case (_) {\n-            }\n-        }\n-        auto len = Vec.len[ident](idents);\n-        if (len == 1u) {\n-            ret d;\n-        }\n-        alt (d) {\n-            case (def_wrap_mod(?i)) {\n-                ret found_mod(e, index, sp, idents, ns, i);\n-            }\n-            case (def_wrap_native_mod(?i)) {\n-                ret found_mod(e, index, sp, idents, ns, i);\n-            }\n-            case (def_wrap_external_mod(?mod_id)) {\n-                ret found_external_mod(e, index, sp, idents, ns, mod_id);\n-            }\n-            case (def_wrap_external_native_mod(?mod_id)) {\n-                ret found_external_mod(e, index, sp, idents, ns, mod_id);\n-            }\n-            case (def_wrap_use(?vi)) {\n-                alt (vi.node) {\n-                    case (ast.view_item_use(_, _, _, ?cnum_opt)) {\n-                        auto cnum = Option.get[int](cnum_opt);\n-                        ret found_crate(e, index, sp, idents, cnum);\n-                    }\n-                }\n+fn resolve_names(&@env e, &ast.crate c) -> @ast.crate {\n+    auto fld = @rec(fold_pat_tag = bind fold_pat_tag(e,_,_,_,_,_,_),\n+                    fold_expr_path = bind fold_expr_path(e,_,_,_,_,_),\n+                    fold_ty_path = bind fold_ty_path(e,_,_,_,_),\n+                    update_env_for_crate = bind update_env_for_crate(_,_),\n+                    update_env_for_item = bind update_env_for_item(_,_),\n+                    update_env_for_native_item =\n+                       bind update_env_for_native_item(_,_),\n+                    update_env_for_block = bind update_env_for_block(_,_),\n+                    update_env_for_arm = bind update_env_for_arm(_,_),\n+                    update_env_for_expr = bind update_env_for_expr(_,_)\n+                    with *fold.new_identity_fold[list[scope]]());\n+    ret fold.fold_crate(nil[scope], fld, @c);\n+\n+    // Helpers for this pass\n+\n+    fn update_env_for_crate(&list[scope] sc, &@ast.crate c) -> list[scope] {\n+        ret cons[scope](scope_crate(c), @sc);\n+    }\n+    fn update_env_for_item(&list[scope] sc, &@ast.item i) -> list[scope] {\n+        ret cons[scope](scope_item(i), @sc);\n+    }\n+    fn update_env_for_native_item(&list[scope] sc, &@ast.native_item i)\n+        -> list[scope] {\n+        ret cons[scope](scope_native_item(i), @sc);\n+    }\n+    fn update_env_for_block(&list[scope] sc, &ast.block b) -> list[scope] {\n+        ret cons[scope](scope_block(b), @sc);\n+    }\n+    fn update_env_for_expr(&list[scope] sc, &@ast.expr x) -> list[scope] {\n+        alt (x.node) {\n+            case (ast.expr_for(?d, _, _, _)) {\n+                ret cons[scope](scope_loop(d), @sc);\n             }\n-            case (def_wrap_other(?d)) {\n-                let uint l = Vec.len[ident](idents);\n-                ret def_wrap_expr_field(l, d);\n+            case (ast.expr_for_each(?d, _, _, _)) {\n+                ret cons[scope](scope_loop(d), @sc);\n             }\n+            case (_) { ret sc; }\n         }\n-        fail;\n     }\n+    fn update_env_for_arm(&list[scope] sc, &ast.arm p) -> list[scope] {\n+        ret cons[scope](scope_arm(p), @sc);\n+    }\n+}\n \n-    if (import_id != none[ast.def_id]) {\n-        alt (index.find(Option.get[ast.def_id](import_id))) {\n-            case (some[def_wrap](?x)) {\n-                alt (x) {\n-                    case (def_wrap_resolving) {\n-                        e.sess.span_err(sp, \"cyclic import\");\n-                        fail;\n-                    }\n-                    case (_) {\n-                        ret x;\n-                    }\n-                }\n-            }\n-            case (none[def_wrap]) {\n-            }\n+fn lookup_import(&env e, def_id defid, namespace ns) -> Option.t[def] {\n+    alt (e.imports.get(defid)) {\n+        case (todo(?item, ?sc)) {\n+            resolve_import(e, item, sc);\n+            ret lookup_import(e, defid, ns);\n         }\n-        index.insert(Option.get[ast.def_id](import_id), def_wrap_resolving);\n-    }\n-    auto first = idents.(0);\n-    auto d_ = lookup_name_wrapped(e, first, ns, up);\n-    alt (d_) {\n-        case (none[tup(@env, def_wrap)]) {\n-            e.sess.span_err(sp, \"unresolved name: \" + first);\n-            fail;\n+        case (resolving(?sp)) {\n+            e.sess.span_err(sp, \"cyclic import\");\n         }\n-        case (some[tup(@env, def_wrap)](?d)) {\n-            auto x = found_something(*d._0, index, sp, idents, ns, d._1);\n-            if (import_id != none[ast.def_id]) {\n-                index.insert(Option.get[ast.def_id](import_id), x);\n-            }\n-            ret x;\n+        case (resolved(?val, ?typ)) {\n+            ret alt (ns) { case (ns_value) { val }\n+                           case (ns_type) { typ } };\n         }\n     }\n }\n \n-fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n-    -> Option.t[tup(@env, def_wrap)] {\n-\n-    // log \"resolving name \" + i;\n-\n-    fn found_def_item(@ast.item i, namespace ns) -> def_wrap {\n-        alt (i.node) {\n-            case (ast.item_const(_, _, _, ?id, _)) {\n-                ret def_wrap_other(ast.def_const(id));\n-            }\n-            case (ast.item_fn(_, _, _, ?id, _)) {\n-                ret def_wrap_other(ast.def_fn(id));\n-            }\n-            case (ast.item_mod(_, _, ?id)) {\n-                ret def_wrap_mod(i);\n-            }\n-            case (ast.item_native_mod(_, _, ?id)) {\n-                ret def_wrap_native_mod(i);\n-            }\n-            case (ast.item_ty(_, _, _, ?id, _)) {\n-                ret def_wrap_other(ast.def_ty(id));\n-            }\n-            case (ast.item_tag(_, _, _, ?id, _)) {\n-                ret def_wrap_other(ast.def_ty(id));\n-            }\n-            case (ast.item_obj(_, _, _, ?odid, _)) {\n-                alt (ns) {\n-                    case (ns_value) {\n-                        ret def_wrap_other(ast.def_obj(odid.ctor));\n-                    }\n-                    case (ns_type) {\n-                        ret def_wrap_other(ast.def_obj(odid.ty));\n-                    }\n-                }\n-            }\n+fn resolve_import(&env e, &@ast.view_item it, &list[scope] sc) {\n+    auto defid; auto ids;\n+    alt (it.node) {\n+        case (ast.view_item_import(_, ?_ids, ?_defid)) {\n+            defid = _defid; ids = _ids;\n         }\n     }\n-\n-    fn found_def_native_item(@ast.native_item i) -> def_wrap {\n-        alt (i.node) {\n-            case (ast.native_item_ty(_, ?id)) {\n-                ret def_wrap_other(ast.def_native_ty(id));\n-            }\n-            case (ast.native_item_fn(_, _, _, _, ?id, _)) {\n-                ret def_wrap_other(ast.def_native_fn(id));\n+    e.imports.insert(defid, resolving(it.span));\n+    \n+    auto n_idents = Vec.len(ids);\n+    auto end_id = ids.(n_idents - 1u);\n+\n+    if (n_idents == 1u) {\n+        register(e, defid, it.span, end_id,\n+                 lookup_in_scope(e, sc, end_id, ns_value),\n+                 lookup_in_scope(e, sc, end_id, ns_type));\n+    } else {\n+        auto dcur = lookup_in_scope_strict(e, sc, it.span, ids.(0), ns_value);\n+        auto i = 1u;\n+        while (true) {\n+            if (!is_module(dcur)) {\n+                e.sess.span_err(it.span, ids.(i-1u) +\n+                                \" is not a module or crate\");\n+            }\n+            if (i == n_idents - 1u) {\n+                register(e, defid, it.span, end_id,\n+                         lookup_in_mod(e, dcur, end_id, ns_value, outside),\n+                         lookup_in_mod(e, dcur, end_id, ns_type, outside));\n+                break;\n+            } else {\n+                dcur = lookup_in_mod_strict(e, dcur, it.span, ids.(i),\n+                                            ns_value, outside);\n+                i += 1u;\n             }\n         }\n     }\n \n-    fn found_def_view(@ast.view_item i) -> def_wrap {\n-        alt (i.node) {\n-            case (ast.view_item_use(_, _, ?id, _)) {\n-                ret def_wrap_use(i);\n-            }\n-            case (ast.view_item_import(_, ?idents,?d, _)) {\n-                ret def_wrap_import(i);\n-            }\n+    fn register(&env e, def_id defid, &span sp, ident id,\n+                Option.t[def] val, Option.t[def] typ) {\n+        if (val == none[def] && typ == none[def]) {\n+            unresolved(e, sp, id, \"import\");\n         }\n-        fail;\n+        e.imports.insert(defid, resolved(val, typ));\n     }\n+}\n \n-    fn check_mod(ast.ident i, ast._mod m, namespace ns,\n-                 direction dir) -> Option.t[def_wrap] {\n-\n-        fn visible(ast.ident i, ast._mod m, direction dir) -> bool {\n+// We received a path expression of the following form:\n+//\n+//     a.b.c.d\n+//\n+// Somewhere along this path there might be a split from a path-expr\n+// to a runtime field-expr. For example:\n+//\n+//     'a' could be the name of a variable in the local scope\n+//     and 'b.c.d' could be a field-sequence inside it.\n+//\n+// Or:\n+//\n+//     'a.b' could be a module path to a constant record, and 'c.d'\n+//     could be a field within it.\n+//\n+// Our job here is to figure out what the prefix of 'a.b.c.d' is that\n+// corresponds to a static binding-name (a module or slot, with no type info)\n+// and split that off as the 'primary' expr_path, with secondary expr_field\n+// expressions tacked on the end.\n \n-            alt (dir) {\n-                case (up) {\n-                    ret true;\n-                }\n-                case (down) {\n-                    // fall through\n-                }\n-            }\n+fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n+                  &Option.t[def] d, &ann a) -> @ast.expr {\n+    auto idents = p.node.idents;\n+    auto n_idents = Vec.len(idents);\n+    assert (n_idents != 0u);\n \n-            ret ast.is_exported(i, m);\n-        }\n+    auto dcur = lookup_in_scope_strict(*e, sc, sp, idents.(0), ns_value);\n+    auto i = 1u;\n+    while (i < n_idents) {\n+        if (!is_module(dcur)) { break; }\n+        dcur = lookup_in_mod_strict(*e, dcur, sp, idents.(i), ns_value,\n+                                    outside);\n+        i += 1u;\n+    }\n+    if (is_module(dcur)) {\n+        e.sess.span_err(sp, \"can't refer to a module as a first-class value\");\n+    }\n \n-        alt (m.index.find(i)) {\n-            case (some[ast.mod_index_entry](?ent)) {\n-                alt (ent) {\n-                    case (ast.mie_view_item(?view_item)) {\n-                        ret some(found_def_view(view_item));\n-                    }\n-                    case (ast.mie_item(?item)) {\n-                        if (visible(i, m, dir)) {\n-                            ret some(found_def_item(item, ns));\n-                        } else {\n-                            ret none[def_wrap];\n-                        }\n-                    }\n-                    case (ast.mie_tag_variant(?item, ?variant_idx)) {\n-                        alt (item.node) {\n-                            case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n-                                if (visible(i, m, dir)) {\n-                                    auto vid = variants.(variant_idx).node.id;\n-                                    auto t = ast.def_variant(tid, vid);\n-                                    ret some[def_wrap](def_wrap_other(t));\n-                                } else {\n-                                    ret none[def_wrap];\n-                                }\n-                            }\n-                            case (_) {\n-                                log_err \"tag item not actually a tag\";\n-                                fail;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            case (none[ast.mod_index_entry]) {\n-                ret none[def_wrap];\n-            }\n-        }\n+    p = rec(node=rec(idents=Vec.slice(idents, 0u, i) with p.node) with p);\n+    auto ex = @fold.respan(sp, ast.expr_path(p, some(dcur), a));\n+    while (i < n_idents) {\n+        ex = @fold.respan(sp, ast.expr_field(ex, idents.(i), a));\n+        i += 1u;\n     }\n+    ret ex;\n+}\n \n-    fn check_native_mod(ast.ident i, ast.native_mod m) -> Option.t[def_wrap] {\n \n-        alt (m.index.find(i)) {\n-            case (some[ast.native_mod_index_entry](?ent)) {\n-                alt (ent) {\n-                    case (ast.nmie_view_item(?view_item)) {\n-                        ret some(found_def_view(view_item));\n-                    }\n-                    case (ast.nmie_item(?item)) {\n-                        ret some(found_def_native_item(item));\n-                    }\n-                }\n-            }\n-            case (none[ast.native_mod_index_entry]) {\n-                ret none[def_wrap];\n-            }\n+fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n+                      namespace ns) -> def {\n+    auto n_idents = Vec.len(idents);\n+    auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), ns);\n+    auto i = 1u;\n+    while (i < n_idents) {\n+        if (!is_module(dcur)) {\n+            e.sess.span_err(sp, idents.(i-1u) +\n+                            \" can't be dereferenced as a module\");\n         }\n+        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), ns, outside);\n+        i += 1u;\n     }\n-\n-    fn handle_fn_decl(ast.ident identifier, &ast.fn_decl decl,\n-                      &vec[ast.ty_param] ty_params) -> Option.t[def_wrap] {\n-        for (ast.arg a in decl.inputs) {\n-            if (Str.eq(a.ident, identifier)) {\n-                auto t = ast.def_arg(a.id);\n-                ret some(def_wrap_other(t));\n-            }\n+    if (is_module(dcur)) {\n+        e.sess.span_err(sp, Str.connect(idents, \".\") +\n+                        \" is a module, not a \" + ns_name(ns));\n+    }\n+    ret dcur;\n+}\n+                      \n+fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast.path p,\n+                &vec[@ast.pat] args, &Option.t[ast.variant_def] old_def,\n+                &ann a) -> @ast.pat {\n+    alt (lookup_path_strict(*e, sc, sp, p.node.idents, ns_value)) {\n+        case (ast.def_variant(?did, ?vid)) {\n+            auto new_def = some[ast.variant_def](tup(did, vid));\n+            ret @fold.respan[ast.pat_](sp, ast.pat_tag(p, args, new_def, a));\n         }\n-\n-        auto i = 0u;\n-        for (ast.ty_param tp in ty_params) {\n-            if (Str.eq(tp, identifier)) {\n-                auto t = ast.def_ty_arg(i);\n-                ret some(def_wrap_other(t));\n-            }\n-            i += 1u;\n+        case (_) {\n+            e.sess.span_err(sp, \"not a tag variant: \" +\n+                            Str.connect(p.node.idents, \".\"));\n+            fail;\n         }\n-        ret none[def_wrap];\n     }\n+}\n \n-    fn found_tag(@ast.item item, uint variant_idx) -> def_wrap {\n-        alt (item.node) {\n-            case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n-                auto vid = variants.(variant_idx).node.id;\n-                auto t = ast.def_variant(tid, vid);\n-                ret def_wrap_other(t);\n-            }\n-            case (_) {\n-                log_err \"tag item not actually a tag\";\n-                fail;\n-            }\n-        }\n+fn fold_ty_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n+                &Option.t[def] d) -> @ast.ty {\n+    auto new_def = lookup_path_strict(*e, sc, sp, p.node.idents, ns_type);\n+    ret @fold.respan[ast.ty_](sp, ast.ty_path(p, some(new_def)));\n+}\n+\n+fn is_module(def d) -> bool {\n+    alt (d) {\n+        case (ast.def_mod(_)) { ret true; }\n+        case (ast.def_native_mod(_)) { ret true; }\n+        case (_) { ret false; }\n     }\n+}\n \n-    fn check_block(ast.ident i, &ast.block_ b, namespace ns)\n-            -> Option.t[def_wrap] {\n-        alt (b.index.find(i)) {\n-            case (some[ast.block_index_entry](?ix)) {\n-                alt(ix) {\n-                    case (ast.bie_item(?it)) {\n-                        ret some(found_def_item(it, ns));\n-                    }\n-                    case (ast.bie_local(?l)) {\n-                        auto t = ast.def_local(l.id);\n-                        ret some(def_wrap_other(t));\n-                    }\n-                    case (ast.bie_tag_variant(?item, ?variant_idx)) {\n-                        ret some(found_tag(item, variant_idx));\n-                    }\n-                }\n-            }\n-            case (_) { ret none[def_wrap]; }\n+fn ns_name(namespace ns) -> str {\n+    alt (ns) {\n+        case (ns_type) { ret \"typename\"; }\n+        case (ns_value) { ret \"name\"; }\n+    }\n+}\n+\n+fn unresolved(&env e, &span sp, ident id, str kind) {\n+    e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n+}\n+\n+fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, ident id,\n+                        namespace ns) -> def {\n+    alt (lookup_in_scope(e, sc, id, ns)) {\n+        case (none[def]) {\n+            unresolved(e, sp, id, ns_name(ns));\n+            fail;\n+        }\n+        case (some[def](?d)) {\n+            ret d;\n         }\n     }\n+}\n \n-    fn in_scope(&session.session sess, ast.ident identifier, &scope s,\n-                namespace ns, direction dir) -> Option.t[def_wrap] {\n+fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n+    -> Option.t[def] {\n+    fn in_scope(&env e, ident id, &scope s, namespace ns)\n+        -> Option.t[def] {\n         alt (s) {\n-\n             case (scope_crate(?c)) {\n-                ret check_mod(identifier, c.node.module, ns, dir);\n+                ret lookup_in_regular_mod(e, c.node.module, id, ns, inside);\n             }\n-\n             case (scope_item(?it)) {\n                 alt (it.node) {\n                     case (ast.item_fn(_, ?f, ?ty_params, _, _)) {\n-                        ret handle_fn_decl(identifier, f.decl, ty_params);\n+                        ret lookup_in_fn(id, f.decl, ty_params, ns);\n                     }\n                     case (ast.item_obj(_, ?ob, ?ty_params, _, _)) {\n-                        for (ast.obj_field f in ob.fields) {\n-                            if (Str.eq(f.ident, identifier)) {\n-                                auto t = ast.def_obj_field(f.id);\n-                                ret some(def_wrap_other(t));\n-                            }\n-                        }\n-\n-                        auto i = 0u;\n-                        for (ast.ty_param tp in ty_params) {\n-                            if (Str.eq(tp, identifier)) {\n-                                auto t = ast.def_ty_arg(i);\n-                                ret some(def_wrap_other(t));\n-                            }\n-                            i += 1u;\n-                        }\n+                        ret lookup_in_obj(id, ob, ty_params, ns);\n                     }\n-                    case (ast.item_tag(_,?variants,?ty_params,?tag_id,_)) {\n-                        auto i = 0u;\n-                        for (ast.ty_param tp in ty_params) {\n-                            if (Str.eq(tp, identifier)) {\n-                                auto t = ast.def_ty_arg(i);\n-                                ret some(def_wrap_other(t));\n-                            }\n-                            i += 1u;\n+                    case (ast.item_tag(_, _, ?ty_params, _, _)) {\n+                        if (ns == ns_type) {\n+                            ret lookup_in_ty_params(id, ty_params);\n                         }\n                     }\n                     case (ast.item_mod(_, ?m, _)) {\n-                        ret check_mod(identifier, m, ns, dir);\n+                        ret lookup_in_regular_mod(e, m, id, ns, inside);\n                     }\n                     case (ast.item_native_mod(_, ?m, _)) {\n-                        ret check_native_mod(identifier, m);\n+                        ret lookup_in_native_mod(e, m, id, ns);\n                     }\n                     case (ast.item_ty(_, _, ?ty_params, _, _)) {\n-                        auto i = 0u;\n-                        for (ast.ty_param tp in ty_params) {\n-                            if (Str.eq(tp, identifier)) {\n-                                auto t = ast.def_ty_arg(i);\n-                                ret some(def_wrap_other(t));\n-                            }\n-                            i += 1u;\n+                        if (ns == ns_type) {\n+                            ret lookup_in_ty_params(id, ty_params);\n                         }\n                     }\n-                    case (_) { /* fall through */ }\n+                    case (_) {}\n                 }\n             }\n \n             case (scope_native_item(?it)) {\n                 alt (it.node) {\n                     case (ast.native_item_fn(_, _, ?decl, ?ty_params, _, _)) {\n-                        ret handle_fn_decl(identifier, decl, ty_params);\n+                        ret lookup_in_fn(id, decl, ty_params, ns);\n                     }\n                 }\n             }\n \n-            case (scope_external_mod(?mod_id, ?path)) {\n-                ret lookup_external_def(sess, mod_id._0, path);\n-            }\n-\n             case (scope_loop(?d)) {\n-                alt (d.node) {\n-                    case (ast.decl_local(?local)) {\n-                        if (Str.eq(local.ident, identifier)) {\n-                            auto lc = ast.def_local(local.id);\n-                            ret some(def_wrap_other(lc));\n+                if (ns == ns_value) {\n+                    alt (d.node) {\n+                        case (ast.decl_local(?local)) {\n+                            if (Str.eq(local.ident, id)) {\n+                                ret some(ast.def_local(local.id));\n+                            }\n                         }\n                     }\n                 }\n             }\n \n             case (scope_block(?b)) {\n-                ret check_block(identifier, b.node, ns);\n+                ret lookup_in_block(id, b.node, ns);\n             }\n \n             case (scope_arm(?a)) {\n-                alt (a.index.find(identifier)) {\n-                    case (some[ast.def_id](?did)) {\n-                        auto t = ast.def_binding(did);\n-                        ret some[def_wrap](def_wrap_other(t));\n+                if (ns == ns_value) {\n+                    alt (a.index.find(id)) {\n+                        case (some[def_id](?did)) {\n+                            ret some(ast.def_binding(did));\n+                        }\n+                        case (_) {}\n                     }\n-                    case (_) { /* fall through */  }\n                 }\n             }\n         }\n-        ret none[def_wrap];\n+        ret none[def];\n     }\n \n-    alt (e.scopes) {\n-        case (nil[scope]) {\n-            ret none[tup(@env, def_wrap)];\n-        }\n-        case (cons[scope](?hd, ?tl)) {\n-            auto x = in_scope(e.sess, i, hd, ns, dir);\n-            alt (x) {\n-                case (some[def_wrap](?x)) {\n-                    ret some(tup(@e, x));\n-                }\n-                case (none[def_wrap]) {\n-                    auto outer_env = rec(scopes = *tl with e);\n-                    ret lookup_name_wrapped(outer_env, i, ns, up);\n+    while (true) {\n+        alt (sc) {\n+            case (nil[scope]) {\n+                ret none[def];\n+            }\n+            case (cons[scope](?hd, ?tl)) {\n+                alt (in_scope(e, id, hd, ns)) {\n+                    case (some[def](?x)) { ret some(x); }\n+                    case (_) { sc = *tl; }\n                 }\n             }\n         }\n     }\n }\n \n-fn fold_pat_tag(&env e, &span sp, &ast.path p, &vec[@ast.pat] args,\n-                &Option.t[ast.variant_def] old_def,\n-                &ann a) -> @ast.pat {\n-    auto len = Vec.len[ast.ident](p.node.idents);\n-    auto last_id = p.node.idents.(len - 1u);\n-    auto new_def;\n-    auto index = new_def_hash[def_wrap]();\n-    auto d = find_final_def(e, index, sp, p.node.idents, ns_value,\n-                            none[ast.def_id]);\n-    alt (unwrap_def(d)) {\n-        case (ast.def_variant(?did, ?vid)) {\n-            new_def = some[ast.variant_def](tup(did, vid));\n-        }\n-        case (_) {\n-            e.sess.span_err(sp, \"not a tag variant: \" + last_id);\n-            new_def = none[ast.variant_def];\n+fn lookup_in_ty_params(ident id, &vec[ast.ty_param] ty_params)\n+    -> Option.t[def] {\n+    auto i = 0u;\n+    for (ast.ty_param tp in ty_params) {\n+        if (Str.eq(tp, id)) {\n+            ret some(ast.def_ty_arg(i));\n         }\n+        i += 1u;\n     }\n+    ret none[def];\n+}\n \n-    ret @fold.respan[ast.pat_](sp, ast.pat_tag(p, args, new_def, a));\n+fn lookup_in_fn(ident id, &ast.fn_decl decl,\n+                &vec[ast.ty_param] ty_params, namespace ns) -> Option.t[def] {\n+    if (ns == ns_value) {\n+        for (ast.arg a in decl.inputs) {\n+            if (Str.eq(a.ident, id)) {\n+                ret some(ast.def_arg(a.id));\n+            }\n+        }\n+        ret none[def];\n+    } else {\n+        ret lookup_in_ty_params(id, ty_params);\n+    }\n }\n \n-// We received a path expression of the following form:\n-//\n-//     a.b.c.d\n-//\n-// Somewhere along this path there might be a split from a path-expr\n-// to a runtime field-expr. For example:\n-//\n-//     'a' could be the name of a variable in the local scope\n-//     and 'b.c.d' could be a field-sequence inside it.\n-//\n-// Or:\n-//\n-//     'a.b' could be a module path to a constant record, and 'c.d'\n-//     could be a field within it.\n-//\n-// Our job here is to figure out what the prefix of 'a.b.c.d' is that\n-// corresponds to a static binding-name (a module or slot, with no type info)\n-// and split that off as the 'primary' expr_path, with secondary expr_field\n-// expressions tacked on the end.\n+fn lookup_in_obj(ident id, &ast._obj ob, &vec[ast.ty_param] ty_params,\n+                 namespace ns) -> Option.t[def] {\n+    if (ns == ns_value) {\n+        for (ast.obj_field f in ob.fields) {\n+            if (Str.eq(f.ident, id)) {\n+                ret some(ast.def_obj_field(f.id));\n+            }\n+        }\n+        ret none[def];\n+    } else {\n+        ret lookup_in_ty_params(id, ty_params);\n+    }\n+}\n \n-fn fold_expr_path(&env e, &span sp, &ast.path p, &Option.t[def] d,\n-                  &ann a) -> @ast.expr {\n-    auto n_idents = Vec.len[ast.ident](p.node.idents);\n-    assert (n_idents != 0u);\n+fn lookup_in_block(ident id, &ast.block_ b, namespace ns)\n+    -> Option.t[def] {\n+    alt (b.index.find(id)) {\n+        case (some[ast.block_index_entry](?ix)) {\n+            alt (ix) {\n+                case (ast.bie_item(?it)) {\n+                    ret found_def_item(it, ns);\n+                }\n+                case (ast.bie_local(?l)) {\n+                    if (ns == ns_value) {\n+                        ret some(ast.def_local(l.id));\n+                    }\n+                }\n+                case (ast.bie_tag_variant(?item, ?variant_idx)) {\n+                    if (ns == ns_value) {\n+                        ret some(found_def_tag(item, variant_idx));\n+                    }\n+                }\n+            }\n+        }\n+        case (_) { }\n+    }\n+    ret none[def];\n+}\n \n-    auto index = new_def_hash[def_wrap]();\n-    auto d = find_final_def(e, index, sp, p.node.idents, ns_value,\n-                            none[ast.def_id]);\n-    let uint path_len = 0u;\n-    alt (d) {\n-        case (def_wrap_expr_field(?remaining, _)) {\n-            path_len = n_idents - remaining + 1u;\n+fn found_def_item(@ast.item i, namespace ns) -> Option.t[def] {\n+    alt (i.node) {\n+        case (ast.item_const(_, _, _, ?id, _)) {\n+            if (ns == ns_value) {\n+                ret some(ast.def_const(id));\n+            }\n         }\n-        case (def_wrap_other(_)) {\n-            path_len = n_idents;\n+        case (ast.item_fn(_, _, _, ?id, _)) {\n+            if (ns == ns_value) {\n+                ret some(ast.def_fn(id));\n+            }\n         }\n-        case (def_wrap_mod(?m)) {\n-            e.sess.span_err(sp,\n-                            \"can't refer to a module as a first-class value\");\n-            fail;\n+        case (ast.item_mod(_, _, ?id)) {\n+            ret some(ast.def_mod(id));\n         }\n+        case (ast.item_native_mod(_, _, ?id)) {\n+            ret some(ast.def_native_mod(id));\n+        }\n+        case (ast.item_ty(_, _, _, ?id, _)) {\n+            if (ns == ns_type) {\n+                ret some(ast.def_ty(id));\n+            }\n+        }\n+        case (ast.item_tag(_, _, _, ?id, _)) {\n+            if (ns == ns_type) {\n+                ret some(ast.def_ty(id));\n+            }\n+        }\n+        case (ast.item_obj(_, _, _, ?odid, _)) {\n+            if (ns == ns_value) {\n+                ret some(ast.def_obj(odid.ctor));\n+            } else {\n+                ret some(ast.def_obj(odid.ty));\n+            }\n+        }\n+        case (_) { }\n     }\n-    auto path_elems =\n-        Vec.slice[ident](p.node.idents, 0u, path_len);\n-    auto p_ = rec(node=rec(idents = path_elems with p.node) with p);\n-    auto d_ = some(unwrap_def(d));\n-    auto ex = @fold.respan[ast.expr_](sp, ast.expr_path(p_, d_, a));\n-    auto i = path_len;\n-    while (i < n_idents) {\n-        auto id = p.node.idents.(i);\n-        ex = @fold.respan[ast.expr_](sp, ast.expr_field(ex, id, a));\n-        i += 1u;\n-    }\n-    ret ex;\n+    ret none[def];\n }\n \n-fn fold_view_item_import(&env e, &span sp,\n-                         &import_map index, &ident i,\n-                         &vec[ident] is, &ast.def_id id,\n-                         &Option.t[def] target_id) -> @ast.view_item {\n-    // Produce errors for invalid imports\n-    auto len = Vec.len[ast.ident](is);\n-    auto last_id = is.(len - 1u);\n-    auto d = find_final_def(e, index, sp, is, ns_value, some(id));\n-    alt (d) {\n-        case (def_wrap_expr_field(?remain, _)) {\n-            auto ident = is.(len - remain);\n-            e.sess.span_err(sp, ident + \" is not a module or crate\");\n+fn found_def_tag(@ast.item item, uint variant_idx) -> def {\n+    alt (item.node) {\n+        case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n+            auto vid = variants.(variant_idx).node.id;\n+            ret ast.def_variant(tid, vid);\n         }\n         case (_) {\n+            log_err \"tag item not actually a tag\";\n+            fail;\n         }\n     }\n-    let Option.t[def] target_def = some(unwrap_def(d));\n-    ret @fold.respan[ast.view_item_](sp, ast.view_item_import(i, is, id,\n-                                                              target_def));\n-}\n-\n-fn fold_ty_path(&env e, &span sp, &ast.path p, &Option.t[def] d) -> @ast.ty {\n-    auto index = new_def_hash[def_wrap]();\n-    auto d = find_final_def(e, index, sp, p.node.idents, ns_type,\n-                            none[ast.def_id]);\n-\n-    ret @fold.respan[ast.ty_](sp, ast.ty_path(p, some(unwrap_def(d))));\n-}\n-\n-fn update_env_for_crate(&env e, &@ast.crate c) -> env {\n-    ret rec(scopes = cons[scope](scope_crate(c), @e.scopes) with e);\n-}\n-\n-fn update_env_for_item(&env e, &@ast.item i) -> env {\n-    ret rec(scopes = cons[scope](scope_item(i), @e.scopes) with e);\n-}\n-\n-fn update_env_for_native_item(&env e, &@ast.native_item i) -> env {\n-    ret rec(scopes = cons[scope](scope_native_item(i), @e.scopes) with e);\n }\n \n-// Not actually called by fold, but here since this is analogous to\n-// update_env_for_item() above and is called by find_final_def().\n-fn update_env_for_external_mod(&env e, &ast.def_id mod_id,\n-                               &vec[ast.ident] idents) -> env {\n-    ret rec(scopes = cons[scope](scope_external_mod(mod_id, idents),\n-                                 @e.scopes)\n-            with e);\n+fn lookup_in_mod_strict(&env e, def m, &span sp, ident id,\n+                        namespace ns, dir dr) -> def {\n+    alt (lookup_in_mod(e, m, id, ns, dr)) {\n+        case (none[def]) {\n+            unresolved(e, sp, id, ns_name(ns));\n+            fail;\n+        }\n+        case (some[def](?d)) {\n+            ret d;\n+        }\n+    }\n }\n \n-fn update_env_for_block(&env e, &ast.block b) -> env {\n-    ret rec(scopes = cons[scope](scope_block(b), @e.scopes) with e);\n+fn lookup_in_mod(&env e, def m, ident id, namespace ns, dir dr)\n+    -> Option.t[def] {\n+    auto defid = ast.def_id_of_def(m);\n+    // FIXME this causes way more metadata lookups than needed. Cache?\n+    if (defid._0 != 0) { // Not in this crate (FIXME use a const, not 0)\n+        auto path = vec(id);\n+        // def_num=-1 is a kludge to overload def_mod for external crates,\n+        // since those don't get a def num\n+        if (defid._1 != -1) {\n+            path = e.ext_map.get(defid) + path;\n+        }\n+        ret lookup_external(e, defid._0, path, ns);\n+    }\n+    alt (m) {\n+        case (ast.def_mod(?defid)) {\n+            alt (*e.mod_map.get(defid)) {\n+                case (wmod(?m)) {\n+                    ret lookup_in_regular_mod(e, m, id, ns, dr);\n+                }\n+            }\n+        }\n+        case (ast.def_native_mod(?defid)) {\n+            alt (*e.mod_map.get(defid)) {\n+                case (wnmod(?m)) {\n+                    ret lookup_in_native_mod(e, m, id, ns);\n+                }\n+            }\n+        }\n+    }\n }\n \n-fn update_env_for_expr(&env e, &@ast.expr x) -> env {\n-    alt (x.node) {\n-        case (ast.expr_for(?d, _, _, _)) {\n-            ret rec(scopes = cons[scope](scope_loop(d), @e.scopes) with e);\n+fn found_view_item(&env e, @ast.view_item vi, namespace ns) -> Option.t[def] {\n+    alt (vi.node) {\n+        case (ast.view_item_use(_, _, _, ?cnum)) {\n+            ret some(ast.def_mod(tup(Option.get(cnum), -1)));\n         }\n-        case (ast.expr_for_each(?d, _, _, _)) {\n-            ret rec(scopes = cons[scope](scope_loop(d), @e.scopes) with e);\n+        case (ast.view_item_import(_, _, ?defid)) {\n+            ret lookup_import(e, defid, ns);\n         }\n-        case (_) { }\n     }\n-    ret e;\n }\n \n-fn update_env_for_arm(&env e, &ast.arm p) -> env {\n-    ret rec(scopes = cons[scope](scope_arm(p), @e.scopes) with e);\n+fn lookup_in_regular_mod(&env e, &ast._mod md, ident id, namespace ns, dir dr)\n+    -> Option.t[def] {\n+    auto found = md.index.find(id);\n+    if (found == none[ast.mod_index_entry] || \n+        (dr == outside && !ast.is_exported(id, md))) {\n+        ret none[def];\n+    }\n+    alt (Option.get(found)) {\n+        case (ast.mie_view_item(?view_item)) {\n+            ret found_view_item(e, view_item, ns);\n+        }\n+        case (ast.mie_item(?item)) {\n+            ret found_def_item(item, ns);\n+        }\n+        case (ast.mie_tag_variant(?item, ?variant_idx)) {\n+            alt (item.node) {\n+                case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n+                    if (ns == ns_value) {\n+                        auto vid = variants.(variant_idx).node.id;\n+                        ret some(ast.def_variant(tid, vid));\n+                    } else {\n+                        ret none[def];\n+                    }\n+                }\n+            }\n+        }            \n+    }\n }\n \n-fn resolve_imports(session.session sess, &@ast.crate crate) -> @ast.crate {\n-    let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n-\n-    auto import_index = new_def_hash[def_wrap]();\n-    fld = @rec( fold_view_item_import\n-                    = bind fold_view_item_import(_,_,import_index,_,_,_,_),\n-                update_env_for_crate = bind update_env_for_crate(_,_),\n-                update_env_for_item = bind update_env_for_item(_,_),\n-                update_env_for_native_item =\n-                    bind update_env_for_native_item(_,_),\n-                update_env_for_block = bind update_env_for_block(_,_),\n-                update_env_for_arm = bind update_env_for_arm(_,_),\n-                update_env_for_expr = bind update_env_for_expr(_,_)\n-                with *fld );\n-\n-    auto e = rec(scopes = nil[scope],\n-                 sess = sess);\n-\n-    ret fold.fold_crate[env](e, fld, crate);\n+fn lookup_in_native_mod(&env e, &ast.native_mod md, ident id, namespace ns)\n+    -> Option.t[def] {\n+    auto found = md.index.find(id);\n+    if (found == none[ast.native_mod_index_entry]) {\n+        ret none[def];\n+    }\n+    alt (Option.get(found)) {\n+        case (ast.nmie_view_item(?view_item)) {\n+            ret found_view_item(e, view_item, ns);\n+        }\n+        case (ast.nmie_item(?item)) {\n+            alt (item.node) {\n+                case (ast.native_item_ty(_, ?id)) {\n+                    if (ns == ns_type) {\n+                        ret some(ast.def_native_ty(id));\n+                    }\n+                }\n+                case (ast.native_item_fn(_, _, _, _, ?id, _)) {\n+                    if (ns == ns_value) {\n+                        ret some(ast.def_native_fn(id));\n+                    }\n+                }\n+            }\n+        }\n+        case (_) {}\n+    }\n+    ret none[def];\n }\n \n-fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n-\n-    let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n-\n-    auto new_crate = resolve_imports(sess, crate);\n-\n-    fld = @rec( fold_pat_tag = bind fold_pat_tag(_,_,_,_,_,_),\n-                fold_expr_path = bind fold_expr_path(_,_,_,_,_),\n-                fold_ty_path = bind fold_ty_path(_,_,_,_),\n-                update_env_for_crate = bind update_env_for_crate(_,_),\n-                update_env_for_item = bind update_env_for_item(_,_),\n-                update_env_for_native_item =\n-                    bind update_env_for_native_item(_,_),\n-                update_env_for_block = bind update_env_for_block(_,_),\n-                update_env_for_arm = bind update_env_for_arm(_,_),\n-                update_env_for_expr = bind update_env_for_expr(_,_)\n-                with *fld );\n-\n-    auto e = rec(scopes = nil[scope],\n-                 sess = sess);\n-\n-    ret fold.fold_crate[env](e, fld, new_crate);\n+// FIXME creader should handle multiple namespaces\n+fn check_def_by_ns(def d, namespace ns) -> bool {\n+    ret alt (d) {\n+        case (ast.def_fn(?id)) { ns == ns_value }\n+        case (ast.def_obj(?id)) { ns == ns_value }\n+        case (ast.def_obj_field(?id)) { ns == ns_value }\n+        case (ast.def_mod(?id)) { true }\n+        case (ast.def_native_mod(?id)) { true }\n+        case (ast.def_const(?id)) { ns == ns_value }\n+        case (ast.def_arg(?id)) { ns == ns_value }\n+        case (ast.def_local(?id)) { ns == ns_value }\n+        case (ast.def_upvar(?id)) { ns == ns_value }\n+        case (ast.def_variant(_, ?id)) { ns == ns_value }\n+        case (ast.def_ty(?id)) { ns == ns_type }\n+        case (ast.def_binding(?id)) { ns == ns_type }\n+        case (ast.def_use(?id)) { true }\n+        case (ast.def_native_ty(?id)) { ns == ns_type }\n+        case (ast.def_native_fn(?id)) { ns == ns_value }\n+    };\n }\n \n+fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n+    -> Option.t[def] {\n+    auto found = creader.lookup_def(e.sess, cnum, ids);\n+    if (found != none[def]) {\n+        auto d = Option.get(found);\n+        if (!check_def_by_ns(d, ns)) { ret none[def]; }\n+        e.ext_map.insert(ast.def_id_of_def(d), ids);\n+    }\n+    ret found;\n+ }\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "b3a0582aa8431e1ef405544e230f61f786f6e202", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -7044,6 +7044,9 @@ fn collect_item_1(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n         case (ast.item_mod(?name, ?m, ?mid)) {\n             ccx.items.insert(mid, i);\n         }\n+        case (ast.item_native_mod(_, _, ?mid)) {\n+            ccx.items.insert(mid, i);\n+        }\n         case (ast.item_ty(_, _, _, ?did, _)) {\n             ccx.items.insert(did, i);\n         }"}, {"sha": "ceef62564fffb2bab5be36be84e3ef7143628d16", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -846,7 +846,7 @@ fn print_view_item(ps s, @ast.view_item item) {\n                 pclose(s);\n             }\n         }\n-        case (ast.view_item_import(?id,?ids,_,_)) {\n+        case (ast.view_item_import(?id,?ids,_)) {\n             wrd1(s, \"import\");\n             if (!Str.eq(id, ids.(Vec.len[str](ids)-1u))) {\n                 wrd1(s, id);"}, {"sha": "6d7748f0e387f27644bcf72966ab8aa3caa8b9f3", "filename": "src/lib/List.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Flib%2FList.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Flib%2FList.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FList.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -56,6 +56,17 @@ fn length[T](&list[T] ls) -> uint {\n   ret foldl[T,uint](ls, 0u, bind count[T](_, _));\n }\n \n+fn cdr[T](&list[T] ls) -> list[T] {\n+    alt (ls) {\n+        case (cons[T](_, ?tl)) {ret *tl;}\n+    }\n+}\n+fn car[T](&list[T] ls) -> T {\n+    alt (ls) {\n+        case (cons[T](?hd, _)) {ret hd;}\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "851250876e0a1e3658ebff063b39a4ef7a59a081", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -1,5 +1,6 @@\n // xfail-boot\n-// error-pattern: unresolved name\n+// xfail-stage0\n+// error-pattern: unresolved import\n \n import m.unexported;\n "}, {"sha": "ee04def6d7d662832a338e1dd64dc4b0caec0dcb", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -1,5 +1,5 @@\n // xfail-boot\n-// error-pattern: unresolved name: baz\n+// error-pattern: unresolved import: baz\n import zed.bar;\n import zed.baz;\n mod zed {"}, {"sha": "5a5361938d328620fb0b602e0d9301b00e0b110e", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c12ab1d019b42e5427e31bfa49f1f799e84165/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=e9c12ab1d019b42e5427e31bfa49f1f799e84165", "patch": "@@ -1,5 +1,5 @@\n // xfail-boot\n-// error-pattern: unresolved name: zed\n+// error-pattern: unresolved name\n import baz.zed.bar;\n mod baz {\n }"}]}