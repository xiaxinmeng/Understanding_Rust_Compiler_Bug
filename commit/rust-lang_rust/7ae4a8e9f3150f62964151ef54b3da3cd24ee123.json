{"sha": "7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZTRhOGU5ZjMxNTBmNjI5NjQxNTFlZjU0YjNkYTNjZDI0ZWUxMjM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-04-21T16:00:12Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-04-30T12:10:52Z"}, "message": "Use hash-tables in trait selection\n\nPuts implementations in bins hashed by the fast-reject key, and\nonly looks up the relevant impls, reducing O(n^2)-ishness\n\nBefore: 688.92user 5.08system 8:56.70elapsed 129%CPU (0avgtext+0avgdata 1208164maxresident)k, LLVM 379.142s\nAfter: 637.78user 5.11system 8:17.48elapsed 129%CPU (0avgtext+0avgdata 1201448maxresident)k LLVM 375.552s\n\nPerformance increase is +7%-ish", "tree": {"sha": "3dd0213972746ef86062dd9ad094acf2b7838507", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dd0213972746ef86062dd9ad094acf2b7838507"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "html_url": "https://github.com/rust-lang/rust/commit/7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/comments", "author": null, "committer": null, "parents": [{"sha": "bd1f73420ab22faa8087a6cf1618225d09d64f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1f73420ab22faa8087a6cf1618225d09d64f9e", "html_url": "https://github.com/rust-lang/rust/commit/bd1f73420ab22faa8087a6cf1618225d09d64f9e"}], "stats": {"total": 475, "additions": 284, "deletions": 191}, "files": [{"sha": "00fc42341c38996225823b22e1df9d67bc5ccb2d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -30,7 +30,9 @@ use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty};\n use middle::astencode::vtable_decoder_helpers;\n+use util::nodemap::FnvHashMap;\n \n+use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n@@ -420,6 +422,9 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n         generics: generics,\n         trait_ref: item_trait_ref(item_doc, tcx, cdata),\n         associated_type_names: associated_type_names,\n+        nonblanket_impls: RefCell::new(FnvHashMap()),\n+        blanket_impls: RefCell::new(vec![]),\n+        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n     }\n }\n "}, {"sha": "90dd452e06b5bf7cc3f5c8504dbe63981c7c5ccc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -974,16 +974,14 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n-    match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n-        None => {}\n-        Some(implementations) => {\n-            for &impl_def_id in &*implementations.borrow() {\n-                rbml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(rbml_w, impl_def_id);\n-                rbml_w.end_tag();\n-            }\n-        }\n-    }\n+    assert!(ast_util::is_local(trait_def_id));\n+    let def = ty::lookup_trait_def(ecx.tcx, trait_def_id);\n+\n+    def.for_each_impl(ecx.tcx, |impl_def_id| {\n+        rbml_w.start_tag(tag_items_data_item_extension_impl);\n+        encode_def_id(rbml_w, impl_def_id);\n+        rbml_w.end_tag();\n+    });\n }\n \n fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {"}, {"sha": "ac3c9dfbb463b3a1d0fba2d88e6aaed6431d8cbc", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -57,20 +57,18 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n-    let cached_result =\n-        tcx.object_safety_cache.borrow().get(&trait_def_id).cloned();\n+    let def = ty::lookup_trait_def(tcx, trait_def_id);\n \n-    let result =\n-        cached_result.unwrap_or_else(|| {\n-            let result = object_safety_violations(tcx, trait_def_id).is_empty();\n+    let result = def.object_safety().unwrap_or_else(|| {\n+        let result = object_safety_violations(tcx, trait_def_id).is_empty();\n \n-            // Record just a yes/no result in the cache; this is what is\n-            // queried most frequently. Note that this may overwrite a\n-            // previous result, but always with the same thing.\n-            tcx.object_safety_cache.borrow_mut().insert(trait_def_id, result);\n+        // Record just a yes/no result in the cache; this is what is\n+        // queried most frequently. Note that this may overwrite a\n+        // previous result, but always with the same thing.\n+        def.set_object_safety(result);\n \n-            result\n-        });\n+        result\n+    });\n \n     debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n "}, {"sha": "2be1096ae306b5db2874ef5a72901f116801896d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -1153,18 +1153,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n \n-        let def_id = obligation.predicate.def_id();\n-        let all_impls = self.all_impls(def_id);\n-        for &impl_def_id in &all_impls {\n-            self.infcx.probe(|snapshot| {\n-                match self.match_impl(impl_def_id, obligation, snapshot) {\n-                    Ok(_) => {\n+        let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n+\n+        def.for_each_relevant_impl(\n+            self.tcx(),\n+            obligation.predicate.0.trait_ref,\n+            |impl_def_id| {\n+                self.infcx.probe(|snapshot| {\n+                    if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n-                    Err(()) => { }\n-                }\n-            });\n-        }\n+                });\n+            }\n+        );\n \n         Ok(())\n     }\n@@ -2529,16 +2530,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    /// Returns set of all impls for a given trait.\n-    fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_def_id);\n-\n-        match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n-            None => Vec::new(),\n-            Some(impls) => impls.borrow().clone(),\n-        }\n-    }\n-\n     fn closure_trait_ref(&self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: ast::DefId,"}, {"sha": "f9ec39113b602440fe73eb249921eecdd3accbba", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 138, "deletions": 61, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -45,6 +45,7 @@ use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n+use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n@@ -737,12 +738,6 @@ pub struct ctxt<'tcx> {\n     /// A method will be in this list if and only if it is a destructor.\n     pub destructors: RefCell<DefIdSet>,\n \n-    /// Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n-\n-    /// A set of traits that have a default impl\n-    traits_with_default_impls: RefCell<DefIdMap<()>>,\n-\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n@@ -766,12 +761,8 @@ pub struct ctxt<'tcx> {\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n-\n-    /// The set of external traits whose implementations have been read. This\n-    /// is used for lazy resolution of traits.\n-    pub populated_external_traits: RefCell<DefIdSet>,\n-\n-    /// The set of external primitive inherent implementations that have been read.\n+    /// The set of external primitive types whose implementations have been read.\n+    /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n     /// Borrows\n@@ -825,9 +816,6 @@ pub struct ctxt<'tcx> {\n     /// results are dependent on the parameter environment.\n     pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n \n-    /// Caches whether traits are object safe\n-    pub object_safety_cache: RefCell<DefIdMap<bool>>,\n-\n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n@@ -966,6 +954,7 @@ impl fmt::Debug for TypeFlags {\n }\n \n impl<'tcx> PartialEq for TyS<'tcx> {\n+    #[inline]\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n         // (self as *const _) == (other as *const _)\n         (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n@@ -2500,6 +2489,16 @@ pub struct TypeScheme<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+bitflags! {\n+    flags TraitFlags: u32 {\n+        const NO_TRAIT_FLAGS        = 0,\n+        const HAS_DEFAULT_IMPL      = 1 << 0,\n+        const IS_OBJECT_SAFE        = 1 << 1,\n+        const OBJECT_SAFETY_VALID   = 1 << 2,\n+        const IMPLS_VALID           = 1 << 3,\n+    }\n+}\n+\n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n     pub unsafety: ast::Unsafety,\n@@ -2522,6 +2521,103 @@ pub struct TraitDef<'tcx> {\n     /// A list of the associated types defined in this trait. Useful\n     /// for resolving `X::Foo` type markers.\n     pub associated_type_names: Vec<ast::Name>,\n+\n+    /// Impls of the trait.\n+    pub nonblanket_impls: RefCell<\n+        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+    >,\n+\n+    /// Blanket impls associated with the trait.\n+    pub blanket_impls: RefCell<Vec<DefId>>,\n+\n+    pub flags: Cell<TraitFlags>\n+}\n+\n+impl<'tcx> TraitDef<'tcx> {\n+    // returns None if not yet calculated\n+    pub fn object_safety(&self) -> Option<bool> {\n+        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n+            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn set_object_safety(&self, is_safe: bool) {\n+        self.flags.set(\n+            self.flags.get() | if is_safe {\n+                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n+            } else {\n+                TraitFlags::OBJECT_SAFETY_VALID\n+            }\n+        );\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_impl(&self,\n+                       tcx: &ctxt<'tcx>,\n+                       impl_def_id: DefId,\n+                       impl_trait_ref: TraitRef<'tcx>) {\n+        // We don't want to borrow_mut after we already populated all impls,\n+        // so check if an impl is present with an immutable borrow first.\n+\n+        if let Some(sty) = fast_reject::simplify_type(tcx,\n+                                                      impl_trait_ref.self_ty(), false) {\n+            if !self.nonblanket_impls.borrow().get(&sty).map(\n+                    |s| s.contains(&impl_def_id)).unwrap_or(false) {\n+                self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+            }\n+        } else {\n+            if !self.blanket_impls.borrow().contains(&impl_def_id) {\n+                self.blanket_impls.borrow_mut().push(impl_def_id)\n+            }\n+        }\n+    }\n+\n+\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ctxt<'tcx>, mut f: F)  {\n+        ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n+                                                   tcx: &ctxt<'tcx>,\n+                                                   trait_ref: TraitRef<'tcx>,\n+                                                   mut f: F)\n+    {\n+        ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        if let Some(self_ty) = trait_ref.substs.self_ty() {\n+            if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, false) {\n+                if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n+                    for &impl_def_id in impls {\n+                        f(impl_def_id);\n+                    }\n+                }\n+                return; // don't process all non-blanket impls\n+            }\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -2681,14 +2777,11 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         struct_fields: RefCell::new(DefIdMap()),\n         destructor_for_type: RefCell::new(DefIdMap()),\n         destructors: RefCell::new(DefIdSet()),\n-        trait_impls: RefCell::new(DefIdMap()),\n-        traits_with_default_impls: RefCell::new(DefIdMap()),\n         inherent_impls: RefCell::new(DefIdMap()),\n         impl_items: RefCell::new(DefIdMap()),\n         used_unsafe: RefCell::new(NodeSet()),\n         used_mut_nodes: RefCell::new(NodeSet()),\n         populated_external_types: RefCell::new(DefIdSet()),\n-        populated_external_traits: RefCell::new(DefIdSet()),\n         populated_external_primitive_impls: RefCell::new(DefIdSet()),\n         upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n@@ -2705,7 +2798,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         repr_hint_cache: RefCell::new(DefIdMap()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n-        object_safety_cache: RefCell::new(DefIdMap()),\n         const_qualif_map: RefCell::new(NodeMap()),\n    }\n }\n@@ -6223,50 +6315,36 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n \n pub fn trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) -> bool {\n     populate_implementations_for_trait_if_necessary(tcx, trait_def_id);\n-    tcx.traits_with_default_impls.borrow().contains_key(&trait_def_id)\n-}\n \n-/// Records a trait-to-implementation mapping.\n-pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n-    // We're using the latest implementation found as the reference one.\n-    // Duplicated implementations are caught and reported in the coherence\n-    // step.\n-    tcx.traits_with_default_impls.borrow_mut().insert(trait_def_id, ());\n+    let def = lookup_trait_def(tcx, trait_def_id);\n+    def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n }\n \n /// Records a trait-to-implementation mapping.\n-pub fn record_trait_implementation(tcx: &ctxt,\n-                                   trait_def_id: DefId,\n-                                   impl_def_id: DefId) {\n-\n-    match tcx.trait_impls.borrow().get(&trait_def_id) {\n-        Some(impls_for_trait) => {\n-            impls_for_trait.borrow_mut().push(impl_def_id);\n-            return;\n-        }\n-        None => {}\n-    }\n-\n-    tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n+pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n+    let def = lookup_trait_def(tcx, trait_def_id);\n+    def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n }\n \n /// Load primitive inherent implementations if necessary\n-pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt, lang_def_id: ast::DefId) {\n-    if lang_def_id.krate == LOCAL_CRATE {\n+pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt,\n+                                                           primitive_def_id: ast::DefId) {\n+    if primitive_def_id.krate == LOCAL_CRATE {\n         return\n     }\n-    if tcx.populated_external_primitive_impls.borrow().contains(&lang_def_id) {\n+\n+    if tcx.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n         return\n     }\n \n-    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\", lang_def_id);\n+    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n+           primitive_def_id);\n \n-    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, lang_def_id);\n+    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, primitive_def_id);\n \n     // Store the implementation info.\n-    tcx.impl_items.borrow_mut().insert(lang_def_id, impl_items);\n-\n-    tcx.populated_external_primitive_impls.borrow_mut().insert(lang_def_id);\n+    tcx.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n+    tcx.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -6276,6 +6354,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     if type_id.krate == LOCAL_CRATE {\n         return\n     }\n+\n     if tcx.populated_external_types.borrow().contains(&type_id) {\n         return\n     }\n@@ -6286,10 +6365,12 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n \n-        // Record the trait->implementation mappings, if applicable.\n-        let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n-        if let Some(ref trait_ref) = associated_traits {\n-            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n+        // Record the implementation, if needed\n+        if let Some(trait_ref) = csearch::get_impl_trait(tcx, impl_def_id) {\n+            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+            trait_def.record_impl(tcx, impl_def_id, trait_ref);\n+        } else {\n+            inherent_impls.push(impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -6310,11 +6391,6 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // Store the implementation info.\n         tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-\n-        // If this is an inherent implementation, record it.\n-        if associated_traits.is_none() {\n-            inherent_impls.push(impl_def_id);\n-        }\n     });\n \n     tcx.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n@@ -6330,7 +6406,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n         return\n     }\n \n-    if tcx.populated_external_traits.borrow().contains(&trait_id) {\n+    let def = lookup_trait_def(tcx, trait_id);\n+    if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n         return\n     }\n \n@@ -6340,9 +6417,9 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id, |implementation_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n-\n+        let trait_ref = impl_trait_ref(tcx, implementation_def_id).unwrap();\n         // Record the trait->implementation mapping.\n-        record_trait_implementation(tcx, trait_id, implementation_def_id);\n+        def.record_impl(tcx, implementation_def_id, trait_ref);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n@@ -6364,7 +6441,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         tcx.impl_items.borrow_mut().insert(implementation_def_id, impl_items);\n     });\n \n-    tcx.populated_external_traits.borrow_mut().insert(trait_id);\n+    def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n }\n \n /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "19e71d6e40d5aecc755863a9042837d4d5fd5549", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -1745,17 +1745,16 @@ impl LintPass for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let impls = cx.tcx.trait_impls.borrow();\n-            let impls = match impls.get(&debug) {\n-                Some(impls) => {\n-                    impls.borrow().iter()\n-                         .filter(|d| d.krate == ast::LOCAL_CRATE)\n-                         .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n-                         .map(|d| d.node)\n-                         .collect()\n+            let debug_def = ty::lookup_trait_def(cx.tcx, debug);\n+            let mut impls = NodeSet();\n+            debug_def.for_each_impl(cx.tcx, |d| {\n+                if d.krate == ast::LOCAL_CRATE {\n+                    if let Some(ty_def) = ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)) {\n+                        impls.insert(ty_def.node);\n+                    }\n                 }\n-                None => NodeSet(),\n-            };\n+            });\n+\n             self.impling_types = Some(impls);\n             debug!(\"{:?}\", self.impling_types);\n         }"}, {"sha": "c94fa03702681bcb5fdd52131ab98cf7b8489c08", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -624,23 +624,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                      item: ty::ImplOrTraitItem<'tcx>,\n                                                      item_index: usize)\n     {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n-                                                            trait_def_id);\n-\n-        let trait_impls = self.tcx().trait_impls.borrow();\n-        let impl_def_ids = trait_impls.get(&trait_def_id);\n-        let impl_def_ids = match impl_def_ids {\n-            None => { return; }\n-            Some(impls) => impls,\n-        };\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n \n-        for &impl_def_id in &*impl_def_ids.borrow() {\n+        // FIXME(arielb1): can we use for_each_relevant_impl here?\n+        trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n                    trait_def_id.repr(self.tcx()),\n                    impl_def_id.repr(self.tcx()));\n \n             if !self.impl_can_possibly_match(impl_def_id) {\n-                continue;\n+                return;\n             }\n \n             let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n@@ -667,7 +660,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 item: item.clone(),\n                 kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n             });\n-        }\n+        });\n     }\n \n     fn impl_can_possibly_match(&self, impl_def_id: ast::DefId) -> bool {"}, {"sha": "05b74a5cc226bd7393d1830518c03358f12535d2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,\n                                                  trait_ref.def_id);\n-            self.add_trait_impl(trait_ref.def_id, impl_did);\n+            self.add_trait_impl(trait_ref, impl_did);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -259,12 +259,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n-    fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        debug!(\"add_trait_impl: base_def_id={:?} impl_def_id={:?}\",\n-               base_def_id, impl_def_id);\n-        ty::record_trait_implementation(self.crate_context.tcx,\n-                                        base_def_id,\n-                                        impl_def_id);\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n+        debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n+               impl_trait_ref, impl_def_id);\n+        let trait_def = ty::lookup_trait_def(self.crate_context.tcx,\n+                                             impl_trait_ref.def_id);\n+        trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Record all the trait items.\n         if let Some(trait_ref) = associated_traits {\n-            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n+            self.add_trait_impl(trait_ref, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -382,18 +382,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n+        ty::populate_implementations_for_trait_if_necessary(tcx, drop_trait);\n+        let drop_trait = ty::lookup_trait_def(tcx, drop_trait);\n \n         let impl_items = tcx.impl_items.borrow();\n-        let trait_impls = match tcx.trait_impls.borrow().get(&drop_trait).cloned() {\n-            None => return, // No types with (new-style) dtors present.\n-            Some(found_impls) => found_impls\n-        };\n \n-        for &impl_did in &*trait_impls.borrow() {\n+        drop_trait.for_each_impl(tcx, |impl_did| {\n             let items = impl_items.get(&impl_did).unwrap();\n             if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n-                continue;\n+                return;\n             }\n             let method_def_id = items[0];\n \n@@ -430,7 +428,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-        }\n+        });\n     }\n \n     /// Ensures that implementations of the built-in trait `Copy` are legal.\n@@ -440,30 +438,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(id) => id,\n             None => return,\n         };\n+        ty::populate_implementations_for_trait_if_necessary(tcx, copy_trait);\n+        let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n \n-        let trait_impls = match tcx.trait_impls\n-                                   .borrow()\n-                                   .get(&copy_trait)\n-                                   .cloned() {\n-            None => {\n-                debug!(\"check_implementations_of_copy(): no types with \\\n-                        implementations of `Copy` found\");\n-                return\n-            }\n-            Some(found_impls) => found_impls\n-        };\n-\n-        // Clone first to avoid a double borrow error.\n-        let trait_impls = trait_impls.borrow().clone();\n-\n-        for &impl_did in &trait_impls {\n+        copy_trait.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_copy: impl_did={}\",\n                    impl_did.repr(tcx));\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n-                continue\n+                return\n             }\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n@@ -506,7 +491,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                the type has a destructor\");\n                 }\n             }\n-        }\n+        });\n     }\n }\n "}, {"sha": "8d402a8c1ee023deeb150e7c6a75f7af5e652411", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 77, "deletions": 33, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -48,59 +48,103 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_def_ids: Vec<(ast::DefId, Vec<ast::DefId>)> =\n-            self.tcx.trait_impls.borrow().iter().map(|(&k, v)| {\n-                // FIXME -- it seems like this method actually pushes\n-                // duplicate impls onto the list\n-                ty::populate_implementations_for_trait_if_necessary(self.tcx, k);\n-                (k, v.borrow().clone())\n-            }).collect();\n-\n-        for &(trait_def_id, ref impls) in &trait_def_ids {\n-            self.check_for_overlapping_impls_of_trait(trait_def_id, impls);\n+        let trait_defs : Vec<&ty::TraitDef> = {\n+            let d = self.tcx.trait_defs.borrow();\n+            d.values().map(|&v|v).collect()\n+        };\n+\n+        for trait_def in trait_defs {\n+            // FIXME -- it seems like this method actually pushes\n+            // duplicate impls onto the list\n+            ty::populate_implementations_for_trait_if_necessary(\n+                self.tcx,\n+                trait_def.trait_ref.def_id);\n+            self.check_for_overlapping_impls_of_trait(trait_def);\n         }\n     }\n \n     fn check_for_overlapping_impls_of_trait(&self,\n-                                            trait_def_id: ast::DefId,\n-                                            trait_impls: &Vec<ast::DefId>)\n+                                            trait_def: &'tcx ty::TraitDef<'tcx>)\n     {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx));\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def={})\",\n+               trait_def.repr(self.tcx));\n \n-        for (i, &impl1_def_id) in trait_impls.iter().enumerate() {\n-            if impl1_def_id.krate != ast::LOCAL_CRATE {\n-                // we don't need to check impls if both are external;\n-                // that's the other crate's job.\n-                continue;\n-            }\n+        // We should already know all impls of this trait, so these\n+        // borrows are safe.\n+        let blanket_impls = trait_def.blanket_impls.borrow();\n+        let nonblanket_impls = trait_def.nonblanket_impls.borrow();\n+        let trait_def_id = trait_def.trait_ref.def_id;\n \n-            for &impl2_def_id in &trait_impls[(i+1)..] {\n+        // Conflicts can only occur between a blanket impl and another impl,\n+        // or between 2 non-blanket impls of the same kind.\n+\n+        for (i, &impl1_def_id) in blanket_impls.iter().enumerate() {\n+            for &impl2_def_id in &blanket_impls[(i+1)..] {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);\n             }\n+\n+            for v in nonblanket_impls.values() {\n+                for &impl2_def_id in v {\n+                    self.check_if_impls_overlap(trait_def_id,\n+                                                impl1_def_id,\n+                                                impl2_def_id);\n+                }\n+            }\n+        }\n+\n+        for impl_group in nonblanket_impls.values() {\n+            for (i, &impl1_def_id) in impl_group.iter().enumerate() {\n+                for &impl2_def_id in &impl_group[(i+1)..] {\n+                    self.check_if_impls_overlap(trait_def_id,\n+                                                impl1_def_id,\n+                                                impl2_def_id);\n+                }\n+            }\n         }\n     }\n \n+    // We need to coherently pick which impl will be displayed\n+    // as causing the error message, and it must be the in the current\n+    // crate. Just pick the smaller impl in the file.\n+    fn order_impls(&self, impl1_def_id: ast::DefId, impl2_def_id: ast::DefId)\n+            -> Option<(ast::DefId, ast::DefId)> {\n+        if impl1_def_id.krate != ast::LOCAL_CRATE {\n+            if impl2_def_id.krate != ast::LOCAL_CRATE {\n+                // we don't need to check impls if both are external;\n+                // that's the other crate's job.\n+                None\n+            } else {\n+                Some((impl2_def_id, impl1_def_id))\n+            }\n+        } else if impl2_def_id.krate != ast::LOCAL_CRATE {\n+            Some((impl1_def_id, impl2_def_id))\n+        } else if impl1_def_id.node < impl2_def_id.node {\n+            Some((impl1_def_id, impl2_def_id))\n+        } else {\n+            Some((impl2_def_id, impl1_def_id))\n+        }\n+    }\n+\n+\n     fn check_if_impls_overlap(&self,\n                               trait_def_id: ast::DefId,\n                               impl1_def_id: ast::DefId,\n                               impl2_def_id: ast::DefId)\n     {\n-        assert_eq!(impl1_def_id.krate, ast::LOCAL_CRATE);\n-\n-        debug!(\"check_if_impls_overlap({}, {}, {})\",\n-               trait_def_id.repr(self.tcx),\n-               impl1_def_id.repr(self.tcx),\n-               impl2_def_id.repr(self.tcx));\n-\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n-        if !traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-            return;\n+        if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n+            impl1_def_id, impl2_def_id) {\n+            debug!(\"check_if_impls_overlap({}, {}, {})\",\n+                   trait_def_id.repr(self.tcx),\n+                   impl1_def_id.repr(self.tcx),\n+                   impl2_def_id.repr(self.tcx));\n+\n+            let infcx = infer::new_infer_ctxt(self.tcx);\n+            if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n+            }\n         }\n-\n-        self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n     }\n \n     fn report_overlap_error(&self, trait_def_id: ast::DefId,"}, {"sha": "6f78e853ebe84ecd592c091e8624d40a86ee9cf4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae4a8e9f3150f62964151ef54b3da3cd24ee123/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "patch": "@@ -83,7 +83,7 @@ use util::ppaux;\n use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -1257,6 +1257,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         generics: ty_generics,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n+        nonblanket_impls: RefCell::new(FnvHashMap()),\n+        blanket_impls: RefCell::new(vec![]),\n+        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n     };\n \n     return tcx.intern_trait_def(trait_def);"}]}