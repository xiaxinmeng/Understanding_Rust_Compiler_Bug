{"sha": "abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "node_id": "C_kwDOAAsO6NoAKGFiYzFhZDcxMDYyZGQ4ZTJiN2FlOTdhZGE3MzZmMmQwYzBiMjM0NGU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-30T18:31:03Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-31T11:21:46Z"}, "message": "Use AdtDef to check enum.", "tree": {"sha": "58a1af6776e385065f916252087f0de66fe49185", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a1af6776e385065f916252087f0de66fe49185"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "html_url": "https://github.com/rust-lang/rust/commit/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65f77b7eb56690cebe5de7c35f6851c183258350", "url": "https://api.github.com/repos/rust-lang/rust/commits/65f77b7eb56690cebe5de7c35f6851c183258350", "html_url": "https://github.com/rust-lang/rust/commit/65f77b7eb56690cebe5de7c35f6851c183258350"}], "stats": {"total": 127, "additions": 65, "deletions": 62}, "files": [{"sha": "133bbd52b9142c3249d634c057088df2953bfef9", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n@@ -75,15 +75,15 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n }\n@@ -506,11 +506,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n-            let item = tcx.hir().item(id);\n-            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n-                return;\n-            };\n-            check_enum(tcx, &enum_definition.variants, item.owner_id.def_id);\n+            check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n@@ -1026,7 +1022,7 @@ pub(super) fn check_packed_inner(\n     None\n }\n \n-pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtDef<'tcx>) {\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     if !adt.repr().transparent() {\n         return;\n     }\n@@ -1035,14 +1031,14 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         feature_err(\n             &tcx.sess.parse_sess,\n             sym::transparent_unions,\n-            sp,\n+            tcx.def_span(adt.did()),\n             \"transparent unions are unstable\",\n         )\n         .emit();\n     }\n \n     if adt.variants().len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did());\n+        bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n         if adt.variants().is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -1103,7 +1099,7 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         .filter_map(|(span, zst, _align1, _non_exhaustive)| if !zst { Some(span) } else { None });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count >= 2 {\n-        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, tcx.def_span(adt.did()));\n     }\n     let incompatible_zst_fields =\n         field_infos.clone().filter(|(_, _, _, opt)| opt.is_some()).count();\n@@ -1143,20 +1139,19 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n }\n \n #[allow(trivial_numeric_casts)]\n-fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: LocalDefId) {\n+fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n-    let sp = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n-    if vs.is_empty() {\n+    if def.variants().is_empty() {\n         if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,\n                 E0084,\n                 \"unsupported representation for zero-variant enum\"\n             )\n-            .span_label(sp, \"zero-variant enum\")\n+            .span_label(tcx.def_span(def_id), \"zero-variant enum\")\n             .emit();\n         }\n     }\n@@ -1167,88 +1162,96 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n             feature_err(\n                 &tcx.sess.parse_sess,\n                 sym::repr128,\n-                sp,\n+                tcx.def_span(def_id),\n                 \"repr with 128-bit type is unstable\",\n             )\n             .emit();\n         }\n     }\n \n-    for v in vs {\n-        if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n+    for v in def.variants() {\n+        if let ty::VariantDiscr::Explicit(discr_def_id) = v.discr {\n+            tcx.ensure().typeck(discr_def_id.expect_local());\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr().int.is_none() {\n-        let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n+    if def.repr().int.is_none() {\n+        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind, CtorKind::Const);\n+        let has_disr = |var: &ty::VariantDef| matches!(var.discr, ty::VariantDiscr::Explicit(_));\n \n-        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n-        let has_non_units = vs.iter().any(|var| !is_unit(var));\n-        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n-        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n+        let has_non_units = def.variants().iter().any(|var| !is_unit(var));\n+        let disr_units = def.variants().iter().any(|var| is_unit(&var) && has_disr(&var));\n+        let disr_non_unit = def.variants().iter().any(|var| !is_unit(&var) && has_disr(&var));\n \n         if disr_non_unit || (disr_units && has_non_units) {\n-            let mut err =\n-                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                tcx.def_span(def_id),\n+                E0732,\n+                \"`#[repr(inttype)]` must be specified\"\n+            );\n             err.emit();\n         }\n     }\n \n-    detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n-\n-    check_transparent(tcx, sp, def);\n+    detect_discriminant_duplicate(tcx, def);\n+    check_transparent(tcx, def);\n }\n \n /// Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal\n-fn detect_discriminant_duplicate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut discrs: Vec<(VariantIdx, Discr<'tcx>)>,\n-    vs: &'tcx [hir::Variant<'tcx>],\n-    self_span: Span,\n-) {\n+fn detect_discriminant_duplicate<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n     // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n-    let report = |dis: Discr<'tcx>, idx: usize, err: &mut Diagnostic| {\n-        let var = &vs[idx]; // HIR for the duplicate discriminant\n-        let (span, display_discr) = match var.disr_expr {\n-            Some(ref expr) => {\n+    let report = |dis: Discr<'tcx>, idx, err: &mut Diagnostic| {\n+        let var = adt.variant(idx); // HIR for the duplicate discriminant\n+        let (span, display_discr) = match var.discr {\n+            ty::VariantDiscr::Explicit(discr_def_id) => {\n                 // In the case the discriminant is both a duplicate and overflowed, let the user know\n-                if let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n+                if let hir::Node::AnonConst(expr) = tcx.hir().get_by_def_id(discr_def_id.expect_local())\n+                    && let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n                     && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n                     && *lit_value != dis.val\n                 {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n-                // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n                 } else {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}`\"))\n+                    // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}`\"))\n                 }\n             }\n-            None => {\n+            // This should not happen.\n+            ty::VariantDiscr::Relative(0) => (tcx.def_span(var.def_id), format!(\"`{dis}`\")),\n+            ty::VariantDiscr::Relative(distance_to_explicit) => {\n                 // At this point we know this discriminant is a duplicate, and was not explicitly\n                 // assigned by the user. Here we iterate backwards to fetch the HIR for the last\n                 // explicitly assigned discriminant, and letting the user know that this was the\n                 // increment startpoint, and how many steps from there leading to the duplicate\n-                if let Some((n, hir::Variant { span, ident, .. })) =\n-                    vs[..idx].iter().rev().enumerate().find(|v| v.1.disr_expr.is_some())\n+                if let Some(explicit_idx) =\n+                    idx.as_u32().checked_sub(distance_to_explicit).map(VariantIdx::from_u32)\n                 {\n-                    let ve_ident = var.ident;\n-                    let n = n + 1;\n-                    let sp = if n > 1 { \"variants\" } else { \"variant\" };\n+                    let explicit_variant = adt.variant(explicit_idx);\n+                    let ve_ident = var.name;\n+                    let ex_ident = explicit_variant.name;\n+                    let sp = if distance_to_explicit > 1 { \"variants\" } else { \"variant\" };\n \n                     err.span_label(\n-                        *span,\n-                        format!(\"discriminant for `{ve_ident}` incremented from this startpoint (`{ident}` + {n} {sp} later => `{ve_ident}` = {dis})\"),\n+                        tcx.def_span(explicit_variant.def_id),\n+                        format!(\n+                            \"discriminant for `{ve_ident}` incremented from this startpoint \\\n+                            (`{ex_ident}` + {distance_to_explicit} {sp} later \\\n+                             => `{ve_ident}` = {dis})\"\n+                        ),\n                     );\n                 }\n \n-                (vs[idx].span, format!(\"`{dis}`\"))\n+                (tcx.def_span(var.def_id), format!(\"`{dis}`\"))\n             }\n         };\n \n         err.span_label(span, format!(\"{display_discr} assigned here\"));\n     };\n \n+    let mut discrs = adt.discriminants(tcx).collect::<Vec<_>>();\n+\n     // Here we loop through the discriminants, comparing each discriminant to another.\n     // When a duplicate is detected, we instantiate an error and point to both\n     // initial and duplicate value. The duplicate discriminant is then discarded by swapping\n@@ -1257,29 +1260,29 @@ fn detect_discriminant_duplicate<'tcx>(\n     // style as we are mutating `discrs` on the fly).\n     let mut i = 0;\n     while i < discrs.len() {\n-        let hir_var_i_idx = discrs[i].0.index();\n+        let var_i_idx = discrs[i].0;\n         let mut error: Option<DiagnosticBuilder<'_, _>> = None;\n \n         let mut o = i + 1;\n         while o < discrs.len() {\n-            let hir_var_o_idx = discrs[o].0.index();\n+            let var_o_idx = discrs[o].0;\n \n             if discrs[i].1.val == discrs[o].1.val {\n                 let err = error.get_or_insert_with(|| {\n                     let mut ret = struct_span_err!(\n                         tcx.sess,\n-                        self_span,\n+                        tcx.def_span(adt.did()),\n                         E0081,\n                         \"discriminant value `{}` assigned more than once\",\n                         discrs[i].1,\n                     );\n \n-                    report(discrs[i].1, hir_var_i_idx, &mut ret);\n+                    report(discrs[i].1, var_i_idx, &mut ret);\n \n                     ret\n                 });\n \n-                report(discrs[o].1, hir_var_o_idx, err);\n+                report(discrs[o].1, var_o_idx, err);\n \n                 // Safe to unwrap here, as we wouldn't reach this point if `discrs` was empty\n                 discrs[o] = *discrs.last().unwrap();"}, {"sha": "d4b21f6893b43295b023ff2de1dab074617f02e0", "filename": "src/test/ui/error-codes/E0081.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr?ref=abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "patch": "@@ -32,7 +32,7 @@ LL |     First = -1,\n    |             -- `-1` assigned here\n LL |\n LL |     Second = -2,\n-   |     ----------- discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n+   |     ------ discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n LL |\n LL |     Last,\n    |     ---- `-1` assigned here\n@@ -53,7 +53,7 @@ LL |     V4 = 0,\n    |          - `0` assigned here\n LL |\n LL |     V5 = -2,\n-   |     ------- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n+   |     -- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n ...\n LL |     V7,\n    |     -- `0` assigned here\n@@ -68,7 +68,7 @@ LL |     V5 = -2,\n    |          -- `-2` assigned here\n ...\n LL |     V8 = -3,\n-   |     ------- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n+   |     -- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n LL |\n LL |     V9,\n    |     -- `-2` assigned here"}]}