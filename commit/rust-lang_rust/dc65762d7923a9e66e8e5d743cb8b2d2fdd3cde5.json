{"sha": "dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNjU3NjJkNzkyM2E5ZTY2ZThlNWQ3NDNjYjhiMmQyZmRkM2NkZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T10:31:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T10:31:55Z"}, "message": "auto merge of #10990 : ktt3ja/rust/method-stability, r=huonw\n\nIf it's a trait method, this checks the stability attribute of the\r\nmethod inside the trait definition. Otherwise, it checks the method\r\nimplementation itself.\r\n\r\nClose #8961.", "tree": {"sha": "d7b3bfe13164b95e88997b369b23686881140750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b3bfe13164b95e88997b369b23686881140750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "html_url": "https://github.com/rust-lang/rust/commit/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47c9a35747e9a15830e35924429050b820825f5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/47c9a35747e9a15830e35924429050b820825f5d", "html_url": "https://github.com/rust-lang/rust/commit/47c9a35747e9a15830e35924429050b820825f5d"}, {"sha": "4f95dceb597da2ab4af207179e0731a6db104287", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f95dceb597da2ab4af207179e0731a6db104287", "html_url": "https://github.com/rust-lang/rust/commit/4f95dceb597da2ab4af207179e0731a6db104287"}], "stats": {"total": 224, "additions": 171, "deletions": 53}, "files": [{"sha": "afc910056ebab36ecc5f0b7e8897f0f6fe982a6d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "patch": "@@ -312,7 +312,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                    &exported_items, reachable_map, crate));\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(ty_cx, &exported_items, crate));\n+         lint::check_crate(ty_cx, method_map, &exported_items, crate));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,"}, {"sha": "b27aa11651d4a1400f27cce9e43dc9f1e4e5417b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "patch": "@@ -812,6 +812,10 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     encode_bounds_and_type(ebml_w, ecx, &tpt);\n \n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n+    match ast_method_opt {\n+        Some(ast_method) => encode_attributes(ebml_w, ast_method.attrs),\n+        None => ()\n+    }\n \n     for ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs.len();\n@@ -1205,11 +1209,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n \n             match ms[i] {\n-                required(_) => {\n+                required(ref tm) => {\n+                    encode_attributes(ebml_w, tm.attrs);\n                     encode_method_sort(ebml_w, 'r');\n                 }\n \n                 provided(m) => {\n+                    encode_attributes(ebml_w, m.attrs);\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != sty_static {"}, {"sha": "8f5ae723c54b221cb5e6a5045157d9fa878a59bc", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "patch": "@@ -37,6 +37,7 @@ use driver::session;\n use middle::privacy;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n+use middle::typeck;\n use middle::pat_util;\n use metadata::csearch;\n use util::ppaux::{ty_to_str};\n@@ -359,6 +360,9 @@ struct Context<'a> {\n     cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n+    // maps from an expression id that corresponds to a method call to the\n+    // details of the method to be invoked\n+    method_map: typeck::method_map,\n     // Items exported by the crate; used by the missing_doc lint.\n     exported_items: &'a privacy::ExportedItems,\n     // The id of the current `ast::struct_def` being walked.\n@@ -1176,20 +1180,43 @@ fn check_missing_doc_variant(cx: &Context, v: &ast::variant) {\n /// Checks for use of items with #[deprecated], #[experimental] and\n /// #[unstable] (or none of them) attributes.\n fn check_stability(cx: &Context, e: &ast::Expr) {\n-    let def = match e.node {\n-        ast::ExprMethodCall(..) |\n-        ast::ExprPath(..) |\n-        ast::ExprStruct(..) => {\n+    let id = match e.node {\n+        ast::ExprPath(..) | ast::ExprStruct(..) => {\n             match cx.tcx.def_map.find(&e.id) {\n-                Some(&def) => def,\n+                Some(&def) => ast_util::def_id_of_def(def),\n+                None => return\n+            }\n+        }\n+        ast::ExprMethodCall(..) => {\n+            match cx.method_map.find(&e.id) {\n+                Some(&typeck::method_map_entry { origin, .. }) => {\n+                    match origin {\n+                        typeck::method_static(def_id) => {\n+                            // If this implements a trait method, get def_id\n+                            // of the method inside trait definition.\n+                            // Otherwise, use the current def_id (which refers\n+                            // to the method inside impl).\n+                            ty::trait_method_of_method(\n+                                cx.tcx, def_id).unwrap_or(def_id)\n+                        }\n+                        typeck::method_param(typeck::method_param {\n+                            trait_id: trait_id,\n+                            method_num: index,\n+                            ..\n+                        })\n+                        | typeck::method_object(typeck::method_object {\n+                            trait_id: trait_id,\n+                            method_num: index,\n+                            ..\n+                        }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n+                    }\n+                }\n                 None => return\n             }\n         }\n         _ => return\n     };\n \n-    let id = ast_util::def_id_of_def(def);\n-\n     let stability = if ast_util::is_local(id) {\n         // this crate\n         match cx.tcx.items.find(&id.node) {\n@@ -1208,7 +1235,8 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n                     None => return\n                 }\n             }\n-            _ => cx.tcx.sess.bug(format!(\"handle_def: {:?} not found\", id))\n+            _ => cx.tcx.sess.span_bug(e.span,\n+                                      format!(\"handle_def: {:?} not found\", id))\n         }\n     } else {\n         // cross-crate\n@@ -1395,12 +1423,14 @@ impl<'a> IdVisitingOperation for Context<'a> {\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n                    exported_items: &privacy::ExportedItems,\n                    crate: &ast::Crate) {\n     let mut cx = Context {\n         dict: @get_lint_dict(),\n         cur: SmallIntMap::new(),\n         tcx: tcx,\n+        method_map: method_map,\n         exported_items: exported_items,\n         cur_struct_def_id: -1,\n         is_doc_hidden: false,"}, {"sha": "1bdd88a3b7afd6a5cbd040b1d98af01f0199e6f2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "patch": "@@ -4540,29 +4540,67 @@ pub fn populate_implementations_for_trait_if_necessary(\n     tcx.populated_external_traits.insert(trait_id);\n }\n \n-/// If the given def ID describes a trait method, returns the ID of the trait\n-/// that the method belongs to. Otherwise, returns `None`.\n+/// Given the def_id of an impl, return the def_id of the trait it implements.\n+/// If it implements no trait, return `None`.\n+pub fn trait_id_of_impl(tcx: ctxt,\n+                        def_id: ast::DefId) -> Option<ast::DefId> {\n+    let node = match tcx.items.find(&def_id.node) {\n+        Some(node) => node,\n+        None => return None\n+    };\n+    match node {\n+        &ast_map::node_item(item, _) => {\n+            match item.node {\n+                ast::item_impl(_, Some(ref trait_ref), _, _) => {\n+                    Some(node_id_to_trait_ref(tcx, trait_ref.ref_id).def_id)\n+                }\n+                _ => None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+\n+/// If the given def ID describes a method belonging to a trait (either a\n+/// default method or an implementation of a trait method), return the ID of\n+/// the trait that the method belongs to. Otherwise, return `None`.\n pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n                        -> Option<ast::DefId> {\n+    if def_id.crate != LOCAL_CRATE {\n+        return csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n+    }\n     match tcx.methods.find(&def_id) {\n-        Some(method_descriptor) => {\n-            match method_descriptor.container {\n-                TraitContainer(id) => return Some(id),\n-                _ => {}\n+        Some(method) => {\n+            match method.container {\n+                TraitContainer(def_id) => Some(def_id),\n+                ImplContainer(def_id) => trait_id_of_impl(tcx, def_id),\n             }\n         }\n-        None => {}\n+        None => None\n     }\n+}\n \n-    // If the method was in the local crate, then if we got here we know the\n-    // answer is negative.\n-    if def_id.crate == LOCAL_CRATE {\n-        return None\n+/// If the given def ID describes a method belonging to a trait, (either a\n+/// default method or an implementation of a trait method), return the ID of\n+/// the method inside trait definition (this means that if the given def ID\n+/// is already that of the original trait method, then the return value is\n+/// the same).\n+/// Otherwise, return `None`.\n+pub fn trait_method_of_method(tcx: ctxt,\n+                              def_id: ast::DefId) -> Option<ast::DefId> {\n+    let name = match tcx.methods.find(&def_id) {\n+        Some(method) => method.ident.name,\n+        None => return None\n+    };\n+    match trait_of_method(tcx, def_id) {\n+        Some(trait_did) => {\n+            let trait_methods = ty::trait_methods(tcx, trait_did);\n+            trait_methods.iter()\n+                .position(|m| m.ident.name == name)\n+                .map(|idx| ty::trait_method(tcx, trait_did, idx).def_id)\n+        }\n+        None => None\n     }\n-\n-    let result = csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n-\n-    result\n }\n \n /// Creates a hash of the type `t` which will be the same no matter what crate"}, {"sha": "ceec1ae3d8a3f0ccf4459d435410d47fbc9012b6", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 72, "deletions": 28, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "patch": "@@ -26,32 +26,32 @@ mod cross_crate {\n         let foo = MethodTester;\n \n         deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); // ~ ERROR use of deprecated item\n-        foo.trait_deprecated(); // ~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n \n         deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); // ~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); // ~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n \n         experimental(); //~ ERROR use of experimental item\n-        foo.method_experimental(); // ~ ERROR use of experimental item\n-        foo.trait_experimental(); // ~ ERROR use of experimental item\n+        foo.method_experimental(); //~ ERROR use of experimental item\n+        foo.trait_experimental(); //~ ERROR use of experimental item\n \n         experimental_text(); //~ ERROR use of experimental item: text\n-        foo.method_experimental_text(); // ~ ERROR use of experimental item: text\n-        foo.trait_experimental_text(); // ~ ERROR use of experimental item: text\n+        foo.method_experimental_text(); //~ ERROR use of experimental item: text\n+        foo.trait_experimental_text(); //~ ERROR use of experimental item: text\n \n         unstable(); //~ ERROR use of unstable item\n-        foo.method_unstable(); // ~ ERROR use of unstable item\n-        foo.trait_unstable(); // ~ ERROR use of unstable item\n+        foo.method_unstable(); //~ ERROR use of unstable item\n+        foo.trait_unstable(); //~ ERROR use of unstable item\n \n         unstable_text(); //~ ERROR use of unstable item: text\n-        foo.method_unstable_text(); // ~ ERROR use of unstable item: text\n-        foo.trait_unstable_text(); // ~ ERROR use of unstable item: text\n+        foo.method_unstable_text(); //~ ERROR use of unstable item: text\n+        foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n \n         unmarked(); //~ ERROR use of unmarked item\n-        foo.method_unmarked(); // ~ ERROR use of unmarked item\n-        foo.trait_unmarked(); // ~ ERROR use of unmarked item\n+        foo.method_unmarked(); //~ ERROR use of unmarked item\n+        foo.trait_unmarked(); //~ ERROR use of unmarked item\n \n         stable();\n         foo.method_stable();\n@@ -102,6 +102,28 @@ mod cross_crate {\n         let _ = FrozenVariant;\n         let _ = LockedVariant;\n     }\n+\n+    fn test_method_param<F: Trait>(foo: F) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_experimental(); //~ ERROR use of experimental item\n+        foo.trait_experimental_text(); //~ ERROR use of experimental item: text\n+        foo.trait_unstable(); //~ ERROR use of unstable item\n+        foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n+        foo.trait_unmarked(); //~ ERROR use of unmarked item\n+        foo.trait_stable();\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_experimental(); //~ ERROR use of experimental item\n+        foo.trait_experimental_text(); //~ ERROR use of experimental item: text\n+        foo.trait_unstable(); //~ ERROR use of unstable item\n+        foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n+        foo.trait_unmarked(); //~ ERROR use of unmarked item\n+        foo.trait_stable();\n+    }\n }\n \n mod this_crate {\n@@ -259,32 +281,32 @@ mod this_crate {\n         let foo = MethodTester;\n \n         deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); // ~ ERROR use of deprecated item\n-        foo.trait_deprecated(); // ~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n \n         deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); // ~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); // ~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n \n         experimental(); //~ ERROR use of experimental item\n-        foo.method_experimental(); // ~ ERROR use of experimental item\n-        foo.trait_experimental(); // ~ ERROR use of experimental item\n+        foo.method_experimental(); //~ ERROR use of experimental item\n+        foo.trait_experimental(); //~ ERROR use of experimental item\n \n         experimental_text(); //~ ERROR use of experimental item: text\n-        foo.method_experimental_text(); // ~ ERROR use of experimental item: text\n-        foo.trait_experimental_text(); // ~ ERROR use of experimental item: text\n+        foo.method_experimental_text(); //~ ERROR use of experimental item: text\n+        foo.trait_experimental_text(); //~ ERROR use of experimental item: text\n \n         unstable(); //~ ERROR use of unstable item\n-        foo.method_unstable(); // ~ ERROR use of unstable item\n-        foo.trait_unstable(); // ~ ERROR use of unstable item\n+        foo.method_unstable(); //~ ERROR use of unstable item\n+        foo.trait_unstable(); //~ ERROR use of unstable item\n \n         unstable_text(); //~ ERROR use of unstable item: text\n-        foo.method_unstable_text(); // ~ ERROR use of unstable item: text\n-        foo.trait_unstable_text(); // ~ ERROR use of unstable item: text\n+        foo.method_unstable_text(); //~ ERROR use of unstable item: text\n+        foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n \n         unmarked(); //~ ERROR use of unmarked item\n-        foo.method_unmarked(); // ~ ERROR use of unmarked item\n-        foo.trait_unmarked(); // ~ ERROR use of unmarked item\n+        foo.method_unmarked(); //~ ERROR use of unmarked item\n+        foo.trait_unmarked(); //~ ERROR use of unmarked item\n \n         stable();\n         foo.method_stable();\n@@ -335,6 +357,28 @@ mod this_crate {\n         let _ = FrozenVariant;\n         let _ = LockedVariant;\n     }\n+\n+    fn test_method_param<F: Trait>(foo: F) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_experimental(); //~ ERROR use of experimental item\n+        foo.trait_experimental_text(); //~ ERROR use of experimental item: text\n+        foo.trait_unstable(); //~ ERROR use of unstable item\n+        foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n+        foo.trait_unmarked(); //~ ERROR use of unmarked item\n+        foo.trait_stable();\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_experimental(); //~ ERROR use of experimental item\n+        foo.trait_experimental_text(); //~ ERROR use of experimental item: text\n+        foo.trait_unstable(); //~ ERROR use of unstable item\n+        foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n+        foo.trait_unmarked(); //~ ERROR use of unmarked item\n+        foo.trait_stable();\n+    }\n }\n \n fn main() {}"}]}