{"sha": "1e4b66300551149fd49ce499aaae5c231cefde7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNGI2NjMwMDU1MTE0OWZkNDljZTQ5OWFhYWU1YzIzMWNlZmRlN2Y=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-05-16T20:10:05Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-05-16T21:00:56Z"}, "message": "Improve documentation for drop elaboration", "tree": {"sha": "03625309989d314f4a336fd54c0d152d03074bd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03625309989d314f4a336fd54c0d152d03074bd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e4b66300551149fd49ce499aaae5c231cefde7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4b66300551149fd49ce499aaae5c231cefde7f", "html_url": "https://github.com/rust-lang/rust/commit/1e4b66300551149fd49ce499aaae5c231cefde7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e4b66300551149fd49ce499aaae5c231cefde7f/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed084b0b8341c974769a0328f61851b0e1fc17fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed084b0b8341c974769a0328f61851b0e1fc17fa", "html_url": "https://github.com/rust-lang/rust/commit/ed084b0b8341c974769a0328f61851b0e1fc17fa"}], "stats": {"total": 108, "additions": 99, "deletions": 9}, "files": [{"sha": "e3982c654d5fa809cb34ba80d967d3c87fe56e19", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e4b66300551149fd49ce499aaae5c231cefde7f/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4b66300551149fd49ce499aaae5c231cefde7f/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=1e4b66300551149fd49ce499aaae5c231cefde7f", "patch": "@@ -277,7 +277,18 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     }\n \n     fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n-        if let DropFlagMode::Shallow = mode { DropStyle::Static } else { DropStyle::Open }\n+        match mode {\n+            DropFlagMode::Shallow => {\n+                // Drops for the contained fields are \"shallow\" and \"static\" - they will simply call\n+                // the field's own drop glue.\n+                DropStyle::Static\n+            }\n+            DropFlagMode::Deep => {\n+                // The top-level drop is \"deep\" and \"open\" - it will be elaborated to a drop ladder\n+                // dropping each field contained in the value.\n+                DropStyle::Open\n+            }\n+        }\n     }\n \n     fn get_drop_flag(&mut self, _path: Self::Path) -> Option<Operand<'tcx>> {"}, {"sha": "ed999c6871bb67fca0e73cc370f42d0d9ffb143e", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 87, "deletions": 8, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1e4b66300551149fd49ce499aaae5c231cefde7f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4b66300551149fd49ce499aaae5c231cefde7f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=1e4b66300551149fd49ce499aaae5c231cefde7f", "patch": "@@ -12,10 +12,15 @@ use std::fmt;\n \n use std::convert::TryInto;\n \n+/// The value of an inserted drop flag.\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum DropFlagState {\n-    Present, // i.e., initialized\n-    Absent,  // i.e., deinitialized or \"moved\"\n+    /// The tracked value is initialized and needs to be dropped when leaving its scope.\n+    Present,\n+\n+    /// The tracked value is uninitialized or was moved out of and does not need to be dropped when\n+    /// leaving its scope.\n+    Absent,\n }\n \n impl DropFlagState {\n@@ -27,23 +32,42 @@ impl DropFlagState {\n     }\n }\n \n+/// Describes how/if a value should be dropped.\n #[derive(Debug)]\n pub enum DropStyle {\n+    /// The value is already dead at the drop location, no drop will be executed.\n     Dead,\n+\n+    /// The value is known to always be initialized at the drop location, drop will always be\n+    /// executed.\n     Static,\n+\n+    /// Whether the value needs to be dropped depends on its drop flag.\n     Conditional,\n+\n+    /// An \"open\" drop is one where only the fields of a value are dropped.\n+    ///\n+    /// For example, this happens when moving out of a struct field: The rest of the struct will be\n+    /// dropped in such an \"open\" drop. It is also used to generate drop glue for the individual\n+    /// components of a value, for example for dropping array elements.\n     Open,\n }\n \n+/// Which drop flags to affect/check with an operation.\n #[derive(Debug)]\n pub enum DropFlagMode {\n+    /// Only affect the top-level drop flag, not that of any contained fields.\n     Shallow,\n+    /// Affect all nested drop flags in addition to the top-level one.\n     Deep,\n }\n \n+/// Describes if unwinding is necessary and where to unwind to if a panic occurs.\n #[derive(Copy, Clone, Debug)]\n pub enum Unwind {\n+    /// Unwind to this block.\n     To(BasicBlock),\n+    /// Already in an unwind path, any panic will cause an abort.\n     InCleanup,\n }\n \n@@ -74,20 +98,58 @@ impl Unwind {\n }\n \n pub trait DropElaborator<'a, 'tcx>: fmt::Debug {\n+    /// The type representing paths that can be moved out of.\n+    ///\n+    /// Users can move out of individual fields of a struct, such as `a.b.c`. This type is used to\n+    /// represent such move paths. Sometimes tracking individual move paths is not necessary, in\n+    /// which case this may be set to (for example) `()`.\n     type Path: Copy + fmt::Debug;\n \n+    // Accessors\n+\n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n     fn body(&self) -> &'a Body<'tcx>;\n     fn tcx(&self) -> TyCtxt<'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n+    // Drop logic\n+\n+    /// Returns how `path` should be dropped, given `mode`.\n     fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n+\n+    /// Returns the drop flag of `path` as a MIR `Operand` (or `None` if `path` has no drop flag).\n     fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>>;\n+\n+    /// Modifies the MIR patch so that the drop flag of `path` (if any) is cleared at `location`.\n+    ///\n+    /// If `mode` is deep, drop flags of all child paths should also be cleared by inserting\n+    /// additional statements.\n     fn clear_drop_flag(&mut self, location: Location, path: Self::Path, mode: DropFlagMode);\n \n+    // Subpaths\n+\n+    /// Returns the subpath of a field of `path` (or `None` if there is no dedicated subpath).\n+    ///\n+    /// If this returns `None`, `field` will not get a dedicated drop flag.\n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path>;\n+\n+    /// Returns the subpath of a dereference of `path` (or `None` if there is no dedicated subpath).\n+    ///\n+    /// If this returns `None`, `*path` will not get a dedicated drop flag.\n+    ///\n+    /// This is only relevant for `Box<T>`, where the contained `T` can be moved out of the box.\n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path>;\n+\n+    /// Returns the subpath of downcasting `path` to one of its variants.\n+    ///\n+    /// If this returns `None`, the downcast of `path` will not get a dedicated drop flag.\n     fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path>;\n+\n+    /// Returns the subpath of indexing a fixed-size array `path`.\n+    ///\n+    /// If this returns `None`, elements of `path` will not get a dedicated drop flag.\n+    ///\n+    /// This is only relevant for array patterns, which can move out of individual array elements.\n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path>;\n }\n \n@@ -106,6 +168,14 @@ where\n     unwind: Unwind,\n }\n \n+/// \"Elaborates\" a drop of `place`/`path` and patches `bb`'s terminator to execute it.\n+///\n+/// The passed `elaborator` is used to determine what should happen at the drop terminator. It\n+/// decides whether the drop can be statically determined or whether it needs a dynamic drop flag,\n+/// and whether the drop is \"open\", ie. should be expanded to drop all subfields of the dropped\n+/// value.\n+///\n+/// When this returns, the MIR patch in the `elaborator` contains the necessary changes.\n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n@@ -346,9 +416,7 @@ where\n         let interior = self.tcx().mk_place_deref(self.place);\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n-        let succ = self.succ; // FIXME(#43234)\n-        let unwind = self.unwind;\n-        let succ = self.box_free_block(adt, substs, succ, unwind);\n+        let succ = self.box_free_block(adt, substs, self.succ, self.unwind);\n         let unwind_succ =\n             self.unwind.map(|unwind| self.box_free_block(adt, substs, unwind, Unwind::InCleanup));\n \n@@ -829,6 +897,8 @@ where\n         self.drop_flag_test_block(drop_block, succ, unwind)\n     }\n \n+    /// Creates a block that resets the drop flag. If `mode` is deep, all children drop flags will\n+    /// also be cleared.\n     fn drop_flag_reset_block(\n         &mut self,\n         mode: DropFlagMode,\n@@ -850,13 +920,15 @@ where\n \n     fn elaborated_drop_block(&mut self) -> BasicBlock {\n         debug!(\"elaborated_drop_block({:?})\", self);\n-        let unwind = self.unwind; // FIXME(#43234)\n-        let succ = self.succ;\n-        let blk = self.drop_block(succ, unwind);\n+        let blk = self.drop_block(self.succ, self.unwind);\n         self.elaborate_drop(blk);\n         blk\n     }\n \n+    /// Creates a block that frees the backing memory of a `Box` if its drop is required (either\n+    /// statically or by checking its drop flag).\n+    ///\n+    /// The contained value will not be dropped.\n     fn box_free_block(\n         &mut self,\n         adt: &'tcx ty::AdtDef,\n@@ -868,6 +940,8 @@ where\n         self.drop_flag_test_block(block, target, unwind)\n     }\n \n+    /// Creates a block that frees the backing memory of a `Box` (without dropping the contained\n+    /// value).\n     fn unelaborated_free_block(\n         &mut self,\n         adt: &'tcx ty::AdtDef,\n@@ -914,6 +988,11 @@ where\n         self.new_block(unwind, block)\n     }\n \n+    /// Returns the block to jump to in order to test the drop flag and execute the drop.\n+    ///\n+    /// Depending on the required `DropStyle`, this might be a generated block with an `if`\n+    /// terminator (for dynamic/open drops), or it might be `on_set` or `on_unset` itself, in case\n+    /// the drop can be statically determined.\n     fn drop_flag_test_block(\n         &mut self,\n         on_set: BasicBlock,"}]}