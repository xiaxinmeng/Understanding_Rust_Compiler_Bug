{"sha": "ce72993488af962892ea3991aef7b9f6e72e40f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNzI5OTM0ODhhZjk2Mjg5MmVhMzk5MWFlZjdiOWY2ZTcyZTQwZjA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-15T18:19:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-15T18:19:50Z"}, "message": "Reformat source tree (minus a couple tests that are still grumpy).", "tree": {"sha": "79e22617071c79b190187ac4ab5ec298643ce142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79e22617071c79b190187ac4ab5ec298643ce142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce72993488af962892ea3991aef7b9f6e72e40f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce72993488af962892ea3991aef7b9f6e72e40f0", "html_url": "https://github.com/rust-lang/rust/commit/ce72993488af962892ea3991aef7b9f6e72e40f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce72993488af962892ea3991aef7b9f6e72e40f0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d381823e2aa1524eabeb3219d7dc1d5007e6096", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d381823e2aa1524eabeb3219d7dc1d5007e6096", "html_url": "https://github.com/rust-lang/rust/commit/8d381823e2aa1524eabeb3219d7dc1d5007e6096"}], "stats": {"total": 32598, "additions": 13667, "deletions": 18931}, "files": [{"sha": "79039cb55d4b70808878e3a052111dec2f9009b0", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,101 +1,136 @@\n-// FIXME: Most of these should be uints.\n \n+\n+\n+// FIXME: Most of these should be uints.\n const int rc_base_field_refcnt = 0;\n \n+\n // FIXME: import from std::dbg when imported consts work.\n const uint const_refcount = 0x7bad_face_u;\n \n const int task_field_refcnt = 0;\n+\n const int task_field_stk = 2;\n+\n const int task_field_runtime_sp = 3;\n+\n const int task_field_rust_sp = 4;\n+\n const int task_field_gc_alloc_chain = 5;\n+\n const int task_field_dom = 6;\n+\n const int n_visible_task_fields = 7;\n \n const int dom_field_interrupt_flag = 1;\n \n const int frame_glue_fns_field_mark = 0;\n+\n const int frame_glue_fns_field_drop = 1;\n+\n const int frame_glue_fns_field_reloc = 2;\n \n const int box_rc_field_refcnt = 0;\n+\n const int box_rc_field_body = 1;\n \n const int general_code_alignment = 16;\n \n const int vec_elt_rc = 0;\n+\n const int vec_elt_alloc = 1;\n+\n const int vec_elt_fill = 2;\n+\n const int vec_elt_pad = 3;\n+\n const int vec_elt_data = 4;\n \n const int tydesc_field_first_param = 0;\n+\n const int tydesc_field_size = 1;\n+\n const int tydesc_field_align = 2;\n+\n const int tydesc_field_take_glue = 3;\n+\n const int tydesc_field_drop_glue = 4;\n+\n const int tydesc_field_free_glue = 5;\n+\n const int tydesc_field_sever_glue = 6;\n+\n const int tydesc_field_mark_glue = 7;\n+\n+\n // FIXME no longer used in rustc, drop when rustboot is gone\n const int tydesc_field_obj_drop_glue = 8;\n+\n const int tydesc_field_is_stateful = 9;\n+\n const int tydesc_field_cmp_glue = 10;\n+\n const int n_tydesc_fields = 11;\n \n const uint cmp_glue_op_eq = 0u;\n+\n const uint cmp_glue_op_lt = 1u;\n-const uint cmp_glue_op_le = 2u;\n \n+const uint cmp_glue_op_le = 2u;\n \n const int obj_field_vtbl = 0;\n+\n const int obj_field_box = 1;\n \n const int obj_body_elt_tydesc = 0;\n+\n const int obj_body_elt_typarams = 1;\n+\n const int obj_body_elt_fields = 2;\n-const int obj_body_elt_with_obj = 3; /* The base object to which an anonymous\n-                                      * object is attached */\n \n-const int fn_field_code = 0;\n+const int obj_body_elt_with_obj = 3;\n+\n+ /* The base object to which an anonymous\n+  * object is attached */\n+ const int fn_field_code = 0;\n+\n const int fn_field_box = 1;\n \n const int closure_elt_tydesc = 0;\n+\n const int closure_elt_target = 1;\n+\n const int closure_elt_bindings = 2;\n+\n const int closure_elt_ty_params = 3;\n \n const uint ivec_default_length = 8u;\n \n const uint ivec_elt_len = 0u;\n+\n const uint ivec_elt_alen = 1u;\n+\n const uint ivec_elt_elems = 2u;\n+\n const uint ivec_heap_stub_elt_zero = 0u;\n+\n const uint ivec_heap_stub_elt_alen = 1u;\n+\n const uint ivec_heap_stub_elt_ptr = 2u;\n+\n const uint ivec_heap_elt_len = 0u;\n-const uint ivec_heap_elt_elems = 1u;\n \n+const uint ivec_heap_elt_elems = 1u;\n \n const int worst_case_glue_call_args = 7;\n \n-fn memcpy_glue_name() -> str {\n-    ret \"rust_memcpy_glue\";\n-}\n-\n-fn bzero_glue_name() -> str {\n-    ret \"rust_bzero_glue\";\n-}\n+fn memcpy_glue_name() -> str { ret \"rust_memcpy_glue\"; }\n \n-fn yield_glue_name() -> str {\n-    ret \"rust_yield_glue\";\n-}\n+fn bzero_glue_name() -> str { ret \"rust_bzero_glue\"; }\n \n-fn no_op_type_glue_name() -> str {\n-    ret \"rust_no_op_type_glue\";\n-}\n+fn yield_glue_name() -> str { ret \"rust_yield_glue\"; }\n \n+fn no_op_type_glue_name() -> str { ret \"rust_no_op_type_glue\"; }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "bb20d79d7c914ab7c377f5f1058cb717eb5207c8", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 84, "deletions": 136, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import driver::session;\n import lib::llvm::llvm;\n import middle::trans;\n@@ -13,7 +14,6 @@ import std::sha1::sha1;\n import std::sort;\n import trans::crate_ctxt;\n import front::ast;\n-\n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::mk_pass_manager;\n@@ -32,34 +32,28 @@ tag output_type {\n \n fn llvm_err(session::session sess, str msg) {\n     auto buf = llvm::LLVMRustGetLastError();\n-    if ((buf as uint) == 0u) {\n+    if (buf as uint == 0u) {\n         sess.err(msg);\n-    } else {\n-        sess.err(msg + \": \" + str::str_from_cstr(buf));\n-    }\n+    } else { sess.err(msg + \": \" + str::str_from_cstr(buf)); }\n     fail;\n }\n \n fn link_intrinsics(session::session sess, ModuleRef llmod) {\n     auto path = fs::connect(sess.get_opts().sysroot, \"intrinsics.bc\");\n     auto membuf =\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(str::buf(path));\n-    if ((membuf as uint) == 0u) {\n+    if (membuf as uint == 0u) {\n         llvm_err(sess, \"installation problem: couldn't open \" + path);\n         fail;\n     }\n-\n     auto llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n     llvm::LLVMDisposeMemoryBuffer(membuf);\n-\n-    if ((llintrinsicsmod as uint) == 0u) {\n+    if (llintrinsicsmod as uint == 0u) {\n         llvm_err(sess, \"installation problem: couldn't parse intrinsics.bc\");\n         fail;\n     }\n-\n     auto linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n     llvm::LLVMDisposeModule(llintrinsicsmod);\n-\n     if (linkres == False) {\n         llvm_err(sess, \"couldn't link the module with the intrinsics\");\n         fail;\n@@ -68,9 +62,8 @@ fn link_intrinsics(session::session sess, ModuleRef llmod) {\n \n mod write {\n     fn is_object_or_assembly_or_exe(output_type ot) -> bool {\n-        if ( (ot == output_type_assembly) ||\n-             (ot == output_type_object) ||\n-             (ot == output_type_exe) ) {\n+        if (ot == output_type_assembly || ot == output_type_object ||\n+                ot == output_type_exe) {\n             ret true;\n         }\n         ret false;\n@@ -83,39 +76,30 @@ mod write {\n         auto stem;\n         if (dot_pos < 0) {\n             stem = output_path;\n-        } else {\n-            stem = str::substr(output_path, 0u, dot_pos as uint);\n-        }\n+        } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n         ret stem + \".\" + extension;\n     }\n-\n     fn run_passes(session::session sess, ModuleRef llmod, str output) {\n-\n         auto opts = sess.get_opts();\n-\n-        if (opts.time_llvm_passes) {\n-          llvm::LLVMRustEnableTimePasses();\n-        }\n-\n+        if (opts.time_llvm_passes) { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n-\n         auto pm = mk_pass_manager();\n         auto td = mk_target_data(x86::get_data_layout());\n         llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n-\n         // TODO: run the linter here also, once there are llvm-c bindings for\n         // it.\n \n         // Generate a pre-optimization intermediate file if -save-temps was\n         // specified.\n+\n         if (opts.save_temps) {\n             alt (opts.output_type) {\n                 case (output_type_bitcode) {\n                     if (opts.optimize != 0u) {\n-                        auto filename = mk_intermediate_name(output,\n-                                                             \"no-opt.bc\");\n+                        auto filename =\n+                            mk_intermediate_name(output, \"no-opt.bc\");\n                         llvm::LLVMWriteBitcodeToFile(llmod,\n-                                                    str::buf(filename));\n+                                                     str::buf(filename));\n                     }\n                 }\n                 case (_) {\n@@ -124,109 +108,95 @@ mod write {\n                 }\n             }\n         }\n-\n-        if (opts.verify) {\n-            llvm::LLVMAddVerifierPass(pm.llpm);\n-        }\n-\n+        if (opts.verify) { llvm::LLVMAddVerifierPass(pm.llpm); }\n         // FIXME: This is mostly a copy of the bits of opt's -O2 that are\n         // available in the C api.\n         // FIXME2: We might want to add optimization levels like -O1, -O2,\n         // -Os, etc\n         // FIXME3: Should we expose and use the pass lists used by the opt\n         // tool?\n+\n         if (opts.optimize != 0u) {\n             auto fpm = mk_pass_manager();\n             llvm::LLVMAddTargetData(td.lltd, fpm.llpm);\n             llvm::LLVMAddStandardFunctionPasses(fpm.llpm, 2u);\n             llvm::LLVMRunPassManager(fpm.llpm, llmod);\n-\n             let uint threshold = 225u;\n-            if (opts.optimize == 3u) {\n-                threshold = 275u;\n-            }\n-\n+            if (opts.optimize == 3u) { threshold = 275u; }\n             llvm::LLVMAddStandardModulePasses(pm.llpm,\n                                               // optimization level\n                                               opts.optimize,\n                                               False, // optimize for size\n-                                              True,  // unit-at-a-time\n-                                              True,  // unroll loops\n-                                              True,  // simplify lib calls\n-                                              threshold); // inline threshold\n-        }\n+                                               True, // unit-at-a-time\n+                                               True, // unroll loops\n+                                               True, // simplify lib calls\n+                                               threshold); // inline threshold\n \n-        if (opts.verify) {\n-            llvm::LLVMAddVerifierPass(pm.llpm);\n         }\n-\n+        if (opts.verify) { llvm::LLVMAddVerifierPass(pm.llpm); }\n         if (is_object_or_assembly_or_exe(opts.output_type)) {\n             let int LLVMAssemblyFile = 0;\n             let int LLVMObjectFile = 1;\n             let int LLVMNullFile = 2;\n             auto FileType;\n-            if ((opts.output_type == output_type_object) ||\n-                (opts.output_type == output_type_exe)) {\n+            if (opts.output_type == output_type_object ||\n+                    opts.output_type == output_type_exe) {\n                 FileType = LLVMObjectFile;\n-            } else {\n-                FileType = LLVMAssemblyFile;\n-            }\n-\n+            } else { FileType = LLVMAssemblyFile; }\n             // Write optimized bitcode if --save-temps was on.\n-            if (opts.save_temps) {\n \n+            if (opts.save_temps) {\n                 // Always output the bitcode file with --save-temps\n+\n                 auto filename = mk_intermediate_name(output, \"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n                 llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n                 pm = mk_pass_manager();\n-\n                 // Save the assembly file if -S is used\n+\n                 if (opts.output_type == output_type_assembly) {\n-                        llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                               str::buf(x86::get_target_triple()),\n-                               str::buf(output), LLVMAssemblyFile);\n+                    auto triple = x86::get_target_triple();\n+                    llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n+                                                  str::buf(triple),\n+                                                  str::buf(output),\n+                                                  LLVMAssemblyFile);\n                 }\n \n                 // Save the object file for -c or --save-temps alone\n                 // This .o is needed when an exe is built\n-                if ((opts.output_type == output_type_object) ||\n-                    (opts.output_type == output_type_exe)) {\n-                        llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                               str::buf(x86::get_target_triple()),\n-                               str::buf(output), LLVMObjectFile);\n-               }\n+                if (opts.output_type == output_type_object ||\n+                        opts.output_type == output_type_exe) {\n+                    auto triple = x86::get_target_triple();\n+                    llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n+                                                  str::buf(triple),\n+                                                  str::buf(output),\n+                                                  LLVMObjectFile);\n+                }\n             } else {\n-\n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n+                auto triple = x86::get_target_triple();\n                 llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                     str::buf(x86::get_target_triple()),\n-                                     str::buf(output),\n-                                     FileType);\n+                                              str::buf(triple),\n+                                              str::buf(output), FileType);\n             }\n-\n             // Clean up and return\n+\n             llvm::LLVMDisposeModule(llmod);\n-            if (opts.time_llvm_passes) {\n-              llvm::LLVMRustPrintPassTimings();\n-            }\n+            if (opts.time_llvm_passes) { llvm::LLVMRustPrintPassTimings(); }\n             ret;\n         }\n-\n         // If only a bitcode file is asked for by using the '--emit-llvm'\n         // flag, then output it here\n-        llvm::LLVMRunPassManager(pm.llpm, llmod);\n \n+        llvm::LLVMRunPassManager(pm.llpm, llmod);\n         llvm::LLVMWriteBitcodeToFile(llmod, str::buf(output));\n         llvm::LLVMDisposeModule(llmod);\n-\n-        if (opts.time_llvm_passes) {\n-          llvm::LLVMRustPrintPassTimings();\n-        }\n+        if (opts.time_llvm_passes) { llvm::LLVMRustPrintPassTimings(); }\n     }\n }\n \n+\n /*\n  * Name mangling and its relationship to metadata. This is complex. Read\n  * carefully.\n@@ -277,81 +247,63 @@ mod write {\n  *    system linkers understand.\n  *\n  */\n-\n-\n iter crate_export_metas(&ast::crate c) -> @ast::meta_item {\n     for (@ast::crate_directive cdir in c.node.directives) {\n         alt (cdir.node) {\n             case (ast::cdir_meta(?v, ?mis)) {\n                 if (v == ast::export_meta) {\n-                    for (@ast::meta_item mi in mis) {\n-                        put mi;\n-                    }\n+                    for (@ast::meta_item mi in mis) { put mi; }\n                 }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n }\n \n-\n iter crate_local_metas(&ast::crate c) -> @ast::meta_item {\n     for (@ast::crate_directive cdir in c.node.directives) {\n         alt (cdir.node) {\n             case (ast::cdir_meta(?v, ?mis)) {\n                 if (v == ast::local_meta) {\n-                    for (@ast::meta_item mi in mis) {\n-                        put mi;\n-                    }\n+                    for (@ast::meta_item mi in mis) { put mi; }\n                 }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n }\n \n-\n-fn get_crate_meta_export(&session::session sess,\n-                         &ast::crate c, str k, str default,\n-                         bool warn_default) -> str {\n+fn get_crate_meta_export(&session::session sess, &ast::crate c, str k,\n+                         str default, bool warn_default) -> str {\n     let vec[@ast::meta_item] v = [];\n     for each (@ast::meta_item mi in crate_export_metas(c)) {\n-        if (mi.node.key == k) {\n-            v += [mi];\n-        }\n+        if (mi.node.key == k) { v += [mi]; }\n     }\n     alt (vec::len(v)) {\n         case (0u) {\n             if (warn_default) {\n-                sess.warn(#fmt(\"missing meta '%s', using '%s' as default\",\n-                               k, default));\n+                sess.warn(#fmt(\"missing meta '%s', using '%s' as default\", k,\n+                               default));\n             }\n             ret default;\n         }\n-        case (1u) {\n-            ret v.(0).node.value;\n-        }\n+        case (1u) { ret v.(0).node.value; }\n         case (_) {\n             sess.span_err(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n         }\n     }\n }\n \n+\n // This calculates CMH as defined above\n fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n-    fn lteq(&@ast::meta_item ma,\n-            &@ast::meta_item mb) -> bool {\n+    fn lteq(&@ast::meta_item ma, &@ast::meta_item mb) -> bool {\n         ret ma.node.key <= mb.node.key;\n     }\n-\n-    fn len_and_str(&str s) -> str {\n-        ret #fmt(\"%u_%s\", str::byte_len(s), s);\n-    }\n-\n-    let vec[mutable @ast::meta_item] v = [mutable];\n+    fn len_and_str(&str s) -> str { ret #fmt(\"%u_%s\", str::byte_len(s), s); }\n+    let vec[mutable @ast::meta_item] v = [mutable ];\n     for each (@ast::meta_item mi in crate_export_metas(crate)) {\n-        if (mi.node.key != \"name\" &&\n-            mi.node.key != \"vers\") {\n+        if (mi.node.key != \"name\" && mi.node.key != \"vers\") {\n             v += [mutable mi];\n         }\n     }\n@@ -365,10 +317,10 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n     ret truncated_sha1_result(sha);\n }\n \n-fn crate_meta_name(&session::session sess, &ast::crate crate,\n-                       &str output) -> str {\n+fn crate_meta_name(&session::session sess, &ast::crate crate, &str output) ->\n+   str {\n     auto os = str::split(fs::basename(output), '.' as u8);\n-    assert vec::len(os) >= 2u;\n+    assert (vec::len(os) >= 2u);\n     vec::pop(os);\n     ret get_crate_meta_export(sess, crate, \"name\", str::connect(os, \".\"),\n                               sess.get_opts().shared);\n@@ -384,15 +336,16 @@ fn truncated_sha1_result(sha1 sha) -> str {\n }\n \n \n-\n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t,\n-               str crate_meta_name,\n+fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t, str crate_meta_name,\n                str crate_meta_extras_hash) -> str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n-    auto cx = @rec(ds=metadata::def_to_str, tcx=tcx,\n-                   abbrevs=metadata::ac_no_abbrevs);\n+\n+    auto cx =\n+        @rec(ds=metadata::def_to_str,\n+             tcx=tcx,\n+             abbrevs=metadata::ac_no_abbrevs);\n     sha.reset();\n     sha.input_str(crate_meta_name);\n     sha.input_str(\"-\");\n@@ -401,6 +354,7 @@ fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t,\n     sha.input_str(metadata::Encode::ty_str(cx, t));\n     auto hash = truncated_sha1_result(sha);\n     // Prefix with _ so that it never blends into adjacent digits\n+\n     ret \"_\" + hash;\n }\n \n@@ -409,54 +363,49 @@ fn get_symbol_hash(&@crate_ctxt ccx, &ty::t t) -> str {\n     alt (ccx.type_sha1s.find(t)) {\n         case (some(?h)) { hash = h; }\n         case (none) {\n-            hash = symbol_hash(ccx.tcx, ccx.sha, t,\n-                               ccx.crate_meta_name,\n-                               ccx.crate_meta_extras_hash);\n+            hash =\n+                symbol_hash(ccx.tcx, ccx.sha, t, ccx.crate_meta_name,\n+                            ccx.crate_meta_extras_hash);\n             ccx.type_sha1s.insert(t, hash);\n         }\n     }\n     ret hash;\n }\n \n-\n fn mangle(&vec[str] ss) -> str {\n-\n     // Follow C++ namespace-mangling style\n \n     auto n = \"_ZN\"; // Begin name-sequence.\n \n-    for (str s in ss) {\n-        n += #fmt(\"%u%s\", str::byte_len(s), s);\n-    }\n-\n+    for (str s in ss) { n += #fmt(\"%u%s\", str::byte_len(s), s); }\n     n += \"E\"; // End name-sequence.\n+\n     ret n;\n }\n \n-\n fn exported_name(&vec[str] path, &str hash, &str vers) -> str {\n     // FIXME: versioning isn't working yet\n+\n     ret mangle(path + [hash]); //  + \"@\" + vers;\n+\n }\n \n-fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path,\n-                        &ty::t t) -> str {\n+fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n     auto hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.crate_meta_vers);\n }\n \n-fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t,\n-                                     &str name) -> str {\n+fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) ->\n+   str {\n     auto f = metadata::def_to_str;\n     auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::ac_no_abbrevs);\n     auto s = pretty::ppaux::ty_to_short_str(ccx.tcx, t);\n-\n     auto hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);\n }\n \n fn mangle_internal_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n-                                       &str flav) -> str {\n+                                        &str flav) -> str {\n     ret mangle(path + [ccx.names.next(flav)]);\n }\n \n@@ -467,7 +416,6 @@ fn mangle_internal_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n fn mangle_internal_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n     ret ccx.names.next(flav);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "50a3f462dd30e3467bcd0c9676e658ffbf50117f", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 92, "deletions": 97, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,7 +1,6 @@\n-import middle::trans;\n \n+import middle::trans;\n import trans::decl_cdecl_fn;\n-\n import trans::T_f32;\n import trans::T_f64;\n import trans::T_fn;\n@@ -20,49 +19,47 @@ import trans::T_str;\n import trans::T_taskptr;\n import trans::T_tydesc;\n import trans::T_void;\n-\n import lib::llvm::type_names;\n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::llvm::TypeRef;\n \n-type upcalls = rec(\n-    ValueRef grow_task,\n-    ValueRef log_int,\n-    ValueRef log_float,\n-    ValueRef log_double,\n-    ValueRef log_str,\n-    ValueRef trace_word,\n-    ValueRef trace_str,\n-    ValueRef new_port,\n-    ValueRef del_port,\n-    ValueRef new_chan,\n-    ValueRef flush_chan,\n-    ValueRef del_chan,\n-    ValueRef clone_chan,\n-    ValueRef _yield,\n-    ValueRef sleep,\n-    ValueRef _join,\n-    ValueRef send,\n-    ValueRef recv,\n-    ValueRef _fail,\n-    ValueRef kill,\n-    ValueRef exit,\n-    ValueRef malloc,\n-    ValueRef free,\n-    ValueRef mark,\n-    ValueRef new_str,\n-    ValueRef new_vec,\n-    ValueRef vec_grow,\n-    ValueRef vec_append,\n-    ValueRef get_type_desc,\n-    ValueRef new_task,\n-    ValueRef start_task,\n-    ValueRef new_thread,\n-    ValueRef start_thread,\n-    ValueRef ivec_resize,\n-    ValueRef ivec_spill\n-);\n+type upcalls =\n+    rec(ValueRef grow_task,\n+        ValueRef log_int,\n+        ValueRef log_float,\n+        ValueRef log_double,\n+        ValueRef log_str,\n+        ValueRef trace_word,\n+        ValueRef trace_str,\n+        ValueRef new_port,\n+        ValueRef del_port,\n+        ValueRef new_chan,\n+        ValueRef flush_chan,\n+        ValueRef del_chan,\n+        ValueRef clone_chan,\n+        ValueRef _yield,\n+        ValueRef sleep,\n+        ValueRef _join,\n+        ValueRef send,\n+        ValueRef recv,\n+        ValueRef _fail,\n+        ValueRef kill,\n+        ValueRef exit,\n+        ValueRef malloc,\n+        ValueRef free,\n+        ValueRef mark,\n+        ValueRef new_str,\n+        ValueRef new_vec,\n+        ValueRef vec_grow,\n+        ValueRef vec_append,\n+        ValueRef get_type_desc,\n+        ValueRef new_task,\n+        ValueRef start_task,\n+        ValueRef new_thread,\n+        ValueRef start_thread,\n+        ValueRef ivec_resize,\n+        ValueRef ivec_spill);\n \n fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n     fn decl(type_names tn, ModuleRef llmod, str name, vec[TypeRef] tys,\n@@ -72,69 +69,67 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n         auto fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-\n     auto dv = bind decl(tn, llmod, _, _, T_void());\n     auto d = bind decl(tn, llmod, _, _, _);\n-\n     // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n-    let vec[TypeRef] empty_vec = [];\n \n-    ret @rec(\n-        grow_task=dv(\"grow_task\", [T_size_t()]),\n-        log_int=dv(\"log_int\", [T_i32(), T_i32()]),\n-        log_float=dv(\"log_float\", [T_i32(), T_f32()]),\n-        log_double=dv(\"log_double\", [T_i32(), T_ptr(T_f64())]),\n-        log_str=dv(\"log_str\", [T_i32(), T_ptr(T_str())]),\n-        trace_word=dv(\"trace_word\", [T_int()]),\n-        trace_str=dv(\"trace_str\", [T_ptr(T_i8())]),\n-        new_port=d(\"new_port\", [T_size_t()], T_opaque_port_ptr()),\n-        del_port=dv(\"del_port\", [T_opaque_port_ptr()]),\n-        new_chan=d(\"new_chan\", [T_opaque_port_ptr()], T_opaque_chan_ptr()),\n-        flush_chan=dv(\"flush_chan\", [T_opaque_chan_ptr()]),\n-        del_chan=dv(\"del_chan\", [T_opaque_chan_ptr()]),\n-        clone_chan=d(\"clone_chan\", [T_taskptr(tn), T_opaque_chan_ptr()],\n-                     T_opaque_chan_ptr()),\n-        _yield=dv(\"yield\", empty_vec),\n-        sleep=dv(\"sleep\", [T_size_t()]),\n-        _join=dv(\"join\", [T_taskptr(tn)]),\n-        send=dv(\"send\", [T_opaque_chan_ptr(), T_ptr(T_i8())]),\n-        recv=dv(\"recv\", [T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n-        _fail=dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n-        kill=dv(\"kill\", [T_taskptr(tn)]),\n-        exit=dv(\"exit\", empty_vec),\n-        malloc=d(\"malloc\", [T_size_t(), T_ptr(T_tydesc(tn))],\n-                               T_ptr(T_i8())),\n-        free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n-        mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n-        new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()], T_ptr(T_str())),\n-        new_vec=d(\"new_vec\", [T_size_t(), T_ptr(T_tydesc(tn))],\n-                                 T_opaque_vec_ptr()),\n-        vec_grow=d(\"vec_grow\", [T_opaque_vec_ptr(), T_size_t(),\n-                                   T_ptr(T_int()), T_ptr(T_tydesc(tn))],\n-                   T_opaque_vec_ptr()),\n-        vec_append=d(\"vec_append\", [T_ptr(T_tydesc(tn)), T_ptr(T_tydesc(tn)),\n-                                    T_ptr(T_opaque_vec_ptr()),\n-                                    T_opaque_vec_ptr(), T_bool()], T_void()),\n-        get_type_desc=d(\"get_type_desc\",\n-                        [T_ptr(T_nil()), T_size_t(), T_size_t(),\n-                         T_size_t(), T_ptr(T_ptr(T_tydesc(tn)))],\n-                        T_ptr(T_tydesc(tn))),\n-        new_task=d(\"new_task\", [T_ptr(T_str())], T_taskptr(tn)),\n-        start_task=d(\"start_task\", [T_taskptr(tn), \n-                                    T_int(), T_int(), T_size_t()],\n-                     T_taskptr(tn)),\n-        new_thread=d(\"new_thread\", [T_ptr(T_i8())], T_taskptr(tn)),\n-        start_thread=d(\"start_thread\", [T_taskptr(tn), T_int(), T_int(),\n-                                           T_int(), T_size_t()],\n-                       T_taskptr(tn)),\n-        ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n-                      T_void()),\n-        ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],\n-                     T_void())\n-    );\n+    let vec[TypeRef] empty_vec = [];\n+    ret @rec(grow_task=dv(\"grow_task\", [T_size_t()]),\n+             log_int=dv(\"log_int\", [T_i32(), T_i32()]),\n+             log_float=dv(\"log_float\", [T_i32(), T_f32()]),\n+             log_double=dv(\"log_double\", [T_i32(), T_ptr(T_f64())]),\n+             log_str=dv(\"log_str\", [T_i32(), T_ptr(T_str())]),\n+             trace_word=dv(\"trace_word\", [T_int()]),\n+             trace_str=dv(\"trace_str\", [T_ptr(T_i8())]),\n+             new_port=d(\"new_port\", [T_size_t()], T_opaque_port_ptr()),\n+             del_port=dv(\"del_port\", [T_opaque_port_ptr()]),\n+             new_chan=d(\"new_chan\", [T_opaque_port_ptr()],\n+                        T_opaque_chan_ptr()),\n+             flush_chan=dv(\"flush_chan\", [T_opaque_chan_ptr()]),\n+             del_chan=dv(\"del_chan\", [T_opaque_chan_ptr()]),\n+             clone_chan=d(\"clone_chan\", [T_taskptr(tn), T_opaque_chan_ptr()],\n+                          T_opaque_chan_ptr()),\n+             _yield=dv(\"yield\", empty_vec),\n+             sleep=dv(\"sleep\", [T_size_t()]),\n+             _join=dv(\"join\", [T_taskptr(tn)]),\n+             send=dv(\"send\", [T_opaque_chan_ptr(), T_ptr(T_i8())]),\n+             recv=dv(\"recv\", [T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n+             _fail=dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+             kill=dv(\"kill\", [T_taskptr(tn)]),\n+             exit=dv(\"exit\", empty_vec),\n+             malloc=d(\"malloc\", [T_size_t(), T_ptr(T_tydesc(tn))],\n+                      T_ptr(T_i8())),\n+             free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n+             mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n+             new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()],\n+                       T_ptr(T_str())),\n+             new_vec=d(\"new_vec\", [T_size_t(), T_ptr(T_tydesc(tn))],\n+                       T_opaque_vec_ptr()),\n+             vec_grow=d(\"vec_grow\",\n+                        [T_opaque_vec_ptr(), T_size_t(), T_ptr(T_int()),\n+                         T_ptr(T_tydesc(tn))], T_opaque_vec_ptr()),\n+             vec_append=d(\"vec_append\",\n+                          [T_ptr(T_tydesc(tn)), T_ptr(T_tydesc(tn)),\n+                           T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(),\n+                           T_bool()], T_void()),\n+             get_type_desc=d(\"get_type_desc\",\n+                             [T_ptr(T_nil()), T_size_t(), T_size_t(),\n+                              T_size_t(), T_ptr(T_ptr(T_tydesc(tn)))],\n+                             T_ptr(T_tydesc(tn))),\n+             new_task=d(\"new_task\", [T_ptr(T_str())], T_taskptr(tn)),\n+             start_task=d(\"start_task\",\n+                          [T_taskptr(tn), T_int(), T_int(), T_size_t()],\n+                          T_taskptr(tn)),\n+             new_thread=d(\"new_thread\", [T_ptr(T_i8())], T_taskptr(tn)),\n+             start_thread=d(\"start_thread\",\n+                            [T_taskptr(tn), T_int(), T_int(), T_int(),\n+                             T_size_t()], T_taskptr(tn)),\n+             ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n+                           T_void()),\n+             ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],\n+                          T_void()));\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "f6fc78351913f5e81d600210cb3ea885fa13e64f", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,47 +1,38 @@\n+\n import lib::llvm::llvm;\n import lib::llvm::llvm::ModuleRef;\n import std::str;\n import std::vec;\n import std::os::target_os;\n import util::common::istr;\n \n-fn get_module_asm() -> str {\n-    ret \"\";\n-}\n+fn get_module_asm() -> str { ret \"\"; }\n \n fn get_meta_sect_name() -> str {\n-    if (str::eq(target_os(), \"macos\")) {\n-        ret \"__DATA,__note.rustc\";\n-    }\n-    if (str::eq(target_os(), \"win32\")) {\n-        ret \".note.rustc\";\n-    }\n+    if (str::eq(target_os(), \"macos\")) { ret \"__DATA,__note.rustc\"; }\n+    if (str::eq(target_os(), \"win32\")) { ret \".note.rustc\"; }\n     ret \".note.rustc\";\n }\n \n fn get_data_layout() -> str {\n     if (str::eq(target_os(), \"macos\")) {\n-      ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64\" +\n-        \"-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128\" +\n-        \"-n8:16:32\";\n+        ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\"\n+            + \"-i32:32:32-i64:32:64\"\n+            + \"-f32:32:32-f64:32:64-v64:64:64\"\n+            + \"-v128:128:128-a0:0:64-f80:128:128\"\n+            + \"-n8:16:32\";\n     }\n     if (str::eq(target_os(), \"win32\")) {\n-      ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n+        ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n     ret \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n fn get_target_triple() -> str {\n-    if (str::eq(target_os(), \"macos\")) {\n-        ret \"i686-apple-darwin\";\n-    }\n-    if (str::eq(target_os(), \"win32\")) {\n-        ret \"i686-pc-mingw32\";\n-    }\n+    if (str::eq(target_os(), \"macos\")) { ret \"i686-apple-darwin\"; }\n+    if (str::eq(target_os(), \"win32\")) { ret \"i686-pc-mingw32\"; }\n     ret \"i686-unknown-linux-gnu\";\n }\n-\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "9aef46058eecf127b95aa40d32a3c0e60233a8c9", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 168, "deletions": 220, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,5 +1,6 @@\n-// -*- rust -*-\n \n+\n+// -*- rust -*-\n import front::creader;\n import front::parser;\n import front::token;\n@@ -15,7 +16,6 @@ import pretty::ppaux;\n import back::link;\n import lib::llvm;\n import util::common;\n-\n import std::fs;\n import std::map::mk_hashmap;\n import std::option;\n@@ -25,99 +25,78 @@ import std::str;\n import std::vec;\n import std::io;\n import std::run;\n-\n import std::getopts;\n import std::getopts::optopt;\n import std::getopts::optmulti;\n import std::getopts::optflag;\n import std::getopts::optflagopt;\n import std::getopts::opt_present;\n-\n import back::link::output_type;\n \n-tag pp_mode {\n-    ppm_normal;\n-    ppm_typed;\n-    ppm_identified;\n-}\n-\n-fn default_environment(session::session sess,\n-                       str argv0,\n-                       str input) -> eval::env {\n-\n-    auto libc = alt (sess.get_targ_cfg().os) {\n-        case (session::os_win32) { \"msvcrt.dll\" }\n-        case (session::os_macos) { \"libc.dylib\" }\n-        case (session::os_linux) { \"libc.so.6\" }\n-        case (_) { \"libc.so\" }\n-    };\n+tag pp_mode { ppm_normal; ppm_typed; ppm_identified; }\n \n-    ret [// Target bindings.\n+fn default_environment(session::session sess, str argv0, str input) ->\n+   eval::env {\n+    auto libc =\n+        alt (sess.get_targ_cfg().os) {\n+            case (session::os_win32) { \"msvcrt.dll\" }\n+            case (session::os_macos) { \"libc.dylib\" }\n+            case (session::os_linux) { \"libc.so.6\" }\n+            case (_) { \"libc.so\" }\n+        };\n+    ret [ // Target bindings.\n          tup(\"target_os\", eval::val_str(std::os::target_os())),\n          tup(\"target_arch\", eval::val_str(\"x86\")),\n          tup(\"target_libc\", eval::val_str(libc)),\n-\n          // Build bindings.\n          tup(\"build_compiler\", eval::val_str(argv0)),\n-         tup(\"build_input\", eval::val_str(input))\n-         ];\n+         tup(\"build_input\", eval::val_str(input))];\n }\n \n-fn parse_input(session::session sess,\n-               parser::parser p,\n-               str input) -> @ast::crate {\n+fn parse_input(session::session sess, parser::parser p, str input) ->\n+   @ast::crate {\n     ret if (str::ends_with(input, \".rc\")) {\n-        parser::parse_crate_from_crate_file(p)\n-    } else if (str::ends_with(input, \".rs\")) {\n-       parser::parse_crate_from_source_file(p)\n-    } else {\n-        sess.err(\"unknown input file type: \" + input);\n-        fail\n-    };\n+            parser::parse_crate_from_crate_file(p)\n+        } else if (str::ends_with(input, \".rs\")) {\n+            parser::parse_crate_from_source_file(p)\n+        } else { sess.err(\"unknown input file type: \" + input); fail };\n }\n \n-fn time[T](bool do_it, str what, fn()->T thunk) -> T {\n+fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n     if (!do_it) { ret thunk(); }\n-\n     auto start = std::time::get_time();\n     auto rv = thunk();\n     auto end = std::time::get_time();\n-\n     // FIXME: Actually do timeval math.\n-    log_err #fmt(\"time: %s took %u s\", what, (end.sec - start.sec) as uint);\n+\n+    log_err #fmt(\"time: %s took %u s\", what, end.sec - start.sec as uint);\n     ret rv;\n }\n \n-fn compile_input(session::session sess,\n-                 eval::env env,\n-                 str input, str output) {\n+fn compile_input(session::session sess, eval::env env, str input,\n+                 str output) {\n     auto time_passes = sess.get_opts().time_passes;\n     auto def = tup(ast::local_crate, 0);\n     auto p = parser::new_parser(sess, env, def, input, 0u, 0u);\n-    auto crate = time(time_passes, \"parsing\",\n-                      bind parse_input(sess, p, input));\n-    if (sess.get_opts().output_type == link::output_type_none) {ret;}\n-\n-    auto def_map = time(time_passes, \"resolution\",\n-                        bind resolve::resolve_crate(sess, crate));\n-\n+    auto crate =\n+        time(time_passes, \"parsing\", bind parse_input(sess, p, input));\n+    if (sess.get_opts().output_type == link::output_type_none) { ret; }\n+    auto def_map =\n+        time(time_passes, \"resolution\",\n+             bind resolve::resolve_crate(sess, crate));\n     auto ty_cx = ty::mk_ctxt(sess, def_map);\n     time[()](time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n-\n     if (sess.get_opts().run_typestate) {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n-\n     time(time_passes, \"alias checking\",\n          bind middle::alias::check_crate(@ty_cx, def_map, crate));\n-\n     auto llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n                                     bind trans::trans_crate(sess, crate,\n                                                             ty_cx, output));\n-\n     time[()](time_passes, \"LLVM passes\",\n              bind link::write::run_passes(sess, llmod, output));\n }\n@@ -127,7 +106,6 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n     auto def = tup(ast::local_crate, 0);\n     auto p = front::parser::new_parser(sess, env, def, input, 0u, 0u);\n     auto crate = parse_input(sess, p, input);\n-\n     auto mode;\n     alt (ppm) {\n         case (ppm_typed) {\n@@ -139,22 +117,20 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n         case (ppm_normal) { mode = ppaux::mo_untyped; }\n         case (ppm_identified) { mode = ppaux::mo_identified; }\n     }\n-\n     pprust::print_file(sess, crate.node.module, input, std::io::stdout(),\n                        mode);\n }\n \n fn version(str argv0) {\n     auto vers = \"unknown version\";\n     auto env_vers = #env(\"CFG_VERSION\");\n-    if (str::byte_len(env_vers) != 0u) {\n-        vers = env_vers;\n-    }\n+    if (str::byte_len(env_vers) != 0u) { vers = env_vers; }\n     io::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n }\n \n fn usage(str argv0) {\n-    io::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) + \"\n+    io::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) +\n+                               \"\n options:\n \n     -h --help          display this message\n@@ -185,35 +161,27 @@ options:\n \n fn get_os(str triple) -> session::os {\n     ret if (str::find(triple, \"win32\") >= 0 ||\n-            str::find(triple, \"mingw32\") >= 0 ) {\n-        session::os_win32\n-    } else if (str::find(triple, \"darwin\") >= 0) {\n-        session::os_macos\n-    } else if (str::find(triple, \"linux\") >= 0) {\n-        session::os_linux\n-    } else {\n-        log_err \"Unknown operating system!\";\n-        fail\n-    };\n+                str::find(triple, \"mingw32\") >= 0) {\n+            session::os_win32\n+        } else if (str::find(triple, \"darwin\") >= 0) {\n+            session::os_macos\n+        } else if (str::find(triple, \"linux\") >= 0) {\n+            session::os_linux\n+        } else { log_err \"Unknown operating system!\"; fail };\n }\n \n fn get_arch(str triple) -> session::arch {\n-    ret if (str::find(triple, \"i386\") >= 0 ||\n-            str::find(triple, \"i486\") >= 0 ||\n-            str::find(triple, \"i586\") >= 0 ||\n-            str::find(triple, \"i686\") >= 0 ||\n-            str::find(triple, \"i786\") >= 0 ) {\n-        session::arch_x86\n-    } else if (str::find(triple, \"x86_64\") >= 0) {\n-        session::arch_x64\n-    } else if (str::find(triple, \"arm\") >= 0 ||\n-        str::find(triple, \"xscale\") >= 0 ) {\n-        session::arch_arm\n-    }\n-    else {\n-        log_err (\"Unknown architecture! \" + triple);\n-        fail\n-    };\n+    ret if (str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0\n+                || str::find(triple, \"i586\") >= 0 ||\n+                str::find(triple, \"i686\") >= 0 ||\n+                str::find(triple, \"i786\") >= 0) {\n+            session::arch_x86\n+        } else if (str::find(triple, \"x86_64\") >= 0) {\n+            session::arch_x64\n+        } else if (str::find(triple, \"arm\") >= 0 ||\n+                       str::find(triple, \"xscale\") >= 0) {\n+            session::arch_arm\n+        } else { log_err \"Unknown architecture! \" + triple; fail };\n }\n \n fn get_default_sysroot(str binary) -> str {\n@@ -225,34 +193,29 @@ fn get_default_sysroot(str binary) -> str {\n fn build_target_config() -> @session::config {\n     let str triple =\n         std::str::rustrt::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n-\n     let @session::config target_cfg =\n-        @rec(os = get_os(triple),\n-             arch = get_arch(triple),\n-             int_type = common::ty_i32,\n-             uint_type = common::ty_u32,\n-             float_type = common::ty_f64);\n-\n+        @rec(os=get_os(triple),\n+             arch=get_arch(triple),\n+             int_type=common::ty_i32,\n+             uint_type=common::ty_u32,\n+             float_type=common::ty_f64);\n     ret target_cfg;\n }\n \n-fn build_session_options(str binary, getopts::match match)\n-    -> @session::options {\n+fn build_session_options(str binary, getopts::match match) ->\n+   @session::options {\n     auto shared = opt_present(match, \"shared\");\n     auto library_search_paths = getopts::opt_strs(match, \"L\");\n-\n-    auto output_type = if (opt_present(match, \"parse-only\")) {\n-        link::output_type_none\n-    } else if (opt_present(match, \"S\")) {\n-        link::output_type_assembly\n-    } else if (opt_present(match, \"c\")) {\n-        link::output_type_object\n-    } else if (opt_present(match, \"emit-llvm\")) {\n-        link::output_type_bitcode\n-    } else {\n-        link::output_type_exe\n-    };\n-\n+    auto output_type =\n+        if (opt_present(match, \"parse-only\")) {\n+            link::output_type_none\n+        } else if (opt_present(match, \"S\")) {\n+            link::output_type_assembly\n+        } else if (opt_present(match, \"c\")) {\n+            link::output_type_object\n+        } else if (opt_present(match, \"emit-llvm\")) {\n+            link::output_type_bitcode\n+        } else { link::output_type_exe };\n     auto verify = !opt_present(match, \"noverify\");\n     auto save_temps = opt_present(match, \"save-temps\");\n     auto debuginfo = opt_present(match, \"g\");\n@@ -261,47 +224,44 @@ fn build_session_options(str binary, getopts::match match)\n     auto time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n     auto run_typestate = !opt_present(match, \"no-typestate\");\n     auto sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n-\n-    let uint opt_level = if (opt_present(match, \"O\")) {\n-        if (opt_present(match, \"OptLevel\")) {\n-            log_err \"error: -O and --OptLevel both provided\";\n-            fail;\n-        }\n-        2u\n-    } else if (opt_present(match, \"OptLevel\")) {\n-        alt (getopts::opt_str(match, \"OptLevel\")) {\n-            case (\"0\") { 0u }\n-            case (\"1\") { 1u }\n-            case (\"2\") { 2u }\n-            case (\"3\") { 3u }\n-            case (_) {\n-                log_err \"error: optimization level needs to be between 0-3\";\n-                fail\n+    let uint opt_level =\n+        if (opt_present(match, \"O\")) {\n+            if (opt_present(match, \"OptLevel\")) {\n+                log_err \"error: -O and --OptLevel both provided\";\n+                fail;\n             }\n-        }\n-    } else {\n-        0u\n-    };\n-\n-    auto sysroot = alt (sysroot_opt) {\n-        case (none) { get_default_sysroot(binary) }\n-        case (some(?s)) { s }\n-    };\n-\n+            2u\n+        } else if (opt_present(match, \"OptLevel\")) {\n+            alt (getopts::opt_str(match, \"OptLevel\")) {\n+                case (\"0\") { 0u }\n+                case (\"1\") { 1u }\n+                case (\"2\") { 2u }\n+                case (\"3\") { 3u }\n+                case (_) {\n+                    log_err \"error: optimization level needs \" +\n+                        \"to be between 0-3\";\n+                    fail\n+                }\n+            }\n+        } else { 0u };\n+    auto sysroot =\n+        alt (sysroot_opt) {\n+            case (none) { get_default_sysroot(binary) }\n+            case (some(?s)) { s }\n+        };\n     let @session::options sopts =\n-        @rec(shared = shared,\n-             optimize = opt_level,\n-             debuginfo = debuginfo,\n-             verify = verify,\n-             run_typestate = run_typestate,\n-             save_temps = save_temps,\n-             stats = stats,\n-             time_passes = time_passes,\n-             time_llvm_passes = time_llvm_passes,\n-             output_type = output_type,\n-             library_search_paths = library_search_paths,\n-             sysroot = sysroot);\n-\n+        @rec(shared=shared,\n+             optimize=opt_level,\n+             debuginfo=debuginfo,\n+             verify=verify,\n+             run_typestate=run_typestate,\n+             save_temps=save_temps,\n+             stats=stats,\n+             time_passes=time_passes,\n+             time_llvm_passes=time_llvm_passes,\n+             output_type=output_type,\n+             library_search_paths=library_search_paths,\n+             sysroot=sysroot);\n     ret sopts;\n }\n \n@@ -311,61 +271,51 @@ fn build_session(@session::options sopts) -> session::session {\n     auto target_crate_num = 0;\n     let vec[@ast::meta_item] md = [];\n     auto sess =\n-        session::session(target_crate_num, target_cfg, sopts,\n-                         crate_cache, md, front::codemap::new_codemap());\n+        session::session(target_crate_num, target_cfg, sopts, crate_cache, md,\n+                         front::codemap::new_codemap());\n     ret sess;\n }\n \n fn parse_pretty(session::session sess, &str name) -> pp_mode {\n-    if (str::eq(name, \"normal\")) { ret ppm_normal; }\n-    else if (str::eq(name, \"typed\")) { ret ppm_typed; }\n-    else if (str::eq(name, \"identified\")) { ret ppm_identified; }\n-\n+    if (str::eq(name, \"normal\")) {\n+        ret ppm_normal;\n+    } else if (str::eq(name, \"typed\")) {\n+        ret ppm_typed;\n+    } else if (str::eq(name, \"identified\")) { ret ppm_identified; }\n     sess.err(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n-             \"`identified`\");\n+                 \"`identified`\");\n }\n \n fn main(vec[str] args) {\n-\n-    auto opts = [optflag(\"h\"), optflag(\"help\"),\n-                 optflag(\"v\"), optflag(\"version\"),\n-                 optflag(\"glue\"), optflag(\"emit-llvm\"),\n-                 optflagopt(\"pretty\"),\n-                 optflag(\"ls\"), optflag(\"parse-only\"),\n-                 optflag(\"O\"), optopt(\"OptLevel\"),\n-                 optflag(\"shared\"), optmulti(\"L\"),\n-                 optflag(\"S\"), optflag(\"c\"), optopt(\"o\"), optflag(\"g\"),\n-                 optflag(\"save-temps\"), optopt(\"sysroot\"),\n-                 optflag(\"stats\"),\n-                 optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n-                 optflag(\"no-typestate\"), optflag(\"noverify\")];\n-\n+    auto opts =\n+        [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n+         optflag(\"glue\"), optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n+         optflag(\"ls\"), optflag(\"parse-only\"), optflag(\"O\"),\n+         optopt(\"OptLevel\"), optflag(\"shared\"), optmulti(\"L\"), optflag(\"S\"),\n+         optflag(\"c\"), optopt(\"o\"), optflag(\"g\"), optflag(\"save-temps\"),\n+         optopt(\"sysroot\"), optflag(\"stats\"), optflag(\"time-passes\"),\n+         optflag(\"time-llvm-passes\"), optflag(\"no-typestate\"),\n+         optflag(\"noverify\")];\n     auto binary = vec::shift[str](args);\n-    auto match = alt (getopts::getopts(args, opts)) {\n-        case (getopts::success(?m)) { m }\n-        case (getopts::failure(?f)) {\n-            log_err #fmt(\"error: %s\", getopts::fail_str(f));\n-            fail\n-        }\n-    };\n-\n-    if (opt_present(match, \"h\") ||\n-        opt_present(match, \"help\")) {\n+    auto match =\n+        alt (getopts::getopts(args, opts)) {\n+            case (getopts::success(?m)) { m }\n+            case (getopts::failure(?f)) {\n+                log_err #fmt(\"error: %s\", getopts::fail_str(f));\n+                fail\n+            }\n+        };\n+    if (opt_present(match, \"h\") || opt_present(match, \"help\")) {\n         usage(binary);\n         ret;\n     }\n-\n-    if (opt_present(match, \"v\") ||\n-        opt_present(match, \"version\")) {\n+    if (opt_present(match, \"v\") || opt_present(match, \"version\")) {\n         version(binary);\n         ret;\n     }\n-\n     auto sopts = build_session_options(binary, match);\n     auto sess = build_session(sopts);\n-\n     auto n_inputs = vec::len[str](match.free);\n-\n     auto output_file = getopts::opt_maybe_str(match, \"o\");\n     auto glue = opt_present(match, \"glue\");\n     if (glue) {\n@@ -376,33 +326,30 @@ fn main(vec[str] args) {\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n-\n     if (n_inputs == 0u) {\n         sess.err(\"No input filename given.\");\n     } else if (n_inputs > 1u) {\n         sess.err(\"Multiple input filenames provided.\");\n     }\n-\n     auto ifile = match.free.(0);\n     let str saved_out_filename = \"\";\n     auto env = default_environment(sess, binary, ifile);\n-    auto pretty = option::map[str,pp_mode](bind parse_pretty(sess, _),\n-        getopts::opt_default(match, \"pretty\", \"normal\"));\n+    auto pretty =\n+        option::map[str,\n+                    pp_mode](bind parse_pretty(sess, _),\n+                             getopts::opt_default(match, \"pretty\", \"normal\"));\n     auto ls = opt_present(match, \"ls\");\n-\n     alt (pretty) {\n         case (some[pp_mode](?ppm)) {\n             pretty_print_input(sess, env, ifile, ppm);\n             ret;\n         }\n-        case (none[pp_mode]) { /* continue */ }\n+        case (none[pp_mode]) {/* continue */ }\n     }\n-\n     if (ls) {\n         front::creader::list_file_metadata(ifile, std::io::stdout());\n         ret;\n     }\n-\n     alt (output_file) {\n         case (none) {\n             let vec[str] parts = str::split(ifile, '.' as u8);\n@@ -412,28 +359,29 @@ fn main(vec[str] args) {\n                 case (link::output_type_none) { parts += [\"pp\"]; }\n                 case (link::output_type_bitcode) { parts += [\"bc\"]; }\n                 case (link::output_type_assembly) { parts += [\"s\"]; }\n-\n-                // Object and exe output both use the '.o' extension here\n-                case (link::output_type_object) { parts += [\"o\"]; }\n+                case (\n+                     // Object and exe output both use the '.o' extension here\n+                     link::output_type_object) {\n+                    parts += [\"o\"];\n+                }\n                 case (link::output_type_exe) { parts += [\"o\"]; }\n             }\n             auto ofile = str::connect(parts, \".\");\n             compile_input(sess, env, ifile, ofile);\n         }\n         case (some(?ofile)) {\n             // FIXME: what about windows? This will create a foo.exe.o.\n+\n             saved_out_filename = ofile;\n             auto temp_filename;\n             alt (sopts.output_type) {\n                 case (link::output_type_exe) {\n                     // FIXME: what about shared?\n+\n                     temp_filename = ofile + \".o\";\n                 }\n-                case (_) {\n-                    temp_filename = ofile;\n-                }\n+                case (_) { temp_filename = ofile; }\n             }\n-\n             compile_input(sess, env, ifile, temp_filename);\n         }\n     }\n@@ -449,41 +397,42 @@ fn main(vec[str] args) {\n         let str stage = \"-L\" + binary_dir;\n         let vec[str] gcc_args;\n         let str prog = \"gcc\";\n-\n         // The invocations of gcc share some flags across platforms\n-        let vec[str] common_cflags = [\"-fno-strict-aliasing\", \"-fPIC\",\n-                           \"-Wall\", \"-fno-rtti\", \"-fno-exceptions\", \"-g\"];\n-        let vec[str] common_libs = [stage, \"-Lrustllvm\", \"-Lrt\",\n-                           \"-lrustrt\", \"-lrustllvm\", \"-lstd\", \"-lm\"];\n \n+        let vec[str] common_cflags =\n+            [\"-fno-strict-aliasing\", \"-fPIC\", \"-Wall\", \"-fno-rtti\",\n+             \"-fno-exceptions\", \"-g\"];\n+        let vec[str] common_libs =\n+            [stage, \"-Lrustllvm\", \"-Lrt\", \"-lrustrt\", \"-lrustllvm\", \"-lstd\",\n+             \"-lm\"];\n         alt (sess.get_targ_cfg().os) {\n             case (session::os_win32) {\n-                gcc_args = common_cflags + [\n-                            \"-march=i686\", \"-O2\",\n-                            glu, main, \"-o\",\n-                            saved_out_filename,\n-                            saved_out_filename + \".o\"] + common_libs;\n+                gcc_args =\n+                    common_cflags +\n+                        [\"-march=i686\", \"-O2\", glu, main, \"-o\",\n+                         saved_out_filename, saved_out_filename + \".o\"] +\n+                        common_libs;\n             }\n             case (session::os_macos) {\n-                gcc_args = common_cflags + [\n-                           \"-arch i386\", \"-O0\", \"-m32\",\n-                           glu, main, \"-o\",\n-                           saved_out_filename,\n-                           saved_out_filename + \".o\"] + common_libs;\n+                gcc_args =\n+                    common_cflags +\n+                        [\"-arch i386\", \"-O0\", \"-m32\", glu, main, \"-o\",\n+                         saved_out_filename, saved_out_filename + \".o\"] +\n+                        common_libs;\n             }\n             case (session::os_linux) {\n-                gcc_args = common_cflags + [\n-                           \"-march=i686\", \"-O2\", \"-m32\",\n-                           glu, main, \"-o\",\n-                           saved_out_filename,\n-                           saved_out_filename + \".o\"] + common_libs;\n+                gcc_args =\n+                    common_cflags +\n+                        [\"-march=i686\", \"-O2\", \"-m32\", glu, main, \"-o\",\n+                         saved_out_filename, saved_out_filename + \".o\"] +\n+                        common_libs;\n             }\n         }\n-\n         // We run 'gcc' here\n-        run::run_program(prog, gcc_args);\n \n+        run::run_program(prog, gcc_args);\n         // Clean up on Darwin\n+\n         if (sess.get_targ_cfg().os == session::os_macos) {\n             run::run_program(\"dsymutil\", [saved_out_filename]);\n         }\n@@ -494,7 +443,6 @@ fn main(vec[str] args) {\n         }\n     }\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "48c85e7bafe789de9f7fc67e9d7caa6cfae8052c", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 49, "deletions": 99, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import front::ast;\n import front::codemap;\n import util::common::span;\n@@ -10,163 +11,112 @@ import std::option;\n import std::option::some;\n import std::option::none;\n \n-tag os {\n-    os_win32;\n-    os_macos;\n-    os_linux;\n-}\n-\n-tag arch {\n-    arch_x86;\n-    arch_x64;\n-    arch_arm;\n-}\n-\n-type config = rec(os os,\n-                  arch arch,\n-                  ty_mach int_type,\n-                  ty_mach uint_type,\n-                  ty_mach float_type);\n-\n-type options = rec(bool shared,\n-                   uint optimize,\n-                   bool debuginfo,\n-                   bool verify,\n-                   bool run_typestate,\n-                   bool save_temps,\n-                   bool stats,\n-                   bool time_passes,\n-                   bool time_llvm_passes,\n-                   back::link::output_type output_type,\n-                   vec[str] library_search_paths,\n-                   str sysroot);\n-\n-type crate_metadata = rec(str name,\n-                          vec[u8] data);\n+tag os { os_win32; os_macos; os_linux; }\n+\n+tag arch { arch_x86; arch_x64; arch_arm; }\n+\n+type config =\n+    rec(os os,\n+        arch arch,\n+        ty_mach int_type,\n+        ty_mach uint_type,\n+        ty_mach float_type);\n+\n+type options =\n+    rec(bool shared,\n+        uint optimize,\n+        bool debuginfo,\n+        bool verify,\n+        bool run_typestate,\n+        bool save_temps,\n+        bool stats,\n+        bool time_passes,\n+        bool time_llvm_passes,\n+        back::link::output_type output_type,\n+        vec[str] library_search_paths,\n+        str sysroot);\n+\n+type crate_metadata = rec(str name, vec[u8] data);\n \n fn span_to_str(span sp, codemap::codemap cm) -> str {\n     auto lo = codemap::lookup_pos(cm, sp.lo);\n     auto hi = codemap::lookup_pos(cm, sp.hi);\n-    ret (#fmt(\"%s:%u:%u:%u:%u\", lo.filename, lo.line,\n-              lo.col, hi.line, hi.col));\n+    ret #fmt(\"%s:%u:%u:%u:%u\", lo.filename, lo.line, lo.col, hi.line, hi.col);\n }\n \n fn emit_diagnostic(option::t[span] sp, str msg, str kind, u8 color,\n                    codemap::codemap cm) {\n     auto ss = \"<input>:0:0:0:0\";\n     alt (sp) {\n-        case (some(?ssp)) {\n-            ss = span_to_str(ssp, cm);\n-        }\n-        case (none) {}\n+        case (some(?ssp)) { ss = span_to_str(ssp, cm); }\n+        case (none) { }\n     }\n     io::stdout().write_str(ss + \": \");\n-\n     if (term::color_supported()) {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-\n     io::stdout().write_str(#fmt(\"%s:\", kind));\n-\n     if (term::color_supported()) {\n         term::reset(io::stdout().get_buf_writer());\n     }\n-\n     io::stdout().write_str(#fmt(\" %s\\n\", msg));\n }\n \n-state obj session(ast::crate_num cnum,\n-                  @config targ_cfg, @options opts,\n-                  map::hashmap[int, crate_metadata] crates,\n-                  mutable vec[@ast::meta_item] metadata,\n-                  codemap::codemap cm) {\n-\n-    fn get_targ_cfg() -> @config {\n-        ret targ_cfg;\n-    }\n-\n-    fn get_opts() -> @options {\n-        ret opts;\n-    }\n-\n-    fn get_targ_crate_num() -> ast::crate_num {\n-        ret cnum;\n-    }\n-\n+obj session(ast::crate_num cnum,\n+            @config targ_cfg,\n+            @options opts,\n+            map::hashmap[int, crate_metadata] crates,\n+            mutable vec[@ast::meta_item] metadata,\n+            codemap::codemap cm) {\n+    fn get_targ_cfg() -> @config { ret targ_cfg; }\n+    fn get_opts() -> @options { ret opts; }\n+    fn get_targ_crate_num() -> ast::crate_num { ret cnum; }\n     fn span_err(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n+\n         emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n         fail;\n     }\n-\n     fn err(str msg) -> ! {\n         emit_diagnostic(none[span], msg, \"error\", 9u8, cm);\n         fail;\n     }\n-\n-    fn add_metadata(vec[@ast::meta_item] data) {\n-        metadata = metadata + data;\n-    }\n-    fn get_metadata() -> vec[@ast::meta_item] {\n-        ret metadata;\n-    }\n-\n+    fn add_metadata(vec[@ast::meta_item] data) { metadata = metadata + data; }\n+    fn get_metadata() -> vec[@ast::meta_item] { ret metadata; }\n     fn span_warn(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n+\n         emit_diagnostic(some(sp), msg, \"warning\", 11u8, cm);\n     }\n-\n     fn warn(str msg) {\n         emit_diagnostic(none[span], msg, \"warning\", 11u8, cm);\n     }\n-\n     fn span_note(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n+\n         emit_diagnostic(some(sp), msg, \"note\", 10u8, cm);\n     }\n-\n     fn span_bug(span sp, str msg) -> ! {\n         self.span_err(sp, #fmt(\"internal compiler error %s\", msg));\n     }\n-\n     fn bug(str msg) -> ! {\n         self.err(#fmt(\"internal compiler error %s\", msg));\n     }\n-\n     fn span_unimpl(span sp, str msg) -> ! {\n         self.span_bug(sp, \"unimplemented \" + msg);\n     }\n-\n-    fn unimpl(str msg) -> ! {\n-        self.bug(\"unimplemented \" + msg);\n-    }\n-\n-    fn get_external_crate(int num) -> crate_metadata {\n-        ret crates.get(num);\n-    }\n-\n+    fn unimpl(str msg) -> ! { self.bug(\"unimplemented \" + msg); }\n+    fn get_external_crate(int num) -> crate_metadata { ret crates.get(num); }\n     fn set_external_crate(int num, &crate_metadata metadata) {\n         crates.insert(num, metadata);\n     }\n-\n-    fn has_external_crate(int num) -> bool {\n-        ret crates.contains_key(num);\n-    }\n-\n-    fn get_codemap() -> codemap::codemap {\n-        ret cm;\n-    }\n-\n+    fn has_external_crate(int num) -> bool { ret crates.contains_key(num); }\n+    fn get_codemap() -> codemap::codemap { ret cm; }\n     fn lookup_pos(uint pos) -> codemap::loc {\n         ret codemap::lookup_pos(cm, pos);\n     }\n-\n-    fn span_str(span sp) -> str {\n-        ret span_to_str(sp, self.get_codemap());\n-    }\n+    fn span_str(span sp) -> str { ret span_to_str(sp, self.get_codemap()); }\n }\n-\n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "6a2f4d986ffb8f5f8d78a3120434ec87d309b4de", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 181, "deletions": 200, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::option;\n import std::str;\n import std::vec;\n@@ -9,15 +10,17 @@ import util::common::filename;\n type ident = str;\n \n type path_ = rec(vec[ident] idents, vec[@ty] types);\n+\n type path = spanned[path_];\n \n-fn path_name(&path p) -> str {\n-    ret str::connect(p.node.idents, \"::\");\n-}\n+fn path_name(&path p) -> str { ret str::connect(p.node.idents, \"::\"); }\n \n type crate_num = int;\n+\n const crate_num local_crate = 0;\n+\n type def_num = int;\n+\n type def_id = tup(crate_num, def_num);\n \n type ty_param = ident;\n@@ -33,7 +36,9 @@ tag def {\n     def_const(def_id);\n     def_arg(def_id);\n     def_local(def_id);\n-    def_variant(def_id /* tag */, def_id /* variant */);\n+    def_variant(def_id, /* tag */def_id);\n+\n+    /* variant */\n     def_ty(def_id);\n     def_ty_arg(uint);\n     def_binding(def_id);\n@@ -44,9 +49,7 @@ tag def {\n \n fn variant_def_ids(&def d) -> tup(def_id, def_id) {\n     alt (d) {\n-        case (def_variant(?tag_id, ?var_id)) {\n-            ret tup(tag_id, var_id);\n-        }\n+        case (def_variant(?tag_id, ?var_id)) { ret tup(tag_id, var_id); }\n     }\n }\n \n@@ -72,16 +75,14 @@ fn def_id_of_def(def d) -> def_id {\n }\n \n type crate = spanned[crate_];\n-type crate_ = rec(vec[@crate_directive] directives,\n-                  _mod module);\n \n-tag meta_visibility {\n-    export_meta;\n-    local_meta;\n-}\n+type crate_ = rec(vec[@crate_directive] directives, _mod module);\n+\n+tag meta_visibility { export_meta; local_meta; }\n \n tag crate_directive_ {\n     cdir_expr(@expr);\n+\n     // FIXME: cdir_let should be eliminated\n     // and redirected to the use of const stmt_decls inside\n     // crate directive blocks.\n@@ -93,45 +94,33 @@ tag crate_directive_ {\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n }\n-type crate_directive = spanned[crate_directive_];\n \n+type crate_directive = spanned[crate_directive_];\n \n type meta_item = spanned[meta_item_];\n+\n type meta_item_ = rec(ident key, str value);\n \n type block = spanned[block_];\n-type block_ = rec(vec[@stmt] stmts,\n-                  option::t[@expr] expr,\n-                  ann a);\n+\n+type block_ = rec(vec[@stmt] stmts, option::t[@expr] expr, ann a);\n \n type pat = spanned[pat_];\n+\n tag pat_ {\n     pat_wild(ann);\n     pat_bind(ident, def_id, ann);\n     pat_lit(@lit, ann);\n     pat_tag(path, vec[@pat], ann);\n }\n \n-tag mutability {\n-    mut;\n-    imm;\n-    maybe_mut;\n-}\n+tag mutability { mut; imm; maybe_mut; }\n \n-tag layer {\n-    layer_value;\n-    layer_state;\n-    layer_gc;\n-}\n+tag layer { layer_value; layer_state; layer_gc; }\n \n-tag _auth {\n-    auth_unsafe;\n-}\n+tag _auth { auth_unsafe; }\n \n-tag proto {\n-    proto_iter;\n-    proto_fn;\n-}\n+tag proto { proto_iter; proto_fn; }\n \n tag binop {\n     add;\n@@ -157,102 +146,85 @@ tag binop {\n \n fn binop_to_str(binop op) -> str {\n     alt (op) {\n-        case (add) {ret \"+\";}\n-        case (sub) {ret \"-\";}\n-        case (mul) {ret \"*\";}\n-        case (div) {ret \"/\";}\n-        case (rem) {ret \"%\";}\n-        case (and) {ret \"&&\";}\n-        case (or) {ret \"||\";}\n-        case (bitxor) {ret \"^\";}\n-        case (bitand) {ret \"&\";}\n-        case (bitor) {ret \"|\";}\n-        case (lsl) {ret \"<<\";}\n-        case (lsr) {ret \">>\";}\n-        case (asr) {ret \">>>\";}\n-        case (eq) {ret \"==\";}\n-        case (lt) {ret \"<\";}\n-        case (le) {ret \"<=\";}\n-        case (ne) {ret \"!=\";}\n-        case (ge) {ret \">=\";}\n-        case (gt) {ret \">\";}\n+        case (add) { ret \"+\"; }\n+        case (sub) { ret \"-\"; }\n+        case (mul) { ret \"*\"; }\n+        case (div) { ret \"/\"; }\n+        case (rem) { ret \"%\"; }\n+        case (and) { ret \"&&\"; }\n+        case (or) { ret \"||\"; }\n+        case (bitxor) { ret \"^\"; }\n+        case (bitand) { ret \"&\"; }\n+        case (bitor) { ret \"|\"; }\n+        case (lsl) { ret \"<<\"; }\n+        case (lsr) { ret \">>\"; }\n+        case (asr) { ret \">>>\"; }\n+        case (eq) { ret \"==\"; }\n+        case (lt) { ret \"<\"; }\n+        case (le) { ret \"<=\"; }\n+        case (ne) { ret \"!=\"; }\n+        case (ge) { ret \">=\"; }\n+        case (gt) { ret \">\"; }\n     }\n }\n \n-\n-tag unop {\n-    box(mutability);\n-    deref;\n-    not;\n-    neg;\n-}\n+tag unop { box(mutability); deref; not; neg; }\n \n fn unop_to_str(unop op) -> str {\n     alt (op) {\n-        case (box(?mt)) {\n-            if (mt == mut) { ret \"@mutable \"; }\n-            ret \"@\";\n-        }\n-        case (deref) {ret \"*\";}\n-        case (not) {ret \"!\";}\n-        case (neg) {ret \"-\";}\n+        case (box(?mt)) { if (mt == mut) { ret \"@mutable \"; } ret \"@\"; }\n+        case (deref) { ret \"*\"; }\n+        case (not) { ret \"!\"; }\n+        case (neg) { ret \"-\"; }\n     }\n }\n \n-tag mode {\n-    val;\n-    alias(bool);\n-}\n+tag mode { val; alias(bool); }\n \n type stmt = spanned[stmt_];\n+\n tag stmt_ {\n-    stmt_decl(@decl, ann); \n+    stmt_decl(@decl, ann);\n     stmt_expr(@expr, ann);\n+\n     // These only exist in crate-level blocks.\n     stmt_crate_directive(@crate_directive);\n }\n \n-tag init_op {\n-    init_assign;\n-    init_recv;\n-    init_move;\n-}\n+tag init_op { init_assign; init_recv; init_move; }\n+\n+type initializer = rec(init_op op, @expr expr);\n \n-type initializer = rec(init_op op,\n-                       @expr expr);\n+type local_ =\n+    rec(option::t[@ty] ty,\n+        bool infer,\n+        ident ident,\n+        option::t[initializer] init,\n+        def_id id,\n+        ann ann);\n \n-type local_ = rec(option::t[@ty] ty,\n-                 bool infer,\n-                 ident ident,\n-                 option::t[initializer] init,\n-                 def_id id,\n-                 ann ann);\n type local = spanned[@local_];\n \n type decl = spanned[decl_];\n-tag decl_ {\n-    decl_local(@local_);\n-    decl_item(@item);\n-}\n+\n+tag decl_ { decl_local(@local_); decl_item(@item); }\n \n type arm = rec(@pat pat, block block);\n \n type elt = rec(mutability mut, @expr expr);\n+\n type field_ = rec(mutability mut, ident ident, @expr expr);\n+\n type field = spanned[field_];\n \n-tag spawn_dom {\n-    dom_implicit;\n-    dom_thread;\n-}\n+tag spawn_dom { dom_implicit; dom_thread; }\n+\n \n // FIXME: temporary\n-tag seq_kind {\n-    sk_unique;\n-    sk_rc;\n-}\n+tag seq_kind { sk_unique; sk_rc; }\n \n type expr = spanned[expr_];\n+\n tag expr_ {\n     expr_vec(vec[@expr], mutability, seq_kind, ann);\n     expr_tup(vec[elt], ann);\n@@ -273,11 +245,11 @@ tag expr_ {\n     expr_alt(@expr, vec[arm], ann);\n     expr_fn(_fn, ann);\n     expr_block(block, ann);\n-    expr_move(@expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_assign_op(binop, @expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_send(@expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_recv(@expr /* TODO: @expr|is_lval */, @expr, ann);\n+    expr_move(@expr, /* TODO: @expr|is_lval */@expr, ann);\n+    expr_assign(@expr, /* TODO: @expr|is_lval */@expr, ann);\n+    expr_assign_op(binop, @expr, /* TODO: @expr|is_lval */@expr, ann);\n+    expr_send(@expr, /* TODO: @expr|is_lval */@expr, ann);\n+    expr_recv(@expr, /* TODO: @expr|is_lval */@expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n     expr_path(path, ann);\n@@ -289,16 +261,19 @@ tag expr_ {\n     expr_put(option::t[@expr], ann);\n     expr_be(@expr, ann);\n     expr_log(int, @expr, ann);\n-/* just an assert, no significance to typestate */\n+\n+    /* just an assert, no significance to typestate */\n     expr_assert(@expr, ann);\n-/* preds that typestate is aware of */\n+\n+    /* preds that typestate is aware of */\n     expr_check(@expr, ann);\n     expr_port(ann);\n     expr_chan(@expr, ann);\n     expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids, ann);\n }\n \n type lit = spanned[lit_];\n+\n tag lit_ {\n     lit_str(str, seq_kind);\n     lit_char(char);\n@@ -311,39 +286,53 @@ tag lit_ {\n     lit_bool(bool);\n }\n \n+\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-\n type mt = rec(@ty ty, mutability mut);\n+\n type ty_field_ = rec(ident ident, mt mt);\n+\n type ty_arg_ = rec(mode mode, @ty ty);\n-type ty_method_ = rec(proto proto, ident ident,\n-                      vec[ty_arg] inputs, @ty output,\n-                      controlflow cf, vec[@constr] constrs);\n+\n+type ty_method_ =\n+    rec(proto proto,\n+        ident ident,\n+        vec[ty_arg] inputs,\n+        @ty output,\n+        controlflow cf,\n+        vec[@constr] constrs);\n+\n type ty_field = spanned[ty_field_];\n+\n type ty_arg = spanned[ty_arg_];\n+\n type ty_method = spanned[ty_method_];\n \n type ty = spanned[ty_];\n+\n tag ty_ {\n     ty_nil;\n     ty_bot; /* return type of ! functions and type of\n              ret/fail/break/cont. there is no syntax\n              for this type. */\n-    /* bot represents the value of functions that don't return a value\n-       locally to their context. in contrast, things like log that do\n-       return, but don't return a meaningful value, have result type nil. */\n-    ty_bool;\n+\n+     /* bot represents the value of functions that don't return a value\n+        locally to their context. in contrast, things like log that do\n+        return, but don't return a meaningful value, have result type nil. */\n+     ty_bool;\n     ty_int;\n     ty_uint;\n     ty_float;\n     ty_machine(util::common::ty_mach);\n     ty_char;\n     ty_str;\n-    ty_istr;        // interior string\n+    ty_istr; // interior string\n+\n     ty_box(mt);\n     ty_vec(mt);\n-    ty_ivec(mt);    // interior vector\n+    ty_ivec(mt); // interior vector\n+\n     ty_ptr(mt);\n     ty_task;\n     ty_port(@ty);\n@@ -357,6 +346,7 @@ tag ty_ {\n     ty_constr(@ty, vec[@constr]);\n }\n \n+\n /*\n A constraint arg that's a function argument is referred to by its position\n rather than name.  This is so we could have higher-order functions that have\n@@ -365,62 +355,69 @@ so that the typestate pass doesn't have to map a function name onto its decl.\n So, the constr_arg type is parameterized: it's instantiated with uint for\n declarations, and ident for uses.\n */\n-tag constr_arg_general_[T] {\n-    carg_base;\n-    carg_ident(T); \n-    carg_lit(@lit);\n-}\n+tag constr_arg_general_[T] { carg_base; carg_ident(T); carg_lit(@lit); }\n+\n type constr_arg = constr_arg_general[uint];\n+\n type constr_arg_use = constr_arg_general[ident];\n+\n type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n \n+\n // The ann field is there so that using the def_map in the type\n // context, we can get the def_id for the path.\n-type constr_general[T] = rec(path path,\n-                             vec[@constr_arg_general[T]] args,\n-                             ann ann);\n+type constr_general[T] =\n+    rec(path path, vec[@constr_arg_general[T]] args, ann ann);\n \n type constr = spanned[constr_general[uint]];\n+\n type constr_use = spanned[constr_general[ident]];\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n-type fn_decl = rec(vec[arg] inputs,\n-                   @ty output,\n-                   purity purity,\n-                   controlflow cf,\n-                   vec[@constr] constraints);\n+\n+type fn_decl =\n+    rec(vec[arg] inputs,\n+        @ty output,\n+        purity purity,\n+        controlflow cf,\n+        vec[@constr] constraints);\n+\n tag purity {\n-    pure_fn;   // declared with \"pred\"\n+    pure_fn; // declared with \"pred\"\n+\n     impure_fn; // declared with \"fn\"\n+\n }\n \n tag controlflow {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n-    return;  // everything else\n+\n+    return; // everything else\n+\n }\n \n-type _fn = rec(fn_decl decl,\n-               proto proto,\n-               block body);\n+type _fn = rec(fn_decl decl, proto proto, block body);\n \n type method_ = rec(ident ident, _fn meth, def_id id, ann ann);\n+\n type method = spanned[method_];\n \n type obj_field = rec(mutability mut, @ty ty, ident ident, def_id id, ann ann);\n-type _obj = rec(vec[obj_field] fields,\n-                vec[@method] methods,\n-                option::t[@method] dtor);\n \n-type anon_obj = rec(\n-    // New fields and methods, if they exist.\n-    option::t[vec[obj_field]] fields,\n-    vec[@method] methods,\n-    // with_obj: the original object being extended, if it exists.\n-    option::t[@expr] with_obj);\n+type _obj =\n+    rec(vec[obj_field] fields, vec[@method] methods, option::t[@method] dtor);\n+\n+type anon_obj =\n+    rec(\n+        // New fields and methods, if they exist.\n+        option::t[vec[obj_field]] fields,\n+        vec[@method] methods,\n \n-type _mod = rec(vec[@view_item] view_items,\n-                vec[@item] items);\n+        // with_obj: the original object being extended, if it exists.\n+        option::t[@expr] with_obj);\n+\n+type _mod = rec(vec[@view_item] view_items, vec[@item] items);\n \n tag native_abi {\n     native_abi_rust;\n@@ -429,16 +426,20 @@ tag native_abi {\n     native_abi_rust_intrinsic;\n }\n \n-type native_mod = rec(str native_name,\n-                      native_abi abi,\n-                      vec[@view_item] view_items,\n-                      vec[@native_item] items);\n+type native_mod =\n+    rec(str native_name,\n+        native_abi abi,\n+        vec[@view_item] view_items,\n+        vec[@native_item] items);\n \n type variant_arg = rec(@ty ty, def_id id);\n+\n type variant_ = rec(str name, vec[variant_arg] args, def_id id, ann ann);\n+\n type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n+\n tag view_item_ {\n     view_item_use(ident, vec[@meta_item], def_id, ann);\n     view_item_import(ident, vec[ident], def_id);\n@@ -452,18 +453,16 @@ type obj_def_ids = rec(def_id ty, def_id ctor);\n // Meta-data associated with an item\n type attribute = spanned[attribute_];\n \n+\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-tag attr_style {\n-    attr_outer;\n-    attr_inner;\n-}\n+tag attr_style { attr_outer; attr_inner; }\n \n-type attribute_ = rec(attr_style style,\n-                      meta_item value);\n+type attribute_ = rec(attr_style style, meta_item value);\n \n type item = spanned[item_];\n+\n tag item_ {\n     item_const(ident, @ty, @expr, vec[attribute], def_id, ann);\n     item_fn(ident, _fn, vec[ty_param], vec[attribute], def_id, ann);\n@@ -476,97 +475,79 @@ tag item_ {\n \n fn item_ident(@item it) -> ident {\n     ret alt (it.node) {\n-        case (item_const(?ident, _, _, _, _, _)) { ident }\n-        case (item_fn(?ident, _, _, _, _, _)) { ident }\n-        case (item_mod(?ident, _, _, _)) { ident }\n-        case (item_native_mod(?ident, _, _, _)) { ident }\n-        case (item_ty(?ident, _, _, _, _, _)) { ident }\n-        case (item_tag(?ident, _, _, _, _, _)) { ident }\n-        case (item_obj(?ident, _, _, _, _, _)) { ident }\n-    }\n+            case (item_const(?ident, _, _, _, _, _)) { ident }\n+            case (item_fn(?ident, _, _, _, _, _)) { ident }\n+            case (item_mod(?ident, _, _, _)) { ident }\n+            case (item_native_mod(?ident, _, _, _)) { ident }\n+            case (item_ty(?ident, _, _, _, _, _)) { ident }\n+            case (item_tag(?ident, _, _, _, _, _)) { ident }\n+            case (item_obj(?ident, _, _, _, _, _)) { ident }\n+        }\n }\n \n type native_item = spanned[native_item_];\n+\n tag native_item_ {\n     native_item_ty(ident, def_id);\n-    native_item_fn(ident, option::t[str],\n-                   fn_decl, vec[ty_param], def_id, ann);\n+    native_item_fn(ident,\n+                   option::t[str],\n+                   fn_decl,\n+                   vec[ty_param],\n+                   def_id,\n+                   ann);\n }\n \n fn is_exported(ident i, _mod m) -> bool {\n     auto nonlocal = true;\n     for (@ast::item it in m.items) {\n-        if (item_ident(it) == i) {\n-            nonlocal = false;\n-        }\n+        if (item_ident(it) == i) { nonlocal = false; }\n         alt (it.node) {\n             case (item_tag(_, ?variants, _, _, _, _)) {\n                 for (variant v in variants) {\n-                    if (v.node.name == i) {\n-                        nonlocal = false;\n-                    }\n+                    if (v.node.name == i) { nonlocal = false; }\n                 }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n-\n-\n     auto count = 0u;\n     for (@ast::view_item vi in m.view_items) {\n         alt (vi.node) {\n             case (ast::view_item_export(?id)) {\n                 if (str::eq(i, id)) {\n                     // even if it's nonlocal (since it's explicit)\n+\n                     ret true;\n                 }\n                 count += 1u;\n             }\n-            case (_) { /* fall through */ }\n+            case (_) {/* fall through */ }\n         }\n     }\n+\n     // If there are no declared exports then \n     // everything not imported is exported\n-    if (count == 0u && !nonlocal) {\n-        ret true;\n-    } else {\n-        ret false;\n-    }\n+    if (count == 0u && !nonlocal) { ret true; } else { ret false; }\n }\n \n fn is_call_expr(@expr e) -> bool {\n     alt (e.node) {\n-        case (expr_call(_, _, _)) {\n-            ret true;\n-        }\n-        case (_) {\n-            ret false;\n-        }\n+        case (expr_call(_, _, _)) { ret true; }\n+        case (_) { ret false; }\n     }\n }\n \n fn is_constraint_arg(@expr e) -> bool {\n     alt (e.node) {\n-        case (expr_lit(_,_)) {\n-            ret true;\n-        }\n-        case (expr_path(_, _)) {\n-            ret true;\n-        }\n-        case (_) {\n-            ret false;\n-        }\n+        case (expr_lit(_, _)) { ret true; }\n+        case (expr_path(_, _)) { ret true; }\n+        case (_) { ret false; }\n     }\n }\n \n-fn eq_ty(&@ty a, &@ty b) -> bool {\n-    ret std::box::ptr_eq(a,b);\n-}\n-\n-fn hash_ty(&@ty t) -> uint {\n-    ret t.span.lo << 16u + t.span.hi;\n-}\n+fn eq_ty(&@ty a, &@ty b) -> bool { ret std::box::ptr_eq(a, b); }\n \n+fn hash_ty(&@ty t) -> uint { ret t.span.lo << 16u + t.span.hi; }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "3e1aa3c59400b62f6e0b6e0d6832424ec1b04464", "filename": "src/comp/front/codemap.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcodemap.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,15 +1,16 @@\n+\n import std::vec;\n \n+\n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n  * with single-word things, rather than passing records all over the\n  * compiler.\n  */\n+type filemap = @rec(str name, uint start_pos, mutable vec[uint] lines);\n \n-type filemap = @rec(str name,\n-                    uint start_pos,\n-                    mutable vec[uint] lines);\n type codemap = @rec(mutable vec[filemap] files);\n+\n type loc = rec(str filename, uint line, uint col);\n \n fn new_codemap() -> codemap {\n@@ -18,34 +19,27 @@ fn new_codemap() -> codemap {\n }\n \n fn new_filemap(str filename, uint start_pos) -> filemap {\n-    ret @rec(name=filename,\n-             start_pos=start_pos,\n-             mutable lines=[0u]);\n+    ret @rec(name=filename, start_pos=start_pos, mutable lines=[0u]);\n }\n \n-fn next_line(filemap file, uint pos) {\n-    vec::push[uint](file.lines, pos);\n-}\n+fn next_line(filemap file, uint pos) { vec::push[uint](file.lines, pos); }\n \n fn lookup_pos(codemap map, uint pos) -> loc {\n-    auto a = 0u; auto b = vec::len[filemap](map.files);\n+    auto a = 0u;\n+    auto b = vec::len[filemap](map.files);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n-        if (map.files.(m).start_pos > pos) { b = m; }\n-        else { a = m; }\n+        if (map.files.(m).start_pos > pos) { b = m; } else { a = m; }\n     }\n     auto f = map.files.(a);\n-    a = 0u; b = vec::len[uint](f.lines);\n+    a = 0u;\n+    b = vec::len[uint](f.lines);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n-        if (f.lines.(m) > pos) { b = m; }\n-        else { a = m; }\n+        if (f.lines.(m) > pos) { b = m; } else { a = m; }\n     }\n-    ret rec(filename=f.name,\n-            line=a + 1u,\n-            col=pos - f.lines.(a));\n+    ret rec(filename=f.name, line=a + 1u, col=pos - f.lines.(a));\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0270717edd943f9d17b33d1396260add6cc68a5e", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 155, "deletions": 196, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,5 +1,6 @@\n-// -*- rust -*-\n \n+\n+// -*- rust -*-\n import driver::session;\n import front::ast;\n import lib::llvm::False;\n@@ -18,7 +19,6 @@ import util::common::respan;\n import util::common::a_bang;\n import util::common::a_ty;\n import util::common::may_begin_ident;\n-\n import std::str;\n import std::uint;\n import std::vec;\n@@ -40,16 +40,15 @@ import std::map::hashmap;\n // contain pipe characters.\n \n // Callback to translate defs to strs or back:\n-type str_def = fn(str) -> ast::def_id;\n+type str_def = fn(str) -> ast::def_id ;\n \n-type pstate = rec(vec[u8] data, int crate,\n-                  mutable uint pos, uint len, ty::ctxt tcx);\n+type pstate =\n+    rec(vec[u8] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n \n type ty_or_bang = util::common::ty_or_bang[ty::t];\n \n-fn peek(@pstate st) -> u8 {\n-    ret st.data.(st.pos);\n-}\n+fn peek(@pstate st) -> u8 { ret st.data.(st.pos); }\n+\n fn next(@pstate st) -> u8 {\n     auto ch = st.data.(st.pos);\n     st.pos = st.pos + 1u;\n@@ -64,38 +63,37 @@ fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n     ret res;\n }\n \n-fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len,\n-                 str_def sd, ty::ctxt tcx) -> ty::t {\n-    auto st = @rec(data=data, crate=crate_num,\n-                   mutable pos=pos, len=len, tcx=tcx);\n+fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n+                 ty::ctxt tcx) -> ty::t {\n+    auto st =\n+        @rec(data=data, crate=crate_num, mutable pos=pos, len=len, tcx=tcx);\n     auto result = parse_ty(st, sd);\n     ret result;\n }\n \n fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     alt (peek(st) as char) {\n         case ('!') { auto ignore = next(st); ret a_bang[ty::t]; }\n-        case (_)   { ret a_ty[ty::t](parse_ty(st, sd)); }\n+        case (_) { ret a_ty[ty::t](parse_ty(st, sd)); }\n     }\n }\n \n fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n     let vec[@ast::constr] res = [];\n     alt (peek(st) as char) {\n         case (':') {\n-            do {\n+            do  {\n                 auto ignore = next(st);\n                 vec::push(res, parse_constr(st, sd));\n             } while (peek(st) as char == ',')\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     ret res;\n }\n \n fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n-    st.tcx.sess.unimpl(\"Reading constraints \"\n-                   + \" isn't implemented\");\n+    st.tcx.sess.unimpl(\"Reading constraints \" + \" isn't implemented\");\n     /*\n     let vec[@ast::constr_arg] args = [];\n     auto sp = rec(lo=0u,hi=0u); // FIXME\n@@ -137,6 +135,7 @@ fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n     } while (next(st) as char == ',');\n     ignore = next(st) as char;\n     */\n+\n }\n \n fn parse_ty(@pstate st, str_def sd) -> ty::t {\n@@ -168,9 +167,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n             let vec[ty::t] params = [];\n-            while (peek(st) as char != ']') {\n-                params += [parse_ty(st, sd)];\n-            }\n+            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tag(st.tcx, def, params);\n         }\n@@ -185,9 +182,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('T') {\n             assert (next(st) as char == '[');\n             let vec[ty::mt] params = [];\n-            while (peek(st) as char != ']') {\n-                params += [parse_mt(st, sd)];\n-            }\n+            while (peek(st) as char != ']') { params += [parse_mt(st, sd)]; }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tup(st.tcx, params);\n         }\n@@ -207,13 +202,13 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0,\n-                          func._1, func._2, func._3);\n+            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1, func._2,\n+                          func._3);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0,\n-                          func._1, func._2, func._3);\n+            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1, func._2,\n+                          func._3);\n         }\n         case ('N') {\n             auto abi;\n@@ -224,28 +219,29 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 case ('l') { abi = ast::native_abi_llvm; }\n             }\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_native_fn(st.tcx,abi,func._0,func._1);\n+            ret ty::mk_native_fn(st.tcx, abi, func._0, func._1);\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n             let vec[ty::method] methods = [];\n             while (peek(st) as char != ']') {\n                 auto proto;\n                 alt (next(st) as char) {\n-                    case ('W') {proto = ast::proto_iter;}\n-                    case ('F') {proto = ast::proto_fn;}\n+                    case ('W') { proto = ast::proto_iter; }\n+                    case ('F') { proto = ast::proto_fn; }\n                 }\n                 auto name = \"\";\n                 while (peek(st) as char != '[') {\n                     name += str::unsafe_from_byte(next(st));\n                 }\n                 auto func = parse_ty_fn(st, sd);\n-                methods += [rec(proto=proto,\n-                                ident=name,\n-                                inputs=func._0,\n-                                output=func._1,\n-                                cf=func._2,\n-                                constrs=func._3)];\n+                methods +=\n+                    [rec(proto=proto,\n+                         ident=name,\n+                         inputs=func._0,\n+                         output=func._1,\n+                         cf=func._2,\n+                         constrs=func._3)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);\n@@ -258,12 +254,12 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             assert (next(st) as char == ':');\n             auto len = parse_hex(st);\n             assert (next(st) as char == '#');\n-            alt (st.tcx.rcache.find(tup(st.crate,pos,len))) {\n+            alt (st.tcx.rcache.find(tup(st.crate, pos, len))) {\n                 case (some(?tt)) { ret tt; }\n                 case (none) {\n                     auto ps = @rec(pos=pos, len=len with *st);\n                     auto tt = parse_ty(ps, sd);\n-                    st.tcx.rcache.insert(tup(st.crate,pos,len), tt);\n+                    st.tcx.rcache.insert(tup(st.crate, pos, len), tt);\n                     ret tt;\n                 }\n             }\n@@ -279,9 +275,9 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n fn parse_mt(@pstate st, str_def sd) -> ty::mt {\n     auto mut;\n     alt (peek(st) as char) {\n-        case ('m') {next(st); mut = ast::mut;}\n-        case ('?') {next(st); mut = ast::maybe_mut;}\n-        case (_)   {mut=ast::imm;}\n+        case ('m') { next(st); mut = ast::mut; }\n+        case ('?') { next(st); mut = ast::maybe_mut; }\n+        case (_) { mut = ast::imm; }\n     }\n     ret rec(ty=parse_ty(st, sd), mut=mut);\n }\n@@ -299,7 +295,7 @@ fn parse_int(@pstate st) -> int {\n     auto n = 0;\n     while (true) {\n         auto cur = peek(st) as char;\n-        if (cur < '0' || cur > '9') {break;}\n+        if (cur < '0' || cur > '9') { break; }\n         st.pos = st.pos + 1u;\n         n *= 10;\n         n += (cur as int) - ('0' as int);\n@@ -311,22 +307,18 @@ fn parse_hex(@pstate st) -> uint {\n     auto n = 0u;\n     while (true) {\n         auto cur = peek(st) as char;\n-        if ((cur < '0' || cur > '9') &&\n-            (cur < 'a' || cur > 'f')) {break;}\n+        if ((cur < '0' || cur > '9') && (cur < 'a' || cur > 'f')) { break; }\n         st.pos = st.pos + 1u;\n         n *= 16u;\n         if ('0' <= cur && cur <= '9') {\n             n += (cur as uint) - ('0' as uint);\n-        } else {\n-            n += (10u + (cur as uint) - ('a' as uint));\n-        }\n+        } else { n += 10u + (cur as uint) - ('a' as uint); }\n     }\n     ret n;\n }\n \n-fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n-                                              ast::controlflow,\n-                                              vec[@ast::constr]) {\n+fn parse_ty_fn(@pstate st, str_def sd) ->\n+   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ast::constr]) {\n     assert (next(st) as char == '[');\n     let vec[ty::arg] inputs = [];\n     while (peek(st) as char != ']') {\n@@ -342,60 +334,56 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n         inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n     }\n     st.pos = st.pos + 1u;\n-    auto cs  = parse_constrs(st, sd);\n+    auto cs = parse_constrs(st, sd);\n     auto res = parse_ty_or_bang(st, sd);\n     alt (res) {\n         case (a_bang) {\n             ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn, cs);\n         }\n-        case (a_ty(?t)) {\n-            ret tup(inputs, t, ast::return, cs);\n-        }\n+        case (a_ty(?t)) { ret tup(inputs, t, ast::return, cs); }\n     }\n-    \n }\n \n \n // Rust metadata parsing\n-\n fn parse_def_id(vec[u8] buf) -> ast::def_id {\n     auto colon_idx = 0u;\n     auto len = vec::len[u8](buf);\n-    while (colon_idx < len && buf.(colon_idx) != (':' as u8)) {\n+    while (colon_idx < len && buf.(colon_idx) != ':' as u8) {\n         colon_idx += 1u;\n     }\n     if (colon_idx == len) {\n         log_err \"didn't find ':' when parsing def id\";\n         fail;\n     }\n-\n     auto crate_part = vec::slice[u8](buf, 0u, colon_idx);\n     auto def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n     auto crate_num = uint::parse_buf(crate_part, 10u) as int;\n     auto def_num = uint::parse_buf(def_part, 10u) as int;\n     ret tup(crate_num, def_num);\n }\n \n-fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n-    -> vec[ebml::doc] {\n+fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n+   vec[ebml::doc] {\n     auto index = ebml::get_doc(d, metadata::tag_index);\n     auto table = ebml::get_doc(index, metadata::tag_index_table);\n-\n-    auto hash_pos = table.start + (hash % 256u) * 4u;\n+    auto hash_pos = table.start + hash % 256u * 4u;\n     auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n     auto bucket = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n+\n     let vec[ebml::doc] result = [];\n     auto belt = metadata::tag_index_buckets_bucket_elt;\n     for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n         auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if (eq_fn(vec::slice[u8](elt.data, elt.start+4u, elt.end))) {\n+        if (eq_fn(vec::slice[u8](elt.data, elt.start + 4u, elt.end))) {\n             vec::push(result, ebml::doc_at(d.data, pos));\n         }\n     }\n     ret result;\n }\n \n+\n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n@@ -422,15 +410,14 @@ fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n     auto found = lookup_hash(items, eqer, metadata::hash_def_num(item_id));\n     if (vec::len(found) == 0u) {\n         ret option::none[ebml::doc];\n-    } else {\n-        ret option::some[ebml::doc](found.(0));\n-    }\n+    } else { ret option::some[ebml::doc](found.(0)); }\n }\n \n fn find_item(int item_id, &ebml::doc items) -> ebml::doc {\n     ret option::get(maybe_find_item(item_id, items));\n }\n \n+\n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n fn lookup_item(int item_id, vec[u8] data) -> ebml::doc {\n@@ -459,11 +446,11 @@ fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n         // that, in turn, links against another crate. We need a mapping\n         // from crate ID to crate \"meta\" attributes as part of the crate\n         // metadata:\n+\n         auto buf = str::bytes(s);\n         auto external_def_id = parse_def_id(buf);\n         ret tup(this_cnum, external_def_id._1);\n     }\n-\n     auto tp = ebml::get_doc(item, metadata::tag_items_data_item_type);\n     auto s = str::unsafe_from_bytes(ebml::doc_data(tp));\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n@@ -490,9 +477,10 @@ fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n }\n \n fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n-    auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile\n-        (str::buf(filename));\n-    if (mb as int == 0) {ret option::none[vec[u8]];}\n+    auto b = str::buf(filename);\n+    auto mb =\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n+    if (mb as int == 0) { ret option::none[vec[u8]]; }\n     auto of = mk_object_file(mb);\n     auto si = mk_section_iter(of.llof);\n     while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n@@ -509,91 +497,75 @@ fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n     ret option::none[vec[u8]];\n }\n \n-fn get_exported_metadata(&session::session sess,\n-                         &str path,\n-                         &vec[u8] data) -> hashmap[str,str] {\n-    auto meta_items = ebml::get_doc(ebml::new_doc(data),\n-                                    metadata::tag_meta_export);\n+fn get_exported_metadata(&session::session sess, &str path, &vec[u8] data) ->\n+   hashmap[str, str] {\n+    auto meta_items =\n+        ebml::get_doc(ebml::new_doc(data), metadata::tag_meta_export);\n     auto mm = common::new_str_hash[str]();\n-\n-    for each (ebml::doc m in ebml::tagged_docs(meta_items,\n-                                               metadata::tag_meta_item)) {\n-\n+    for each (ebml::doc m in\n+             ebml::tagged_docs(meta_items, metadata::tag_meta_item)) {\n         auto kd = ebml::get_doc(m, metadata::tag_meta_item_key);\n         auto vd = ebml::get_doc(m, metadata::tag_meta_item_value);\n-\n         auto k = str::unsafe_from_bytes(ebml::doc_data(kd));\n         auto v = str::unsafe_from_bytes(ebml::doc_data(vd));\n-\n         log #fmt(\"metadata in %s: %s = %s\", path, k, v);\n-\n-        if (!mm.insert(k,v)) {\n+        if (!mm.insert(k, v)) {\n             sess.warn(#fmt(\"Duplicate metadata item in %s: %s\", path, k));\n         }\n     }\n     ret mm;\n }\n \n-fn metadata_matches(hashmap[str,str] mm,\n-                    &vec[@ast::meta_item] metas) -> bool {\n+fn metadata_matches(hashmap[str, str] mm, &vec[@ast::meta_item] metas) ->\n+   bool {\n     log #fmt(\"matching %u metadata requirements against %u metadata items\",\n              vec::len(metas), mm.size());\n     for (@ast::meta_item mi in metas) {\n         alt (mm.find(mi.node.key)) {\n             case (some(?v)) {\n                 if (v == mi.node.value) {\n-                    log #fmt(\"matched '%s': '%s'\",\n-                             mi.node.key, mi.node.value);\n+                    log #fmt(\"matched '%s': '%s'\", mi.node.key,\n+                             mi.node.value);\n                 } else {\n-                    log #fmt(\"missing '%s': '%s' (got '%s')\",\n-                             mi.node.key, mi.node.value, v);\n+                    log #fmt(\"missing '%s': '%s' (got '%s')\", mi.node.key,\n+                             mi.node.value, v);\n                     ret false;\n                 }\n             }\n             case (none) {\n-                    log #fmt(\"missing '%s': '%s'\",\n-                             mi.node.key, mi.node.value);\n-                    ret false;\n+                log #fmt(\"missing '%s': '%s'\", mi.node.key, mi.node.value);\n+                ret false;\n             }\n         }\n     }\n     ret true;\n }\n \n-fn find_library_crate(&session::session sess,\n-                      &ast::ident ident,\n+fn find_library_crate(&session::session sess, &ast::ident ident,\n                       &vec[@ast::meta_item] metas,\n-                      &vec[str] library_search_paths)\n-    -> option::t[tup(str, vec[u8])] {\n-\n+                      &vec[str] library_search_paths) ->\n+   option::t[tup(str, vec[u8])] {\n     let str crate_name = ident;\n     for (@ast::meta_item mi in metas) {\n-        if (mi.node.key == \"name\") {\n-            crate_name = mi.node.value;\n-            break;\n-        }\n+        if (mi.node.key == \"name\") { crate_name = mi.node.value; break; }\n     }\n     auto nn = parser::default_native_lib_naming(sess);\n     let str prefix = nn.prefix + crate_name;\n-\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n     // tricks. Currently the glob(3) interface is a bit more than we can\n     // stomach from here, and writing a C++ wrapper is more work than just\n     // manually filtering fs::list_dir here.\n \n     for (str library_search_path in library_search_paths) {\n-\n         for (str path in fs::list_dir(library_search_path)) {\n-\n             let str f = fs::basename(path);\n-            if (! (str::starts_with(f, prefix) &&\n-                   str::ends_with(f, nn.suffix))) {\n-                log #fmt(\"skipping %s, doesn't look like %s*%s\",\n-                         path, prefix, nn.suffix);\n+            if (!(str::starts_with(f, prefix) &&\n+                      str::ends_with(f, nn.suffix))) {\n+                log #fmt(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n+                         nn.suffix);\n                 cont;\n             }\n-\n             alt (get_metadata_section(path)) {\n                 case (option::some(?cvec)) {\n                     auto mm = get_exported_metadata(sess, path, cvec);\n@@ -604,37 +576,33 @@ fn find_library_crate(&session::session sess,\n                     log #fmt(\"found %s with matching metadata\", path);\n                     ret some(tup(path, cvec));\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n         }\n     }\n     ret none;\n }\n \n-fn load_library_crate(&session::session sess,\n-                      &int cnum,\n-                      &ast::ident ident,\n+fn load_library_crate(&session::session sess, &int cnum, &ast::ident ident,\n                       &vec[@ast::meta_item] metas,\n                       &vec[str] library_search_paths) {\n     alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n         case (some(?t)) {\n-            sess.set_external_crate(cnum, rec(name=ident,\n-                                              data=t._1));\n+            sess.set_external_crate(cnum, rec(name=ident, data=t._1));\n             ret;\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     log_err #fmt(\"can't find crate for '%s'\", ident);\n     fail;\n }\n \n-type env = @rec(\n-    session::session sess,\n-    resolve::crate_map crate_map,\n-    @hashmap[str, int] crate_cache,\n-    vec[str] library_search_paths,\n-    mutable int next_crate_num\n-);\n+type env =\n+    @rec(session::session sess,\n+         resolve::crate_map crate_map,\n+         @hashmap[str, int] crate_cache,\n+         vec[str] library_search_paths,\n+         mutable int next_crate_num);\n \n fn visit_view_item(env e, &@ast::view_item i) {\n     alt (i.node) {\n@@ -646,9 +614,7 @@ fn visit_view_item(env e, &@ast::view_item i) {\n                                    e.library_search_paths);\n                 e.crate_cache.insert(ident, e.next_crate_num);\n                 e.next_crate_num += 1;\n-            } else {\n-                cnum = e.crate_cache.get(ident);\n-            }\n+            } else { cnum = e.crate_cache.get(ident); }\n             e.crate_map.insert(ann.id, cnum);\n         }\n         case (_) { }\n@@ -657,66 +623,70 @@ fn visit_view_item(env e, &@ast::view_item i) {\n \n \n // Reads external crates referenced by \"use\" directives.\n-fn read_crates(session::session sess,\n-               resolve::crate_map crate_map,\n+fn read_crates(session::session sess, resolve::crate_map crate_map,\n                &ast::crate crate) {\n-    auto e = @rec(\n-        sess=sess,\n-        crate_map=crate_map,\n-        crate_cache=@common::new_str_hash[int](),\n-        library_search_paths=sess.get_opts().library_search_paths,\n-        mutable next_crate_num=1\n-    );\n-\n-    auto v = rec(visit_view_item_pre=bind visit_view_item(e, _)\n-                 with walk::default_visitor());\n+    auto e =\n+        @rec(sess=sess,\n+             crate_map=crate_map,\n+             crate_cache=@common::new_str_hash[int](),\n+             library_search_paths=sess.get_opts().library_search_paths,\n+             mutable next_crate_num=1);\n+    auto v =\n+        rec(visit_view_item_pre=bind visit_view_item(e, _)\n+            with walk::default_visitor());\n     walk::walk_crate(v, crate);\n }\n \n-\n fn kind_has_type_params(u8 kind_ch) -> bool {\n     ret alt (kind_ch as char) {\n-        case ('c') { false } case ('f') { true  } case ('F') { true  }\n-        case ('y') { true  } case ('o') { true  } case ('t') { true  }\n-        case ('T') { false } case ('m') { false } case ('n') { false }\n-        case ('v') { true  }\n-    };\n+            case ('c') { false }\n+            case ('f') { true }\n+            case ('F') { true }\n+            case ('y') { true }\n+            case ('o') { true }\n+            case ('t') { true }\n+            case ('T') { false }\n+            case ('m') { false }\n+            case ('n') { false }\n+            case ('v') { true }\n+        };\n }\n \n-// Crate metadata queries\n \n-fn lookup_defs(session::session sess, int cnum, vec[ast::ident] path)\n-    -> vec[ast::def] {\n+// Crate metadata queries\n+fn lookup_defs(session::session sess, int cnum, vec[ast::ident] path) ->\n+   vec[ast::def] {\n     auto data = sess.get_external_crate(cnum).data;\n-\n-    ret vec::map(bind lookup_def(cnum, data, _),\n-                 resolve_path(path, data));\n+    ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n+\n // FIXME doesn't yet handle re-exported externals\n fn lookup_def(int cnum, vec[u8] data, &ast::def_id did_) -> ast::def {\n     auto item = lookup_item(did_._1, data);\n     auto kind_ch = item_kind(item);\n-\n     auto did = tup(cnum, did_._1);\n-\n-    auto def = alt (kind_ch as char) {\n-        case ('c') { ast::def_const(did) }\n-        case ('f') { ast::def_fn(did) }\n-        case ('F') { ast::def_native_fn(did) }\n-        case ('y') { ast::def_ty(did) }\n-        case ('o') { ast::def_obj(did) }\n-        case ('T') { ast::def_native_ty(did) }\n-        // We treat references to tags as references to types.\n-        case ('t') { ast::def_ty(did) }\n-        case ('m') { ast::def_mod(did) }\n-        case ('n') { ast::def_native_mod(did) }\n-        case ('v') {\n-            auto tid = variant_tag_id(item);\n-            tid = tup(cnum, tid._1);\n-            ast::def_variant(tid, did)\n-        }\n-    };\n+    auto def =\n+        alt (kind_ch as char) {\n+            case ('c') { ast::def_const(did) }\n+            case ('f') { ast::def_fn(did) }\n+            case ('F') { ast::def_native_fn(did) }\n+            case ('y') { ast::def_ty(did) }\n+            case ('o') { ast::def_obj(did) }\n+            case ('T') { ast::def_native_ty(did) }\n+            case (\n+                 // We treat references to tags as references to types.\n+                 't') {\n+                ast::def_ty(did)\n+            }\n+            case ('m') { ast::def_mod(did) }\n+            case ('n') { ast::def_native_mod(did) }\n+            case ('v') {\n+                auto tid = variant_tag_id(item);\n+                tid = tup(cnum, tid._1);\n+                ast::def_variant(tid, did)\n+            }\n+        };\n     ret def;\n }\n \n@@ -725,16 +695,12 @@ fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n     auto data = tcx.sess.get_external_crate(external_crate_id).data;\n     auto item = lookup_item(def._1, data);\n     auto t = item_type(item, external_crate_id, tcx);\n-\n     auto tp_count;\n     auto kind_ch = item_kind(item);\n     auto has_ty_params = kind_has_type_params(kind_ch);\n     if (has_ty_params) {\n         tp_count = item_ty_param_count(item, external_crate_id);\n-    } else {\n-        tp_count = 0u;\n-    }\n-\n+    } else { tp_count = 0u; }\n     ret tup(tp_count, t);\n }\n \n@@ -744,13 +710,11 @@ fn get_symbol(session::session sess, ast::def_id def) -> str {\n     ret item_symbol(lookup_item(def._1, data));\n }\n \n-fn get_tag_variants(ty::ctxt tcx, ast::def_id def)\n-    -> vec[ty::variant_info] {\n+fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> vec[ty::variant_info] {\n     auto external_crate_id = def._0;\n     auto data = tcx.sess.get_external_crate(external_crate_id).data;\n     auto items = ebml::get_doc(ebml::new_doc(data), metadata::tag_items);\n     auto item = find_item(def._1, items);\n-\n     let vec[ty::variant_info] infos = [];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n@@ -759,25 +723,21 @@ fn get_tag_variants(ty::ctxt tcx, ast::def_id def)\n         let vec[ty::t] arg_tys = [];\n         alt (ty::struct(tcx, ctor_ty)) {\n             case (ty::ty_fn(_, ?args, _, _, _)) {\n-                for (ty::arg a in args) {\n-                    arg_tys += [a.ty];\n-                }\n+                for (ty::arg a in args) { arg_tys += [a.ty]; }\n             }\n             case (_) {\n                 // Nullary tag variant.\n+\n             }\n         }\n         infos += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n     }\n-\n     ret infos;\n }\n \n fn list_file_metadata(str path, io::writer out) {\n     alt (get_metadata_section(path)) {\n-        case (option::some(?bytes)) {\n-            list_crate_metadata(bytes, out);\n-        }\n+        case (option::some(?bytes)) { list_crate_metadata(bytes, out); }\n         case (option::none) {\n             out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n         }\n@@ -799,7 +759,7 @@ fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n     auto index = ebml::get_doc(paths, metadata::tag_index);\n     auto bs = ebml::get_doc(index, metadata::tag_index_buckets);\n     for each (ebml::doc bucket in\n-              ebml::tagged_docs(bs, metadata::tag_index_buckets_bucket)) {\n+             ebml::tagged_docs(bs, metadata::tag_index_buckets_bucket)) {\n         auto et = metadata::tag_index_buckets_bucket_elt;\n         for each (ebml::doc elt in ebml::tagged_docs(bucket, et)) {\n             auto data = read_path(elt);\n@@ -819,19 +779,18 @@ fn describe_def(&ebml::doc items, ast::def_id id) -> str {\n \n fn item_kind_to_str(u8 kind) -> str {\n     alt (kind as char) {\n-        case ('c') {ret \"const\";}\n-        case ('f') {ret \"fn\";}\n-        case ('F') {ret \"native fn\";}\n-        case ('y') {ret \"type\";}\n-        case ('o') {ret \"obj\";}\n-        case ('T') {ret \"native type\";}\n-        case ('t') {ret \"type\";}\n-        case ('m') {ret \"mod\";}\n-        case ('n') {ret \"native mod\";}\n-        case ('v') {ret \"tag\";}\n+        case ('c') { ret \"const\"; }\n+        case ('f') { ret \"fn\"; }\n+        case ('F') { ret \"native fn\"; }\n+        case ('y') { ret \"type\"; }\n+        case ('o') { ret \"obj\"; }\n+        case ('T') { ret \"native type\"; }\n+        case ('t') { ret \"type\"; }\n+        case ('m') { ret \"mod\"; }\n+        case ('n') { ret \"native mod\"; }\n+        case ('v') { ret \"tag\"; }\n     }\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "023fe9e4373b88ffa57c4fdf9a399f3b16e87787", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 69, "deletions": 171, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,10 +1,10 @@\n+\n import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n import std::map::hashmap;\n-\n import driver::session;\n import ast::ident;\n import front::parser::parser;\n@@ -18,76 +18,49 @@ import util::common::new_str_hash;\n \n \n // Simple dynamic-typed value type for eval_expr.\n-tag val {\n-    val_bool(bool);\n-    val_int(int);\n-    val_str(str);\n-}\n+tag val { val_bool(bool); val_int(int); val_str(str); }\n \n-tag eval_mode {\n-    mode_depend;\n-    mode_parse;\n-}\n+tag eval_mode { mode_depend; mode_parse; }\n \n type env = vec[tup(ident, val)];\n-type ctx = @rec(parser p,\n-                eval_mode mode,\n-                mutable vec[str] deps,\n-                session::session sess,\n-                mutable uint chpos,\n-                mutable uint next_ann);\n \n-fn mk_env() -> env {\n-    ret [];\n-}\n+type ctx =\n+    @rec(parser p,\n+         eval_mode mode,\n+         mutable vec[str] deps,\n+         session::session sess,\n+         mutable uint chpos,\n+         mutable uint next_ann);\n+\n+fn mk_env() -> env { ret []; }\n \n fn val_is_bool(val v) -> bool {\n-    alt (v) {\n-        case (val_bool(_)) { true }\n-        case (_) { false }\n-    }\n+    alt (v) { case (val_bool(_)) { true } case (_) { false } }\n }\n \n fn val_is_int(val v) -> bool {\n-    alt (v) {\n-        case (val_int(_)) { true }\n-        case (_) { false }\n-    }\n+    alt (v) { case (val_int(_)) { true } case (_) { false } }\n }\n \n fn val_is_str(val v) -> bool {\n-    alt (v) {\n-        case (val_str(_)) { true }\n-        case (_) { false }\n-    }\n+    alt (v) { case (val_str(_)) { true } case (_) { false } }\n }\n \n fn val_as_bool(val v) -> bool {\n-    alt (v) {\n-        case (val_bool(?b)) { b }\n-        case (_) { fail }\n-    }\n+    alt (v) { case (val_bool(?b)) { b } case (_) { fail } }\n }\n \n fn val_as_int(val v) -> int {\n-    alt (v) {\n-        case (val_int(?i)) { i }\n-        case (_) { fail }\n-    }\n+    alt (v) { case (val_int(?i)) { i } case (_) { fail } }\n }\n \n fn val_as_str(val v) -> str {\n-    alt (v) {\n-        case (val_str(?s)) { s }\n-        case (_) { fail }\n-    }\n+    alt (v) { case (val_str(?s)) { s } case (_) { fail } }\n }\n \n fn lookup(session::session sess, env e, span sp, ident i) -> val {\n     for (tup(ident, val) pair in e) {\n-        if (str::eq(i, pair._0)) {\n-            ret pair._1;\n-        }\n+        if (str::eq(i, pair._0)) { ret pair._1; }\n     }\n     sess.span_err(sp, \"unknown variable: \" + i)\n }\n@@ -96,42 +69,33 @@ fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n     alt (lit.node) {\n         case (ast::lit_bool(?b)) { val_bool(b) }\n         case (ast::lit_int(?i)) { val_int(i) }\n-        case (ast::lit_str(?s,_)) { val_str(s) }\n-        case (_) {\n-            cx.sess.span_err(sp, \"evaluating unsupported literal\")\n-        }\n+        case (ast::lit_str(?s, _)) { val_str(s) }\n+        case (_) { cx.sess.span_err(sp, \"evaluating unsupported literal\") }\n     }\n }\n \n fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n     alt (x.node) {\n         case (ast::expr_path(?pth, _)) {\n             if (vec::len[ident](pth.node.idents) == 1u &&\n-                vec::len[@ast::ty](pth.node.types) == 0u) {\n+                    vec::len[@ast::ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n             cx.sess.span_err(x.span, \"evaluating structured path-name\");\n         }\n-\n-        case (ast::expr_lit(?lit, _)) {\n-            ret eval_lit(cx, x.span, lit);\n-        }\n-\n+        case (ast::expr_lit(?lit, _)) { ret eval_lit(cx, x.span, lit); }\n         case (ast::expr_unary(?op, ?a, _)) {\n             auto av = eval_expr(cx, e, a);\n             alt (op) {\n                 case (ast::not) {\n-                    if (val_is_bool(av)) {\n-                        ret val_bool(!val_as_bool(av));\n-                    }\n+                    if (val_is_bool(av)) { ret val_bool(!val_as_bool(av)); }\n                     cx.sess.span_err(x.span, \"bad types in '!' expression\");\n                 }\n                 case (_) {\n                     cx.sess.span_err(x.span, \"evaluating unsupported unop\");\n                 }\n             }\n         }\n-\n         case (ast::expr_binary(?op, ?a, ?b, _)) {\n             auto av = eval_expr(cx, e, a);\n             auto bv = eval_expr(cx, e, b);\n@@ -145,57 +109,48 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '+' expression\");\n                 }\n-\n                 case (ast::sub) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) - val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '-' expression\");\n                 }\n-\n                 case (ast::mul) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) * val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '*' expression\");\n                 }\n-\n                 case (ast::div) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) / val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '/' expression\");\n                 }\n-\n                 case (ast::rem) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) % val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '%' expression\");\n                 }\n-\n                 case (ast::and) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) && val_as_bool(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '&&' expression\");\n                 }\n-\n                 case (ast::or) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) || val_as_bool(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '||' expression\");\n                 }\n-\n                 case (ast::eq) {\n                     ret val_bool(val_eq(cx.sess, x.span, av, bv));\n                 }\n-\n                 case (ast::ne) {\n-                    ret val_bool(! val_eq(cx.sess, x.span, av, bv));\n+                    ret val_bool(!val_eq(cx.sess, x.span, av, bv));\n                 }\n-\n                 case (_) {\n                     cx.sess.span_err(x.span, \"evaluating unsupported binop\");\n                 }\n@@ -214,52 +169,34 @@ fn val_eq(session::session sess, span sp, val av, val bv) -> bool {\n     } else if (val_is_int(av) && val_is_int(bv)) {\n         val_as_int(av) == val_as_int(bv)\n     } else if (val_is_str(av) && val_is_str(bv)) {\n-        str::eq(val_as_str(av),\n-                val_as_str(bv))\n-    } else {\n-        sess.span_err(sp, \"bad types in comparison\")\n-    }\n+        str::eq(val_as_str(av), val_as_str(bv))\n+    } else { sess.span_err(sp, \"bad types in comparison\") }\n }\n \n-fn eval_crate_directives(ctx cx,\n-                                env e,\n-                                vec[@ast::crate_directive] cdirs,\n-                                str prefix,\n-                                &mutable vec[@ast::view_item] view_items,\n-                                &mutable vec[@ast::item] items) {\n-\n+fn eval_crate_directives(ctx cx, env e, vec[@ast::crate_directive] cdirs,\n+                         str prefix, &mutable vec[@ast::view_item] view_items,\n+                         &mutable vec[@ast::item] items) {\n     for (@ast::crate_directive sub_cdir in cdirs) {\n-        eval_crate_directive(cx, e, sub_cdir, prefix,\n-                             view_items, items);\n+        eval_crate_directive(cx, e, sub_cdir, prefix, view_items, items);\n     }\n }\n \n-\n fn eval_crate_directives_to_mod(ctx cx, env e,\n-                                       vec[@ast::crate_directive] cdirs,\n-                                       str prefix) -> ast::_mod {\n+                                vec[@ast::crate_directive] cdirs, str prefix)\n+   -> ast::_mod {\n     let vec[@ast::view_item] view_items = [];\n     let vec[@ast::item] items = [];\n-\n-    eval_crate_directives(cx, e, cdirs, prefix,\n-                          view_items, items);\n-\n+    eval_crate_directives(cx, e, cdirs, prefix, view_items, items);\n     ret rec(view_items=view_items, items=items);\n }\n \n-\n-fn eval_crate_directive_block(ctx cx,\n-                                     env e,\n-                                     &ast::block blk,\n-                                     str prefix,\n-                                     &mutable vec[@ast::view_item] view_items,\n-                                     &mutable vec[@ast::item] items) {\n-\n+fn eval_crate_directive_block(ctx cx, env e, &ast::block blk, str prefix,\n+                              &mutable vec[@ast::view_item] view_items,\n+                              &mutable vec[@ast::item] items) {\n     for (@ast::stmt s in blk.node.stmts) {\n         alt (s.node) {\n             case (ast::stmt_crate_directive(?cdir)) {\n-                eval_crate_directive(cx, e, cdir, prefix,\n-                                     view_items, items);\n+                eval_crate_directive(cx, e, cdir, prefix, view_items, items);\n             }\n             case (_) {\n                 cx.sess.span_err(s.span,\n@@ -269,51 +206,46 @@ fn eval_crate_directive_block(ctx cx,\n     }\n }\n \n-fn eval_crate_directive_expr(ctx cx,\n-                                    env e,\n-                                    @ast::expr x,\n-                                    str prefix,\n-                                    &mutable vec[@ast::view_item] view_items,\n-                                    &mutable vec[@ast::item] items) {\n+fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n+                             &mutable vec[@ast::view_item] view_items,\n+                             &mutable vec[@ast::item] items) {\n     alt (x.node) {\n-\n         case (ast::expr_if(?cond, ?thn, ?elopt, _)) {\n             auto cv = eval_expr(cx, e, cond);\n             if (!val_is_bool(cv)) {\n                 cx.sess.span_err(x.span, \"bad cond type in 'if'\");\n             }\n-\n             if (val_as_bool(cv)) {\n-                ret eval_crate_directive_block(cx, e, thn, prefix,\n-                                               view_items, items);\n+                ret eval_crate_directive_block(cx, e, thn, prefix, view_items,\n+                                               items);\n             }\n-\n             alt (elopt) {\n                 case (some(?els)) {\n                     ret eval_crate_directive_expr(cx, e, els, prefix,\n                                                   view_items, items);\n                 }\n                 case (_) {\n                     // Absent-else is ok.\n+\n                 }\n             }\n         }\n-\n         case (ast::expr_alt(?v, ?arms, _)) {\n             auto vv = eval_expr(cx, e, v);\n             for (ast::arm arm in arms) {\n                 alt (arm.pat.node) {\n                     case (ast::pat_lit(?lit, _)) {\n                         auto pv = eval_lit(cx, arm.pat.span, lit);\n                         if (val_eq(cx.sess, arm.pat.span, vv, pv)) {\n-                            ret eval_crate_directive_block\n-                                (cx, e, arm.block, prefix, view_items, items);\n+                            ret eval_crate_directive_block(cx, e, arm.block,\n+                                                           prefix, view_items,\n+                                                           items);\n                         }\n                     }\n                     case (ast::pat_wild(_)) {\n-                        ret eval_crate_directive_block\n-                            (cx, e, arm.block, prefix,\n-                             view_items, items);\n+                        ret eval_crate_directive_block(cx, e, arm.block,\n+                                                       prefix, view_items,\n+                                                       items);\n                     }\n                     case (_) {\n                         cx.sess.span_err(arm.pat.span,\n@@ -323,102 +255,68 @@ fn eval_crate_directive_expr(ctx cx,\n             }\n             cx.sess.span_err(x.span, \"no cases matched in 'alt'\");\n         }\n-\n         case (ast::expr_block(?block, _)) {\n-            ret eval_crate_directive_block(cx, e, block, prefix,\n-                                           view_items, items);\n-        }\n-\n-        case (_) {\n-            cx.sess.span_err(x.span, \"unsupported expr type\");\n+            ret eval_crate_directive_block(cx, e, block, prefix, view_items,\n+                                           items);\n         }\n+        case (_) { cx.sess.span_err(x.span, \"unsupported expr type\"); }\n     }\n }\n \n-fn eval_crate_directive(ctx cx,\n-                               env e,\n-                               @ast::crate_directive cdir,\n-                               str prefix,\n-                               &mutable vec[@ast::view_item] view_items,\n-                               &mutable vec[@ast::item] items) {\n+fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n+                        &mutable vec[@ast::view_item] view_items,\n+                        &mutable vec[@ast::item] items) {\n     alt (cdir.node) {\n-\n         case (ast::cdir_let(?id, ?x, ?cdirs)) {\n             auto v = eval_expr(cx, e, x);\n             auto e0 = [tup(id, v)] + e;\n-            eval_crate_directives(cx, e0, cdirs, prefix,\n-                                  view_items, items);\n+            eval_crate_directives(cx, e0, cdirs, prefix, view_items, items);\n         }\n-\n         case (ast::cdir_expr(?x)) {\n-            eval_crate_directive_expr(cx, e, x, prefix,\n-                                      view_items, items);\n+            eval_crate_directive_expr(cx, e, x, prefix, view_items, items);\n         }\n-\n         case (ast::cdir_src_mod(?id, ?file_opt)) {\n-\n             auto file_path = id + \".rs\";\n             alt (file_opt) {\n-                case (some(?f)) {\n-                    file_path = f;\n-                }\n-                case (none) {}\n+                case (some(?f)) { file_path = f; }\n+                case (none) { }\n             }\n-\n             auto full_path = prefix + std::fs::path_sep() + file_path;\n-\n-            if (cx.mode == mode_depend) {\n-                cx.deps += [full_path];\n-                ret;\n-            }\n-\n+            if (cx.mode == mode_depend) { cx.deps += [full_path]; ret; }\n             auto start_id = cx.p.next_def_id();\n-            auto p0 = new_parser(cx.sess, e, start_id, full_path, cx.chpos,\n-                                 cx.next_ann);\n+            auto p0 =\n+                new_parser(cx.sess, e, start_id, full_path, cx.chpos,\n+                           cx.next_ann);\n             auto m0 = parse_mod_items(p0, token::EOF);\n             auto next_id = p0.next_def_id();\n             // Thread defids and chpos through the parsers\n+\n             cx.p.set_def(next_id._1);\n             cx.chpos = p0.get_chpos();\n             cx.next_ann = p0.next_ann_num();\n             auto im = ast::item_mod(id, m0, [], next_id);\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n             vec::push[@ast::item](items, i);\n         }\n-\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n-\n             auto path = id;\n-            alt (dir_opt) {\n-                case (some(?d)) {\n-                    path = d;\n-                }\n-                case (none) {}\n-            }\n-\n+            alt (dir_opt) { case (some(?d)) { path = d; } case (none) { } }\n             auto full_path = prefix + std::fs::path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n             auto im = ast::item_mod(id, m0, [], cx.p.next_def_id());\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n             vec::push[@ast::item](items, i);\n         }\n-\n         case (ast::cdir_view_item(?vi)) {\n             vec::push[@ast::view_item](view_items, vi);\n         }\n-\n         case (ast::cdir_meta(?vi, ?mi)) {\n-            if (vi == ast::export_meta) {\n-                cx.sess.add_metadata(mi);\n-            }\n+            if (vi == ast::export_meta) { cx.sess.add_metadata(mi); }\n         }\n-\n-        case (ast::cdir_syntax(?pth)) {}\n-        case (ast::cdir_auth(?pth, ?eff)) {}\n+        case (ast::cdir_syntax(?pth)) { }\n+        case (ast::cdir_auth(?pth, ?eff)) { }\n     }\n }\n-\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "cc8762aee8b4e76d943d2f4789c2b1b420e35cf3", "filename": "src/comp/front/ext.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fext.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,19 +1,18 @@\n+\n import std::option;\n import std::map::hashmap;\n-\n import driver::session::session;\n import front::parser::parser;\n import util::common::span;\n import util::common::new_str_hash;\n \n-type syntax_expander = fn(&ext_ctxt, span,\n-                          &vec[@ast::expr],\n-                          option::t[str]) -> @ast::expr;\n+type syntax_expander =\n+    fn(&ext_ctxt, span, &vec[@ast::expr], option::t[str]) -> @ast::expr ;\n+\n \n // Temporary: to introduce a tag in order to make a recursive type work\n-tag syntax_extension {\n-    x(syntax_expander);\n-}\n+tag syntax_extension { x(syntax_expander); }\n+\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n@@ -24,36 +23,32 @@ fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n     ret syntax_expanders;\n }\n \n-type span_msg_fn = fn (span sp, str msg) -> !;\n-type next_ann_fn = fn () -> ast::ann;\n+type span_msg_fn = fn(span, str) -> !  ;\n+\n+type next_ann_fn = fn() -> ast::ann ;\n+\n \n // Provides a limited set of services necessary for syntax extensions\n // to do their thing\n-type ext_ctxt = rec(span_msg_fn span_err,\n-                    span_msg_fn span_unimpl,\n-                    next_ann_fn next_ann);\n+type ext_ctxt =\n+    rec(span_msg_fn span_err, span_msg_fn span_unimpl, next_ann_fn next_ann);\n \n fn mk_ctxt(parser parser) -> ext_ctxt {\n     auto sess = parser.get_session();\n-\n     fn ext_span_err_(session sess, span sp, str msg) -> ! {\n         sess.span_err(sp, msg);\n     }\n     auto ext_span_err = bind ext_span_err_(sess, _, _);\n-\n     fn ext_span_unimpl_(session sess, span sp, str msg) -> ! {\n         sess.span_unimpl(sp, msg);\n     }\n     auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n-\n     fn ext_next_ann_(parser parser) -> ast::ann { parser.get_ann() }\n     auto ext_next_ann = bind ext_next_ann_(parser);\n-\n-    ret rec(span_err = ext_span_err,\n-            span_unimpl = ext_span_unimpl,\n-            next_ann = ext_next_ann);\n+    ret rec(span_err=ext_span_err,\n+            span_unimpl=ext_span_unimpl,\n+            next_ann=ext_next_ann);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "dca7b90f7abf166d7747d84934e96b8c5ddc685a", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,59 +1,48 @@\n+\n+\n /*\n  * The compiler code necessary to support the #env extension.  Eventually this\n  * should all get sucked into either the compiler syntax extension plugin\n  * interface.\n  */\n-\n import util::common;\n-\n import std::str;\n import std::vec;\n import std::option;\n import std::generic_os;\n-\n import ext::*;\n-\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(&ext_ctxt cx,\n-                     common::span sp,\n-                     &vec[@ast::expr] args,\n+fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n-\n     if (vec::len[@ast::expr](args) != 1u) {\n         cx.span_err(sp, \"malformed #env call\");\n     }\n-\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t[str] rather than just an maybe-empty string.\n \n     auto var = expr_to_str(cx, args.(0));\n     alt (generic_os::getenv(var)) {\n-        case (option::none) {\n-            ret make_new_str(cx, sp, \"\");\n-        }\n-        case (option::some(?s)) {\n-            ret make_new_str(cx, sp, s);\n-        }\n+        case (option::none) { ret make_new_str(cx, sp, \"\"); }\n+        case (option::some(?s)) { ret make_new_str(cx, sp, s); }\n     }\n }\n \n-// FIXME: duplicate code copied from extfmt:\n \n+// FIXME: duplicate code copied from extfmt:\n fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n     alt (expr.node) {\n         case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n-                case (ast::lit_str(?s,_)) { ret s; }\n+                case (ast::lit_str(?s, _)) { ret s; }\n                 case (_) { cx.span_err(l.span, \"malformed #env call\"); }\n             }\n         }\n         case (_) { cx.span_err(expr.span, \"malformed #env call\"); }\n     }\n }\n \n-fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit)\n-    -> @ast::expr {\n+fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n     auto expr = ast::expr_lit(sp_lit, cx.next_ann());\n     ret @rec(node=expr, span=sp);\n@@ -62,7 +51,6 @@ fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit)\n fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n     ret make_new_lit(cx, sp, ast::lit_str(s, ast::sk_rc));\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "557d84342b85825d454f07a71c4869fb9d30c887", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 99, "deletions": 230, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,42 +1,32 @@\n+\n+\n /*\n  * The compiler code necessary to support the #fmt extension.  Eventually this\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n-\n import util::common;\n-\n import std::str;\n import std::vec;\n import std::option;\n import std::option::none;\n import std::option::some;\n-\n import std::extfmt::ct::*;\n-\n import ext::*;\n-\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(&ext_ctxt cx,\n-                     common::span sp, \n-                     &vec[@ast::expr] args,\n+fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n-\n     if (vec::len[@ast::expr](args) == 0u) {\n         cx.span_err(sp, \"#fmt requires a format string\");\n     }\n-\n     auto fmt = expr_to_str(cx, args.(0));\n     auto fmtspan = args.(0).span;\n-\n     log \"Format string:\";\n     log fmt;\n-\n     fn parse_fmt_err_(&ext_ctxt cx, common::span sp, str msg) -> ! {\n         cx.span_err(sp, msg);\n     }\n-\n     auto parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n     auto pieces = parse_fmt_string(fmt, parse_fmt_err);\n     auto args_len = vec::len[@ast::expr](args);\n@@ -49,149 +39,124 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n     alt (expr.node) {\n         case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n-                case (ast::lit_str(?s,_)) { ret s; }\n+                case (ast::lit_str(?s, _)) { ret s; }\n                 case (_) { cx.span_err(l.span, err_msg); }\n             }\n         }\n-        case (_) {\n-            cx.span_err(expr.span, err_msg);\n-        }\n+        case (_) { cx.span_err(expr.span, err_msg); }\n     }\n }\n \n+\n // FIXME: A lot of these functions for producing expressions can probably\n // be factored out in common with other code that builds expressions.\n // FIXME: Cleanup the naming of these functions\n-fn pieces_to_expr(&ext_ctxt cx, common::span sp,\n-                  vec[piece] pieces, vec[@ast::expr] args) -> @ast::expr {\n-\n-    fn make_new_lit(&ext_ctxt cx,\n-                    common::span sp, ast::lit_ lit) -> @ast::expr {\n+fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n+                  vec[@ast::expr] args) -> @ast::expr {\n+    fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) ->\n+       @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n         auto expr = ast::expr_lit(sp_lit, cx.next_ann());\n         ret @rec(node=expr, span=sp);\n     }\n-\n     fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n         auto lit = ast::lit_str(s, ast::sk_rc);\n         ret make_new_lit(cx, sp, lit);\n     }\n-\n     fn make_new_int(&ext_ctxt cx, common::span sp, int i) -> @ast::expr {\n         auto lit = ast::lit_int(i);\n         ret make_new_lit(cx, sp, lit);\n     }\n-\n     fn make_new_uint(&ext_ctxt cx, common::span sp, uint u) -> @ast::expr {\n         auto lit = ast::lit_uint(u);\n         ret make_new_lit(cx, sp, lit);\n     }\n-\n-    fn make_add_expr(&ext_ctxt cx, common::span sp,\n-                     @ast::expr lhs, @ast::expr rhs) -> @ast::expr {\n+    fn make_add_expr(&ext_ctxt cx, common::span sp, @ast::expr lhs,\n+                     @ast::expr rhs) -> @ast::expr {\n         auto binexpr = ast::expr_binary(ast::add, lhs, rhs, cx.next_ann());\n         ret @rec(node=binexpr, span=sp);\n     }\n-\n     fn make_path_expr(&ext_ctxt cx, common::span sp, vec[ast::ident] idents)\n-            -> @ast::expr {\n+       -> @ast::expr {\n         let vec[@ast::ty] types = [];\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n         auto pathexpr = ast::expr_path(sp_path, cx.next_ann());\n         auto sp_pathexpr = @rec(node=pathexpr, span=sp);\n         ret sp_pathexpr;\n     }\n-\n-    fn make_vec_expr(&ext_ctxt cx, common::span sp, vec[@ast::expr] exprs)\n-            -> @ast::expr {\n-        auto vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc,\n-                                     cx.next_ann());\n+    fn make_vec_expr(&ext_ctxt cx, common::span sp, vec[@ast::expr] exprs) ->\n+       @ast::expr {\n+        auto vecexpr =\n+            ast::expr_vec(exprs, ast::imm, ast::sk_rc, cx.next_ann());\n         auto sp_vecexpr = @rec(node=vecexpr, span=sp);\n         ret sp_vecexpr;\n     }\n-\n     fn make_call(&ext_ctxt cx, common::span sp, vec[ast::ident] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n         auto callexpr = ast::expr_call(pathexpr, args, cx.next_ann());\n         auto sp_callexpr = @rec(node=callexpr, span=sp);\n         ret sp_callexpr;\n     }\n-\n     fn make_rec_expr(&ext_ctxt cx, common::span sp,\n                      vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n         let vec[ast::field] astfields = [];\n         for (tup(ast::ident, @ast::expr) field in fields) {\n             auto ident = field._0;\n             auto val = field._1;\n-            auto astfield = rec(node=rec(mut = ast::imm,\n-                                         ident = ident,\n-                                         expr = val), span=sp);\n+            auto astfield =\n+                rec(node=rec(mut=ast::imm, ident=ident, expr=val), span=sp);\n             astfields += [astfield];\n         }\n-\n-        auto recexpr = ast::expr_rec(astfields,\n-                                    option::none[@ast::expr],\n-                                    cx.next_ann());\n+        auto recexpr =\n+            ast::expr_rec(astfields, option::none[@ast::expr], cx.next_ann());\n         auto sp_recexpr = @rec(node=recexpr, span=sp);\n         ret sp_recexpr;\n     }\n-\n     fn make_path_vec(str ident) -> vec[str] {\n         // FIXME: #fmt can't currently be used from within std\n         // because we're explicitly referencing the 'std' crate here\n+\n         ret [\"std\", \"extfmt\", \"rt\", ident];\n     }\n-\n-    fn make_rt_path_expr(&ext_ctxt cx,\n-                         common::span sp, str ident) -> @ast::expr {\n+    fn make_rt_path_expr(&ext_ctxt cx, common::span sp, str ident) ->\n+       @ast::expr {\n         auto path = make_path_vec(ident);\n         ret make_path_expr(cx, sp, path);\n     }\n-\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n-    fn make_rt_conv_expr(&ext_ctxt cx,\n-                         common::span sp, &conv cnv) -> @ast::expr {\n \n-        fn make_flags(&ext_ctxt cx, common::span sp, vec[flag] flags)\n-                -> @ast::expr {\n+    fn make_rt_conv_expr(&ext_ctxt cx, common::span sp, &conv cnv) ->\n+       @ast::expr {\n+        fn make_flags(&ext_ctxt cx, common::span sp, vec[flag] flags) ->\n+           @ast::expr {\n             let vec[@ast::expr] flagexprs = [];\n             for (flag f in flags) {\n                 auto fstr;\n                 alt (f) {\n-                    case (flag_left_justify) {\n-                        fstr = \"flag_left_justify\";\n-                    }\n-                    case (flag_left_zero_pad) {\n-                        fstr = \"flag_left_zero_pad\";\n-                    }\n+                    case (flag_left_justify) { fstr = \"flag_left_justify\"; }\n+                    case (flag_left_zero_pad) { fstr = \"flag_left_zero_pad\"; }\n                     case (flag_space_for_sign) {\n                         fstr = \"flag_space_for_sign\";\n                     }\n-                    case (flag_sign_always) {\n-                        fstr = \"flag_sign_always\";\n-                    }\n-                    case (flag_alternate) {\n-                        fstr = \"flag_alternate\";\n-                    }\n+                    case (flag_sign_always) { fstr = \"flag_sign_always\"; }\n+                    case (flag_alternate) { fstr = \"flag_alternate\"; }\n                 }\n                 flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n             }\n-\n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n+\n             if (vec::len[@ast::expr](flagexprs) == 0u) {\n                 flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n-\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n-\n-        fn make_count(&ext_ctxt cx,\n-                      common::span sp, &count cnt) -> @ast::expr {\n+        fn make_count(&ext_ctxt cx, common::span sp, &count cnt) ->\n+           @ast::expr {\n             alt (cnt) {\n                 case (count_implied) {\n                     ret make_rt_path_expr(cx, sp, \"count_implied\");\n@@ -207,143 +172,96 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp,\n                 }\n             }\n         }\n-\n         fn make_ty(&ext_ctxt cx, common::span sp, &ty t) -> @ast::expr {\n             auto rt_type;\n             alt (t) {\n                 case (ty_hex(?c)) {\n                     alt (c) {\n-                        case (case_upper) {\n-                            rt_type = \"ty_hex_upper\";\n-                        }\n-                        case (case_lower) {\n-                            rt_type = \"ty_hex_lower\";\n-                        }\n+                        case (case_upper) { rt_type = \"ty_hex_upper\"; }\n+                        case (case_lower) { rt_type = \"ty_hex_lower\"; }\n                     }\n                 }\n-                case (ty_bits) {\n-                    rt_type = \"ty_bits\";\n-                }\n-                case (ty_octal) {\n-                    rt_type = \"ty_octal\";\n-                }\n-                case (_) {\n-                    rt_type = \"ty_default\";\n-                }\n+                case (ty_bits) { rt_type = \"ty_bits\"; }\n+                case (ty_octal) { rt_type = \"ty_octal\"; }\n+                case (_) { rt_type = \"ty_default\"; }\n             }\n-\n             ret make_rt_path_expr(cx, sp, rt_type);\n         }\n-\n-        fn make_conv_rec(&ext_ctxt cx,\n-                         common::span sp,\n-                         @ast::expr flags_expr,\n-                         @ast::expr width_expr,\n-                         @ast::expr precision_expr,\n+        fn make_conv_rec(&ext_ctxt cx, common::span sp, @ast::expr flags_expr,\n+                         @ast::expr width_expr, @ast::expr precision_expr,\n                          @ast::expr ty_expr) -> @ast::expr {\n-            ret make_rec_expr(cx, sp, [tup(\"flags\", flags_expr),\n-                                         tup(\"width\", width_expr),\n-                                         tup(\"precision\", precision_expr),\n-                                         tup(\"ty\", ty_expr)]);\n+            ret make_rec_expr(cx, sp,\n+                              [tup(\"flags\", flags_expr),\n+                               tup(\"width\", width_expr),\n+                               tup(\"precision\", precision_expr),\n+                               tup(\"ty\", ty_expr)]);\n         }\n-\n         auto rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         auto rt_conv_width = make_count(cx, sp, cnv.width);\n         auto rt_conv_precision = make_count(cx, sp, cnv.precision);\n         auto rt_conv_ty = make_ty(cx, sp, cnv.ty);\n-        ret make_conv_rec(cx,\n-                          sp,\n-                          rt_conv_flags,\n-                          rt_conv_width,\n-                          rt_conv_precision,\n-                          rt_conv_ty);\n+        ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n+                          rt_conv_precision, rt_conv_ty);\n     }\n-\n-    fn make_conv_call(&ext_ctxt cx, common::span sp, str conv_type,\n-                      &conv cnv, @ast::expr arg) -> @ast::expr {\n+    fn make_conv_call(&ext_ctxt cx, common::span sp, str conv_type, &conv cnv,\n+                      @ast::expr arg) -> @ast::expr {\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n         auto cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         auto args = [cnv_expr, arg];\n         ret make_call(cx, arg.span, path, args);\n     }\n-\n-    fn make_new_conv(&ext_ctxt cx, common::span sp,\n-                     conv cnv, @ast::expr arg) -> @ast::expr {\n-\n+    fn make_new_conv(&ext_ctxt cx, common::span sp, conv cnv, @ast::expr arg)\n+       -> @ast::expr {\n         // FIXME: Extract all this validation into extfmt::ct\n+\n         fn is_signed_type(conv cnv) -> bool {\n             alt (cnv.ty) {\n                 case (ty_int(?s)) {\n                     alt (s) {\n-                        case (signed) {\n-                            ret true;\n-                        }\n-                        case (unsigned) {\n-                            ret false;\n-                        }\n+                        case (signed) { ret true; }\n+                        case (unsigned) { ret false; }\n                     }\n                 }\n-                case (_) {\n-                    ret false;\n-                }\n+                case (_) { ret false; }\n             }\n         }\n-\n         auto unsupported = \"conversion not supported in #fmt string\";\n-\n         alt (cnv.param) {\n-            case (option::none) {\n-            }\n-            case (_) {\n-                cx.span_unimpl(sp, unsupported);\n-            }\n+            case (option::none) { }\n+            case (_) { cx.span_unimpl(sp, unsupported); }\n         }\n-\n         for (flag f in cnv.flags) {\n             alt (f) {\n-                case (flag_left_justify) {\n-                }\n+                case (flag_left_justify) { }\n                 case (flag_sign_always) {\n                     if (!is_signed_type(cnv)) {\n-                        cx.span_err(sp, \"+ flag only valid in \"\n-                                    + \"signed #fmt conversion\");\n+                        cx.span_err(sp,\n+                                    \"+ flag only valid in \" +\n+                                        \"signed #fmt conversion\");\n                     }\n                 }\n                 case (flag_space_for_sign) {\n                     if (!is_signed_type(cnv)) {\n-                        cx.span_err(sp, \"space flag only valid in \"\n-                                    + \"signed #fmt conversions\");\n+                        cx.span_err(sp,\n+                                    \"space flag only valid in \" +\n+                                        \"signed #fmt conversions\");\n                     }\n                 }\n-                case (flag_left_zero_pad) {\n-                }\n-                case (_) {\n-                    cx.span_unimpl(sp, unsupported);\n-                }\n+                case (flag_left_zero_pad) { }\n+                case (_) { cx.span_unimpl(sp, unsupported); }\n             }\n         }\n-\n         alt (cnv.width) {\n-            case (count_implied) {\n-            }\n-            case (count_is(_)) {\n-            }\n-            case (_) {\n-                cx.span_unimpl(sp, unsupported);\n-            }\n+            case (count_implied) { }\n+            case (count_is(_)) { }\n+            case (_) { cx.span_unimpl(sp, unsupported); }\n         }\n-\n         alt (cnv.precision) {\n-            case (count_implied) {\n-            }\n-            case (count_is(_)) {\n-            }\n-            case (_) {\n-                cx.span_unimpl(sp, unsupported);\n-            }\n+            case (count_implied) { }\n+            case (count_is(_)) { }\n+            case (_) { cx.span_unimpl(sp, unsupported); }\n         }\n-\n         alt (cnv.ty) {\n             case (ty_str) {\n                 ret make_conv_call(cx, arg.span, \"str\", cnv, arg);\n@@ -373,38 +291,21 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp,\n             case (ty_octal) {\n                 ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n             }\n-            case (_) {\n-                cx.span_unimpl(sp, unsupported);\n-            }\n+            case (_) { cx.span_unimpl(sp, unsupported); }\n         }\n     }\n-\n     fn log_conv(conv c) {\n         alt (c.param) {\n-            case (some(?p)) {\n-                log \"param: \" + std::int::to_str(p, 10u);\n-            }\n-            case (_) {\n-                log \"param: none\";\n-            }\n+            case (some(?p)) { log \"param: \" + std::int::to_str(p, 10u); }\n+            case (_) { log \"param: none\"; }\n         }\n         for (flag f in c.flags) {\n             alt (f) {\n-                case (flag_left_justify) {\n-                    log \"flag: left justify\";\n-                }\n-                case (flag_left_zero_pad) {\n-                    log \"flag: left zero pad\";\n-                }\n-                case (flag_space_for_sign) {\n-                    log \"flag: left space pad\";\n-                }\n-                case (flag_sign_always) {\n-                    log \"flag: sign always\";\n-                }\n-                case (flag_alternate) {\n-                    log \"flag: alternate\";\n-                }\n+                case (flag_left_justify) { log \"flag: left justify\"; }\n+                case (flag_left_zero_pad) { log \"flag: left zero pad\"; }\n+                case (flag_space_for_sign) { log \"flag: left space pad\"; }\n+                case (flag_sign_always) { log \"flag: sign always\"; }\n+                case (flag_alternate) { log \"flag: alternate\"; }\n             }\n         }\n         alt (c.width) {\n@@ -414,12 +315,8 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp,\n             case (count_is_param(?i)) {\n                 log \"width: count is param \" + std::int::to_str(i, 10u);\n             }\n-            case (count_is_next_param) {\n-                log \"width: count is next param\";\n-            }\n-            case (count_implied) {\n-                log \"width: count is implied\";\n-            }\n+            case (count_is_next_param) { log \"width: count is next param\"; }\n+            case (count_implied) { log \"width: count is implied\"; }\n         }\n         alt (c.precision) {\n             case (count_is(?i)) {\n@@ -428,57 +325,33 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp,\n             case (count_is_param(?i)) {\n                 log \"prec: count is param \" + std::int::to_str(i, 10u);\n             }\n-            case (count_is_next_param) {\n-                log \"prec: count is next param\";\n-            }\n-            case (count_implied) {\n-                log \"prec: count is implied\";\n-            }\n+            case (count_is_next_param) { log \"prec: count is next param\"; }\n+            case (count_implied) { log \"prec: count is implied\"; }\n         }\n         alt (c.ty) {\n-            case (ty_bool) {\n-                log \"type: bool\";\n-            }\n-            case (ty_str) {\n-                log \"type: str\";\n-            }\n-            case (ty_char) {\n-                log \"type: char\";\n-            }\n+            case (ty_bool) { log \"type: bool\"; }\n+            case (ty_str) { log \"type: str\"; }\n+            case (ty_char) { log \"type: char\"; }\n             case (ty_int(?s)) {\n                 alt (s) {\n-                    case (signed) {\n-                        log \"type: signed\";\n-                    }\n-                    case (unsigned) {\n-                        log \"type: unsigned\";\n-                    }\n+                    case (signed) { log \"type: signed\"; }\n+                    case (unsigned) { log \"type: unsigned\"; }\n                 }\n             }\n-            case (ty_bits) {\n-                log \"type: bits\";\n-            }\n+            case (ty_bits) { log \"type: bits\"; }\n             case (ty_hex(?cs)) {\n                 alt (cs) {\n-                    case (case_upper) {\n-                        log \"type: uhex\";\n-                    }\n-                    case (case_lower) {\n-                        log \"type: lhex\";\n-                    }\n+                    case (case_upper) { log \"type: uhex\"; }\n+                    case (case_lower) { log \"type: lhex\"; }\n                 }\n             }\n-            case (ty_octal) {\n-                log \"type: octal\";\n-            }\n+            case (ty_octal) { log \"type: octal\"; }\n         }\n     }\n-\n     auto fmt_sp = args.(0).span;\n     auto n = 0u;\n     auto tmp_expr = make_new_str(cx, sp, \"\");\n     auto nargs = vec::len[@ast::expr](args);\n-\n     for (piece pc in pieces) {\n         alt (pc) {\n             case (piece_string(?s)) {\n@@ -487,32 +360,28 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp,\n             }\n             case (piece_conv(?conv)) {\n                 n += 1u;\n-\n                 if (n >= nargs) {\n-                    cx.span_err(sp, \"not enough arguments to #fmt \"\n-                                + \"for the given format string\");\n+                    cx.span_err(sp,\n+                                \"not enough arguments to #fmt \" +\n+                                    \"for the given format string\");\n                 }\n-\n                 log \"Building conversion:\";\n                 log_conv(conv);\n-\n                 auto arg_expr = args.(n);\n                 auto c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n                 tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, c_expr);\n             }\n         }\n     }\n-\n     auto expected_nargs = n + 1u; // n conversions + the fmt string\n+\n     if (expected_nargs < nargs) {\n         cx.span_err(sp,\n                     #fmt(\"too many arguments to #fmt. found %u, expected %u\",\n                          nargs, expected_nargs));\n     }\n-\n     ret tmp_expr;\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "7f013f7c6148e347219f7f4e97ae54cc02fd1dd0", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 169, "deletions": 379, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::io;\n import std::str;\n import std::vec;\n@@ -11,173 +12,123 @@ import driver::session::session;\n import util::common;\n import util::common::*;\n import util::data::interner;\n-\n-state type reader = state obj {\n-    fn is_eof() -> bool;\n-    fn curr() -> char;\n-    fn next() -> char;\n-    fn init();\n-    fn bump();\n-    fn mark();\n-    fn get_mark_chpos() -> uint;\n-    fn get_mark_str() -> str;\n-    fn get_interner() -> @interner::interner[str];\n-    fn get_chpos() -> uint;\n-    fn get_col() -> uint;\n-    fn get_filemap() -> codemap::filemap;\n-    fn err(str m);\n-};\n-\n-fn new_reader(session sess, io::reader rdr,\n-              codemap::filemap filemap,\n+import util::data::interner::intern;\n+\n+type reader =\n+    obj {\n+        fn is_eof() -> bool ;\n+        fn curr() -> char ;\n+        fn next() -> char ;\n+        fn init() ;\n+        fn bump() ;\n+        fn mark() ;\n+        fn get_mark_chpos() -> uint ;\n+        fn get_mark_str() -> str ;\n+        fn get_interner() -> @interner::interner[str] ;\n+        fn get_chpos() -> uint ;\n+        fn get_col() -> uint ;\n+        fn get_filemap() -> codemap::filemap ;\n+        fn err(str) ;\n+    };\n+\n+fn new_reader(session sess, io::reader rdr, codemap::filemap filemap,\n               @interner::interner[str] itr) -> reader {\n-\n-    state obj reader(session sess,\n-                     str file,\n-                     uint len,\n-                     mutable uint col,\n-                     mutable uint pos,\n-                     mutable char ch,\n-                     mutable uint mark_chpos,\n-                     mutable uint chpos,\n-                     mutable vec[str] strs,\n-                     codemap::filemap fm,\n-                     @interner::interner[str] itr) {\n-\n-        fn is_eof() -> bool {\n-            ret ch == -1 as char;\n-        }\n-\n+    obj reader(session sess,\n+               str file,\n+               uint len,\n+               mutable uint col,\n+               mutable uint pos,\n+               mutable char ch,\n+               mutable uint mark_chpos,\n+               mutable uint chpos,\n+               mutable vec[str] strs,\n+               codemap::filemap fm,\n+               @interner::interner[str] itr) {\n+        fn is_eof() -> bool { ret ch == -1 as char; }\n         fn mark() { mark_chpos = chpos; }\n-        fn get_mark_str() -> str {\n-            ret str::slice(file, mark_chpos, chpos);\n-        }\n+        fn get_mark_str() -> str { ret str::slice(file, mark_chpos, chpos); }\n         fn get_mark_chpos() -> uint { ret mark_chpos; }\n         fn get_chpos() -> uint { ret chpos; }\n-\n-        fn curr() -> char {\n-            ret ch;\n-        }\n-\n+        fn curr() -> char { ret ch; }\n         fn next() -> char {\n-            if (pos < len) {ret str::char_at(file, pos);}\n-            else {ret -1 as char;}\n+            if (pos < len) {\n+                ret str::char_at(file, pos);\n+            } else { ret -1 as char; }\n         }\n-\n         fn init() {\n             if (pos < len) {\n                 auto next = str::char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             }\n         }\n-\n         fn bump() {\n             if (pos < len) {\n                 col += 1u;\n                 chpos += 1u;\n-                if (ch == '\\n') {\n-                    codemap::next_line(fm, chpos);\n-                    col = 0u;\n-                }\n+                if (ch == '\\n') { codemap::next_line(fm, chpos); col = 0u; }\n                 auto next = str::char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n-            } else {\n-                ch = -1 as char;\n-            }\n+            } else { ch = -1 as char; }\n         }\n-\n         fn get_interner() -> @interner::interner[str] { ret itr; }\n-\n-        fn get_col() -> uint {\n-            ret col;\n-        }\n-\n-        fn get_filemap() -> codemap::filemap {\n-            ret fm;\n-        }\n-\n-        fn err(str m) {\n-            sess.span_err(rec(lo=chpos, hi=chpos), m);\n-        }\n+        fn get_col() -> uint { ret col; }\n+        fn get_filemap() -> codemap::filemap { ret fm; }\n+        fn err(str m) { sess.span_err(rec(lo=chpos, hi=chpos), m); }\n     }\n     auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];\n-    auto rd = reader(sess, file, str::byte_len(file), 0u, 0u,\n-                     -1 as char, filemap.start_pos, filemap.start_pos,\n-                     strs, filemap, itr);\n+    auto rd =\n+        reader(sess, file, str::byte_len(file), 0u, 0u, -1 as char,\n+               filemap.start_pos, filemap.start_pos, strs, filemap, itr);\n     rd.init();\n     ret rd;\n }\n \n-\n-fn dec_digit_val(char c) -> int {\n-    ret (c as int) - ('0' as int);\n-}\n+fn dec_digit_val(char c) -> int { ret (c as int) - ('0' as int); }\n \n fn hex_digit_val(char c) -> int {\n-    if (in_range(c, '0', '9')) {\n-        ret (c as int) - ('0' as int);\n-    }\n-\n-    if (in_range(c, 'a', 'f')) {\n-        ret ((c as int) - ('a' as int)) + 10;\n-    }\n-\n-    if (in_range(c, 'A', 'F')) {\n-        ret ((c as int) - ('A' as int)) + 10;\n-    }\n-\n+    if (in_range(c, '0', '9')) { ret (c as int) - ('0' as int); }\n+    if (in_range(c, 'a', 'f')) { ret (c as int) - ('a' as int) + 10; }\n+    if (in_range(c, 'A', 'F')) { ret (c as int) - ('A' as int) + 10; }\n     fail;\n }\n \n-fn bin_digit_value(char c) -> int {\n-    if (c == '0') { ret 0; }\n-    ret 1;\n-}\n+fn bin_digit_value(char c) -> int { if (c == '0') { ret 0; } ret 1; }\n \n fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n fn consume_whitespace_and_comments(&reader rdr) {\n-    while (is_whitespace(rdr.curr())) {\n-        rdr.bump();\n-    }\n+    while (is_whitespace(rdr.curr())) { rdr.bump(); }\n     be consume_any_line_comment(rdr);\n }\n \n fn consume_any_line_comment(&reader rdr) {\n     if (rdr.curr() == '/') {\n         alt (rdr.next()) {\n             case ('/') {\n-                while (rdr.curr() != '\\n' && !rdr.is_eof()) {\n-                    rdr.bump();\n-                }\n+                while (rdr.curr() != '\\n' && !rdr.is_eof()) { rdr.bump(); }\n                 // Restart whitespace munch.\n+\n                 be consume_whitespace_and_comments(rdr);\n             }\n             case ('*') {\n                 rdr.bump();\n                 rdr.bump();\n                 be consume_block_comment(rdr);\n             }\n-            case (_) {\n-                ret;\n-            }\n+            case (_) { ret; }\n         }\n     }\n }\n \n-\n fn consume_block_comment(&reader rdr) {\n     let int level = 1;\n     while (level > 0) {\n-        if (rdr.is_eof()) {\n-            rdr.err(\"unterminated block comment\");\n-            fail;\n-        }\n+        if (rdr.is_eof()) { rdr.err(\"unterminated block comment\"); fail; }\n         if (rdr.curr() == '/' && rdr.next() == '*') {\n             rdr.bump();\n             rdr.bump();\n@@ -187,32 +138,27 @@ fn consume_block_comment(&reader rdr) {\n                 rdr.bump();\n                 rdr.bump();\n                 level -= 1;\n-            } else {\n-                rdr.bump();\n-            }\n+            } else { rdr.bump(); }\n         }\n     }\n     // restart whitespace munch.\n+\n     be consume_whitespace_and_comments(rdr);\n }\n \n fn digits_to_string(str s) -> int {\n-\n     let int accum_int = 0;\n     let int i = 0;\n-\n     for (u8 c in s) {\n         accum_int *= 10;\n         accum_int += dec_digit_val(c as char);\n     }\n-\n     ret accum_int;\n }\n \n fn scan_exponent(&reader rdr) -> option::t[str] {\n     auto c = rdr.curr();\n     auto res = \"\";\n-\n     if (c == 'e' || c == 'E') {\n         res += str::from_bytes([c as u8]);\n         rdr.bump();\n@@ -223,31 +169,19 @@ fn scan_exponent(&reader rdr) -> option::t[str] {\n         }\n         auto exponent = scan_dec_digits(rdr);\n         if (str::byte_len(exponent) > 0u) {\n-            ret(some(res + exponent));\n-        }\n-        else {\n-            rdr.err(\"scan_exponent: bad fp literal\");\n-            fail;\n-        }\n-    }\n-    else {\n-        ret none[str];\n-    }\n+            ret some(res + exponent);\n+        } else { rdr.err(\"scan_exponent: bad fp literal\"); fail; }\n+    } else { ret none[str]; }\n }\n \n fn scan_dec_digits(&reader rdr) -> str {\n-\n     auto c = rdr.curr();\n     let str res = \"\";\n-\n-    while (is_dec_digit (c) || c == '_') {\n-        if (c != '_') {\n-            res += str::from_bytes([c as u8]);\n-        }\n+    while (is_dec_digit(c) || c == '_') {\n+        if (c != '_') { res += str::from_bytes([c as u8]); }\n         rdr.bump();\n         c = rdr.curr();\n     }\n-\n     ret res;\n }\n \n@@ -256,16 +190,12 @@ fn scan_number(char c, &reader rdr) -> token::token {\n     let str dec_str = \"\";\n     let bool is_dec_integer = false;\n     auto n = rdr.next();\n-\n     if (c == '0' && n == 'x') {\n         rdr.bump();\n         rdr.bump();\n         c = rdr.curr();\n         while (is_hex_digit(c) || c == '_') {\n-            if (c != '_') {\n-                accum_int *= 16;\n-                accum_int += hex_digit_val(c);\n-            }\n+            if (c != '_') { accum_int *= 16; accum_int += hex_digit_val(c); }\n             rdr.bump();\n             c = rdr.curr();\n         }\n@@ -274,125 +204,100 @@ fn scan_number(char c, &reader rdr) -> token::token {\n         rdr.bump();\n         c = rdr.curr();\n         while (is_bin_digit(c) || c == '_') {\n-            if (c != '_') {\n-                accum_int *= 2;\n-                accum_int += bin_digit_value(c);\n-            }\n+            if (c != '_') { accum_int *= 2; accum_int += bin_digit_value(c); }\n             rdr.bump();\n             c = rdr.curr();\n         }\n-    } else {\n-        dec_str = scan_dec_digits(rdr);\n-        is_dec_integer = true;\n-    }\n-\n-    if (is_dec_integer) {\n-        accum_int = digits_to_string(dec_str);\n-    }\n-\n+    } else { dec_str = scan_dec_digits(rdr); is_dec_integer = true; }\n+    if (is_dec_integer) { accum_int = digits_to_string(dec_str); }\n     c = rdr.curr();\n     n = rdr.next();\n-\n     if (c == 'u' || c == 'i') {\n-        let bool signed = (c == 'i');\n+        let bool signed = c == 'i';\n         rdr.bump();\n         c = rdr.curr();\n         if (c == '8') {\n             rdr.bump();\n             if (signed) {\n                 ret token::LIT_MACH_INT(common::ty_i8, accum_int);\n-            } else {\n-                ret token::LIT_MACH_INT(common::ty_u8, accum_int);\n-            }\n+            } else { ret token::LIT_MACH_INT(common::ty_u8, accum_int); }\n         }\n-\n         n = rdr.next();\n         if (c == '1' && n == '6') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n                 ret token::LIT_MACH_INT(common::ty_i16, accum_int);\n-            } else {\n-                ret token::LIT_MACH_INT(common::ty_u16, accum_int);\n-            }\n+            } else { ret token::LIT_MACH_INT(common::ty_u16, accum_int); }\n         }\n         if (c == '3' && n == '2') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n                 ret token::LIT_MACH_INT(common::ty_i32, accum_int);\n-            } else {\n-                ret token::LIT_MACH_INT(common::ty_u32, accum_int);\n-            }\n+            } else { ret token::LIT_MACH_INT(common::ty_u32, accum_int); }\n         }\n-\n         if (c == '6' && n == '4') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n                 ret token::LIT_MACH_INT(common::ty_i64, accum_int);\n-            } else {\n-                ret token::LIT_MACH_INT(common::ty_u64, accum_int);\n-            }\n+            } else { ret token::LIT_MACH_INT(common::ty_u64, accum_int); }\n         }\n-\n         if (signed) {\n             ret token::LIT_INT(accum_int);\n         } else {\n             // FIXME: should cast in the target bit-width.\n+\n             ret token::LIT_UINT(accum_int as uint);\n         }\n     }\n     c = rdr.curr();\n-\n     if (c == '.') {\n         // Parse a floating-point number.\n+\n         rdr.bump();\n         auto dec_part = scan_dec_digits(rdr);\n         auto float_str = dec_str + \".\" + dec_part;\n         c = rdr.curr();\n         auto exponent_str = scan_exponent(rdr);\n         alt (exponent_str) {\n-            case (some(?s)) {\n-                float_str += s;\n-            }\n-            case (none) {\n-            }\n+            case (some(?s)) { float_str += s; }\n+            case (none) { }\n         }\n-\n         c = rdr.curr();\n         if (c == 'f') {\n             rdr.bump();\n             c = rdr.curr();\n             n = rdr.next();\n             if (c == '3' && n == '2') {\n-                rdr.bump(); rdr.bump();\n+                rdr.bump();\n+                rdr.bump();\n                 ret token::LIT_MACH_FLOAT(util::common::ty_f32,\n-                    interner::intern[str](*rdr.get_interner(), float_str));\n-            }\n-            else if (c == '6' && n == '4') {\n-                rdr.bump(); rdr.bump();\n+                                          intern(*rdr.get_interner(),\n+                                                 float_str));\n+            } else if (c == '6' && n == '4') {\n+                rdr.bump();\n+                rdr.bump();\n                 ret token::LIT_MACH_FLOAT(util::common::ty_f64,\n-                    interner::intern[str](*rdr.get_interner(), float_str));\n+                                          intern(*rdr.get_interner(),\n+                                                           float_str));\n                 /* FIXME: if this is out of range for either a 32-bit or\n                    64-bit float, it won't be noticed till the back-end */\n+\n             }\n-        }\n-        else {\n+        } else {\n             ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n                                                        float_str));\n         }\n     }\n-\n     auto maybe_exponent = scan_exponent(rdr);\n-    alt(maybe_exponent) {\n-        case(some(?s)) {\n+    alt (maybe_exponent) {\n+        case (some(?s)) {\n             ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n                                                        dec_str + s));\n         }\n-        case(none) {\n-            ret token::LIT_INT(accum_int);\n-        }\n+        case (none) { ret token::LIT_INT(accum_int); }\n     }\n }\n \n@@ -412,50 +317,38 @@ fn scan_numeric_escape(&reader rdr, uint n_hex_digits) -> char {\n     ret accum_int as char;\n }\n \n-\n fn next_token(&reader rdr) -> token::token {\n     auto accum_str = \"\";\n-\n     consume_whitespace_and_comments(rdr);\n-\n     if (rdr.is_eof()) { ret token::EOF; }\n-\n     rdr.mark();\n     auto c = rdr.curr();\n-\n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n             str::push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n-\n-        if (str::eq(accum_str, \"_\")) {\n-            ret token::UNDERSCORE;\n-        }\n-\n+        if (str::eq(accum_str, \"_\")) { ret token::UNDERSCORE; }\n         auto is_mod_name = c == ':' && rdr.next() == ':';\n         ret token::IDENT(interner::intern[str](*rdr.get_interner(),\n                                                accum_str), is_mod_name);\n     }\n-\n-    if (is_dec_digit(c)) {\n-        ret scan_number(c, rdr);\n-    }\n-\n+    if (is_dec_digit(c)) { ret scan_number(c, rdr); }\n     fn binop(&reader rdr, token::binop op) -> token::token {\n         rdr.bump();\n         if (rdr.curr() == '=') {\n             rdr.bump();\n             ret token::BINOPEQ(op);\n-        } else {\n-            ret token::BINOP(op);\n-        }\n+        } else { ret token::BINOP(op); }\n     }\n-\n     alt (c) {\n-        // One-byte tokens.\n-        case ('?') { rdr.bump(); ret token::QUES; }\n+        case (\n+             // One-byte tokens.\n+             '?') {\n+            rdr.bump();\n+            ret token::QUES;\n+        }\n         case (';') { rdr.bump(); ret token::SEMI; }\n         case (',') { rdr.bump(); ret token::COMMA; }\n         case ('.') { rdr.bump(); ret token::DOT; }\n@@ -473,80 +366,47 @@ fn next_token(&reader rdr) -> token::token {\n             if (rdr.curr() == ':') {\n                 rdr.bump();\n                 ret token::MOD_SEP;\n-            }\n-            else {\n-                ret token::COLON;\n-            };\n+            } else { ret token::COLON; }\n         }\n-\n-        // Multi-byte tokens.\n-        case ('=') {\n+        case (\n+             // Multi-byte tokens.\n+             '=') {\n             rdr.bump();\n             if (rdr.curr() == '=') {\n                 rdr.bump();\n                 ret token::EQEQ;\n-            } else {\n-                ret token::EQ;\n-            }\n+            } else { ret token::EQ; }\n         }\n-\n         case ('!') {\n             rdr.bump();\n             if (rdr.curr() == '=') {\n                 rdr.bump();\n                 ret token::NE;\n-            } else {\n-                ret token::NOT;\n-            }\n+            } else { ret token::NOT; }\n         }\n-\n         case ('<') {\n             rdr.bump();\n             alt (rdr.curr()) {\n-                case ('=') {\n-                    rdr.bump();\n-                    ret token::LE;\n-                }\n-                case ('<') {\n-                    ret binop(rdr, token::LSL);\n-                }\n-                case ('-') {\n-                    rdr.bump();\n-                    ret token::LARROW;\n-                }\n-                case ('|') {\n-                    rdr.bump();\n-                    ret token::SEND;\n-                }\n-                case (_) {\n-                    ret token::LT;\n-                }\n+                case ('=') { rdr.bump(); ret token::LE; }\n+                case ('<') { ret binop(rdr, token::LSL); }\n+                case ('-') { rdr.bump(); ret token::LARROW; }\n+                case ('|') { rdr.bump(); ret token::SEND; }\n+                case (_) { ret token::LT; }\n             }\n         }\n-\n         case ('>') {\n             rdr.bump();\n             alt (rdr.curr()) {\n-                case ('=') {\n-                    rdr.bump();\n-                    ret token::GE;\n-                }\n-\n+                case ('=') { rdr.bump(); ret token::GE; }\n                 case ('>') {\n                     if (rdr.next() == '>') {\n                         rdr.bump();\n                         ret binop(rdr, token::ASR);\n-                    } else {\n-                        ret binop(rdr, token::LSR);\n-                    }\n-                }\n-\n-                case (_) {\n-                    ret token::GT;\n+                    } else { ret binop(rdr, token::LSR); }\n                 }\n+                case (_) { ret token::GT; }\n             }\n         }\n-\n         case ('\\'') {\n             rdr.bump();\n             auto c2 = rdr.curr();\n@@ -560,27 +420,24 @@ fn next_token(&reader rdr) -> token::token {\n                     case ('t') { c2 = '\\t'; }\n                     case ('\\\\') { c2 = '\\\\'; }\n                     case ('\\'') { c2 = '\\''; }\n-\n                     case ('x') { c2 = scan_numeric_escape(rdr, 2u); }\n                     case ('u') { c2 = scan_numeric_escape(rdr, 4u); }\n                     case ('U') { c2 = scan_numeric_escape(rdr, 8u); }\n-\n                     case (?c2) {\n                         rdr.err(#fmt(\"unknown character escape: %d\",\n                                      c2 as int));\n                         fail;\n                     }\n                 }\n             }\n-\n             if (rdr.curr() != '\\'') {\n                 rdr.err(\"unterminated character constant\");\n                 fail;\n             }\n             rdr.bump(); // advance curr past token\n+\n             ret token::LIT_CHAR(c2);\n         }\n-\n         case ('\"') {\n             rdr.bump();\n             while (rdr.curr() != '\"') {\n@@ -606,114 +463,74 @@ fn next_token(&reader rdr) -> token::token {\n                             case ('\"') {\n                                 str::push_byte(accum_str, '\"' as u8);\n                             }\n-                            case ('\\n') {\n-                                consume_whitespace(rdr);\n-                            }\n-\n+                            case ('\\n') { consume_whitespace(rdr); }\n                             case ('x') {\n                                 str::push_char(accum_str,\n                                                scan_numeric_escape(rdr, 2u));\n                             }\n-\n                             case ('u') {\n                                 str::push_char(accum_str,\n                                                scan_numeric_escape(rdr, 4u));\n                             }\n-\n                             case ('U') {\n                                 str::push_char(accum_str,\n                                                scan_numeric_escape(rdr, 8u));\n                             }\n-\n                             case (?c2) {\n                                 rdr.err(#fmt(\"unknown string escape: %d\",\n                                              c2 as int));\n                                 fail;\n                             }\n                         }\n                     }\n-                    case (_) {\n-                        str::push_char(accum_str, ch);\n-                    }\n+                    case (_) { str::push_char(accum_str, ch); }\n                 }\n             }\n             rdr.bump();\n             ret token::LIT_STR(interner::intern[str](*rdr.get_interner(),\n                                                      accum_str));\n         }\n-\n         case ('-') {\n             if (rdr.next() == '>') {\n                 rdr.bump();\n                 rdr.bump();\n                 ret token::RARROW;\n-            } else {\n-                ret binop(rdr, token::MINUS);\n-            }\n+            } else { ret binop(rdr, token::MINUS); }\n         }\n-\n         case ('&') {\n             if (rdr.next() == '&') {\n                 rdr.bump();\n                 rdr.bump();\n                 ret token::ANDAND;\n-            } else {\n-                ret binop(rdr, token::AND);\n-            }\n+            } else { ret binop(rdr, token::AND); }\n         }\n-\n         case ('|') {\n             alt (rdr.next()) {\n-                case ('|') {\n-                    rdr.bump();\n-                    rdr.bump();\n-                    ret token::OROR;\n-                }\n-                case ('>') {\n-                    rdr.bump();\n-                    rdr.bump();\n-                    ret token::RECV;\n-                }\n-                case (_) {\n-                    ret binop(rdr, token::OR);\n-                }\n+                case ('|') { rdr.bump(); rdr.bump(); ret token::OROR; }\n+                case ('>') { rdr.bump(); rdr.bump(); ret token::RECV; }\n+                case (_) { ret binop(rdr, token::OR); }\n             }\n         }\n-\n-        case ('+') {\n-            ret binop(rdr, token::PLUS);\n-        }\n-\n-        case ('*') {\n-            ret binop(rdr, token::STAR);\n-        }\n-\n-        case ('/') {\n-            ret binop(rdr, token::SLASH);\n-        }\n-\n-        case ('^') {\n-            ret binop(rdr, token::CARET);\n-        }\n-\n-        case ('%') {\n-            ret binop(rdr, token::PERCENT);\n-        }\n-\n+        case ('+') { ret binop(rdr, token::PLUS); }\n+        case ('*') { ret binop(rdr, token::STAR); }\n+        case ('/') { ret binop(rdr, token::SLASH); }\n+        case ('^') { ret binop(rdr, token::CARET); }\n+        case ('%') { ret binop(rdr, token::PERCENT); }\n         case (?c) {\n             rdr.err(#fmt(\"unkown start of token: %d\", c as int));\n             fail;\n         }\n     }\n-\n     fail;\n }\n \n-\n tag cmnt_style {\n-    isolated;  // No code on either side of each line of the comment\n-    trailing;  // Code exists to the left of the comment\n-    mixed;     // Code before /* foo */ and after the comment\n+    isolated; // No code on either side of each line of the comment\n+\n+    trailing; // Code exists to the left of the comment\n+\n+    mixed; // Code before /* foo */ and after the comment\n+\n }\n \n type cmnt = rec(cmnt_style style, vec[str] lines, uint pos);\n@@ -724,80 +541,64 @@ fn read_to_eol(&reader rdr) -> str {\n         str::push_char(val, rdr.curr());\n         rdr.bump();\n     }\n-    if (rdr.curr() == '\\n') {\n-        rdr.bump();\n-    } else {\n-        assert rdr.is_eof();\n-    }\n+    if (rdr.curr() == '\\n') { rdr.bump(); } else { assert (rdr.is_eof()); }\n     ret val;\n }\n \n fn read_one_line_comment(&reader rdr) -> str {\n     auto val = read_to_eol(rdr);\n-    assert val.(0) == ('/' as u8) && val.(1) == ('/' as u8);\n+    assert (val.(0) == '/' as u8 && val.(1) == '/' as u8);\n     ret val;\n }\n \n fn consume_whitespace(&reader rdr) {\n-    while (is_whitespace(rdr.curr()) && !rdr.is_eof()) {\n-        rdr.bump();\n-    }\n+    while (is_whitespace(rdr.curr()) && !rdr.is_eof()) { rdr.bump(); }\n }\n \n-\n fn consume_non_eol_whitespace(&reader rdr) {\n-    while (is_whitespace(rdr.curr()) &&\n-           rdr.curr() != '\\n' && !rdr.is_eof()) {\n+    while (is_whitespace(rdr.curr()) && rdr.curr() != '\\n' && !rdr.is_eof()) {\n         rdr.bump();\n     }\n }\n \n-\n fn read_line_comments(&reader rdr, bool code_to_the_left) -> cmnt {\n     log \">>> line comments\";\n     auto p = rdr.get_chpos();\n     let vec[str] lines = [];\n     while (rdr.curr() == '/' && rdr.next() == '/') {\n-        auto line =  read_one_line_comment(rdr);\n+        auto line = read_one_line_comment(rdr);\n         log line;\n         lines += [line];\n         consume_non_eol_whitespace(rdr);\n     }\n     log \"<<< line comments\";\n-    ret rec(style = if (code_to_the_left) { trailing } else { isolated },\n-            lines = lines,\n+    ret rec(style=if (code_to_the_left) { trailing } else { isolated },\n+            lines=lines,\n             pos=p);\n }\n \n fn all_whitespace(&str s, uint begin, uint end) -> bool {\n     let uint i = begin;\n     while (i != end) {\n-        if (!is_whitespace(s.(i) as char)) {\n-            ret false;\n-        }\n+        if (!is_whitespace(s.(i) as char)) { ret false; }\n         i += 1u;\n     }\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(&mutable vec[str] lines,\n-                                        &str s, uint col) {\n+fn trim_whitespace_prefix_and_push_line(&mutable vec[str] lines, &str s,\n+                                        uint col) {\n     auto s1;\n     if (all_whitespace(s, 0u, col)) {\n         if (col < str::byte_len(s)) {\n             s1 = str::slice(s, col, str::byte_len(s));\n-        } else {\n-            s1 = \"\";\n-        }\n-    } else {\n-        s1 = s;\n-    }\n+        } else { s1 = \"\"; }\n+    } else { s1 = s; }\n     log \"pushing line: \" + s1;\n     lines += [s1];\n }\n \n-fn read_block_comment(&reader rdr,\n-                      bool code_to_the_left) -> cmnt {\n+fn read_block_comment(&reader rdr, bool code_to_the_left) -> cmnt {\n     log \">>> block comment\";\n     auto p = rdr.get_chpos();\n     let vec[str] lines = [];\n@@ -808,10 +609,7 @@ fn read_block_comment(&reader rdr,\n     let int level = 1;\n     while (level > 0) {\n         log #fmt(\"=== block comment level %d\", level);\n-        if (rdr.is_eof()) {\n-            rdr.err(\"unterminated block comment\");\n-            fail;\n-        }\n+        if (rdr.is_eof()) { rdr.err(\"unterminated block comment\"); fail; }\n         if (rdr.curr() == '\\n') {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n             curr_line = \"\";\n@@ -829,63 +627,56 @@ fn read_block_comment(&reader rdr,\n                     rdr.bump();\n                     curr_line += \"/\";\n                     level -= 1;\n-                } else {\n-                    rdr.bump();\n-                }\n+                } else { rdr.bump(); }\n             }\n         }\n     }\n     if (str::byte_len(curr_line) != 0u) {\n         trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n     }\n-\n     auto style = if (code_to_the_left) { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n-    if (!rdr.is_eof() &&\n-        rdr.curr() != '\\n' &&\n-        vec::len(lines) == 1u) {\n+    if (!rdr.is_eof() && rdr.curr() != '\\n' && vec::len(lines) == 1u) {\n         style = mixed;\n     }\n     log \"<<< block comment\";\n-    ret rec(style = style, lines = lines, pos=p);\n+    ret rec(style=style, lines=lines, pos=p);\n }\n \n fn peeking_at_comment(&reader rdr) -> bool {\n-    ret (rdr.curr() == '/' && rdr.next() == '/') ||\n-        (rdr.curr() == '/' && rdr.next() == '*');\n+    ret rdr.curr() == '/' && rdr.next() == '/' ||\n+            rdr.curr() == '/' && rdr.next() == '*';\n }\n \n fn consume_comment(&reader rdr, bool code_to_the_left,\n                    &mutable vec[cmnt] comments) {\n     log \">>> consume comment\";\n     if (rdr.curr() == '/' && rdr.next() == '/') {\n-        vec::push[cmnt](comments,\n-                        read_line_comments(rdr, code_to_the_left));\n+        vec::push[cmnt](comments, read_line_comments(rdr, code_to_the_left));\n     } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-        vec::push[cmnt](comments,\n-                        read_block_comment(rdr, code_to_the_left));\n+        vec::push[cmnt](comments, read_block_comment(rdr, code_to_the_left));\n     } else { fail; }\n     log \"<<< consume comment\";\n }\n \n fn is_lit(&token::token t) -> bool {\n     ret alt (t) {\n-        case (token::LIT_INT(_)) { true }\n-        case (token::LIT_UINT(_)) { true }\n-        case (token::LIT_MACH_INT(_,_)) { true }\n-        case (token::LIT_FLOAT(_)) { true }\n-        case (token::LIT_MACH_FLOAT(_,_)) { true }\n-        case (token::LIT_STR(_)) { true }\n-        case (token::LIT_CHAR(_)) { true }\n-        case (token::LIT_BOOL(_)) { true }\n-        case (_) { false }\n-    }\n+            case (token::LIT_INT(_)) { true }\n+            case (token::LIT_UINT(_)) { true }\n+            case (token::LIT_MACH_INT(_, _)) { true }\n+            case (token::LIT_FLOAT(_)) { true }\n+            case (token::LIT_MACH_FLOAT(_, _)) { true }\n+            case (token::LIT_STR(_)) { true }\n+            case (token::LIT_CHAR(_)) { true }\n+            case (token::LIT_BOOL(_)) { true }\n+            case (_) { false }\n+        }\n }\n \n type lit = rec(str lit, uint pos);\n \n-fn gather_comments_and_literals(session sess, str path)\n-    -> rec(vec[cmnt] cmnts, vec[lit] lits) {\n+fn gather_comments_and_literals(session sess, str path) ->\n+   rec(vec[cmnt] cmnts, vec[lit] lits) {\n     auto srdr = io::file_reader(path);\n     auto itr = @interner::mk[str](str::hash, str::eq);\n     auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u), itr);\n@@ -907,15 +698,14 @@ fn gather_comments_and_literals(session sess, str path)\n             break;\n         }\n         if (is_lit(next_token(rdr))) {\n-            vec::push[lit](literals, rec(lit=rdr.get_mark_str(),\n-                                         pos=rdr.get_mark_chpos()));\n+            vec::push[lit](literals,\n+                           rec(lit=rdr.get_mark_str(),\n+                               pos=rdr.get_mark_chpos()));\n         }\n         first_read = false;\n     }\n     ret rec(cmnts=comments, lits=literals);\n- }\n-\n-\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "72eda8ca309cf01b3171986a00b2f3a5cf8b85f1", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 557, "deletions": 830, "changes": 1387, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,11 +1,11 @@\n+\n import std::io;\n import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n import std::map::hashmap;\n-\n import driver::session;\n import util::common;\n import util::common::filename;\n@@ -15,170 +15,114 @@ import util::data::interner;\n import util::common::a_bang;\n import util::common::a_ty;\n \n-tag restriction {\n-    UNRESTRICTED;\n-    RESTRICT_NO_CALL_EXPRS;\n-}\n+tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; }\n \n-tag file_type {\n-    CRATE_FILE;\n-    SOURCE_FILE;\n-}\n+tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n type ty_or_bang = util::common::ty_or_bang[@ast::ty];\n \n-state type parser =\n-    state obj {\n-        fn peek() -> token::token;\n-        fn bump();\n-        fn err(str s) -> !;\n-        fn restrict(restriction r);\n-        fn get_restriction() -> restriction;\n-        fn get_file_type() -> file_type;\n-        fn get_env() -> eval::env;\n-        fn get_session() -> session::session;\n-        fn get_span() -> common::span;\n-        fn get_lo_pos() -> uint;\n-        fn get_hi_pos() -> uint;\n-        fn get_last_lo_pos() -> uint;\n-        fn next_def_id() -> ast::def_id;\n-        fn set_def(ast::def_num);\n-        fn get_prec_table() -> vec[op_spec];\n-        fn get_str(token::str_num) -> str;\n-        fn get_reader() -> lexer::reader;\n-        fn get_filemap() -> codemap::filemap;\n-        fn get_bad_expr_words() -> hashmap[str, ()];\n-        fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension];\n-        fn get_chpos() -> uint;\n-        fn get_ann() -> ast::ann;\n-        fn next_ann_num() -> uint;\n+type parser =\n+    obj {\n+        fn peek() -> token::token ;\n+        fn bump() ;\n+        fn err(str) -> !  ;\n+        fn restrict(restriction) ;\n+        fn get_restriction() -> restriction ;\n+        fn get_file_type() -> file_type ;\n+        fn get_env() -> eval::env ;\n+        fn get_session() -> session::session ;\n+        fn get_span() -> common::span ;\n+        fn get_lo_pos() -> uint ;\n+        fn get_hi_pos() -> uint ;\n+        fn get_last_lo_pos() -> uint ;\n+        fn next_def_id() -> ast::def_id ;\n+        fn set_def(ast::def_num) ;\n+        fn get_prec_table() -> vec[op_spec] ;\n+        fn get_str(token::str_num) -> str ;\n+        fn get_reader() -> lexer::reader ;\n+        fn get_filemap() -> codemap::filemap ;\n+        fn get_bad_expr_words() -> hashmap[str, ()] ;\n+        fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension] ;\n+        fn get_chpos() -> uint ;\n+        fn get_ann() -> ast::ann ;\n+        fn next_ann_num() -> uint ;\n     };\n \n-fn new_parser(session::session sess,\n+fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n+              str path, uint pos, uint next_ann) -> parser {\n+    obj stdio_parser(session::session sess,\n                      eval::env env,\n-                     ast::def_id initial_def,\n-                     str path, uint pos, uint next_ann) -> parser {\n-    state obj stdio_parser(session::session sess,\n-                           eval::env env,\n-                           file_type ftype,\n-                           mutable token::token tok,\n-                           mutable uint lo,\n-                           mutable uint hi,\n-                           mutable uint last_lo,\n-                           mutable ast::def_num def,\n-                           mutable restriction res,\n-                           ast::crate_num crate,\n-                           lexer::reader rdr,\n-                           vec[op_spec] precs,\n-                           mutable uint next_ann_var,\n-                           hashmap[str, ()] bad_words,\n-                           hashmap[str, ext::syntax_extension]\n-                               syntax_expanders)\n-        {\n-            fn peek() -> token::token {\n-                ret tok;\n-            }\n-\n-            fn bump() {\n-                // log rdr.get_filename()\n-                //   + \":\" + common::istr(lo.line as int);\n-                last_lo = lo;\n-                tok = lexer::next_token(rdr);\n-                lo = rdr.get_mark_chpos();\n-                hi = rdr.get_chpos();\n-            }\n-\n-            fn err(str m) -> ! {\n-                sess.span_err(rec(lo=lo, hi=hi), m);\n-            }\n-\n-            fn restrict(restriction r) {\n-                res = r;\n-            }\n-\n-            fn get_restriction() -> restriction {\n-                ret res;\n-            }\n-\n-            fn get_session() -> session::session {\n-                ret sess;\n-            }\n-\n-            fn get_span() -> common::span { ret rec(lo=lo, hi=hi); }\n-            fn get_lo_pos() -> uint { ret lo; }\n-            fn get_hi_pos() -> uint { ret hi; }\n-            fn get_last_lo_pos() -> uint { ret last_lo; }\n-\n-            fn next_def_id() -> ast::def_id {\n-                def += 1;\n-                ret tup(crate, def);\n-            }\n-\n-            fn set_def(ast::def_num d) {\n-                def = d;\n-            }\n-\n-            fn get_file_type() -> file_type {\n-                ret ftype;\n-            }\n-\n-            fn get_env() -> eval::env {\n-                ret env;\n-            }\n-\n-            fn get_prec_table() -> vec[op_spec] {\n-                ret precs;\n-            }\n-\n-            fn get_str(token::str_num i) -> str {\n-                ret interner::get(*rdr.get_interner(), i);\n-            }\n-\n-            fn get_reader() -> lexer::reader {\n-                ret rdr;\n-            }\n-\n-            fn get_filemap() -> codemap::filemap {\n-                ret rdr.get_filemap();\n-            }\n-\n-            fn get_bad_expr_words() -> hashmap[str, ()] {\n-                ret bad_words;\n-            }\n-\n-            fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension] {\n-                ret syntax_expanders;\n-            }\n-\n-            fn get_chpos() -> uint {ret rdr.get_chpos();}\n-\n-            fn get_ann() -> ast::ann {\n-                auto rv = rec(id=next_ann_var);\n-                next_ann_var += 1u;\n-                ret rv;\n-            }\n-            fn next_ann_num() -> uint {\n-                ret next_ann_var;\n-            }\n-        }\n-    auto ftype = SOURCE_FILE;\n-    if (str::ends_with(path, \".rc\")) {\n-        ftype = CRATE_FILE;\n+                     file_type ftype,\n+                     mutable token::token tok,\n+                     mutable uint lo,\n+                     mutable uint hi,\n+                     mutable uint last_lo,\n+                     mutable ast::def_num def,\n+                     mutable restriction res,\n+                     ast::crate_num crate,\n+                     lexer::reader rdr,\n+                     vec[op_spec] precs,\n+                     mutable uint next_ann_var,\n+                     hashmap[str, ()] bad_words,\n+                     hashmap[str, ext::syntax_extension] syntax_expanders) {\n+        fn peek() -> token::token { ret tok; }\n+        fn bump() {\n+            // log rdr.get_filename()\n+            //   + \":\" + common::istr(lo.line as int);\n+\n+            last_lo = lo;\n+            tok = lexer::next_token(rdr);\n+            lo = rdr.get_mark_chpos();\n+            hi = rdr.get_chpos();\n+        }\n+        fn err(str m) -> ! { sess.span_err(rec(lo=lo, hi=hi), m); }\n+        fn restrict(restriction r) { res = r; }\n+        fn get_restriction() -> restriction { ret res; }\n+        fn get_session() -> session::session { ret sess; }\n+        fn get_span() -> common::span { ret rec(lo=lo, hi=hi); }\n+        fn get_lo_pos() -> uint { ret lo; }\n+        fn get_hi_pos() -> uint { ret hi; }\n+        fn get_last_lo_pos() -> uint { ret last_lo; }\n+        fn next_def_id() -> ast::def_id { def += 1; ret tup(crate, def); }\n+        fn set_def(ast::def_num d) { def = d; }\n+        fn get_file_type() -> file_type { ret ftype; }\n+        fn get_env() -> eval::env { ret env; }\n+        fn get_prec_table() -> vec[op_spec] { ret precs; }\n+        fn get_str(token::str_num i) -> str {\n+            ret interner::get(*rdr.get_interner(), i);\n+        }\n+        fn get_reader() -> lexer::reader { ret rdr; }\n+        fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n+        fn get_bad_expr_words() -> hashmap[str, ()] { ret bad_words; }\n+        fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension] {\n+            ret syntax_expanders;\n+        }\n+        fn get_chpos() -> uint { ret rdr.get_chpos(); }\n+        fn get_ann() -> ast::ann {\n+            auto rv = rec(id=next_ann_var);\n+            next_ann_var += 1u;\n+            ret rv;\n+        }\n+        fn next_ann_num() -> uint { ret next_ann_var; }\n     }\n+    auto ftype = SOURCE_FILE;\n+    if (str::ends_with(path, \".rc\")) { ftype = CRATE_FILE; }\n     auto srdr = io::file_reader(path);\n     auto filemap = codemap::new_filemap(path, pos);\n     vec::push(sess.get_codemap().files, filemap);\n     auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess, srdr, filemap, itr);\n     // Make sure npos points at first actual token:\n+\n     lexer::consume_whitespace_and_comments(rdr);\n     auto npos = rdr.get_chpos();\n-    ret stdio_parser(sess, env, ftype, lexer::next_token(rdr),\n-                     npos, npos, npos, initial_def._1, UNRESTRICTED,\n-                     initial_def._0, rdr, prec_table(), next_ann,\n-                     bad_expr_word_table(), ext::syntax_expander_table());\n+    ret stdio_parser(sess, env, ftype, lexer::next_token(rdr), npos, npos,\n+                     npos, initial_def._1, UNRESTRICTED, initial_def._0, rdr,\n+                     prec_table(), next_ann, bad_expr_word_table(),\n+                     ext::syntax_expander_table());\n }\n \n+\n // These are the words that shouldn't be allowed as value identifiers,\n // because, if used at the start of a line, they will cause the line to be\n // interpreted as a specific kind of statement, which would be confusing.\n@@ -245,17 +189,16 @@ fn spanned[T](uint lo, uint hi, &T node) -> common::spanned[T] {\n fn parse_ident(&parser p) -> ast::ident {\n     alt (p.peek()) {\n         case (token::IDENT(?i, _)) { p.bump(); ret p.get_str(i); }\n-        case (_) {\n-            p.err(\"expecting ident\");\n-            fail;\n-        }\n+        case (_) { p.err(\"expecting ident\"); fail; }\n     }\n }\n+\n fn parse_value_ident(&parser p) -> ast::ident {\n     check_bad_word(p);\n     ret parse_ident(p);\n }\n \n+\n /* FIXME: gross hack copied from rustboot to make certain configuration-based\n  * decisions work at build-time.  We should probably change it to use a\n  * lexical sytnax-extension or something similar. For now we just imitate\n@@ -265,27 +208,26 @@ fn parse_str_lit_or_env_ident(&parser p) -> ast::ident {\n     alt (p.peek()) {\n         case (token::LIT_STR(?s)) { p.bump(); ret p.get_str(s); }\n         case (token::IDENT(?i, _)) {\n-            auto v = eval::lookup(p.get_session(), p.get_env(),\n-                                 p.get_span(), p.get_str(i));\n+            auto v =\n+                eval::lookup(p.get_session(), p.get_env(), p.get_span(),\n+                             p.get_str(i));\n             if (!eval::val_is_str(v)) {\n                 p.err(\"expecting string-valued variable\");\n             }\n             p.bump();\n             ret eval::val_as_str(v);\n         }\n-        case (_) {\n-            p.err(\"expecting string literal\");\n-            fail;\n-        }\n+        case (_) { p.err(\"expecting string literal\"); fail; }\n     }\n }\n \n fn is_word(&parser p, &str word) -> bool {\n     ret alt (p.peek()) {\n-        case (token::IDENT(?sid, false)) { str::eq(word, p.get_str(sid)) }\n-        case (_) { false }\n-    };\n+            case (token::IDENT(?sid, false)) { str::eq(word, p.get_str(sid)) }\n+            case (_) { false }\n+        };\n }\n+\n fn eat_word(&parser p, &str word) -> bool {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n@@ -297,12 +239,14 @@ fn eat_word(&parser p, &str word) -> bool {\n         case (_) { ret false; }\n     }\n }\n+\n fn expect_word(&parser p, &str word) {\n     if (!eat_word(p, word)) {\n         p.err(\"expecting \" + word + \", found \" +\n-              token::to_str(p.get_reader(), p.peek()));\n+                  token::to_str(p.get_reader(), p.peek()));\n     }\n }\n+\n fn check_bad_word(&parser p) {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n@@ -311,86 +255,78 @@ fn check_bad_word(&parser p) {\n                 p.err(\"found \" + w + \" in expression position\");\n             }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n }\n \n-fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n-    -> ast::ty_ {\n+fn parse_ty_fn(ast::proto proto, &parser p, uint lo) -> ast::ty_ {\n     fn parse_fn_input_ty(&parser p) -> ast::ty_arg {\n         auto lo = p.get_lo_pos();\n         auto mode = ast::val;\n         if (p.peek() == token::BINOP(token::AND)) {\n             p.bump();\n             mode = ast::alias(eat_word(p, \"mutable\"));\n         }\n-\n         auto t = parse_ty(p);\n-\n         alt (p.peek()) {\n-            case (token::IDENT(_, _)) { p.bump(); /* ignore param name */ }\n-            case (_) { /* no param name present */ }\n+            case (token::IDENT(_, _)) { p.bump();/* ignore param name */ }\n+            case (_) {/* no param name present */ }\n         }\n-\n         ret spanned(lo, t.span.hi, rec(mode=mode, ty=t));\n     }\n-\n     auto lo = p.get_lo_pos();\n-    auto inputs = parse_seq(token::LPAREN, token::RPAREN,\n-                            some(token::COMMA), parse_fn_input_ty, p);\n-\n+    auto inputs =\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                  parse_fn_input_ty, p);\n     auto constrs = parse_constrs([], p);\n-\n     let @ast::ty output;\n     auto cf = ast::return;\n     if (p.peek() == token::RARROW) {\n         p.bump();\n         auto tmp = parse_ty_or_bang(p);\n         alt (tmp) {\n-            case (a_ty(?t)) {\n-                output = t;\n-            }\n+            case (a_ty(?t)) { output = t; }\n             case (a_bang) {\n                 output = @spanned(lo, inputs.span.hi, ast::ty_bot);\n                 cf = ast::noreturn;\n             }\n         }\n-    } else {\n-        output = @spanned(lo, inputs.span.hi, ast::ty_nil);\n-    }\n-\n+    } else { output = @spanned(lo, inputs.span.hi, ast::ty_nil); }\n     ret ast::ty_fn(proto, inputs.node, output, cf, constrs.node);\n }\n \n fn parse_proto(&parser p) -> ast::proto {\n-    if      (eat_word(p, \"iter\")) { ret ast::proto_iter; }\n-    else if (eat_word(p, \"fn\"))   { ret ast::proto_fn; }\n-    else if (eat_word(p, \"pred\")) { ret ast::proto_fn; }\n-    else                          { unexpected(p, p.peek()); }\n+    if (eat_word(p, \"iter\")) {\n+        ret ast::proto_iter;\n+    } else if (eat_word(p, \"fn\")) {\n+        ret ast::proto_fn;\n+    } else if (eat_word(p, \"pred\")) {\n+        ret ast::proto_fn;\n+    } else { unexpected(p, p.peek()); }\n }\n \n fn parse_ty_obj(&parser p, &mutable uint hi) -> ast::ty_ {\n     fn parse_method_sig(&parser p) -> ast::ty_method {\n         auto flo = p.get_lo_pos();\n-\n         let ast::proto proto = parse_proto(p);\n         auto ident = parse_value_ident(p);\n         auto f = parse_ty_fn(proto, p, flo);\n         expect(p, token::SEMI);\n         alt (f) {\n             case (ast::ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n                 ret spanned(flo, output.span.hi,\n-                            rec(proto=proto, ident=ident,\n-                                inputs=inputs, output=output, cf=cf,\n+                            rec(proto=proto,\n+                                ident=ident,\n+                                inputs=inputs,\n+                                output=output,\n+                                cf=cf,\n                                 constrs=constrs));\n             }\n         }\n         fail;\n     }\n     auto f = parse_method_sig;\n-    auto meths = parse_seq(token::LBRACE,\n-                           token::RBRACE,\n-                           none, f, p);\n+    auto meths = parse_seq(token::LBRACE, token::RBRACE, none, f, p);\n     hi = meths.span.hi;\n     ret ast::ty_obj(meths.node);\n }\n@@ -408,18 +344,14 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n     ret spanned(lo, mt.ty.span.hi, rec(ident=id, mt=mt));\n }\n \n+\n // if i is the jth ident in args, return j\n // otherwise, fail\n fn ident_index(&parser p, &vec[ast::arg] args, &ast::ident i) -> uint {\n     auto j = 0u;\n-    for (ast::arg a in args) {\n-        if (a.ident == i) {\n-            ret j;\n-        }\n-        j += 1u;\n-    }\n+    for (ast::arg a in args) { if (a.ident == i) { ret j; } j += 1u; }\n     p.get_session().span_err(p.get_span(),\n-      \"Unbound variable \" + i + \" in constraint arg\");\n+                             \"Unbound variable \" + i + \" in constraint arg\");\n }\n \n fn parse_constr_arg(vec[ast::arg] args, &parser p) -> @ast::constr_arg {\n@@ -439,19 +371,19 @@ fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n     auto path = parse_path(p);\n     auto pf = bind parse_constr_arg(fn_args, _);\n     let rec(vec[@ast::constr_arg] node, span span) args =\n-         parse_seq(token::LPAREN,\n-                   token::RPAREN,\n-                   some(token::COMMA), pf, p);\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), pf, p);\n     // FIXME fix the def_id\n+\n     ret @spanned(lo, args.span.hi,\n                  rec(path=path, args=args.node, ann=p.get_ann()));\n }\n \n+\n // Use the args list to translate each bound variable \n // mentioned in a constraint to an arg index.\n // Seems weird to do this in the parser, but I'm not sure how else to.\n-fn parse_constrs(&vec[ast::arg] args, \n-                 &parser p) -> common::spanned[vec[@ast::constr]] {\n+fn parse_constrs(&vec[ast::arg] args, &parser p) ->\n+   common::spanned[vec[@ast::constr]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     let vec[@ast::constr] constrs = [];\n@@ -461,59 +393,72 @@ fn parse_constrs(&vec[ast::arg] args,\n             auto constr = parse_ty_constr(args, p);\n             hi = constr.span.hi;\n             vec::push(constrs, constr);\n-            if (p.peek() == token::COMMA) {\n-                p.bump();\n-            } else {\n-                break;\n-            }\n+            if (p.peek() == token::COMMA) { p.bump(); } else { break; }\n         }\n     }\n-   ret spanned(lo, hi, constrs);\n+    ret spanned(lo, hi, constrs);\n }\n \n fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n-   if (p.peek() == token::COLON) {\n-       auto constrs = parse_constrs([], p);\n-       ret @spanned(t.span.lo, constrs.span.hi,\n-                    ast::ty_constr(t, constrs.node));\n-   }\n-   ret t;\n+    if (p.peek() == token::COLON) {\n+        auto constrs = parse_constrs([], p);\n+        ret @spanned(t.span.lo, constrs.span.hi,\n+                     ast::ty_constr(t, constrs.node));\n+    }\n+    ret t;\n }\n \n fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n     alt (p.peek()) {\n         case (token::NOT) { p.bump(); ret a_bang[@ast::ty]; }\n-        case (_)         { ret a_ty(parse_ty(p)); }\n+        case (_) { ret a_ty(parse_ty(p)); }\n     }\n }\n \n fn parse_ty(&parser p) -> @ast::ty {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n     let ast::ty_ t;\n-\n     // FIXME: do something with this\n-    let ast::layer lyr = parse_layer(p);\n \n-    if      (eat_word(p, \"bool\")) { t = ast::ty_bool; }\n-    else if (eat_word(p, \"int\")) { t = ast::ty_int; }\n-    else if (eat_word(p, \"uint\")) { t = ast::ty_uint; }\n-    else if (eat_word(p, \"float\")) { t = ast::ty_float; }\n-    else if (eat_word(p, \"str\")) { t = ast::ty_str; }\n-    else if (eat_word(p, \"istr\")) { t = ast::ty_istr; }\n-    else if (eat_word(p, \"char\")) { t = ast::ty_char; }\n-    else if (eat_word(p, \"task\")) { t = ast::ty_task; }\n-    else if (eat_word(p, \"i8\")) { t = ast::ty_machine(common::ty_i8); }\n-    else if (eat_word(p, \"i16\")) { t = ast::ty_machine(common::ty_i16); }\n-    else if (eat_word(p, \"i32\")) { t = ast::ty_machine(common::ty_i32); }\n-    else if (eat_word(p, \"i64\")) { t = ast::ty_machine(common::ty_i64); }\n-    else if (eat_word(p, \"u8\")) { t = ast::ty_machine(common::ty_u8); }\n-    else if (eat_word(p, \"u16\")) { t = ast::ty_machine(common::ty_u16); }\n-    else if (eat_word(p, \"u32\")) { t = ast::ty_machine(common::ty_u32); }\n-    else if (eat_word(p, \"u64\")) { t = ast::ty_machine(common::ty_u64); }\n-    else if (eat_word(p, \"f32\")) { t = ast::ty_machine(common::ty_f32); }\n-    else if (eat_word(p, \"f64\")) { t = ast::ty_machine(common::ty_f64); }\n-    else if (p.peek() == token::LPAREN) {\n+    let ast::layer lyr = parse_layer(p);\n+    if (eat_word(p, \"bool\")) {\n+        t = ast::ty_bool;\n+    } else if (eat_word(p, \"int\")) {\n+        t = ast::ty_int;\n+    } else if (eat_word(p, \"uint\")) {\n+        t = ast::ty_uint;\n+    } else if (eat_word(p, \"float\")) {\n+        t = ast::ty_float;\n+    } else if (eat_word(p, \"str\")) {\n+        t = ast::ty_str;\n+    } else if (eat_word(p, \"istr\")) {\n+        t = ast::ty_istr;\n+    } else if (eat_word(p, \"char\")) {\n+        t = ast::ty_char;\n+    } else if (eat_word(p, \"task\")) {\n+        t = ast::ty_task;\n+    } else if (eat_word(p, \"i8\")) {\n+        t = ast::ty_machine(common::ty_i8);\n+    } else if (eat_word(p, \"i16\")) {\n+        t = ast::ty_machine(common::ty_i16);\n+    } else if (eat_word(p, \"i32\")) {\n+        t = ast::ty_machine(common::ty_i32);\n+    } else if (eat_word(p, \"i64\")) {\n+        t = ast::ty_machine(common::ty_i64);\n+    } else if (eat_word(p, \"u8\")) {\n+        t = ast::ty_machine(common::ty_u8);\n+    } else if (eat_word(p, \"u16\")) {\n+        t = ast::ty_machine(common::ty_u16);\n+    } else if (eat_word(p, \"u32\")) {\n+        t = ast::ty_machine(common::ty_u32);\n+    } else if (eat_word(p, \"u64\")) {\n+        t = ast::ty_machine(common::ty_u64);\n+    } else if (eat_word(p, \"f32\")) {\n+        t = ast::ty_machine(common::ty_f32);\n+    } else if (eat_word(p, \"f64\")) {\n+        t = ast::ty_machine(common::ty_f64);\n+    } else if (p.peek() == token::LPAREN) {\n         p.bump();\n         alt (p.peek()) {\n             case (token::RPAREN) {\n@@ -543,32 +488,25 @@ fn parse_ty(&parser p) -> @ast::ty {\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"tup\")) {\n-        auto elems = parse_seq(token::LPAREN, token::RPAREN,\n-                               some(token::COMMA), parse_mt, p);\n+        auto elems =\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_mt, p);\n         hi = elems.span.hi;\n         t = ast::ty_tup(elems.node);\n     } else if (eat_word(p, \"rec\")) {\n         auto elems =\n-            parse_seq(token::LPAREN, token::RPAREN,\n-                      some(token::COMMA), parse_ty_field, p);\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_ty_field, p);\n         hi = elems.span.hi;\n         t = ast::ty_rec(elems.node);\n     } else if (eat_word(p, \"fn\")) {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_fn, p, flo);\n-        alt (t) {\n-            case (ast::ty_fn(_, _, ?out, _, _)) {\n-                hi = out.span.hi;\n-            }\n-        }\n+        alt (t) { case (ast::ty_fn(_, _, ?out, _, _)) { hi = out.span.hi; } }\n     } else if (eat_word(p, \"iter\")) {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_iter, p, flo);\n-        alt (t) {\n-            case (ast::ty_fn(_, _, ?out, _, _)) {\n-                hi = out.span.hi;\n-            }\n-        }\n+        alt (t) { case (ast::ty_fn(_, _, ?out, _, _)) { hi = out.span.hi; } }\n     } else if (eat_word(p, \"obj\")) {\n         t = parse_ty_obj(p, hi);\n     } else if (eat_word(p, \"port\")) {\n@@ -588,20 +526,16 @@ fn parse_ty(&parser p) -> @ast::ty {\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"mutable\")) {\n         p.get_session().span_warn(p.get_span(),\n-            \"ignoring deprecated 'mutable' type constructor\");\n+                                  \"ignoring deprecated 'mutable'\"\n+                                  + \" type constructor\");\n         auto typ = parse_ty(p);\n         t = typ.node;\n         hi = typ.span.hi;\n     } else if (is_ident(p.peek())) {\n         auto path = parse_path(p);\n         t = ast::ty_path(path, p.get_ann());\n         hi = path.span.hi;\n-    } else {\n-        p.err(\"expecting type\");\n-        t = ast::ty_nil;\n-        fail;\n-    }\n-\n+    } else { p.err(\"expecting type\"); t = ast::ty_nil; fail; }\n     ret parse_ty_constrs(@spanned(lo, hi, t), p);\n }\n \n@@ -616,35 +550,26 @@ fn parse_arg(&parser p) -> ast::arg {\n     ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n-fn parse_seq_to_end[T](token::token ket,\n-                       option::t[token::token] sep,\n-                       (fn(&parser) -> T) f,\n-                       &parser p) -> vec[T] {\n+fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n+                       fn(&parser) -> T  f, &parser p) -> vec[T] {\n     let bool first = true;\n     let vec[T] v = [];\n     while (p.peek() != ket) {\n-        alt(sep) {\n+        alt (sep) {\n             case (some(?t)) {\n-                if (first) {\n-                    first = false;\n-                } else {\n-                    expect(p, t);\n-                }\n-            }\n-            case (_) {\n+                if (first) { first = false; } else { expect(p, t); }\n             }\n+            case (_) { }\n         }\n         v += [f(p)];\n     }\n     expect(p, ket);\n     ret v;\n }\n \n-fn parse_seq[T](token::token bra,\n-                token::token ket,\n-                option::t[token::token] sep,\n-                (fn(&parser) -> T) f,\n-                &parser p) -> util::common::spanned[vec[T]] {\n+fn parse_seq[T](token::token bra, token::token ket,\n+                option::t[token::token] sep, fn(&parser) -> T  f, &parser p)\n+   -> util::common::spanned[vec[T]] {\n     auto lo = p.get_lo_pos();\n     expect(p, bra);\n     auto result = parse_seq_to_end[T](ket, sep, f, p);\n@@ -661,14 +586,8 @@ fn parse_lit(&parser p) -> ast::lit {\n         lit = ast::lit_bool(false);\n     } else {\n         alt (p.peek()) {\n-            case (token::LIT_INT(?i)) {\n-                p.bump();\n-                lit = ast::lit_int(i);\n-            }\n-            case (token::LIT_UINT(?u)) {\n-                p.bump();\n-                lit = ast::lit_uint(u);\n-            }\n+            case (token::LIT_INT(?i)) { p.bump(); lit = ast::lit_int(i); }\n+            case (token::LIT_UINT(?u)) { p.bump(); lit = ast::lit_uint(u); }\n             case (token::LIT_FLOAT(?s)) {\n                 p.bump();\n                 lit = ast::lit_float(p.get_str(s));\n@@ -681,72 +600,54 @@ fn parse_lit(&parser p) -> ast::lit {\n                 p.bump();\n                 lit = ast::lit_mach_float(tm, p.get_str(s));\n             }\n-            case (token::LIT_CHAR(?c)) {\n-                p.bump();\n-                lit = ast::lit_char(c);\n-            }\n+            case (token::LIT_CHAR(?c)) { p.bump(); lit = ast::lit_char(c); }\n             case (token::LIT_STR(?s)) {\n                 p.bump();\n                 lit = ast::lit_str(p.get_str(s), ast::sk_rc);\n             }\n-            case (?t) {\n-                unexpected(p, t);\n-            }\n+            case (?t) { unexpected(p, t); }\n         }\n     }\n     ret rec(node=lit, span=sp);\n }\n \n fn is_ident(token::token t) -> bool {\n-    alt (t) {\n-        case (token::IDENT(_, _)) { ret true; }\n-        case (_) {}\n-    }\n+    alt (t) { case (token::IDENT(_, _)) { ret true; } case (_) { } }\n     ret false;\n }\n \n-fn parse_ty_args(&parser p, uint hi) ->\n-    util::common::spanned[vec[@ast::ty]] {\n-\n+fn parse_ty_args(&parser p, uint hi) -> util::common::spanned[vec[@ast::ty]] {\n     if (p.peek() == token::LBRACKET) {\n-        ret parse_seq(token::LBRACKET, token::RBRACKET,\n-                      some(token::COMMA), parse_ty, p);\n+        ret parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n+                      parse_ty, p);\n     }\n     let vec[@ast::ty] v = [];\n     auto pos = p.get_lo_pos();\n     ret spanned(hi, hi, v);\n }\n \n fn parse_path(&parser p) -> ast::path {\n-\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n-\n     let vec[ast::ident] ids = [];\n     while (true) {\n         alt (p.peek()) {\n             case (token::IDENT(?i, _)) {\n                 hi = p.get_hi_pos();\n                 ids += [p.get_str(i)];\n                 p.bump();\n-                if (p.peek() == token::MOD_SEP) {\n-                    p.bump();\n-                } else { break; }\n+                if (p.peek() == token::MOD_SEP) { p.bump(); } else { break; }\n             }\n             case (_) { break; }\n         }\n     }\n-\n     auto tys = parse_ty_args(p, hi);\n     ret spanned(lo, tys.span.hi, rec(idents=ids, types=tys.node));\n }\n \n fn parse_mutability(&parser p) -> ast::mutability {\n     if (eat_word(p, \"mutable\")) {\n-        if (p.peek() == token::QUES) {\n-            p.bump();\n-            ret ast::maybe_mut;\n-        }\n+        if (p.peek() == token::QUES) { p.bump(); ret ast::maybe_mut; }\n         ret ast::mut;\n     }\n     ret ast::imm;\n@@ -762,33 +663,29 @@ fn parse_field(&parser p) -> ast::field {\n }\n \n fn parse_bottom_expr(&parser p) -> @ast::expr {\n-\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n-\n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n+\n     auto lit = @spanned(lo, hi, ast::lit_nil);\n     let ast::expr_ ex = ast::expr_lit(lit, p.get_ann());\n-\n     if (p.peek() == token::LPAREN) {\n         p.bump();\n         alt (p.peek()) {\n             case (token::RPAREN) {\n                 hi = p.get_hi_pos();\n                 p.bump();\n                 auto lit = @spanned(lo, hi, ast::lit_nil);\n-                ret @spanned(lo, hi,\n-                             ast::expr_lit(lit, p.get_ann()));\n+                ret @spanned(lo, hi, ast::expr_lit(lit, p.get_ann()));\n             }\n-            case (_) { /* fall through */ }\n+            case (_) {/* fall through */ }\n         }\n         auto e = parse_expr(p);\n         hi = p.get_hi_pos();\n         expect(p, token::RPAREN);\n         ret @spanned(lo, hi, e.node);\n-\n-    } else if  (p.peek() == token::LBRACE) {\n+    } else if (p.peek() == token::LBRACE) {\n         auto blk = parse_block(p);\n         ret @spanned(blk.span.lo, blk.span.hi,\n                      ast::expr_block(blk, p.get_ann()));\n@@ -812,88 +709,81 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             auto e = parse_expr(p);\n             ret rec(mut=m, expr=e);\n         }\n-        auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                            some(token::COMMA), parse_elt, p);\n+        auto es =\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_elt, p);\n         hi = es.span.hi;\n         ex = ast::expr_tup(es.node, p.get_ann());\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n-        auto es = parse_seq_to_end(token::RBRACKET,\n-                                   some(token::COMMA),\n-                                   parse_expr, p);\n+        auto es =\n+            parse_seq_to_end(token::RBRACKET, some(token::COMMA), parse_expr,\n+                             p);\n         ex = ast::expr_vec(es, mut, ast::sk_rc, p.get_ann());\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n         alt (p.peek()) {\n-            case (token::LBRACKET) {    // unique array (temporary)\n+            case (token::LBRACKET) { // unique array (temporary)\n+\n                 p.bump();\n                 auto mut = parse_mutability(p);\n-                auto es = parse_seq_to_end(token::RBRACKET,\n-                                           some(token::COMMA), parse_expr, p);\n+                auto es =\n+                    parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n+                                     parse_expr, p);\n                 ex = ast::expr_vec(es, mut, ast::sk_unique, p.get_ann());\n             }\n             case (token::LIT_STR(?s)) {\n                 p.bump();\n-                auto lit = @rec(\n-                    node=ast::lit_str(p.get_str(s), ast::sk_unique),\n-                    span=p.get_span()\n-                );\n+                auto lit =\n+                    @rec(node=ast::lit_str(p.get_str(s), ast::sk_unique),\n+                         span=p.get_span());\n                 ex = ast::expr_lit(lit, p.get_ann());\n             }\n             case (_) {\n                 p.get_session().span_unimpl(p.get_span(),\n-                    \"unique pointer creation\");\n+                                            \"unique pointer creation\");\n             }\n         }\n     } else if (eat_word(p, \"obj\")) {\n         // Anonymous object\n \n         // FIXME: Can anonymous objects have ty params?\n-        auto ty_params = parse_ty_params(p);\n \n+        auto ty_params = parse_ty_params(p);\n         // Only make people type () if they're actually adding new fields\n+\n         let option::t[vec[ast::obj_field]] fields = none;\n         if (p.peek() == token::LPAREN) {\n             p.bump();\n-            fields = some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n-                                           parse_obj_field, p));\n+            fields =\n+                some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n+                                      parse_obj_field, p));\n         }\n-\n         let vec[@ast::method] meths = [];\n         let option::t[@ast::expr] with_obj = none;\n-\n         expect(p, token::LBRACE);\n-\n         while (p.peek() != token::RBRACE) {\n             if (eat_word(p, \"with\")) {\n                 with_obj = some(parse_expr(p));\n-            } else {\n-                vec::push(meths, parse_method(p));\n-            }\n+            } else { vec::push(meths, parse_method(p)); }\n         }\n-\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n-\n         // fields and methods may be *additional* or *overriding* fields\n         // and methods if there's a with_obj, or they may be the *only*\n         // fields and methods if there's no with_obj.\n \n         // We don't need to pull \".node\" out of fields because it's not a\n         // \"spanned\".\n-        let ast::anon_obj ob = rec(fields=fields,\n-                                   methods=meths,\n-                                   with_obj=with_obj);\n \n+        let ast::anon_obj ob =\n+            rec(fields=fields, methods=meths, with_obj=with_obj);\n         auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n-\n         ex = ast::expr_anon_obj(ob, ty_params, odid, p.get_ann());\n-\n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n         auto fields = [parse_field(p)];\n-\n         auto more = true;\n         auto base = none;\n         while (more) {\n@@ -909,48 +799,36 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             } else if (p.peek() == token::COMMA) {\n                 p.bump();\n                 fields += [parse_field(p)];\n-            } else {\n-                unexpected(p, p.peek());\n-            }\n+            } else { unexpected(p, p.peek()); }\n         }\n-\n         ex = ast::expr_rec(fields, base, p.get_ann());\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(&parser p) -> option::t[@ast::expr] {\n             alt (p.peek()) {\n-                case (token::UNDERSCORE) {\n-                    p.bump();\n-                    ret none;\n-                }\n-                case (_) {\n-                    ret some(parse_expr(p));\n-                }\n+                case (token::UNDERSCORE) { p.bump(); ret none; }\n+                case (_) { ret some(parse_expr(p)); }\n             }\n         }\n-\n-        auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                            some(token::COMMA), parse_expr_opt, p);\n+        auto es =\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_expr_opt, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node, p.get_ann());\n     } else if (p.peek() == token::POUND) {\n         p.bump();\n         auto pth = parse_path(p);\n-        auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                            some(token::COMMA), parse_expr, p);\n+        auto es =\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_expr, p);\n         hi = es.span.hi;\n         auto ext_span = rec(lo=lo, hi=hi);\n         ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n     } else if (eat_word(p, \"fail\")) {\n         auto msg;\n         alt (p.peek()) {\n-           case (token::LIT_STR(?s)) {\n-               msg = some(p.get_str(s));\n-               p.bump();\n-           }\n-           case (_) {\n-               msg = none;\n-           }\n+            case (token::LIT_STR(?s)) { msg = some(p.get_str(s)); p.bump(); }\n+            case (_) { msg = none; }\n         }\n         ex = ast::expr_fail(p.get_ann(), msg);\n     } else if (eat_word(p, \"log\")) {\n@@ -969,14 +847,13 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         /* Should be a predicate (pure boolean function) applied to \n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n+\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n         ex = ast::expr_check(e, p.get_ann());\n     } else if (eat_word(p, \"ret\")) {\n         alt (p.peek()) {\n-            case (token::SEMI) {\n-                ex = ast::expr_ret(none, p.get_ann());\n-            }\n+            case (token::SEMI) { ex = ast::expr_ret(none, p.get_ann()); }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n@@ -989,9 +866,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_cont(p.get_ann());\n     } else if (eat_word(p, \"put\")) {\n         alt (p.peek()) {\n-            case (token::SEMI) {\n-                ex = ast::expr_put(none, p.get_ann());\n-            }\n+            case (token::SEMI) { ex = ast::expr_put(none, p.get_ann()); }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n@@ -1000,14 +875,12 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         }\n     } else if (eat_word(p, \"be\")) {\n         auto e = parse_expr(p);\n+\n         // FIXME: Is this the right place for this check?\n-        if /*check*/ (ast::is_call_expr(e)) {\n+        if (/*check*/ast::is_call_expr(e)) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e, p.get_ann());\n-        }\n-        else {\n-            p.err(\"Non-call expression in tail call\");\n-        }\n+        } else { p.err(\"Non-call expression in tail call\"); }\n     } else if (eat_word(p, \"port\")) {\n         expect(p, token::LPAREN);\n         expect(p, token::RPAREN);\n@@ -1021,16 +894,17 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_chan(e, p.get_ann());\n     } else if (eat_word(p, \"self\")) {\n         log \"parsing a self-call...\";\n-\n         expect(p, token::DOT);\n         // The rest is a call expression.\n+\n         let @ast::expr f = parse_self_method(p);\n-        auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                            some(token::COMMA), parse_expr, p);\n+        auto es =\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node, p.get_ann());\n     } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n-               !is_word(p, \"false\")) {\n+                   !is_word(p, \"false\")) {\n         check_bad_word(p);\n         auto pth = parse_path(p);\n         hi = pth.span.hi;\n@@ -1040,32 +914,26 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         hi = lit.span.hi;\n         ex = ast::expr_lit(@lit, p.get_ann());\n     }\n-\n     ret @spanned(lo, hi, ex);\n }\n \n+\n /*\n  * FIXME: This is a crude approximation of the syntax-extension system,\n  * for purposes of prototyping and/or hard-wiring any extensions we\n  * wish to use while bootstrapping. The eventual aim is to permit\n  * loading rust crates to process extensions.\n  */\n-\n-fn expand_syntax_ext(&parser p, common::span sp,\n-                     &ast::path path, vec[@ast::expr] args,\n-                     option::t[str] body) -> ast::expr_ {\n-\n+fn expand_syntax_ext(&parser p, common::span sp, &ast::path path,\n+                     vec[@ast::expr] args, option::t[str] body) ->\n+   ast::expr_ {\n     assert (vec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n-\n     alt (p.get_syntax_expanders().find(extname)) {\n-        case (none) {\n-            p.err(\"unknown syntax expander: '\" + extname + \"'\");\n-        }\n+        case (none) { p.err(\"unknown syntax expander: '\" + extname + \"'\"); }\n         case (some(ext::x(?ext))) {\n             auto ext_cx = ext::mk_ctxt(p);\n-            ret ast::expr_ext(path, args, body,\n-                              ext(ext_cx, sp, args, body), \n+            ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body),\n                               p.get_ann());\n         }\n     }\n@@ -1087,32 +955,30 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n     auto hi = e.span.hi;\n     while (true) {\n         alt (p.peek()) {\n-\n             case (token::LPAREN) {\n                 if (p.get_restriction() == RESTRICT_NO_CALL_EXPRS) {\n                     ret e;\n                 } else {\n                     // Call expr.\n-                    auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                                        some(token::COMMA), parse_expr, p);\n+\n+                    auto es =\n+                        parse_seq(token::LPAREN, token::RPAREN,\n+                                  some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n                     auto e_ = ast::expr_call(e, es.node, p.get_ann());\n                     e = @spanned(lo, hi, e_);\n                 }\n             }\n-\n             case (token::DOT) {\n                 p.bump();\n                 alt (p.peek()) {\n-\n                     case (token::IDENT(?i, _)) {\n                         hi = p.get_hi_pos();\n                         p.bump();\n-                        auto e_ = ast::expr_field(e, p.get_str(i),\n-                                                 p.get_ann());\n+                        auto e_ =\n+                            ast::expr_field(e, p.get_str(i), p.get_ann());\n                         e = @spanned(lo, hi, e_);\n                     }\n-\n                     case (token::LPAREN) {\n                         p.bump();\n                         auto ix = parse_expr(p);\n@@ -1121,44 +987,35 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                         auto e_ = ast::expr_index(e, ix, p.get_ann());\n                         e = @spanned(lo, hi, e_);\n                     }\n-\n-                    case (?t) {\n-                        unexpected(p, t);\n-                    }\n+                    case (?t) { unexpected(p, t); }\n                 }\n             }\n-            case (_) {\n-                ret e;\n-            }\n+            case (_) { ret e; }\n         }\n     }\n     ret e;\n }\n \n fn parse_prefix_expr(&parser p) -> @ast::expr {\n-\n     if (eat_word(p, \"mutable\")) {\n         p.get_session().span_warn(p.get_span(),\n-            \"ignoring deprecated 'mutable' prefix operator\");\n+                                  \"ignoring deprecated 'mutable'\"\n+                                  + \" prefix operator\");\n     }\n-\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n-\n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n+\n     auto lit = @spanned(lo, lo, ast::lit_nil);\n     let ast::expr_ ex = ast::expr_lit(lit, p.get_ann());\n-\n     alt (p.peek()) {\n-\n         case (token::NOT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_unary(ast::not, e, p.get_ann());\n         }\n-\n         case (token::BINOP(?b)) {\n             alt (b) {\n                 case (token::MINUS) {\n@@ -1167,78 +1024,69 @@ fn parse_prefix_expr(&parser p) -> @ast::expr {\n                     hi = e.span.hi;\n                     ex = ast::expr_unary(ast::neg, e, p.get_ann());\n                 }\n-\n                 case (token::STAR) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span.hi;\n                     ex = ast::expr_unary(ast::deref, e, p.get_ann());\n                 }\n-\n-                case (_) {\n-                    ret parse_dot_or_call_expr(p);\n-                }\n+                case (_) { ret parse_dot_or_call_expr(p); }\n             }\n         }\n-\n         case (token::AT) {\n             p.bump();\n             auto m = parse_mutability(p);\n             auto e = parse_prefix_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_unary(ast::box(m), e, p.get_ann());\n         }\n-\n-        case (_) {\n-            ret parse_dot_or_call_expr(p);\n-        }\n+        case (_) { ret parse_dot_or_call_expr(p); }\n     }\n     ret @spanned(lo, hi, ex);\n }\n \n type op_spec = rec(token::token tok, ast::binop op, int prec);\n \n+\n // FIXME make this a const, don't store it in parser state\n fn prec_table() -> vec[op_spec] {\n     ret [rec(tok=token::BINOP(token::STAR), op=ast::mul, prec=11),\n-            rec(tok=token::BINOP(token::SLASH), op=ast::div, prec=11),\n-            rec(tok=token::BINOP(token::PERCENT), op=ast::rem, prec=11),\n-            rec(tok=token::BINOP(token::PLUS), op=ast::add, prec=10),\n-            rec(tok=token::BINOP(token::MINUS), op=ast::sub, prec=10),\n-            rec(tok=token::BINOP(token::LSL), op=ast::lsl, prec=9),\n-            rec(tok=token::BINOP(token::LSR), op=ast::lsr, prec=9),\n-            rec(tok=token::BINOP(token::ASR), op=ast::asr, prec=9),\n-            rec(tok=token::BINOP(token::AND), op=ast::bitand, prec=8),\n-            rec(tok=token::BINOP(token::CARET), op=ast::bitxor, prec=6),\n-            rec(tok=token::BINOP(token::OR), op=ast::bitor, prec=6),\n-            // 'as' sits between here with 5\n-            rec(tok=token::LT, op=ast::lt, prec=4),\n-            rec(tok=token::LE, op=ast::le, prec=4),\n-            rec(tok=token::GE, op=ast::ge, prec=4),\n-            rec(tok=token::GT, op=ast::gt, prec=4),\n-            rec(tok=token::EQEQ, op=ast::eq, prec=3),\n-            rec(tok=token::NE, op=ast::ne, prec=3),\n-            rec(tok=token::ANDAND, op=ast::and, prec=2),\n-            rec(tok=token::OROR, op=ast::or, prec=1)];\n+         rec(tok=token::BINOP(token::SLASH), op=ast::div, prec=11),\n+         rec(tok=token::BINOP(token::PERCENT), op=ast::rem, prec=11),\n+         rec(tok=token::BINOP(token::PLUS), op=ast::add, prec=10),\n+         rec(tok=token::BINOP(token::MINUS), op=ast::sub, prec=10),\n+         rec(tok=token::BINOP(token::LSL), op=ast::lsl, prec=9),\n+         rec(tok=token::BINOP(token::LSR), op=ast::lsr, prec=9),\n+         rec(tok=token::BINOP(token::ASR), op=ast::asr, prec=9),\n+         rec(tok=token::BINOP(token::AND), op=ast::bitand, prec=8),\n+         rec(tok=token::BINOP(token::CARET), op=ast::bitxor, prec=6),\n+         rec(tok=token::BINOP(token::OR), op=ast::bitor, prec=6),\n+         // 'as' sits between here with 5\n+         rec(tok=token::LT, op=ast::lt, prec=4),\n+         rec(tok=token::LE, op=ast::le, prec=4),\n+         rec(tok=token::GE, op=ast::ge, prec=4),\n+         rec(tok=token::GT, op=ast::gt, prec=4),\n+         rec(tok=token::EQEQ, op=ast::eq, prec=3),\n+         rec(tok=token::NE, op=ast::ne, prec=3),\n+         rec(tok=token::ANDAND, op=ast::and, prec=2),\n+         rec(tok=token::OROR, op=ast::or, prec=1)];\n }\n \n fn parse_binops(&parser p) -> @ast::expr {\n     ret parse_more_binops(p, parse_prefix_expr(p), 0);\n }\n \n const int unop_prec = 100;\n+\n const int as_prec = 5;\n \n-fn parse_more_binops(&parser p, @ast::expr lhs, int min_prec)\n-    -> @ast::expr {\n+fn parse_more_binops(&parser p, @ast::expr lhs, int min_prec) -> @ast::expr {\n     auto peeked = p.peek();\n     for (op_spec cur in p.get_prec_table()) {\n         if (cur.prec > min_prec && cur.tok == peeked) {\n             p.bump();\n-            auto rhs = parse_more_binops(p, parse_prefix_expr(p),\n-                                         cur.prec);\n-            auto bin = ast::expr_binary(cur.op, lhs, rhs,\n-                                        p.get_ann());\n+            auto rhs = parse_more_binops(p, parse_prefix_expr(p), cur.prec);\n+            auto bin = ast::expr_binary(cur.op, lhs, rhs, p.get_ann());\n             auto span = @spanned(lhs.span.lo, rhs.span.hi, bin);\n             ret parse_more_binops(p, span, min_prec);\n         }\n@@ -1300,14 +1148,13 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n             ret @spanned(lo, rhs.span.hi,\n                          ast::expr_recv(rhs, lhs, p.get_ann()));\n         }\n-        case (_) { /* fall through */ }\n+        case (_) {/* fall through */ }\n     }\n     ret lhs;\n }\n \n fn parse_if_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n-\n     expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n@@ -1319,7 +1166,6 @@ fn parse_if_expr(&parser p) -> @ast::expr {\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n     }\n-\n     ret @spanned(lo, hi, ast::expr_if(cond, thn, els, p.get_ann()));\n }\n \n@@ -1343,40 +1189,31 @@ fn parse_else_expr(&parser p) -> @ast::expr {\n \n fn parse_head_local(&parser p) -> @ast::local {\n     auto lo = p.get_lo_pos();\n-    let @ast::local_ l = if (is_word(p, \"auto\")) {\n-                           parse_auto_local(p)\n-                         } else {\n-                           parse_typed_local(p)\n-                         };\n+    let @ast::local_ l =\n+        if (is_word(p, \"auto\")) {\n+            parse_auto_local(p)\n+        } else { parse_typed_local(p) };\n     ret @spanned(lo, p.get_hi_pos(), l);\n }\n \n-\n-\n fn parse_for_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n-\n     auto is_each = eat_word(p, \"each\");\n-\n-    expect (p, token::LPAREN);\n-\n+    expect(p, token::LPAREN);\n     auto decl = parse_head_local(p);\n     expect_word(p, \"in\");\n-\n     auto seq = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto body = parse_block(p);\n     auto hi = body.span.hi;\n     if (is_each) {\n-        ret @spanned(lo, hi, ast::expr_for_each(decl, seq, body,\n-                                                p.get_ann()));\n+        ret @spanned(lo, hi,\n+                     ast::expr_for_each(decl, seq, body, p.get_ann()));\n     } else {\n-        ret @spanned(lo, hi, ast::expr_for(decl, seq, body,\n-                                          p.get_ann()));\n+        ret @spanned(lo, hi, ast::expr_for(decl, seq, body, p.get_ann()));\n     }\n }\n \n-\n fn parse_while_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n@@ -1391,7 +1228,7 @@ fn parse_do_while_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     auto body = parse_block(p);\n     expect_word(p, \"while\");\n-    expect (p, token::LPAREN);\n+    expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto hi = cond.span.hi;\n@@ -1404,7 +1241,6 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n     auto discriminant = parse_expr(p);\n     expect(p, token::RPAREN);\n     expect(p, token::LBRACE);\n-\n     let vec[ast::arm] arms = [];\n     while (p.peek() != token::RBRACE) {\n         if (eat_word(p, \"case\")) {\n@@ -1415,14 +1251,14 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n             arms += [rec(pat=pat, block=block)];\n         } else if (p.peek() == token::RBRACE) {\n             /* empty */\n+\n         } else {\n             p.err(\"expected 'case' or '}' when parsing 'alt' statement \" +\n-                  \"but found \" + token::to_str(p.get_reader(), p.peek()));\n+                      \"but found \" + token::to_str(p.get_reader(), p.peek()));\n         }\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n-\n     auto expr = ast::expr_alt(discriminant, arms, p.get_ann());\n     ret @spanned(lo, hi, expr);\n }\n@@ -1431,15 +1267,15 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     // FIXME: Parse domain and name\n     // FIXME: why no full expr?\n+\n     auto fn_expr = parse_bottom_expr(p);\n-    auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                        some(token::COMMA), parse_expr, p);\n+    auto es =\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                  parse_expr, p);\n     auto hi = es.span.hi;\n-    auto spawn_expr = ast::expr_spawn(ast::dom_implicit,\n-                                     option::none,\n-                                     fn_expr,\n-                                     es.node,\n-                                     p.get_ann());\n+    auto spawn_expr =\n+        ast::expr_spawn(ast::dom_implicit, option::none, fn_expr, es.node,\n+                        p.get_ann());\n     ret @spanned(lo, hi, spawn_expr);\n }\n \n@@ -1459,22 +1295,21 @@ fn parse_initializer(&parser p) -> option::t[ast::initializer] {\n     alt (p.peek()) {\n         case (token::EQ) {\n             p.bump();\n-            ret some(rec(op = ast::init_assign,\n-                         expr = parse_expr(p)));\n+            ret some(rec(op=ast::init_assign, expr=parse_expr(p)));\n         }\n         case (token::LARROW) {\n             p.bump();\n-            ret some(rec(op = ast::init_move,\n-                         expr = parse_expr(p)));\n-        }\n-        // Now that the the channel is the first argument to receive,\n-        // combining it with an initializer doesn't really make sense.\n-        // case (token::RECV) {\n-        //     p.bump();\n-        //     ret some(rec(op = ast::init_recv,\n-        //                  expr = parse_expr(p)));\n-        // }\n-        case (_) {\n+            ret some(rec(op=ast::init_move, expr=parse_expr(p)));\n+        }\n+        case (\n+             // Now that the the channel is the first argument to receive,\n+             // combining it with an initializer doesn't really make sense.\n+             // case (token::RECV) {\n+             //     p.bump();\n+             //     ret some(rec(op = ast::init_recv,\n+             //                  expr = parse_expr(p)));\n+             // }\n+             _) {\n             ret none;\n         }\n     }\n@@ -1484,7 +1319,6 @@ fn parse_pat(&parser p) -> @ast::pat {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     auto pat;\n-\n     alt (p.peek()) {\n         case (token::UNDERSCORE) {\n             p.bump();\n@@ -1496,12 +1330,13 @@ fn parse_pat(&parser p) -> @ast::pat {\n                 case (token::IDENT(?id, _)) {\n                     hi = p.get_hi_pos();\n                     p.bump();\n-                    pat = ast::pat_bind(p.get_str(id), p.next_def_id(),\n-                                       p.get_ann());\n+                    pat =\n+                        ast::pat_bind(p.get_str(id), p.next_def_id(),\n+                                      p.get_ann());\n                 }\n                 case (?tok) {\n                     p.err(\"expected identifier after '?' in pattern but \" +\n-                          \"found \" + token::to_str(p.get_reader(), tok));\n+                              \"found \" + token::to_str(p.get_reader(), tok));\n                     fail;\n                 }\n             }\n@@ -1514,38 +1349,34 @@ fn parse_pat(&parser p) -> @ast::pat {\n             } else {\n                 auto tag_path = parse_path(p);\n                 hi = tag_path.span.hi;\n-\n                 let vec[@ast::pat] args;\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n                         auto f = parse_pat;\n-                        auto a = parse_seq(token::LPAREN,\n-                                           token::RPAREN,\n-                                           some(token::COMMA), f, p);\n+                        auto a =\n+                            parse_seq(token::LPAREN, token::RPAREN,\n+                                      some(token::COMMA), f, p);\n                         args = a.node;\n                         hi = a.span.hi;\n                     }\n                     case (_) { args = []; }\n                 }\n-\n                 pat = ast::pat_tag(tag_path, args, p.get_ann());\n             }\n         }\n     }\n-\n     ret @spanned(lo, hi, pat);\n }\n \n-fn parse_local_full(&option::t[@ast::ty] tyopt,\n-                    &parser p) -> @ast::local_ {\n+fn parse_local_full(&option::t[@ast::ty] tyopt, &parser p) -> @ast::local_ {\n     auto ident = parse_value_ident(p);\n     auto init = parse_initializer(p);\n-    ret @rec(ty = tyopt,\n-             infer = false,\n-             ident = ident,\n-             init = init,\n-             id = p.next_def_id(),\n-             ann = p.get_ann());\n+    ret @rec(ty=tyopt,\n+             infer=false,\n+             ident=ident,\n+             init=init,\n+             id=p.next_def_id(),\n+             ann=p.get_ann());\n }\n \n fn parse_typed_local(&parser p) -> @ast::local_ {\n@@ -1572,9 +1403,7 @@ fn parse_auto(&parser p) -> @ast::decl {\n fn parse_stmt(&parser p) -> @ast::stmt {\n     if (p.get_file_type() == SOURCE_FILE) {\n         ret parse_source_stmt(p);\n-    } else {\n-        ret parse_crate_stmt(p);\n-    }\n+    } else { ret parse_crate_stmt(p); }\n }\n \n fn parse_crate_stmt(&parser p) -> @ast::stmt {\n@@ -1588,8 +1417,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n     if (eat_word(p, \"let\")) {\n         auto decl = parse_let(p);\n         auto hi = p.get_span();\n-        ret @spanned\n-            (lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n+        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n     } else if (eat_word(p, \"auto\")) {\n         auto decl = parse_auto(p);\n         auto hi = p.get_span();\n@@ -1602,12 +1430,14 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n                 ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_ann()));\n             }\n             case (fn_no_item) { // parse_item will have already skipped \"fn\"\n+\n                 auto e = parse_fn_expr(p);\n                 e = parse_dot_or_call_expr_with(p, e);\n                 ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n             }\n             case (no_item) {\n                 // Remainder are line-expr stmts.\n+\n                 auto e = parse_expr(p);\n                 ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n             }\n@@ -1619,94 +1449,93 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n \n fn stmt_to_expr(@ast::stmt stmt) -> option::t[@ast::expr] {\n     ret alt (stmt.node) {\n-        case (ast::stmt_expr(?e,_)) { some(e) }\n-        case (_) { none }\n-    };\n+            case (ast::stmt_expr(?e, _)) { some(e) }\n+            case (_) { none }\n+        };\n }\n \n fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n     alt (stmt.node) {\n-        case (ast::stmt_decl(?d,_)) {\n+        case (ast::stmt_decl(?d, _)) {\n             alt (d.node) {\n                 case (ast::decl_local(_)) { ret true; }\n                 case (ast::decl_item(_)) { ret false; }\n             }\n         }\n-        case (ast::stmt_expr(?e,_)) {\n+        case (ast::stmt_expr(?e, _)) {\n             alt (e.node) {\n-                case (ast::expr_vec(_,_,_,_))    { ret true; }\n-                case (ast::expr_tup(_,_))        { ret true; }\n-                case (ast::expr_rec(_,_,_))      { ret true; }\n-                case (ast::expr_call(_,_,_))     { ret true; }\n-                case (ast::expr_self_method(_,_)){ ret false; }\n-                case (ast::expr_binary(_,_,_,_)) { ret true; }\n-                case (ast::expr_unary(_,_,_))    { ret true; }\n-                case (ast::expr_lit(_,_))        { ret true; }\n-                case (ast::expr_cast(_,_,_))     { ret true; }\n-                case (ast::expr_if(_,_,_,_))     { ret false; }\n-                case (ast::expr_for(_,_,_,_))    { ret false; }\n-                case (ast::expr_for_each(_,_,_,_))\n-                    { ret false; }\n-                case (ast::expr_while(_,_,_))    { ret false; }\n-                case (ast::expr_do_while(_,_,_)) { ret false; }\n-                case (ast::expr_alt(_,_,_))      { ret false; }\n-                case (ast::expr_fn(_,_))       { ret false; }\n-                case (ast::expr_block(_,_))      { ret false; }\n-                case (ast::expr_assign(_,_,_))   { ret true; }\n-                case (ast::expr_assign_op(_,_,_,_))\n-                    { ret true; }\n-                case (ast::expr_send(_,_,_))     { ret true; }\n-                case (ast::expr_recv(_,_,_))     { ret true; }\n-                case (ast::expr_field(_,_,_))    { ret true; }\n-                case (ast::expr_index(_,_,_))    { ret true; }\n-                case (ast::expr_path(_,_))       { ret true; }\n-                case (ast::expr_fail(_,_))       { ret true; }\n-                case (ast::expr_break(_))        { ret true; }\n-                case (ast::expr_cont(_))         { ret true; }\n-                case (ast::expr_ret(_,_))        { ret true; }\n-                case (ast::expr_put(_,_))        { ret true; }\n-                case (ast::expr_be(_,_))         { ret true; }\n-                case (ast::expr_log(_,_,_))        { ret true; }\n-                case (ast::expr_check(_,_)) { ret true; }\n-                case (ast::expr_assert(_,_)) { ret true; }\n-            }\n+                case (ast::expr_vec(_, _, _, _)) { ret true; }\n+                case (ast::expr_tup(_, _)) { ret true; }\n+                case (ast::expr_rec(_, _, _)) { ret true; }\n+                case (ast::expr_call(_, _, _)) { ret true; }\n+                case (ast::expr_self_method(_, _)) { ret false; }\n+                case (ast::expr_binary(_, _, _, _)) { ret true; }\n+                case (ast::expr_unary(_, _, _)) { ret true; }\n+                case (ast::expr_lit(_, _)) { ret true; }\n+                case (ast::expr_cast(_, _, _)) { ret true; }\n+                case (ast::expr_if(_, _, _, _)) { ret false; }\n+                case (ast::expr_for(_, _, _, _)) { ret false; }\n+                case (ast::expr_for_each(_, _, _, _)) { ret false; }\n+                case (ast::expr_while(_, _, _)) { ret false; }\n+                case (ast::expr_do_while(_, _, _)) { ret false; }\n+                case (ast::expr_alt(_, _, _)) { ret false; }\n+                case (ast::expr_fn(_, _)) { ret false; }\n+                case (ast::expr_block(_, _)) { ret false; }\n+                case (ast::expr_assign(_, _, _)) { ret true; }\n+                case (ast::expr_assign_op(_, _, _, _)) { ret true; }\n+                case (ast::expr_send(_, _, _)) { ret true; }\n+                case (ast::expr_recv(_, _, _)) { ret true; }\n+                case (ast::expr_field(_, _, _)) { ret true; }\n+                case (ast::expr_index(_, _, _)) { ret true; }\n+                case (ast::expr_path(_, _)) { ret true; }\n+                case (ast::expr_fail(_, _)) { ret true; }\n+                case (ast::expr_break(_)) { ret true; }\n+                case (ast::expr_cont(_)) { ret true; }\n+                case (ast::expr_ret(_, _)) { ret true; }\n+                case (ast::expr_put(_, _)) { ret true; }\n+                case (ast::expr_be(_, _)) { ret true; }\n+                case (ast::expr_log(_, _, _)) { ret true; }\n+                case (ast::expr_check(_, _)) { ret true; }\n+                case (ast::expr_assert(_, _)) { ret true; }\n+            }\n+        }\n+        case (\n+             // We should not be calling this on a cdir.\n+             ast::stmt_crate_directive(?cdir)) {\n+            fail;\n         }\n-        // We should not be calling this on a cdir.\n-        case (ast::stmt_crate_directive(?cdir))  { fail; }\n     }\n }\n \n fn parse_block(&parser p) -> ast::block {\n     auto lo = p.get_lo_pos();\n-\n     let vec[@ast::stmt] stmts = [];\n     let option::t[@ast::expr] expr = none;\n-\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n         alt (p.peek()) {\n             case (token::RBRACE) {\n                 // empty; fall through to next iteration\n+\n             }\n             case (token::SEMI) {\n                 p.bump();\n                 // empty\n+\n             }\n             case (_) {\n                 auto stmt = parse_stmt(p);\n                 alt (stmt_to_expr(stmt)) {\n                     case (some(?e)) {\n                         alt (p.peek()) {\n-                            case (token::SEMI) {\n-                                p.bump();\n-                                stmts += [stmt];\n-                            }\n+                            case (token::SEMI) { p.bump(); stmts += [stmt]; }\n                             case (token::RBRACE) { expr = some(e); }\n                             case (?t) {\n                                 if (stmt_ends_with_semi(*stmt)) {\n                                     p.err(\"expected ';' or '}' after \" +\n-                                          \"expression but found \" +\n-                                          token::to_str(p.get_reader(), t));\n+                                              \"expression but found \" +\n+                                              token::to_str(p.get_reader(),\n+                                                            t));\n                                     fail;\n                                 }\n                                 stmts += [stmt];\n@@ -1715,7 +1544,9 @@ fn parse_block(&parser p) -> ast::block {\n                     }\n                     case (none) {\n                         // Not an expression statement.\n+\n                         stmts += [stmt];\n+\n                         // FIXME: crazy differentiation between conditions\n                         // used in branches and binary expressions in rustboot\n                         // means we cannot use && here. I know, right?\n@@ -1729,85 +1560,78 @@ fn parse_block(&parser p) -> ast::block {\n             }\n         }\n     }\n-\n     auto hi = p.get_hi_pos();\n     p.bump();\n-\n     auto bloc = rec(stmts=stmts, expr=expr, a=p.get_ann());\n     ret spanned(lo, hi, bloc);\n }\n \n-fn parse_ty_param(&parser p) -> ast::ty_param {\n-    ret parse_ident(p);\n-}\n+fn parse_ty_param(&parser p) -> ast::ty_param { ret parse_ident(p); }\n \n fn parse_ty_params(&parser p) -> vec[ast::ty_param] {\n     let vec[ast::ty_param] ty_params = [];\n     if (p.peek() == token::LBRACKET) {\n-        ty_params = parse_seq(token::LBRACKET, token::RBRACKET,\n-                              some(token::COMMA), parse_ty_param, p).node;\n+        ty_params =\n+            parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n+                      parse_ty_param, p).node;\n     }\n     ret ty_params;\n }\n \n fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     auto pf = parse_arg;\n     let util::common::spanned[vec[ast::arg]] inputs =\n-        parse_seq(token::LPAREN, token::RPAREN,\n-                  some(token::COMMA), parse_arg, p);\n-\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n+                  p);\n     let ty_or_bang res;\n-\n     auto constrs = parse_constrs(inputs.node, p).node;\n-\n     if (p.peek() == token::RARROW) {\n         p.bump();\n         res = parse_ty_or_bang(p);\n     } else {\n-        res = a_ty(@spanned(inputs.span.lo, inputs.span.hi,\n-                            ast::ty_nil));\n+        res = a_ty(@spanned(inputs.span.lo, inputs.span.hi, ast::ty_nil));\n     }\n-\n     alt (res) {\n         case (a_ty(?t)) {\n-            ret rec(inputs=inputs.node, output=t,\n-                    purity=purity, cf=ast::return, constraints=constrs);\n+            ret rec(inputs=inputs.node,\n+                    output=t,\n+                    purity=purity,\n+                    cf=ast::return,\n+                    constraints=constrs);\n         }\n         case (a_bang) {\n             ret rec(inputs=inputs.node,\n-                    output=@spanned(p.get_lo_pos(),\n-                                    p.get_hi_pos(), ast::ty_bot),\n-                    purity=purity, cf=ast::noreturn, constraints=constrs);\n+                    output=@spanned(p.get_lo_pos(), p.get_hi_pos(),\n+                                    ast::ty_bot),\n+                    purity=purity,\n+                    cf=ast::noreturn,\n+                    constraints=constrs);\n         }\n     }\n }\n \n fn parse_fn(&parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n     auto decl = parse_fn_decl(p, purity);\n     auto body = parse_block(p);\n-    ret rec(decl = decl,\n-            proto = proto,\n-            body = body);\n+    ret rec(decl=decl, proto=proto, body=body);\n }\n \n-fn parse_fn_header(&parser p)\n-    -> tup(ast::ident, vec[ast::ty_param]) {\n+fn parse_fn_header(&parser p) -> tup(ast::ident, vec[ast::ty_param]) {\n     auto id = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     ret tup(id, ty_params);\n }\n \n fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto,\n-                         vec[ast::attribute] attrs ) -> @ast::item {\n+                         vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto f = parse_fn(p, proto, purity);\n-    auto item = ast::item_fn(t._0, f, t._1, attrs,\n-                            p.next_def_id(), p.get_ann());\n+    auto item =\n+        ast::item_fn(t._0, f, t._1, attrs, p.next_def_id(), p.get_ann());\n     ret @spanned(lo, f.body.span.hi, item);\n }\n \n-\n fn parse_obj_field(&parser p) -> ast::obj_field {\n     auto mut = parse_mutability(p);\n     auto ty = parse_ty(p);\n@@ -1820,8 +1644,7 @@ fn parse_method(&parser p) -> @ast::method {\n     auto proto = parse_proto(p);\n     auto ident = parse_value_ident(p);\n     auto f = parse_fn(p, proto, ast::impure_fn);\n-    auto meth = rec(ident=ident, meth=f,\n-                    id=p.next_def_id(), ann=p.get_ann());\n+    auto meth = rec(ident=ident, meth=f, id=p.next_def_id(), ann=p.get_ann());\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n@@ -1830,56 +1653,42 @@ fn parse_dtor(&parser p) -> @ast::method {\n     let ast::block b = parse_block(p);\n     let vec[ast::arg] inputs = [];\n     let @ast::ty output = @spanned(lo, lo, ast::ty_nil);\n-    let ast::fn_decl d = rec(inputs=inputs,\n-                             output=output,\n-                             purity=ast::impure_fn,\n-                             cf=ast::return,\n- // I guess dtors can't have constraints? \n-                             constraints=[]);\n-    let ast::_fn f = rec(decl = d,\n-                         proto = ast::proto_fn,\n-                         body = b);\n-    let ast::method_ m = rec(ident=\"drop\",\n-                            meth=f,\n-                            id=p.next_def_id(),\n-                            ann=p.get_ann());\n+    let ast::fn_decl d =\n+        rec(inputs=inputs,\n+            output=output,\n+            purity=ast::impure_fn,\n+            cf=ast::return,\n+\n+            // I guess dtors can't have constraints? \n+            constraints=[]);\n+    let ast::_fn f = rec(decl=d, proto=ast::proto_fn, body=b);\n+    let ast::method_ m =\n+        rec(ident=\"drop\", meth=f, id=p.next_def_id(), ann=p.get_ann());\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n-fn parse_item_obj(&parser p, ast::layer lyr,\n-                  vec[ast::attribute] attrs) -> @ast::item {\n+fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n+   @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     auto pf = parse_obj_field;\n     let util::common::spanned[vec[ast::obj_field]] fields =\n-        parse_seq[ast::obj_field]\n-        (token::LPAREN,\n-         token::RPAREN,\n-         some(token::COMMA),\n-         pf, p);\n-\n+        parse_seq[ast::obj_field](token::LPAREN, token::RPAREN,\n+                                  some(token::COMMA), pf, p);\n     let vec[@ast::method] meths = [];\n     let option::t[@ast::method] dtor = none;\n-\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n         if (eat_word(p, \"drop\")) {\n             dtor = some(parse_dtor(p));\n-        } else {\n-            vec::push(meths, parse_method(p));\n-        }\n+        } else { vec::push(meths, parse_method(p)); }\n     }\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n-\n-    let ast::_obj ob = rec(fields=fields.node,\n-                          methods=meths,\n-                          dtor=dtor);\n-\n+    let ast::_obj ob = rec(fields=fields.node, methods=meths, dtor=dtor);\n     auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n     auto item = ast::item_obj(ident, ob, ty_params, attrs, odid, p.get_ann());\n-\n     ret @spanned(lo, hi, item);\n }\n \n@@ -1889,12 +1698,10 @@ fn parse_mod_items(&parser p, token::token term) -> ast::_mod {\n     while (p.peek() != term) {\n         auto attrs = parse_attributes(p);\n         alt (parse_item(p, attrs)) {\n-            case (got_item(?i)) {\n-                vec::push(items, i);\n-            }\n+            case (got_item(?i)) { vec::push(items, i); }\n             case (_) {\n                 p.err(\"expected item but found \" +\n-                      token::to_str(p.get_reader(), p.peek()));\n+                          token::to_str(p.get_reader(), p.peek()));\n             }\n         }\n     }\n@@ -1909,8 +1716,8 @@ fn parse_item_const(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto e = parse_expr(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto item = ast::item_const(id, ty, e, attrs,\n-                                p.next_def_id(), p.get_ann());\n+    auto item =\n+        ast::item_const(id, ty, e, attrs, p.next_def_id(), p.get_ann());\n     ret @spanned(lo, hi, item);\n }\n \n@@ -1944,9 +1751,9 @@ fn parse_item_native_fn(&parser p) -> @ast::native_item {\n     }\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto item = ast::native_item_fn(t._0, link_name, decl,\n-                                   t._1, p.next_def_id(),\n-                                   p.get_ann());\n+    auto item =\n+        ast::native_item_fn(t._0, link_name, decl, t._1, p.next_def_id(),\n+                            p.get_ann());\n     ret @spanned(lo, hi, item);\n }\n \n@@ -1956,38 +1763,26 @@ fn parse_native_item(&parser p) -> @ast::native_item {\n         ret parse_item_native_type(p);\n     } else if (eat_word(p, \"fn\")) {\n         ret parse_item_native_fn(p);\n-    } else {\n-        unexpected(p, p.peek());\n-        fail;\n-    }\n+    } else { unexpected(p, p.peek()); fail; }\n }\n \n-fn parse_native_mod_items(&parser p, &str native_name,\n-                          ast::native_abi abi) -> ast::native_mod {\n+fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi) ->\n+   ast::native_mod {\n     let vec[@ast::native_item] items = [];\n-\n     auto view_items = parse_native_view(p);\n-\n-    while (p.peek() != token::RBRACE) {\n-        items += [parse_native_item(p)];\n-    }\n-    ret rec(native_name=native_name, abi=abi,\n+    while (p.peek() != token::RBRACE) { items += [parse_native_item(p)]; }\n+    ret rec(native_name=native_name,\n+            abi=abi,\n             view_items=view_items,\n             items=items);\n }\n \n-fn default_native_lib_naming(session::session sess)\n-    -> rec(str prefix, str suffix) {\n+fn default_native_lib_naming(session::session sess) ->\n+   rec(str prefix, str suffix) {\n     alt (sess.get_targ_cfg().os) {\n-        case (session::os_win32) {\n-            ret rec(prefix=\"\", suffix=\".dll\");\n-        }\n-        case (session::os_macos) {\n-            ret rec(prefix=\"lib\", suffix=\".dylib\");\n-        }\n-        case (session::os_linux) {\n-            ret rec(prefix=\"lib\", suffix=\".so\");\n-        }\n+        case (session::os_win32) { ret rec(prefix=\"\", suffix=\".dll\"); }\n+        case (session::os_macos) { ret rec(prefix=\"lib\", suffix=\".dylib\"); }\n+        case (session::os_linux) { ret rec(prefix=\"lib\", suffix=\".so\"); }\n     }\n }\n \n@@ -2008,20 +1803,15 @@ fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n             abi = ast::native_abi_llvm;\n         } else if (str::eq(t, \"rust-intrinsic\")) {\n             abi = ast::native_abi_rust_intrinsic;\n-        } else {\n-            p.err(\"unsupported abi: \" + t);\n-            fail;\n-        }\n+        } else { p.err(\"unsupported abi: \" + t); fail; }\n     }\n     expect_word(p, \"mod\");\n     auto id = parse_ident(p);\n     auto native_name;\n     if (p.peek() == token::EQ) {\n         expect(p, token::EQ);\n         native_name = parse_str_lit_or_env_ident(p);\n-    } else {\n-        native_name = default_native_name(p.get_session(), id);\n-    }\n+    } else { native_name = default_native_name(p.get_session(), id); }\n     expect(p, token::LBRACE);\n     auto m = parse_native_mod_items(p, native_name, abi);\n     auto hi = p.get_hi_pos();\n@@ -2039,21 +1829,19 @@ fn parse_type_decl(&parser p) -> tup(uint, ast::ident) {\n fn parse_item_type(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto t = parse_type_decl(p);\n     auto tps = parse_ty_params(p);\n-\n     expect(p, token::EQ);\n     auto ty = parse_ty(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto item = ast::item_ty(t._1, ty, tps, attrs,\n-                             p.next_def_id(), p.get_ann());\n+    auto item =\n+        ast::item_ty(t._1, ty, tps, attrs, p.next_def_id(), p.get_ann());\n     ret @spanned(t._0, hi, item);\n }\n \n fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n-\n     let vec[ast::variant] variants = [];\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n@@ -2063,111 +1851,94 @@ fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n                 check_bad_word(p);\n                 auto vlo = p.get_lo_pos();\n                 p.bump();\n-\n                 let vec[ast::variant_arg] args = [];\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n-                        auto arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n-                                                 some(token::COMMA),\n-                                                 parse_ty, p);\n+                        auto arg_tys =\n+                            parse_seq(token::LPAREN, token::RPAREN,\n+                                      some(token::COMMA), parse_ty, p);\n                         for (@ast::ty ty in arg_tys.node) {\n                             args += [rec(ty=ty, id=p.next_def_id())];\n                         }\n                     }\n-                    case (_) { /* empty */ }\n+                    case (_) {/* empty */ }\n                 }\n-\n                 auto vhi = p.get_hi_pos();\n                 expect(p, token::SEMI);\n-\n                 auto id = p.next_def_id();\n-                auto vr = rec(name=p.get_str(name), args=args,\n-                              id=id, ann=p.get_ann());\n+                auto vr =\n+                    rec(name=p.get_str(name),\n+                        args=args,\n+                        id=id,\n+                        ann=p.get_ann());\n                 variants += [spanned(vlo, vhi, vr)];\n             }\n-            case (token::RBRACE) { /* empty */ }\n+            case (token::RBRACE) {/* empty */ }\n             case (_) {\n                 p.err(\"expected name of variant or '}' but found \" +\n-                      token::to_str(p.get_reader(), tok));\n+                          token::to_str(p.get_reader(), tok));\n             }\n         }\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n-\n-    auto item = ast::item_tag(id, variants, ty_params, attrs,\n-                              p.next_def_id(), p.get_ann());\n+    auto item =\n+        ast::item_tag(id, variants, ty_params, attrs, p.next_def_id(),\n+                      p.get_ann());\n     ret @spanned(lo, hi, item);\n }\n \n-\n fn parse_layer(&parser p) -> ast::layer {\n     if (eat_word(p, \"state\")) {\n         ret ast::layer_state;\n     } else if (eat_word(p, \"gc\")) {\n         ret ast::layer_gc;\n-    } else {\n-        ret ast::layer_value;\n-    }\n+    } else { ret ast::layer_value; }\n     fail;\n }\n \n-\n fn parse_auth(&parser p) -> ast::_auth {\n     if (eat_word(p, \"unsafe\")) {\n         ret ast::auth_unsafe;\n-    } else {\n-        unexpected(p, p.peek());\n-    }\n+    } else { unexpected(p, p.peek()); }\n     fail;\n }\n \n-tag parsed_item {\n-    got_item(@ast::item);\n-    no_item;\n-    fn_no_item;\n-}\n+tag parsed_item { got_item(@ast::item); no_item; fn_no_item; }\n \n fn parse_item(&parser p, vec[ast::attribute] attrs) -> parsed_item {\n-\n     if (eat_word(p, \"const\")) {\n         ret got_item(parse_item_const(p, attrs));\n     } else if (eat_word(p, \"fn\")) {\n         // This is an anonymous function\n+\n         if (p.peek() == token::LPAREN) { ret fn_no_item; }\n-        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn,\n-                                           ast::proto_fn, attrs));\n+        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n+                                           attrs));\n     } else if (eat_word(p, \"pred\")) {\n-        ret got_item(parse_item_fn_or_iter(p, ast::pure_fn,\n-                                           ast::proto_fn, attrs));\n+        ret got_item(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn,\n+                                           attrs));\n     } else if (eat_word(p, \"iter\")) {\n-        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn,\n-                                           ast::proto_iter, attrs));\n+        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter,\n+                                           attrs));\n     } else if (eat_word(p, \"mod\")) {\n         ret got_item(parse_item_mod(p, attrs));\n     } else if (eat_word(p, \"native\")) {\n         ret got_item(parse_item_native_mod(p, attrs));\n     }\n-\n     auto lyr = parse_layer(p);\n     if (eat_word(p, \"type\")) {\n         ret got_item(parse_item_type(p, attrs));\n     } else if (eat_word(p, \"tag\")) {\n         ret got_item(parse_item_tag(p, attrs));\n     } else if (eat_word(p, \"obj\")) {\n         ret got_item(parse_item_obj(p, lyr, attrs));\n-    } else {\n-        ret no_item;\n-    }\n+    } else { ret no_item; }\n }\n \n fn parse_attributes(&parser p) -> vec[ast::attribute] {\n     let vec[ast::attribute] attrs = [];\n-\n-    while (p.peek() == token::POUND) {\n-        attrs += [parse_attribute(p)];\n-    }\n-\n+    while (p.peek() == token::POUND) { attrs += [parse_attribute(p)]; }\n     ret attrs;\n }\n \n@@ -2178,8 +1949,7 @@ fn parse_attribute(&parser p) -> ast::attribute {\n     auto meta_item = parse_meta_item(p);\n     expect(p, token::RBRACKET);\n     auto hi = p.get_hi_pos();\n-    ret spanned(lo, hi, rec(style = ast::attr_outer,\n-                            value = *meta_item));\n+    ret spanned(lo, hi, rec(style=ast::attr_outer, value=*meta_item));\n }\n \n fn parse_meta_item(&parser p) -> @ast::meta_item {\n@@ -2190,30 +1960,22 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n         case (token::LIT_STR(?s)) {\n             auto hi = p.get_hi_pos();\n             p.bump();\n-            ret @spanned(lo, hi, rec(key = ident,\n-                                     value = p.get_str(s)));\n-        }\n-        case (_) {\n-            p.err(\"Metadata items must be string literals\");\n+            ret @spanned(lo, hi, rec(key=ident, value=p.get_str(s)));\n         }\n+        case (_) { p.err(\"Metadata items must be string literals\"); }\n     }\n     fail;\n }\n \n fn parse_meta(&parser p) -> vec[@ast::meta_item] {\n-    ret parse_seq(token::LPAREN, token::RPAREN,\n-                  some(token::COMMA), parse_meta_item, p).node;\n+    ret parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                  parse_meta_item, p).node;\n }\n \n fn parse_optional_meta(&parser p) -> vec[@ast::meta_item] {\n     alt (p.peek()) {\n-        case (token::LPAREN) {\n-            ret parse_meta(p);\n-        }\n-        case (_) {\n-            let vec[@ast::meta_item] v = [];\n-            ret v;\n-        }\n+        case (token::LPAREN) { ret parse_meta(p); }\n+        case (_) { let vec[@ast::meta_item] v = []; ret v; }\n     }\n }\n \n@@ -2223,36 +1985,31 @@ fn parse_use(&parser p) -> @ast::view_item {\n     auto metadata = parse_optional_meta(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto use_decl = ast::view_item_use(ident, metadata, p.next_def_id(),\n-                                       p.get_ann());\n+    auto use_decl =\n+        ast::view_item_use(ident, metadata, p.next_def_id(), p.get_ann());\n     ret @spanned(lo, hi, use_decl);\n }\n \n fn parse_rest_import_name(&parser p, ast::ident first,\n-                          option::t[ast::ident] def_ident)\n-        -> @ast::view_item {\n+                          option::t[ast::ident] def_ident) ->\n+   @ast::view_item {\n     auto lo = p.get_lo_pos();\n     let vec[ast::ident] identifiers = [first];\n     let bool glob = false;\n-\n     while (true) {\n         alt (p.peek()) {\n-            case (token::SEMI) {\n-                p.bump();\n-                break;\n-            }\n+            case (token::SEMI) { p.bump(); break; }\n             case (token::MOD_SEP) {\n                 if (glob) { p.err(\"cannot path into a glob\"); }\n                 p.bump();\n             }\n             case (_) { p.err(\"expecting '::' or ';'\"); }\n         }\n         alt (p.peek()) {\n-            case (token::IDENT(_,_)) {\n-                identifiers += [parse_ident(p)];\n-            }\n-            //the lexer can't tell the different kinds of stars apart ) :\n-            case (token::BINOP(token::STAR)) { \n+            case (token::IDENT(_, _)) { identifiers += [parse_ident(p)]; }\n+            case (\n+                 //the lexer can't tell the different kinds of stars apart ) :\n+                 token::BINOP(token::STAR)) {\n                 glob = true;\n                 p.bump();\n             }\n@@ -2262,38 +2019,34 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n     auto hi = p.get_hi_pos();\n     auto import_decl;\n     alt (def_ident) {\n-        case(some(?i)) {\n-            if (glob) {\n-                p.err(\"globbed imports can't be renamed\");\n-            }\n-            import_decl = ast::view_item_import(i, identifiers,\n-                                                p.next_def_id());\n+        case (some(?i)) {\n+            if (glob) { p.err(\"globbed imports can't be renamed\"); }\n+            import_decl =\n+                ast::view_item_import(i, identifiers, p.next_def_id());\n         }\n         case (_) {\n             if (glob) {\n-                import_decl = ast::view_item_import_glob(identifiers,\n-                                                         p.next_def_id());\n+                import_decl =\n+                    ast::view_item_import_glob(identifiers, p.next_def_id());\n             } else {\n                 auto len = vec::len(identifiers);\n-                import_decl = ast::view_item_import(identifiers.(len - 1u), \n-                                                    identifiers, \n-                                                    p.next_def_id());\n+                import_decl =\n+                    ast::view_item_import(identifiers.(len - 1u), identifiers,\n+                                          p.next_def_id());\n             }\n         }\n     }\n     ret @spanned(lo, hi, import_decl);\n }\n \n-fn parse_full_import_name(&parser p, ast::ident def_ident)\n-       -> @ast::view_item {\n+fn parse_full_import_name(&parser p, ast::ident def_ident) ->\n+   @ast::view_item {\n     alt (p.peek()) {\n         case (token::IDENT(?i, _)) {\n             p.bump();\n             ret parse_rest_import_name(p, p.get_str(i), some(def_ident));\n         }\n-        case (_) {\n-            p.err(\"expecting an identifier\");\n-        }\n+        case (_) { p.err(\"expecting an identifier\"); }\n     }\n     fail;\n }\n@@ -2312,9 +2065,7 @@ fn parse_import(&parser p) -> @ast::view_item {\n                 }\n             }\n         }\n-        case (_) {\n-            p.err(\"expecting an identifier\");\n-        }\n+        case (_) { p.err(\"expecting an identifier\"); }\n     }\n     fail;\n }\n@@ -2332,19 +2083,15 @@ fn parse_view_item(&parser p) -> @ast::view_item {\n         ret parse_use(p);\n     } else if (eat_word(p, \"import\")) {\n         ret parse_import(p);\n-    } else if (eat_word(p, \"export\")) {\n-        ret parse_export(p);\n-    } else {\n-        fail;\n-    }\n+    } else if (eat_word(p, \"export\")) { ret parse_export(p); } else { fail; }\n }\n \n fn is_view_item(&parser p) -> bool {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n             auto st = p.get_str(sid);\n             ret str::eq(st, \"use\") || str::eq(st, \"import\") ||\n-                str::eq(st, \"export\");\n+                    str::eq(st, \"export\");\n         }\n         case (_) { ret false; }\n     }\n@@ -2353,37 +2100,30 @@ fn is_view_item(&parser p) -> bool {\n \n fn parse_view(&parser p) -> vec[@ast::view_item] {\n     let vec[@ast::view_item] items = [];\n-    while (is_view_item(p)) {\n-        items += [parse_view_item(p)];\n-    }\n+    while (is_view_item(p)) { items += [parse_view_item(p)]; }\n     ret items;\n }\n \n fn parse_native_view(&parser p) -> vec[@ast::view_item] {\n     let vec[@ast::view_item] items = [];\n-    while (is_view_item(p)) {\n-        items += [parse_view_item(p)];\n-    }\n+    while (is_view_item(p)) { items += [parse_view_item(p)]; }\n     ret items;\n }\n \n-\n fn parse_crate_from_source_file(&parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto m = parse_mod_items(p, token::EOF);\n     let vec[@ast::crate_directive] cdirs = [];\n-    ret @spanned(lo, p.get_lo_pos(), rec(directives=cdirs,\n-                                         module=m));\n+    ret @spanned(lo, p.get_lo_pos(), rec(directives=cdirs, module=m));\n }\n \n+\n // Logic for parsing crate files (.rc)\n //\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-\n-fn parse_crate_directive(&parser p) -> ast::crate_directive\n-{\n+fn parse_crate_directive(&parser p) -> ast::crate_directive {\n     auto lo = p.get_lo_pos();\n     if (eat_word(p, \"auth\")) {\n         auto n = parse_path(p);\n@@ -2394,48 +2134,41 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive\n         ret spanned(lo, hi, ast::cdir_auth(n, a));\n     } else if (eat_word(p, \"meta\")) {\n         auto mv = ast::local_meta;\n-        if (eat_word(p, \"export\")) {\n-            mv = ast::export_meta;\n-        }\n+        if (eat_word(p, \"export\")) { mv = ast::export_meta; }\n         auto mis = parse_meta(p);\n         auto hi = p.get_hi_pos();\n         expect(p, token::SEMI);\n         ret spanned(lo, hi, ast::cdir_meta(mv, mis));\n     } else if (eat_word(p, \"mod\")) {\n         auto id = parse_ident(p);\n-        auto file_opt = alt (p.peek()) {\n-            case (token::EQ) {\n-                p.bump();\n-                // FIXME: turn this into parse+eval expr\n-                some(parse_str_lit_or_env_ident(p))\n-            }\n-            case (_) { none }\n-        };\n+        auto file_opt =\n+            alt (p.peek()) {\n+                case (token::EQ) {\n+                    p.bump();\n \n+                    // FIXME: turn this into parse+eval expr\n+                    some(parse_str_lit_or_env_ident(p))\n+                }\n+                case (_) { none }\n+            };\n         alt (p.peek()) {\n-\n-            // mod x = \"foo.rs\";\n-\n-            case (token::SEMI) {\n+            case (\n+                 // mod x = \"foo.rs\";\n+                 token::SEMI) {\n                 auto hi = p.get_hi_pos();\n                 p.bump();\n                 ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt));\n             }\n-\n-            // mod x = \"foo_dir\" { ...directives... }\n-\n-            case (token::LBRACE) {\n+            case (\n+                 // mod x = \"foo_dir\" { ...directives... }\n+                 token::LBRACE) {\n                 p.bump();\n                 auto cdirs = parse_crate_directives(p, token::RBRACE);\n                 auto hi = p.get_hi_pos();\n                 expect(p, token::RBRACE);\n-                ret spanned(lo, hi,\n-                            ast::cdir_dir_mod(id, file_opt, cdirs));\n-            }\n-\n-            case (?t) {\n-                unexpected(p, t);\n+                ret spanned(lo, hi, ast::cdir_dir_mod(id, file_opt, cdirs));\n             }\n+            case (?t) { unexpected(p, t); }\n         }\n     } else if (eat_word(p, \"let\")) {\n         expect(p, token::LPAREN);\n@@ -2464,17 +2197,13 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive\n     fail;\n }\n \n-\n-fn parse_crate_directives(&parser p, token::token term)\n-    -> vec[@ast::crate_directive] {\n-\n+fn parse_crate_directives(&parser p, token::token term) ->\n+   vec[@ast::crate_directive] {\n     let vec[@ast::crate_directive] cdirs = [];\n-\n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n         vec::push(cdirs, cdir);\n     }\n-\n     ret cdirs;\n }\n \n@@ -2483,21 +2212,19 @@ fn parse_crate_from_crate_file(&parser p) -> @ast::crate {\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n     auto cdirs = parse_crate_directives(p, token::EOF);\n     let vec[str] deps = [];\n-    auto cx = @rec(p=p,\n-                   mode=eval::mode_parse,\n-                   mutable deps = deps,\n-                   sess=p.get_session(),\n-                   mutable chpos=p.get_chpos(),\n-                   mutable next_ann=p.next_ann_num());\n-    auto m = eval::eval_crate_directives_to_mod(cx, p.get_env(),\n-                                               cdirs, prefix);\n+    auto cx =\n+        @rec(p=p,\n+             mode=eval::mode_parse,\n+             mutable deps=deps,\n+             sess=p.get_session(),\n+             mutable chpos=p.get_chpos(),\n+             mutable next_ann=p.next_ann_num());\n+    auto m =\n+        eval::eval_crate_directives_to_mod(cx, p.get_env(), cdirs, prefix);\n     auto hi = p.get_hi_pos();\n     expect(p, token::EOF);\n-    ret @spanned(lo, hi, rec(directives=cdirs,\n-                             module=m));\n+    ret @spanned(lo, hi, rec(directives=cdirs, module=m));\n }\n-\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "30329e1ffd32b9a2c69475bf170b47dfab0c39cb", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import util::common::ty_mach;\n import util::common::ty_mach_to_str;\n import util::common::new_str_hash;\n@@ -23,6 +24,7 @@ tag binop {\n }\n \n tag token {\n+\n     /* Expression-operator symbols. */\n     EQ;\n     LT;\n@@ -35,7 +37,6 @@ tag token {\n     OROR;\n     NOT;\n     TILDE;\n-\n     BINOP(binop);\n     BINOPEQ(binop);\n \n@@ -57,7 +58,6 @@ tag token {\n     RBRACKET;\n     LBRACE;\n     RBRACE;\n-\n     POUND;\n \n     /* Literals */\n@@ -74,7 +74,6 @@ tag token {\n     IDENT(str_num, bool);\n     IDX(int);\n     UNDERSCORE;\n-\n     BRACEQUOTE(str_num);\n     EOF;\n }\n@@ -97,7 +96,6 @@ fn binop_to_str(binop o) -> str {\n \n fn to_str(lexer::reader r, token t) -> str {\n     alt (t) {\n-\n         case (EQ) { ret \"=\"; }\n         case (LT) { ret \"<\"; }\n         case (LE) { ret \"<=\"; }\n@@ -109,12 +107,13 @@ fn to_str(lexer::reader r, token t) -> str {\n         case (TILDE) { ret \"~\"; }\n         case (OROR) { ret \"||\"; }\n         case (ANDAND) { ret \"&&\"; }\n-\n         case (BINOP(?op)) { ret binop_to_str(op); }\n         case (BINOPEQ(?op)) { ret binop_to_str(op) + \"=\"; }\n-\n-        /* Structural symbols */\n-        case (AT) { ret \"@\"; }\n+        case (\n+             /* Structural symbols */\n+             AT) {\n+            ret \"@\";\n+        }\n         case (DOT) { ret \".\"; }\n         case (COMMA) { ret \",\"; }\n         case (SEMI) { ret \";\"; }\n@@ -131,49 +130,46 @@ fn to_str(lexer::reader r, token t) -> str {\n         case (RBRACKET) { ret \"]\"; }\n         case (LBRACE) { ret \"{\"; }\n         case (RBRACE) { ret \"}\"; }\n-\n         case (POUND) { ret \"#\"; }\n-\n-        /* Literals */\n-        case (LIT_INT(?i)) { ret int::to_str(i, 10u); }\n+        case (\n+             /* Literals */\n+             LIT_INT(?i)) {\n+            ret int::to_str(i, 10u);\n+        }\n         case (LIT_UINT(?u)) { ret uint::to_str(u, 10u); }\n         case (LIT_MACH_INT(?tm, ?i)) {\n-            ret  int::to_str(i, 10u)\n-                + \"_\" + ty_mach_to_str(tm);\n+            ret int::to_str(i, 10u) + \"_\" + ty_mach_to_str(tm);\n         }\n         case (LIT_MACH_FLOAT(?tm, ?s)) {\n             ret interner::get[str](*r.get_interner(), s) + \"_\" +\n-                ty_mach_to_str(tm);\n+                    ty_mach_to_str(tm);\n         }\n-\n         case (LIT_FLOAT(?s)) { ret interner::get[str](*r.get_interner(), s); }\n         case (LIT_STR(?s)) {\n             // FIXME: escape.\n+\n             ret \"\\\"\" + interner::get[str](*r.get_interner(), s) + \"\\\"\";\n         }\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape.\n+\n             auto tmp = \"'\";\n             str::push_char(tmp, c);\n             str::push_byte(tmp, '\\'' as u8);\n             ret tmp;\n         }\n-\n-        case (LIT_BOOL(?b)) {\n-            if (b) { ret \"true\"; } else { ret \"false\"; }\n+        case (LIT_BOOL(?b)) { if (b) { ret \"true\"; } else { ret \"false\"; } }\n+        case (\n+             /* Name components */\n+             IDENT(?s, _)) {\n+            ret interner::get[str](*r.get_interner(), s);\n         }\n-\n-        /* Name components */\n-        case (IDENT(?s, _)) { ret interner::get[str](*r.get_interner(), s); }\n         case (IDX(?i)) { ret \"_\" + int::to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n-\n         case (BRACEQUOTE(_)) { ret \"<bracequote>\"; }\n         case (EOF) { ret \"<eof>\"; }\n     }\n }\n-\n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "d9ef386de622429267d8d49372475adbebfca75a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 190, "deletions": 209, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import front::ast;\n import front::ast::ident;\n import front::ast::def_num;\n@@ -10,47 +11,46 @@ import std::option::some;\n import std::option::none;\n import std::option::is_none;\n \n+\n // This is not an alias-analyser (though it would merit from becoming one, or\n // at getting input from one, to be more precise). It is a pass that checks\n // whether aliases are used in a safe way. Beyond that, though it doesn't have\n // a lot to do with aliases, it also checks whether assignments are valid\n // (using an lval, which is actually mutable), since it already has all the\n // information needed to do that (and the typechecker, which would be a\n // logical place for such a check, doesn't).\n+tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n-tag valid {\n-    valid;\n-    overwritten(span, ast::path);\n-    val_taken(span, ast::path);\n-}\n+type restrict =\n+    @rec(vec[def_num] root_vars,\n+         def_num block_defnum,\n+         vec[def_num] bindings,\n+         vec[ty::t] tys,\n+         vec[uint] depends_on,\n+         mutable valid ok);\n \n-type restrict = @rec(vec[def_num] root_vars,\n-                     def_num block_defnum,\n-                     vec[def_num] bindings,\n-                     vec[ty::t] tys,\n-                     vec[uint] depends_on,\n-                     mutable valid ok);\n type scope = vec[restrict];\n \n-tag local_info {\n-    arg(ast::mode);\n-    objfield(ast::mutability);\n-}\n+tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n-type ctx = rec(@ty::ctxt tcx,\n-               resolve::def_map dm,\n-               std::map::hashmap[def_num,local_info] local_map);\n+type ctx =\n+    rec(@ty::ctxt tcx,\n+        resolve::def_map dm,\n+        std::map::hashmap[def_num, local_info] local_map);\n \n fn check_crate(@ty::ctxt tcx, resolve::def_map dm, &@ast::crate crate) {\n-    auto cx = @rec(tcx = tcx,\n-                   dm = dm,\n-                   // Stores information about object fields and function\n-                   // arguments that's otherwise not easily available.\n-                   local_map = util::common::new_int_hash());\n-    auto v = @rec(visit_fn = bind visit_fn(cx, _, _, _, _, _, _, _, _),\n-                  visit_item = bind visit_item(cx, _, _, _),\n-                  visit_expr = bind visit_expr(cx, _, _, _)\n-                  with *visit::default_visitor[scope]());\n+    auto cx =\n+        @rec(tcx=tcx,\n+             dm=dm,\n+\n+             // Stores information about object fields and function\n+             // arguments that's otherwise not easily available.\n+             local_map=util::common::new_int_hash());\n+    auto v =\n+        @rec(visit_fn=bind visit_fn(cx, _, _, _, _, _, _, _, _),\n+             visit_item=bind visit_item(cx, _, _, _),\n+             visit_expr=bind visit_expr(cx, _, _, _)\n+             with *visit::default_visitor[scope]());\n     visit::visit_crate(*crate, [], visit::vtor(v));\n }\n \n@@ -71,17 +71,15 @@ fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n                 cx.local_map.insert(f.id._1, objfield(f.mut));\n             }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     visit::visit_item(i, sc, v);\n }\n \n fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n     auto handled = false;\n     alt (ex.node) {\n-        case (ast::expr_call(?f, ?args, _)) {\n-            check_call(*cx, f, args, sc);\n-        }\n+        case (ast::expr_call(?f, ?args, _)) { check_call(*cx, f, args, sc); }\n         case (ast::expr_alt(?input, ?arms, _)) {\n             check_alt(*cx, input, arms, sc, v);\n             handled = true;\n@@ -91,13 +89,13 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 case (some(?ex)) {\n                     auto root = expr_root(*cx, ex, false);\n                     if (mut_field(root.ds)) {\n-                        cx.tcx.sess.span_err\n-                            (ex.span,\n-                             \"result of put must be immutably rooted\");\n+                        cx.tcx.sess.span_err(ex.span,\n+                                             \"result of put must be\"\n+                                             + \" immutably rooted\");\n                     }\n                     visit_expr(cx, ex, sc, v);\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n             handled = true;\n         }\n@@ -109,7 +107,6 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n             check_for(*cx, decl, seq, block, sc, v);\n             handled = true;\n         }\n-\n         case (ast::expr_path(?pt, ?ann)) {\n             check_var(*cx, ex, pt, ann, false, sc);\n         }\n@@ -125,25 +122,23 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n             check_assign(cx, dest, src, sc, v);\n             handled = true;\n         }\n-\n-        case (_) {}\n+        case (_) { }\n     }\n     if (!handled) { visit::visit_expr(ex, sc, v); }\n }\n \n-fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n-    -> rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n+fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n+   rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n-    auto arg_ts = alt (ty::struct(*cx.tcx, fty)) {\n-        case (ty::ty_fn(_, ?args, _, _, _)) { args }\n-        case (ty::ty_native_fn(_, ?args, _)) { args }\n-    };\n-\n+    auto arg_ts =\n+        alt (ty::struct(*cx.tcx, fty)) {\n+            case (ty::ty_fn(_, ?args, _, _, _)) { args }\n+            case (ty::ty_native_fn(_, ?args, _)) { args }\n+        };\n     let vec[def_num] roots = [];\n     let vec[tup(uint, def_num)] mut_roots = [];\n     let vec[ty::t] unsafe_ts = [];\n     let vec[uint] unsafe_t_offsets = [];\n-\n     auto i = 0u;\n     for (ty::arg arg_t in arg_ts) {\n         if (arg_t.mode != ty::mo_val) {\n@@ -156,39 +151,38 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n                     }\n                     case (_) {\n                         if (!mut_field(root.ds)) {\n-                            cx.tcx.sess.span_err\n-                                (arg.span, \"passing a temporary value or \\\n-                                 immutable field by mutable alias\");\n+                            auto m = \"passing a temporary value or \\\n+                                 immutable field by mutable alias\";\n+                            cx.tcx.sess.span_err(arg.span, m);\n                         }\n                     }\n                 }\n             }\n             alt (path_def_id(cx, root.ex)) {\n                 case (some(?did)) { vec::push(roots, did._1); }\n-                case (_) {}\n+                case (_) { }\n             }\n             alt (inner_mut(root.ds)) {\n                 case (some(?t)) {\n                     vec::push(unsafe_ts, t);\n                     vec::push(unsafe_t_offsets, i);\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n         }\n         i += 1u;\n     }\n-\n     if (vec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n                 if (def_is_local(cx.dm.get(ann.id))) {\n-                    cx.tcx.sess.span_err\n-                        (f.span, #fmt(\"function may alias with argument \\\n-                         %u, which is not immutably rooted\",\n-                         unsafe_t_offsets.(0)));\n+                    cx.tcx.sess.span_err(f.span,\n+                                         #fmt(\"function may alias with \\\n+                         argument %u, which is not immutably rooted\",\n+                                              unsafe_t_offsets.(0)));\n                 }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n     auto j = 0u;\n@@ -199,16 +193,18 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n         for (ty::arg arg_t in arg_ts) {\n             auto mut_alias = arg_t.mode == ty::mo_alias(true);\n             if (i != offset &&\n-                ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias)) {\n-                cx.tcx.sess.span_err\n-                    (args.(i).span, #fmt(\"argument %u may alias with \\\n-                     argument %u, which is not immutably rooted\", i, offset));\n+                    ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias))\n+               {\n+                cx.tcx.sess.span_err(args.(i).span,\n+                                     #fmt(\"argument %u may alias with \\\n+                     argument %u, which is not immutably rooted\",\n+                                          i, offset));\n             }\n             i += 1u;\n         }\n     }\n-\n     // Ensure we're not passing a root by mutable alias.\n+\n     for (tup(uint, def_num) root in mut_roots) {\n         auto mut_alias_to_root = vec::count(root._1, roots) > 1u;\n         for (restrict r in sc) {\n@@ -217,38 +213,37 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n             }\n         }\n         if (mut_alias_to_root) {\n-            cx.tcx.sess.span_err\n-                (args.(root._0).span, \"passing a mutable alias to a \\\n+            cx.tcx.sess.span_err(args.(root._0).span,\n+                                 \"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n     }\n-\n-    ret rec(root_vars = roots, unsafe_ts = unsafe_ts);\n+    ret rec(root_vars=roots, unsafe_ts=unsafe_ts);\n }\n \n-fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n-             &scope sc, &vt[scope] v) {\n+fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms, &scope sc,\n+             &vt[scope] v) {\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n-    auto roots = alt (path_def_id(cx, root.ex)) {\n-        case (some(?did)) { [did._1] }\n-        case (_) { [] }\n-    };\n-    let vec[ty::t] forbidden_tp = alt (inner_mut(root.ds)) {\n-        case (some(?t)) { [t] }\n-        case (_) { [] }\n-    };\n-\n+    auto roots =\n+        alt (path_def_id(cx, root.ex)) {\n+            case (some(?did)) { [did._1] }\n+            case (_) { [] }\n+        };\n+    let vec[ty::t] forbidden_tp =\n+        alt (inner_mut(root.ds)) { case (some(?t)) { [t] } case (_) { [] } };\n     for (ast::arm a in arms) {\n         auto dnums = arm_defnums(a);\n         auto new_sc = sc;\n         if (vec::len(dnums) > 0u) {\n-            new_sc = sc + [@rec(root_vars=roots,\n-                                block_defnum=dnums.(0),\n-                                bindings=dnums,\n-                                tys=forbidden_tp,\n-                                depends_on=deps(sc, roots),\n-                                mutable ok=valid)];\n+            new_sc =\n+                sc +\n+                    [@rec(root_vars=roots,\n+                          block_defnum=dnums.(0),\n+                          bindings=dnums,\n+                          tys=forbidden_tp,\n+                          depends_on=deps(sc, roots),\n+                          mutable ok=valid)];\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n@@ -258,15 +253,11 @@ fn arm_defnums(&ast::arm arm) -> vec[def_num] {\n     auto dnums = [];\n     fn walk_pat(&mutable vec[def_num] found, &@ast::pat p) {\n         alt (p.node) {\n-            case (ast::pat_bind(_, ?did, _)) {\n-                vec::push(found, did._1);\n-            }\n+            case (ast::pat_bind(_, ?did, _)) { vec::push(found, did._1); }\n             case (ast::pat_tag(_, ?children, _)) {\n-                for (@ast::pat child in children) {\n-                    walk_pat(found, child);\n-                }\n+                for (@ast::pat child in children) { walk_pat(found, child); }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n     walk_pat(dnums, arm.pat);\n@@ -280,47 +271,46 @@ fn check_for_each(&ctx cx, &@ast::local local, &@ast::expr call,\n         case (ast::expr_call(?f, ?args, _)) {\n             auto data = check_call(cx, f, args, sc);\n             auto defnum = local.node.id._1;\n-            \n-            auto new_sc = @rec(root_vars=data.root_vars,\n-                               block_defnum=defnum,\n-                               bindings=[defnum],\n-                               tys=data.unsafe_ts,\n-                               depends_on=deps(sc, data.root_vars),\n-                               mutable ok=valid);\n+            auto new_sc =\n+                @rec(root_vars=data.root_vars,\n+                     block_defnum=defnum,\n+                     bindings=[defnum],\n+                     tys=data.unsafe_ts,\n+                     depends_on=deps(sc, data.root_vars),\n+                     mutable ok=valid);\n             visit::visit_block(block, sc + [new_sc], v);\n         }\n     }\n }\n \n-fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq,\n-             &ast::block block, &scope sc, &vt[scope] v) {\n+fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n+             &scope sc, &vt[scope] v) {\n     visit::visit_expr(seq, sc, v);\n     auto defnum = local.node.id._1;\n-\n     auto root = expr_root(cx, seq, false);\n-    auto root_def = alt (path_def_id(cx, root.ex)) {\n-        case (some(?did)) { [did._1] }\n-        case (_) { [] }\n-    };\n-    auto unsafe = alt (inner_mut(root.ds)) {\n-        case (some(?t)) { [t] }\n-        case (_) { [] }\n-    };\n+    auto root_def =\n+        alt (path_def_id(cx, root.ex)) {\n+            case (some(?did)) { [did._1] }\n+            case (_) { [] }\n+        };\n+    auto unsafe =\n+        alt (inner_mut(root.ds)) { case (some(?t)) { [t] } case (_) { [] } };\n     // If this is a mutable vector, don't allow it to be touched.\n+\n     auto seq_t = ty::expr_ty(*cx.tcx, seq);\n     alt (ty::struct(*cx.tcx, seq_t)) {\n         case (ty::ty_vec(?mt)) {\n             if (mt.mut != ast::imm) { unsafe = [seq_t]; }\n         }\n-        case (ty::ty_str) {}\n+        case (ty::ty_str) { }\n     }\n-\n-    auto new_sc = @rec(root_vars=root_def,\n-                       block_defnum=defnum,\n-                       bindings=[defnum],\n-                       tys=unsafe,\n-                       depends_on=deps(sc, root_def),\n-                       mutable ok=valid);\n+    auto new_sc =\n+        @rec(root_vars=root_def,\n+             block_defnum=defnum,\n+             bindings=[defnum],\n+             tys=unsafe,\n+             depends_on=deps(sc, root_def),\n+             mutable ok=valid);\n     visit::visit_block(block, sc + [new_sc], v);\n }\n \n@@ -331,6 +321,7 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n     for (restrict r in sc) {\n+\n         // excludes variables introduced since the alias was made\n         if (my_defnum < r.block_defnum) {\n             for (ty::t t in r.tys) {\n@@ -344,22 +335,21 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n     }\n }\n \n+\n // FIXME does not catch assigning to immutable object fields yet\n-fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n-                &scope sc, &vt[scope] v) {\n+fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n+                &vt[scope] v) {\n     visit_expr(cx, src, sc, v);\n-    \n     alt (dest.node) {\n         case (ast::expr_path(?p, ?ann)) {\n             auto dnum = ast::def_id_of_def(cx.dm.get(ann.id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n-                cx.tcx.sess.span_err\n-                    (dest.span, \"assigning to immutable alias\");\n+                cx.tcx.sess.span_err(dest.span,\n+                                     \"assigning to immutable alias\");\n             } else if (is_immutable_objfield(cx, dnum)) {\n-                cx.tcx.sess.span_err\n-                    (dest.span, \"assigning to immutable obj field\");\n+                cx.tcx.sess.span_err(dest.span,\n+                                     \"assigning to immutable obj field\");\n             }\n-\n             auto var_t = ty::expr_ty(*cx.tcx, dest);\n             for (restrict r in sc) {\n                 if (vec::member(dnum, r.root_vars)) {\n@@ -373,13 +363,14 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n             if (vec::len(root.ds) == 0u) {\n                 cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n             } else if (!root.ds.(0).mut) {\n-                auto name = alt (root.ds.(0).kind) {\n-                    case (unbox) { \"box\" }\n-                    case (field) { \"field\" }\n-                    case (index) { \"vec content\" }\n-                };\n-                cx.tcx.sess.span_err\n-                    (dest.span, \"assignment to immutable \" + name);\n+                auto name =\n+                    alt (root.ds.(0).kind) {\n+                        case (unbox) { \"box\" }\n+                        case (field) { \"field\" }\n+                        case (index) { \"vec content\" }\n+                    };\n+                cx.tcx.sess.span_err(dest.span,\n+                                     \"assignment to immutable \" + name);\n             }\n             visit_expr(cx, dest, sc, v);\n         }\n@@ -389,13 +380,14 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n fn is_immutable_alias(&@ctx cx, &scope sc, def_num dnum) -> bool {\n     alt (cx.local_map.find(dnum)) {\n         case (some(arg(ast::alias(false)))) { ret true; }\n-        case (_) {}\n+        case (_) { }\n     }\n     for (restrict r in sc) {\n         if (vec::member(dnum, r.bindings)) { ret true; }\n     }\n     ret false;\n }\n+\n fn is_immutable_objfield(&@ctx cx, def_num dnum) -> bool {\n     ret cx.local_map.find(dnum) == some(objfield(ast::imm));\n }\n@@ -407,17 +399,18 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n         prob = sc.(dep).ok;\n     }\n     if (prob != valid) {\n-        auto msg = alt (prob) {\n-            case (overwritten(?sp, ?wpt)) {\n-                tup(sp, \"overwriting \" + ast::path_name(wpt))\n-            }\n-            case (val_taken(?sp, ?vpt)) {\n-                tup(sp, \"taking the value of \" + ast::path_name(vpt))\n-            }\n-        };\n-        cx.tcx.sess.span_err\n-            (msg._0, msg._1 + \" will invalidate alias \" +\n-             ast::path_name(p) + \", which is still used\");\n+        auto msg =\n+            alt (prob) {\n+                case (overwritten(?sp, ?wpt)) {\n+                    tup(sp, \"overwriting \" + ast::path_name(wpt))\n+                }\n+                case (val_taken(?sp, ?vpt)) {\n+                    tup(sp, \"taking the value of \" + ast::path_name(vpt))\n+                }\n+            };\n+        cx.tcx.sess.span_err(msg._0,\n+                             msg._1 + \" will invalidate alias \" +\n+                                 ast::path_name(p) + \", which is still used\");\n     }\n }\n \n@@ -426,55 +419,45 @@ fn deps(&scope sc, vec[def_num] roots) -> vec[uint] {\n     auto result = [];\n     for (restrict r in sc) {\n         for (def_num dn in roots) {\n-            if (vec::member(dn, r.bindings)) {\n-                vec::push(result, i);\n-            }\n+            if (vec::member(dn, r.bindings)) { vec::push(result, i); }\n         }\n         i += 1u;\n     }\n     ret result;\n }\n \n-tag deref_t {\n-    unbox;\n-    field;\n-    index;\n-}\n+tag deref_t { unbox; field; index; }\n+\n type deref = rec(bool mut, deref_t kind, ty::t outer_t);\n \n+\n // Finds the root (the thing that is dereferenced) for the given expr, and a\n // vec of dereferences that were used on this root. Note that, in this vec,\n // the inner derefs come in front, so foo.bar.baz becomes rec(ex=foo,\n // ds=[field(baz),field(bar)])\n-fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n-    -> rec(@ast::expr ex, vec[deref] ds) {\n-\n-    fn maybe_auto_unbox(&ctx cx, &ty::t t)\n-        -> rec(ty::t t, option::t[deref] d) {\n+fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n+   rec(@ast::expr ex, vec[deref] ds) {\n+    fn maybe_auto_unbox(&ctx cx, &ty::t t) ->\n+       rec(ty::t t, option::t[deref] d) {\n         alt (ty::struct(*cx.tcx, t)) {\n             case (ty::ty_box(?mt)) {\n-                ret rec(t=mt.ty, d=some(rec(mut=mt.mut != ast::imm,\n-                                            kind=unbox,\n-                                            outer_t=t)));\n-            }\n-            case (_) {\n-                ret rec(t=t, d=none);\n+                ret rec(t=mt.ty,\n+                        d=some(rec(mut=mt.mut != ast::imm,\n+                                   kind=unbox,\n+                                   outer_t=t)));\n             }\n+            case (_) { ret rec(t=t, d=none); }\n         }\n     }\n     fn maybe_push_auto_unbox(&option::t[deref] d, &mutable vec[deref] ds) {\n-        alt (d) {\n-            case (some(?d)) { vec::push(ds, d); }\n-            case (none) {}\n-        }\n+        alt (d) { case (some(?d)) { vec::push(ds, d); } case (none) { } }\n     }\n-\n     let vec[deref] ds = [];\n     while (true) {\n-        alt ({ex.node}) {\n+        alt ({ ex.node }) {\n             case (ast::expr_field(?base, ?ident, _)) {\n-                auto auto_unbox = maybe_auto_unbox\n-                    (cx, ty::expr_ty(*cx.tcx, base));\n+                auto auto_unbox =\n+                    maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n                 auto mut = false;\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_tup(?fields)) {\n@@ -489,22 +472,21 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n                             }\n                         }\n                     }\n-                    case (ty::ty_obj(_)) {}\n+                    case (ty::ty_obj(_)) { }\n                 }\n-                vec::push(ds, rec(mut=mut,\n-                                  kind=field,\n-                                  outer_t=auto_unbox.t));\n+                vec::push(ds, rec(mut=mut, kind=field, outer_t=auto_unbox.t));\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n                 ex = base;\n             }\n             case (ast::expr_index(?base, _, _)) {\n-                auto auto_unbox = maybe_auto_unbox\n-                    (cx, ty::expr_ty(*cx.tcx, base));\n+                auto auto_unbox =\n+                    maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n-                        vec::push(ds, rec(mut=mt.mut != ast::imm,\n-                                          kind=index,\n-                                          outer_t=auto_unbox.t));\n+                        vec::push(ds,\n+                                  rec(mut=mt.mut != ast::imm,\n+                                      kind=index,\n+                                      outer_t=auto_unbox.t));\n                     }\n                 }\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n@@ -515,15 +497,14 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n                     auto base_t = ty::expr_ty(*cx.tcx, base);\n                     alt (ty::struct(*cx.tcx, base_t)) {\n                         case (ty::ty_box(?mt)) {\n-                            vec::push(ds, rec(mut=mt.mut != ast::imm,\n-                                              kind=unbox,\n-                                              outer_t=base_t));\n+                            vec::push(ds,\n+                                      rec(mut=mt.mut != ast::imm,\n+                                          kind=unbox,\n+                                          outer_t=base_t));\n                         }\n                     }\n                     ex = base;\n-                } else {\n-                    break;\n-                }\n+                } else { break; }\n             }\n             case (_) { break; }\n         }\n@@ -536,16 +517,12 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n }\n \n fn mut_field(&vec[deref] ds) -> bool {\n-    for (deref d in ds) {\n-        if (d.mut) { ret true; }\n-    }\n+    for (deref d in ds) { if (d.mut) { ret true; } }\n     ret false;\n }\n \n fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n-    for (deref d in ds) {\n-        if (d.mut) { ret some(d.outer_t); }\n-    }\n+    for (deref d in ds) { if (d.mut) { ret some(d.outer_t); } }\n     ret none;\n }\n \n@@ -554,14 +531,12 @@ fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n         case (ast::expr_path(_, ?ann)) {\n             ret some(ast::def_id_of_def(cx.dm.get(ann.id)));\n         }\n-        case (_) {\n-            ret none;\n-        }\n+        case (_) { ret none; }\n     }\n }\n \n-fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut)\n-    -> bool {\n+fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n+   bool {\n     fn get_mut(bool cur, &ty::mt mt) -> bool {\n         ret cur || mt.mut != ast::imm;\n     }\n@@ -599,13 +574,20 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut)\n                 }\n                 ret false;\n             }\n-            // These may contain anything.\n-            case (ty::ty_fn(_, _, _, _, _)) { ret true; }\n+            case (\n+                 // These may contain anything.\n+                 ty::ty_fn(_, _, _, _, _)) {\n+                ret true;\n+            }\n             case (ty::ty_obj(_)) { ret true; }\n-            // A type param may include everything, but can only be treated as\n-            // opaque downstream, and is thus safe unless we saw mutable\n-            // fields, in which case the whole thing can be overwritten.\n-            case (ty::ty_param(_)) { ret mut; }\n+            case (\n+                 // A type param may include everything, but can only be\n+                 // treated as opaque downstream, and is thus safe unless we\n+                 // saw mutable fields, in which case the whole thing can be\n+                 // overwritten.\n+                 ty::ty_param(_)) {\n+                ret mut;\n+            }\n             case (_) { ret false; }\n         }\n     }\n@@ -614,14 +596,13 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut)\n \n fn def_is_local(&ast::def d) -> bool {\n     ret alt (d) {\n-        case (ast::def_local(_)) { true }\n-        case (ast::def_arg(_)) { true }\n-        case (ast::def_obj_field(_)) { true }\n-        case (ast::def_binding(_)) { true }\n-        case (_) { false }\n-    };\n+            case (ast::def_local(_)) { true }\n+            case (ast::def_arg(_)) { true }\n+            case (ast::def_obj_field(_)) { true }\n+            case (ast::def_binding(_)) { true }\n+            case (_) { false }\n+        };\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "b64bab69eaf0c45c981a126faccfe75eaa298191", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 98, "deletions": 163, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::str;\n import std::uint;\n import std::vec;\n@@ -7,7 +8,6 @@ import std::io;\n import std::option;\n import std::option::some;\n import std::option::none;\n-\n import front::ast;\n import front::ast::*;\n import middle::trans;\n@@ -17,77 +17,90 @@ import back::x86;\n import back::link;\n import util::common;\n import pretty::ppaux::lit_to_str;\n-\n import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::False;\n \n const uint tag_paths = 0x01u;\n+\n const uint tag_items = 0x02u;\n \n const uint tag_paths_data = 0x03u;\n+\n const uint tag_paths_data_name = 0x04u;\n+\n const uint tag_paths_data_item = 0x05u;\n+\n const uint tag_paths_data_mod = 0x06u;\n \n const uint tag_def_id = 0x07u;\n \n const uint tag_items_data = 0x08u;\n+\n const uint tag_items_data_item = 0x09u;\n+\n const uint tag_items_data_item_kind = 0x0au;\n+\n const uint tag_items_data_item_ty_param_count = 0x0bu;\n+\n const uint tag_items_data_item_type = 0x0cu;\n+\n const uint tag_items_data_item_symbol = 0x0du;\n+\n const uint tag_items_data_item_variant = 0x0eu;\n+\n const uint tag_items_data_item_tag_id = 0x0fu;\n \n const uint tag_index = 0x11u;\n+\n const uint tag_index_buckets = 0x12u;\n+\n const uint tag_index_buckets_bucket = 0x13u;\n+\n const uint tag_index_buckets_bucket_elt = 0x14u;\n+\n const uint tag_index_table = 0x15u;\n \n const uint tag_meta_export = 0x16u;\n+\n const uint tag_meta_local = 0x17u;\n+\n const uint tag_meta_item = 0x18u;\n+\n const uint tag_meta_item_key = 0x19u;\n+\n const uint tag_meta_item_value = 0x20u;\n \n+\n // Type encoding\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-\n type ty_abbrev = rec(uint pos, uint len, str s);\n \n-tag abbrev_ctxt {\n-    ac_no_abbrevs;\n-    ac_use_abbrevs(hashmap[ty::t, ty_abbrev]);\n-}\n+tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap[ty::t, ty_abbrev]); }\n \n mod Encode {\n+    type ctxt =\n+        rec(fn(&ast::def_id) -> str  ds, // Def -> str Callback:\n+\n+            ty::ctxt tcx, // The type context.\n \n-    type ctxt = rec(\n-        fn(&ast::def_id) -> str ds,          // Def -> str Callback:\n-        ty::ctxt tcx,                        // The type context.\n-        abbrev_ctxt abbrevs\n-    );\n+            abbrev_ctxt abbrevs);\n \n     fn cx_uses_abbrevs(&@ctxt cx) -> bool {\n         alt (cx.abbrevs) {\n-            case (ac_no_abbrevs)     { ret false; }\n+            case (ac_no_abbrevs) { ret false; }\n             case (ac_use_abbrevs(_)) { ret true; }\n         }\n     }\n-\n     fn ty_str(&@ctxt cx, &ty::t t) -> str {\n         assert (!cx_uses_abbrevs(cx));\n         auto sw = io::string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();\n     }\n-\n     fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n         alt (cx.abbrevs) {\n             case (ac_no_abbrevs) {\n@@ -105,32 +118,26 @@ mod Encode {\n             }\n             case (ac_use_abbrevs(?abbrevs)) {\n                 alt (abbrevs.find(t)) {\n-                    case (some(?a)) {\n-                        w.write_str(a.s);\n-                        ret;\n-                    }\n+                    case (some(?a)) { w.write_str(a.s); ret; }\n                     case (none) {\n                         auto pos = w.get_buf_writer().tell();\n                         auto ss = enc_sty(w, cx, ty::struct(cx.tcx, t));\n                         auto end = w.get_buf_writer().tell();\n-                        auto len = end-pos;\n+                        auto len = end - pos;\n                         fn estimate_sz(uint u) -> uint {\n                             auto n = u;\n                             auto len = 0u;\n-                            while (n != 0u) {\n-                                len += 1u;\n-                                n = n >> 4u;\n-                            }\n+                            while (n != 0u) { len += 1u; n = n >> 4u; }\n                             ret len;\n                         }\n                         auto abbrev_len =\n                             3u + estimate_sz(pos) + estimate_sz(len);\n-\n                         if (abbrev_len < len) {\n                             // I.e. it's actually an abbreviation.\n-                            auto s = (\"#\"\n-                                      + uint::to_str(pos, 16u) + \":\"\n-                                      + uint::to_str(len, 16u) + \"#\");\n+\n+                            auto s =\n+                                \"#\" + uint::to_str(pos, 16u) + \":\" +\n+                                    uint::to_str(len, 16u) + \"#\";\n                             auto a = rec(pos=pos, len=len, s=s);\n                             abbrevs.insert(t, a);\n                         }\n@@ -140,16 +147,14 @@ mod Encode {\n             }\n         }\n     }\n-\n     fn enc_mt(&io::writer w, &@ctxt cx, &ty::mt mt) {\n         alt (mt.mut) {\n-            case (ast::imm)       { }\n-            case (ast::mut)       { w.write_char('m'); }\n+            case (ast::imm) { }\n+            case (ast::mut) { w.write_char('m'); }\n             case (ast::maybe_mut) { w.write_char('?'); }\n         }\n         enc_ty(w, cx, mt.ty);\n     }\n-\n     fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         alt (st) {\n             case (ty::ty_nil) { w.write_char('n'); }\n@@ -172,29 +177,25 @@ mod Encode {\n                     case (common::ty_f64) { w.write_str(\"MF\"); }\n                 }\n             }\n-            case (ty::ty_char) {w.write_char('c');}\n-            case (ty::ty_str) {w.write_char('s');}\n-            case (ty::ty_istr) {w.write_char('S');}\n-            case (ty::ty_tag(?def,?tys)) {\n+            case (ty::ty_char) { w.write_char('c'); }\n+            case (ty::ty_str) { w.write_char('s'); }\n+            case (ty::ty_istr) { w.write_char('S'); }\n+            case (ty::ty_tag(?def, ?tys)) {\n                 w.write_str(\"t[\");\n                 w.write_str(cx.ds(def));\n                 w.write_char('|');\n-                for (ty::t t in tys) {\n-                    enc_ty(w, cx, t);\n-                }\n+                for (ty::t t in tys) { enc_ty(w, cx, t); }\n                 w.write_char(']');\n             }\n-            case (ty::ty_box(?mt)) {w.write_char('@'); enc_mt(w, cx, mt); }\n-            case (ty::ty_ptr(?mt)) {w.write_char('*'); enc_mt(w, cx, mt); }\n-            case (ty::ty_vec(?mt)) {w.write_char('V'); enc_mt(w, cx, mt); }\n-            case (ty::ty_ivec(?mt)) {w.write_char('I'); enc_mt(w, cx, mt); }\n-            case (ty::ty_port(?t)) {w.write_char('P'); enc_ty(w, cx, t); }\n-            case (ty::ty_chan(?t)) {w.write_char('C'); enc_ty(w, cx, t); }\n+            case (ty::ty_box(?mt)) { w.write_char('@'); enc_mt(w, cx, mt); }\n+            case (ty::ty_ptr(?mt)) { w.write_char('*'); enc_mt(w, cx, mt); }\n+            case (ty::ty_vec(?mt)) { w.write_char('V'); enc_mt(w, cx, mt); }\n+            case (ty::ty_ivec(?mt)) { w.write_char('I'); enc_mt(w, cx, mt); }\n+            case (ty::ty_port(?t)) { w.write_char('P'); enc_ty(w, cx, t); }\n+            case (ty::ty_chan(?t)) { w.write_char('C'); enc_ty(w, cx, t); }\n             case (ty::ty_tup(?mts)) {\n                 w.write_str(\"T[\");\n-                for (ty::mt mt in mts) {\n-                    enc_mt(w, cx, mt);\n-                }\n+                for (ty::mt mt in mts) { enc_mt(w, cx, mt); }\n                 w.write_char(']');\n             }\n             case (ty::ty_rec(?fields)) {\n@@ -206,11 +207,11 @@ mod Encode {\n                 }\n                 w.write_char(']');\n             }\n-            case (ty::ty_fn(?proto,?args,?out,?cf,?constrs)) {\n+            case (ty::ty_fn(?proto, ?args, ?out, ?cf, ?constrs)) {\n                 enc_proto(w, proto);\n                 enc_ty_fn(w, cx, args, out, cf, constrs);\n             }\n-            case (ty::ty_native_fn(?abi,?args,?out)) {\n+            case (ty::ty_native_fn(?abi, ?args, ?out)) {\n                 w.write_char('N');\n                 alt (abi) {\n                     case (ast::native_abi_rust) { w.write_char('r'); }\n@@ -236,23 +237,21 @@ mod Encode {\n                 w.write_char('X');\n                 w.write_str(common::istr(id));\n             }\n-            case (ty::ty_native) {w.write_char('E');}\n+            case (ty::ty_native) { w.write_char('E'); }\n             case (ty::ty_param(?id)) {\n                 w.write_char('p');\n                 w.write_str(common::uistr(id));\n             }\n-            case (ty::ty_type) {w.write_char('Y');}\n-            case (ty::ty_task) {w.write_char('a');}\n+            case (ty::ty_type) { w.write_char('Y'); }\n+            case (ty::ty_task) { w.write_char('a'); }\n         }\n     }\n-\n     fn enc_proto(&io::writer w, ast::proto proto) {\n         alt (proto) {\n             case (ast::proto_iter) { w.write_char('W'); }\n             case (ast::proto_fn) { w.write_char('F'); }\n         }\n     }\n-\n     fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n                  &ast::controlflow cf, &vec[@ast::constr] constrs) {\n         w.write_char('[');\n@@ -262,54 +261,40 @@ mod Encode {\n                     w.write_char('&');\n                     if (mut) { w.write_char('m'); }\n                 }\n-                case (ty::mo_val) {}\n+                case (ty::mo_val) { }\n             }\n             enc_ty(w, cx, arg.ty);\n         }\n         w.write_char(']');\n         alt (cf) {\n-            case (ast::noreturn) {\n-                w.write_char('!');\n-            }\n-            case (_) {\n-                enc_ty(w, cx, out);\n-            }\n+            case (ast::noreturn) { w.write_char('!'); }\n+            case (_) { enc_ty(w, cx, out); }\n         }\n         auto colon = true;\n         for (@ast::constr c in constrs) {\n-            if (colon) { w.write_char(':'); colon = false; }\n-            else { w.write_char(','); }\n+            if (colon) {\n+                w.write_char(':');\n+                colon = false;\n+            } else { w.write_char(','); }\n             enc_constr(w, cx, c);\n         }\n     }\n-\n     fn enc_constr(&io::writer w, &@ctxt cx, &@ast::constr c) {\n         w.write_str(path_to_str(c.node.path));\n         w.write_char('(');\n         // FIXME\n         //   w.write_str(cx.ds(c.node.id));\n+\n         auto comma = false;\n         for (@constr_arg a in c.node.args) {\n-            if (comma) {\n-                w.write_char(',');\n-            }\n-            else {\n-                comma = true;\n-            }\n+            if (comma) { w.write_char(','); } else { comma = true; }\n             alt (a.node) {\n-                case (carg_base) {\n-                    w.write_char('*');\n-                }\n-                case (carg_ident(?i)) {\n-                    w.write_uint(i);\n-                }\n-                case (carg_lit(?l)) {\n-                    w.write_str(lit_to_str(l));\n-                }\n+                case (carg_base) { w.write_char('*'); }\n+                case (carg_ident(?i)) { w.write_uint(i); }\n+                case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }\n             }\n         }\n     }\n-\n }\n \n \n@@ -320,7 +305,6 @@ fn C_postr(&str s) -> ValueRef {\n \n \n // Path table encoding\n-\n fn encode_name(&ebml::writer ebml_w, &str name) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(str::bytes(name));\n@@ -333,8 +317,7 @@ fn encode_def_id(&ebml::writer ebml_w, &ast::def_id id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&ebml::writer ebml_w,\n-                            &vec[ast::variant] variants,\n+fn encode_tag_variant_paths(&ebml::writer ebml_w, &vec[ast::variant] variants,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (ast::variant variant in variants) {\n@@ -346,17 +329,14 @@ fn encode_tag_variant_paths(&ebml::writer ebml_w,\n     }\n }\n \n-fn add_to_index(&ebml::writer ebml_w,\n-                &vec[str] path,\n-                &mutable vec[tup(str, uint)] index,\n-                &str name) {\n+fn add_to_index(&ebml::writer ebml_w, &vec[str] path,\n+                &mutable vec[tup(str, uint)] index, &str name) {\n     auto full_path = path + [name];\n     index += [tup(str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n }\n \n fn encode_native_module_item_paths(&ebml::writer ebml_w,\n-                                   &ast::native_mod nmod,\n-                                   &vec[str] path,\n+                                   &ast::native_mod nmod, &vec[str] path,\n                                    &mutable vec[tup(str, uint)] index) {\n     for (@ast::native_item nitem in nmod.items) {\n         alt (nitem.node) {\n@@ -378,15 +358,11 @@ fn encode_native_module_item_paths(&ebml::writer ebml_w,\n     }\n }\n \n-fn encode_module_item_paths(&ebml::writer ebml_w,\n-                            &ast::_mod module,\n+fn encode_module_item_paths(&ebml::writer ebml_w, &ast::_mod module,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (@ast::item it in module.items) {\n-        if (!ast::is_exported(ast::item_ident(it), module)) {\n-            cont;\n-        }\n-\n+        if (!ast::is_exported(ast::item_ident(it), module)) { cont; }\n         alt (it.node) {\n             case (ast::item_const(?id, _, ?tps, _, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n@@ -432,7 +408,6 @@ fn encode_module_item_paths(&ebml::writer ebml_w,\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 ebml::end_tag(ebml_w);\n-\n                 encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n             case (ast::item_obj(?id, _, ?tps, _, ?odid, ?ann)) {\n@@ -441,7 +416,6 @@ fn encode_module_item_paths(&ebml::writer ebml_w,\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, odid.ctor);\n                 ebml::end_tag(ebml_w);\n-\n                 add_to_index(ebml_w, path, index, id);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n@@ -452,8 +426,8 @@ fn encode_module_item_paths(&ebml::writer ebml_w,\n     }\n }\n \n-fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate)\n-        -> vec[tup(str, uint)] {\n+fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate) ->\n+   vec[tup(str, uint)] {\n     let vec[tup(str, uint)] index = [];\n     let vec[str] path = [];\n     ebml::start_tag(ebml_w, tag_paths);\n@@ -464,16 +438,13 @@ fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate)\n \n \n // Item info table encoding\n-\n fn encode_kind(&ebml::writer ebml_w, u8 c) {\n     ebml::start_tag(ebml_w, tag_items_data_item_kind);\n     ebml_w.writer.write([c]);\n     ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(&ast::def_id did) -> str {\n-    ret #fmt(\"%d:%d\", did._0, did._1);\n-}\n+fn def_to_str(&ast::def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n \n fn encode_type_param_count(&ebml::writer ebml_w, &vec[ast::ty_param] tps) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n@@ -489,10 +460,9 @@ fn encode_variant_id(&ebml::writer ebml_w, &ast::def_id vid) {\n \n fn encode_type(&@trans::crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n     ebml::start_tag(ebml_w, tag_items_data_item_type);\n-\n     auto f = def_to_str;\n-    auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx,\n-                            abbrevs=ac_use_abbrevs(cx.type_abbrevs));\n+    auto ty_str_ctxt =\n+        @rec(ds=f, tcx=cx.tcx, abbrevs=ac_use_abbrevs(cx.type_abbrevs));\n     Encode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n     ebml::end_tag(ebml_w);\n }\n@@ -517,15 +487,12 @@ fn encode_tag_id(&ebml::writer ebml_w, &ast::def_id id) {\n     ebml::end_tag(ebml_w);\n }\n \n-\n-\n fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                            &ast::def_id did, &vec[ast::variant] variants,\n                            &mutable vec[tup(int, uint)] index,\n                            &vec[ast::ty_param] ty_params) {\n     for (ast::variant variant in variants) {\n         index += [tup(variant.node.id._1, ebml_w.writer.tell())];\n-\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n@@ -590,7 +557,6 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                 encode_variant_id(ebml_w, v.node.id);\n             }\n             ebml::end_tag(ebml_w);\n-\n             encode_tag_variant_info(cx, ebml_w, did, variants, index, tps);\n         }\n         case (ast::item_obj(?id, _, ?tps, _, ?odid, ?ann)) {\n@@ -602,7 +568,6 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n             encode_type(cx, ebml_w, fn_ty);\n             encode_symbol(cx, ebml_w, odid.ctor);\n             ebml::end_tag(ebml_w);\n-\n             index += [tup(odid.ty._1, ebml_w.writer.tell())];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n@@ -634,69 +599,54 @@ fn encode_info_for_native_item(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w)\n-        -> vec[tup(int, uint)] {\n+fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w) ->\n+   vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = [];\n-\n     ebml::start_tag(ebml_w, tag_items_data);\n     for each (@tup(ast::def_id, @ast::item) kvp in cx.items.items()) {\n         index += [tup(kvp._0._1, ebml_w.writer.tell())];\n         encode_info_for_item(cx, ebml_w, kvp._1, index);\n     }\n     for each (@tup(ast::def_id, @ast::native_item) kvp in\n-            cx.native_items.items()) {\n+             cx.native_items.items()) {\n         index += [tup(kvp._0._1, ebml_w.writer.tell())];\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n     ebml::end_tag(ebml_w);\n-\n     ret index;\n }\n \n \n // Path and definition ID indexing\n \n // djb's cdb hashes.\n-\n-fn hash_def_num(&int def_num) -> uint {\n-    ret 177573u ^ (def_num as uint);\n-}\n+fn hash_def_num(&int def_num) -> uint { ret 177573u ^ (def_num as uint); }\n \n fn hash_path(&str s) -> uint {\n     auto h = 5381u;\n-    for (u8 ch in str::bytes(s)) {\n-        h = ((h << 5u) + h) ^ (ch as uint);\n-    }\n+    for (u8 ch in str::bytes(s)) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n \n-fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n-        -> vec[vec[tup(T, uint)]] {\n+fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint  hash_fn) ->\n+   vec[vec[tup(T, uint)]] {\n     let vec[mutable vec[tup(T, uint)]] buckets = vec::empty_mut();\n-    for each (uint i in uint::range(0u, 256u)) {\n-        buckets += [mutable []];\n-    }\n-\n+    for each (uint i in uint::range(0u, 256u)) { buckets += [mutable []]; }\n     for (tup(T, uint) elt in index) {\n         auto h = hash_fn(elt._0);\n         buckets.(h % 256u) += [elt];\n     }\n-\n     ret vec::freeze(buckets);\n }\n \n-fn encode_index[T](&ebml::writer ebml_w,\n-                   &vec[vec[tup(T, uint)]] buckets,\n-                   fn(&io::writer, &T) write_fn) {\n+fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+                   fn(&io::writer, &T)  write_fn) {\n     auto writer = io::new_writer_(ebml_w.writer);\n-\n     ebml::start_tag(ebml_w, tag_index);\n-\n     let vec[uint] bucket_locs = [];\n     ebml::start_tag(ebml_w, tag_index_buckets);\n     for (vec[tup(T, uint)] bucket in buckets) {\n         bucket_locs += [ebml_w.writer.tell()];\n-\n         ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n         for (tup(T, uint) elt in bucket) {\n             ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n@@ -707,27 +657,19 @@ fn encode_index[T](&ebml::writer ebml_w,\n         ebml::end_tag(ebml_w);\n     }\n     ebml::end_tag(ebml_w);\n-\n     ebml::start_tag(ebml_w, tag_index_table);\n-    for (uint pos in bucket_locs) {\n-        writer.write_be_uint(pos, 4u);\n-    }\n+    for (uint pos in bucket_locs) { writer.write_be_uint(pos, 4u); }\n     ebml::end_tag(ebml_w);\n-\n     ebml::end_tag(ebml_w);\n }\n \n-fn write_str(&io::writer writer, &str s) {\n-    writer.write_str(s);\n-}\n+fn write_str(&io::writer writer, &str s) { writer.write_str(s); }\n \n fn write_int(&io::writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n-\n fn encode_meta_items(&ebml::writer ebml_w, &ast::crate crate) {\n-\n     fn encode_meta_item(&ebml::writer ebml_w, &ast::meta_item mi) {\n         ebml::start_tag(ebml_w, tag_meta_item);\n         ebml::start_tag(ebml_w, tag_meta_item_key);\n@@ -738,67 +680,60 @@ fn encode_meta_items(&ebml::writer ebml_w, &ast::crate crate) {\n         ebml::end_tag(ebml_w);\n         ebml::end_tag(ebml_w);\n     }\n-\n     ebml::start_tag(ebml_w, tag_meta_export);\n     for each (@ast::meta_item mi in link::crate_export_metas(crate)) {\n         encode_meta_item(ebml_w, *mi);\n     }\n     ebml::end_tag(ebml_w);\n-\n     ebml::start_tag(ebml_w, tag_meta_local);\n     for each (@ast::meta_item mi in link::crate_local_metas(crate)) {\n         encode_meta_item(ebml_w, *mi);\n     }\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate)\n-        -> ValueRef {\n+fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) -> ValueRef {\n     auto string_w = io::string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n     auto ebml_w = ebml::create_writer(buf_w);\n-\n     // Encode the meta items\n-    encode_meta_items(ebml_w, *crate);\n \n+    encode_meta_items(ebml_w, *crate);\n     // Encode and index the paths.\n+\n     ebml::start_tag(ebml_w, tag_paths);\n     auto paths_index = encode_item_paths(ebml_w, crate);\n     auto str_writer = write_str;\n     auto path_hasher = hash_path;\n     auto paths_buckets = create_index[str](paths_index, path_hasher);\n     encode_index[str](ebml_w, paths_buckets, str_writer);\n     ebml::end_tag(ebml_w);\n-\n     // Encode and index the items.\n+\n     ebml::start_tag(ebml_w, tag_items);\n     auto items_index = encode_info_for_items(cx, ebml_w);\n     auto int_writer = write_int;\n     auto item_hasher = hash_def_num;\n     auto items_buckets = create_index[int](items_index, item_hasher);\n     encode_index[int](ebml_w, items_buckets, int_writer);\n     ebml::end_tag(ebml_w);\n-\n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n-    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n \n+    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n     ret C_postr(string_w.get_str());\n }\n \n fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n-    if (!cx.sess.get_opts().shared) {\n-        ret;\n-    }\n-\n+    if (!cx.sess.get_opts().shared) { ret; }\n     auto llmeta = encode_metadata(cx, crate);\n     auto llconst = trans::C_struct([llmeta]);\n-    auto llglobal = llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n-                                       str::buf(\"rust_metadata\"));\n+    auto llglobal =\n+        llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n+                            str::buf(\"rust_metadata\"));\n     llvm::LLVMSetInitializer(llglobal, llconst);\n     llvm::LLVMSetSection(llglobal, str::buf(x86::get_meta_sect_name()));\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "1da8fa0d410859483aa1b9e81f3e186764f2f14f", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 353, "deletions": 388, "changes": 741, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import front::ast;\n import front::ast::ident;\n import front::ast::def;\n@@ -23,6 +24,7 @@ import std::option::none;\n import std::str;\n import std::vec;\n \n+\n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n // and then uses this information to resolve the imports. The second pass\n@@ -33,92 +35,106 @@ import std::vec;\n // crate. The parser doesn't assign a def_id to this module.\n // (FIXME See https://github.com/graydon/rust/issues/358 for the reason this\n //  isn't a const.)\n-\n tag scope {\n     scope_crate(@ast::crate);\n     scope_item(@ast::item);\n     scope_fn(ast::fn_decl, vec[ast::ty_param]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local_); // there's only 1 decl per loop.\n+\n     scope_block(ast::block);\n     scope_arm(ast::arm);\n }\n+\n type scopes = list[scope];\n \n tag import_state {\n     todo(@ast::view_item, scopes); // only used for explicit imports\n+\n     resolving(span);\n-    resolved(option::t[def] /* value */,\n-             option::t[def] /* type */,\n-             option::t[def] /* module */);\n+    resolved(option::t[def],\n+\n+             /* value */\n+             option::t[def],\n+\n+             /* type */\n+             option::t[def]);\n+    /* module */\n+\n }\n \n-type ext_hash = hashmap[tup(def_id,str,namespace),def];\n+type ext_hash = hashmap[tup(def_id, str, namespace), def];\n+\n fn new_ext_hash() -> ext_hash {\n-    fn hash(&tup(def_id,str,namespace) v) -> uint {\n-        ret str::hash(v._1) + util::common::hash_def(v._0) + (alt (v._2) {\n-            case (ns_value) { 1u }\n-            case (ns_type) { 2u }\n-            case (ns_module) { 3u }\n-        });\n+    fn hash(&tup(def_id, str, namespace) v) -> uint {\n+        ret str::hash(v._1) + util::common::hash_def(v._0) +\n+                alt (v._2) {\n+                    case (ns_value) { 1u }\n+                    case (ns_type) { 2u }\n+                    case (ns_module) { 3u }\n+                };\n     }\n-    fn eq(&tup(def_id,str,namespace) v1,\n-          &tup(def_id,str,namespace) v2) -> bool {\n-        ret util::common::def_eq(v1._0, v2._0) &&\n-            str::eq(v1._1, v2._1) &&\n-            v1._2 == v2._2;\n+    fn eq(&tup(def_id, str, namespace) v1, &tup(def_id, str, namespace) v2) ->\n+       bool {\n+        ret util::common::def_eq(v1._0, v2._0) && str::eq(v1._1, v2._1) &&\n+                v1._2 == v2._2;\n     }\n-    ret std::map::mk_hashmap[tup(def_id,str,namespace),def](hash, eq);\n+    ret std::map::mk_hashmap[tup(def_id, str, namespace), def](hash, eq);\n }\n \n tag mod_index_entry {\n     mie_view_item(@ast::view_item);\n     mie_item(@ast::item);\n     mie_native_item(@ast::native_item);\n-    mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n+    mie_tag_variant(@ast::item, /* tag item */uint);\n+    /* variant index */\n+\n }\n-type mod_index = hashmap[ident,list[mod_index_entry]];\n \n-type indexed_mod = rec(option::t[ast::_mod] m, \n-                       mod_index index,\n-                       mutable vec[def] glob_imports,\n-                       hashmap[str,import_state] glob_imported_names);\n+type mod_index = hashmap[ident, list[mod_index_entry]];\n+\n+type indexed_mod =\n+    rec(option::t[ast::_mod] m,\n+        mod_index index,\n+        mutable vec[def] glob_imports,\n+        hashmap[str, import_state] glob_imported_names);\n+\n+\n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n+\n // It should be safe to use index to memoize lookups of globbed names.\n+type crate_map = hashmap[uint, ast::crate_num];\n \n-type crate_map = hashmap[uint,ast::crate_num];\n+type def_map = hashmap[uint, def];\n \n-type def_map = hashmap[uint,def];\n+type env =\n+    rec(crate_map crate_map,\n+        def_map def_map,\n+        hashmap[def_id, @ast::item] ast_map,\n+        hashmap[ast::def_num, import_state] imports,\n+        hashmap[ast::def_num, @indexed_mod] mod_map,\n+        hashmap[def_id, vec[ident]] ext_map,\n+        ext_hash ext_cache,\n+        session sess);\n \n-type env = rec(crate_map crate_map,\n-               def_map def_map,\n-               hashmap[def_id,@ast::item] ast_map,\n-               hashmap[ast::def_num,import_state] imports,\n-               hashmap[ast::def_num,@indexed_mod] mod_map,\n-               hashmap[def_id,vec[ident]] ext_map,\n-               ext_hash ext_cache,\n-               session sess);\n \n // Used to distinguish between lookups from outside and from inside modules,\n // since export restrictions should only be applied for the former.\n tag dir { inside; outside; }\n \n-tag namespace {\n-    ns_value;\n-    ns_type;\n-    ns_module;\n-}\n+tag namespace { ns_value; ns_type; ns_module; }\n \n fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n-    auto e = @rec(crate_map = new_uint_hash[ast::crate_num](),\n-                  def_map = new_uint_hash[def](),\n-                  ast_map = new_def_hash[@ast::item](),\n-                  imports = new_int_hash[import_state](),\n-                  mod_map = new_int_hash[@indexed_mod](),\n-                  ext_map = new_def_hash[vec[ident]](),\n-                  ext_cache = new_ext_hash(),\n-                  sess = sess);\n+    auto e =\n+        @rec(crate_map=new_uint_hash[ast::crate_num](),\n+             def_map=new_uint_hash[def](),\n+             ast_map=new_def_hash[@ast::item](),\n+             imports=new_int_hash[import_state](),\n+             mod_map=new_int_hash[@indexed_mod](),\n+             ext_map=new_def_hash[vec[ident]](),\n+             ext_cache=new_ext_hash(),\n+             sess=sess);\n     creader::read_crates(sess, e.crate_map, *crate);\n     map_crate(e, crate);\n     resolve_imports(*e);\n@@ -130,55 +146,55 @@ fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n \n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n-\n fn map_crate(&@env e, &@ast::crate c) {\n     // First, find all the modules, and index the names that they contain\n+\n     auto v_map_mod =\n-        @rec(visit_view_item = bind index_vi(e, _, _, _),\n-             visit_item = bind index_i(e, _, _, _)\n+        @rec(visit_view_item=bind index_vi(e, _, _, _),\n+             visit_item=bind index_i(e, _, _, _)\n              with *visit::default_visitor[scopes]());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil),\n                        visit::vtor(v_map_mod));\n     // Register the top-level mod \n-    e.mod_map.insert(-1, @rec(m=some(c.node.module),\n-                              index=index_mod(c.node.module),\n-                              mutable glob_imports=vec::empty[def](),\n-                              glob_imported_names\n-                              =new_str_hash[import_state]()));\n \n+    e.mod_map.insert(-1,\n+                     @rec(m=some(c.node.module),\n+                          index=index_mod(c.node.module),\n+                          mutable glob_imports=vec::empty[def](),\n+                          glob_imported_names=new_str_hash[import_state]()));\n     fn index_vi(@env e, &@ast::view_item i, &scopes sc, &vt[scopes] v) {\n         alt (i.node) {\n             case (ast::view_item_import(_, ?ids, ?defid)) {\n                 e.imports.insert(defid._1, todo(i, sc));\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n-\n     fn index_i(@env e, &@ast::item i, &scopes sc, &vt[scopes] v) {\n         visit_item_with_scope(i, sc, v);\n         alt (i.node) {\n             case (ast::item_mod(_, ?md, _, ?defid)) {\n-                e.mod_map.insert(defid._1, \n-                                 @rec(m=some(md), index=index_mod(md),\n+                auto s = new_str_hash[import_state]();\n+                e.mod_map.insert(defid._1,\n+                                 @rec(m=some(md),\n+                                      index=index_mod(md),\n                                       mutable glob_imports=vec::empty[def](),\n-                                      glob_imported_names\n-                                      =new_str_hash[import_state]()));\n+                                      glob_imported_names=s));\n                 e.ast_map.insert(defid, i);\n             }\n             case (ast::item_native_mod(_, ?nmd, _, ?defid)) {\n-                e.mod_map.insert(defid._1, \n-                                 @rec(m=none[ast::_mod], \n+                auto s = new_str_hash[import_state]();\n+                e.mod_map.insert(defid._1,\n+                                 @rec(m=none[ast::_mod],\n                                       index=index_nmod(nmd),\n                                       mutable glob_imports=vec::empty[def](),\n-                                      glob_imported_names\n-                                      =new_str_hash[import_state]()));\n+                                      glob_imported_names=s));\n                 e.ast_map.insert(defid, i);\n             }\n             case (ast::item_const(_, _, _, _, ?defid, _)) {\n                 e.ast_map.insert(defid, i);\n             }\n-            case (ast::item_fn(_, _, _, _, ?defid, _)) { \n+            case (ast::item_fn(_, _, _, _, ?defid, _)) {\n                 e.ast_map.insert(defid, i);\n             }\n             case (ast::item_ty(_, _, _, _, ?defid, _)) {\n@@ -187,108 +203,101 @@ fn map_crate(&@env e, &@ast::crate c) {\n             case (ast::item_tag(_, _, _, _, ?defid, _)) {\n                 e.ast_map.insert(defid, i);\n             }\n-            case (ast::item_obj(_, _, _, _, ?obj_def_ids, _)) { \n+            case (ast::item_obj(_, _, _, _, ?obj_def_ids, _)) {\n                 e.ast_map.insert(obj_def_ids.ty, i);\n                 e.ast_map.insert(obj_def_ids.ctor, i);\n             }\n         }\n     }\n-\n     // Next, assemble the links for globbed imports.\n+\n     auto v_link_glob =\n-        @rec(visit_view_item = bind link_glob(e, _, _, _),\n-             visit_item = visit_item_with_scope\n+        @rec(visit_view_item=bind link_glob(e, _, _, _),\n+             visit_item=visit_item_with_scope\n              with *visit::default_visitor[scopes]());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil),\n                        visit::vtor(v_link_glob));\n-            \n     fn link_glob(@env e, &@ast::view_item vi, &scopes sc, &vt[scopes] v) {\n         fn find_mod(@env e, scopes sc) -> @indexed_mod {\n             alt (sc) {\n                 case (cons(scope_item(?i), ?tl)) {\n-                    alt(i.node) {\n+                    alt (i.node) {\n                         case (ast::item_mod(_, _, _, ?defid)) {\n                             ret e.mod_map.get(defid._1);\n                         }\n                         case (ast::item_native_mod(_, _, _, ?defid)) {\n                             ret e.mod_map.get(defid._1);\n                         }\n-                        case (_) {\n-                            be find_mod(e, *tl);\n-                        }\n+                        case (_) { be find_mod(e, *tl); }\n                     }\n                 }\n                 case (_) {\n                     ret e.mod_map.get(-1); //top-level\n+\n                 }\n             }\n         }\n-\n         alt (vi.node) {\n-            //if it really is a glob import, that is\n-            case (ast::view_item_import_glob(?path, _)) {\n-                find_mod(e, sc).glob_imports \n-                    += [follow_import(*e, sc, path, vi.span)];\n+            case (\n+                 //if it really is a glob import, that is\n+                 ast::view_item_import_glob(?path, _)) {\n+                find_mod(e, sc).glob_imports +=\n+                    [follow_import(*e, sc, path, vi.span)];\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n-        \n     }\n-    \n }\n \n fn resolve_imports(&env e) {\n     for each (@tup(ast::def_num, import_state) it in e.imports.items()) {\n         alt (it._1) {\n-            case (todo(?item, ?sc)) {\n-                resolve_import(e, item, sc);\n-            }\n-            case (resolved(_, _, _)) {}\n+            case (todo(?item, ?sc)) { resolve_import(e, item, sc); }\n+            case (resolved(_, _, _)) { }\n         }\n     }\n }\n \n fn resolve_names(&@env e, &@ast::crate c) {\n-    auto v = @rec(visit_native_item = visit_native_item_with_scope,\n-                  visit_item = visit_item_with_scope,\n-                  visit_block = visit_block_with_scope,\n-                  visit_arm = bind walk_arm(e, _, _, _),\n-                  visit_expr = bind walk_expr(e, _, _, _),\n-                  visit_ty = bind walk_ty(e, _, _, _),\n-                  visit_fn = visit_fn_with_scope,\n-                  visit_constr = bind walk_constr(e, _, _, _)\n-                  with *visit::default_visitor());\n-    visit::visit_crate(*c, cons(scope_crate(c), @nil),\n-                       visit::vtor(v));\n-\n+    auto v =\n+        @rec(visit_native_item=visit_native_item_with_scope,\n+             visit_item=visit_item_with_scope,\n+             visit_block=visit_block_with_scope,\n+             visit_arm=bind walk_arm(e, _, _, _),\n+             visit_expr=bind walk_expr(e, _, _, _),\n+             visit_ty=bind walk_ty(e, _, _, _),\n+             visit_fn=visit_fn_with_scope,\n+             visit_constr=bind walk_constr(e, _, _, _)\n+             with *visit::default_visitor());\n+    visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n         visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n             case (ast::expr_path(?p, ?a)) {\n-                auto df = lookup_path_strict(*e, sc, exp.span,\n-                                             p.node.idents, ns_value);\n+                auto df =\n+                    lookup_path_strict(*e, sc, exp.span, p.node.idents,\n+                                       ns_value);\n                 e.def_map.insert(a.id, df);\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n-\n     fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        auto new_def = lookup_path_strict(*e, sc, c.span,\n-                                          c.node.path.node.idents,\n-                                          ns_value);\n+        auto new_def =\n+            lookup_path_strict(*e, sc, c.span, c.node.path.node.idents,\n+                               ns_value);\n         e.def_map.insert(c.node.ann.id, new_def);\n     }\n-\n     fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n             case (ast::ty_path(?p, ?a)) {\n-                auto new_def = lookup_path_strict(*e, sc, t.span,\n-                                                  p.node.idents, ns_type);\n+                auto new_def =\n+                    lookup_path_strict(*e, sc, t.span, p.node.idents,\n+                                       ns_type);\n                 e.def_map.insert(a.id, new_def);\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n@@ -298,112 +307,111 @@ fn resolve_names(&@env e, &@ast::crate c) {\n     fn walk_pat(&env e, &scopes sc, &@ast::pat pat) {\n         alt (pat.node) {\n             case (ast::pat_tag(?p, ?children, ?a)) {\n-                auto fnd = lookup_path_strict(e, sc, p.span, p.node.idents,\n-                                              ns_value);\n+                auto fnd =\n+                    lookup_path_strict(e, sc, p.span, p.node.idents,\n+                                       ns_value);\n                 alt (fnd) {\n                     case (ast::def_variant(?did, ?vid)) {\n                         e.def_map.insert(a.id, fnd);\n                     }\n                     case (_) {\n-                        e.sess.span_err(p.span, \"not a tag variant: \" +\n-                                        ast::path_name(p));\n+                        e.sess.span_err(p.span,\n+                                        \"not a tag variant: \" +\n+                                            ast::path_name(p));\n                     }\n                 }\n-                for (@ast::pat child in children) {\n-                    walk_pat(e, sc, child);\n-                }\n+                for (@ast::pat child in children) { walk_pat(e, sc, child); }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n }\n \n-// Visit helper functions\n \n+// Visit helper functions\n fn visit_item_with_scope(&@ast::item i, &scopes sc, &vt[scopes] v) {\n     visit::visit_item(i, cons(scope_item(i), @sc), v);\n }\n-fn visit_native_item_with_scope(&@ast::native_item ni,\n-                                &scopes sc, &vt[scopes] v) {\n+\n+fn visit_native_item_with_scope(&@ast::native_item ni, &scopes sc,\n+                                &vt[scopes] v) {\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n+\n fn visit_fn_with_scope(&ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n-                       &ident name, &def_id d_id, &ann a,\n-                       &scopes sc, &vt[scopes] v) {\n-    visit::visit_fn(f, tp, sp, name, d_id, a,\n-                    cons(scope_fn(f.decl, tp), @sc), v);\n+                       &ident name, &def_id d_id, &ann a, &scopes sc,\n+                       &vt[scopes] v) {\n+    visit::visit_fn(f, tp, sp, name, d_id, a, cons(scope_fn(f.decl, tp), @sc),\n+                    v);\n }\n+\n fn visit_block_with_scope(&ast::block b, &scopes sc, &vt[scopes] v) {\n     visit::visit_block(b, cons(scope_block(b), @sc), v);\n }\n+\n fn visit_arm_with_scope(&ast::arm a, &scopes sc, &vt[scopes] v) {\n     visit::visit_arm(a, cons(scope_arm(a), @sc), v);\n }\n+\n fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n-    auto new_sc = alt (x.node) {\n-        case (ast::expr_for(?d, _, _, _)) {\n-            cons[scope](scope_loop(d.node), @sc)\n-        }\n-        case (ast::expr_for_each(?d, _, _, _)) {\n-            cons[scope](scope_loop(d.node), @sc)\n-        }\n-        case (ast::expr_fn(?f, _)) {\n-            cons(scope_fn(f.decl, []), @sc)\n-        }\n-        case (_) { sc }\n-    };\n+    auto new_sc =\n+        alt (x.node) {\n+            case (ast::expr_for(?d, _, _, _)) {\n+                cons[scope](scope_loop(d.node), @sc)\n+            }\n+            case (ast::expr_for_each(?d, _, _, _)) {\n+                cons[scope](scope_loop(d.node), @sc)\n+            }\n+            case (ast::expr_fn(?f, _)) { cons(scope_fn(f.decl, []), @sc) }\n+            case (_) { sc }\n+        };\n     visit::visit_expr(x, new_sc, v);\n }\n \n-\n-fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) \n-    -> def {\n+fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n     auto path_len = vec::len(path);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     auto i = 1u;\n     while (true) {\n         if (i == path_len) { break; }\n-        dcur = lookup_in_mod_strict(e, dcur, sp, path.(i),\n-                                    ns_module, outside);\n+        dcur =\n+            lookup_in_mod_strict(e, dcur, sp, path.(i), ns_module, outside);\n         i += 1u;\n     }\n-\n     alt (dcur) {\n         case (ast::def_mod(?def_id)) { ret dcur; }\n         case (ast::def_native_mod(?def_id)) { ret dcur; }\n         case (_) {\n-            e.sess.span_err(sp, str::connect(path, \"::\") \n-                            + \" does not name a module.\");\n+            e.sess.span_err(sp,\n+                            str::connect(path, \"::\") +\n+                                \" does not name a module.\");\n         }\n     }\n }\n \n \n-\n-\n // Import resolution\n-\n fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n-    auto defid; auto ids;\n+    auto defid;\n+    auto ids;\n     alt (it.node) {\n         case (ast::view_item_import(_, ?_ids, ?_defid)) {\n-            defid = _defid; ids = _ids;\n+            defid = _defid;\n+            ids = _ids;\n         }\n     }\n     e.imports.insert(defid._1, resolving(it.span));\n-    \n     auto n_idents = vec::len(ids);\n     auto end_id = ids.(n_idents - 1u);\n-\n     if (n_idents == 1u) {\n         auto next_sc = std::list::cdr(sc);\n         register(e, defid, it.span, end_id,\n                  lookup_in_scope(e, next_sc, it.span, end_id, ns_value),\n                  lookup_in_scope(e, next_sc, it.span, end_id, ns_type),\n                  lookup_in_scope(e, next_sc, it.span, end_id, ns_module));\n     } else {\n-        auto dcur = lookup_in_scope_strict(e, sc, it.span, ids.(0),\n-                                           ns_module);\n+        auto dcur =\n+            lookup_in_scope_strict(e, sc, it.span, ids.(0), ns_module);\n         auto i = 1u;\n         while (true) {\n             if (i == n_idents - 1u) {\n@@ -416,26 +424,26 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n                                        outside));\n                 break;\n             } else {\n-                dcur = lookup_in_mod_strict(e, dcur, it.span, ids.(i),\n-                                            ns_module, outside);\n+                dcur =\n+                    lookup_in_mod_strict(e, dcur, it.span, ids.(i), ns_module,\n+                                         outside);\n                 i += 1u;\n             }\n         }\n     }\n-\n     fn register(&env e, def_id defid, &span sp, &ident id,\n                 &option::t[def] val, &option::t[def] typ,\n                 &option::t[def] md) {\n         if (option::is_none(val) && option::is_none(typ) &&\n-            option::is_none(md)) {\n+                option::is_none(md)) {\n             unresolved(e, sp, id, \"import\");\n         }\n         e.imports.insert(defid._1, resolved(val, typ, md));\n     }\n }\n \n-// Utilities\n \n+// Utilities\n fn ns_name(namespace ns) -> str {\n     alt (ns) {\n         case (ns_type) { ret \"typename\"; }\n@@ -448,8 +456,8 @@ fn unresolved(&env e, &span sp, &ident id, &str kind) -> ! {\n     e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n }\n \n-// Lookup helpers\n \n+// Lookup helpers\n fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n                       namespace ns) -> def {\n     auto n_idents = vec::len(idents);\n@@ -463,46 +471,40 @@ fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n     }\n     ret dcur;\n }\n-                      \n+\n fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident id,\n-                        namespace ns) -> def {\n+                          namespace ns) -> def {\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n-        case (none) {\n-            unresolved(e, sp, id, ns_name(ns));\n-        }\n-        case (some(?d)) {\n-            ret d;\n-        }\n+        case (none) { unresolved(e, sp, id, ns_name(ns)); }\n+        case (some(?d)) { ret d; }\n     }\n }\n \n fn scope_is_fn(&scope sc) -> bool {\n     ret alt (sc) {\n-        case (scope_fn(_, _)) { true }\n-        case (scope_native_item(_)) { true }\n-        case (_) { false }\n-    };\n+            case (scope_fn(_, _)) { true }\n+            case (scope_native_item(_)) { true }\n+            case (_) { false }\n+        };\n }\n \n fn def_is_local(&def d) -> bool {\n     ret alt (d) {\n-        case (ast::def_arg(_)) { true }\n-        case (ast::def_local(_)) { true }\n-        case (ast::def_binding(_)) { true }\n-        case (_) { false }\n-    };\n+            case (ast::def_arg(_)) { true }\n+            case (ast::def_local(_)) { true }\n+            case (ast::def_binding(_)) { true }\n+            case (_) { false }\n+        };\n }\n+\n fn def_is_obj_field(&def d) -> bool {\n-    ret alt (d) {\n-        case (ast::def_obj_field(_)) { true }\n-        case (_) { false }\n-    };\n+    ret alt (d) { case (ast::def_obj_field(_)) { true } case (_) { false } };\n }\n \n-fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns)\n-    -> option::t[def] {\n-    fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns)\n-        -> option::t[def] {\n+fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n+   option::t[def] {\n+    fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns) ->\n+       option::t[def] {\n         //not recursing through globs\n \n         alt (s) {\n@@ -531,12 +533,13 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns)\n                             ret lookup_in_ty_params(id, ty_params);\n                         }\n                     }\n-                    case (_) {}\n+                    case (_) { }\n                 }\n             }\n             case (scope_native_item(?it)) {\n                 alt (it.node) {\n-                    case (ast::native_item_fn(_, _, ?decl, ?ty_params, _, _)){\n+                    case (ast::native_item_fn(_, _, ?decl, ?ty_params, _, _))\n+                         {\n                         ret lookup_in_fn(id, decl, ty_params, ns);\n                     }\n                 }\n@@ -551,55 +554,47 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns)\n                     }\n                 }\n             }\n-            case (scope_block(?b)) {\n-                ret lookup_in_block(id, b.node, ns);\n-            }\n+            case (scope_block(?b)) { ret lookup_in_block(id, b.node, ns); }\n             case (scope_arm(?a)) {\n-                if (ns == ns_value) {\n-                    ret lookup_in_pat(id, *a.pat);\n-                }\n+                if (ns == ns_value) { ret lookup_in_pat(id, *a.pat); }\n             }\n         }\n         ret none[def];\n     }\n-\n     auto left_fn = false;\n     // Used to determine whether obj fields are in scope\n+\n     auto left_fn_level2 = false;\n     while (true) {\n-        alt ({sc}) {\n-            case (nil) {\n-                ret none[def];\n-            }\n+        alt ({ sc }) {\n+            case (nil) { ret none[def]; }\n             case (cons(?hd, ?tl)) {\n                 auto fnd = in_scope(e, sp, id, hd, ns);\n                 if (!option::is_none(fnd)) {\n                     auto df = option::get(fnd);\n-                    if ((left_fn && def_is_local(df)) ||\n-                        (left_fn_level2 && def_is_obj_field(df))) {\n-                        e.sess.span_err\n-                            (sp, \"attempted dynamic environment-capture\");\n+                    if (left_fn && def_is_local(df) ||\n+                            left_fn_level2 && def_is_obj_field(df)) {\n+                        e.sess.span_err(sp,\n+                                        \"attempted dynamic \\\n+                                         environment-capture\");\n                     }\n                     ret fnd;\n                 }\n                 if (left_fn) { left_fn_level2 = true; }\n-                if (ns == ns_value && !left_fn) {\n-                    left_fn = scope_is_fn(hd);\n-                }\n+                if (ns == ns_value && !left_fn) { left_fn = scope_is_fn(hd); }\n                 sc = *tl;\n             }\n         }\n     }\n     e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n+\n }\n \n-fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n-    -> option::t[def] {\n+fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params) ->\n+   option::t[def] {\n     auto i = 0u;\n     for (ast::ty_param tp in ty_params) {\n-        if (str::eq(tp, id)) {\n-            ret some(ast::def_ty_arg(i));\n-        }\n+        if (str::eq(tp, id)) { ret some(ast::def_ty_arg(i)); }\n         i += 1u;\n     }\n     ret none[def];\n@@ -610,8 +605,8 @@ fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n         case (ast::pat_bind(?name, ?defid, _)) {\n             if (str::eq(name, id)) { ret some(ast::def_binding(defid)); }\n         }\n-        case (ast::pat_wild(_)) {}\n-        case (ast::pat_lit(_, _)) {}\n+        case (ast::pat_wild(_)) { }\n+        case (ast::pat_lit(_, _)) { }\n         case (ast::pat_tag(_, ?pats, _)) {\n             for (@ast::pat p in pats) {\n                 auto found = lookup_in_pat(id, *p);\n@@ -622,21 +617,16 @@ fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n     ret none[def];\n }\n \n-\n fn lookup_in_fn(&ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n                 namespace ns) -> option::t[def] {\n     alt (ns) {\n         case (ns_value) {\n             for (ast::arg a in decl.inputs) {\n-                if (str::eq(a.ident, id)) {\n-                    ret some(ast::def_arg(a.id));\n-                }\n+                if (str::eq(a.ident, id)) { ret some(ast::def_arg(a.id)); }\n             }\n             ret none[def];\n         }\n-        case (ns_type) {\n-            ret lookup_in_ty_params(id, ty_params);\n-        }\n+        case (ns_type) { ret lookup_in_ty_params(id, ty_params); }\n         case (_) { ret none[def]; }\n     }\n }\n@@ -652,18 +642,16 @@ fn lookup_in_obj(&ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n             }\n             ret none[def];\n         }\n-        case (ns_type) {\n-            ret lookup_in_ty_params(id, ty_params);\n-        }\n+        case (ns_type) { ret lookup_in_ty_params(id, ty_params); }\n         case (_) { ret none[def]; }\n     }\n }\n \n-fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n-    -> option::t[def] {\n+fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n+   option::t[def] {\n     for (@ast::stmt st in b.stmts) {\n         alt (st.node) {\n-            case (ast::stmt_decl(?d,_)) {\n+            case (ast::stmt_decl(?d, _)) {\n                 alt (d.node) {\n                     case (ast::decl_local(?loc)) {\n                         if (ns == ns_value && str::eq(id, loc.ident)) {\n@@ -672,32 +660,35 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n                     }\n                     case (ast::decl_item(?it)) {\n                         alt (it.node) {\n-                            case (ast::item_tag(?name, ?variants, _,\n-                                                _, ?defid, _)) {\n+                            case (ast::item_tag(?name, ?variants, _, _,\n+                                                ?defid, _)) {\n                                 if (ns == ns_type) {\n                                     if (str::eq(name, id)) {\n                                         ret some(ast::def_ty(defid));\n                                     }\n                                 } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n                                         if (str::eq(v.node.name, id)) {\n-                                            ret some(ast::def_variant(\n-                                                      defid, v.node.id));\n+                                            auto i =  v.node.id;\n+                                            ret some(ast::def_variant(defid,\n+                                                                      i));\n                                         }\n                                     }\n                                 }\n                             }\n                             case (_) {\n                                 if (str::eq(ast::item_ident(it), id)) {\n                                     auto found = found_def_item(it, ns);\n-                                    if (!option::is_none(found)) {ret found;}\n+                                    if (!option::is_none(found)) {\n+                                        ret found;\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n     ret none[def];\n@@ -735,32 +726,27 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n     ret none[def];\n }\n \n-fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n-                        namespace ns, dir dr) -> def {\n+fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id, namespace ns,\n+                        dir dr) -> def {\n     alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n-        case (none) {\n-            unresolved(e, sp, id, ns_name(ns));\n-        }\n-        case (some(?d)) {\n-            ret d;\n-        }\n+        case (none) { unresolved(e, sp, id, ns_name(ns)); }\n+        case (some(?d)) { ret d; }\n     }\n }\n \n-fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr)\n-    -> option::t[def] {\n+fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr) ->\n+   option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n     if (defid._0 != ast::local_crate) {\n         // examining a module in an external crate\n-        auto cached = e.ext_cache.find(tup(defid,id,ns));\n+\n+        auto cached = e.ext_cache.find(tup(defid, id, ns));\n         if (!option::is_none(cached)) { ret cached; }\n         auto path = [id];\n-        if (defid._1 != -1) {\n-            path = e.ext_map.get(defid) + path;\n-        }\n+        if (defid._1 != -1) { path = e.ext_map.get(defid) + path; }\n         auto fnd = lookup_external(e, defid._0, path, ns);\n         if (!option::is_none(fnd)) {\n-            e.ext_cache.insert(tup(defid,id,ns), option::get(fnd));\n+            e.ext_cache.insert(tup(defid, id, ns), option::get(fnd));\n         }\n         ret fnd;\n     }\n@@ -774,8 +760,8 @@ fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr)\n     }\n }\n \n-fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n-    -> option::t[def] {\n+fn found_view_item(&env e, @ast::view_item vi, namespace ns) ->\n+   option::t[def] {\n     alt (vi.node) {\n         case (ast::view_item_use(_, _, _, ?ann)) {\n             ret some(ast::def_mod(tup(e.crate_map.get(ann.id), -1)));\n@@ -785,6 +771,7 @@ fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n         }\n         case (ast::view_item_import_glob(_, ?defid)) {\n             ret none[def]; //will be handled in the fallback glob pass\n+\n         }\n     }\n }\n@@ -795,31 +782,32 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n             resolve_import(e, item, sc);\n             ret lookup_import(e, defid, ns);\n         }\n-        case (resolving(?sp)) {\n-            e.sess.span_err(sp, \"cyclic import\");\n-        }\n+        case (resolving(?sp)) { e.sess.span_err(sp, \"cyclic import\"); }\n         case (resolved(?val, ?typ, ?md)) {\n-            ret alt (ns) { case (ns_value) { val }\n-                           case (ns_type) { typ }\n-                           case (ns_module) { md } };\n+            ret alt (ns) {\n+                    case (ns_value) { val }\n+                    case (ns_type) { typ }\n+                    case (ns_module) { md }\n+                };\n         }\n     }\n }\n \n-\n-fn lookup_in_local_native_mod(&env e, def_id defid, &span sp,\n-                              &ident id, namespace ns) -> option::t[def] {\n+fn lookup_in_local_native_mod(&env e, def_id defid, &span sp, &ident id,\n+                              namespace ns) -> option::t[def] {\n     ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n }\n \n-fn lookup_in_local_mod(&env e, def_id defid, &span sp, \n-                       &ident id, namespace ns, dir dr) -> option::t[def] {\n+fn lookup_in_local_mod(&env e, def_id defid, &span sp, &ident id,\n+                       namespace ns, dir dr) -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n     if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n-         // if we're in a native mod, then dr==inside, so info.m is some _mod\n-         ret none[def]; // name is not visible\n+        // if we're in a native mod, then dr==inside, so info.m is some _mod\n+\n+        ret none[def]; // name is not visible\n+\n     }\n-    alt(info.index.find(id)) {\n+    alt (info.index.find(id)) {\n         case (none) { }\n         case (some(?lst_)) {\n             auto lst = lst_;\n@@ -836,141 +824,132 @@ fn lookup_in_local_mod(&env e, def_id defid, &span sp,\n         }\n     }\n     // not local or explicitly imported; try globs:\n+\n     ret lookup_glob_in_mod(e, info, sp, id, ns, dr);\n }\n \n-fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, \n-                      &ident id, namespace wanted_ns, dir dr)\n-    -> option::t[def] {\n-    fn per_ns(&env e, @indexed_mod info, &span sp, &ident id, \n-              namespace ns, dir dr) -> option::t[def] {\n-        fn l_i_m_r(&env e, &def m, &span sp, &ident id, \n-                   namespace ns, dir dr) -> option::t[def] {\n+fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n+                      namespace wanted_ns, dir dr) -> option::t[def] {\n+    fn per_ns(&env e, @indexed_mod info, &span sp, &ident id, namespace ns,\n+              dir dr) -> option::t[def] {\n+        fn l_i_m_r(&env e, &def m, &span sp, &ident id, namespace ns, dir dr)\n+           -> option::t[def] {\n             be lookup_in_mod(e, m, sp, id, ns, dr);\n         }\n-\n-        auto matches = vec::filter_map[def, def]\n-            (bind l_i_m_r(e, _, sp, id, ns, dr), \n-             {info.glob_imports});\n+        auto matches =\n+            vec::filter_map[def,\n+                            def](bind l_i_m_r(e, _, sp, id, ns, dr),\n+                                 { info.glob_imports });\n         if (vec::len(matches) == 0u) {\n             ret none[def];\n-        } else if (vec::len(matches) == 1u){\n+        } else if (vec::len(matches) == 1u) {\n             ret some[def](matches.(0));\n         } else {\n             for (def match in matches) {\n                 alt (e.ast_map.find(ast::def_id_of_def(match))) {\n                     case (some(?it)) {\n                         e.sess.span_note(it.span,\n-                           \"'\" + id + \"' is defined here.\");\n+                                         \"'\" + id + \"' is defined here.\");\n                     }\n                     case (_) {\n-                        e.sess.bug(\"Internal error: imports and matches \"\n-                                   + \"don't agree\");\n+                        e.sess.bug(\"Internal error: imports and matches \" +\n+                                       \"don't agree\");\n                     }\n                 }\n             }\n-            e.sess.span_err(sp, \"'\" + id + \"' is glob-imported from\" +\n-                            \" multiple different modules.\");\n+            e.sess.span_err(sp,\n+                            \"'\" + id + \"' is glob-imported from\" +\n+                                \" multiple different modules.\");\n         }\n     }\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n-    if(!info.glob_imported_names.contains_key(id)) {\n+\n+    if (!info.glob_imported_names.contains_key(id)) {\n         info.glob_imported_names.insert(id, resolving(sp));\n         auto val = per_ns(e, info, sp, id, ns_value, dr);\n         auto typ = per_ns(e, info, sp, id, ns_type, dr);\n-        auto md  = per_ns(e, info, sp, id, ns_module, dr);\n+        auto md = per_ns(e, info, sp, id, ns_module, dr);\n         info.glob_imported_names.insert(id, resolved(val, typ, md));\n     }\n     alt (info.glob_imported_names.get(id)) {\n-        case (todo(_,_)) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n+        case (todo(_, _)) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n         case (resolving(?sp)) {\n             ret none[def]; //circularity is okay in import globs\n+\n         }\n         case (resolved(?val, ?typ, ?md)) {\n-            ret alt (wanted_ns) { case (ns_value) { val }\n-                                  case (ns_type) { typ }\n-                                  case (ns_module) { md } };\n+            ret alt (wanted_ns) {\n+                    case (ns_value) { val }\n+                    case (ns_type) { typ }\n+                    case (ns_module) { md }\n+                };\n         }\n     }\n }\n \n-fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n-    -> option::t[def] {\n+fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns) ->\n+   option::t[def] {\n     alt (mie) {\n         case (mie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n-        case (mie_item(?item)) {\n-            ret found_def_item(item, ns);\n-        }\n+        case (mie_item(?item)) { ret found_def_item(item, ns); }\n         case (mie_tag_variant(?item, ?variant_idx)) {\n             alt (item.node) {\n                 case (ast::item_tag(_, ?variants, _, _, ?tid, _)) {\n                     if (ns == ns_value) {\n                         auto vid = variants.(variant_idx).node.id;\n                         ret some(ast::def_variant(tid, vid));\n-                    } else {\n-                        ret none[def];\n-                    }\n+                    } else { ret none[def]; }\n                 }\n             }\n         }\n         case (mie_native_item(?native_item)) {\n             alt (native_item.node) {\n                 case (ast::native_item_ty(_, ?id)) {\n-                    if (ns == ns_type) {\n-                        ret some(ast::def_native_ty(id));\n-                    }\n+                    if (ns == ns_type) { ret some(ast::def_native_ty(id)); }\n                 }\n                 case (ast::native_item_fn(_, _, _, _, ?id, _)) {\n-                    if (ns == ns_value) {\n-                        ret some(ast::def_native_fn(id));\n-                    }\n+                    if (ns == ns_value) { ret some(ast::def_native_fn(id)); }\n                 }\n             }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     ret none[def];\n }\n \n \n-\n // Module indexing\n-\n-fn add_to_index(&hashmap[ident,list[mod_index_entry]] index, &ident id, \n+fn add_to_index(&hashmap[ident, list[mod_index_entry]] index, &ident id,\n                 &mod_index_entry ent) {\n     alt (index.find(id)) {\n-        case (none) {\n-            index.insert(id, cons(ent, @nil[mod_index_entry]));\n-        }\n-        case (some(?prev)) {\n-            index.insert(id, cons(ent, @prev));\n-        }\n+        case (none) { index.insert(id, cons(ent, @nil[mod_index_entry])); }\n+        case (some(?prev)) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n \n fn index_mod(&ast::_mod md) -> mod_index {\n     auto index = new_str_hash[list[mod_index_entry]]();\n-\n     for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n-            case(ast::view_item_use(?id, _, _, _)) {\n+            case (ast::view_item_use(?id, _, _, _)) {\n                 add_to_index(index, id, mie_view_item(it));\n             }\n-            case(ast::view_item_import(?def_ident,_,_)) {\n+            case (ast::view_item_import(?def_ident, _, _)) {\n                 add_to_index(index, def_ident, mie_view_item(it));\n             }\n-            //globbed imports have to be resolved lazily.\n-            case(ast::view_item_import_glob(_,_)) {}\n-            case(ast::view_item_export(_)) {}\n+            case (\n+                 //globbed imports have to be resolved lazily.\n+                 ast::view_item_import_glob(_, _)) {\n+            }\n+            case (ast::view_item_export(_)) { }\n         }\n     }\n-\n     for (@ast::item it in md.items) {\n         alt (it.node) {\n-            case (ast::item_const(?id, _, _,  _, _, _)) {\n+            case (ast::item_const(?id, _, _, _, _, _)) {\n                 add_to_index(index, id, mie_item(it));\n             }\n             case (ast::item_fn(?id, _, _, _, _, _)) {\n@@ -990,7 +969,7 @@ fn index_mod(&ast::_mod md) -> mod_index {\n                 let uint variant_idx = 0u;\n                 for (ast::variant v in variants) {\n                     add_to_index(index, v.node.name,\n-                                     mie_tag_variant(it, variant_idx));\n+                                 mie_tag_variant(it, variant_idx));\n                     variant_idx += 1u;\n                 }\n             }\n@@ -999,23 +978,20 @@ fn index_mod(&ast::_mod md) -> mod_index {\n             }\n         }\n     }\n-\n     ret index;\n }\n \n fn index_nmod(&ast::native_mod md) -> mod_index {\n     auto index = new_str_hash[list[mod_index_entry]]();\n-\n     for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n-            case(ast::view_item_import(?def_ident,_,_)) {\n+            case (ast::view_item_import(?def_ident, _, _)) {\n                 add_to_index(index, def_ident, mie_view_item(it));\n             }\n-            case(ast::view_item_import_glob(_,_)) {}\n-            case(ast::view_item_export(_)) {}\n+            case (ast::view_item_import_glob(_, _)) { }\n+            case (ast::view_item_export(_)) { }\n         }\n     }\n-\n     for (@ast::native_item it in md.items) {\n         alt (it.node) {\n             case (ast::native_item_ty(?id, _)) {\n@@ -1026,81 +1002,85 @@ fn index_nmod(&ast::native_mod md) -> mod_index {\n             }\n         }\n     }\n-\n     ret index;\n }\n \n-// External lookups\n \n+// External lookups\n fn ns_for_def(def d) -> namespace {\n     ret alt (d) {\n-        case (ast::def_fn(?id)) { ns_value }\n-        case (ast::def_obj(?id)) { ns_value }\n-        case (ast::def_obj_field(?id)) { ns_value }\n-        case (ast::def_mod(?id)) { ns_module }\n-        case (ast::def_native_mod(?id)) { ns_module }\n-        case (ast::def_const(?id)) { ns_value }\n-        case (ast::def_arg(?id)) { ns_value }\n-        case (ast::def_local(?id)) { ns_value }\n-        case (ast::def_variant(_, ?id)) { ns_value }\n-        case (ast::def_ty(?id)) { ns_type }\n-        case (ast::def_binding(?id)) { ns_type }\n-        case (ast::def_use(?id)) { ns_module }\n-        case (ast::def_native_ty(?id)) { ns_type }\n-        case (ast::def_native_fn(?id)) { ns_value }\n-    };\n+            case (ast::def_fn(?id)) { ns_value }\n+            case (ast::def_obj(?id)) { ns_value }\n+            case (ast::def_obj_field(?id)) { ns_value }\n+            case (ast::def_mod(?id)) { ns_module }\n+            case (ast::def_native_mod(?id)) { ns_module }\n+            case (ast::def_const(?id)) { ns_value }\n+            case (ast::def_arg(?id)) { ns_value }\n+            case (ast::def_local(?id)) { ns_value }\n+            case (ast::def_variant(_, ?id)) { ns_value }\n+            case (ast::def_ty(?id)) { ns_type }\n+            case (ast::def_binding(?id)) { ns_type }\n+            case (ast::def_use(?id)) { ns_module }\n+            case (ast::def_native_ty(?id)) { ns_type }\n+            case (ast::def_native_fn(?id)) { ns_value }\n+        };\n }\n \n-fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n-    -> option::t[def] {\n+fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns) ->\n+   option::t[def] {\n     for (def d in creader::lookup_defs(e.sess, cnum, ids)) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if (ns == ns_for_def(d)) { ret some(d); }\n     }\n     ret none[def];\n }\n \n-// Collision detection\n \n+// Collision detection\n fn check_for_collisions(&@env e, &ast::crate c) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n+\n     for each (@tup(ast::def_num, @indexed_mod) m in e.mod_map.items()) {\n         for each (@tup(ident, list[mod_index_entry]) name in\n-                  m._1.index.items()) {\n+                 m._1.index.items()) {\n             check_mod_name(*e, name._0, name._1);\n         }\n     }\n-\n     // Other scopes have to be checked the hard way.\n-    auto v = @rec(visit_item = bind check_item(e, _, _, _),\n-                  visit_block = bind check_block(e, _, _, _),\n-                  visit_arm = bind check_arm(e, _, _, _)\n-                  with *visit::default_visitor());\n+\n+    auto v =\n+        @rec(visit_item=bind check_item(e, _, _, _),\n+             visit_block=bind check_block(e, _, _, _),\n+             visit_arm=bind check_arm(e, _, _, _)\n+             with *visit::default_visitor());\n     visit::visit_crate(c, (), visit::vtor(v));\n }\n \n fn check_mod_name(&env e, &ident name, list[mod_index_entry] entries) {\n-    auto saw_mod = false; auto saw_type = false; auto saw_value = false;\n-\n+    auto saw_mod = false;\n+    auto saw_type = false;\n+    auto saw_value = false;\n     fn dup(&env e, &span sp, &str word, &ident name) {\n         e.sess.span_err(sp, \"duplicate definition of \" + word + name);\n     }\n-\n     while (true) {\n         alt (entries) {\n             case (cons(?entry, ?rest)) {\n                 if (!option::is_none(lookup_in_mie(e, entry, ns_value))) {\n-                    if (saw_value) { dup(e, mie_span(entry), \"\", name); }\n-                    else { saw_value = true; }\n+                    if (saw_value) {\n+                        dup(e, mie_span(entry), \"\", name);\n+                    } else { saw_value = true; }\n                 }\n                 if (!option::is_none(lookup_in_mie(e, entry, ns_type))) {\n-                    if (saw_type) { dup(e, mie_span(entry), \"type \", name); }\n-                    else { saw_type = true; }\n+                    if (saw_type) {\n+                        dup(e, mie_span(entry), \"type \", name);\n+                    } else { saw_type = true; }\n                 }\n                 if (!option::is_none(lookup_in_mie(e, entry, ns_module))) {\n-                    if (saw_mod) { dup(e, mie_span(entry), \"module \", name); }\n-                    else { saw_mod = true; }\n+                    if (saw_mod) {\n+                        dup(e, mie_span(entry), \"module \", name);\n+                    } else { saw_mod = true; }\n                 }\n                 entries = *rest;\n             }\n@@ -1118,18 +1098,15 @@ fn mie_span(&mod_index_entry mie) -> span {\n     }\n }\n \n-\n fn check_item(@env e, &@ast::item i, &() x, &vt[()] v) {\n     visit::visit_item(i, x, v);\n     alt (i.node) {\n-        case (ast::item_fn(_, ?f, ?ty_params, _, _,  _)) {\n+        case (ast::item_fn(_, ?f, ?ty_params, _, _, _)) {\n             check_fn(*e, i.span, f);\n             ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n         }\n         case (ast::item_obj(_, ?ob, ?ty_params, _, _, _)) {\n-            fn field_name(&ast::obj_field field) -> ident {\n-                ret field.ident;\n-            }\n+            fn field_name(&ast::obj_field field) -> ident { ret field.ident; }\n             ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n             for (@ast::method m in ob.methods) {\n                 check_fn(*e, m.span, m.node.meth);\n@@ -1139,46 +1116,40 @@ fn check_item(@env e, &@ast::item i, &() x, &vt[()] v) {\n         case (ast::item_tag(_, _, ?ty_params, _, _, _)) {\n             ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n }\n \n fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n     visit::visit_arm(a, x, v);\n     fn walk_pat(checker ch, &@ast::pat p) {\n         alt (p.node) {\n-            case (ast::pat_bind(?name, _, _)) {\n-                add_name(ch, p.span, name);\n-            }\n+            case (ast::pat_bind(?name, _, _)) { add_name(ch, p.span, name); }\n             case (ast::pat_tag(_, ?children, _)) {\n-                for (@ast::pat child in children) {\n-                    walk_pat(ch, child);\n-                }\n+                for (@ast::pat child in children) { walk_pat(ch, child); }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n     walk_pat(checker(*e, \"binding\"), a.pat);\n }\n \n fn check_block(@env e, &ast::block b, &() x, &vt[()] v) {\n     visit::visit_block(b, x, v);\n-\n     auto values = checker(*e, \"value\");\n     auto types = checker(*e, \"type\");\n     auto mods = checker(*e, \"module\");\n-    \n     for (@ast::stmt st in b.node.stmts) {\n         alt (st.node) {\n-            case (ast::stmt_decl(?d,_)) {\n+            case (ast::stmt_decl(?d, _)) {\n                 alt (d.node) {\n                     case (ast::decl_local(?loc)) {\n                         add_name(values, d.span, loc.ident);\n                     }\n                     case (ast::decl_item(?it)) {\n                         alt (it.node) {\n-                            case (ast::item_tag(?name, ?variants,\n-                                                _, _, _, _)) {\n+                            case (ast::item_tag(?name, ?variants, _, _, _, _))\n+                                 {\n                                 add_name(types, it.span, name);\n                                 for (ast::variant v in variants) {\n                                     add_name(values, v.span, v.node.name);\n@@ -1208,21 +1179,18 @@ fn check_block(@env e, &ast::block b, &() x, &vt[()] v) {\n                     }\n                 }\n             }\n-            case (_) {}\n+            case (_) { }\n         }\n     }\n }\n \n fn check_fn(&env e, &span sp, &ast::_fn f) {\n-    fn arg_name(&ast::arg a) -> ident {\n-        ret a.ident;\n-    }\n+    fn arg_name(&ast::arg a) -> ident { ret a.ident; }\n     ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n-type checker = @rec(mutable vec[ident] seen,\n-                    str kind,\n-                    session sess);\n+type checker = @rec(mutable vec[ident] seen, str kind, session sess);\n+\n fn checker(&env e, str kind) -> checker {\n     let vec[ident] seen = [];\n     ret @rec(mutable seen=seen, kind=kind, sess=e.sess);\n@@ -1239,14 +1207,11 @@ fn add_name(&checker ch, &span sp, &ident id) {\n \n fn ident_id(&ident i) -> ident { ret i; }\n \n-fn ensure_unique[T](&env e, &span sp, &vec[T] elts, fn (&T) -> ident id,\n+fn ensure_unique[T](&env e, &span sp, &vec[T] elts, fn(&T) -> ident  id,\n                     &str kind) {\n     auto ch = checker(e, kind);\n-    for (T elt in elts) {\n-        add_name(ch, sp, id(elt));\n-    }\n+    for (T elt in elts) { add_name(ch, sp, id(elt)); }\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "24bef67d75876439a748bb56d2975d1f2bddc81b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2211, "deletions": 3320, "changes": 5531, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "746c75787fb66bdffb3ce7c82c2aecfe78a77dcb", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 96, "deletions": 97, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,207 +1,206 @@\n+\n import front::ast::ident;\n import std::vec;\n import std::bitv;\n \n+\n /* \n    This says: this expression requires the idents in <pre> to be initialized,\n    and given the precondition, it guarantees that the idents in <post> are\n    initialized.\n  */\n-type precond  = bitv::t; /* 1 means \"this variable must be initialized\"\n-                           0 means \"don't care about this variable\" */\n-type postcond = bitv::t; /* 1 means \"this variable is initialized\"\n-                           0 means \"don't know about this variable */\n-\n-type prestate = bitv::t; /* 1 means \"this variable is definitely initialized\"\n-                           0 means \"don't know whether this variable is\n-                           initialized\" */\n-type poststate = bitv::t; /* 1 means \"this variable is definitely initialized\"\n-                            0 means \"don't know whether this variable is\n-                            initialized\" */\n-\n-/* named thus so as not to confuse with prestate and poststate */\n+type precond = bitv::t;\n+\n+ /* 1 means \"this variable must be initialized\"\n+   0 means \"don't care about this variable\" */\n+ type postcond = bitv::t;\n+\n+ /* 1 means \"this variable is initialized\"\n+   0 means \"don't know about this variable */\n+ type prestate = bitv::t;\n+\n+ /* 1 means \"this variable is definitely initialized\"\n+   0 means \"don't know whether this variable is\n+   initialized\" */\n+ type poststate = bitv::t;\n+\n+ /* 1 means \"this variable is definitely initialized\"\n+   0 means \"don't know whether this variable is\n+   initialized\" */\n+  /* named thus so as not to confuse with prestate and poststate */\n type pre_and_post = @rec(precond precondition, postcond postcondition);\n+\n+\n /* FIXME: once it's implemented: */\n-//  : ((*.precondition).nbits == (*.postcondition).nbits);\n \n+//  : ((*.precondition).nbits == (*.postcondition).nbits);\n type pre_and_post_state = rec(prestate prestate, poststate poststate);\n \n type ts_ann = @rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n-  be bitv::create(num_vars, false);\n+    be bitv::create(num_vars, false);\n }\n \n-fn true_postcond(uint num_vars) -> postcond {\n-  be true_precond(num_vars);\n-}\n+fn true_postcond(uint num_vars) -> postcond { be true_precond(num_vars); }\n \n-fn empty_prestate(uint num_vars) -> prestate {\n-  be true_precond(num_vars);\n-}\n+fn empty_prestate(uint num_vars) -> prestate { be true_precond(num_vars); }\n \n-fn empty_poststate(uint num_vars) -> poststate {\n-  be true_precond(num_vars);\n-}\n+fn empty_poststate(uint num_vars) -> poststate { be true_precond(num_vars); }\n \n fn false_postcond(uint num_vars) -> postcond {\n     be bitv::create(num_vars, true);\n }\n \n fn empty_pre_post(uint num_vars) -> pre_and_post {\n-  ret(@rec(precondition=empty_prestate(num_vars),\n-           postcondition=empty_poststate(num_vars)));\n+    ret @rec(precondition=empty_prestate(num_vars),\n+             postcondition=empty_poststate(num_vars));\n }\n \n fn empty_states(uint num_vars) -> pre_and_post_state {\n-  ret(rec(prestate=true_precond(num_vars),\n-          poststate=true_postcond(num_vars)));\n+    ret rec(prestate=true_precond(num_vars),\n+            poststate=true_postcond(num_vars));\n }\n \n fn empty_ann(uint num_vars) -> ts_ann {\n-  ret(@rec(conditions=empty_pre_post(num_vars),\n-           states=empty_states(num_vars)));\n+    ret @rec(conditions=empty_pre_post(num_vars),\n+             states=empty_states(num_vars));\n }\n \n-fn get_pre(&pre_and_post p) -> precond {\n-  ret p.precondition;\n-}\n+fn get_pre(&pre_and_post p) -> precond { ret p.precondition; }\n \n-fn get_post(&pre_and_post p) -> postcond {\n-  ret p.postcondition;\n-}\n+fn get_post(&pre_and_post p) -> postcond { ret p.postcondition; }\n \n fn difference(&precond p1, &precond p2) -> bool {\n-  be bitv::difference(p1, p2);\n+    be bitv::difference(p1, p2);\n }\n \n-fn union(&precond p1, &precond p2) -> bool {\n-  be bitv::union(p1, p2);\n-}\n+fn union(&precond p1, &precond p2) -> bool { be bitv::union(p1, p2); }\n \n-fn intersect(&precond p1, &precond p2) -> bool {\n-  be bitv::intersect(p1, p2);\n-}\n+fn intersect(&precond p1, &precond p2) -> bool { be bitv::intersect(p1, p2); }\n \n fn pps_len(&pre_and_post p) -> uint {\n-  // gratuitous check\n-  assert (p.precondition.nbits == p.postcondition.nbits);\n-  ret p.precondition.nbits;\n+    // gratuitous check\n+\n+    assert (p.precondition.nbits == p.postcondition.nbits);\n+    ret p.precondition.nbits;\n }\n \n-fn require(uint i, &pre_and_post p) -> () {\n-  // sets the ith bit in p's pre\n-  bitv::set(p.precondition, i, true);\n+fn require(uint i, &pre_and_post p) {\n+    // sets the ith bit in p's pre\n+\n+    bitv::set(p.precondition, i, true);\n }\n \n-fn require_and_preserve(uint i, &pre_and_post p) -> () {\n-  // sets the ith bit in p's pre and post\n-  bitv::set(p.precondition, i, true);\n-  bitv::set(p.postcondition, i, true);\n+fn require_and_preserve(uint i, &pre_and_post p) {\n+    // sets the ith bit in p's pre and post\n+\n+    bitv::set(p.precondition, i, true);\n+    bitv::set(p.postcondition, i, true);\n }\n \n fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n-  // sets the ith bit in p's post\n-  auto was_set = bitv::get(p.postcondition, i);\n-  bitv::set(p.postcondition, i, true);\n-  ret !was_set;\n+    // sets the ith bit in p's post\n+\n+    auto was_set = bitv::get(p.postcondition, i);\n+    bitv::set(p.postcondition, i, true);\n+    ret !was_set;\n }\n \n fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n-  // sets the ith bit in p's post\n-  auto was_set = bitv::get(s.poststate, i);\n-  bitv::set(s.poststate, i, true);\n-  ret !was_set;\n+    // sets the ith bit in p's post\n+\n+    auto was_set = bitv::get(s.poststate, i);\n+    bitv::set(s.poststate, i, true);\n+    ret !was_set;\n }\n \n fn clear_in_poststate(uint i, &pre_and_post_state s) -> bool {\n-  // sets the ith bit in p's post\n-  auto was_set = bitv::get(s.poststate, i);\n-  bitv::set(s.poststate, i, false);\n-  ret was_set;\n+    // sets the ith bit in p's post\n+\n+    auto was_set = bitv::get(s.poststate, i);\n+    bitv::set(s.poststate, i, false);\n+    ret was_set;\n }\n \n+\n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n-fn set_precondition(ts_ann a, &precond p) -> () {\n-  bitv::copy(a.conditions.precondition, p);\n+fn set_precondition(ts_ann a, &precond p) {\n+    bitv::copy(a.conditions.precondition, p);\n }\n \n+\n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_postcondition(ts_ann a, &postcond p) -> () {\n-  bitv::copy(a.conditions.postcondition, p);\n+fn set_postcondition(ts_ann a, &postcond p) {\n+    bitv::copy(a.conditions.postcondition, p);\n }\n \n+\n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n fn set_prestate(ts_ann a, &prestate p) -> bool {\n-  ret bitv::copy(a.states.prestate, p);\n+    ret bitv::copy(a.states.prestate, p);\n }\n \n+\n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_poststate(ts_ann a, &poststate p) -> bool {\n-  ret bitv::copy(a.states.poststate, p);\n+    ret bitv::copy(a.states.poststate, p);\n }\n \n+\n // Set all the bits in p that are set in new\n fn extend_prestate(&prestate p, &poststate new) -> bool {\n-  ret bitv::union(p, new);\n+    ret bitv::union(p, new);\n }\n \n+\n // Set all the bits in p that are set in new\n fn extend_poststate(&poststate p, &poststate new) -> bool {\n-  ret bitv::union(p, new);\n+    ret bitv::union(p, new);\n }\n \n+\n // Clears the given bit in p\n fn relax_prestate(uint i, &prestate p) -> bool {\n     auto was_set = bitv::get(p, i);\n     bitv::set(p, i, false);\n     ret was_set;\n }\n \n+\n // Clears all the bits in p\n-fn clear(&precond p) -> () {\n-    bitv::clear(p);\n-}\n+fn clear(&precond p) { bitv::clear(p); }\n+\n \n // Sets all the bits in p\n-fn set(&precond p) -> () {\n-    bitv::set_all(p);\n-}\n+fn set(&precond p) { bitv::set_all(p); }\n \n-fn ann_precond(&ts_ann a) -> precond {\n-  ret a.conditions.precondition;\n-}\n+fn ann_precond(&ts_ann a) -> precond { ret a.conditions.precondition; }\n \n-fn ann_prestate(&ts_ann a) -> prestate {\n-  ret a.states.prestate;\n-}\n+fn ann_prestate(&ts_ann a) -> prestate { ret a.states.prestate; }\n \n-fn ann_poststate(&ts_ann a) -> poststate {\n-  ret a.states.poststate;\n-}\n+fn ann_poststate(&ts_ann a) -> poststate { ret a.states.poststate; }\n \n fn pp_clone(&pre_and_post p) -> pre_and_post {\n-  ret @rec(precondition=clone(p.precondition),\n-           postcondition=clone(p.postcondition));\n+    ret @rec(precondition=clone(p.precondition),\n+             postcondition=clone(p.postcondition));\n }\n \n-fn clone(prestate p) -> prestate {\n-    ret bitv::clone(p);\n-}\n+fn clone(prestate p) -> prestate { ret bitv::clone(p); }\n+\n \n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = 0\n fn implies(bitv::t a, bitv::t b) -> bool {\n-  auto tmp = bitv::clone(b);\n-  bitv::difference(tmp, a);\n-  ret bitv::is_false(tmp);\n+    auto tmp = bitv::clone(b);\n+    bitv::difference(tmp, a);\n+    ret bitv::is_false(tmp);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "c29705f78fc16fd4a070ef29632d4f757f63727d", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,11 +1,10 @@\n+\n import std::vec;\n import std::option;\n import std::option::some;\n import std::option::none;\n-\n import front::ast::*;\n import middle::ty::expr_ann;\n-\n import util::common::uistr;\n import util::common::span;\n import util::common::new_str_hash;\n@@ -16,7 +15,6 @@ import util::common::log_stmt_err;\n import util::common::log_expr;\n import util::common::log_block;\n import util::common::log_stmt;\n-\n import aux::fn_info;\n import aux::fn_info_map;\n import aux::num_constraints;\n@@ -25,75 +23,72 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(&@expr e, @mutable vec[uint] res) -> () {\n-    vec::push(*res, (expr_ann(e)).id);\n+fn collect_ids_expr(&@expr e, @mutable vec[uint] res) {\n+    vec::push(*res, expr_ann(e).id);\n }\n-fn collect_ids_block(&block b, @mutable vec[uint] res) -> () {\n+\n+fn collect_ids_block(&block b, @mutable vec[uint] res) {\n     vec::push(*res, b.node.a.id);\n }\n \n-fn collect_ids_stmt(&@stmt s, @mutable vec[uint] res) -> () {\n+fn collect_ids_stmt(&@stmt s, @mutable vec[uint] res) {\n     alt (s.node) {\n-        case (stmt_decl(_,?a)) {\n-            log(\"node_id \" + uistr(a.id));\n+        case (stmt_decl(_, ?a)) {\n+            log \"node_id \" + uistr(a.id);\n             log_stmt(*s);\n-  \n             vec::push(*res, a.id);\n         }\n-        case (stmt_expr(_,?a)) {\n-            log(\"node_id \" + uistr(a.id));\n+        case (stmt_expr(_, ?a)) {\n+            log \"node_id \" + uistr(a.id);\n             log_stmt(*s);\n-    \n             vec::push(*res, a.id);\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n }\n \n-fn collect_ids_local(&@local l, @mutable vec[uint] res) -> () {\n+fn collect_ids_local(&@local l, @mutable vec[uint] res) {\n     vec::push(*res, l.node.ann.id);\n }\n \n fn node_ids_in_fn(&_fn f, &span sp, &ident i, &def_id d, &ann a,\n-                  @mutable vec[uint] res) -> () {\n+                  @mutable vec[uint] res) {\n     auto collect_ids = walk::default_visitor();\n-    collect_ids = rec(visit_expr_pre  = bind collect_ids_expr(_,res),\n-                      visit_block_pre = bind collect_ids_block(_,res),\n-                      visit_stmt_pre  = bind collect_ids_stmt(_,res),\n-                      visit_local_pre  = bind collect_ids_local(_,res)\n-                      with collect_ids);\n+    collect_ids =\n+        rec(visit_expr_pre=bind collect_ids_expr(_, res),\n+            visit_block_pre=bind collect_ids_block(_, res),\n+            visit_stmt_pre=bind collect_ids_stmt(_, res),\n+            visit_local_pre=bind collect_ids_local(_, res) with collect_ids);\n     walk::walk_fn(collect_ids, f, sp, i, d, a);\n }\n \n-fn init_vecs(&crate_ctxt ccx, &vec[uint] node_ids, uint len) -> () {\n+fn init_vecs(&crate_ctxt ccx, &vec[uint] node_ids, uint len) {\n     for (uint i in node_ids) {\n-        log(uistr(i) + \" |-> \" + uistr(len));\n+        log uistr(i) + \" |-> \" + uistr(len);\n         add_node(ccx, i, empty_ann(len));\n     }\n }\n \n-fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f,\n-            &span sp, &ident i, &def_id d, &ann a) -> () {\n+fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f, &span sp, &ident i,\n+            &def_id d, &ann a) {\n     let @mutable vec[uint] node_ids = @mutable [];\n     node_ids_in_fn(f, sp, i, d, a, node_ids);\n     auto node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &span sp, &ident i,\n-                  &def_id f_id, &ann a)\n-    -> () {\n+fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id f_id,\n+                  &ann a) {\n     auto f_info = get_fn_info(ccx, f_id);\n     visit_fn(ccx, num_constraints(f_info), f, sp, i, f_id, a);\n }\n \n-fn annotate_crate(&crate_ctxt ccx, &crate crate) -> () {\n+fn annotate_crate(&crate_ctxt ccx, &crate crate) {\n     auto do_ann = walk::default_visitor();\n-    do_ann = rec(visit_fn_pre = bind annotate_in_fn(ccx,_,_,_,_,_)\n-                 with do_ann);\n+    do_ann =\n+        rec(visit_fn_pre=bind annotate_in_fn(ccx, _, _, _, _, _) with do_ann);\n     walk::walk_crate(do_ann, crate);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "689d00b47ff0b2d1044793956553c7bf1cece5ea", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 198, "deletions": 265, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::bitv;\n import std::vec;\n import std::vec::len;\n@@ -7,12 +8,9 @@ import std::option;\n import std::option::none;\n import std::option::some;\n import std::option::maybe;\n-\n import front::ast;\n import front::ast::*;\n-\n import middle::ty::expr_ann;\n-\n import util::common;\n import util::common::span;\n import util::common::respan;\n@@ -23,7 +21,6 @@ import util::common::log_expr_err;\n import util::common::uistr;\n import util::common::lit_eq;\n import pretty::pprust::path_to_str;\n-\n import tstate::ann::pre_and_post;\n import tstate::ann::pre_and_post_state;\n import tstate::ann::empty_ann;\n@@ -40,37 +37,23 @@ import tstate::ann::extend_poststate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n import tstate::ann::ts_ann;\n-\n import util::common::istr;\n import pretty::ppaux::constr_args_to_str;\n import pretty::ppaux::lit_to_str;\n \n-/* logging funs */\n \n-fn def_id_to_str(def_id d) -> str {\n-   ret (istr(d._0) + \",\" + istr(d._1));\n-}\n+/* logging funs */\n+fn def_id_to_str(def_id d) -> str { ret istr(d._0) + \",\" + istr(d._1); }\n \n fn comma_str(vec[@constr_arg_use] args) -> str {\n     auto res = \"\";\n     auto comma = false;\n     for (@constr_arg_use a in args) {\n-        if (comma) {\n-            res += \", \";\n-        }\n-        else {\n-            comma = true;\n-        }\n+        if (comma) { res += \", \"; } else { comma = true; }\n         alt (a.node) {\n-            case (carg_base) {\n-                res += \"*\";\n-            }\n-            case (carg_ident(?i)) {\n-                res += i;\n-            }\n-            case (carg_lit(?l)) {\n-                res += lit_to_str(l);\n-            }\n+            case (carg_base) { res += \"*\"; }\n+            case (carg_ident(?i)) { res += i; }\n+            case (carg_lit(?l)) { res += lit_to_str(l); }\n         }\n     }\n     ret res;\n@@ -82,132 +65,112 @@ fn constraint_to_str(&ty::ctxt tcx, &constr c) -> str {\n             ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n         }\n         case (npred(?p, ?args)) {\n-            ret path_to_str(p) + \"(\" + comma_str(args) + \")\"\n-                + \"[\" + tcx.sess.span_str(c.span) + \"]\";\n+            ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n+                    tcx.sess.span_str(c.span) + \"]\";\n         }\n     }\n }\n \n fn bitv_to_str(fn_ctxt fcx, bitv::t v) -> str {\n-  auto s = \"\";\n-  auto comma = false;\n-\n-  for (norm_constraint p in constraints(fcx)) {\n-      if (bitv::get(v, p.bit_num)) {\n-          s += (if (comma) { \", \" } else { comma = true; \"\" })\n-              + aux::constraint_to_str(fcx.ccx.tcx, p.c);\n-      }\n-  }\n-  ret s;\n+    auto s = \"\";\n+    auto comma = false;\n+    for (norm_constraint p in constraints(fcx)) {\n+        if (bitv::get(v, p.bit_num)) {\n+            s +=\n+                if (comma) { \", \" } else { comma = true; \"\" } +\n+                    aux::constraint_to_str(fcx.ccx.tcx, p.c);\n+        }\n+    }\n+    ret s;\n }\n \n-fn log_bitv(&fn_ctxt fcx, &bitv::t v) {\n-    log(bitv_to_str(fcx, v));\n-}\n+fn log_bitv(&fn_ctxt fcx, &bitv::t v) { log bitv_to_str(fcx, v); }\n \n-fn first_difference_string(&fn_ctxt fcx, &bitv::t expected,\n-                           &bitv::t actual) -> str {\n+fn first_difference_string(&fn_ctxt fcx, &bitv::t expected, &bitv::t actual)\n+   -> str {\n     let str s = \"\";\n     auto done = false;\n     for (norm_constraint c in constraints(fcx)) {\n         if (!done) {\n             if (bitv::get(expected, c.bit_num) &&\n-                !bitv::get(actual, c.bit_num)) {\n-                \n-            /*\n-              FIXME\n-              for fun, try either:\n-              * \"ret s\" after the assignment to s\n-              or\n-              * using break here\n-              */\n+                    !bitv::get(actual, c.bit_num)) {\n+                /*\n+                  FIXME\n+                  for fun, try either:\n+                  * \"ret s\" after the assignment to s\n+                  or\n+                  * using break here\n+                  */\n+\n                 s = constraint_to_str(fcx.ccx.tcx, c.c);\n-            \n-            done = true;\n+                done = true;\n             }\n         }\n     }\n     ret s;\n }\n \n-fn log_bitv_err(fn_ctxt fcx, bitv::t v) {\n-    log_err(bitv_to_str(fcx, v));\n-}\n+fn log_bitv_err(fn_ctxt fcx, bitv::t v) { log_err bitv_to_str(fcx, v); }\n \n-fn tos (vec[uint] v) -> str {\n-  auto res = \"\";\n-  for (uint i in v) {\n-    if (i == 0u) {\n-      res += \"0\";\n-    }\n-    else {\n-      res += \"1\";\n-    }\n-  }\n-  ret res;\n+fn tos(vec[uint] v) -> str {\n+    auto res = \"\";\n+    for (uint i in v) { if (i == 0u) { res += \"0\"; } else { res += \"1\"; } }\n+    ret res;\n }\n \n-fn log_cond(vec[uint] v) -> () {\n-    log(tos(v));\n-}\n-fn log_cond_err(vec[uint] v) -> () {\n-    log_err(tos(v));\n-}\n+fn log_cond(vec[uint] v) { log tos(v); }\n \n-fn log_pp(&pre_and_post pp) -> () {\n-  auto p1 = bitv::to_vec(pp.precondition);\n-  auto p2 = bitv::to_vec(pp.postcondition);\n-  log(\"pre:\");\n-  log_cond(p1);\n-  log(\"post:\");\n-  log_cond(p2);\n-}\n+fn log_cond_err(vec[uint] v) { log_err tos(v); }\n \n-fn log_pp_err(&pre_and_post pp) -> () {\n-  auto p1 = bitv::to_vec(pp.precondition);\n-  auto p2 = bitv::to_vec(pp.postcondition);\n-  log_err(\"pre:\");\n-  log_cond_err(p1);\n-  log_err(\"post:\");\n-  log_cond_err(p2);\n+fn log_pp(&pre_and_post pp) {\n+    auto p1 = bitv::to_vec(pp.precondition);\n+    auto p2 = bitv::to_vec(pp.postcondition);\n+    log \"pre:\";\n+    log_cond(p1);\n+    log \"post:\";\n+    log_cond(p2);\n }\n \n-fn log_states(&pre_and_post_state pp) -> () {\n-  auto p1 = bitv::to_vec(pp.prestate);\n-  auto p2 = bitv::to_vec(pp.poststate);\n-  log(\"prestate:\");\n-  log_cond(p1);\n-  log(\"poststate:\");\n-  log_cond(p2);\n+fn log_pp_err(&pre_and_post pp) {\n+    auto p1 = bitv::to_vec(pp.precondition);\n+    auto p2 = bitv::to_vec(pp.postcondition);\n+    log_err \"pre:\";\n+    log_cond_err(p1);\n+    log_err \"post:\";\n+    log_cond_err(p2);\n }\n \n-fn log_states_err(&pre_and_post_state pp) -> () {\n-  auto p1 = bitv::to_vec(pp.prestate);\n-  auto p2 = bitv::to_vec(pp.poststate);\n-  log_err(\"prestate:\");\n-  log_cond_err(p1);\n-  log_err(\"poststate:\");\n-  log_cond_err(p2);\n+fn log_states(&pre_and_post_state pp) {\n+    auto p1 = bitv::to_vec(pp.prestate);\n+    auto p2 = bitv::to_vec(pp.poststate);\n+    log \"prestate:\";\n+    log_cond(p1);\n+    log \"poststate:\";\n+    log_cond(p2);\n }\n \n-fn print_ident(&ident i) -> () {\n-  log(\" \" + i + \" \");\n+fn log_states_err(&pre_and_post_state pp) {\n+    auto p1 = bitv::to_vec(pp.prestate);\n+    auto p2 = bitv::to_vec(pp.poststate);\n+    log_err \"prestate:\";\n+    log_cond_err(p1);\n+    log_err \"poststate:\";\n+    log_cond_err(p2);\n }\n \n-fn print_idents(vec[ident] idents) -> () {\n-  if (len[ident](idents) == 0u) {\n-    ret;\n-  }\n-  else {\n-    log(\"an ident: \" + pop[ident](idents));\n-    print_idents(idents);\n-  }\n+fn print_ident(&ident i) { log \" \" + i + \" \"; }\n+\n+fn print_idents(vec[ident] idents) {\n+    if (len[ident](idents) == 0u) {\n+        ret;\n+    } else { log \"an ident: \" + pop[ident](idents); print_idents(idents); }\n }\n \n \n /* data structures */\n \n /**********************************************************************/\n+\n /* Two different data structures represent constraints in different\n  contexts: constraint and norm_constraint.\n \n@@ -234,116 +197,108 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n+type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n \n-type pred_desc_ = rec(vec[@constr_arg_use] args,\n-                      uint bit_num);\n type pred_desc = spanned[pred_desc_];\n+\n tag constraint {\n     cinit(uint, span, ident);\n     cpred(path, @mutable vec[pred_desc]);\n }\n-tag constr__ {\n-    ninit(ident);\n-    npred(path, vec[@constr_arg_use]);\n-}\n+\n+tag constr__ { ninit(ident); npred(path, vec[@constr_arg_use]); }\n+\n type constr_ = rec(def_id id, constr__ c);\n+\n type constr = spanned[constr_];\n-type norm_constraint = rec(uint bit_num,\n-                           constr c);\n+\n+type norm_constraint = rec(uint bit_num, constr c);\n+\n type constr_map = @std::map::hashmap[def_id, constraint];\n \n-type fn_info  = rec(constr_map constrs, uint num_constraints, controlflow cf);\n+type fn_info = rec(constr_map constrs, uint num_constraints, controlflow cf);\n+\n \n /* mapping from node ID to typestate annotation */\n type node_ann_table = @mutable vec[mutable ts_ann];\n \n+\n /* mapping from function name to fn_info map */\n type fn_info_map = @std::map::hashmap[def_id, fn_info];\n \n-type fn_ctxt    = rec(fn_info enclosing,\n-                      def_id id,\n-                      ident name,\n-                      crate_ctxt ccx);\n+type fn_ctxt = rec(fn_info enclosing, def_id id, ident name, crate_ctxt ccx);\n \n-type crate_ctxt = rec(ty::ctxt tcx,\n-                      node_ann_table node_anns,\n-                      fn_info_map fm);\n+type crate_ctxt = rec(ty::ctxt tcx, node_ann_table node_anns, fn_info_map fm);\n \n fn get_fn_info(&crate_ctxt ccx, def_id did) -> fn_info {\n     assert (ccx.fm.contains_key(did));\n     ret ccx.fm.get(did);\n }\n \n-fn add_node(&crate_ctxt ccx, uint i, &ts_ann a) -> () {\n-    auto sz = len(*(ccx.node_anns)); \n-    if (sz <= i) {\n-        grow(*(ccx.node_anns), (i - sz) + 1u, empty_ann(0u));\n-    }\n+fn add_node(&crate_ctxt ccx, uint i, &ts_ann a) {\n+    auto sz = len(*ccx.node_anns);\n+    if (sz <= i) { grow(*ccx.node_anns, i - sz + 1u, empty_ann(0u)); }\n     ccx.node_anns.(i) = a;\n }\n \n fn get_ts_ann(&crate_ctxt ccx, uint i) -> option::t[ts_ann] {\n-    if (i < len(*(ccx.node_anns))) {\n+    if (i < len(*ccx.node_anns)) {\n         ret some[ts_ann](ccx.node_anns.(i));\n-    }\n-    else {\n-        ret none[ts_ann];\n-    }\n+    } else { ret none[ts_ann]; }\n }\n-/********* utils ********/\n \n+\n+/********* utils ********/\n fn ann_to_ts_ann(&crate_ctxt ccx, &ann a) -> ts_ann {\n     alt (get_ts_ann(ccx, a.id)) {\n-        case (none)         { \n-            log_err (\"ann_to_ts_ann: no ts_ann for node_id \"\n-                     + uistr(a.id));\n+        case (none) {\n+            log_err \"ann_to_ts_ann: no ts_ann for node_id \" + uistr(a.id);\n             fail;\n         }\n-        case (some(?t))     { ret t; }\n+        case (some(?t)) { ret t; }\n     }\n }\n \n fn ann_to_poststate(&crate_ctxt ccx, ann a) -> poststate {\n     log \"ann_to_poststate\";\n-    ret (ann_to_ts_ann(ccx, a)).states.poststate;\n+    ret ann_to_ts_ann(ccx, a).states.poststate;\n }\n \n fn stmt_to_ann(&crate_ctxt ccx, &stmt s) -> ts_ann {\n     log \"stmt_to_ann\";\n-  alt (s.node) {\n-    case (stmt_decl(_,?a)) {\n-        ret ann_to_ts_ann(ccx, a);\n-    }\n-    case (stmt_expr(_,?a)) {\n-        ret ann_to_ts_ann(ccx, a);\n-    }\n-    case (stmt_crate_directive(_)) {\n-        log_err \"expecting an annotated statement here\";\n-        fail;\n+    alt (s.node) {\n+        case (stmt_decl(_, ?a)) { ret ann_to_ts_ann(ccx, a); }\n+        case (stmt_expr(_, ?a)) { ret ann_to_ts_ann(ccx, a); }\n+        case (stmt_crate_directive(_)) {\n+            log_err \"expecting an annotated statement here\";\n+            fail;\n+        }\n     }\n-  }\n }\n \n+\n /* fails if e has no annotation */\n fn expr_states(&crate_ctxt ccx, @expr e) -> pre_and_post_state {\n     log \"expr_states\";\n-    ret (ann_to_ts_ann(ccx, expr_ann(e)).states);\n+    ret ann_to_ts_ann(ccx, expr_ann(e)).states;\n }\n \n+\n /* fails if e has no annotation */\n fn expr_pp(&crate_ctxt ccx, @expr e) -> pre_and_post {\n     log \"expr_pp\";\n-    ret (ann_to_ts_ann(ccx, expr_ann(e)).conditions);\n+    ret ann_to_ts_ann(ccx, expr_ann(e)).conditions;\n }\n \n fn stmt_pp(&crate_ctxt ccx, &stmt s) -> pre_and_post {\n-    ret (stmt_to_ann(ccx, s).conditions);\n+    ret stmt_to_ann(ccx, s).conditions;\n }\n \n+\n /* fails if b has no annotation */\n fn block_pp(&crate_ctxt ccx, &block b) -> pre_and_post {\n     log \"block_pp\";\n-    ret (ann_to_ts_ann(ccx, b.node.a).conditions);\n+    ret ann_to_ts_ann(ccx, b.node.a).conditions;\n }\n \n fn clear_pp(pre_and_post pp) {\n@@ -358,69 +313,68 @@ fn clear_precond(&crate_ctxt ccx, &ann a) {\n \n fn block_states(&crate_ctxt ccx, &block b) -> pre_and_post_state {\n     log \"block_states\";\n-    ret (ann_to_ts_ann(ccx, b.node.a).states);\n+    ret ann_to_ts_ann(ccx, b.node.a).states;\n }\n \n fn stmt_states(&crate_ctxt ccx, &stmt s) -> pre_and_post_state {\n-    ret (stmt_to_ann(ccx, s)).states;\n+    ret stmt_to_ann(ccx, s).states;\n }\n \n fn expr_precond(&crate_ctxt ccx, @expr e) -> precond {\n-    ret (expr_pp(ccx, e)).precondition;\n+    ret expr_pp(ccx, e).precondition;\n }\n \n fn expr_postcond(&crate_ctxt ccx, @expr e) -> postcond {\n-    ret (expr_pp(ccx, e)).postcondition;\n+    ret expr_pp(ccx, e).postcondition;\n }\n \n fn expr_prestate(&crate_ctxt ccx, @expr e) -> prestate {\n-    ret (expr_states(ccx, e)).prestate;\n+    ret expr_states(ccx, e).prestate;\n }\n \n fn expr_poststate(&crate_ctxt ccx, @expr e) -> poststate {\n-    ret (expr_states(ccx, e)).poststate;\n+    ret expr_states(ccx, e).poststate;\n }\n \n fn stmt_precond(&crate_ctxt ccx, &stmt s) -> precond {\n-    ret (stmt_pp(ccx, s)).precondition;\n+    ret stmt_pp(ccx, s).precondition;\n }\n \n fn stmt_postcond(&crate_ctxt ccx, &stmt s) -> postcond {\n-    ret (stmt_pp(ccx, s)).postcondition;\n+    ret stmt_pp(ccx, s).postcondition;\n }\n \n fn states_to_poststate(&pre_and_post_state ss) -> poststate {\n-  ret ss.poststate;\n+    ret ss.poststate;\n }\n \n fn stmt_prestate(&crate_ctxt ccx, &stmt s) -> prestate {\n-    ret (stmt_states(ccx, s)).prestate;\n+    ret stmt_states(ccx, s).prestate;\n }\n \n fn stmt_poststate(&crate_ctxt ccx, &stmt s) -> poststate {\n-    ret (stmt_states(ccx, s)).poststate;\n+    ret stmt_states(ccx, s).poststate;\n }\n \n fn block_postcond(&crate_ctxt ccx, &block b) -> postcond {\n-    ret (block_pp(ccx, b)).postcondition;\n+    ret block_pp(ccx, b).postcondition;\n }\n \n fn block_poststate(&crate_ctxt ccx, &block b) -> poststate {\n-    ret (block_states(ccx, b)).poststate;\n+    ret block_states(ccx, b).poststate;\n }\n \n+\n /* sets the pre_and_post for an ann */\n fn with_pp(&crate_ctxt ccx, &ann a, pre_and_post p) {\n-    add_node(ccx, a.id, @rec(conditions=p,\n-                             states=empty_states(pps_len(p))));\n+    add_node(ccx, a.id, @rec(conditions=p, states=empty_states(pps_len(p))));\n }\n \n fn set_prestate_ann(&crate_ctxt ccx, &ann a, &prestate pre) -> bool {\n     log \"set_prestate_ann\";\n     ret set_prestate(ann_to_ts_ann(ccx, a), pre);\n }\n \n-\n fn extend_prestate_ann(&crate_ctxt ccx, &ann a, &prestate pre) -> bool {\n     log \"extend_prestate_ann\";\n     ret extend_prestate(ann_to_ts_ann(ccx, a).states.prestate, pre);\n@@ -436,15 +390,14 @@ fn extend_poststate_ann(&crate_ctxt ccx, &ann a, &poststate post) -> bool {\n     ret extend_poststate(ann_to_ts_ann(ccx, a).states.poststate, post);\n }\n \n-fn set_pre_and_post(&crate_ctxt ccx, &ann a,\n-                    &precond pre, &postcond post) -> () {\n+fn set_pre_and_post(&crate_ctxt ccx, &ann a, &precond pre, &postcond post) {\n     log \"set_pre_and_post\";\n     auto t = ann_to_ts_ann(ccx, a);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n-fn copy_pre_post(&crate_ctxt ccx, &ann a, &@expr sub) -> () {\n+fn copy_pre_post(&crate_ctxt ccx, &ann a, &@expr sub) {\n     log \"set_pre_and_post\";\n     auto p = expr_pp(ccx, sub);\n     auto t = ann_to_ts_ann(ccx, a);\n@@ -460,29 +413,25 @@ fn set_postcond_false(&crate_ctxt ccx, &ann a) {\n }\n \n fn pure_exp(&crate_ctxt ccx, &ann a, &prestate p) -> bool {\n-  auto changed = false;\n-  changed = extend_prestate_ann(ccx, a, p) || changed;\n-  changed = extend_poststate_ann(ccx, a, p) || changed;\n-  ret changed;\n+    auto changed = false;\n+    changed = extend_prestate_ann(ccx, a, p) || changed;\n+    changed = extend_poststate_ann(ccx, a, p) || changed;\n+    ret changed;\n }\n \n-fn fixed_point_states(&fn_ctxt fcx,\n-    fn (&fn_ctxt, &_fn) -> bool f, &_fn start) -> () {\n+fn fixed_point_states(&fn_ctxt fcx, fn(&fn_ctxt, &_fn) -> bool  f,\n+                      &_fn start) {\n+    auto changed = f(fcx, start);\n+    if (changed) {\n+        ret fixed_point_states(fcx, f, start);\n+    } else {\n+        // we're done!\n \n-  auto changed = f(fcx, start);\n-\n-  if (changed) {\n-    ret fixed_point_states(fcx, f, start);\n-  }\n-  else {\n-    // we're done!\n-    ret;\n-  }\n+        ret;\n+    }\n }\n \n-fn num_constraints(fn_info m) -> uint {\n-    ret m.num_constraints;\n-}\n+fn num_constraints(fn_info m) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n     let vec[mutable ts_ann] na = vec::empty_mut();\n@@ -492,40 +441,32 @@ fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n     alt (ccx.fm.find(d)) {\n         case (some(?fi)) { ret fi.cf; }\n-        case (none)      { ret return; } \n+        case (none) { ret return; }\n     }\n }\n \n+\n /* Use e's type to determine whether it returns.\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx,\n-                                             expr_ann(e)))) {\n-        case (ty::ty_fn(_,_,_,?cf,_)) {\n-            ret cf;\n-        }\n-        case (_) {\n-            ret return;\n-        }\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, expr_ann(e)))) {\n+        case (ty::ty_fn(_, _, _, ?cf, _)) { ret cf; }\n+        case (_) { ret return; }\n     }\n }\n \n fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ast::constr] {\n     alt (ty::struct(cx, ty::ann_to_type(cx, expr_ann(e)))) {\n-        case (ty::ty_fn(_,_,_,_,?cs)) {\n-            ret cs;\n-        }\n-        case (_) {\n-            ret [];\n-        }\n+        case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n+        case (_) { ret []; }\n     }\n }\n \n fn ann_to_def_strict(&ty::ctxt cx, &ann a) -> def {\n     alt (cx.def_map.find(a.id)) {\n-        case (none) { \n-            log_err(\"ann_to_def: node_id \" + uistr(a.id) + \" has no def\");\n+        case (none) {\n+            log_err \"ann_to_def: node_id \" + uistr(a.id) + \" has no def\";\n             fail;\n         }\n         case (some(?d)) { ret d; }\n@@ -544,49 +485,48 @@ fn norm_a_constraint(&def_id id, &constraint c) -> vec[norm_constraint] {\n         case (cpred(?p, ?descs)) {\n             let vec[norm_constraint] res = [];\n             for (pred_desc pd in *descs) {\n-                vec::push(res, rec(bit_num=pd.node.bit_num,\n-                  c=respan(pd.span, rec(id=id, c=npred(p, pd.node.args)))));\n+                vec::push(res,\n+                          rec(bit_num=pd.node.bit_num,\n+                              c=respan(pd.span,\n+                                       rec(id=id,\n+                                           c=npred(p, pd.node.args)))));\n             }\n             ret res;\n         }\n     }\n }\n \n+\n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n     let vec[norm_constraint] res = [];\n-    for each (@tup(def_id, constraint) p in\n-              fcx.enclosing.constrs.items()) {\n+    for each (@tup(def_id, constraint) p in fcx.enclosing.constrs.items()) {\n         res += norm_a_constraint(p._0, p._1);\n     }\n     ret res;\n }\n \n+\n // FIXME:\n // this probably doesn't handle name shadowing well (or at all)\n // variables should really always be id'd by def_id and not ident\n-fn match_args(&fn_ctxt fcx, vec[pred_desc] occs,\n-              vec[@constr_arg_use] occ) -> uint {\n-    log (\"match_args: looking at \" +\n-             pretty::ppaux::constr_args_to_str_1(occ));\n+fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n+   uint {\n+    log \"match_args: looking at \" + pretty::ppaux::constr_args_to_str_1(occ);\n     for (pred_desc pd in occs) {\n-        log (\"match_args: candidate \" + pred_desc_to_str(pd));\n-        if (ty::args_eq(str::eq, pd.node.args, occ)) {\n-            ret pd.node.bit_num;\n-        }\n+        log \"match_args: candidate \" + pred_desc_to_str(pd);\n+        if (ty::args_eq(str::eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n     }\n-    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");  \n+    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n \n fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n     alt (tcx.def_map.find(t)) {\n         case (none) {\n             tcx.sess.bug(\"def_id_for_constr: bad node_id \" + uistr(t));\n-         }\n-        case (some(def_fn(?i))) {\n-            ret i;\n         }\n+        case (some(def_fn(?i))) { ret i; }\n         case (_) {\n             tcx.sess.bug(\"def_id_for_constr: pred is not a function\");\n         }\n@@ -598,60 +538,59 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n         case (expr_path(?p, _)) {\n             if (vec::len(p.node.idents) == 1u) {\n                 ret @respan(p.span, carg_ident[ident](p.node.idents.(0)));\n-            }\n-            else {\n-                tcx.sess.bug(\"exprs_to_constr_args: non-local variable \"\n-                             + \"as pred arg\");\n+            } else {\n+                tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n+                                 \"as pred arg\");\n             }\n         }\n-        case (expr_lit(?l, _)) {\n-            ret @respan(e.span, carg_lit(l));\n-        }\n+        case (expr_lit(?l, _)) { ret @respan(e.span, carg_lit(l)); }\n         case (_) {\n             tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n         }\n     }\n }\n \n-fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args)\n-    -> vec[@constr_arg_use] {\n+fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) ->\n+   vec[@constr_arg_use] {\n     auto f = bind expr_to_constr_arg(tcx, _);\n-    ret vec::map(f, args); \n+    ret vec::map(f, args);\n }\n \n fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n     alt (e.node) {\n-        // FIXME\n-        // change the first pattern to expr_path to test a typechecker bug\n-        case (expr_call(?operator, ?args, _)) {\n+        case (\n+             // FIXME change the first pattern to expr_path to test a\n+             // typechecker bug\n+             expr_call(?operator, ?args, _)) {\n             alt (operator.node) {\n                 case (expr_path(?p, ?a)) {\n                     ret respan(e.span,\n-                          rec(id=def_id_for_constr(tcx, a.id),\n-                              c=npred(p, \n-                                      exprs_to_constr_args(tcx, args)))); \n+                               rec(id=def_id_for_constr(tcx, a.id),\n+                                   c=npred(p,\n+                                           exprs_to_constr_args(tcx, args))));\n                 }\n                 case (_) {\n-                    tcx.sess.span_err(operator.span, \"Internal error: \" +\n-                       \" ill-formed operator in predicate\");\n+                    tcx.sess.span_err(operator.span,\n+                                      \"Internal error: \" +\n+                                          \" ill-formed operator \\\n+                                            in predicate\");\n                 }\n             }\n         }\n         case (_) {\n-            tcx.sess.span_err(e.span, \"Internal error: \" +\n-                              \" ill-formed predicate\");\n+            tcx.sess.span_err(e.span,\n+                              \"Internal error: \" + \" ill-formed predicate\");\n         }\n     }\n }\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n-    ret (\"<\" + uistr(p.node.bit_num) + \", \" + \n-         pretty::ppaux::constr_args_to_str_1(p.node.args) + \">\");\n+    ret \"<\" + uistr(p.node.bit_num) + \", \" +\n+            pretty::ppaux::constr_args_to_str_1(p.node.args) + \">\";\n }\n \n-fn substitute_constr_args(&ty::ctxt cx,\n-                          &vec[@expr] actuals, &@ast::constr c)\n-    -> constr__ {\n+fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals, &@ast::constr c)\n+   -> constr__ {\n     let vec[@constr_arg_use] res = [];\n     for (@constr_arg a in c.node.args) {\n         res += [substitute_arg(cx, actuals, a)];\n@@ -661,31 +600,26 @@ fn substitute_constr_args(&ty::ctxt cx,\n \n type subst = vec[tup(arg, @expr)];\n \n-fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a)\n-     -> @constr_arg_use {\n+fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a) ->\n+   @constr_arg_use {\n     auto num_actuals = vec::len(actuals);\n     alt (a.node) {\n         case (carg_ident(?i)) {\n             if (i < num_actuals) {\n                 ret expr_to_constr_arg(cx, actuals.(i));\n-            }\n-            else {\n+            } else {\n                 cx.sess.span_err(a.span, \"Constraint argument out of bounds\");\n             }\n         }\n         case (carg_base) { ret @respan(a.span, carg_base); }\n-        case (carg_lit(?l))  { ret @respan(a.span, carg_lit(l)); }\n+        case (carg_lit(?l)) { ret @respan(a.span, carg_lit(l)); }\n     }\n }\n \n fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n     alt (vec::last(p.node.idents)) {\n-        case (none) {\n-            cx.sess.span_err(p.span, \"Malformed path\");\n-        }\n-        case (some(?i)) {\n-            ret i;\n-        }\n+        case (none) { cx.sess.span_err(p.span, \"Malformed path\"); }\n+        case (some(?i)) { ret i; }\n     }\n }\n //\n@@ -698,4 +632,3 @@ fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //\n-"}, {"sha": "99b4c80820ea2b884664b3393f81c242075fa1d7", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 56, "deletions": 74, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,10 +1,9 @@\n+\n import std::bitv;\n import std::vec;\n import std::vec::len;\n import std::vec::slice;\n-\n import front::ast::*;\n-\n import aux::fn_ctxt;\n import aux::fn_info;\n import aux::log_bitv;\n@@ -16,7 +15,6 @@ import aux::npred;\n import aux::pred_desc;\n import aux::match_args;\n import aux::constr_;\n-\n import tstate::aux::ann_to_ts_ann;\n import tstate::ann::pre_and_post;\n import tstate::ann::precond;\n@@ -34,30 +32,26 @@ import tstate::ann::clone;\n import tstate::ann::set_in_postcond;\n import tstate::ann::set_in_poststate;\n import tstate::ann::clear_in_poststate;\n-           \n+\n fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n     assert (fcx.enclosing.constrs.contains_key(c.id));\n     auto res = fcx.enclosing.constrs.get(c.id);\n     alt (c.c) {\n         case (ninit(_)) {\n             alt (res) {\n-                case (cinit(?n,_,_)) {\n-                    ret n;\n-                }\n+                case (cinit(?n, _, _)) { ret n; }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\"\n-                                         + \" found a pred constraint\");\n+                                             + \" found a pred constraint\");\n                 }\n             }\n         }\n         case (npred(_, ?args)) {\n             alt (res) {\n-                case (cpred(_, ?descs)) {\n-                    ret match_args(fcx, *descs, args);\n-                }\n+                case (cpred(_, ?descs)) { ret match_args(fcx, *descs, args); }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n-                                         + \" found an init constraint\");\n+                                             + \" found an init constraint\");\n                 }\n             }\n         }\n@@ -68,84 +62,75 @@ fn promises(&fn_ctxt fcx, &poststate p, &constr_ c) -> bool {\n     ret bitv::get(p, bit_num(fcx, c));\n }\n \n+\n // Given a list of pres and posts for exprs e0 ... en,\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n fn seq_preconds(fn_ctxt fcx, vec[pre_and_post] pps) -> precond {\n-  let uint sz = len[pre_and_post](pps);\n-  let uint num_vars = num_constraints(fcx.enclosing);\n-\n-  if (sz >= 1u) {\n-    auto first = pps.(0);\n-    assert (pps_len(first) == num_vars);\n-    let precond rest = seq_preconds(fcx,\n-                         slice[pre_and_post](pps, 1u, sz));\n-    difference(rest, first.postcondition);\n-    auto res = clone(first.precondition);\n-    union(res, rest);\n-\n-    log(\"seq_preconds:\");\n-    log(\"first.postcondition =\");\n-    log_bitv(fcx, first.postcondition);\n-    log(\"rest =\");\n-    log_bitv(fcx, rest);\n-    log(\"returning\");\n-    log_bitv(fcx, res);\n-\n-    ret res;\n-  }\n-  else {\n-      ret true_precond(num_vars);\n-  }\n+    let uint sz = len[pre_and_post](pps);\n+    let uint num_vars = num_constraints(fcx.enclosing);\n+    if (sz >= 1u) {\n+        auto first = pps.(0);\n+        assert (pps_len(first) == num_vars);\n+        let precond rest =\n+            seq_preconds(fcx, slice[pre_and_post](pps, 1u, sz));\n+        difference(rest, first.postcondition);\n+        auto res = clone(first.precondition);\n+        union(res, rest);\n+        log \"seq_preconds:\";\n+        log \"first.postcondition =\";\n+        log_bitv(fcx, first.postcondition);\n+        log \"rest =\";\n+        log_bitv(fcx, rest);\n+        log \"returning\";\n+        log_bitv(fcx, res);\n+        ret res;\n+    } else { ret true_precond(num_vars); }\n }\n \n+\n /* works on either postconds or preconds\n  should probably rethink the whole type synonym situation */\n fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = vec::len[postcond](rest);\n-\n-  if (sz > 0u) {\n-    auto other = rest.(0);\n-    union(first, other);\n-    union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n-  }\n-\n-  ret first;\n+    auto sz = vec::len[postcond](rest);\n+    if (sz > 0u) {\n+        auto other = rest.(0);\n+        union(first, other);\n+        union_postconds_go(first,\n+                           slice[postcond](rest, 1u, len[postcond](rest)));\n+    }\n+    ret first;\n }\n \n fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n-  if (len[postcond](pcs) > 0u) {\n-      ret union_postconds_go(bitv::clone(pcs.(0)), pcs);\n-  }\n-  else {\n-      ret empty_prestate(nv);\n-  }\n+    if (len[postcond](pcs) > 0u) {\n+        ret union_postconds_go(bitv::clone(pcs.(0)), pcs);\n+    } else { ret empty_prestate(nv); }\n }\n \n+\n /* Gee, maybe we could use foldl or something */\n fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = vec::len[postcond](rest);\n-\n-  if (sz > 0u) {\n-    auto other = rest.(0);\n-    intersect(first, other);\n-    intersect_postconds_go(first, slice[postcond](rest, 1u,\n-                                                  len[postcond](rest)));\n-  }\n-\n-  ret first;\n+    auto sz = vec::len[postcond](rest);\n+    if (sz > 0u) {\n+        auto other = rest.(0);\n+        intersect(first, other);\n+        intersect_postconds_go(first,\n+                               slice[postcond](rest, 1u,\n+                                               len[postcond](rest)));\n+    }\n+    ret first;\n }\n \n fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n-  assert (len[postcond](pcs) > 0u);\n-\n-  ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n+    assert (len[postcond](pcs) > 0u);\n+    ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n }\n \n fn gen(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n-  ret set_in_postcond(bit_num(fcx, c),\n-                      (ann_to_ts_ann(fcx.ccx, a)).conditions);\n+    ret set_in_postcond(bit_num(fcx, c),\n+                        ann_to_ts_ann(fcx.ccx, a).conditions);\n }\n \n fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n@@ -155,17 +140,14 @@ fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n }\n \n fn gen_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n-  log \"gen_poststate\";\n-  ret set_in_poststate(bit_num(fcx, c),\n-                       (ann_to_ts_ann(fcx.ccx, a)).states);\n+    log \"gen_poststate\";\n+    ret set_in_poststate(bit_num(fcx, c), ann_to_ts_ann(fcx.ccx, a).states);\n }\n \n fn kill_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n-  log \"kill_poststate\";\n-  ret clear_in_poststate(bit_num(fcx, c),\n-                         (ann_to_ts_ann(fcx.ccx, a)).states);\n+    log \"kill_poststate\";\n+    ret clear_in_poststate(bit_num(fcx, c), ann_to_ts_ann(fcx.ccx, a).states);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "de75229558068995f62c9dee48c798c5773cd876", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import front::ast;\n import front::ast::method;\n import front::ast::ann;\n@@ -13,7 +14,6 @@ import front::ast::ty_param;\n import front::ast::crate;\n import front::ast::return;\n import front::ast::noreturn;\n-\n import front::ast::expr;\n import middle::ty::type_is_nil;\n import middle::ty::ret_ty_of_fn;\n@@ -36,12 +36,10 @@ import std::vec::slice;\n import std::vec::unzip;\n import std::vec::plus_option;\n import std::vec::cat_options;\n-\n import std::option;\n import std::option::t;\n import std::option::some;\n import std::option::none;\n-\n import aux::fn_ctxt;\n import aux::crate_ctxt;\n import aux::new_crate_ctxt;\n@@ -54,39 +52,37 @@ import aux::num_constraints;\n import aux::fixed_point_states;\n import aux::bitv_to_str;\n import aux::first_difference_string;\n-\n import pretty::pprust::ty_to_str;\n import util::common::log_stmt_err;\n import aux::log_bitv_err;\n import bitvectors::promises;\n-\n import annotate::annotate_crate;\n import collect_locals::mk_f_to_fn_info;\n import pre_post_conditions::fn_pre_post;\n import states::find_pre_post_state_fn;\n \n-fn check_states_expr(&fn_ctxt fcx, @expr e) -> () {\n-    let precond prec  = expr_precond(fcx.ccx, e);\n+fn check_states_expr(&fn_ctxt fcx, @expr e) {\n+    let precond prec = expr_precond(fcx.ccx, e);\n     let prestate pres = expr_prestate(fcx.ccx, e);\n-\n     if (!implies(pres, prec)) {\n         auto s = \"\";\n         auto diff = first_difference_string(fcx, prec, pres);\n-        s += (\"Unsatisfied precondition constraint (for example, \"\n-              + diff + \") for expression:\\n\");\n+        s +=\n+            \"Unsatisfied precondition constraint (for example, \" + diff +\n+                \") for expression:\\n\";\n         s += pretty::pprust::expr_to_str(e);\n-        s += (\"\\nPrecondition:\\n\");\n+        s += \"\\nPrecondition:\\n\";\n         s += bitv_to_str(fcx, prec);\n-        s += (\"\\nPrestate:\\n\");\n+        s += \"\\nPrestate:\\n\";\n         s += bitv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_err(e.span, s);\n     }\n }\n \n-fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n+fn check_states_stmt(&fn_ctxt fcx, &stmt s) {\n     auto a = stmt_to_ann(fcx.ccx, s);\n-    let precond prec    = ann_precond(a);\n-    let prestate pres   = ann_prestate(a);\n+    let precond prec = ann_precond(a);\n+    let prestate pres = ann_prestate(a);\n \n     /*    \n       log_err(\"check_states_stmt:\");\n@@ -96,113 +92,109 @@ fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n       log_err(\"pres = \");\n       log_bitv_err(fcx.enclosing, pres);\n     */\n-\n     if (!implies(pres, prec)) {\n         auto ss = \"\";\n         auto diff = first_difference_string(fcx, prec, pres);\n-        ss += (\"Unsatisfied precondition constraint (for example, \"\n-              + diff + \") for statement:\\n\");\n+        ss +=\n+            \"Unsatisfied precondition constraint (for example, \" + diff +\n+                \") for statement:\\n\";\n         ss += pretty::pprust::stmt_to_str(s);\n-        ss += (\"\\nPrecondition:\\n\");\n+        ss += \"\\nPrecondition:\\n\";\n         ss += bitv_to_str(fcx, prec);\n-        ss += (\"\\nPrestate: \\n\");\n+        ss += \"\\nPrestate: \\n\";\n         ss += bitv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_err(s.span, ss);\n     }\n }\n \n-fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n+fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) {\n     auto enclosing = fcx.enclosing;\n-    auto nv   = num_constraints(enclosing);\n+    auto nv = num_constraints(enclosing);\n     auto post = @mutable empty_poststate(nv);\n-\n-    fn do_one_(fn_ctxt fcx, &@stmt s, @mutable poststate post) -> () {\n+    fn do_one_(fn_ctxt fcx, &@stmt s, @mutable poststate post) {\n         check_states_stmt(fcx, *s);\n         *post = stmt_poststate(fcx.ccx, *s);\n     }\n-\n     auto do_one = bind do_one_(fcx, _, post);\n- \n     vec::map[@stmt, ()](do_one, f.body.node.stmts);\n-    fn do_inner_(fn_ctxt fcx, &@expr e, @mutable poststate post) -> () {\n+    fn do_inner_(fn_ctxt fcx, &@expr e, @mutable poststate post) {\n         check_states_expr(fcx, e);\n         *post = expr_poststate(fcx.ccx, e);\n     }\n     auto do_inner = bind do_inner_(fcx, _, post);\n     option::map[@expr, ()](do_inner, f.body.node.expr);\n-  \n     auto cf = fcx.enclosing.cf;\n     /* Finally, check that the return value is initialized */\n+\n     let aux::constr_ ret_c = rec(id=fcx.id, c=aux::ninit(fcx.name));\n-    if (f.proto == ast::proto_fn\n-        && ! promises(fcx, {*post}, ret_c)\n-        && ! type_is_nil(fcx.ccx.tcx,\n-                         ret_ty_of_fn(fcx.ccx.tcx, a))\n-        && cf == return) {\n-        fcx.ccx.tcx.sess.span_note(f.body.span, \"In function \" + fcx.name +\n-          \", not all control paths return a value\");\n+    if (f.proto == ast::proto_fn && !promises(fcx, { *post }, ret_c) &&\n+            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, a)) &&\n+            cf == return) {\n+        fcx.ccx.tcx.sess.span_note(f.body.span,\n+                                   \"In function \" + fcx.name +\n+                                       \", not all control paths \\\n+                                        return a value\");\n         fcx.ccx.tcx.sess.span_err(f.decl.output.span,\n-            \"see declared return type of '\" + ty_to_str(*f.decl.output) +\n-            \"'\");\n-    }\n-    else if (cf == noreturn) {\n+                                  \"see declared return type of '\" +\n+                                      ty_to_str(*f.decl.output) + \"'\");\n+    } else if (cf == noreturn) {\n+\n         // check that this really always fails\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n-        if (! promises(fcx, {*post}, ret_c)) {\n+        if (!promises(fcx, { *post }, ret_c)) {\n             fcx.ccx.tcx.sess.span_err(f.body.span,\n-              \"In non-returning function \" + fcx.name +\n-              \", some control paths may return to the caller\");\n+                                      \"In non-returning function \" + fcx.name\n+                                      + \", some control paths may \\\n+                                           return to the caller\");\n         }\n     }\n-\n }\n \n-fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n+fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a) {\n     /* Compute the pre- and post-states for this function */\n+\n     auto g = find_pre_post_state_fn;\n     fixed_point_states(fcx, g, f);\n-    \n     /* Now compare each expr's pre-state to its precondition\n        and post-state to its postcondition */\n+\n     check_states_against_conditions(fcx, f, a);\n }\n \n-fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i,\n-             &def_id id, &ann a) -> () {\n+fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n+             &ann a) {\n     /* Look up the var-to-bit-num map for this function */\n+\n     assert (ccx.fm.contains_key(id));\n     auto f_info = ccx.fm.get(id);\n-\n     auto fcx = rec(enclosing=f_info, id=id, name=i, ccx=ccx);\n     check_fn_states(fcx, f, a);\n }\n \n-\n-\n-fn check_crate(ty::ctxt cx, @crate crate) -> () {\n+fn check_crate(ty::ctxt cx, @crate crate) {\n     let crate_ctxt ccx = new_crate_ctxt(cx);\n-\n     /* Build the global map from function id to var-to-bit-num-map */\n+\n     mk_f_to_fn_info(ccx, crate);\n-  \n     /* Add a blank ts_ann for every statement (and expression) */\n-    annotate_crate(ccx, *crate);\n \n+    annotate_crate(ccx, *crate);\n     /* Compute the pre and postcondition for every subexpression */\n+\n     auto do_pre_post = walk::default_visitor();\n-    do_pre_post = rec(visit_fn_pre = bind fn_pre_post(ccx,_,_,_,_,_)\n-                      with do_pre_post);\n+    do_pre_post =\n+        rec(visit_fn_pre=bind fn_pre_post(ccx, _, _, _, _, _)\n+            with do_pre_post);\n     walk::walk_crate(do_pre_post, *crate);\n-    \n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n+\n     auto do_states = walk::default_visitor();\n-    do_states = rec(visit_fn_pre = bind fn_states(ccx,_,_,_,_,_)\n-                    with do_states);\n+    do_states =\n+        rec(visit_fn_pre=bind fn_states(ccx, _, _, _, _, _) with do_states);\n     walk::walk_crate(do_states, *crate);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "3c7efcdbe1e038dd84dca991986cb59014460030", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,14 +1,12 @@\n+\n import std::vec;\n import std::vec::plus_option;\n-\n import front::ast;\n import front::ast::*;\n import option::*;\n-\n import middle::walk::walk_crate;\n import middle::walk::walk_fn;\n import middle::walk::ast_visitor;\n-\n import aux::cinit;\n import aux::ninit;\n import aux::npred;\n@@ -21,36 +19,38 @@ import aux::constr_map;\n import aux::expr_to_constr;\n import aux::constraints_expr;\n import aux::ann_to_def_strict;\n-\n import util::common::new_def_hash;\n import util::common::uistr;\n import util::common::span;\n import util::common::respan;\n \n type ctxt = rec(@mutable vec[aux::constr] cs, ty::ctxt tcx);\n \n-fn collect_local(&ctxt cx, &@local loc) -> () {\n-    log(\"collect_local: pushing \" + loc.node.ident);\n-    vec::push(*cx.cs, respan(loc.span,\n-                             rec(id=loc.node.id,\n-                                 c=ninit(loc.node.ident))));\n+fn collect_local(&ctxt cx, &@local loc) {\n+    log \"collect_local: pushing \" + loc.node.ident;\n+    vec::push(*cx.cs,\n+              respan(loc.span, rec(id=loc.node.id, c=ninit(loc.node.ident))));\n }\n \n-fn collect_pred(&ctxt cx, &@expr e) -> () {\n+fn collect_pred(&ctxt cx, &@expr e) {\n     alt (e.node) {\n         case (expr_check(?e, _)) {\n             vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n         }\n-        // If it's a call, generate appropriate instances of the\n-        // call's constraints.\n-        case (expr_call(?operator, ?operands, ?a)) {\n+        case (\n+             // If it's a call, generate appropriate instances of the\n+             // call's constraints.\n+             expr_call(?operator, ?operands, ?a)) {\n             for (@ast::constr c in constraints_expr(cx.tcx, operator)) {\n                 auto d_id = ann_to_def_strict(cx.tcx, c.node.ann);\n                 alt (d_id) {\n                     case (def_fn(?an_id)) {\n-                        let aux::constr ct = respan(c.span,\n-                          rec(id=an_id, c=aux::substitute_constr_args(cx.tcx,\n-                                            operands, c)));\n+                        let aux::constr ct =\n+                            respan(c.span,\n+                                   rec(id=an_id,\n+                                       c=aux::substitute_constr_args(cx.tcx,\n+                                                                     operands,\n+                                                                     c)));\n                         vec::push(*cx.cs, ct);\n                     }\n                     case (_) {\n@@ -60,100 +60,98 @@ fn collect_pred(&ctxt cx, &@expr e) -> () {\n                 }\n             }\n             // FIXME: constraints on result type\n+\n         }\n         case (_) { }\n     }\n }\n \n fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n-    -> ctxt {\n+   -> ctxt {\n     let ctxt cx = rec(cs=@mutable vec::alloc(0u), tcx=tcx);\n     auto visitor = walk::default_visitor();\n-    visitor = rec(visit_local_pre=bind collect_local(cx,_),\n-                  visit_expr_pre=bind collect_pred(cx,_)\n-                  with visitor);\n+    visitor =\n+        rec(visit_local_pre=bind collect_local(cx, _),\n+            visit_expr_pre=bind collect_pred(cx, _) with visitor);\n     walk_fn(visitor, f, sp, i, d, a);\n     ret cx;\n }\n \n-fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl)\n-    -> uint {\n-    log(aux::constraint_to_str(tcx, c) + \" |-> \"\n-        + util::common::uistr(next));\n+fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n+   uint {\n+    log aux::constraint_to_str(tcx, c) + \" |-> \" + util::common::uistr(next);\n     alt (c.node.c) {\n-        case (ninit(?i)) {\n-            tbl.insert(c.node.id, cinit(next, c.span, i));\n-        }\n+        case (ninit(?i)) { tbl.insert(c.node.id, cinit(next, c.span, i)); }\n         case (npred(?p, ?args)) {\n             alt (tbl.find(c.node.id)) {\n                 case (some(?ct)) {\n                     alt (ct) {\n-                        case (cinit(_,_,_)) {\n-                            tcx.sess.bug(\"add_constraint: same def_id used\"\n-                                         + \" as a variable and a pred\");\n+                        case (cinit(_, _, _)) {\n+                            tcx.sess.bug(\"add_constraint: same def_id used\" +\n+                                             \" as a variable and a pred\");\n                         }\n                         case (cpred(_, ?pds)) {\n-                             vec::push(*pds, respan(c.span,\n-                               rec(args=args, bit_num=next)));\n+                            vec::push(*pds,\n+                                      respan(c.span,\n+                                             rec(args=args, bit_num=next)));\n                         }\n                     }\n                 }\n                 case (none) {\n-                    tbl.insert(c.node.id, cpred(p,\n-                      @mutable [respan(c.span, rec(args=args,\n-                                                   bit_num=next))]));\n+                    tbl.insert(c.node.id,\n+                               cpred(p,\n+                                     @mutable [respan(c.span,\n+                                                      rec(args=args,\n+                                                          bit_num=next))]));\n                 }\n             }\n         }\n     }\n-    ret (next + 1u);\n+    ret next + 1u;\n }\n \n+\n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp,\n-              &ident f_name, &def_id f_id, &ann a)\n-    -> () {\n+fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp, &ident f_name,\n+              &def_id f_id, &ann a) {\n     auto res_map = @new_def_hash[constraint]();\n     let uint next = 0u;\n     let vec[arg] f_args = f.decl.inputs;\n-\n     /* ignore args, which we know are initialized;\n        just collect locally declared vars */\n \n     let ctxt cx = find_locals(ccx.tcx, f, f_sp, f_name, f_id, a);\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for (aux::constr c in {*cx.cs}) {\n+    for (aux::constr c in { *cx.cs }) {\n         next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n+\n     add_constraint(cx.tcx, respan(f_sp, rec(id=f_id, c=ninit(f_name))), next,\n                    res_map);\n-    \n-    auto res = rec(constrs=res_map,\n-                            num_constraints=vec::len(*cx.cs) + 1u,\n-                   cf=f.decl.cf);\n-\n+    auto res =\n+        rec(constrs=res_map,\n+            num_constraints=vec::len(*cx.cs) + 1u,\n+            cf=f.decl.cf);\n     ccx.fm.insert(f_id, res);\n-    \n-    log(f_name + \" has \" + uistr(num_constraints(res)) + \" constraints\");\n-\n+    log f_name + \" has \" + uistr(num_constraints(res)) + \" constraints\";\n }\n \n+\n /* initializes the global fn_info_map (mapping each function ID, including\n    nested locally defined functions, onto a mapping from local variable name\n    to bit number) */\n-fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) -> () {\n-  let ast_visitor vars_visitor = walk::default_visitor();\n-  vars_visitor = rec(visit_fn_pre=bind mk_fn_info(ccx,_,_,_,_,_)\n-                     with vars_visitor);\n-\n-  walk_crate(vars_visitor, *c);\n+fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) {\n+    let ast_visitor vars_visitor = walk::default_visitor();\n+    vars_visitor =\n+        rec(visit_fn_pre=bind mk_fn_info(ccx, _, _, _, _, _)\n+            with vars_visitor);\n+    walk_crate(vars_visitor, *c);\n }\n-\n //\n // Local Variables:\n // mode: rust\n@@ -164,4 +162,3 @@ fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) -> () {\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //\n-"}, {"sha": "98c7821235ab09df32c25e6cab19c01e493f8352", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 201, "deletions": 224, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::vec;\n import std::vec::plus_option;\n import std::option;\n@@ -44,24 +45,21 @@ import aux::ann_to_ts_ann;\n import aux::set_postcond_false;\n import aux::controlflow_expr;\n import aux::expr_to_constr;\n+\n //import aux::constr_to_constr_occ;\n import aux::constraints_expr;\n import aux::substitute_constr_args;\n import aux::ninit;\n import aux::npred;\n import aux::path_to_ident;\n-\n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n import bitvectors::intersect_postconds;\n import bitvectors::declare_var;\n import bitvectors::bit_num;\n import bitvectors::gen;\n-\n import front::ast::*;\n-\n import middle::ty::expr_ann;\n-\n import util::common::new_def_hash;\n import util::common::decl_lhs;\n import util::common::uistr;\n@@ -77,180 +75,174 @@ import util::common::log_block;\n import util::common::span;\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n-    log(\"implement find_pre_post_mod!\");\n+    log \"implement find_pre_post_mod!\";\n     fail;\n }\n \n fn find_pre_post_native_mod(&native_mod m) -> native_mod {\n-    log(\"implement find_pre_post_native_mod\");\n+    log \"implement find_pre_post_native_mod\";\n     fail;\n }\n \n-\n-fn find_pre_post_obj(&crate_ctxt ccx, _obj o) -> () {\n-    fn do_a_method(crate_ctxt ccx, &@method m) -> () {\n+fn find_pre_post_obj(&crate_ctxt ccx, _obj o) {\n+    fn do_a_method(crate_ctxt ccx, &@method m) {\n         assert (ccx.fm.contains_key(m.node.id));\n-        let fn_ctxt fcx = rec(enclosing=ccx.fm.get(m.node.id),\n-                       id=m.node.id, name=m.node.ident, ccx=ccx);\n+        let fn_ctxt fcx =\n+            rec(enclosing=ccx.fm.get(m.node.id),\n+                id=m.node.id,\n+                name=m.node.ident,\n+                ccx=ccx);\n         find_pre_post_fn(fcx, m.node.meth);\n     }\n-    auto f = bind do_a_method(ccx,_);\n+    auto f = bind do_a_method(ccx, _);\n     vec::map[@method, ()](f, o.methods);\n     option::map[@method, ()](f, o.dtor);\n }\n \n-fn find_pre_post_item(&crate_ctxt ccx, &item i) -> () {\n+fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n     alt (i.node) {\n         case (item_const(?id, ?t, ?e, _, ?di, ?a)) {\n             // make a fake fcx\n-            auto fake_fcx = rec(enclosing=\n-                rec(constrs=@new_def_hash[constraint](),\n-                    num_constraints=0u,\n-                    cf=return),\n-                                id=tup(0,0),\n-                                name=\"\",\n-                                ccx=ccx);\n+\n+            auto fake_fcx =\n+                rec(enclosing=rec(constrs=@new_def_hash[constraint](),\n+                                  num_constraints=0u,\n+                                  cf=return),\n+                    id=tup(0, 0),\n+                    name=\"\",\n+                    ccx=ccx);\n             find_pre_post_expr(fake_fcx, e);\n         }\n         case (item_fn(?id, ?f, ?ps, _, ?di, ?a)) {\n             assert (ccx.fm.contains_key(di));\n-            auto fcx = rec(enclosing=ccx.fm.get(di),\n-                           id=di, name=id, ccx=ccx);\n+            auto fcx = rec(enclosing=ccx.fm.get(di), id=di, name=id, ccx=ccx);\n             find_pre_post_fn(fcx, f);\n         }\n-        case (item_mod(?id, ?m, _, ?di)) {\n-            find_pre_post_mod(m);\n-        }\n+        case (item_mod(?id, ?m, _, ?di)) { find_pre_post_mod(m); }\n         case (item_native_mod(?id, ?nm, _, ?di)) {\n             find_pre_post_native_mod(nm);\n         }\n-        case (item_ty(_,_,_,_,_,_)) {\n-            ret;\n-        }\n-        case (item_tag(_,_,_,_,_,_)) {\n-            ret;\n-        }\n+        case (item_ty(_, _, _, _, _, _)) { ret; }\n+        case (item_tag(_, _, _, _, _, _)) { ret; }\n         case (item_obj(?id, ?o, ?ps, _, ?di, ?a)) {\n             find_pre_post_obj(ccx, o);\n         }\n     }\n }\n \n+\n /* Finds the pre and postcondition for each expr in <args>;\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to \n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n     if (vec::len[@expr](args) > 0u) {\n-        log (\"find_pre_post_exprs: oper =\");\n-        log_expr(*(args.(0)));\n+        log \"find_pre_post_exprs: oper =\";\n+        log_expr(*args.(0));\n     }\n-\n     auto enclosing = fcx.enclosing;\n-    auto fm        = fcx.ccx.fm;\n-    auto nv        = num_constraints(enclosing);\n-\n-    fn do_one(fn_ctxt fcx, &@expr e) -> () {\n-        find_pre_post_expr(fcx, e);\n-    }\n+    auto fm = fcx.ccx.fm;\n+    auto nv = num_constraints(enclosing);\n+    fn do_one(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     auto f = bind do_one(fcx, _);\n-\n     vec::map[@expr, ()](f, args);\n-\n     fn get_pp(crate_ctxt ccx, &@expr e) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-\n     auto g = bind get_pp(fcx.ccx, _);\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n-\n     set_pre_and_post(fcx.ccx, a, seq_preconds(fcx, pps),\n-        union_postconds\n-          (nv, (vec::map[pre_and_post, postcond](h, pps))));\n+                     union_postconds(nv,\n+                                     vec::map[pre_and_post,\n+                                              postcond](h, pps)));\n }\n \n-fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index,\n-      &block body, &ann a) -> () {\n+fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n+                      &ann a) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    auto loop_precond = declare_var(fcx, rec(id=l.node.id,\n-                                             c=ninit(l.node.ident)),\n-      seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]));\n-    auto loop_postcond = intersect_postconds\n-        ([expr_postcond(fcx.ccx, index), block_postcond(fcx.ccx, body)]);\n+    auto loop_precond =\n+        declare_var(fcx, rec(id=l.node.id, c=ninit(l.node.ident)),\n+                    seq_preconds(fcx,\n+                                 [expr_pp(fcx.ccx, index),\n+                                  block_pp(fcx.ccx, body)]));\n+    auto loop_postcond =\n+        intersect_postconds([expr_postcond(fcx.ccx, index),\n+                             block_postcond(fcx.ccx, body)]);\n     set_pre_and_post(fcx.ccx, a, loop_precond, loop_postcond);\n }\n \n-fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n-                &ann larger_ann, &ann new_var, &path pth) -> () {\n-  alt (ann_to_def(fcx.ccx, new_var)) {\n-      case (some(?d)) {\n-          alt (d) {\n-              case (def_local(?d_id)) {\n-                  find_pre_post_expr(fcx, rhs);\n-                  auto p = expr_pp(fcx.ccx, rhs);\n-                  set_pre_and_post(fcx.ccx, larger_ann,\n-                                   p.precondition, p.postcondition);\n-                  gen(fcx, larger_ann, rec(id=d_id,\n-                        c=ninit(path_to_ident(fcx.ccx.tcx, pth))));\n-              }\n-              case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n-          }\n-      }\n-    case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n-  }\n+fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, &ann larger_ann,\n+                &ann new_var, &path pth) {\n+    alt (ann_to_def(fcx.ccx, new_var)) {\n+        case (some(?d)) {\n+            alt (d) {\n+                case (def_local(?d_id)) {\n+                    find_pre_post_expr(fcx, rhs);\n+                    auto p = expr_pp(fcx.ccx, rhs);\n+                    set_pre_and_post(fcx.ccx, larger_ann, p.precondition,\n+                                     p.postcondition);\n+                    gen(fcx, larger_ann,\n+                        rec(id=d_id,\n+                            c=ninit(path_to_ident(fcx.ccx.tcx, pth))));\n+                }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n+            }\n+        }\n+        case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n+    }\n }\n \n+\n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n-    auto enclosing      = fcx.enclosing;\n+fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n+    auto enclosing = fcx.enclosing;\n     auto num_local_vars = num_constraints(enclosing);\n-\n-    fn do_rand_(fn_ctxt fcx, &@expr e) -> () {\n-        find_pre_post_expr(fcx, e);\n-    }\n-    \n-    log(\"find_pre_post_expr (num_constraints =\" +\n-        uistr(num_local_vars) + \"):\");\n+    fn do_rand_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n+    log \"find_pre_post_expr (num_constraints =\" + uistr(num_local_vars) +\n+            \"):\";\n     log_expr(*e);\n-\n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n-          \n             /* should test higher-order constrained functions */\n+\n             /* FIXME */\n \n             /* see if the call has any constraints on its in type */\n-            log(\"a function: \" );\n+\n+            log \"a function: \";\n             log_expr(*operator);\n             auto pp = expr_pp(fcx.ccx, e);\n             for (@constr c in constraints_expr(fcx.ccx.tcx, operator)) {\n                 auto id = ann_to_def(fcx.ccx, c.node.ann);\n                 alt (id) {\n                     case (some(def_fn(?d_id))) {\n-                        auto i = bit_num(fcx, rec(id=d_id,\n-                                    c=substitute_constr_args(fcx.ccx.tcx,\n-                                                             operands, c)));\n+                        auto i =\n+                            bit_num(fcx,\n+                                    rec(id=d_id,\n+                                        c=substitute_constr_args(fcx.ccx.tcx,\n+                                                                 operands,\n+                                                                 c)));\n                         require(i, pp);\n                     }\n                     case (_) {\n-                        fcx.ccx.tcx.sess.span_err(c.span, \"Unbound pred \"\n-                          + \" or pred that's not bound to a function\");\n+                        fcx.ccx.tcx.sess.span_err(c.span,\n+                                                  \"Unbound pred \" +\n+                                                      \" or pred that's not \\\n+                                                        bound to a function\");\n                     }\n                 }\n             }\n-             \n+\n             // FIXME: constraints on result type\n-            \n+\n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n-                case (noreturn) {\n-                    set_postcond_false(fcx.ccx, a);\n-                }\n+                case (noreturn) { set_postcond_false(fcx.ccx, a); }\n                 case (_) { }\n             }\n         }\n@@ -268,72 +260,67 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         case (expr_path(?p, ?a)) {\n             auto res = expr_pp(fcx.ccx, e);\n             clear_pp(res);\n-\n             auto df = ann_to_def_strict(fcx.ccx.tcx, a);\n             alt (df) {\n                 case (def_local(?d_id)) {\n-                    auto i = bit_num(fcx, rec(id=d_id,\n-                                c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n+                    auto i =\n+                        bit_num(fcx,\n+                                rec(id=d_id,\n+                                    c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n                     require_and_preserve(i, res);\n                 }\n-                case (_) { /* nothing to check */ }\n+                case (_) {/* nothing to check */ }\n             }\n         }\n-        case (expr_self_method(?v, ?a)) {\n-            clear_pp(expr_pp(fcx.ccx, e));\n-        }\n-        case(expr_log(_, ?arg, ?a)) {\n+        case (expr_self_method(?v, ?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_log(_, ?arg, ?a)) {\n             find_pre_post_expr(fcx, arg);\n             copy_pre_post(fcx.ccx, a, arg);\n         }\n         case (expr_chan(?arg, ?a)) {\n             find_pre_post_expr(fcx, arg);\n             copy_pre_post(fcx.ccx, a, arg);\n         }\n-        case(expr_put(?opt, ?a)) {\n+        case (expr_put(?opt, ?a)) {\n             alt (opt) {\n                 case (some(?arg)) {\n                     find_pre_post_expr(fcx, arg);\n                     copy_pre_post(fcx.ccx, a, arg);\n                 }\n-                case (none) {\n-                    clear_pp(expr_pp(fcx.ccx, e));\n-                }\n+                case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n             }\n         }\n-        // FIXME this was just put in here as a placeholder\n-        case (expr_fn(?f, ?a)) {\n+        case (\n+             // FIXME this was just put in here as a placeholder\n+             expr_fn(?f, ?a)) {\n             clear_pp(expr_pp(fcx.ccx, e));\n         }\n         case (expr_block(?b, ?a)) {\n             find_pre_post_block(fcx, b);\n             auto p = block_pp(fcx.ccx, b);\n             set_pre_and_post(fcx.ccx, a, p.precondition, p.postcondition);\n         }\n-        case (expr_rec(?fields,?maybe_base,?a)) {\n+        case (expr_rec(?fields, ?maybe_base, ?a)) {\n             auto es = field_exprs(fields);\n             vec::plus_option[@expr](es, maybe_base);\n             find_pre_post_exprs(fcx, es, a);\n         }\n         case (expr_move(?lhs, ?rhs, ?a)) {\n+\n             // FIXME: this needs to deinitialize the rhs\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n                     gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n                 }\n-                case (_) {\n-                    find_pre_post_exprs(fcx, [lhs, rhs], a);\n-                }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], a); }\n             }\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n                     gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n                 }\n-                case (_) {\n-                    find_pre_post_exprs(fcx, [lhs, rhs], a);\n-                }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], a); }\n             }\n         }\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n@@ -344,18 +331,18 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                 case (_) {\n                     // doesn't check that lhs is an lval, but\n                     // that's probably ok\n+\n                     find_pre_post_exprs(fcx, [lhs, rhs], a);\n                 }\n             }\n         }\n         case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n+\n             find_pre_post_exprs(fcx, [lhs, rhs], a);\n         }\n-        case (expr_lit(_,?a)) {\n-            clear_pp(expr_pp(fcx.ccx, e));\n-        }\n+        case (expr_lit(_, ?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_ret(?maybe_val, ?a)) {\n             alt (maybe_val) {\n                 case (none) {\n@@ -372,58 +359,61 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         }\n         case (expr_be(?e, ?a)) {\n             find_pre_post_expr(fcx, e);\n-            set_pre_and_post(fcx.ccx, a,\n-               expr_prestate(fcx.ccx, e),\n-               false_postcond(num_local_vars));\n+            set_pre_and_post(fcx.ccx, a, expr_prestate(fcx.ccx, e),\n+                             false_postcond(num_local_vars));\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n             find_pre_post_expr(fcx, antec);\n             find_pre_post_block(fcx, conseq);\n             alt (maybe_alt) {\n                 case (none) {\n                     log \"333\";\n-                    auto precond_res = seq_preconds(fcx,\n-                                         [expr_pp(fcx.ccx, antec),\n-                                          block_pp(fcx.ccx, conseq)]);\n+                    auto precond_res =\n+                        seq_preconds(fcx,\n+                                     [expr_pp(fcx.ccx, antec),\n+                                      block_pp(fcx.ccx, conseq)]);\n                     set_pre_and_post(fcx.ccx, a, precond_res,\n                                      expr_poststate(fcx.ccx, antec));\n                 }\n                 case (some(?altern)) {\n                     find_pre_post_expr(fcx, altern);\n                     log \"444\";\n                     auto precond_true_case =\n-                        seq_preconds(fcx, [expr_pp(fcx.ccx, antec),\n-                                           block_pp(fcx.ccx, conseq)]);\n-                    auto postcond_true_case = union_postconds\n-                        (num_local_vars,\n-                         [expr_postcond(fcx.ccx, antec),\n-                          block_postcond(fcx.ccx, conseq)]);\n+                        seq_preconds(fcx,\n+                                     [expr_pp(fcx.ccx, antec),\n+                                      block_pp(fcx.ccx, conseq)]);\n+                    auto postcond_true_case =\n+                        union_postconds(num_local_vars,\n+                                        [expr_postcond(fcx.ccx, antec),\n+                                         block_postcond(fcx.ccx, conseq)]);\n                     log \"555\";\n-                    auto precond_false_case = seq_preconds\n-                        (fcx, [expr_pp(fcx.ccx, antec),\n-                               expr_pp(fcx.ccx, altern)]);\n-                    auto postcond_false_case = union_postconds\n-                        (num_local_vars,\n-                         [expr_postcond(fcx.ccx, antec),\n-                          expr_postcond(fcx.ccx, altern)]);\n-                    auto precond_res = union_postconds\n-                        (num_local_vars,\n-                         [precond_true_case, precond_false_case]);\n-                    auto postcond_res = intersect_postconds\n-                        ([postcond_true_case, postcond_false_case]);\n+                    auto precond_false_case =\n+                        seq_preconds(fcx,\n+                                     [expr_pp(fcx.ccx, antec),\n+                                      expr_pp(fcx.ccx, altern)]);\n+                    auto postcond_false_case =\n+                        union_postconds(num_local_vars,\n+                                        [expr_postcond(fcx.ccx, antec),\n+                                         expr_postcond(fcx.ccx, altern)]);\n+                    auto precond_res =\n+                        union_postconds(num_local_vars,\n+                                        [precond_true_case,\n+                                         precond_false_case]);\n+                    auto postcond_res =\n+                        intersect_postconds([postcond_true_case,\n+                                             postcond_false_case]);\n                     set_pre_and_post(fcx.ccx, a, precond_res, postcond_res);\n                 }\n             }\n         }\n-        case (expr_binary(?bop,?l,?r,?a)) {\n+        case (expr_binary(?bop, ?l, ?r, ?a)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n                FIXME */\n+\n             find_pre_post_exprs(fcx, [l, r], a);\n         }\n-        case (expr_send(?l, ?r, ?a)) {\n-            find_pre_post_exprs(fcx, [l, r], a);\n-        }\n-        case (expr_unary(_,?operand,?a)) {\n+        case (expr_send(?l, ?r, ?a)) { find_pre_post_exprs(fcx, [l, r], a); }\n+        case (expr_unary(_, ?operand, ?a)) {\n             find_pre_post_expr(fcx, operand);\n             copy_pre_post(fcx.ccx, a, operand);\n         }\n@@ -437,26 +427,28 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             log \"666\";\n             set_pre_and_post(fcx.ccx, a,\n                              seq_preconds(fcx,\n-                               [expr_pp(fcx.ccx, test), \n-                                   block_pp(fcx.ccx, body)]),\n-                    intersect_postconds([expr_postcond(fcx.ccx, test),\n-                                         block_postcond(fcx.ccx, body)]));\n+                                          [expr_pp(fcx.ccx, test),\n+                                           block_pp(fcx.ccx, body)]),\n+                             intersect_postconds([expr_postcond(fcx.ccx,\n+                                                                test),\n+                                                  block_postcond(fcx.ccx,\n+                                                                 body)]));\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n-   \n-            auto loop_postcond = union_postconds(num_local_vars,\n-                   [block_postcond(fcx.ccx, body),\n-                    expr_postcond(fcx.ccx, test)]);\n+            auto loop_postcond =\n+                union_postconds(num_local_vars,\n+                                [block_postcond(fcx.ccx, body),\n+                                 expr_postcond(fcx.ccx, test)]);\n             /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n+\n             if (has_nonlocal_exits(body)) {\n                 loop_postcond = empty_poststate(num_local_vars);\n             }\n-\n-\n-            set_pre_and_post(fcx.ccx, a, seq_preconds(fcx,\n+            set_pre_and_post(fcx.ccx, a,\n+                             seq_preconds(fcx,\n                                           [block_pp(fcx.ccx, body),\n                                            expr_pp(fcx.ccx, test)]),\n                              loop_postcond);\n@@ -485,14 +477,13 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n-            auto antec_pp = pp_clone(expr_pp(fcx.ccx, ex)); \n-            auto e_pp  = @rec(precondition=empty_prestate(num_local_vars),\n-                             postcondition=false_postcond(num_local_vars));\n+            auto antec_pp = pp_clone(expr_pp(fcx.ccx, ex));\n+            auto e_pp =\n+                @rec(precondition=empty_prestate(num_local_vars),\n+                     postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, fcx, _, _);\n-\n-            auto alts_overall_pp = vec::foldl[pre_and_post, pre_and_post]\n-                                    (g, e_pp, alt_pps);\n-\n+            auto alts_overall_pp =\n+                vec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n             set_pre_and_post(fcx.ccx, a, alts_overall_pp.precondition,\n                              alts_overall_pp.postcondition);\n         }\n@@ -504,8 +495,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             set_pre_and_post(fcx.ccx, a,\n                              /* if execution continues after fail,\n                                 then everything is true! */\n-               empty_prestate(num_local_vars),\n-               false_postcond(num_local_vars));\n+                             empty_prestate(num_local_vars),\n+                             false_postcond(num_local_vars));\n         }\n         case (expr_assert(?p, ?a)) {\n             find_pre_post_expr(fcx, p);\n@@ -514,26 +505,23 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         case (expr_check(?p, ?a)) {\n             /* FIXME: Can we bypass this by having a\n              node-id-to-constr_occ table? */\n+\n             find_pre_post_expr(fcx, p);\n             copy_pre_post(fcx.ccx, a, p);\n             /* predicate p holds after this expression executes */\n+\n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n             gen(fcx, a, c.node);\n         }\n-        case(expr_bind(?operator, ?maybe_args, ?a)) {\n+        case (expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = vec::cat_options[@expr](maybe_args);\n             vec::push[@expr](args, operator); /* ??? order of eval? */\n+\n             find_pre_post_exprs(fcx, args, a);\n         }\n-        case (expr_break(?a)) {\n-            clear_pp(expr_pp(fcx.ccx, e));\n-        }\n-        case (expr_cont(?a)) {\n-            clear_pp(expr_pp(fcx.ccx, e));\n-        }\n-        case (expr_port(?a)) {\n-            clear_pp(expr_pp(fcx.ccx, e));\n-        }\n+        case (expr_break(?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_cont(?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_port(?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_ext(_, _, _, ?expanded, ?a)) {\n             find_pre_post_expr(fcx, expanded);\n             copy_pre_post(fcx.ccx, a, expanded);\n@@ -544,58 +532,53 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                     find_pre_post_expr(fcx, ex);\n                     copy_pre_post(fcx.ccx, a, ex);\n                 }\n-                case (none) {\n-                    clear_pp(expr_pp(fcx.ccx, e));\n-                }\n+                case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n             }\n         }\n     }\n }\n \n-\n-fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n-    -> () {\n-    log(\"stmt =\");\n+fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n+    log \"stmt =\";\n     log_stmt(s);\n-\n-    auto enclosing      = fcx.enclosing;\n+    auto enclosing = fcx.enclosing;\n     auto num_local_vars = num_constraints(enclosing);\n-    alt(s.node) {\n-        case(stmt_decl(?adecl, ?a)) {\n-            alt(adecl.node) {\n-                case(decl_local(?alocal)) {\n-                    alt(alocal.init) {\n-                        case(some(?an_init)) {\n+    alt (s.node) {\n+        case (stmt_decl(?adecl, ?a)) {\n+            alt (adecl.node) {\n+                case (decl_local(?alocal)) {\n+                    alt (alocal.init) {\n+                        case (some(?an_init)) {\n                             find_pre_post_expr(fcx, an_init.expr);\n                             copy_pre_post(fcx.ccx, alocal.ann, an_init.expr);\n-\n                             /* Inherit ann from initializer, and add var being\n                                initialized to the postcondition */\n+\n                             copy_pre_post(fcx.ccx, a, an_init.expr);\n-                            gen(fcx, a, rec(id=alocal.id,\n-                                            c=ninit(alocal.ident)));\n+                            gen(fcx, a,\n+                                rec(id=alocal.id, c=ninit(alocal.ident)));\n                         }\n-                        case(none) {\n+                        case (none) {\n                             clear_pp(ann_to_ts_ann(fcx.ccx,\n                                                    alocal.ann).conditions);\n                             clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);\n                         }\n                     }\n                 }\n-                case(decl_item(?anitem)) {\n+                case (decl_item(?anitem)) {\n                     clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);\n                     find_pre_post_item(fcx.ccx, *anitem);\n                 }\n             }\n         }\n-        case(stmt_expr(?e,?a)) {\n+        case (stmt_expr(?e, ?a)) {\n             find_pre_post_expr(fcx, e);\n             copy_pre_post(fcx.ccx, a, e);\n-        }    \n+        }\n     }\n }\n \n-fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n+fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     /* Want to say that if there is a break or cont in this\n      block, then that invalidates the poststate upheld by\n     any of the stmts after it. \n@@ -609,57 +592,53 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n      This will mean that:\n      x = 0;\n      break;\n-\n+    \n      won't have a postcondition that says x is initialized, but that's ok.\n      */\n-    auto nv = num_constraints(fcx.enclosing);\n \n-    fn do_one_(fn_ctxt fcx, &@stmt s) -> () {\n+    auto nv = num_constraints(fcx.enclosing);\n+    fn do_one_(fn_ctxt fcx, &@stmt s) {\n         find_pre_post_stmt(fcx, *s);\n-        log(\"pre_post for stmt:\");\n+        log \"pre_post for stmt:\";\n         log_stmt(*s);\n-        log(\"is:\");\n+        log \"is:\";\n         log_pp(stmt_pp(fcx.ccx, *s));\n     }\n     auto do_one = bind do_one_(fcx, _);\n-    \n     vec::map[@stmt, ()](do_one, b.node.stmts);\n-    fn do_inner_(fn_ctxt fcx, &@expr e) -> () {\n-        find_pre_post_expr(fcx, e);\n-    }\n+    fn do_inner_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     auto do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n-\n     let vec[pre_and_post] pps = [];\n-\n     fn get_pp_stmt(crate_ctxt ccx, &@stmt s) -> pre_and_post {\n         ret stmt_pp(ccx, *s);\n     }\n-    auto f = bind get_pp_stmt(fcx.ccx,_);\n+    auto f = bind get_pp_stmt(fcx.ccx, _);\n     pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(crate_ctxt ccx, &@expr e) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n     auto g = bind get_pp_expr(fcx.ccx, _);\n     plus_option[pre_and_post](pps,\n-       option::map[@expr, pre_and_post](g, b.node.expr));\n-\n-    auto block_precond  = seq_preconds(fcx, pps);\n+                              option::map[@expr,\n+                                          pre_and_post](g, b.node.expr));\n+    auto block_precond = seq_preconds(fcx, pps);\n     auto h = get_post;\n-    auto postconds =  vec::map[pre_and_post, postcond](h, pps);\n+    auto postconds = vec::map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n+\n     vec::push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n-    if (! has_nonlocal_exits(b)) {\n+\n+    if (!has_nonlocal_exits(b)) {\n         block_postcond = union_postconds(nv, postconds);\n     }\n-\n     set_pre_and_post(fcx.ccx, b.node.a, block_precond, block_postcond);\n }\n \n-fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) -> () {\n+fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) {\n     find_pre_post_block(fcx, f.body);\n \n     // Treat the tail expression as a return statement\n@@ -668,18 +647,16 @@ fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) -> () {\n             auto tailann = expr_ann(tailexpr);\n             set_postcond_false(fcx.ccx, tailann);\n         }\n-        case (none) { /* fallthrough */ }\n+        case (none) {/* fallthrough */ }\n     }\n }\n \n fn fn_pre_post(crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n-               &ann a) -> () {\n+               &ann a) {\n     assert (ccx.fm.contains_key(id));\n-    auto fcx = rec(enclosing=ccx.fm.get(id),\n-                   id=id, name=i, ccx=ccx);\n-    find_pre_post_fn(fcx, f);  \n+    auto fcx = rec(enclosing=ccx.fm.get(id), id=id, name=i, ccx=ccx);\n+    find_pre_post_fn(fcx, f);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "ddcf448c471ed872cd6d98b13f0424299f654241", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 584, "deletions": 527, "changes": 1111, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::bitv;\n import std::vec;\n import std::vec::plus_option;\n@@ -8,7 +9,6 @@ import std::option::is_none;\n import std::option::none;\n import std::option::some;\n import std::option::maybe;\n-\n import tstate::ann::pre_and_post;\n import tstate::ann::get_post;\n import tstate::ann::postcond;\n@@ -52,23 +52,19 @@ import aux::expr_to_constr;\n import aux::ninit;\n import aux::npred;\n import aux::path_to_ident;\n-\n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n import bitvectors::intersect_postconds;\n import bitvectors::declare_var;\n import bitvectors::bit_num;\n import bitvectors::gen_poststate;\n import bitvectors::kill_poststate;\n-\n import front::ast;\n import front::ast::*;\n-\n import middle::ty::expr_ann;\n import middle::ty::expr_ty;\n import middle::ty::type_is_nil;\n import middle::ty::type_is_bot;\n-\n import util::common::new_def_hash;\n import util::common::decl_lhs;\n import util::common::uistr;\n@@ -81,21 +77,19 @@ import util::common::has_nonlocal_exits;\n import util::common::log_stmt;\n import util::common::log_expr_err;\n \n-fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs)\n-     -> tup(bool, poststate) {\n-  auto changed = false;\n-  auto post = pres;\n-\n-  for (@expr e in exprs) {\n-    changed = find_pre_post_state_expr(fcx, post, e) || changed;\n-    post = expr_poststate(fcx.ccx, e);\n-  }\n-\n-  ret tup(changed, post);\n+fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs) ->\n+   tup(bool, poststate) {\n+    auto changed = false;\n+    auto post = pres;\n+    for (@expr e in exprs) {\n+        changed = find_pre_post_state_expr(fcx, post, e) || changed;\n+        post = expr_poststate(fcx.ccx, e);\n+    }\n+    ret tup(changed, post);\n }\n \n-fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres,\n-                             &ann a, &vec[@expr] es) -> bool {\n+fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, &ann a,\n+                             &vec[@expr] es) -> bool {\n     auto res = seq_states(fcx, pres, es);\n     auto changed = res._0;\n     changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n@@ -104,535 +98,607 @@ fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres,\n }\n \n fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n-  &@expr index, &block body, &ann a) -> bool {\n+                            &@expr index, &block body, &ann a) -> bool {\n     auto changed = false;\n-\n     /* same issues as while */\n+\n     // FIXME: also want to set l as initialized, no?\n+\n     changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n     changed = find_pre_post_state_expr(fcx, pres, index) || changed;\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n-    changed = find_pre_post_state_block(fcx,\n-                expr_poststate(fcx.ccx, index), body) || changed;\n-    auto res_p = intersect_postconds([expr_poststate(fcx.ccx, index),\n-                                         block_poststate(fcx.ccx, body)]);\n-  \n+\n+    changed =\n+        find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, index), body)\n+            || changed;\n+    auto res_p =\n+        intersect_postconds([expr_poststate(fcx.ccx, index),\n+                             block_poststate(fcx.ccx, body)]);\n     changed = extend_poststate_ann(fcx.ccx, a, res_p) || changed;\n     ret changed;\n }\n \n fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a, &path p) -> bool {\n-  alt (ann_to_def(fcx.ccx, a_new_var)) {\n-      case (some(def_local(?loc))) {\n-          ret gen_poststate(fcx, a, rec(id=loc,\n-                c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n-      }\n-      case (_) { ret false; }\n-  }\n+    alt (ann_to_def(fcx.ccx, a_new_var)) {\n+        case (some(def_local(?loc))) {\n+            ret gen_poststate(fcx, a,\n+                              rec(id=loc,\n+                                  c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n+        }\n+        case (_) { ret false; }\n+    }\n }\n \n fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n-  auto changed = false;\n-  auto num_local_vars = num_constraints(fcx.enclosing);\n-\n-  /*  \n-  log_err(\"states:\");\n-  log_expr_err(*e);\n-  aux::log_bitv_err(fcx, expr_poststate(fcx.ccx, e));\n-  */\n-\n-  /* FIXME could get rid of some of the copy/paste */\n-  alt (e.node) {\n-    case (expr_vec(?elts, _, _, ?a)) {\n-        ret find_pre_post_state_exprs(fcx, pres, a, elts); \n-    }\n-    case (expr_tup(?elts, ?a)) {\n-      ret find_pre_post_state_exprs(fcx, pres, a, elt_exprs(elts));\n-    }\n-    case (expr_call(?operator, ?operands, ?a)) {\n-      /* do the prestate for the rator */\n-      changed = find_pre_post_state_expr(fcx, pres, operator)\n-        || changed;\n-      /* rands go left-to-right */\n-      changed = find_pre_post_state_exprs(fcx,\n-                  expr_poststate(fcx.ccx, operator), a, operands) || changed;\n-      /* if this is a failing call, it sets everything as initialized */\n-       alt (controlflow_expr(fcx.ccx, operator)) {\n-          case (noreturn) {\n-              changed = set_poststate_ann(fcx.ccx, a,\n-                                          false_postcond(num_local_vars))\n-                  || changed;\n-          }\n-          case (_) { }\n-      }\n-      ret changed;\n-    }\n-    case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-        changed = find_pre_post_state_expr(fcx, pres, operator);\n-        ret(find_pre_post_state_exprs(fcx,\n-                 expr_poststate(fcx.ccx, operator), a, operands)\n-          || changed);\n-    }\n-    case (expr_bind(?operator, ?maybe_args, ?a)) {\n-        changed = find_pre_post_state_expr(fcx, pres, operator)\n-            || changed;\n-        ret (find_pre_post_state_exprs(fcx,\n-          expr_poststate(fcx.ccx, operator), a,\n-             cat_options[@expr](maybe_args)) || changed);\n-    }\n-    case (expr_path(_,?a)) {\n-      ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_log(_,?e,?a)) {\n-        /* factor out the \"one exp\" pattern */\n-        changed = find_pre_post_state_expr(fcx, pres, e);\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, e)) || changed;\n-        ret changed;\n-    }\n-    case (expr_chan(?e, ?a)) {\n-        changed = find_pre_post_state_expr(fcx, pres, e);\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, e)) || changed;\n-        ret changed;\n-    }\n-    case (expr_ext(_, _, _, ?expanded, ?a)) {\n-        changed = find_pre_post_state_expr(fcx, pres, expanded);\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, expanded)) || changed;\n-        ret changed;\n-    }\n-    case (expr_put(?maybe_e, ?a)) {\n-        alt (maybe_e) {\n-            case (some(?arg)) {\n-                changed = find_pre_post_state_expr(fcx, pres, arg);\n-                changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, arg)) || changed;\n-                ret changed;\n-            }\n-            case (none) {\n-                ret pure_exp(fcx.ccx, a, pres);\n-            }\n+    auto changed = false;\n+    auto num_local_vars = num_constraints(fcx.enclosing);\n+\n+    /*  \n+    log_err(\"states:\");\n+    log_expr_err(*e);\n+    aux::log_bitv_err(fcx, expr_poststate(fcx.ccx, e));\n+    */\n+\n+    /* FIXME could get rid of some of the copy/paste */\n+    alt (e.node) {\n+        case (expr_vec(?elts, _, _, ?a)) {\n+            ret find_pre_post_state_exprs(fcx, pres, a, elts);\n         }\n-    }\n-    case (expr_lit(?l,?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    // FIXME This was just put in here as a placeholder\n-    case (expr_fn(?f,?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_block(?b,?a)) {\n-        changed = find_pre_post_state_block(fcx, pres, b)\n-           || changed;\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    block_poststate(fcx.ccx, b)) || changed;\n-        ret changed;\n-    }\n-    case (expr_rec(?fields,?maybe_base,?a)) {\n-        changed = find_pre_post_state_exprs(fcx, pres, a,\n-                                            field_exprs(fields)) || changed;\n-        alt (maybe_base) {\n-            case (none) { /* do nothing */ }\n-            case (some(?base)) {\n-                changed = find_pre_post_state_expr(fcx, pres, base)\n-                    || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, base)) || changed;\n+        case (expr_tup(?elts, ?a)) {\n+            ret find_pre_post_state_exprs(fcx, pres, a, elt_exprs(elts));\n+        }\n+        case (expr_call(?operator, ?operands, ?a)) {\n+            /* do the prestate for the rator */\n+\n+            changed =\n+                find_pre_post_state_expr(fcx, pres, operator) || changed;\n+            /* rands go left-to-right */\n+\n+            changed =\n+                find_pre_post_state_exprs(fcx,\n+                                          expr_poststate(fcx.ccx, operator),\n+                                          a, operands) || changed;\n+            /* if this is a failing call, it sets everything as initialized */\n+\n+            alt (controlflow_expr(fcx.ccx, operator)) {\n+                case (noreturn) {\n+                    changed =\n+                        set_poststate_ann(fcx.ccx, a,\n+                                          false_postcond(num_local_vars)) ||\n+                            changed;\n+                }\n+                case (_) { }\n             }\n+            ret changed;\n         }\n-        ret changed;\n-    }\n-    case (expr_move(?lhs, ?rhs, ?a)) {\n-        // FIXME: this needs to deinitialize the rhs\n-        extend_prestate_ann(fcx.ccx, a, pres);\n-\n-        alt (lhs.node) {\n-            case (expr_path(?p, ?a_lhs)) {\n-                // assignment to local var\n-                changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n-                changed = find_pre_post_state_expr(fcx, pres, rhs)\n+        case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+            changed = find_pre_post_state_expr(fcx, pres, operator);\n+            ret find_pre_post_state_exprs(fcx,\n+                                          expr_poststate(fcx.ccx, operator),\n+                                          a, operands) || changed;\n+        }\n+        case (expr_bind(?operator, ?maybe_args, ?a)) {\n+            changed =\n+                find_pre_post_state_expr(fcx, pres, operator) || changed;\n+            ret find_pre_post_state_exprs(fcx,\n+                                          expr_poststate(fcx.ccx, operator),\n+                                          a, cat_options[@expr](maybe_args))\n                     || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, rhs)) || changed;\n-                changed = gen_if_local(fcx, a_lhs, a, p)|| changed;\n-            }\n-            case (_) {\n-                // assignment to something that must already have been init'd\n-                changed = find_pre_post_state_expr(fcx, pres, lhs)\n+        }\n+        case (expr_path(_, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_log(_, ?e, ?a)) {\n+            /* factor out the \"one exp\" pattern */\n+\n+            changed = find_pre_post_state_expr(fcx, pres, e);\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, e))\n                     || changed;\n-                changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(fcx.ccx, lhs), rhs) || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, rhs)) || changed;\n-            }\n+            ret changed;\n         }\n-        ret changed;\n-    }\n-    case (expr_assign(?lhs, ?rhs, ?a)) {\n-        extend_prestate_ann(fcx.ccx, a, pres);\n-\n-        alt (lhs.node) {\n-            case (expr_path(?p, ?a_lhs)) {\n-                // assignment to local var\n-                changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n-                changed = find_pre_post_state_expr(fcx, pres, rhs)\n+        case (expr_chan(?e, ?a)) {\n+            changed = find_pre_post_state_expr(fcx, pres, e);\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, e))\n                     || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, rhs)) || changed;\n-                changed = gen_if_local(fcx, a_lhs, a, p)|| changed;\n+            ret changed;\n+        }\n+        case (expr_ext(_, _, _, ?expanded, ?a)) {\n+            changed = find_pre_post_state_expr(fcx, pres, expanded);\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a,\n+                                     expr_poststate(fcx.ccx, expanded)) ||\n+                    changed;\n+            ret changed;\n+        }\n+        case (expr_put(?maybe_e, ?a)) {\n+            alt (maybe_e) {\n+                case (some(?arg)) {\n+                    changed = find_pre_post_state_expr(fcx, pres, arg);\n+                    changed =\n+                        extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, arg)) ||\n+                            changed;\n+                    ret changed;\n+                }\n+                case (none) { ret pure_exp(fcx.ccx, a, pres); }\n             }\n-            case (_) {\n-                // assignment to something that must already have been init'd\n-                changed = find_pre_post_state_expr(fcx, pres, lhs)\n+        }\n+        case (expr_lit(?l, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (\n+             // FIXME This was just put in here as a placeholder\n+             expr_fn(?f, ?a)) {\n+            ret pure_exp(fcx.ccx, a, pres);\n+        }\n+        case (expr_block(?b, ?a)) {\n+            changed = find_pre_post_state_block(fcx, pres, b) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, block_poststate(fcx.ccx, b))\n                     || changed;\n-                changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(fcx.ccx, lhs), rhs) || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, rhs)) || changed;\n-            }\n+            ret changed;\n         }\n-        ret changed;\n-    }\n-    case (expr_recv(?lhs, ?rhs, ?a)) {\n-        extend_prestate_ann(fcx.ccx, a, pres);\n-\n-        alt (lhs.node) {\n-            case (expr_path(?p, ?a_lhs)) {\n-                // receive to local var\n-                changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n-                changed = find_pre_post_state_expr(fcx, pres, rhs)\n+        case (expr_rec(?fields, ?maybe_base, ?a)) {\n+            changed =\n+                find_pre_post_state_exprs(fcx, pres, a, field_exprs(fields))\n                     || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, rhs)) || changed;\n-                changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n+            alt (maybe_base) {\n+                case (none) {/* do nothing */ }\n+                case (some(?base)) {\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, base) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, base)) ||\n+                            changed;\n+                }\n             }\n-            case (_) {\n-                // receive to something that must already have been init'd\n-                changed = find_pre_post_state_expr(fcx, pres, lhs)\n-                    || changed;\n-                changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(fcx.ccx, lhs), rhs) || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, rhs)) || changed;\n+            ret changed;\n+        }\n+        case (expr_move(?lhs, ?rhs, ?a)) {\n+            // FIXME: this needs to deinitialize the rhs\n+\n+            extend_prestate_ann(fcx.ccx, a, pres);\n+            alt (lhs.node) {\n+                case (expr_path(?p, ?a_lhs)) {\n+                    // assignment to local var\n+\n+                    changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, rhs) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, rhs)) ||\n+                            changed;\n+                    changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n+                }\n+                case (_) {\n+                    // assignment to something that must already have been\n+                    // init'd\n+\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+                    changed =\n+                        find_pre_post_state_expr(fcx,\n+                                                 expr_poststate(fcx.ccx, lhs),\n+                                                 rhs) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, rhs)) ||\n+                            changed;\n+                }\n             }\n+            ret changed;\n         }\n-        ret changed;\n-    }\n-\n-    case (expr_ret(?maybe_ret_val, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        /* normally, everything is true if execution continues after\n-           a ret expression (since execution never continues locally\n-           after a ret expression */\n-        set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n-        /* return from an always-failing function clears the return bit */\n-        alt (fcx.enclosing.cf) {\n-            case (noreturn) {\n-                kill_poststate(fcx, a, rec(id=fcx.id, c=ninit(fcx.name)));\n+        case (expr_assign(?lhs, ?rhs, ?a)) {\n+            extend_prestate_ann(fcx.ccx, a, pres);\n+            alt (lhs.node) {\n+                case (expr_path(?p, ?a_lhs)) {\n+                    // assignment to local var\n+\n+                    changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, rhs) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, rhs)) ||\n+                            changed;\n+                    changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n+                }\n+                case (_) {\n+                    // assignment to something that must already have been\n+                    // init'd\n+\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+                    changed =\n+                        find_pre_post_state_expr(fcx,\n+                                                 expr_poststate(fcx.ccx, lhs),\n+                                                 rhs) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, rhs)) ||\n+                            changed;\n+                }\n             }\n-            case (_) {}\n+            ret changed;\n         }\n-        alt(maybe_ret_val) {\n-            case (none) { /* do nothing */ }\n-            case (some(?ret_val)) {\n-                changed = find_pre_post_state_expr(fcx,\n-                             pres, ret_val) || changed;\n+        case (expr_recv(?lhs, ?rhs, ?a)) {\n+            extend_prestate_ann(fcx.ccx, a, pres);\n+            alt (lhs.node) {\n+                case (expr_path(?p, ?a_lhs)) {\n+                    // receive to local var\n+\n+                    changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, rhs) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, rhs)) ||\n+                            changed;\n+                    changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n+                }\n+                case (_) {\n+                    // receive to something that must already have been init'd\n+\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+                    changed =\n+                        find_pre_post_state_expr(fcx,\n+                                                 expr_poststate(fcx.ccx, lhs),\n+                                                 rhs) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, rhs)) ||\n+                            changed;\n+                }\n             }\n+            ret changed;\n         }\n-        ret changed;\n-    }\n-    case (expr_be(?e, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n-        changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-        ret changed;\n-    }\n-    case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = find_pre_post_state_expr(fcx, pres, antec)\n-            || changed;\n-        changed = find_pre_post_state_block(fcx,\n-          expr_poststate(fcx.ccx, antec), conseq) || changed;\n-        alt (maybe_alt) {\n-            case (none) {\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, antec)) || changed;\n+        case (expr_ret(?maybe_ret_val, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            /* normally, everything is true if execution continues after\n+               a ret expression (since execution never continues locally\n+               after a ret expression */\n+\n+            set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n+            /* return from an always-failing function clears the return bit */\n+\n+            alt (fcx.enclosing.cf) {\n+                case (noreturn) {\n+                    kill_poststate(fcx, a, rec(id=fcx.id, c=ninit(fcx.name)));\n+                }\n+                case (_) { }\n+            }\n+            alt (maybe_ret_val) {\n+                case (none) {/* do nothing */ }\n+                case (some(?ret_val)) {\n+                    changed =\n+                        find_pre_post_state_expr(fcx, pres, ret_val) ||\n+                            changed;\n+                }\n             }\n-            case (some(?altern)) {\n-                changed = find_pre_post_state_expr(fcx,\n-                   expr_poststate(fcx.ccx, antec), altern) || changed;\n-                auto poststate_res = intersect_postconds\n-                    ([block_poststate(fcx.ccx, conseq),\n-                      expr_poststate(fcx.ccx, altern)]);\n-                changed = extend_poststate_ann(fcx.ccx, a, poststate_res)\n+            ret changed;\n+        }\n+        case (expr_be(?e, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n+            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+            ret changed;\n+        }\n+        case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, antec) || changed;\n+            changed =\n+                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n+                                          conseq) || changed;\n+            alt (maybe_alt) {\n+                case (none) {\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, antec))\n                             || changed;\n+                }\n+                case (some(?altern)) {\n+                    changed =\n+                        find_pre_post_state_expr(fcx,\n+                                                 expr_poststate(fcx.ccx,\n+                                                                antec),\n+                                                 altern) || changed;\n+                    auto poststate_res =\n+                        intersect_postconds([block_poststate(fcx.ccx, conseq),\n+                                             expr_poststate(fcx.ccx,\n+                                                            altern)]);\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a, poststate_res) ||\n+                            changed;\n+                }\n             }\n+            log \"if:\";\n+            log_expr(*e);\n+            log \"new prestate:\";\n+            log_bitv(fcx, pres);\n+            log \"new poststate:\";\n+            log_bitv(fcx, expr_poststate(fcx.ccx, e));\n+            ret changed;\n         }\n-        log(\"if:\");\n-        log_expr(*e);\n-        log(\"new prestate:\");\n-        log_bitv(fcx, pres);\n-        log(\"new poststate:\");\n-        log_bitv(fcx, expr_poststate(fcx.ccx, e));\n+        case (expr_binary(?bop, ?l, ?r, ?a)) {\n+            /* FIXME: what if bop is lazy? */\n \n-        ret changed;\n-    }\n-    case (expr_binary(?bop, ?l, ?r, ?a)) {\n-        /* FIXME: what if bop is lazy? */\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = find_pre_post_state_expr(fcx, pres, l)\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n+            changed =\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n                     || changed;\n-        changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, r))\n                     || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, r)) || changed;\n-        ret changed;\n-    }\n-    case (expr_send(?l, ?r, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = find_pre_post_state_expr(fcx, pres, l)\n+            ret changed;\n+        }\n+        case (expr_send(?l, ?r, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n+            changed =\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n                     || changed;\n-        changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, r))\n                     || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, r)) || changed;\n-        ret changed;\n-    }\n-    case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n-        /* quite similar to binary -- should abstract this */\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = find_pre_post_state_expr(fcx, pres, lhs)\n+            ret changed;\n+        }\n+        case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n+            /* quite similar to binary -- should abstract this */\n+\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+            changed =\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n+                                         rhs) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, rhs))\n                     || changed;\n-        changed = find_pre_post_state_expr(fcx,\n-                    expr_poststate(fcx.ccx, lhs), rhs) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, rhs)) || changed;\n-        ret changed;\n-    }\n-    case (expr_while(?test, ?body, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        /* to handle general predicates, we need to pass in\n-            pres `intersect` (poststate(a)) \n-         like: auto test_pres = intersect_postconds(pres, expr_postcond(a));\n-         However, this doesn't work right now because we would be passing\n-         in an all-zero prestate initially\n-           FIXME\n-           maybe need a \"don't know\" state in addition to 0 or 1?\n-        */\n-        changed = find_pre_post_state_expr(fcx, pres, test)\n-            || changed;\n-        changed = find_pre_post_state_block(fcx,\n-                    expr_poststate(fcx.ccx, test), body) || changed; \n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    intersect_postconds([expr_poststate(fcx.ccx, test),\n-                      block_poststate(fcx.ccx, body)])) || changed;\n-        ret changed;\n-    }\n-    case (expr_do_while(?body, ?test, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = find_pre_post_state_block(fcx, pres, body)\n-            || changed;\n-        changed = find_pre_post_state_expr(fcx,\n-                     block_poststate(fcx.ccx, body), test) || changed;\n+            ret changed;\n+        }\n+        case (expr_while(?test, ?body, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            /* to handle general predicates, we need to pass in\n+                pres `intersect` (poststate(a)) \n+             like: auto test_pres = intersect_postconds(pres,\n+             expr_postcond(a)); However, this doesn't work right now because\n+             we would be passing in an all-zero prestate initially\n+               FIXME\n+               maybe need a \"don't know\" state in addition to 0 or 1?\n+            */\n \n-        /* conservative approximination: if the body of the loop\n-           could break or cont, we revert to the prestate\n-           (TODO: could treat cont differently from break, since\n-           if there's a cont, the test will execute) */\n-        if (has_nonlocal_exits(body)) {\n-            changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, test) || changed;\n+            changed =\n+                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n+                                          body) || changed;\n+            changed =\n+                {\n+                    auto e_post = expr_poststate(fcx.ccx, test);\n+                    auto b_post = block_poststate(fcx.ccx, body);\n+                    extend_poststate_ann(fcx.ccx, a,\n+                                         intersect_postconds([e_post,\n+                                                              b_post]))\n+                    || changed\n+                };\n+            ret changed;\n         }\n-        else {\n-            changed = extend_poststate_ann(fcx.ccx, a,\n-                        expr_poststate(fcx.ccx, test)) || changed;\n+        case (expr_do_while(?body, ?test, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_block(fcx, pres, body) || changed;\n+            changed =\n+                find_pre_post_state_expr(fcx, block_poststate(fcx.ccx, body),\n+                                         test) || changed;\n+            /* conservative approximination: if the body of the loop\n+               could break or cont, we revert to the prestate\n+               (TODO: could treat cont differently from break, since\n+               if there's a cont, the test will execute) */\n+\n+            if (has_nonlocal_exits(body)) {\n+                changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n+            } else {\n+                changed =\n+                    extend_poststate_ann(fcx.ccx, a,\n+                                         expr_poststate(fcx.ccx, test)) ||\n+                        changed;\n+            }\n+            ret changed;\n+        }\n+        case (expr_for(?d, ?index, ?body, ?a)) {\n+            ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n+        }\n+        case (expr_for_each(?d, ?index, ?body, ?a)) {\n+            ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n+        }\n+        case (expr_index(?e, ?sub, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+            changed =\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, e), sub)\n+                    || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a,\n+                                     expr_poststate(fcx.ccx, sub));\n+            ret changed;\n         }\n+        case (expr_alt(?e, ?alts, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+            auto e_post = expr_poststate(fcx.ccx, e);\n+            auto a_post;\n+            if (vec::len[arm](alts) > 0u) {\n+                a_post = false_postcond(num_local_vars);\n+                for (arm an_alt in alts) {\n+                    changed =\n+                        find_pre_post_state_block(fcx, e_post, an_alt.block)\n+                            || changed;\n+                    intersect(a_post, block_poststate(fcx.ccx, an_alt.block));\n+                    // We deliberately do *not* update changed here, because\n+                    // we'd go into an infinite loop that way, and the change\n+                    // gets made after the if expression.\n \n-        ret changed;\n-    }\n-    case (expr_for(?d, ?index, ?body, ?a)) {\n-        ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n-    }\n-    case (expr_for_each(?d, ?index, ?body, ?a)) {\n-        ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n-    }\n-    case (expr_index(?e, ?sub, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed; \n-        changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-        changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(fcx.ccx, e), sub) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                                       expr_poststate(fcx.ccx, sub));\n-        ret changed;\n-    }\n-    case (expr_alt(?e, ?alts, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed; \n-        changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-        auto e_post = expr_poststate(fcx.ccx, e);\n-        auto a_post;\n-        if (vec::len[arm](alts) > 0u) {\n-            a_post = false_postcond(num_local_vars);\n-            for (arm an_alt in alts) {\n-                changed = find_pre_post_state_block(fcx, e_post,\n-                                                    an_alt.block) || changed;\n-                intersect(a_post, block_poststate(fcx.ccx, an_alt.block));\n-                // We deliberately do *not* update changed here, because we'd\n-                // go into an infinite loop that way, and the change gets made\n-                // after the if expression.\n+                }\n+            } else {\n+                // No alts; poststate is the poststate of the test\n+\n+                a_post = e_post;\n             }\n+            changed = extend_poststate_ann(fcx.ccx, a, a_post) || changed;\n+            ret changed;\n         }\n-        else {\n-            // No alts; poststate is the poststate of the test\n-            a_post = e_post;\n+        case (expr_field(?e, _, ?a)) {\n+            changed = find_pre_post_state_expr(fcx, pres, e);\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, e))\n+                    || changed;\n+            ret changed;\n         }\n-        changed = extend_poststate_ann(fcx.ccx, a, a_post) || changed;\n-        ret changed;\n-    }\n-    case (expr_field(?e, _, ?a)) {\n-        changed = find_pre_post_state_expr(fcx, pres, e);\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, e)) || changed;\n-        ret changed;\n-    }\n-    case (expr_unary(_,?operand,?a)) {\n-        changed = find_pre_post_state_expr(fcx, pres, operand)\n-          || changed;\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, operand)) || changed;\n-        ret changed;\n-    }\n-    case (expr_cast(?operand, _, ?a)) {\n-           changed = find_pre_post_state_expr(fcx, pres, operand)\n-          || changed;\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a,\n-                    expr_poststate(fcx.ccx, operand)) || changed;\n-        ret changed;\n-    }\n-    case (expr_fail(?a, _)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        /* if execution continues after fail, then everything is true! woo! */\n-        changed = set_poststate_ann(fcx.ccx, a,\n-                    false_postcond(num_local_vars)) || changed;\n-        ret changed;\n-    }\n-    case (expr_assert(?p, ?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_check(?p, ?a)) {\n-        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-        changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-        changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n-        /* predicate p holds after this expression executes */\n-        let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-        changed = gen_poststate(fcx, a, c.node) || changed;\n-        ret changed;\n-    }\n-    case (expr_break(?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_cont(?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_port(?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_self_method(_, ?a)) {\n-        ret pure_exp(fcx.ccx, a, pres);\n-    }\n-    case (expr_anon_obj(?anon_obj, _, _,?a)) {\n-        alt (anon_obj.with_obj) {\n-            case (some(?e)) {\n-                changed = find_pre_post_state_expr(fcx, pres, e);\n-                changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-                changed = extend_poststate_ann(fcx.ccx, a,\n-                            expr_poststate(fcx.ccx, e)) || changed;\n-                ret changed;\n-            }\n-            case (none) {\n-                ret pure_exp(fcx.ccx, a, pres);\n+        case (expr_unary(_, ?operand, ?a)) {\n+            changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a,\n+                                     expr_poststate(fcx.ccx, operand)) ||\n+                    changed;\n+            ret changed;\n+        }\n+        case (expr_cast(?operand, _, ?a)) {\n+            changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a,\n+                                     expr_poststate(fcx.ccx, operand)) ||\n+                    changed;\n+            ret changed;\n+        }\n+        case (expr_fail(?a, _)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            /* if execution continues after fail, then everything is true!\n+               woo! */\n+\n+            changed =\n+                set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars))\n+                    || changed;\n+            ret changed;\n+        }\n+        case (expr_assert(?p, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_check(?p, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n+            /* predicate p holds after this expression executes */\n+\n+            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+            changed = gen_poststate(fcx, a, c.node) || changed;\n+            ret changed;\n+        }\n+        case (expr_break(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_cont(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_port(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_self_method(_, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_anon_obj(?anon_obj, _, _, ?a)) {\n+            alt (anon_obj.with_obj) {\n+                case (some(?e)) {\n+                    changed = find_pre_post_state_expr(fcx, pres, e);\n+                    changed =\n+                        extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+                    changed =\n+                        extend_poststate_ann(fcx.ccx, a,\n+                                             expr_poststate(fcx.ccx, e)) ||\n+                            changed;\n+                    ret changed;\n+                }\n+                case (none) { ret pure_exp(fcx.ccx, a, pres); }\n             }\n         }\n     }\n-  }\n }\n \n fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n     auto changed = false;\n     auto stmt_ann = stmt_to_ann(fcx.ccx, *s);\n- \n-    log(\"*At beginning: stmt = \");\n+    log \"*At beginning: stmt = \";\n     log_stmt(*s);\n-    log(\"*prestate = \");\n-    log(bitv::to_str(stmt_ann.states.prestate));\n-    log(\"*poststate =\");\n-    log(bitv::to_str(stmt_ann.states.poststate));\n-    log(\"*changed =\");\n-    log(changed);\n-  \n+    log \"*prestate = \";\n+    log bitv::to_str(stmt_ann.states.prestate);\n+    log \"*poststate =\";\n+    log bitv::to_str(stmt_ann.states.poststate);\n+    log \"*changed =\";\n+    log changed;\n     alt (s.node) {\n         case (stmt_decl(?adecl, ?a)) {\n             alt (adecl.node) {\n                 case (decl_local(?alocal)) {\n                     alt (alocal.init) {\n                         case (some(?an_init)) {\n-                            changed = extend_prestate\n-                                (stmt_ann.states.prestate, pres) || changed;\n-                            changed = find_pre_post_state_expr\n-                                (fcx, pres, an_init.expr) || changed;\n-                            changed = extend_poststate\n-                                (stmt_ann.states.poststate,\n-                                 expr_poststate(fcx.ccx, an_init.expr))\n-                                || changed;\n-                            changed = gen_poststate(fcx, a,\n-                              rec(id=alocal.id, c=ninit(alocal.ident)))\n-                                || changed;\n-                            log(\"Summary: stmt = \");\n+                            changed =\n+                                extend_prestate(stmt_ann.states.prestate,\n+                                                pres) || changed;\n+                            changed =\n+                                find_pre_post_state_expr(fcx, pres,\n+                                                         an_init.expr) ||\n+                                    changed;\n+                            changed =\n+                                extend_poststate(stmt_ann.states.poststate,\n+                                                 expr_poststate(fcx.ccx,\n+                                                                an_init.expr))\n+                                    || changed;\n+                            changed =\n+                                gen_poststate(fcx, a,\n+                                              rec(id=alocal.id,\n+                                                  c=ninit(alocal.ident))) ||\n+                                    changed;\n+                            log \"Summary: stmt = \";\n                             log_stmt(*s);\n-                            log(\"prestate = \");\n-                            log(bitv::to_str(stmt_ann.states.prestate));\n+                            log \"prestate = \";\n+                            log bitv::to_str(stmt_ann.states.prestate);\n                             log_bitv(fcx, stmt_ann.states.prestate);\n-                            log(\"poststate =\");\n+                            log \"poststate =\";\n                             log_bitv(fcx, stmt_ann.states.poststate);\n-                            log(\"changed =\");\n-                            log(changed);\n-  \n+                            log \"changed =\";\n+                            log changed;\n                             ret changed;\n                         }\n                         case (none) {\n-                            changed = extend_prestate\n-                                (stmt_ann.states.prestate, pres) || changed;\n-                            changed = extend_poststate\n-                                (stmt_ann.states.poststate, pres) || changed;\n+                            changed =\n+                                extend_prestate(stmt_ann.states.prestate,\n+                                                pres) || changed;\n+                            changed =\n+                                extend_poststate(stmt_ann.states.poststate,\n+                                                 pres) || changed;\n                             ret changed;\n                         }\n                     }\n                 }\n                 case (decl_item(?an_item)) {\n-                    changed = extend_prestate(stmt_ann.states.prestate, pres)\n-                        || changed;\n-                    changed = extend_poststate(stmt_ann.states.poststate,\n-                                pres) || changed;\n+                    changed =\n+                        extend_prestate(stmt_ann.states.prestate, pres) ||\n+                            changed;\n+                    changed =\n+                        extend_poststate(stmt_ann.states.poststate, pres) ||\n+                            changed;\n                     /* the outer \"walk\" will recurse into the item */\n+\n                     ret changed;\n-                 }\n+                }\n             }\n         }\n         case (stmt_expr(?e, _)) {\n             changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-            changed = extend_prestate(stmt_ann.states.prestate,\n-                                      expr_prestate(fcx.ccx, e))\n-                || changed;\n-            changed = extend_poststate(stmt_ann.states.poststate,\n-                                       expr_poststate(fcx.ccx, e)) || changed;\n+            changed =\n+                extend_prestate(stmt_ann.states.prestate,\n+                                expr_prestate(fcx.ccx, e)) || changed;\n+            changed =\n+                extend_poststate(stmt_ann.states.poststate,\n+                                 expr_poststate(fcx.ccx, e)) || changed;\n             /*\n               log(\"Summary: stmt = \");\n               log_stmt(*s);\n@@ -645,75 +711,70 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n               log(\"changed =\");\n               log(changed);\n             */\n+\n             ret changed;\n         }\n         case (_) { ret false; }\n     }\n }\n \n+\n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n-  -> bool {\n-    \n-  auto changed = false;\n-  auto num_local_vars = num_constraints(fcx.enclosing);\n-\n-  /* First, set the pre-states and post-states for every expression */\n-  auto pres = pres0;\n-  \n-  /* Iterate over each stmt. The new prestate is <pres>. The poststate\n-   consist of improving <pres> with whatever variables this stmt initializes.\n-  Then <pres> becomes the new poststate. */ \n-  for (@stmt s in b.node.stmts) {\n-    changed = find_pre_post_state_stmt(fcx, pres, s) || changed;\n-    pres = stmt_poststate(fcx.ccx, *s);\n-  }\n-\n-  auto post = pres;\n-\n-  alt (b.node.expr) {\n-    case (none) {}\n-    case (some(?e)) {\n-      changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-      post = expr_poststate(fcx.ccx, e);\n+fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b) ->\n+   bool {\n+    auto changed = false;\n+    auto num_local_vars = num_constraints(fcx.enclosing);\n+    /* First, set the pre-states and post-states for every expression */\n+\n+    auto pres = pres0;\n+    /* Iterate over each stmt. The new prestate is <pres>. The poststate\n+     consist of improving <pres> with whatever variables this stmt\n+     initializes.  Then <pres> becomes the new poststate. */\n+\n+    for (@stmt s in b.node.stmts) {\n+        changed = find_pre_post_state_stmt(fcx, pres, s) || changed;\n+        pres = stmt_poststate(fcx.ccx, *s);\n     }\n-  }\n-\n-  /*\n-  log_err(\"block:\");\n-  log_block_err(b);\n-  log_err(\"has non-local exits?\");\n-  log_err(has_nonlocal_exits(b));\n-  */\n-\n-  /* conservative approximation: if a block contains a break\n-     or cont, we assume nothing about the poststate */\n-  if (has_nonlocal_exits(b)) {\n-      post = pres0;\n-  }\n-  \n-  set_prestate_ann(fcx.ccx, b.node.a, pres0);\n-  set_poststate_ann(fcx.ccx, b.node.a, post);\n-\n-  log(\"For block:\");\n-  log_block(b);\n-  log(\"poststate = \");\n-  log_states(block_states(fcx.ccx, b));\n-  log(\"pres0:\");\n-  log_bitv(fcx, pres0);\n-  log(\"post:\");\n-  log_bitv(fcx, post);\n-\n-  ret changed;\n+    auto post = pres;\n+    alt (b.node.expr) {\n+        case (none) { }\n+        case (some(?e)) {\n+            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+            post = expr_poststate(fcx.ccx, e);\n+        }\n+    }\n+    /*\n+    log_err(\"block:\");\n+    log_block_err(b);\n+    log_err(\"has non-local exits?\");\n+    log_err(has_nonlocal_exits(b));\n+    */\n+\n+    /* conservative approximation: if a block contains a break\n+       or cont, we assume nothing about the poststate */\n+\n+    if (has_nonlocal_exits(b)) { post = pres0; }\n+    set_prestate_ann(fcx.ccx, b.node.a, pres0);\n+    set_poststate_ann(fcx.ccx, b.node.a, post);\n+    log \"For block:\";\n+    log_block(b);\n+    log \"poststate = \";\n+    log_states(block_states(fcx.ccx, b));\n+    log \"pres0:\";\n+    log_bitv(fcx, pres0);\n+    log \"post:\";\n+    log_bitv(fcx, post);\n+    ret changed;\n }\n \n fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n     auto num_local_vars = num_constraints(fcx.enclosing);\n-    auto changed = find_pre_post_state_block(fcx,\n-                     empty_prestate(num_local_vars), f.body);\n-\n+    auto changed =\n+        find_pre_post_state_block(fcx, empty_prestate(num_local_vars),\n+                                  f.body);\n     // Treat the tail expression as a return statement\n+\n     alt (f.body.node.expr) {\n         case (some(?tailexpr)) {\n             auto tailann = expr_ann(tailexpr);\n@@ -723,9 +784,8 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n             // implicitly result in nil, we have to be careful to not\n             // interpret nil-typed block results as the result of a\n             // function with some other return type\n-            if (!type_is_nil(fcx.ccx.tcx, tailty)\n-                && !type_is_bot(fcx.ccx.tcx, tailty)) {\n-\n+            if (!type_is_nil(fcx.ccx.tcx, tailty) &&\n+                    !type_is_bot(fcx.ccx.tcx, tailty)) {\n                 set_poststate_ann(fcx.ccx, tailann,\n                                   false_postcond(num_local_vars));\n                 alt (fcx.enclosing.cf) {\n@@ -737,12 +797,10 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n                 }\n             }\n         }\n-        case (none) { /* fallthrough */ }\n+        case (none) {/* fallthrough */ }\n     }\n-\n     ret changed;\n }\n-\n //\n // Local Variables:\n // mode: rust\n@@ -753,4 +811,3 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //\n-"}, {"sha": "027c8b333ae0da74449c4f4d496e316d848e6167", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 696, "deletions": 980, "changes": 1676, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d86aa74c1bd4fb4b8d74bd51fb3791647a7bc1f8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 556, "deletions": 768, "changes": 1324, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "46acc83345960eda6754a4954da8019fc228eda1", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 77, "deletions": 135, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,10 +1,12 @@\n+\n import front::ast::*;\n import std::option;\n import std::option::some;\n import std::option::none;\n import util::common::span;\n import util::common::respan;\n \n+\n // Context-passing AST walker. Each overridden visit method has full control\n // over what happens with its node, it can do its own traversal of the node's\n // children (potentially passing in different contexts to each), call\n@@ -15,42 +17,41 @@ import util::common::respan;\n // circular types, so the visitor record can not hold functions that take\n // visitors. A vt tag is used to break the cycle.\n tag vt[E] { vtor(visitor[E]); }\n-fn vt[E](&vt[E] x) -> visitor[E] {\n-    alt (x) { case (vtor(?v)) { ret v; } }\n-}\n+\n+fn vt[E](&vt[E] x) -> visitor[E] { alt (x) { case (vtor(?v)) { ret v; } } }\n \n type visitor[E] =\n-    @rec(fn(&_mod m, &span sp, &E e, &vt[E] v) visit_mod,\n-         fn(&@view_item v, &E e, &vt[E] v)     visit_view_item,\n-         fn(&@native_item i, &E e, &vt[E] v)   visit_native_item,\n-         fn(&@item i, &E e, &vt[E] v)          visit_item,\n-         fn(&@local l, &E e, &vt[E] v)         visit_local,\n-         fn(&block b, &E e, &vt[E] v)          visit_block,\n-         fn(&@stmt s, &E e, &vt[E] v)          visit_stmt,\n-         fn(&arm a, &E e, &vt[E] v)            visit_arm,\n-         fn(&@pat p, &E e, &vt[E] v)           visit_pat,\n-         fn(&@decl d, &E e, &vt[E] v)          visit_decl,\n-         fn(&@expr ex, &E e, &vt[E] v)         visit_expr,\n-         fn(&@ty t, &E e, &vt[E] v)            visit_ty,\n-         fn(&@constr c, &E e, &vt[E] v)        visit_constr,\n-         fn(&_fn f, &vec[ty_param] tp, &span sp, &ident name, &def_id d_id,\n-            &ann a, &E e, &vt[E] v)            visit_fn);\n+    @rec(fn(&_mod, &span, &E, &vt[E])  visit_mod,\n+         fn(&@view_item, &E, &vt[E])  visit_view_item,\n+         fn(&@native_item, &E, &vt[E])  visit_native_item,\n+         fn(&@item, &E, &vt[E])  visit_item,\n+         fn(&@local, &E, &vt[E])  visit_local,\n+         fn(&block, &E, &vt[E])  visit_block,\n+         fn(&@stmt, &E, &vt[E])  visit_stmt,\n+         fn(&arm, &E, &vt[E])  visit_arm,\n+         fn(&@pat, &E, &vt[E])  visit_pat,\n+         fn(&@decl, &E, &vt[E])  visit_decl,\n+         fn(&@expr, &E, &vt[E])  visit_expr,\n+         fn(&@ty, &E, &vt[E])  visit_ty,\n+         fn(&@constr, &E, &vt[E])  visit_constr,\n+         fn(&_fn, &vec[ty_param], &span, &ident, &def_id, &ann, &E, &vt[E])\n+             visit_fn);\n \n fn default_visitor[E]() -> visitor[E] {\n-    ret @rec(visit_mod = bind visit_mod[E](_, _, _, _),\n-             visit_view_item = bind visit_view_item[E](_, _, _),\n-             visit_native_item = bind visit_native_item[E](_, _, _),\n-             visit_item = bind visit_item[E](_, _, _),\n-             visit_local = bind visit_local[E](_, _, _),\n-             visit_block = bind visit_block[E](_, _, _),\n-             visit_stmt = bind visit_stmt[E](_, _, _),\n-             visit_arm = bind visit_arm[E](_, _, _),\n-             visit_pat = bind visit_pat[E](_, _, _),\n-             visit_decl = bind visit_decl[E](_, _, _),\n-             visit_expr = bind visit_expr[E](_, _, _),\n-             visit_ty = bind visit_ty[E](_, _, _),\n-             visit_constr = bind visit_constr[E](_, _, _),\n-             visit_fn = bind visit_fn[E](_, _, _, _, _, _, _, _));\n+    ret @rec(visit_mod=bind visit_mod[E](_, _, _, _),\n+             visit_view_item=bind visit_view_item[E](_, _, _),\n+             visit_native_item=bind visit_native_item[E](_, _, _),\n+             visit_item=bind visit_item[E](_, _, _),\n+             visit_local=bind visit_local[E](_, _, _),\n+             visit_block=bind visit_block[E](_, _, _),\n+             visit_stmt=bind visit_stmt[E](_, _, _),\n+             visit_arm=bind visit_arm[E](_, _, _),\n+             visit_pat=bind visit_pat[E](_, _, _),\n+             visit_decl=bind visit_decl[E](_, _, _),\n+             visit_expr=bind visit_expr[E](_, _, _),\n+             visit_ty=bind visit_ty[E](_, _, _),\n+             visit_constr=bind visit_constr[E](_, _, _),\n+             visit_fn=bind visit_fn[E](_, _, _, _, _, _, _, _));\n }\n \n fn visit_crate[E](&crate c, &E e, &vt[E] v) {\n@@ -65,39 +66,33 @@ fn visit_crate_directive[E](&@crate_directive cd, &E e, &vt[E] v) {\n                 visit_crate_directive(cdir, e, v);\n             }\n         }\n-        case (cdir_src_mod(_, _)) {}\n+        case (cdir_src_mod(_, _)) { }\n         case (cdir_dir_mod(_, _, ?cdirs)) {\n             for (@crate_directive cdir in cdirs) {\n                 visit_crate_directive(cdir, e, v);\n             }\n         }\n-        case (cdir_view_item(?vi)) {\n-            vt(v).visit_view_item(vi, e, v);\n-        }\n-        case (cdir_meta(_,_)) {}\n-        case (cdir_syntax(_)) {}\n-        case (cdir_auth(_, _)) {}\n+        case (cdir_view_item(?vi)) { vt(v).visit_view_item(vi, e, v); }\n+        case (cdir_meta(_, _)) { }\n+        case (cdir_syntax(_)) { }\n+        case (cdir_auth(_, _)) { }\n     }\n }\n \n fn visit_mod[E](&_mod m, &span sp, &E e, &vt[E] v) {\n-    for (@view_item vi in m.view_items) {\n-        vt(v).visit_view_item(vi, e, v);\n-    }\n-    for (@item i in m.items) {\n-        vt(v).visit_item(i, e, v);\n-    }\n+    for (@view_item vi in m.view_items) { vt(v).visit_view_item(vi, e, v); }\n+    for (@item i in m.items) { vt(v).visit_item(i, e, v); }\n }\n \n-fn visit_view_item[E](&@view_item vi, &E e, &vt[E] v) {}\n+fn visit_view_item[E](&@view_item vi, &E e, &vt[E] v) { }\n \n fn visit_local[E](&@local loc, &E e, &vt[E] v) {\n     alt (loc.node.ty) {\n-        case (none) {}\n+        case (none) { }\n         case (some(?t)) { vt(v).visit_ty(t, e, v); }\n     }\n     alt (loc.node.init) {\n-        case (none) {}\n+        case (none) { }\n         case (some(?i)) { vt(v).visit_expr(i.expr, e, v); }\n     }\n }\n@@ -111,9 +106,7 @@ fn visit_item[E](&@item i, &E e, &vt[E] v) {\n         case (item_fn(?nm, ?f, ?tp, _, ?d, ?a)) {\n             vt(v).visit_fn(f, tp, i.span, nm, d, a, e, v);\n         }\n-        case (item_mod(_, ?m, _, _)) {\n-            vt(v).visit_mod(m, i.span, e, v);\n-        }\n+        case (item_mod(_, ?m, _, _)) { vt(v).visit_mod(m, i.span, e, v); }\n         case (item_native_mod(_, ?nm, _, _)) {\n             for (@view_item vi in nm.view_items) {\n                 vt(v).visit_view_item(vi, e, v);\n@@ -122,9 +115,7 @@ fn visit_item[E](&@item i, &E e, &vt[E] v) {\n                 vt(v).visit_native_item(ni, e, v);\n             }\n         }\n-        case (item_ty(_, ?t, _, _, _, _)) {\n-            vt(v).visit_ty(t, e, v);\n-        }\n+        case (item_ty(_, ?t, _, _, _, _)) { vt(v).visit_ty(t, e, v); }\n         case (item_tag(_, ?variants, _, _, _, _)) {\n             for (variant vr in variants) {\n                 for (variant_arg va in vr.node.args) {\n@@ -133,22 +124,19 @@ fn visit_item[E](&@item i, &E e, &vt[E] v) {\n             }\n         }\n         case (item_obj(_, ?ob, _, _, _, _)) {\n-            for (obj_field f in ob.fields) {\n-                vt(v).visit_ty(f.ty, e, v);\n-            }\n+            for (obj_field f in ob.fields) { vt(v).visit_ty(f.ty, e, v); }\n             for (@method m in ob.methods) {\n                 vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,\n                                m.node.id, m.node.ann, e, v);\n             }\n             alt (ob.dtor) {\n-                case (none) {}\n+                case (none) { }\n                 case (some(?m)) {\n                     vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,\n                                    m.node.id, m.node.ann, e, v);\n                 }\n             }\n         }\n-\n     }\n }\n \n@@ -160,22 +148,14 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n         case (ty_port(?t)) { vt(v).visit_ty(t, e, v); }\n         case (ty_chan(?t)) { vt(v).visit_ty(t, e, v); }\n         case (ty_tup(?mts)) {\n-            for (mt mt in mts) {\n-                vt(v).visit_ty(mt.ty, e, v);\n-            }\n+            for (mt mt in mts) { vt(v).visit_ty(mt.ty, e, v); }\n         }\n         case (ty_rec(?flds)) {\n-            for (ty_field f in flds) {\n-                vt(v).visit_ty(f.node.mt.ty, e, v);\n-            }\n+            for (ty_field f in flds) { vt(v).visit_ty(f.node.mt.ty, e, v); }\n         }\n         case (ty_fn(_, ?args, ?out, _, ?constrs)) {\n-            for (ty_arg a in args) {\n-                vt(v).visit_ty(a.node.ty, e, v);\n-            }\n-            for (@constr c in constrs) {\n-                vt(v).visit_constr(c, e, v);\n-            }\n+            for (ty_arg a in args) { vt(v).visit_ty(a.node.ty, e, v); }\n+            for (@constr c in constrs) { vt(v).visit_constr(c, e, v); }\n             vt(v).visit_ty(out, e, v);\n         }\n         case (ty_obj(?tmeths)) {\n@@ -187,17 +167,16 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n             }\n         }\n         case (ty_path(?p, _)) {\n-            for (@ty tp in p.node.types) {\n-                vt(v).visit_ty(tp, e, v);\n-            }\n+            for (@ty tp in p.node.types) { vt(v).visit_ty(tp, e, v); }\n         }\n         case (ty_constr(?t, _)) { vt(v).visit_ty(t, e, v); }\n-        case (_) {}\n+        case (_) { }\n     }\n }\n \n fn visit_constr[E](&@constr c, &E e, &vt[E] v) {\n     // default\n+\n }\n \n fn visit_pat[E](&@pat p, &E e, &vt[E] v) {\n@@ -206,26 +185,20 @@ fn visit_pat[E](&@pat p, &E e, &vt[E] v) {\n             for (@ty tp in path.node.types) { vt(v).visit_ty(tp, e, v); }\n             for (@pat child in children) { vt(v).visit_pat(child, e, v); }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n }\n \n fn visit_native_item[E](&@native_item ni, &E e, &vt[E] v) {\n     alt (ni.node) {\n-        case (native_item_fn(_, _, ?fd, _, _, _)) {\n-            visit_fn_decl(fd, e, v);\n-        }\n-        case (native_item_ty(_, _)) {}\n+        case (native_item_fn(_, _, ?fd, _, _, _)) { visit_fn_decl(fd, e, v); }\n+        case (native_item_ty(_, _)) { }\n     }\n }\n \n fn visit_fn_decl[E](&fn_decl fd, &E e, &vt[E] v) {\n-    for (arg a in fd.inputs) {\n-        vt(v).visit_ty(a.ty, e, v);\n-    }\n-    for (@constr c in fd.constraints) {\n-        vt(v).visit_constr(c, e, v);\n-    }\n+    for (arg a in fd.inputs) { vt(v).visit_ty(a.ty, e, v); }\n+    for (@constr c in fd.constraints) { vt(v).visit_constr(c, e, v); }\n     vt(v).visit_ty(fd.output, e, v);\n }\n \n@@ -259,9 +232,8 @@ fn visit_decl[E](&@decl d, &E e, &vt[E] v) {\n \n fn visit_expr_opt[E](option::t[@expr] eo, &E e, &vt[E] v) {\n     alt (eo) {\n-        case (none) {}\n-        case (some(?ex)) { vt(v).visit_expr(ex, e, v);\n-        }\n+        case (none) { }\n+        case (some(?ex)) { vt(v).visit_expr(ex, e, v); }\n     }\n }\n \n@@ -271,9 +243,7 @@ fn visit_exprs[E](vec[@expr] exprs, &E e, &vt[E] v) {\n \n fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n     alt (ex.node) {\n-        case (expr_vec(?es, _, _, _)) {\n-            visit_exprs(es, e, v);\n-        }\n+        case (expr_vec(?es, _, _, _)) { visit_exprs(es, e, v); }\n         case (expr_tup(?elts, _)) {\n             for (elt el in elts) { vt(v).visit_expr(el.expr, e, v); }\n         }\n@@ -298,9 +268,7 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_unary(_, ?a, _)) {\n-            vt(v).visit_expr(a, e, v);\n-        }\n+        case (expr_unary(_, ?a, _)) { vt(v).visit_expr(a, e, v); }\n         case (expr_lit(_, _)) { }\n         case (expr_cast(?x, ?t, _)) {\n             vt(v).visit_expr(x, e, v);\n@@ -331,17 +299,13 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n         }\n         case (expr_alt(?x, ?arms, _)) {\n             vt(v).visit_expr(x, e, v);\n-            for (arm a in arms) {\n-                vt(v).visit_arm(a, e, v);\n-            }\n+            for (arm a in arms) { vt(v).visit_arm(a, e, v); }\n         }\n         case (expr_fn(?f, _)) {\n             visit_fn_decl(f.decl, e, v);\n             vt(v).visit_block(f.body, e, v);\n         }\n-        case (expr_block(?b, _)) {\n-            vt(v).visit_block(b, e, v);\n-        }\n+        case (expr_block(?b, _)) { vt(v).visit_block(b, e, v); }\n         case (expr_assign(?a, ?b, _)) {\n             vt(v).visit_expr(b, e, v);\n             vt(v).visit_expr(a, e, v);\n@@ -362,48 +326,29 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_field(?x, _, _)) {\n-            vt(v).visit_expr(x, e, v);\n-        }\n+        case (expr_field(?x, _, _)) { vt(v).visit_expr(x, e, v); }\n         case (expr_index(?a, ?b, _)) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n         case (expr_path(?p, _)) {\n-            for (@ty tp in p.node.types) {\n-                vt(v).visit_ty(tp, e, v);\n-            }\n+            for (@ty tp in p.node.types) { vt(v).visit_ty(tp, e, v); }\n         }\n         case (expr_ext(_, _, _, ?expansion, _)) {\n             vt(v).visit_expr(expansion, e, v);\n         }\n         case (expr_fail(_, _)) { }\n         case (expr_break(_)) { }\n         case (expr_cont(_)) { }\n-        case (expr_ret(?eo, _)) {\n-            visit_expr_opt(eo, e, v);\n-        }\n-        case (expr_put(?eo, _)) {\n-            visit_expr_opt(eo, e, v);\n-        }\n-        case (expr_be(?x, _)) {\n-            vt(v).visit_expr(x, e, v);\n-        }\n-        case (expr_log(_,?x, _)) {\n-            vt(v).visit_expr(x, e, v);\n-        }\n-        case (expr_check(?x, _)) {\n-            vt(v).visit_expr(x, e, v);\n-        }\n-        case (expr_assert(?x, _)) {\n-            vt(v).visit_expr(x, e, v);\n-        }\n+        case (expr_ret(?eo, _)) { visit_expr_opt(eo, e, v); }\n+        case (expr_put(?eo, _)) { visit_expr_opt(eo, e, v); }\n+        case (expr_be(?x, _)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_log(_, ?x, _)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_check(?x, _)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_assert(?x, _)) { vt(v).visit_expr(x, e, v); }\n         case (expr_port(_)) { }\n-        case (expr_chan(?x, _)) {\n-            vt(v).visit_expr(x, e, v);\n-        }\n-\n-        case (expr_anon_obj(?anon_obj,_,_,_)) { \n+        case (expr_chan(?x, _)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_anon_obj(?anon_obj, _, _, _)) {\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n@@ -414,12 +359,10 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             }\n             alt (anon_obj.with_obj) {\n                 case (none) { }\n-                case (some(?ex)) {\n-                    vt(v).visit_expr(ex, e, v);\n-                }\n+                case (some(?ex)) { vt(v).visit_expr(ex, e, v); }\n             }\n             for (@method m in anon_obj.methods) {\n-                vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident, \n+                vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,\n                                m.node.id, m.node.ann, e, v);\n             }\n         }\n@@ -430,7 +373,6 @@ fn visit_arm[E](&arm a, &E e, &vt[E] v) {\n     vt(v).visit_pat(a.pat, e, v);\n     vt(v).visit_block(a.block, e, v);\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "a57d3183677aa9cad39274d25ab7111fcc9487a8", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 133, "deletions": 224, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,49 +1,49 @@\n-import front::ast;\n \n+import front::ast;\n import std::option;\n import std::option::some;\n import std::option::none;\n-\n import util::common::span;\n import util::common::respan;\n \n+\n // FIXME: Should visit patterns as well.\n type ast_visitor =\n-    rec(fn () -> bool                  keep_going,\n-        fn () -> bool                  want_crate_directives,\n-        fn (&ast::crate c)              visit_crate_pre,\n-        fn (&ast::crate c)              visit_crate_post,\n-        fn (&@ast::crate_directive cd)  visit_crate_directive_pre,\n-        fn (&@ast::crate_directive cd)  visit_crate_directive_post,\n-        fn (&@ast::view_item i)         visit_view_item_pre,\n-        fn (&@ast::view_item i)         visit_view_item_post,\n-        fn (&@ast::native_item i)       visit_native_item_pre,\n-        fn (&@ast::native_item i)       visit_native_item_post,\n-        fn (&@ast::item i)              visit_item_pre,\n-        fn (&@ast::item i)              visit_item_post,\n-        fn (&@ast::method m)            visit_method_pre,\n-        fn (&@ast::method m)            visit_method_post,\n-        fn (&ast::block b)              visit_block_pre,\n-        fn (&ast::block b)              visit_block_post,\n-        fn (&@ast::stmt s)              visit_stmt_pre,\n-        fn (&@ast::stmt s)              visit_stmt_post,\n-        fn (&ast::arm a)                visit_arm_pre,\n-        fn (&ast::arm a)                visit_arm_post,\n-        fn (&@ast::pat p)               visit_pat_pre,\n-        fn (&@ast::pat p)               visit_pat_post,\n-        fn (&@ast::decl d)              visit_decl_pre,\n-        fn (&@ast::decl d)              visit_decl_post,\n-        fn (&@ast::local l)            visit_local_pre,\n-        fn (&@ast::local l)            visit_local_post,\n-        fn (&@ast::expr e)              visit_expr_pre,\n-        fn (&@ast::expr e)              visit_expr_post,\n-        fn (&@ast::ty t)                visit_ty_pre,\n-        fn (&@ast::ty t)                visit_ty_post,\n-        fn (&@ast::constr c)            visit_constr,\n-        fn (&ast::_fn f, &span sp, &ast::ident name, \n-            &ast::def_id d_id, &ast::ann a)  visit_fn_pre,\n-        fn (&ast::_fn f, &span sp, &ast::ident name,\n-            &ast::def_id d_id, &ast::ann a)  visit_fn_post);\n+    rec(fn() -> bool  keep_going,\n+        fn() -> bool  want_crate_directives,\n+        fn(&ast::crate)  visit_crate_pre,\n+        fn(&ast::crate)  visit_crate_post,\n+        fn(&@ast::crate_directive)  visit_crate_directive_pre,\n+        fn(&@ast::crate_directive)  visit_crate_directive_post,\n+        fn(&@ast::view_item)  visit_view_item_pre,\n+        fn(&@ast::view_item)  visit_view_item_post,\n+        fn(&@ast::native_item)  visit_native_item_pre,\n+        fn(&@ast::native_item)  visit_native_item_post,\n+        fn(&@ast::item)  visit_item_pre,\n+        fn(&@ast::item)  visit_item_post,\n+        fn(&@ast::method)  visit_method_pre,\n+        fn(&@ast::method)  visit_method_post,\n+        fn(&ast::block)  visit_block_pre,\n+        fn(&ast::block)  visit_block_post,\n+        fn(&@ast::stmt)  visit_stmt_pre,\n+        fn(&@ast::stmt)  visit_stmt_post,\n+        fn(&ast::arm)  visit_arm_pre,\n+        fn(&ast::arm)  visit_arm_post,\n+        fn(&@ast::pat)  visit_pat_pre,\n+        fn(&@ast::pat)  visit_pat_post,\n+        fn(&@ast::decl)  visit_decl_pre,\n+        fn(&@ast::decl)  visit_decl_post,\n+        fn(&@ast::local)  visit_local_pre,\n+        fn(&@ast::local)  visit_local_post,\n+        fn(&@ast::expr)  visit_expr_pre,\n+        fn(&@ast::expr)  visit_expr_post,\n+        fn(&@ast::ty)  visit_ty_pre,\n+        fn(&@ast::ty)  visit_ty_post,\n+        fn(&@ast::constr)  visit_constr,\n+        fn(&ast::_fn, &span, &ast::ident, &ast::def_id, &ast::ann)\n+            visit_fn_pre,\n+        fn(&ast::_fn, &span, &ast::ident, &ast::def_id, &ast::ann)\n+            visit_fn_post);\n \n fn walk_crate(&ast_visitor v, &ast::crate c) {\n     if (!v.keep_going()) { ret; }\n@@ -63,30 +63,24 @@ fn walk_crate_directive(&ast_visitor v, @ast::crate_directive cd) {\n                 walk_crate_directive(v, cdir);\n             }\n         }\n-        case (ast::cdir_src_mod(_, _)) {}\n+        case (ast::cdir_src_mod(_, _)) { }\n         case (ast::cdir_dir_mod(_, _, ?cdirs)) {\n             for (@ast::crate_directive cdir in cdirs) {\n                 walk_crate_directive(v, cdir);\n             }\n         }\n-        case (ast::cdir_view_item(?vi)) {\n-            walk_view_item(v, vi);\n-        }\n-        case (ast::cdir_meta(_,_)) {}\n-        case (ast::cdir_syntax(_)) {}\n-        case (ast::cdir_auth(_, _)) {}\n+        case (ast::cdir_view_item(?vi)) { walk_view_item(v, vi); }\n+        case (ast::cdir_meta(_, _)) { }\n+        case (ast::cdir_syntax(_)) { }\n+        case (ast::cdir_auth(_, _)) { }\n     }\n     v.visit_crate_directive_post(cd);\n }\n \n fn walk_mod(&ast_visitor v, &ast::_mod m) {\n     if (!v.keep_going()) { ret; }\n-    for (@ast::view_item vi in m.view_items) {\n-        walk_view_item(v, vi);\n-    }\n-    for (@ast::item i in m.items) {\n-        walk_item(v, i);\n-    }\n+    for (@ast::view_item vi in m.view_items) { walk_view_item(v, vi); }\n+    for (@ast::item i in m.items) { walk_item(v, i); }\n }\n \n fn walk_view_item(&ast_visitor v, @ast::view_item vi) {\n@@ -97,15 +91,10 @@ fn walk_view_item(&ast_visitor v, @ast::view_item vi) {\n \n fn walk_local(&ast_visitor v, @ast::local loc) {\n     v.visit_local_pre(loc);\n-    alt (loc.node.ty) {\n-        case (none) {}\n-        case (some(?t)) { walk_ty(v, t); }\n-    }\n+    alt (loc.node.ty) { case (none) { } case (some(?t)) { walk_ty(v, t); } }\n     alt (loc.node.init) {\n-        case (none) {}\n-        case (some(?i)) {\n-            walk_expr(v, i.expr);\n-        }\n+        case (none) { }\n+        case (some(?i)) { walk_expr(v, i.expr); }\n     }\n     v.visit_local_post(loc);\n }\n@@ -121,15 +110,9 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n         case (ast::item_fn(?nm, ?f, _, _, ?d, ?a)) {\n             walk_fn(v, f, i.span, nm, d, a);\n         }\n-        case (ast::item_mod(_, ?m, _, _)) {\n-            walk_mod(v, m);\n-        }\n-        case (ast::item_native_mod(_, ?nm, _, _)) {\n-            walk_native_mod(v, nm);\n-        }\n-        case (ast::item_ty(_, ?t, _, _, _, _)) {\n-            walk_ty(v, t);\n-        }\n+        case (ast::item_mod(_, ?m, _, _)) { walk_mod(v, m); }\n+        case (ast::item_native_mod(_, ?nm, _, _)) { walk_native_mod(v, nm); }\n+        case (ast::item_ty(_, ?t, _, _, _, _)) { walk_ty(v, t); }\n         case (ast::item_tag(_, ?variants, _, _, _, _)) {\n             for (ast::variant vr in variants) {\n                 for (ast::variant_arg va in vr.node.args) {\n@@ -138,24 +121,21 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n             }\n         }\n         case (ast::item_obj(_, ?ob, _, _, _, _)) {\n-            for (ast::obj_field f in ob.fields) {\n-                walk_ty(v, f.ty);\n-            }\n+            for (ast::obj_field f in ob.fields) { walk_ty(v, f.ty); }\n             for (@ast::method m in ob.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, m.span,\n-                        m.node.ident, m.node.id, m.node.ann);\n+                walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n+                        m.node.ann);\n                 v.visit_method_post(m);\n             }\n             alt (ob.dtor) {\n-                case (none) {}\n+                case (none) { }\n                 case (some(?m)) {\n                     walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n                             m.node.ann);\n                 }\n             }\n         }\n-\n     }\n     v.visit_item_post(i);\n }\n@@ -164,40 +144,32 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n     if (!v.keep_going()) { ret; }\n     v.visit_ty_pre(t);\n     alt (t.node) {\n-        case (ast::ty_nil) {}\n-        case (ast::ty_bot) {}\n-        case (ast::ty_bool) {}\n-        case (ast::ty_int) {}\n-        case (ast::ty_uint) {}\n-        case (ast::ty_float) {}\n-        case (ast::ty_machine(_)) {}\n-        case (ast::ty_char) {}\n-        case (ast::ty_str) {}\n-        case (ast::ty_istr) {}\n+        case (ast::ty_nil) { }\n+        case (ast::ty_bot) { }\n+        case (ast::ty_bool) { }\n+        case (ast::ty_int) { }\n+        case (ast::ty_uint) { }\n+        case (ast::ty_float) { }\n+        case (ast::ty_machine(_)) { }\n+        case (ast::ty_char) { }\n+        case (ast::ty_str) { }\n+        case (ast::ty_istr) { }\n         case (ast::ty_box(?mt)) { walk_ty(v, mt.ty); }\n         case (ast::ty_vec(?mt)) { walk_ty(v, mt.ty); }\n         case (ast::ty_ivec(?mt)) { walk_ty(v, mt.ty); }\n         case (ast::ty_ptr(?mt)) { walk_ty(v, mt.ty); }\n-        case (ast::ty_task) {}\n+        case (ast::ty_task) { }\n         case (ast::ty_port(?t)) { walk_ty(v, t); }\n         case (ast::ty_chan(?t)) { walk_ty(v, t); }\n         case (ast::ty_tup(?mts)) {\n-            for (ast::mt mt in mts) {\n-                walk_ty(v, mt.ty);\n-            }\n+            for (ast::mt mt in mts) { walk_ty(v, mt.ty); }\n         }\n         case (ast::ty_rec(?flds)) {\n-            for (ast::ty_field f in flds) {\n-                walk_ty(v, f.node.mt.ty);\n-            }\n+            for (ast::ty_field f in flds) { walk_ty(v, f.node.mt.ty); }\n         }\n         case (ast::ty_fn(_, ?args, ?out, _, ?constrs)) {\n-            for (ast::ty_arg a in args) {\n-                walk_ty(v, a.node.ty);\n-            }\n-            for (@ast::constr c in constrs) {\n-                v.visit_constr(c);\n-            }\n+            for (ast::ty_arg a in args) { walk_ty(v, a.node.ty); }\n+            for (@ast::constr c in constrs) { v.visit_constr(c); }\n             walk_ty(v, out);\n         }\n         case (ast::ty_obj(?tmeths)) {\n@@ -209,11 +181,9 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n             }\n         }\n         case (ast::ty_path(?p, _)) {\n-            for (@ast::ty tp in p.node.types) {\n-                walk_ty(v, tp);\n-            }\n+            for (@ast::ty tp in p.node.types) { walk_ty(v, tp); }\n         }\n-        case (ast::ty_type) {}\n+        case (ast::ty_type) { }\n         case (ast::ty_constr(?t, _)) { walk_ty(v, t); }\n     }\n     v.visit_ty_post(t);\n@@ -223,26 +193,18 @@ fn walk_pat(&ast_visitor v, &@ast::pat p) {\n     v.visit_pat_pre(p);\n     alt (p.node) {\n         case (ast::pat_tag(?path, ?children, _)) {\n-            for (@ast::ty tp in path.node.types) {\n-                walk_ty(v, tp);\n-            }\n-            for (@ast::pat child in children) {\n-                walk_pat(v, child);\n-            }\n+            for (@ast::ty tp in path.node.types) { walk_ty(v, tp); }\n+            for (@ast::pat child in children) { walk_pat(v, child); }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     v.visit_pat_post(p);\n }\n \n fn walk_native_mod(&ast_visitor v, &ast::native_mod nm) {\n     if (!v.keep_going()) { ret; }\n-    for (@ast::view_item vi in nm.view_items) {\n-        walk_view_item(v, vi);\n-    }\n-    for (@ast::native_item ni in nm.items) {\n-        walk_native_item(v, ni);\n-    }\n+    for (@ast::view_item vi in nm.view_items) { walk_view_item(v, vi); }\n+    for (@ast::native_item ni in nm.items) { walk_native_item(v, ni); }\n }\n \n fn walk_native_item(&ast_visitor v, @ast::native_item ni) {\n@@ -252,19 +214,14 @@ fn walk_native_item(&ast_visitor v, @ast::native_item ni) {\n         case (ast::native_item_fn(_, _, ?fd, _, _, _)) {\n             walk_fn_decl(v, fd);\n         }\n-        case (ast::native_item_ty(_, _)) {\n-        }\n+        case (ast::native_item_ty(_, _)) { }\n     }\n     v.visit_native_item_post(ni);\n }\n \n fn walk_fn_decl(&ast_visitor v, &ast::fn_decl fd) {\n-    for (ast::arg a in fd.inputs) {\n-        walk_ty(v, a.ty);\n-    }\n-    for (@ast::constr c in fd.constraints) {\n-        v.visit_constr(c);\n-    }\n+    for (ast::arg a in fd.inputs) { walk_ty(v, a.ty); }\n+    for (@ast::constr c in fd.constraints) { v.visit_constr(c); }\n     walk_ty(v, fd.output);\n }\n \n@@ -280,9 +237,7 @@ fn walk_fn(&ast_visitor v, &ast::_fn f, &span sp, &ast::ident i,\n fn walk_block(&ast_visitor v, &ast::block b) {\n     if (!v.keep_going()) { ret; }\n     v.visit_block_pre(b);\n-    for (@ast::stmt s in b.node.stmts) {\n-        walk_stmt(v, s);\n-    }\n+    for (@ast::stmt s in b.node.stmts) { walk_stmt(v, s); }\n     walk_expr_opt(v, b.node.expr);\n     v.visit_block_post(b);\n }\n@@ -291,12 +246,8 @@ fn walk_stmt(&ast_visitor v, @ast::stmt s) {\n     if (!v.keep_going()) { ret; }\n     v.visit_stmt_pre(s);\n     alt (s.node) {\n-        case (ast::stmt_decl(?d, _)) {\n-            walk_decl(v, d);\n-        }\n-        case (ast::stmt_expr(?e, _)) {\n-            walk_expr(v, e);\n-        }\n+        case (ast::stmt_decl(?d, _)) { walk_decl(v, d); }\n+        case (ast::stmt_expr(?e, _)) { walk_expr(v, e); }\n         case (ast::stmt_crate_directive(?cdir)) {\n             walk_crate_directive(v, cdir);\n         }\n@@ -308,47 +259,30 @@ fn walk_decl(&ast_visitor v, @ast::decl d) {\n     if (!v.keep_going()) { ret; }\n     v.visit_decl_pre(d);\n     alt (d.node) {\n-        case (ast::decl_local(?loc)) {\n-            walk_local(v, @respan(d.span, loc));\n-        }\n-        case (ast::decl_item(?it)) {\n-            walk_item(v, it);\n-        }\n+        case (ast::decl_local(?loc)) { walk_local(v, @respan(d.span, loc)); }\n+        case (ast::decl_item(?it)) { walk_item(v, it); }\n     }\n     v.visit_decl_post(d);\n }\n \n fn walk_expr_opt(&ast_visitor v, option::t[@ast::expr] eo) {\n-    alt (eo) {\n-        case (none) {}\n-        case (some(?e)) {\n-            walk_expr(v, e);\n-        }\n-    }\n+    alt (eo) { case (none) { } case (some(?e)) { walk_expr(v, e); } }\n }\n \n fn walk_exprs(&ast_visitor v, vec[@ast::expr] exprs) {\n-    for (@ast::expr e in exprs) {\n-        walk_expr(v, e);\n-    }\n+    for (@ast::expr e in exprs) { walk_expr(v, e); }\n }\n \n fn walk_expr(&ast_visitor v, @ast::expr e) {\n     if (!v.keep_going()) { ret; }\n     v.visit_expr_pre(e);\n     alt (e.node) {\n-        case (ast::expr_vec(?es, _, _, _)) {\n-            walk_exprs(v, es);\n-        }\n+        case (ast::expr_vec(?es, _, _, _)) { walk_exprs(v, es); }\n         case (ast::expr_tup(?elts, _)) {\n-            for (ast::elt e in elts) {\n-                walk_expr(v, e.expr);\n-            }\n+            for (ast::elt e in elts) { walk_expr(v, e.expr); }\n         }\n         case (ast::expr_rec(?flds, ?base, _)) {\n-            for (ast::field f in flds) {\n-                walk_expr(v, f.node.expr);\n-            }\n+            for (ast::field f in flds) { walk_expr(v, f.node.expr); }\n             walk_expr_opt(v, base);\n         }\n         case (ast::expr_call(?callee, ?args, _)) {\n@@ -358,9 +292,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_self_method(_, _)) { }\n         case (ast::expr_bind(?callee, ?args, _)) {\n             walk_expr(v, callee);\n-            for (option::t[@ast::expr] eo in args) {\n-                walk_expr_opt(v, eo);\n-            }\n+            for (option::t[@ast::expr] eo in args) { walk_expr_opt(v, eo); }\n         }\n         case (ast::expr_spawn(_, _, ?callee, ?args, _)) {\n             walk_expr(v, callee);\n@@ -370,14 +302,9 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_unary(_, ?a, _)) {\n-            walk_expr(v, a);\n-        }\n+        case (ast::expr_unary(_, ?a, _)) { walk_expr(v, a); }\n         case (ast::expr_lit(_, _)) { }\n-        case (ast::expr_cast(?x, ?t, _)) {\n-            walk_expr(v, x);\n-            walk_ty(v, t);\n-        }\n+        case (ast::expr_cast(?x, ?t, _)) { walk_expr(v, x); walk_ty(v, t); }\n         case (ast::expr_if(?x, ?b, ?eo, _)) {\n             walk_expr(v, x);\n             walk_block(v, b);\n@@ -414,127 +341,110 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             walk_fn_decl(v, f.decl);\n             walk_block(v, f.body);\n         }\n-        case (ast::expr_block(?b, _)) {\n-            walk_block(v, b);\n-        }\n+        case (ast::expr_block(?b, _)) { walk_block(v, b); }\n         case (ast::expr_assign(?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_move(?a, ?b, _)) {\n-            walk_expr(v, a);\n-            walk_expr(v, b);\n-        }\n+        case (ast::expr_move(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n         case (ast::expr_assign_op(_, ?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_send(?a, ?b, _)) {\n-            walk_expr(v, a);\n-            walk_expr(v, b);\n-        }\n-        case (ast::expr_recv(?a, ?b, _)) {\n-            walk_expr(v, a);\n-            walk_expr(v, b);\n-        }\n-        case (ast::expr_field(?x, _, _)) {\n-            walk_expr(v, x);\n-        }\n+        case (ast::expr_send(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n+        case (ast::expr_recv(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n+        case (ast::expr_field(?x, _, _)) { walk_expr(v, x); }\n         case (ast::expr_index(?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n         case (ast::expr_path(?p, _)) {\n-            for (@ast::ty tp in p.node.types) {\n-                walk_ty(v, tp);\n-            }\n+            for (@ast::ty tp in p.node.types) { walk_ty(v, tp); }\n         }\n         case (ast::expr_ext(_, ?args, ?body, ?expansion, _)) {\n             // Only walk expansion, not args/body.\n+\n             walk_expr(v, expansion);\n         }\n         case (ast::expr_fail(_, _)) { }\n         case (ast::expr_break(_)) { }\n         case (ast::expr_cont(_)) { }\n-        case (ast::expr_ret(?eo, _)) {\n-            walk_expr_opt(v, eo);\n-        }\n-        case (ast::expr_put(?eo, _)) {\n-            walk_expr_opt(v, eo);\n-        }\n-        case (ast::expr_be(?x, _)) {\n-            walk_expr(v, x);\n-        }\n-        case (ast::expr_log(_,?x, _)) {\n-            walk_expr(v, x);\n-        }\n-        case (ast::expr_check(?x, _)) {\n-            walk_expr(v, x);\n-        }\n-        case (ast::expr_assert(?x, _)) {\n-            walk_expr(v, x);\n-        }\n+        case (ast::expr_ret(?eo, _)) { walk_expr_opt(v, eo); }\n+        case (ast::expr_put(?eo, _)) { walk_expr_opt(v, eo); }\n+        case (ast::expr_be(?x, _)) { walk_expr(v, x); }\n+        case (ast::expr_log(_, ?x, _)) { walk_expr(v, x); }\n+        case (ast::expr_check(?x, _)) { walk_expr(v, x); }\n+        case (ast::expr_assert(?x, _)) { walk_expr(v, x); }\n         case (ast::expr_port(_)) { }\n-        case (ast::expr_chan(?x, _)) {\n-            walk_expr(v, x);\n-        }\n-\n-        case (ast::expr_anon_obj(?anon_obj,_,_,_)) { \n-\n+        case (ast::expr_chan(?x, _)) { walk_expr(v, x); }\n+        case (ast::expr_anon_obj(?anon_obj, _, _, _)) {\n             // Fields\n-            let option::t[vec[ast::obj_field]] fields \n-                = none[vec[ast::obj_field]];\n \n+            let option::t[vec[ast::obj_field]] fields =\n+                none[vec[ast::obj_field]];\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n-                    for (ast::obj_field f in fields) {\n-                        walk_ty(v, f.ty);\n-                    }\n+                    for (ast::obj_field f in fields) { walk_ty(v, f.ty); }\n                 }\n             }\n-\n             // with_obj\n+\n             let option::t[@ast::expr] with_obj = none[@ast::expr];\n             alt (anon_obj.with_obj) {\n                 case (none) { }\n-                case (some(?e)) {\n-                    walk_expr(v, e);\n-                }\n+                case (some(?e)) { walk_expr(v, e); }\n             }\n \n             // Methods\n             for (@ast::method m in anon_obj.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, m.span, m.node.ident, \n-                        m.node.id, m.node.ann);\n+                walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n+                        m.node.ann);\n                 v.visit_method_post(m);\n-\n             }\n         }\n     }\n     v.visit_expr_post(e);\n }\n \n fn def_keep_going() -> bool { ret true; }\n+\n fn def_want_crate_directives() -> bool { ret false; }\n+\n fn def_visit_crate(&ast::crate c) { }\n+\n fn def_visit_crate_directive(&@ast::crate_directive c) { }\n+\n fn def_visit_view_item(&@ast::view_item vi) { }\n+\n fn def_visit_native_item(&@ast::native_item ni) { }\n+\n fn def_visit_item(&@ast::item i) { }\n+\n fn def_visit_method(&@ast::method m) { }\n+\n fn def_visit_block(&ast::block b) { }\n+\n fn def_visit_stmt(&@ast::stmt s) { }\n+\n fn def_visit_arm(&ast::arm a) { }\n+\n fn def_visit_pat(&@ast::pat p) { }\n+\n fn def_visit_decl(&@ast::decl d) { }\n+\n fn def_visit_local(&@ast::local l) { }\n+\n fn def_visit_expr(&@ast::expr e) { }\n+\n fn def_visit_ty(&@ast::ty t) { }\n+\n fn def_visit_constr(&@ast::constr c) { }\n+\n fn def_visit_fn(&ast::_fn f, &span sp, &ast::ident i, &ast::def_id d,\n-                &ast::ann a) { }\n+                &ast::ann a) {\n+}\n \n fn default_visitor() -> ast_visitor {\n     ret rec(keep_going=def_keep_going,\n@@ -571,7 +481,6 @@ fn default_visitor() -> ast_visitor {\n             visit_fn_pre=def_visit_fn,\n             visit_fn_post=def_visit_fn);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "c77b288fe2ee849146c5f5517e5f5fc433b61a02", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 94, "deletions": 161, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,7 +1,9 @@\n+\n import std::io;\n import std::vec;\n import std::str;\n \n+\n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's\n  * Mesa pretty-printer, as described in appendix A of\n@@ -54,19 +56,13 @@ import std::str;\n  * line (which it can't) and so naturally place the content on its own line to\n  * avoid combining it with other lines and making matters even worse.\n  */\n-\n tag breaks { consistent; inconsistent; }\n+\n type break_t = rec(int offset, int blank_space);\n-type begin_t = rec(int offset, breaks breaks);\n \n-tag token {\n-    STRING(str,int);\n-    BREAK(break_t);\n-    BEGIN(begin_t);\n-    END;\n-    EOF;\n-}\n+type begin_t = rec(int offset, breaks breaks);\n \n+tag token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n \n fn tok_str(token t) -> str {\n     alt (t) {\n@@ -78,18 +74,16 @@ fn tok_str(token t) -> str {\n     }\n }\n \n-fn buf_str(vec[mutable token] toks, vec[mutable int] szs,\n-           uint left, uint right, uint lim) -> str {\n+fn buf_str(vec[mutable token] toks, vec[mutable int] szs, uint left,\n+           uint right, uint lim) -> str {\n     auto n = vec::len(toks);\n-    assert n == vec::len(szs);\n+    assert (n == vec::len(szs));\n     auto i = left;\n     auto L = lim;\n     auto s = \"[\";\n     while (i != right && L != 0u) {\n         L -= 1u;\n-        if (i != left) {\n-            s += \", \";\n-        }\n+        if (i != left) { s += \", \"; }\n         s += #fmt(\"%d=%s\", szs.(i), tok_str(toks.(i)));\n         i += 1u;\n         i %= n;\n@@ -98,43 +92,35 @@ fn buf_str(vec[mutable token] toks, vec[mutable int] szs,\n     ret s;\n }\n \n-\n tag print_stack_break { fits; broken(breaks); }\n+\n type print_stack_elt = rec(int offset, print_stack_break pbreak);\n \n const int size_infinity = 0xffff;\n \n fn mk_printer(io::writer out, uint linewidth) -> printer {\n-\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n-    let uint n = 3u * linewidth;\n \n+    let uint n = 3u * linewidth;\n     log #fmt(\"mk_printer %u\", linewidth);\n-\n     let vec[mutable token] token = vec::init_elt_mut(EOF, n);\n     let vec[mutable int] size = vec::init_elt_mut(0, n);\n     let vec[mutable uint] scan_stack = vec::init_elt_mut(0u, n);\n     let vec[print_stack_elt] print_stack = [];\n-\n-    ret printer(out,\n-                n,\n-                linewidth as int, // margin\n-                linewidth as int, // space\n-                0u,               // left\n-                0u,               // right\n-                token,\n-                size,\n-                0,                // left_total\n-                0,                // right_total\n-                scan_stack,\n-                true,             // scan_stack_empty\n-                0u,               // top\n-                0u,               // bottom\n-                print_stack,\n-                0);\n+    ret printer(out, n, linewidth as int, // margin\n+                 linewidth as int, // space\n+                 0u, // left\n+                 0u, // right\n+                 token, size, 0, // left_total\n+                 0, // right_total\n+                 scan_stack, true, // scan_stack_empty\n+                 0u, // top\n+                 0u, // bottom\n+                 print_stack, 0);\n }\n \n+\n /*\n  * In case you do not have the paper, here is an explanation of what's going\n  * on.\n@@ -212,66 +198,65 @@ fn mk_printer(io::writer out, uint linewidth) -> printer {\n  * the method called 'pretty_print', and the 'PRINT' process is the method\n  * called 'print'.\n  */\n-\n obj printer(io::writer out,\n             uint buf_len,\n-            mutable int margin,        // width of lines we're constrained to\n-            mutable int space,         // number of spaces left on line\n-\n-            mutable uint left,         // index of left side of input stream\n-            mutable uint right,        // index of right side of input stream\n-            mutable vec[mutable token] token,// ring-buffr stream goes through\n-            mutable vec[mutable int] size,  // ring-buffer of calculated sizes\n-            mutable int left_total,    // running size of stream \"...left\"\n-            mutable int right_total,   // running size of stream \"...right\"\n-\n-            // pseudo-stack, really a ring too. Holds the primary-ring-buffers\n-            // index of the BEGIN that started the current block, possibly\n-            // with the most recent BREAK after that BEGIN (if there is any)\n-            // on top of it. Stuff is flushed off the bottom as it becomes\n-            // irrelevant due to the primary ring-buffer advancing.\n-\n-            mutable vec[mutable uint] scan_stack,\n+            mutable int margin, // width of lines we're constrained to\n+\n+            mutable int space, // number of spaces left on line\n+\n+            mutable uint left, // index of left side of input stream\n+\n+            mutable uint right, // index of right side of input stream\n+\n+            mutable vec[mutable token]\n+                token, // ring-buffr stream goes through\n+\n+            mutable vec[mutable int] size, // ring-buffer of calculated sizes\n+\n+            mutable int left_total, // running size of stream \"...left\"\n+\n+            mutable int right_total, // running size of stream \"...right\"\n+\n+             // pseudo-stack, really a ring too. Holds the\n+             // primary-ring-buffers index of the BEGIN that started the\n+             // current block, possibly with the most recent BREAK after that\n+             // BEGIN (if there is any) on top of it. Stuff is flushed off the\n+             // bottom as it becomes irrelevant due to the primary ring-buffer\n+             // advancing.\n+             mutable vec[mutable uint] scan_stack,\n             mutable bool scan_stack_empty, // top==bottom disambiguator\n-            mutable uint top,              // index of top of scan_stack\n-            mutable uint bottom,           // index of bottom of scan_stack\n \n-            // stack of blocks-in-progress being flushed by print\n-            mutable vec[print_stack_elt] print_stack,\n+            mutable uint top, // index of top of scan_stack\n \n-            // buffered indentation to avoid writing trailing whitespace\n-            mutable int pending_indentation\n-            ) {\n+            mutable uint bottom, // index of bottom of scan_stack\n \n+             // stack of blocks-in-progress being flushed by print\n+            mutable vec[print_stack_elt] print_stack,\n \n+            // buffered indentation to avoid writing trailing whitespace\n+            mutable int pending_indentation) {\n     fn pretty_print(token t) {\n-\n         log #fmt(\"pp [%u,%u]\", left, right);\n         alt (t) {\n-\n             case (EOF) {\n                 if (!scan_stack_empty) {\n                     self.check_stack(0);\n                     self.advance_left(token.(left), size.(left));\n                 }\n                 self.indent(0);\n             }\n-\n             case (BEGIN(?b)) {\n                 if (scan_stack_empty) {\n                     left_total = 1;\n                     right_total = 1;\n                     left = 0u;\n                     right = 0u;\n-                } else {\n-                    self.advance_right();\n-                }\n+                } else { self.advance_right(); }\n                 log #fmt(\"pp BEGIN/buffer [%u,%u]\", left, right);\n                 token.(right) = t;\n                 size.(right) = -right_total;\n                 self.scan_push(right);\n             }\n-\n             case (END) {\n                 if (scan_stack_empty) {\n                     log #fmt(\"pp END/print [%u,%u]\", left, right);\n@@ -284,24 +269,20 @@ obj printer(io::writer out,\n                     self.scan_push(right);\n                 }\n             }\n-\n             case (BREAK(?b)) {\n                 if (scan_stack_empty) {\n                     left_total = 1;\n                     right_total = 1;\n                     left = 0u;\n                     right = 0u;\n-                } else {\n-                    self.advance_right();\n-                }\n+                } else { self.advance_right(); }\n                 log #fmt(\"pp BREAK/buffer [%u,%u]\", left, right);\n                 self.check_stack(0);\n                 self.scan_push(right);\n                 token.(right) = t;\n                 size.(right) = -right_total;\n                 right_total += b.blank_space;\n             }\n-\n             case (STRING(?s, ?len)) {\n                 if (scan_stack_empty) {\n                     log #fmt(\"pp STRING/print [%u,%u]\", left, right);\n@@ -317,86 +298,65 @@ obj printer(io::writer out,\n             }\n         }\n     }\n-\n     fn check_stream() {\n         log #fmt(\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n-                     left, right, left_total, right_total);;\n+                 left, right, left_total, right_total);\n         if (right_total - left_total > space) {\n             log #fmt(\"scan window is %d, longer than space on line (%d)\",\n-                         right_total - left_total, space);\n+                     right_total - left_total, space);\n             if (!scan_stack_empty) {\n                 if (left == scan_stack.(bottom)) {\n                     log #fmt(\"setting %u to infinity and popping\", left);\n                     size.(self.scan_pop_bottom()) = size_infinity;\n                 }\n             }\n             self.advance_left(token.(left), size.(left));\n-            if (left != right) {\n-                self.check_stream();\n-            }\n+            if (left != right) { self.check_stream(); }\n         }\n     }\n-\n     fn scan_push(uint x) {\n         log #fmt(\"scan_push %u\", x);\n         if (scan_stack_empty) {\n             scan_stack_empty = false;\n-        } else {\n-            top += 1u;\n-            top %= buf_len;\n-            assert top != bottom;\n-        }\n+        } else { top += 1u; top %= buf_len; assert (top != bottom); }\n         scan_stack.(top) = x;\n     }\n-\n     fn scan_pop() -> uint {\n-        assert !scan_stack_empty;\n+        assert (!scan_stack_empty);\n         auto x = scan_stack.(top);\n         if (top == bottom) {\n             scan_stack_empty = true;\n-        } else {\n-            top += (buf_len - 1u);\n-            top %= buf_len;\n-        }\n+        } else { top += buf_len - 1u; top %= buf_len; }\n         ret x;\n     }\n-\n     fn scan_top() -> uint {\n-        assert !scan_stack_empty;\n+        assert (!scan_stack_empty);\n         ret scan_stack.(top);\n     }\n-\n     fn scan_pop_bottom() -> uint {\n-        assert !scan_stack_empty;\n+        assert (!scan_stack_empty);\n         auto x = scan_stack.(bottom);\n         if (top == bottom) {\n             scan_stack_empty = true;\n-        } else {\n-            bottom += 1u;\n-            bottom %= buf_len;\n-        }\n+        } else { bottom += 1u; bottom %= buf_len; }\n         ret x;\n     }\n-\n     fn advance_right() {\n         right += 1u;\n         right %= buf_len;\n-        assert right != left;\n+        assert (right != left);\n     }\n-\n     fn advance_left(token x, int L) {\n         log #fmt(\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L);\n         if (L >= 0) {\n             self.print(x, L);\n             alt (x) {\n-                case (BREAK(?b)) {\n-                    left_total += b.blank_space;\n-                }\n+                case (BREAK(?b)) { left_total += b.blank_space; }\n                 case (STRING(_, ?len)) {\n-                    assert len == L;\n+                    assert (len == L);\n                     left_total += len;\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n             if (left != right) {\n                 left += 1u;\n@@ -405,7 +365,6 @@ obj printer(io::writer out,\n             }\n         }\n     }\n-\n     fn check_stack(int k) {\n         if (!scan_stack_empty) {\n             auto x = self.scan_top();\n@@ -418,93 +377,75 @@ obj printer(io::writer out,\n                 }\n                 case (END) {\n                     // paper says + not =, but that makes no sense.\n+\n                     size.(self.scan_pop()) = 1;\n                     self.check_stack(k + 1);\n                 }\n                 case (_) {\n                     size.(self.scan_pop()) = size.(x) + right_total;\n-                    if (k > 0) {\n-                        self.check_stack(k);\n-                    }\n+                    if (k > 0) { self.check_stack(k); }\n                 }\n             }\n         }\n     }\n-\n     fn print_newline(int amount) {\n         log #fmt(\"NEWLINE %d\", amount);\n         out.write_str(\"\\n\");\n         pending_indentation = 0;\n         self.indent(amount);\n     }\n-\n     fn indent(int amount) {\n         log #fmt(\"INDENT %d\", amount);\n         pending_indentation += amount;\n     }\n-\n     fn top() -> print_stack_elt {\n         auto n = vec::len(print_stack);\n-        let print_stack_elt top =\n-            rec(offset=0, pbreak=broken(inconsistent));;\n-        if (n != 0u) {\n-            top = print_stack.(n - 1u);\n-        }\n+        let print_stack_elt top = rec(offset=0, pbreak=broken(inconsistent));\n+        if (n != 0u) { top = print_stack.(n - 1u); }\n         ret top;\n     }\n-\n     fn write_str(str s) {\n         while (pending_indentation > 0) {\n             out.write_str(\" \");\n             pending_indentation -= 1;\n         }\n         out.write_str(s);\n     }\n-\n     fn print(token x, int L) {\n-        log #fmt(\"print %s %d (remaining line space=%d)\",\n-                 tok_str(x), L, space);\n+        log #fmt(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n+                 space);\n         log buf_str(token, size, left, right, 6u);\n         alt (x) {\n             case (BEGIN(?b)) {\n                 if (L > space) {\n-                    auto col = (margin - space) + b.offset;\n+                    auto col = margin - space + b.offset;\n                     log #fmt(\"print BEGIN -> push broken block at col %d\",\n                              col);\n                     vec::push(print_stack,\n-                              rec(offset = col,\n-                                  pbreak = broken(b.breaks)));\n+                              rec(offset=col, pbreak=broken(b.breaks)));\n                 } else {\n                     log \"print BEGIN -> push fitting block\";\n-                    vec::push(print_stack,\n-                              rec(offset = 0,\n-                                  pbreak = fits));\n+                    vec::push(print_stack, rec(offset=0, pbreak=fits));\n                 }\n             }\n-\n             case (END) {\n                 log \"print END -> pop END\";\n-                assert vec::len(print_stack) != 0u;\n+                assert (vec::len(print_stack) != 0u);\n                 vec::pop(print_stack);\n             }\n-\n             case (BREAK(?b)) {\n-\n                 auto top = self.top();\n-\n                 alt (top.pbreak) {\n                     case (fits) {\n                         log \"print BREAK in fitting block\";\n                         space -= b.blank_space;\n                         self.indent(b.blank_space);\n                     }\n-\n                     case (broken(consistent)) {\n                         log \"print BREAK in consistent block\";\n                         self.print_newline(top.offset + b.offset);\n                         space = margin - (top.offset + b.offset);\n                     }\n-\n                     case (broken(inconsistent)) {\n                         if (L > space) {\n                             log \"print BREAK w/ newline in inconsistent\";\n@@ -518,17 +459,17 @@ obj printer(io::writer out,\n                     }\n                 }\n             }\n-\n             case (STRING(?s, ?len)) {\n                 log \"print STRING\";\n-                assert L == len;\n+                assert (L == len);\n                 // assert L <= space;\n+\n                 space -= len;\n                 self.write_str(s);\n             }\n-\n             case (EOF) {\n                 // EOF should never get here.\n+\n                 fail;\n             }\n         }\n@@ -537,45 +478,37 @@ obj printer(io::writer out,\n \n \n // Convenience functions to talk to the printer.\n-\n fn box(printer p, uint indent, breaks b) {\n-    p.pretty_print(BEGIN(rec(offset = indent as int,\n-                             breaks = b)));\n+    p.pretty_print(BEGIN(rec(offset=indent as int, breaks=b)));\n }\n \n+fn ibox(printer p, uint indent) { box(p, indent, inconsistent); }\n \n-fn ibox(printer p, uint indent) {\n-    box(p, indent, inconsistent);\n-}\n-\n-fn cbox(printer p, uint indent) {\n-    box(p, indent, consistent);\n-}\n-\n+fn cbox(printer p, uint indent) { box(p, indent, consistent); }\n \n fn break_offset(printer p, uint n, int off) {\n-    p.pretty_print(BREAK(rec(offset = off,\n-                             blank_space = n as int)));\n+    p.pretty_print(BREAK(rec(offset=off, blank_space=n as int)));\n }\n \n fn end(printer p) { p.pretty_print(END); }\n+\n fn eof(printer p) { p.pretty_print(EOF); }\n+\n fn word(printer p, str wrd) {\n     p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n }\n-fn huge_word(printer p, str wrd) {\n-    p.pretty_print(STRING(wrd, 0xffff));\n-}\n-fn zero_word(printer p, str wrd) {\n-    p.pretty_print(STRING(wrd, 0));\n-}\n+\n+fn huge_word(printer p, str wrd) { p.pretty_print(STRING(wrd, 0xffff)); }\n+\n+fn zero_word(printer p, str wrd) { p.pretty_print(STRING(wrd, 0)); }\n+\n fn spaces(printer p, uint n) { break_offset(p, n, 0); }\n-fn zerobreak(printer p) { spaces(p, 0u); }\n-fn space(printer p) { spaces(p, 1u); }\n-fn hardbreak(printer p) { spaces(p, 0xffffu); }\n \n+fn zerobreak(printer p) { spaces(p, 0u); }\n \n+fn space(printer p) { spaces(p, 1u); }\n \n+fn hardbreak(printer p) { spaces(p, 0xffffu); }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "f1a85287c7f58c1497e3b298590403264629c376", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 131, "deletions": 224, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::io;\n import middle::ty::*;\n import front::ast::constr_arg;\n@@ -10,169 +11,122 @@ import front::codemap;\n import front::codemap::codemap;\n \n fn ty_to_str(&ctxt cx, &t typ) -> str {\n-\n-  fn fn_input_to_str(&ctxt cx,\n-                     &rec(middle::ty::mode mode, t ty) input) -> str {\n-        auto s = alt (input.mode) {\n-            case (mo_val) { \"\" }\n-            case (mo_alias(false)) { \"&\" }\n-            case (mo_alias(true)) { \"&mutable \" }\n-        };\n-\n+    fn fn_input_to_str(&ctxt cx, &rec(middle::ty::mode mode, t ty) input) ->\n+       str {\n+        auto s =\n+            alt (input.mode) {\n+                case (mo_val) { \"\" }\n+                case (mo_alias(false)) { \"&\" }\n+                case (mo_alias(true)) { \"&mutable \" }\n+            };\n         ret s + ty_to_str(cx, input.ty);\n     }\n-\n-    fn fn_to_str(&ctxt cx,\n-                 ast::proto proto,\n-                 option::t[ast::ident] ident,\n+    fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  vec[arg] inputs, t output, ast::controlflow cf,\n                  &vec[@ast::constr] constrs) -> str {\n-            auto f = bind fn_input_to_str(cx, _);\n-\n-            auto s;\n-            alt (proto) {\n-                case (ast::proto_iter) {\n-                    s = \"iter\";\n-                }\n-                case (ast::proto_fn) {\n-                    s = \"fn\";\n-                }\n-            }\n-\n-            alt (ident) {\n-                case (some(?i)) {\n-                    s += \" \";\n-                    s += i;\n-                }\n-                case (_) { }\n+        auto f = bind fn_input_to_str(cx, _);\n+        auto s;\n+        alt (proto) {\n+            case (ast::proto_iter) { s = \"iter\"; }\n+            case (ast::proto_fn) { s = \"fn\"; }\n+        }\n+        alt (ident) { case (some(?i)) { s += \" \"; s += i; } case (_) { } }\n+        s += \"(\";\n+        s += str::connect(vec::map[arg, str](f, inputs), \", \");\n+        s += \")\";\n+        if (struct(cx, output) != ty_nil) {\n+            alt (cf) {\n+                case (ast::noreturn) { s += \" -> !\"; }\n+                case (ast::return) { s += \" -> \" + ty_to_str(cx, output); }\n             }\n-\n-            s += \"(\";\n-            s += str::connect(vec::map[arg,str](f, inputs), \", \");\n-            s += \")\";\n-\n-            if (struct(cx, output) != ty_nil) {\n-                alt (cf) {\n-                    case (ast::noreturn) {\n-                        s += \" -> !\";\n-                    }\n-                    case (ast::return) {\n-                        s += \" -> \" + ty_to_str(cx, output);\n-                    }\n-                }\n-            }\n-\n-            s += constrs_str(constrs);\n-            ret s;\n+        }\n+        s += constrs_str(constrs);\n+        ret s;\n     }\n-\n     fn method_to_str(&ctxt cx, &method m) -> str {\n-        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident),\n-                      m.inputs, m.output, m.cf, m.constrs) + \";\";\n+        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident), m.inputs,\n+                      m.output, m.cf, m.constrs) + \";\";\n     }\n-\n     fn field_to_str(&ctxt cx, &field f) -> str {\n         ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n     }\n-\n     fn mt_to_str(&ctxt cx, &mt m) -> str {\n         auto mstr;\n         alt (m.mut) {\n-            case (ast::mut)       { mstr = \"mutable \"; }\n-            case (ast::imm)       { mstr = \"\";         }\n+            case (ast::mut) { mstr = \"mutable \"; }\n+            case (ast::imm) { mstr = \"\"; }\n             case (ast::maybe_mut) { mstr = \"mutable? \"; }\n         }\n-\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n-\n-    alt (cname(cx, typ)) {\n-        case (some(?cs)) {\n-            ret cs;\n-        }\n-        case (_) { }\n-    }\n-\n+    alt (cname(cx, typ)) { case (some(?cs)) { ret cs; } case (_) { } }\n     auto s = \"\";\n-\n     alt (struct(cx, typ)) {\n-        case (ty_native)       { s += \"native\";                          }\n-        case (ty_nil)          { s += \"()\";                              }\n-        case (ty_bot)          { s += \"_|_\";                             }\n-        case (ty_bool)         { s += \"bool\";                            }\n-        case (ty_int)          { s += \"int\";                             }\n-        case (ty_float)        { s += \"float\";                           }\n-        case (ty_uint)         { s += \"uint\";                            }\n-        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm);        }\n-        case (ty_char)         { s += \"char\";                            }\n-        case (ty_str)          { s += \"str\";                             }\n-        case (ty_istr)         { s += \"istr\";                            }\n-        case (ty_box(?tm))     { s += \"@\" + mt_to_str(cx, tm);           }\n-        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(cx, tm) + \"]\";  }\n-        case (ty_ivec(?tm))    { s += \"ivec[\" + mt_to_str(cx, tm) + \"]\"; }\n-        case (ty_port(?t))     { s += \"port[\" + ty_to_str(cx, t) + \"]\";  }\n-        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(cx, t) + \"]\";  }\n-        case (ty_type)         { s += \"type\";                            }\n-        case (ty_task)         { s += \"task\";                            }\n-\n+        case (ty_native) { s += \"native\"; }\n+        case (ty_nil) { s += \"()\"; }\n+        case (ty_bot) { s += \"_|_\"; }\n+        case (ty_bool) { s += \"bool\"; }\n+        case (ty_int) { s += \"int\"; }\n+        case (ty_float) { s += \"float\"; }\n+        case (ty_uint) { s += \"uint\"; }\n+        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm); }\n+        case (ty_char) { s += \"char\"; }\n+        case (ty_str) { s += \"str\"; }\n+        case (ty_istr) { s += \"istr\"; }\n+        case (ty_box(?tm)) { s += \"@\" + mt_to_str(cx, tm); }\n+        case (ty_vec(?tm)) { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n+        case (ty_ivec(?tm)) { s += \"ivec[\" + mt_to_str(cx, tm) + \"]\"; }\n+        case (ty_port(?t)) { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_chan(?t)) { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_type) { s += \"type\"; }\n+        case (ty_task) { s += \"task\"; }\n         case (ty_tup(?elems)) {\n             auto f = bind mt_to_str(cx, _);\n-            auto strs = vec::map[mt,str](f, elems);\n+            auto strs = vec::map[mt, str](f, elems);\n             s += \"tup(\" + str::connect(strs, \",\") + \")\";\n         }\n-\n         case (ty_rec(?elems)) {\n             auto f = bind field_to_str(cx, _);\n-            auto strs = vec::map[field,str](f, elems);\n+            auto strs = vec::map[field, str](f, elems);\n             s += \"rec(\" + str::connect(strs, \",\") + \")\";\n         }\n-\n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-            s += \"<tag#\" + util::common::istr(id._0) + \":\" +\n-                util::common::istr(id._1) + \">\";\n+\n+            s +=\n+                \"<tag#\" + util::common::istr(id._0) + \":\" +\n+                    util::common::istr(id._1) + \">\";\n             if (vec::len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n-                auto strs = vec::map[t,str](f, tps);\n+                auto strs = vec::map[t, str](f, tps);\n                 s += \"[\" + str::connect(strs, \",\") + \"]\";\n             }\n         }\n-\n         case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n-            s += fn_to_str(cx, proto, none[ast::ident], inputs, output, cf,\n-                           constrs);\n+            s +=\n+                fn_to_str(cx, proto, none[ast::ident], inputs, output, cf,\n+                          constrs);\n         }\n-\n         case (ty_native_fn(_, ?inputs, ?output)) {\n-          let vec[@ast::constr] constrs = [];\n-            s += fn_to_str(cx, ast::proto_fn, none[ast::ident],\n-                           inputs, output, ast::return, constrs);\n+            let vec[@ast::constr] constrs = [];\n+            s +=\n+                fn_to_str(cx, ast::proto_fn, none[ast::ident], inputs, output,\n+                          ast::return, constrs);\n         }\n-\n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n-            auto m = vec::map[method,str](f, meths);\n+            auto m = vec::map[method, str](f, meths);\n             s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n-\n-        case (ty_var(?v)) {\n-            s += \"<T\" + util::common::istr(v) + \">\";\n-        }\n-\n+        case (ty_var(?v)) { s += \"<T\" + util::common::istr(v) + \">\"; }\n         case (ty_param(?id)) {\n             s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n-\n-        case (_) {\n-            s += ty_to_short_str(cx, typ);\n-        }\n-\n+        case (_) { s += ty_to_short_str(cx, typ); }\n     }\n-\n     ret s;\n }\n \n-\n fn ty_to_short_str(&ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n     auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::ac_no_abbrevs);\n@@ -181,46 +135,29 @@ fn ty_to_short_str(&ctxt cx, t typ) -> str {\n     ret s;\n }\n \n-fn constr_arg_to_str[T](fn (&T) -> str f,\n-                        &ast::constr_arg_general_[T] c) -> str {\n+fn constr_arg_to_str[T](fn(&T) -> str  f, &ast::constr_arg_general_[T] c) ->\n+   str {\n     alt (c) {\n-        case (ast::carg_base) {\n-            ret \"*\";\n-        }\n-        case (ast::carg_ident(?i)) {\n-            ret f(i);\n-        }\n-        case (ast::carg_lit(?l)) {\n-            ret lit_to_str(l);\n-        }\n+        case (ast::carg_base) { ret \"*\"; }\n+        case (ast::carg_ident(?i)) { ret f(i); }\n+        case (ast::carg_lit(?l)) { ret lit_to_str(l); }\n     }\n }\n \n fn constr_arg_to_str_1(&ast::constr_arg_general_[str] c) -> str {\n     alt (c) {\n-        case (ast::carg_base) {\n-            ret \"*\";\n-        }\n-        case (ast::carg_ident(?i)) {\n-            ret i;\n-        }\n-        case (ast::carg_lit(?l)) {\n-            ret lit_to_str(l);\n-        }\n+        case (ast::carg_base) { ret \"*\"; }\n+        case (ast::carg_ident(?i)) { ret i; }\n+        case (ast::carg_lit(?l)) { ret lit_to_str(l); }\n     }\n }\n \n-fn constr_args_to_str[T](fn (&T) -> str f, \n+fn constr_args_to_str[T](fn(&T) -> str  f,\n                          &vec[@ast::constr_arg_general[T]] args) -> str {\n     auto comma = false;\n-    auto s   = \"(\";\n+    auto s = \"(\";\n     for (@ast::constr_arg_general[T] a in args) {\n-        if (comma) {\n-            s += \", \";\n-        }\n-        else {\n-            comma = true;\n-        }\n+        if (comma) { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str[T](f, a.node);\n     }\n     s += \")\";\n@@ -229,14 +166,9 @@ fn constr_args_to_str[T](fn (&T) -> str f,\n \n fn constr_args_to_str_1(&vec[@ast::constr_arg_use] args) -> str {\n     auto comma = false;\n-    auto s   = \"(\";\n+    auto s = \"(\";\n     for (@ast::constr_arg_use a in args) {\n-        if (comma) {\n-            s += \", \";\n-        }\n-        else {\n-            comma = true;\n-        }\n+        if (comma) { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str_1(a.node);\n     }\n     s += \")\";\n@@ -245,7 +177,6 @@ fn constr_args_to_str_1(&vec[@ast::constr_arg_use] args) -> str {\n \n fn print_literal(&ps s, &@ast::lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n-\n     alt (next_lit(s)) {\n         case (some(?lt)) {\n             if (lt.pos == lit.span.lo) {\n@@ -254,39 +185,33 @@ fn print_literal(&ps s, &@ast::lit lit) {\n                 ret;\n             }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n-\n     alt (lit.node) {\n-        case (ast::lit_str(?st,?kind)) {\n+        case (ast::lit_str(?st, ?kind)) {\n             if (kind == ast::sk_unique) { word(s.s, \"~\"); }\n             print_string(s, st);\n         }\n         case (ast::lit_char(?ch)) {\n-            word(s.s, \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'')\n-                + \"'\");\n-        }\n-        case (ast::lit_int(?val)) {\n-            word(s.s, common::istr(val));\n-        }\n-        case (ast::lit_uint(?val)) {\n-            word(s.s, common::uistr(val) + \"u\");\n-        }\n-        case (ast::lit_float(?fstr)) {\n-            word(s.s, fstr);\n+            word(s.s,\n+                 \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'') + \"'\");\n         }\n-        case (ast::lit_mach_int(?mach,?val)) {\n+        case (ast::lit_int(?val)) { word(s.s, common::istr(val)); }\n+        case (ast::lit_uint(?val)) { word(s.s, common::uistr(val) + \"u\"); }\n+        case (ast::lit_float(?fstr)) { word(s.s, fstr); }\n+        case (ast::lit_mach_int(?mach, ?val)) {\n             word(s.s, common::istr(val as int));\n             word(s.s, common::ty_mach_to_str(mach));\n         }\n-        case (ast::lit_mach_float(?mach,?val)) {\n+        case (ast::lit_mach_float(?mach, ?val)) {\n             // val is already a str\n+\n             word(s.s, val);\n             word(s.s, common::ty_mach_to_str(mach));\n         }\n-        case (ast::lit_nil) {word(s.s, \"()\");}\n+        case (ast::lit_nil) { word(s.s, \"()\"); }\n         case (ast::lit_bool(?val)) {\n-            if (val) {word(s.s, \"true\");} else {word(s.s, \"false\");}\n+            if (val) { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n         }\n     }\n }\n@@ -298,9 +223,9 @@ fn next_lit(&ps s) -> option::t[lexer::lit] {\n         case (some(?lits)) {\n             if (s.cur_lit < vec::len(lits)) {\n                 ret some(lits.(s.cur_lit));\n-            } else {ret none[lexer::lit];}\n+            } else { ret none[lexer::lit]; }\n         }\n-        case (_) {ret none[lexer::lit];}\n+        case (_) { ret none[lexer::lit]; }\n     }\n }\n \n@@ -313,31 +238,25 @@ fn maybe_print_comment(&ps s, uint pos) {\n                     s.cur_cmnt += 1u;\n                 } else { break; }\n             }\n-            case (_) {break;}\n+            case (_) { break; }\n         }\n     }\n }\n \n-\n fn print_comment(&ps s, lexer::cmnt cmnt) {\n     alt (cmnt.style) {\n         case (lexer::mixed) {\n-            assert vec::len(cmnt.lines) == 1u;\n+            assert (vec::len(cmnt.lines) == 1u);\n             zerobreak(s.s);\n             word(s.s, cmnt.lines.(0));\n             zerobreak(s.s);\n         }\n-\n         case (lexer::isolated) {\n             hardbreak(s.s);\n             ibox(s, 0u);\n-            for (str line in cmnt.lines) {\n-                word(s.s, line);\n-                hardbreak(s.s);\n-            }\n+            for (str line in cmnt.lines) { word(s.s, line); hardbreak(s.s); }\n             end(s);\n         }\n-\n         case (lexer::trailing) {\n             word(s.s, \" \");\n             if (vec::len(cmnt.lines) == 1u) {\n@@ -356,23 +275,25 @@ fn print_comment(&ps s, lexer::cmnt cmnt) {\n }\n \n fn print_string(&ps s, &str st) {\n-    word(s.s, \"\\\"\"); word(s.s, escape_str(st, '\"')); word(s.s, \"\\\"\");\n+    word(s.s, \"\\\"\");\n+    word(s.s, escape_str(st, '\"'));\n+    word(s.s, \"\\\"\");\n }\n \n-\n fn escape_str(str st, char to_escape) -> str {\n     let str out = \"\";\n     auto len = str::byte_len(st);\n     auto i = 0u;\n     while (i < len) {\n         alt (st.(i) as char) {\n-            case ('\\n') {out += \"\\\\n\";}\n-            case ('\\t') {out += \"\\\\t\";}\n-            case ('\\r') {out += \"\\\\r\";}\n-            case ('\\\\') {out += \"\\\\\\\\\";}\n+            case ('\\n') { out += \"\\\\n\"; }\n+            case ('\\t') { out += \"\\\\t\"; }\n+            case ('\\r') { out += \"\\\\r\"; }\n+            case ('\\\\') { out += \"\\\\\\\\\"; }\n             case (?cur) {\n-                if (cur == to_escape) {out += \"\\\\\";}\n+                if (cur == to_escape) { out += \"\\\\\"; }\n                 // FIXME some (or all?) non-ascii things should be escaped\n+\n                 str::push_char(out, cur);\n             }\n         }\n@@ -381,50 +302,43 @@ fn escape_str(str st, char to_escape) -> str {\n     ret out;\n }\n \n-fn to_str[T](&T t, fn(&ps s, &T s) f) -> str {\n+fn to_str[T](&T t, fn(&ps, &T)  f) -> str {\n     auto writer = io::string_writer();\n     auto s = rust_printer(writer.get_writer());\n     f(s, t);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n-\n fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n     alt (s.comments) {\n         case (some(?cmnts)) {\n             if (s.cur_cmnt < vec::len(cmnts)) {\n                 ret some(cmnts.(s.cur_cmnt));\n-            } else {ret none[lexer::cmnt];}\n+            } else { ret none[lexer::cmnt]; }\n         }\n-        case (_) {ret none[lexer::cmnt];}\n+        case (_) { ret none[lexer::cmnt]; }\n     }\n }\n \n-type ps = @rec(pp::printer s,\n-               option::t[codemap] cm,\n-               option::t[vec[lexer::cmnt]] comments,\n-               option::t[vec[lexer::lit]] literals,\n-               mutable uint cur_cmnt,\n-               mutable uint cur_lit,\n-               mutable vec[pp::breaks] boxes,\n-               mode mode);\n+type ps =\n+    @rec(pp::printer s,\n+         option::t[codemap] cm,\n+         option::t[vec[lexer::cmnt]] comments,\n+         option::t[vec[lexer::lit]] literals,\n+         mutable uint cur_cmnt,\n+         mutable uint cur_lit,\n+         mutable vec[pp::breaks] boxes,\n+         mode mode);\n \n fn ibox(&ps s, uint u) {\n     vec::push(s.boxes, pp::inconsistent);\n     pp::ibox(s.s, u);\n }\n \n-fn end(&ps s) {\n-    vec::pop(s.boxes);\n-    pp::end(s.s);\n-}\n+fn end(&ps s) { vec::pop(s.boxes); pp::end(s.s); }\n \n-tag mode {\n-    mo_untyped;\n-    mo_typed(ctxt);\n-    mo_identified;\n-}\n+tag mode { mo_untyped; mo_typed(ctxt); mo_identified; }\n \n fn rust_printer(io::writer writer) -> ps {\n     let vec[pp::breaks] boxes = [];\n@@ -439,36 +353,29 @@ fn rust_printer(io::writer writer) -> ps {\n }\n \n const uint indent_unit = 4u;\n+\n const uint default_columns = 78u;\n \n+\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(&uint i) -> str {\n-    ret util::common::uistr(i);\n-}\n+fn uint_to_str(&uint i) -> str { ret util::common::uistr(i); }\n \n fn constr_to_str(&@ast::constr c) -> str {\n-  ret path_to_str(c.node.path)\n-      + constr_args_to_str(uint_to_str, c.node.args);\n+    ret path_to_str(c.node.path) +\n+            constr_args_to_str(uint_to_str, c.node.args);\n }\n \n fn constrs_str(&vec[@ast::constr] constrs) -> str {\n-  auto s = \"\";\n-  auto colon = true;\n-  for (@ast::constr c in constrs) {\n-    if (colon) {\n-      s += \" : \";\n-      colon = false;\n-    }\n-    else {\n-      s += \", \";\n+    auto s = \"\";\n+    auto colon = true;\n+    for (@ast::constr c in constrs) {\n+        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n+        s += constr_to_str(c);\n     }\n-    s += constr_to_str(c);\n-  }\n-  ret s;\n+    ret s;\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "35e116c880ff2a54c48e3e1d82097440e28de4e3", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 213, "deletions": 287, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::uint;\n import std::vec;\n import std::str;\n@@ -10,10 +11,8 @@ import front::codemap::codemap;\n import front::ast;\n import middle::ty;\n import util::common;\n-\n import option::some;\n import option::none;\n-\n import pp::printer;\n import pp::break_offset;\n import pp::word;\n@@ -32,23 +31,29 @@ fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n               mode mode) {\n     let vec[pp::breaks] boxes = [];\n     auto r = lexer::gather_comments_and_literals(sess, filename);\n-    auto s = @rec(s=pp::mk_printer(out, default_columns),\n-                  cm=some(sess.get_codemap()),\n-                  comments=some(r.cmnts),\n-                  literals=some(r.lits),\n-                  mutable cur_cmnt=0u,\n-                  mutable cur_lit=0u,\n-                  mutable boxes = boxes,\n-                  mode=mode);\n+    auto s =\n+        @rec(s=pp::mk_printer(out, default_columns),\n+             cm=some(sess.get_codemap()),\n+             comments=some(r.cmnts),\n+             literals=some(r.lits),\n+             mutable cur_cmnt=0u,\n+             mutable cur_lit=0u,\n+             mutable boxes=boxes,\n+             mode=mode);\n     print_mod(s, _mod);\n     eof(s.s);\n }\n \n fn ty_to_str(&ast::ty ty) -> str { be to_str(ty, print_type); }\n+\n fn pat_to_str(&@ast::pat pat) -> str { be to_str(pat, print_pat); }\n+\n fn expr_to_str(&@ast::expr e) -> str { be to_str(e, print_expr); }\n+\n fn stmt_to_str(&ast::stmt s) -> str { be to_str(s, print_stmt); }\n+\n fn item_to_str(&@ast::item i) -> str { be to_str(i, print_item); }\n+\n fn path_to_str(&ast::path p) -> str { be to_str(p, print_path); }\n \n fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n@@ -62,11 +67,11 @@ fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n fn block_to_str(&ast::block blk) -> str {\n     auto writer = io::string_writer();\n     auto s = rust_printer(writer.get_writer());\n-\n     // containing cbox, will be closed by print-block at }\n-    cbox(s, indent_unit);\n \n+    cbox(s, indent_unit);\n     // head-ibox, will be closed by print-block after {\n+\n     ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n@@ -83,45 +88,41 @@ fn box(&ps s, uint u, pp::breaks b) {\n     pp::box(s.s, u, b);\n }\n \n-fn word_nbsp(&ps s, str w) {\n-    word(s.s, w);\n-    word(s.s, \" \");\n-}\n+fn word_nbsp(&ps s, str w) { word(s.s, w); word(s.s, \" \"); }\n \n-fn word_space(&ps s, str w) {\n-    word(s.s, w);\n-    space(s.s);\n-}\n+fn word_space(&ps s, str w) { word(s.s, w); space(s.s); }\n \n-fn popen(&ps s) {\n-    word(s.s, \"(\");\n-}\n+fn popen(&ps s) { word(s.s, \"(\"); }\n \n-fn pclose(&ps s) {\n-    word(s.s, \")\");\n-}\n+fn pclose(&ps s) { word(s.s, \")\"); }\n \n fn head(&ps s, str w) {\n     // outer-box is consistent\n+\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n+\n     ibox(s, str::char_len(w) + 1u);\n     // keyword that starts the head\n+\n     word_nbsp(s, w);\n }\n \n fn bopen(&ps s) {\n     word(s.s, \"{\");\n     end(s); // close the head-box\n+\n }\n \n fn bclose(&ps s, common::span span) {\n     maybe_print_comment(s, span.hi);\n     break_offset(s.s, 1u, -(indent_unit as int));\n     word(s.s, \"}\");\n     end(s); // close the outer-box\n+\n }\n \n+\n // Synthesizes a comment that was not textually present in the original source\n // file.\n fn synth_comment(&ps s, str text) {\n@@ -132,19 +133,18 @@ fn synth_comment(&ps s, str text) {\n     word(s.s, \"*/\");\n }\n \n-fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op) {\n+fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op) {\n     box(s, 0u, b);\n     auto first = true;\n     for (IN elt in elts) {\n-        if (first) {first = false;}\n-        else {word_space(s, \",\");}\n+        if (first) { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n     end(s);\n }\n \n-fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op,\n-                     fn(&IN) -> common::span get_span) {\n+fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op,\n+                     fn(&IN) -> common::span  get_span) {\n     box(s, 0u, b);\n     auto len = vec::len[IN](elts);\n     auto i = 0u;\n@@ -163,7 +163,7 @@ fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op,\n }\n \n fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n-    fn expr_span(&@ast::expr expr) -> common::span {ret expr.span;}\n+    fn expr_span(&@ast::expr expr) -> common::span { ret expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n@@ -173,38 +173,45 @@ fn print_mod(&ps s, ast::_mod _mod) {\n     }\n     for (@ast::item item in _mod.items) {\n         // Mod-level item printing we're a little more space-y about.\n+\n         hardbreak(s.s);\n         print_item(s, item);\n     }\n     print_remaining_comments(s);\n }\n \n fn print_boxed_type(&ps s, &@ast::ty ty) { print_type(s, *ty); }\n-fn print_type(&ps s, &ast::ty ty) {\n \n+fn print_type(&ps s, &ast::ty ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt (ty.node) {\n-        case (ast::ty_nil) {word(s.s, \"()\");}\n-        case (ast::ty_bool) {word(s.s, \"bool\");}\n-        case (ast::ty_bot) {word(s.s, \"!\");}\n-        case (ast::ty_int) {word(s.s, \"int\");}\n-        case (ast::ty_uint) {word(s.s, \"uint\");}\n-        case (ast::ty_float) {word(s.s, \"float\");}\n-        case (ast::ty_machine(?tm)) {word(s.s, common::ty_mach_to_str(tm));}\n-        case (ast::ty_char) {word(s.s, \"char\");}\n-        case (ast::ty_str) {word(s.s, \"str\");}\n-        case (ast::ty_box(?mt)) {word(s.s, \"@\"); print_mt(s, mt);}\n+        case (ast::ty_nil) { word(s.s, \"()\"); }\n+        case (ast::ty_bool) { word(s.s, \"bool\"); }\n+        case (ast::ty_bot) { word(s.s, \"!\"); }\n+        case (ast::ty_int) { word(s.s, \"int\"); }\n+        case (ast::ty_uint) { word(s.s, \"uint\"); }\n+        case (ast::ty_float) { word(s.s, \"float\"); }\n+        case (ast::ty_machine(?tm)) { word(s.s, common::ty_mach_to_str(tm)); }\n+        case (ast::ty_char) { word(s.s, \"char\"); }\n+        case (ast::ty_str) { word(s.s, \"str\"); }\n+        case (ast::ty_box(?mt)) { word(s.s, \"@\"); print_mt(s, mt); }\n         case (ast::ty_vec(?mt)) {\n-            word(s.s, \"vec[\"); print_mt(s, mt); word(s.s, \"]\");\n+            word(s.s, \"vec[\");\n+            print_mt(s, mt);\n+            word(s.s, \"]\");\n         }\n         case (ast::ty_port(?t)) {\n-            word(s.s, \"port[\"); print_type(s, *t); word(s.s, \"]\");\n+            word(s.s, \"port[\");\n+            print_type(s, *t);\n+            word(s.s, \"]\");\n         }\n         case (ast::ty_chan(?t)) {\n-            word(s.s, \"chan[\"); print_type(s, *t); word(s.s, \"]\");\n+            word(s.s, \"chan[\");\n+            print_type(s, *t);\n+            word(s.s, \"]\");\n         }\n-        case (ast::ty_type) {word(s.s, \"type\");}\n+        case (ast::ty_type) { word(s.s, \"type\"); }\n         case (ast::ty_tup(?elts)) {\n             word(s.s, \"tup\");\n             popen(s);\n@@ -221,9 +228,7 @@ fn print_type(&ps s, &ast::ty ty) {\n                 word(s.s, f.node.ident);\n                 end(s);\n             }\n-            fn get_span(&ast::ty_field f) -> common::span {\n-                ret f.span;\n-            }\n+            fn get_span(&ast::ty_field f) -> common::span { ret f.span; }\n             commasep_cmnt(s, consistent, fields, print_field, get_span);\n             pclose(s);\n         }\n@@ -242,18 +247,15 @@ fn print_type(&ps s, &ast::ty ty) {\n             }\n             bclose(s, ty.span);\n         }\n-        case (ast::ty_fn(?proto,?inputs,?output,?cf,?constrs)) {\n+        case (ast::ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n             print_ty_fn(s, proto, none[str], inputs, output, cf, constrs);\n         }\n-        case (ast::ty_path(?path,_)) {\n-            print_path(s, path);\n-        }\n+        case (ast::ty_path(?path, _)) { print_path(s, path); }\n     }\n     end(s);\n }\n \n fn print_item(&ps s, &@ast::item item) {\n-\n     hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n     alt (item.node) {\n@@ -264,31 +266,33 @@ fn print_item(&ps s, &@ast::item item) {\n             space(s.s);\n             word_space(s, id);\n             end(s); // end the head-ibox\n+\n             word_space(s, \"=\");\n             print_expr(s, expr);\n             word(s.s, \";\");\n             end(s); // end the outer cbox\n+\n         }\n-        case (ast::item_fn(?name,?_fn,?typarams,?attrs,_,_)) {\n+        case (ast::item_fn(?name, ?_fn, ?typarams, ?attrs, _, _)) {\n             print_outer_attributes(s, attrs);\n             print_fn(s, _fn.decl, _fn.proto, name, typarams);\n             word(s.s, \" \");\n             print_block(s, _fn.body);\n         }\n-        case (ast::item_mod(?id,?_mod,?attrs,_)) {\n+        case (ast::item_mod(?id, ?_mod, ?attrs, _)) {\n             print_outer_attributes(s, attrs);\n             head(s, \"mod\");\n             word_nbsp(s, id);\n             bopen(s);\n-            for (@ast::item itm in _mod.items) {print_item(s, itm);}\n+            for (@ast::item itm in _mod.items) { print_item(s, itm); }\n             bclose(s, item.span);\n         }\n-        case (ast::item_native_mod(?id,?nmod,?attrs,_)) {\n+        case (ast::item_native_mod(?id, ?nmod, ?attrs, _)) {\n             print_outer_attributes(s, attrs);\n             head(s, \"native\");\n             alt (nmod.abi) {\n-                case (ast::native_abi_rust) {word_nbsp(s, \"\\\"rust\\\"\");}\n-                case (ast::native_abi_cdecl) {word_nbsp(s, \"\\\"cdecl\\\"\");}\n+                case (ast::native_abi_rust) { word_nbsp(s, \"\\\"rust\\\"\"); }\n+                case (ast::native_abi_cdecl) { word_nbsp(s, \"\\\"cdecl\\\"\"); }\n                 case (ast::native_abi_rust_intrinsic) {\n                     word_nbsp(s, \"\\\"rust-intrinsic\\\"\");\n                 }\n@@ -301,44 +305,46 @@ fn print_item(&ps s, &@ast::item item) {\n                 ibox(s, indent_unit);\n                 maybe_print_comment(s, item.span.lo);\n                 alt (item.node) {\n-                    case (ast::native_item_ty(?id,_)) {\n+                    case (ast::native_item_ty(?id, _)) {\n                         word_nbsp(s, \"type\");\n                         word(s.s, id);\n                     }\n-                    case (ast::native_item_fn(?id,?lname,?decl,\n-                                             ?typarams,_,_)) {\n+                    case (ast::native_item_fn(?id, ?lname, ?decl, ?typarams,\n+                                              _, _)) {\n                         print_fn(s, decl, ast::proto_fn, id, typarams);\n                         alt (lname) {\n-                            case (none) {}\n-                            case (some(?ss)) {\n-                                print_string(s, ss);\n-                            }\n+                            case (none) { }\n+                            case (some(?ss)) { print_string(s, ss); }\n                         }\n                         end(s); // end head-ibox\n+\n                         end(s); // end the outer fn box\n+\n                     }\n                 }\n                 word(s.s, \";\");\n                 end(s);\n             }\n             bclose(s, item.span);\n         }\n-        case (ast::item_ty(?id,?ty,?params,?attrs,_,_)) {\n+        case (ast::item_ty(?id, ?ty, ?params, ?attrs, _, _)) {\n             print_outer_attributes(s, attrs);\n             ibox(s, indent_unit);\n             ibox(s, 0u);\n             word_nbsp(s, \"type\");\n             word(s.s, id);\n             print_type_params(s, params);\n             end(s); // end the inner ibox\n+\n             space(s.s);\n             word_space(s, \"=\");\n             print_type(s, *ty);\n             word(s.s, \";\");\n             end(s); // end the outer ibox\n+\n             break_offset(s.s, 0u, 0);\n         }\n-        case (ast::item_tag(?id,?variants,?params,?attrs,_,_)) {\n+        case (ast::item_tag(?id, ?variants, ?params, ?attrs, _, _)) {\n             print_outer_attributes(s, attrs);\n             head(s, \"tag\");\n             word(s.s, id);\n@@ -362,7 +368,7 @@ fn print_item(&ps s, &@ast::item item) {\n             }\n             bclose(s, item.span);\n         }\n-        case (ast::item_obj(?id,?_obj,?params,?attrs,_,_)) {\n+        case (ast::item_obj(?id, ?_obj, ?params, ?attrs, _, _)) {\n             print_outer_attributes(s, attrs);\n             head(s, \"obj\");\n             word(s.s, id);\n@@ -376,7 +382,7 @@ fn print_item(&ps s, &@ast::item item) {\n                 word(s.s, field.ident);\n                 end(s);\n             }\n-            fn get_span(&ast::obj_field f) -> common::span {ret f.ty.span;}\n+            fn get_span(&ast::obj_field f) -> common::span { ret f.ty.span; }\n             commasep_cmnt(s, consistent, _obj.fields, print_field, get_span);\n             pclose(s);\n             space(s.s);\n@@ -395,7 +401,7 @@ fn print_item(&ps s, &@ast::item item) {\n                     head(s, \"drop\");\n                     print_block(s, dtor.node.meth.body);\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n             bclose(s, item.span);\n         }\n@@ -407,24 +413,19 @@ fn print_item(&ps s, &@ast::item item) {\n             space(s.s);\n             synth_comment(s, uint::to_str(ty::item_ann(item).id, 10u));\n         }\n-        case (_) { /* no-op */ }\n+        case (_) {/* no-op */ }\n     }\n }\n \n fn print_outer_attributes(&ps s, vec[ast::attribute] attrs) {\n     auto count = 0;\n     for (ast::attribute attr in attrs) {\n         alt (attr.node.style) {\n-            case (ast::attr_outer) {\n-                print_attribute(s, attr);\n-                count += 1;\n-            }\n-            case (_) { /* fallthrough */ }\n+            case (ast::attr_outer) { print_attribute(s, attr); count += 1; }\n+            case (_) {/* fallthrough */ }\n         }\n     }\n-    if (count > 0) {\n-        hardbreak(s.s);\n-    }\n+    if (count > 0) { hardbreak(s.s); }\n }\n \n fn print_attribute(&ps s, &ast::attribute attr) {\n@@ -438,33 +439,24 @@ fn print_attribute(&ps s, &ast::attribute attr) {\n fn print_stmt(&ps s, &ast::stmt st) {\n     maybe_print_comment(s, st.span.lo);\n     alt (st.node) {\n-        case (ast::stmt_decl(?decl,_)) {\n-            print_decl(s, decl);\n-        }\n-        case (ast::stmt_expr(?expr,_)) {\n-            space(s.s);\n-            print_expr(s, expr);\n-        }\n+        case (ast::stmt_decl(?decl, _)) { print_decl(s, decl); }\n+        case (ast::stmt_expr(?expr, _)) { space(s.s); print_expr(s, expr); }\n     }\n-    if (front::parser::stmt_ends_with_semi(st)) {word(s.s, \";\");}\n+    if (front::parser::stmt_ends_with_semi(st)) { word(s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, none[uint]);\n }\n \n fn print_block(&ps s, ast::block blk) {\n     maybe_print_comment(s, blk.span.lo);\n     bopen(s);\n-    for (@ast::stmt st in blk.node.stmts) {\n-        print_stmt(s, *st)\n-\n-    }\n+    for (@ast::stmt st in blk.node.stmts) { print_stmt(s, *st) }\n     alt (blk.node.expr) {\n         case (some(?expr)) {\n             space(s.s);\n             print_expr(s, expr);\n-            maybe_print_trailing_comment(s, expr.span,\n-                                         some(blk.span.hi));\n+            maybe_print_trailing_comment(s, expr.span, some(blk.span.hi));\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     bclose(s, blk.span);\n \n@@ -474,93 +466,83 @@ fn print_block(&ps s, ast::block blk) {\n             space(s.s);\n             synth_comment(s, \"block \" + uint::to_str(blk.node.a.id, 10u));\n         }\n-        case (_) { /* no-op */ }\n+        case (_) {/* no-op */ }\n     }\n }\n \n fn print_expr(&ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n-\n     alt (s.mode) {\n-        case (mo_untyped) { /* no-op */ }\n+        case (mo_untyped) {/* no-op */ }\n         case (mo_typed(_)) { popen(s); }\n         case (mo_identified) { popen(s); }\n     }\n-\n     alt (expr.node) {\n-        case (ast::expr_vec(?exprs,?mut,?kind,_)) {\n+        case (ast::expr_vec(?exprs, ?mut, ?kind, _)) {\n             ibox(s, indent_unit);\n-\n             alt (kind) {\n                 case (ast::sk_rc) { word(s.s, \"[\"); }\n                 case (ast::sk_unique) { word(s.s, \"~[\"); }\n             }\n-\n-            if (mut == ast::mut) {\n-                word_nbsp(s, \"mutable\");\n-            }\n+            if (mut == ast::mut) { word_nbsp(s, \"mutable\"); }\n             commasep_exprs(s, inconsistent, exprs);\n             word(s.s, \"]\");\n             end(s);\n         }\n-        case (ast::expr_tup(?exprs,_)) {\n+        case (ast::expr_tup(?exprs, _)) {\n             fn printElt(&ps s, &ast::elt elt) {\n                 ibox(s, indent_unit);\n-                if (elt.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n+                if (elt.mut == ast::mut) { word_nbsp(s, \"mutable\"); }\n                 print_expr(s, elt.expr);\n                 end(s);\n             }\n-            fn get_span(&ast::elt elt) -> common::span {ret elt.expr.span;}\n+            fn get_span(&ast::elt elt) -> common::span { ret elt.expr.span; }\n             word(s.s, \"tup\");\n             popen(s);\n             commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n             pclose(s);\n         }\n-        case (ast::expr_rec(?fields,?wth,_)) {\n+        case (ast::expr_rec(?fields, ?wth, _)) {\n             fn print_field(&ps s, &ast::field field) {\n                 ibox(s, indent_unit);\n-                if (field.node.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n+                if (field.node.mut == ast::mut) { word_nbsp(s, \"mutable\"); }\n                 word(s.s, field.node.ident);\n                 word(s.s, \"=\");\n                 print_expr(s, field.node.expr);\n                 end(s);\n             }\n-            fn get_span(&ast::field field) -> common::span {\n-                ret field.span;\n-            }\n+            fn get_span(&ast::field field) -> common::span { ret field.span; }\n             word(s.s, \"rec\");\n             popen(s);\n             commasep_cmnt(s, consistent, fields, print_field, get_span);\n             alt (wth) {\n                 case (some(?expr)) {\n-                    if (vec::len(fields) > 0u) {space(s.s);}\n+                    if (vec::len(fields) > 0u) { space(s.s); }\n                     ibox(s, indent_unit);\n                     word_space(s, \"with\");\n                     print_expr(s, expr);\n                     end(s);\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n             pclose(s);\n         }\n-        case (ast::expr_call(?func,?args,_)) {\n+        case (ast::expr_call(?func, ?args, _)) {\n             print_expr(s, func);\n             popen(s);\n             commasep_exprs(s, inconsistent, args);\n             pclose(s);\n         }\n-        case (ast::expr_self_method(?ident,_)) {\n+        case (ast::expr_self_method(?ident, _)) {\n             word(s.s, \"self.\");\n             print_ident(s, ident);\n         }\n-        case (ast::expr_bind(?func,?args,_)) {\n+        case (ast::expr_bind(?func, ?args, _)) {\n             fn print_opt(&ps s, &option::t[@ast::expr] expr) {\n                 alt (expr) {\n-                    case (some(?expr)) {\n-                        print_expr(s, expr);\n-                    }\n-                    case (_) {word(s.s, \"_\");}\n+                    case (some(?expr)) { print_expr(s, expr); }\n+                    case (_) { word(s.s, \"_\"); }\n                 }\n             }\n             word_nbsp(s, \"bind\");\n@@ -569,35 +551,32 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             commasep(s, inconsistent, args, print_opt);\n             pclose(s);\n         }\n-    case (ast::expr_spawn(_,_,?e,?es,_)) {\n-          word_nbsp(s, \"spawn\");\n-          print_expr(s, e);\n-          popen(s);\n-          commasep_exprs(s, inconsistent, es);\n-          pclose(s);\n+        case (ast::expr_spawn(_, _, ?e, ?es, _)) {\n+            word_nbsp(s, \"spawn\");\n+            print_expr(s, e);\n+            popen(s);\n+            commasep_exprs(s, inconsistent, es);\n+            pclose(s);\n         }\n-        case (ast::expr_binary(?op,?lhs,?rhs,_)) {\n+        case (ast::expr_binary(?op, ?lhs, ?rhs, _)) {\n             auto prec = operator_prec(op);\n             print_maybe_parens(s, lhs, prec);\n             space(s.s);\n             word_space(s, ast::binop_to_str(op));\n             print_maybe_parens(s, rhs, prec + 1);\n         }\n-        case (ast::expr_unary(?op,?expr,_)) {\n+        case (ast::expr_unary(?op, ?expr, _)) {\n             word(s.s, ast::unop_to_str(op));\n             print_maybe_parens(s, expr, front::parser::unop_prec);\n         }\n-        case (ast::expr_lit(?lit,_)) {\n-            print_literal(s, lit);\n-        }\n-        case (ast::expr_cast(?expr,?ty,_)) {\n+        case (ast::expr_lit(?lit, _)) { print_literal(s, lit); }\n+        case (ast::expr_cast(?expr, ?ty, _)) {\n             print_maybe_parens(s, expr, front::parser::as_prec);\n             space(s.s);\n             word_space(s, \"as\");\n             print_type(s, *ty);\n         }\n-        case (ast::expr_if(?test,?block,?elseopt,_)) {\n-\n+        case (ast::expr_if(?test, ?block, ?elseopt, _)) {\n             head(s, \"if\");\n             popen(s);\n             print_expr(s, test);\n@@ -608,9 +587,10 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                 alt (els) {\n                     case (some(?_else)) {\n                         alt (_else.node) {\n-                            // \"another else-if\"\n-                            case (ast::expr_if(?i,?t,?e,_)) {\n-                                cbox(s, indent_unit-1u);\n+                            case (\n+                                 // \"another else-if\"\n+                                 ast::expr_if(?i, ?t, ?e, _)) {\n+                                cbox(s, indent_unit - 1u);\n                                 ibox(s, 0u);\n                                 word(s.s, \" else if \");\n                                 popen(s);\n@@ -620,29 +600,30 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                                 print_block(s, t);\n                                 do_else(s, e);\n                             }\n-                            // \"final else\"\n-                            case (ast::expr_block(?b, _)) {\n-                                cbox(s, indent_unit-1u);\n+                            case (\n+                                 // \"final else\"\n+                                 ast::expr_block(?b, _)) {\n+                                cbox(s, indent_unit - 1u);\n                                 ibox(s, 0u);\n                                 word(s.s, \" else \");\n                                 print_block(s, b);\n                             }\n                         }\n                     }\n-                    case (_) { /* fall through */ }\n+                    case (_) {/* fall through */ }\n                 }\n             }\n             do_else(s, elseopt);\n         }\n-        case (ast::expr_while(?test,?block,_)) {\n+        case (ast::expr_while(?test, ?block, _)) {\n             head(s, \"while\");\n             popen(s);\n             print_expr(s, test);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast::expr_for(?decl,?expr,?block,_)) {\n+        case (ast::expr_for(?decl, ?expr, ?block, _)) {\n             head(s, \"for\");\n             popen(s);\n             print_for_decl(s, decl);\n@@ -653,7 +634,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast::expr_for_each(?decl,?expr,?block,_)) {\n+        case (ast::expr_for_each(?decl, ?expr, ?block, _)) {\n             head(s, \"for each\");\n             popen(s);\n             print_for_decl(s, decl);\n@@ -664,7 +645,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast::expr_do_while(?block,?expr,_)) {\n+        case (ast::expr_do_while(?block, ?expr, _)) {\n             head(s, \"do\");\n             space(s.s);\n             print_block(s, block);\n@@ -674,7 +655,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_alt(?expr,?arms,_)) {\n+        case (ast::expr_alt(?expr, ?arms, _)) {\n             head(s, \"alt\");\n             popen(s);\n             print_expr(s, expr);\n@@ -698,27 +679,28 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             space(s.s);\n             print_block(s, f.body);\n         }\n-        case (ast::expr_block(?block,_)) {\n+        case (ast::expr_block(?block, _)) {\n             // containing cbox, will be closed by print-block at }\n-            cbox(s, indent_unit);\n \n+            cbox(s, indent_unit);\n             // head-box, will be closed by print-block after {\n+\n             ibox(s, 0u);\n             print_block(s, block);\n         }\n-        case (ast::expr_move(?lhs,?rhs,_)) {\n+        case (ast::expr_move(?lhs, ?rhs, _)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"<-\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_assign(?lhs,?rhs,_)) {\n+        case (ast::expr_assign(?lhs, ?rhs, _)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"=\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_assign_op(?op,?lhs,?rhs,_)) {\n+        case (ast::expr_assign_op(?op, ?lhs, ?rhs, _)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word(s.s, ast::binop_to_str(op));\n@@ -737,74 +719,60 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             word_space(s, \"|>\");\n             print_expr(s, lhs);\n         }\n-        case (ast::expr_field(?expr,?id,_)) {\n+        case (ast::expr_field(?expr, ?id, _)) {\n             print_expr(s, expr);\n             word(s.s, \".\");\n             word(s.s, id);\n         }\n-        case (ast::expr_index(?expr,?index,_)) {\n+        case (ast::expr_index(?expr, ?index, _)) {\n             print_expr(s, expr);\n             word(s.s, \".\");\n             popen(s);\n             print_expr(s, index);\n             pclose(s);\n         }\n-        case (ast::expr_path(?path,_)) {\n-            print_path(s, path);\n-        }\n+        case (ast::expr_path(?path, _)) { print_path(s, path); }\n         case (ast::expr_fail(_, ?str)) {\n             word(s.s, \"fail\");\n             alt (str) {\n-                case (some(?msg)) {\n-                    word(s.s, #fmt(\"\\\"%s\\\"\", msg));\n-                }\n-                case (_) {}\n+                case (some(?msg)) { word(s.s, #fmt(\"\\\"%s\\\"\", msg)); }\n+                case (_) { }\n             }\n         }\n-        case (ast::expr_break(_)) {\n-            word(s.s, \"break\");\n-        }\n-        case (ast::expr_cont(_)) {\n-            word(s.s, \"cont\");\n-        }\n-        case (ast::expr_ret(?result,_)) {\n+        case (ast::expr_break(_)) { word(s.s, \"break\"); }\n+        case (ast::expr_cont(_)) { word(s.s, \"cont\"); }\n+        case (ast::expr_ret(?result, _)) {\n             word(s.s, \"ret\");\n             alt (result) {\n-                case (some(?expr)) {\n-                    word(s.s, \" \");\n-                    print_expr(s, expr);\n-                }\n-                case (_) {}\n+                case (some(?expr)) { word(s.s, \" \"); print_expr(s, expr); }\n+                case (_) { }\n             }\n         }\n-        case (ast::expr_put(?result,_)) {\n+        case (ast::expr_put(?result, _)) {\n             word(s.s, \"put\");\n             alt (result) {\n-                case (some(?expr)) {\n-                    word(s.s, \" \");\n-                    print_expr(s, expr);\n-                }\n-                case (_) {}\n+                case (some(?expr)) { word(s.s, \" \"); print_expr(s, expr); }\n+                case (_) { }\n             }\n         }\n-        case (ast::expr_be(?result,_)) {\n+        case (ast::expr_be(?result, _)) {\n             word_nbsp(s, \"be\");\n             print_expr(s, result);\n         }\n-        case (ast::expr_log(?lvl,?expr,_)) {\n+        case (ast::expr_log(?lvl, ?expr, _)) {\n             alt (lvl) {\n-                case (1) {word_nbsp(s, \"log\");}\n-                case (0) {word_nbsp(s, \"log_err\");}\n+                case (1) { word_nbsp(s, \"log\"); }\n+                case (0) { word_nbsp(s, \"log_err\"); }\n             }\n             print_expr(s, expr);\n         }\n-        case (ast::expr_check(?expr,_)) {\n+        case (ast::expr_check(?expr, _)) {\n             word_nbsp(s, \"check\");\n             popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_assert(?expr,_)) {\n+        case (ast::expr_assert(?expr, _)) {\n             word_nbsp(s, \"assert\");\n             popen(s);\n             print_expr(s, expr);\n@@ -819,28 +787,25 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                 pclose(s);\n             }\n             // FIXME: extension 'body'\n+\n         }\n-        case (ast::expr_port(_)) {\n-            word(s.s, \"port\");\n-            popen(s);\n-            pclose(s);\n-        }\n+        case (ast::expr_port(_)) { word(s.s, \"port\"); popen(s); pclose(s); }\n         case (ast::expr_chan(?expr, _)) {\n             word(s.s, \"chan\");\n             popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-\n-        case (ast::expr_anon_obj(_,_,_,_)) {\n+        case (ast::expr_anon_obj(_, _, _, _)) {\n             word(s.s, \"anon obj\");\n             // TODO: nicer pretty-printing of anon objs\n+\n         }\n     }\n-\n     // Print the type or node ID if necessary.\n+\n     alt (s.mode) {\n-        case (mo_untyped) { /* no-op */ }\n+        case (mo_untyped) {/* no-op */ }\n         case (mo_typed(?tcx)) {\n             space(s.s);\n             word(s.s, \"as\");\n@@ -854,7 +819,6 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             pclose(s);\n         }\n     }\n-\n     end(s);\n }\n \n@@ -875,13 +839,12 @@ fn print_decl(&ps s, &@ast::decl decl) {\n \n                     // Print the type or node ID if necessary.\n                     alt (s.mode) {\n-                        case (mo_untyped) { /* no-op */ }\n+                        case (mo_untyped) {/* no-op */ }\n                         case (mo_typed(?tcx)) {\n-                            auto lty =\n-                                ty::ann_to_type(tcx, loc.ann);\n+                            auto lty = ty::ann_to_type(tcx, loc.ann);\n                             word_space(s, ppaux::ty_to_str(tcx, lty));\n                         }\n-                        case (mo_identified) { /* no-op */ }\n+                        case (mo_identified) {/* no-op */ }\n                     }\n                 }\n             }\n@@ -890,31 +853,21 @@ fn print_decl(&ps s, &@ast::decl decl) {\n                 case (some(?init)) {\n                     space(s.s);\n                     alt (init.op) {\n-                        case (ast::init_assign) {\n-                            word_space(s, \"=\");\n-                        }\n-                        case (ast::init_move) {\n-                            word_space(s, \"<-\");\n-                        }\n-                        case (ast::init_recv) {\n-                            word_space(s, \"|>\");\n-                        }\n+                        case (ast::init_assign) { word_space(s, \"=\"); }\n+                        case (ast::init_move) { word_space(s, \"<-\"); }\n+                        case (ast::init_recv) { word_space(s, \"|>\"); }\n                     }\n                     print_expr(s, init.expr);\n                 }\n-                case (_) {}\n+                case (_) { }\n             }\n             end(s);\n         }\n-        case (ast::decl_item(?item)) {\n-            print_item(s, item);\n-        }\n+        case (ast::decl_item(?item)) { print_item(s, item); }\n     }\n }\n \n-fn print_ident(&ps s, &ast::ident ident) {\n-    word(s.s, ident);\n-}\n+fn print_ident(&ps s, &ast::ident ident) { word(s.s, ident); }\n \n fn print_for_decl(&ps s, @ast::local loc) {\n     print_type(s, *option::get(loc.node.ty));\n@@ -926,8 +879,7 @@ fn print_path(&ps s, &ast::path path) {\n     maybe_print_comment(s, path.span.lo);\n     auto first = true;\n     for (str id in path.node.idents) {\n-        if (first) {first = false;}\n-        else {word(s.s, \"::\");}\n+        if (first) { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n     if (vec::len(path.node.types) > 0u) {\n@@ -940,10 +892,10 @@ fn print_path(&ps s, &ast::path path) {\n fn print_pat(&ps s, &@ast::pat pat) {\n     maybe_print_comment(s, pat.span.lo);\n     alt (pat.node) {\n-        case (ast::pat_wild(_)) {word(s.s, \"_\");}\n-        case (ast::pat_bind(?id,_,_)) {word(s.s, \"?\" + id);}\n-        case (ast::pat_lit(?lit,_)) {print_literal(s, lit);}\n-        case (ast::pat_tag(?path,?args,_)) {\n+        case (ast::pat_wild(_)) { word(s.s, \"_\"); }\n+        case (ast::pat_bind(?id, _, _)) { word(s.s, \"?\" + id); }\n+        case (ast::pat_lit(?lit, _)) { print_literal(s, lit); }\n+        case (ast::pat_tag(?path, ?args, _)) {\n             print_path(s, path);\n             if (vec::len(args) > 0u) {\n                 popen(s);\n@@ -959,7 +911,7 @@ fn print_pat(&ps s, &@ast::pat pat) {\n             space(s.s);\n             synth_comment(s, uint::to_str(ty::pat_ann(pat).id, 10u));\n         }\n-        case (_) { /* no-op */ }\n+        case (_) {/* no-op */ }\n     }\n }\n \n@@ -969,13 +921,9 @@ fn print_fn(&ps s, ast::fn_decl decl, ast::proto proto, str name,\n         case (ast::impure_fn) {\n             if (proto == ast::proto_iter) {\n                 head(s, \"iter\");\n-            } else {\n-                head(s, \"fn\");\n-            }\n-        }\n-        case (_) {\n-            head(s, \"pred\");\n+            } else { head(s, \"fn\"); }\n         }\n+        case (_) { head(s, \"pred\"); }\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n@@ -1006,16 +954,14 @@ fn print_alias(&ps s, ast::mode m) {\n     alt (m) {\n         case (ast::alias(true)) { word_space(s, \"&mutable\"); }\n         case (ast::alias(false)) { word(s.s, \"&\"); }\n-        case (ast::val) {}\n+        case (ast::val) { }\n     }\n }\n \n fn print_type_params(&ps s, &vec[ast::ty_param] params) {\n     if (vec::len(params) > 0u) {\n         word(s.s, \"[\");\n-        fn printParam(&ps s, &ast::ty_param param) {\n-            word(s.s, param);\n-        }\n+        fn printParam(&ps s, &ast::ty_param param) { word(s.s, param); }\n         commasep(s, inconsistent, params, printParam);\n         word(s.s, \"]\");\n     }\n@@ -1033,7 +979,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n     hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n     alt (item.node) {\n-        case (ast::view_item_use(?id,?mta,_,_)) {\n+        case (ast::view_item_use(?id, ?mta, _, _)) {\n             head(s, \"use\");\n             word(s.s, id);\n             if (vec::len(mta) > 0u) {\n@@ -1042,25 +988,23 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n                 pclose(s);\n             }\n         }\n-        case (ast::view_item_import(?id,?ids,_)) {\n+        case (ast::view_item_import(?id, ?ids, _)) {\n             head(s, \"import\");\n-            if (!str::eq(id, ids.(vec::len(ids)-1u))) {\n+            if (!str::eq(id, ids.(vec::len(ids) - 1u))) {\n                 word_space(s, id);\n                 word_space(s, \"=\");\n             }\n             auto first = true;\n             for (str elt in ids) {\n-                if (first) {first = false;}\n-                else {word(s.s, \"::\");}\n+                if (first) { first = false; } else { word(s.s, \"::\"); }\n                 word(s.s, elt);\n             }\n         }\n-        case (ast::view_item_import_glob(?ids,_)) {\n+        case (ast::view_item_import_glob(?ids, _)) {\n             head(s, \"import\");\n             auto first = true;\n             for (str elt in ids) {\n-                if (first) {first = false;}\n-                else {word(s.s, \"::\");}\n+                if (first) { first = false; } else { word(s.s, \"::\"); }\n                 word(s.s, elt);\n             }\n             word(s.s, \"::*\");\n@@ -1072,41 +1016,42 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n     }\n     word(s.s, \";\");\n     end(s); // end inner head-block\n+\n     end(s); // end outer head-block\n+\n }\n \n+\n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n fn operator_prec(ast::binop op) -> int {\n     for (front::parser::op_spec spec in front::parser::prec_table()) {\n-        if (spec.op == op) {ret spec.prec;}\n+        if (spec.op == op) { ret spec.prec; }\n     }\n     fail;\n }\n \n fn print_maybe_parens(&ps s, &@ast::expr expr, int outer_prec) {\n     auto add_them;\n     alt (expr.node) {\n-        case (ast::expr_binary(?op,_,_,_)) {\n+        case (ast::expr_binary(?op, _, _, _)) {\n             add_them = operator_prec(op) < outer_prec;\n         }\n-        case (ast::expr_cast(_,_,_)) {\n+        case (ast::expr_cast(_, _, _)) {\n             add_them = front::parser::as_prec < outer_prec;\n         }\n-        case (_) {\n-            add_them = false;\n-        }\n+        case (_) { add_them = false; }\n     }\n-    if (add_them) {popen(s);}\n+    if (add_them) { popen(s); }\n     print_expr(s, expr);\n-    if (add_them) {pclose(s);}\n+    if (add_them) { pclose(s); }\n }\n \n fn print_mutability(&ps s, &ast::mutability mut) {\n     alt (mut) {\n-        case (ast::mut)       { word_nbsp(s, \"mutable\");  }\n+        case (ast::mut) { word_nbsp(s, \"mutable\"); }\n         case (ast::maybe_mut) { word_nbsp(s, \"mutable?\"); }\n-        case (ast::imm)       { /* nothing */        }\n+        case (ast::imm) {/* nothing */ }\n     }\n }\n \n@@ -1119,14 +1064,12 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n                &vec[ast::ty_arg] inputs, &@ast::ty output,\n                &ast::controlflow cf, &vec[@ast::constr] constrs) {\n     ibox(s, indent_unit);\n-    if (proto == ast::proto_fn) {word(s.s, \"fn\");}\n-    else {word(s.s, \"iter\");}\n+    if (proto == ast::proto_fn) {\n+        word(s.s, \"fn\");\n+    } else { word(s.s, \"iter\"); }\n     alt (id) {\n-        case (some(?id)) {\n-            word(s.s, \" \");\n-            word(s.s, id);\n-        }\n-        case (_) {}\n+        case (some(?id)) { word(s.s, \" \"); word(s.s, id); }\n+        case (_) { }\n     }\n     zerobreak(s.s);\n     popen(s);\n@@ -1142,12 +1085,8 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n         ibox(s, indent_unit);\n         word_space(s, \"->\");\n         alt (cf) {\n-            case (ast::return) {\n-                print_type(s, *output);\n-            }\n-            case (ast::noreturn) {\n-                word_nbsp(s, \"!\");\n-            }\n+            case (ast::return) { print_type(s, *output); }\n+            case (ast::noreturn) { word_nbsp(s, \"!\"); }\n         }\n         end(s);\n     }\n@@ -1158,50 +1097,37 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n fn maybe_print_trailing_comment(&ps s, common::span span,\n                                 option::t[uint] next_pos) {\n     auto cm;\n-    alt (s.cm) {\n-        case (some(?ccm)) {\n-            cm = ccm;\n-        }\n-        case (_) { ret; }\n-    }\n+    alt (s.cm) { case (some(?ccm)) { cm = ccm; } case (_) { ret; } }\n     alt (next_comment(s)) {\n         case (some(?cmnt)) {\n             if (cmnt.style != lexer::trailing) { ret; }\n-\n             auto span_line = codemap::lookup_pos(cm, span.hi);\n             auto comment_line = codemap::lookup_pos(cm, cmnt.pos);\n             auto next = cmnt.pos + 1u;\n-            alt (next_pos) {\n-                case (none) { }\n-                case (some(?p)) { next = p; }\n-            }\n-            if (span.hi < cmnt.pos &&\n-                cmnt.pos < next &&\n-                span_line.line == comment_line.line) {\n+            alt (next_pos) { case (none) { } case (some(?p)) { next = p; } }\n+            if (span.hi < cmnt.pos && cmnt.pos < next &&\n+                    span_line.line == comment_line.line) {\n                 print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n             }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n }\n \n fn print_remaining_comments(&ps s) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (some(?cmnt)) {\n-                print_comment(s, cmnt);\n-                s.cur_cmnt += 1u;\n-            }\n-            case (_) {break;}\n+            case (some(?cmnt)) { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n+            case (_) { break; }\n         }\n     }\n }\n \n fn in_cbox(&ps s) -> bool {\n     auto len = vec::len(s.boxes);\n     if (len == 0u) { ret false; }\n-    ret s.boxes.(len-1u) == pp::consistent;\n+    ret s.boxes.(len - 1u) == pp::consistent;\n }\n //\n // Local Variables:"}, {"sha": "d52d16960506671810bb1dc900c2dc49b47e1a3c", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 73, "deletions": 128, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n import std::map;\n import std::map::hashmap;\n import std::uint;\n@@ -12,7 +13,6 @@ import front::codemap::codemap;\n import front::ast::lit;\n import front::ast::path;\n import middle::walk;\n-\n import std::io::stdout;\n import std::io::str_writer;\n import std::io::string_writer;\n@@ -28,51 +28,47 @@ import pretty::ppaux::mo_untyped;\n import pretty::pp::mk_printer;\n \n type filename = str;\n+\n type span = rec(uint lo, uint hi);\n+\n type spanned[T] = rec(T node, span span);\n+\n type flag = hashmap[str, ()];\n \n tag ty_mach {\n     ty_i8;\n     ty_i16;\n     ty_i32;\n     ty_i64;\n-\n     ty_u8;\n     ty_u16;\n     ty_u32;\n     ty_u64;\n-\n     ty_f32;\n     ty_f64;\n }\n \n-tag ty_or_bang[T] {\n-    a_ty(T);\n-    a_bang;\n-}\n+tag ty_or_bang[T] { a_ty(T); a_bang; }\n \n fn ty_mach_to_str(ty_mach tm) -> str {\n     alt (tm) {\n         case (ty_u8) { ret \"u8\"; }\n         case (ty_u16) { ret \"u16\"; }\n         case (ty_u32) { ret \"u32\"; }\n         case (ty_u64) { ret \"u64\"; }\n-\n         case (ty_i8) { ret \"i8\"; }\n         case (ty_i16) { ret \"i16\"; }\n         case (ty_i32) { ret \"i32\"; }\n         case (ty_i64) { ret \"i64\"; }\n-\n         case (ty_f32) { ret \"f32\"; }\n         case (ty_f64) { ret \"f64\"; }\n     }\n }\n \n-fn new_str_hash[V]() -> std::map::hashmap[str,V] {\n+fn new_str_hash[V]() -> std::map::hashmap[str, V] {\n     let std::map::hashfn[str] hasher = std::str::hash;\n     let std::map::eqfn[str] eqer = std::str::eq;\n-    ret std::map::mk_hashmap[str,V](hasher, eqer);\n+    ret std::map::mk_hashmap[str, V](hasher, eqer);\n }\n \n fn def_eq(&ast::def_id a, &ast::def_id b) -> bool {\n@@ -81,40 +77,36 @@ fn def_eq(&ast::def_id a, &ast::def_id b) -> bool {\n \n fn hash_def(&ast::def_id d) -> uint {\n     auto h = 5381u;\n-    h = ((h << 5u) + h) ^ (d._0 as uint);\n-    h = ((h << 5u) + h) ^ (d._1 as uint);\n+    h = (h << 5u) + h ^ (d._0 as uint);\n+    h = (h << 5u) + h ^ (d._1 as uint);\n     ret h;\n }\n \n-fn new_def_hash[V]() -> std::map::hashmap[ast::def_id,V] {\n+fn new_def_hash[V]() -> std::map::hashmap[ast::def_id, V] {\n     let std::map::hashfn[ast::def_id] hasher = hash_def;\n     let std::map::eqfn[ast::def_id] eqer = def_eq;\n-    ret std::map::mk_hashmap[ast::def_id,V](hasher, eqer);\n+    ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);\n }\n \n-fn new_int_hash[V]() -> std::map::hashmap[int,V] {\n+fn new_int_hash[V]() -> std::map::hashmap[int, V] {\n     fn hash_int(&int x) -> uint { ret x as uint; }\n     fn eq_int(&int a, &int b) -> bool { ret a == b; }\n     auto hasher = hash_int;\n     auto eqer = eq_int;\n-    ret std::map::mk_hashmap[int,V](hasher, eqer);\n+    ret std::map::mk_hashmap[int, V](hasher, eqer);\n }\n \n-fn new_uint_hash[V]() -> std::map::hashmap[uint,V] {\n+fn new_uint_hash[V]() -> std::map::hashmap[uint, V] {\n     fn hash_uint(&uint x) -> uint { ret x; }\n     fn eq_uint(&uint a, &uint b) -> bool { ret a == b; }\n     auto hasher = hash_uint;\n     auto eqer = eq_uint;\n-    ret std::map::mk_hashmap[uint,V](hasher, eqer);\n+    ret std::map::mk_hashmap[uint, V](hasher, eqer);\n }\n \n-fn istr(int i) -> str {\n-    ret int::to_str(i, 10u);\n-}\n+fn istr(int i) -> str { ret int::to_str(i, 10u); }\n \n-fn uistr(uint i) -> str {\n-    ret uint::to_str(i, 10u);\n-}\n+fn uistr(uint i) -> str { ret uint::to_str(i, 10u); }\n \n fn elt_expr(&ast::elt e) -> @ast::expr { ret e.expr; }\n \n@@ -125,101 +117,69 @@ fn elt_exprs(&vec[ast::elt] elts) -> vec[@ast::expr] {\n \n fn field_expr(&ast::field f) -> @ast::expr { ret f.node.expr; }\n \n-fn field_exprs(vec[ast::field] fields) -> vec [@ast::expr] {\n+fn field_exprs(vec[ast::field] fields) -> vec[@ast::expr] {\n     auto f = field_expr;\n     ret vec::map[ast::field, @ast::expr](f, fields);\n }\n \n-fn log_expr(&ast::expr e) -> () {\n-    log(pretty::pprust::expr_to_str(@e));\n-}\n+fn log_expr(&ast::expr e) { log pretty::pprust::expr_to_str(@e); }\n \n-fn log_expr_err(&ast::expr e) -> () {\n-    log_err(pretty::pprust::expr_to_str(@e));\n-}\n+fn log_expr_err(&ast::expr e) { log_err pretty::pprust::expr_to_str(@e); }\n \n-fn log_ty_err(&ty t) -> () {\n-    log_err(pretty::pprust::ty_to_str(t));\n-}\n+fn log_ty_err(&ty t) { log_err pretty::pprust::ty_to_str(t); }\n \n-fn log_pat_err(&@pat p) -> () {\n-    log_err(pretty::pprust::pat_to_str(p));\n-}\n+fn log_pat_err(&@pat p) { log_err pretty::pprust::pat_to_str(p); }\n \n-fn log_block(&ast::block b) -> () {\n-    log(pretty::pprust::block_to_str(b));\n-}\n+fn log_block(&ast::block b) { log pretty::pprust::block_to_str(b); }\n \n-fn log_block_err(&ast::block b) -> () {\n-    log_err(pretty::pprust::block_to_str(b));\n-}\n+fn log_block_err(&ast::block b) { log_err pretty::pprust::block_to_str(b); }\n \n-fn log_item_err(&@ast::item i) -> () {\n-    log_err(pretty::pprust::item_to_str(i));\n-}\n+fn log_item_err(&@ast::item i) { log_err pretty::pprust::item_to_str(i); }\n \n-fn log_fn(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n-    log(pretty::pprust::fun_to_str(f, name, params));\n+fn log_fn(&ast::_fn f, str name, vec[ast::ty_param] params) {\n+    log pretty::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n-    log_err(pretty::pprust::fun_to_str(f, name, params));\n+fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) {\n+    log_err pretty::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_stmt(&ast::stmt st) -> () {\n-    log(pretty::pprust::stmt_to_str(st));\n-}\n+fn log_stmt(&ast::stmt st) { log pretty::pprust::stmt_to_str(st); }\n \n-fn log_stmt_err(&ast::stmt st) -> () {\n-    log_err(pretty::pprust::stmt_to_str(st));\n-}\n+fn log_stmt_err(&ast::stmt st) { log_err pretty::pprust::stmt_to_str(st); }\n \n fn decl_lhs(@ast::decl d) -> ast::def_id {\n     alt (d.node) {\n-        case (ast::decl_local(?l)) {\n-            ret l.id;\n-        }\n+        case (ast::decl_local(?l)) { ret l.id; }\n         case (ast::decl_item(?an_item)) {\n             alt (an_item.node) {\n-                case (ast::item_const(_,_,_,_,?d,_)) {\n-                    ret d;\n-                }\n-                case (ast::item_fn(_,_,_,_,?d,_)) {\n-                    ret d;\n-                }\n-                case (ast::item_mod(_,_,_,?d)) {\n-                    ret d;\n-                }\n-                case (ast::item_native_mod(_,_,_,?d)) {\n-                    ret d;\n-                }\n-                case (ast::item_ty(_,_,_,_,?d,_)) {\n-                    ret d;\n-                }\n-                case (ast::item_tag(_,_,_,_,?d,_)) {\n-                    ret d;\n-                }\n-                case (ast::item_obj(_,_,_,_,?d,_)) {\n+                case (ast::item_const(_, _, _, _, ?d, _)) { ret d; }\n+                case (ast::item_fn(_, _, _, _, ?d, _)) { ret d; }\n+                case (ast::item_mod(_, _, _, ?d)) { ret d; }\n+                case (ast::item_native_mod(_, _, _, ?d)) { ret d; }\n+                case (ast::item_ty(_, _, _, _, ?d, _)) { ret d; }\n+                case (ast::item_tag(_, _, _, _, ?d, _)) { ret d; }\n+                case (ast::item_obj(_, _, _, _, ?d, _)) {\n                     ret d.ctor; /* This doesn't really make sense */\n+\n                 }\n             }\n         }\n     }\n }\n \n fn has_nonlocal_exits(&ast::block b) -> bool {\n-   auto has_exits = @mutable false;\n-\n-   fn visit_expr(@mutable bool flag, &@ast::expr e) {\n-       alt (e.node) {\n-           case (ast::expr_break(_)) { *flag = true; }\n-           case (ast::expr_cont(_)) { *flag = true; }\n-           case (_) { }\n-       }\n-   }\n-\n-    auto v = rec(visit_expr_pre=bind visit_expr(has_exits, _)\n-                 with walk::default_visitor());\n+    auto has_exits = @mutable false;\n+    fn visit_expr(@mutable bool flag, &@ast::expr e) {\n+        alt (e.node) {\n+            case (ast::expr_break(_)) { *flag = true; }\n+            case (ast::expr_cont(_)) { *flag = true; }\n+            case (_) { }\n+        }\n+    }\n+    auto v =\n+        rec(visit_expr_pre=bind visit_expr(has_exits, _)\n+            with walk::default_visitor());\n     walk::walk_block(v, b);\n     ret *has_exits;\n }\n@@ -233,100 +193,85 @@ fn local_rhs_span(&@ast::local_ l, &span def) -> span {\n \n fn lit_eq(&@ast::lit l, &@ast::lit m) -> bool {\n     alt (l.node) {\n-        case (ast::lit_str(?s,?kind_s)) {\n+        case (ast::lit_str(?s, ?kind_s)) {\n             alt (m.node) {\n-                case (ast::lit_str(?t,?kind_t)) {\n+                case (ast::lit_str(?t, ?kind_t)) {\n                     ret s == t && kind_s == kind_t;\n                 }\n-                case (_)           { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_char(?c)) {\n             alt (m.node) {\n                 case (ast::lit_char(?d)) { ret c == d; }\n-                case (_)           { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_int(?i)) {\n             alt (m.node) {\n                 case (ast::lit_int(?j)) { ret i == j; }\n-                case (_)           { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_uint(?i)) {\n             alt (m.node) {\n                 case (ast::lit_uint(?j)) { ret i == j; }\n-                case (_)            { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_mach_int(_, ?i)) {\n             alt (m.node) {\n                 case (ast::lit_mach_int(_, ?j)) { ret i == j; }\n-                case (_)                    { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_float(?s)) {\n             alt (m.node) {\n                 case (ast::lit_float(?t)) { ret s == t; }\n-                case (_)             { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n-        case (ast::lit_mach_float(_,?s)) {\n+        case (ast::lit_mach_float(_, ?s)) {\n             alt (m.node) {\n-                case (ast::lit_mach_float(_,?t)) { ret s == t; }\n-                case (_)               { ret false; }\n+                case (ast::lit_mach_float(_, ?t)) { ret s == t; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_nil) {\n             alt (m.node) {\n                 case (ast::lit_nil) { ret true; }\n-                case (_)       { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n         case (ast::lit_bool(?b)) {\n             alt (m.node) {\n                 case (ast::lit_bool(?c)) { ret b == c; }\n-                case (_)            { ret false; }\n+                case (_) { ret false; }\n             }\n         }\n     }\n }\n \n-fn respan[T](&span sp, &T t) -> spanned[T] {\n-    ret rec(node=t, span=sp);\n-}\n+fn respan[T](&span sp, &T t) -> spanned[T] { ret rec(node=t, span=sp); }\n \n-fn may_begin_ident(char c) -> bool {\n-    ret (is_alpha(c) || c == '_');\n-}\n+fn may_begin_ident(char c) -> bool { ret is_alpha(c) || c == '_'; }\n \n-fn in_range(char c, char lo, char hi) -> bool {\n-    ret lo <= c && c <= hi;\n-}\n+fn in_range(char c, char lo, char hi) -> bool { ret lo <= c && c <= hi; }\n \n fn is_alpha(char c) -> bool {\n-    ret in_range(c, 'a', 'z') ||\n-        in_range(c, 'A', 'Z');\n+    ret in_range(c, 'a', 'z') || in_range(c, 'A', 'Z');\n }\n \n-fn is_dec_digit(char c) -> bool {\n-    ret in_range(c, '0', '9');\n-}\n+fn is_dec_digit(char c) -> bool { ret in_range(c, '0', '9'); }\n \n-fn is_alnum(char c) -> bool {\n-    ret is_alpha(c) || is_dec_digit(c);\n-}\n+fn is_alnum(char c) -> bool { ret is_alpha(c) || is_dec_digit(c); }\n \n fn is_hex_digit(char c) -> bool {\n-    ret in_range(c, '0', '9') ||\n-        in_range(c, 'a', 'f') ||\n-        in_range(c, 'A', 'F');\n-}\n-\n-fn is_bin_digit(char c) -> bool {\n-    ret c == '0' || c == '1';\n+    ret in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n+            in_range(c, 'A', 'F');\n }\n \n+fn is_bin_digit(char c) -> bool { ret c == '0' || c == '1'; }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "78dae38a42605ac04c7806d3932474eef596e504", "filename": "src/comp/util/data.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Futil%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Fcomp%2Futil%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fdata.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,7 +1,8 @@\n+\n+\n // An \"interner\" is a data structure that associates values with uint tags and\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n-\n import std::vec;\n import std::map;\n import std::map::hashmap;\n@@ -12,19 +13,17 @@ import std::option::none;\n import std::option::some;\n \n mod interner {\n-    type interner[T] = rec(\n-        hashmap[T,uint] map,\n-        mutable vec[T] vect,\n-        hashfn[T] hasher,\n-        eqfn[T] eqer\n-    );\n+    type interner[T] =\n+        rec(hashmap[T, uint] map,\n+            mutable vec[T] vect,\n+            hashfn[T] hasher,\n+            eqfn[T] eqer);\n \n     fn mk[T](hashfn[T] hasher, eqfn[T] eqer) -> interner[T] {\n-        auto m = map::mk_hashmap[T,uint](hasher, eqer);\n+        auto m = map::mk_hashmap[T, uint](hasher, eqer);\n         let vec[T] vect = [];\n         ret rec(map=m, mutable vect=vect, hasher=hasher, eqer=eqer);\n     }\n-\n     fn intern[T](&interner[T] itr, &T val) -> uint {\n         alt (itr.map.find(val)) {\n             case (some(?idx)) { ret idx; }\n@@ -36,9 +35,5 @@ mod interner {\n             }\n         }\n     }\n-\n-    fn get[T](&interner[T] itr, uint idx) -> T {\n-        ret itr.vect.(idx);\n-    }\n-}\n-\n+    fn get[T](&interner[T] itr, uint idx) -> T { ret itr.vect.(idx); }\n+}\n\\ No newline at end of file"}, {"sha": "c9bb5e1d480bd0abac30a2e7afe0e4fa54a0faf9", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 30, "deletions": 84, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,4 @@\n+\n export t;\n export create;\n export union;\n@@ -17,105 +18,79 @@ export to_vec;\n export to_str;\n export eq_vec;\n \n+\n // FIXME: With recursive object types, we could implement binary methods like\n //        union, intersection, and difference. At that point, we could write\n //        an optimizing version of this module that produces a different obj\n //        for the case where nbits <= 32.\n \n // FIXME: Almost all the functions in this module should be state fns, but the\n //        effect system isn't currently working correctly.\n-state type t = rec(vec[mutable uint] storage, uint nbits);\n+type t = rec(vec[mutable uint] storage, uint nbits);\n+\n \n // FIXME: this should be a constant once they work\n-fn uint_bits() -> uint {\n-    ret 32u + ((1u << 32u) >> 27u);\n-}\n+fn uint_bits() -> uint { ret 32u + (1u << 32u >> 27u); }\n \n fn create(uint nbits, bool init) -> t {\n     auto elt = if (init) { !0u } else { 0u };\n-\n     auto storage = vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n-    ret rec(storage = storage, nbits = nbits);\n+    ret rec(storage=storage, nbits=nbits);\n }\n \n-fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n+fn process(&fn(uint, uint) -> uint  op, &t v0, &t v1) -> bool {\n     auto len = vec::len(v1.storage);\n-\n     assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n-\n     auto changed = false;\n-\n     for each (uint i in uint::range(0u, len)) {\n         auto w0 = v0.storage.(i);\n         auto w1 = v1.storage.(i);\n-\n         auto w = op(w0, w1);\n-        if (w0 != w) {\n-            changed = true;\n-            v0.storage.(i) = w;\n-        }\n+        if (w0 != w) { changed = true; v0.storage.(i) = w; }\n     }\n-\n     ret changed;\n }\n \n-fn lor(uint w0, uint w1) -> uint {\n-    ret w0 | w1;\n-}\n+fn lor(uint w0, uint w1) -> uint { ret w0 | w1; }\n \n-fn union(&t v0, &t v1) -> bool {\n-    auto sub = lor;\n-    ret process(sub, v0, v1);\n-}\n+fn union(&t v0, &t v1) -> bool { auto sub = lor; ret process(sub, v0, v1); }\n \n-fn land(uint w0, uint w1) -> uint {\n-    ret w0 & w1;\n-}\n+fn land(uint w0, uint w1) -> uint { ret w0 & w1; }\n \n fn intersect(&t v0, &t v1) -> bool {\n     auto sub = land;\n     ret process(sub, v0, v1);\n }\n \n-fn right(uint w0, uint w1) -> uint {\n-    ret w1;\n-}\n+fn right(uint w0, uint w1) -> uint { ret w1; }\n \n-fn copy(&t v0, t v1) -> bool {\n-    auto sub = right;\n-    ret process(sub, v0, v1);\n-}\n+fn copy(&t v0, t v1) -> bool { auto sub = right; ret process(sub, v0, v1); }\n \n fn clone(t v) -> t {\n     auto storage = vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n     auto len = vec::len(v.storage);\n-    for each (uint i in uint::range(0u, len)) {\n-        storage.(i) = v.storage.(i);\n-    }\n-    ret rec(storage = storage, nbits = v.nbits);\n+    for each (uint i in uint::range(0u, len)) { storage.(i) = v.storage.(i); }\n+    ret rec(storage=storage, nbits=v.nbits);\n }\n \n fn get(&t v, uint i) -> bool {\n     assert (i < v.nbits);\n-\n     auto bits = uint_bits();\n-\n     auto w = i / bits;\n     auto b = i % bits;\n-    auto x = 1u & (v.storage.(w) >> b);\n+    auto x = 1u & v.storage.(w) >> b;\n     ret x == 1u;\n }\n \n fn equal(&t v0, &t v1) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n+\n     auto len = vec::len(v1.storage);\n     auto i = 0u;\n     while (i < len) {\n-        if (v0.storage.(i) != v1.storage.(i)) {\n-            ret false;\n-        }\n+        if (v0.storage.(i) != v1.storage.(i)) { ret false; }\n         i = i + 1u;\n     }\n     ret true;\n@@ -128,9 +103,7 @@ fn clear(&t v) {\n }\n \n fn set_all(&t v) {\n-    for each (uint i in uint::range(0u, v.nbits)) {\n-        set(v, i, true);\n-    }\n+    for each (uint i in uint::range(0u, v.nbits)) { set(v, i, true); }\n }\n \n fn invert(&t v) {\n@@ -139,6 +112,7 @@ fn invert(&t v) {\n     }\n }\n \n+\n /* v0 = v0 - v1 */\n fn difference(&t v0, &t v1) -> bool {\n     invert(v1);\n@@ -149,49 +123,30 @@ fn difference(&t v0, &t v1) -> bool {\n \n fn set(&t v, uint i, bool x) {\n     assert (i < v.nbits);\n-\n     auto bits = uint_bits();\n-\n     auto w = i / bits;\n     auto b = i % bits;\n     auto w0 = v.storage.(w);\n     auto flag = 1u << b;\n-    v.storage.(w) = if (x) {\n-        v.storage.(w) | flag\n-    } else {\n-        v.storage.(w) & !flag\n-    };\n+    v.storage.(w) =\n+        if (x) { v.storage.(w) | flag } else { v.storage.(w) & !flag };\n }\n \n+\n /* true if all bits are 1 */\n fn is_true(&t v) -> bool {\n-    for (uint i in to_vec(v)) {\n-        if (i != 1u) {\n-            ret false;\n-        }\n-    }\n-\n+    for (uint i in to_vec(v)) { if (i != 1u) { ret false; } }\n     ret true;\n }\n \n+\n /* true if all bits are non-1 */\n fn is_false(&t v) -> bool {\n-    for (uint i in to_vec(v)) {\n-        if (i == 1u) {\n-            ret false;\n-        }\n-    }\n-\n+    for (uint i in to_vec(v)) { if (i == 1u) { ret false; } }\n     ret true;\n }\n \n-fn init_to_vec(t v, uint i) -> uint {\n-    ret if (get(v, i)) {\n-        1u\n-    } else {\n-        0u\n-    };\n-}\n+fn init_to_vec(t v, uint i) -> uint { ret if (get(v, i)) { 1u } else { 0u }; }\n \n fn to_vec(&t v) -> vec[uint] {\n     auto sub = bind init_to_vec(v, _);\n@@ -200,19 +155,13 @@ fn to_vec(&t v) -> vec[uint] {\n \n fn to_str(&t v) -> str {\n     auto res = \"\";\n-\n     for (uint i in bitv::to_vec(v)) {\n-        if (i == 1u) {\n-            res += \"1\";\n-        }\n-        else {\n-            res += \"0\";\n-        }\n+        if (i == 1u) { res += \"1\"; } else { res += \"0\"; }\n     }\n-\n     ret res;\n }\n \n+\n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n     assert (v0.nbits == vec::len[uint](v1));\n@@ -221,14 +170,11 @@ fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n     while (i < len) {\n         auto w0 = get(v0, i);\n         auto w1 = v1.(i);\n-        if ((!w0 && w1 != 0u) || (w0 && w1 == 0u)) {\n-            ret false;\n-        }\n+        if (!w0 && w1 != 0u || w0 && w1 == 0u) { ret false; }\n         i = i + 1u;\n     }\n     ret true;\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0435c40f47441df18d7372b0412d5a5abc34fb78", "filename": "src/lib/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbox.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,8 +1,8 @@\n+\n export ptr_eq;\n \n native \"rust\" mod rustrt {\n     fn rust_ptr_eq[T](@T a, @T b) -> int;\n }\n \n-fn ptr_eq[T](@T a, @T b) -> bool { ret rustrt::rust_ptr_eq[T](a, b) != 0; }\n-\n+fn ptr_eq[T](@T a, @T b) -> bool { ret rustrt::rust_ptr_eq[T](a, b) != 0; }\n\\ No newline at end of file"}, {"sha": "7c00cd280490526a391765f6d5984fda95cc521f", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,6 @@\n+\n+\n+\n /**\n  * Unsafe debugging functions for inspecting values.\n  *\n@@ -19,25 +22,16 @@ native \"rust\" mod rustrt {\n     fn debug_trap(str msg);\n }\n \n-fn debug_vec[T](vec[T] v) {\n-    vec::print_debug_info[T](v);\n-}\n+fn debug_vec[T](vec[T] v) { vec::print_debug_info[T](v); }\n \n-fn debug_tydesc[T]() {\n-    rustrt::debug_tydesc[T]();\n-}\n+fn debug_tydesc[T]() { rustrt::debug_tydesc[T](); }\n \n-fn debug_opaque[T](&T x) {\n-    rustrt::debug_opaque[T](x);\n-}\n+fn debug_opaque[T](&T x) { rustrt::debug_opaque[T](x); }\n \n-fn debug_box[T](@T x) {\n-    rustrt::debug_box[T](x);\n-}\n+fn debug_box[T](@T x) { rustrt::debug_box[T](x); }\n+\n+fn debug_tag[T](&T x) { rustrt::debug_tag[T](x); }\n \n-fn debug_tag[T](&T x) {\n-    rustrt::debug_tag[T](x);\n-}\n \n /**\n  * `nmethods` is the number of methods we expect the object to have.  The\n@@ -52,18 +46,11 @@ fn debug_obj[T](&T x, uint nmethods, uint nbytes) {\n     rustrt::debug_obj[T](x, nmethods, nbytes);\n }\n \n-fn debug_fn[T](&T x) {\n-    rustrt::debug_fn[T](x);\n-}\n-\n-fn ptr_cast[T, U](@T x) -> @U {\n-    ret rustrt::debug_ptrcast[T, U](x);\n-}\n+fn debug_fn[T](&T x) { rustrt::debug_fn[T](x); }\n \n-fn trap(str s) {\n-    rustrt::debug_trap(s);\n-}\n+fn ptr_cast[T, U](@T x) -> @U { ret rustrt::debug_ptrcast[T, U](x); }\n \n+fn trap(str s) { rustrt::debug_trap(s); }\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "ca9cda954a5591443703ea2e84ae821053965b19", "filename": "src/lib/deque.rs", "status": "modified", "additions": 79, "deletions": 109, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,142 +1,112 @@\n-/**\n- * A deque, for fun.  Untested as of yet.  Likely buggy.\n- */\n-\n-type t[T] = obj {\n-            fn size() -> uint;\n-\n-            fn add_front(&T t);\n-            fn add_back(&T t);\n \n-            fn pop_front() -> T;\n-            fn pop_back() -> T;\n \n-            fn peek_front() -> T;\n-            fn peek_back() -> T;\n \n-            fn get(int i) -> T;\n-};\n+/**\n+ * A deque, for fun.  Untested as of yet.  Likely buggy.\n+ */\n+type t[T] =\n+    obj {\n+        fn size() -> uint ;\n+        fn add_front(&T) ;\n+        fn add_back(&T) ;\n+        fn pop_front() -> T ;\n+        fn pop_back() -> T ;\n+        fn peek_front() -> T ;\n+        fn peek_back() -> T ;\n+        fn get(int) -> T ;\n+    };\n \n fn create[T]() -> t[T] {\n-\n     type cell[T] = option::t[T];\n \n     let uint initial_capacity = 32u; // 2^5\n+     /**\n+      * Grow is only called on full elts, so nelts is also len(elts), unlike\n+      * elsewhere.\n+      */\n \n-    /**\n-     * Grow is only called on full elts, so nelts is also len(elts), unlike\n-     * elsewhere.\n-     */\n-    fn grow[T](uint nelts, uint lo, vec[mutable cell[T]] elts)\n-        -> vec[mutable cell[T]] {\n+    fn grow[T](uint nelts, uint lo, vec[mutable cell[T]] elts) ->\n+       vec[mutable cell[T]] {\n         assert (nelts == vec::len(elts));\n-\n         // FIXME: Making the vector argument an alias is a workaround for\n         // issue #375\n-        fn fill[T](uint i, uint nelts, uint lo,\n-                   &vec[mutable cell[T]] old) -> cell[T] {\n+\n+        fn fill[T](uint i, uint nelts, uint lo, &vec[mutable cell[T]] old) ->\n+           cell[T] {\n             ret if (i < nelts) {\n-                old.((lo + i) % nelts)\n-            } else {\n-                option::none\n-            };\n+                    old.((lo + i) % nelts)\n+                } else { option::none };\n         }\n-\n         let uint nalloc = uint::next_power_of_two(nelts + 1u);\n         let vec::init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n         ret vec::init_fn_mut[cell[T]](copy_op, nalloc);\n     }\n-\n     fn get[T](vec[mutable cell[T]] elts, uint i) -> T {\n         ret alt (elts.(i)) {\n-            case (option::some(?t)) { t }\n-            case (_) { fail }\n-        };\n+                case (option::some(?t)) { t }\n+                case (_) { fail }\n+            };\n     }\n-\n     obj deque[T](mutable uint nelts,\n                  mutable uint lo,\n                  mutable uint hi,\n-                 mutable vec[mutable cell[T]] elts)\n-        {\n-            fn size() -> uint { ret nelts; }\n-\n-            fn add_front(&T t) {\n-                let uint oldlo = lo;\n-\n-                if (lo == 0u) {\n-                    lo = vec::len[cell[T]](elts) - 1u;\n-                } else {\n-                    lo -= 1u;\n-                }\n-\n-                if (lo == hi) {\n-                    elts = grow[T](nelts, oldlo, elts);\n-                    lo = vec::len[cell[T]](elts) - 1u;\n-                    hi = nelts;\n-                }\n-\n-                elts.(lo) = option::some[T](t);\n-                nelts += 1u;\n+                 mutable vec[mutable cell[T]] elts) {\n+        fn size() -> uint { ret nelts; }\n+        fn add_front(&T t) {\n+            let uint oldlo = lo;\n+            if (lo == 0u) {\n+                lo = vec::len[cell[T]](elts) - 1u;\n+            } else { lo -= 1u; }\n+            if (lo == hi) {\n+                elts = grow[T](nelts, oldlo, elts);\n+                lo = vec::len[cell[T]](elts) - 1u;\n+                hi = nelts;\n             }\n-\n-            fn add_back(&T t) {\n-                if (lo == hi && nelts != 0u) {\n-                    elts = grow[T](nelts, lo, elts);\n-                    lo = 0u;\n-                    hi = nelts;\n-                }\n-\n-                elts.(hi) = option::some[T](t);\n-                hi = (hi + 1u) % vec::len[cell[T]](elts);\n-                nelts += 1u;\n-            }\n-\n-            /**\n-             * We actually release (turn to none()) the T we're popping so\n-             * that we don't keep anyone's refcount up unexpectedly.\n-             */\n-            fn pop_front() -> T {\n-                let T t = get[T](elts, lo);\n-                elts.(lo) = option::none[T];\n-                lo = (lo + 1u) % vec::len[cell[T]](elts);\n-                nelts -= 1u;\n-                ret t;\n-            }\n-\n-            fn pop_back() -> T {\n-                if (hi == 0u) {\n-                    hi = vec::len[cell[T]](elts) - 1u;\n-                } else {\n-                    hi -= 1u;\n-                }\n-\n-                let T t = get[T](elts, hi);\n-                elts.(hi) = option::none[T];\n-                nelts -= 1u;\n-                ret t;\n-            }\n-\n-            fn peek_front() -> T {\n-                ret get[T](elts, lo);\n-            }\n-\n-            fn peek_back() -> T {\n-                ret get[T](elts, hi - 1u);\n-            }\n-\n-            fn get(int i) -> T {\n-                let uint idx = (lo + (i as uint)) % vec::len[cell[T]](elts);\n-                ret get[T](elts, idx);\n+            elts.(lo) = option::some[T](t);\n+            nelts += 1u;\n+        }\n+        fn add_back(&T t) {\n+            if (lo == hi && nelts != 0u) {\n+                elts = grow[T](nelts, lo, elts);\n+                lo = 0u;\n+                hi = nelts;\n             }\n-\n+            elts.(hi) = option::some[T](t);\n+            hi = (hi + 1u) % vec::len[cell[T]](elts);\n+            nelts += 1u;\n         }\n-    let vec[mutable cell[T]] v = vec::init_elt_mut(option::none,\n-                                                   initial_capacity);\n \n+        /**\n+         * We actually release (turn to none()) the T we're popping so\n+         * that we don't keep anyone's refcount up unexpectedly.\n+         */\n+        fn pop_front() -> T {\n+            let T t = get[T](elts, lo);\n+            elts.(lo) = option::none[T];\n+            lo = (lo + 1u) % vec::len[cell[T]](elts);\n+            nelts -= 1u;\n+            ret t;\n+        }\n+        fn pop_back() -> T {\n+            if (hi == 0u) {\n+                hi = vec::len[cell[T]](elts) - 1u;\n+            } else { hi -= 1u; }\n+            let T t = get[T](elts, hi);\n+            elts.(hi) = option::none[T];\n+            nelts -= 1u;\n+            ret t;\n+        }\n+        fn peek_front() -> T { ret get[T](elts, lo); }\n+        fn peek_back() -> T { ret get[T](elts, hi - 1u); }\n+        fn get(int i) -> T {\n+            let uint idx = (lo + (i as uint)) % vec::len[cell[T]](elts);\n+            ret get[T](elts, idx);\n+        }\n+    }\n+    let vec[mutable cell[T]] v =\n+        vec::init_elt_mut(option::none, initial_capacity);\n     ret deque[T](0u, 0u, 0u, v);\n }\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "47613cce28c8ec7e1cc2eb225c0791cd1575bc80", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 35, "deletions": 49, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,40 +1,38 @@\n+\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n-\n import option::none;\n import option::some;\n \n type ebml_tag = rec(uint id, uint size);\n+\n type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n \n+\n // TODO: When we have module renaming, make \"reader\" and \"writer\" separate\n // modules within this file.\n \n // ebml reading\n-\n-type doc = rec(vec[u8] data,\n-               uint start,\n-               uint end);\n+type doc = rec(vec[u8] data, uint start, uint end);\n \n fn vint_at(vec[u8] data, uint start) -> tup(uint, uint) {\n     auto a = data.(start);\n-    if (a & 0x80u8 != 0u8) { ret tup((a & 0x7fu8) as uint, start + 1u); }\n+    if (a & 0x80u8 != 0u8) { ret tup(a & 0x7fu8 as uint, start + 1u); }\n     if (a & 0x40u8 != 0u8) {\n-        ret tup((((a & 0x3fu8) as uint) << 8u) | (data.(start + 1u) as uint),\n+        ret tup((a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n                 start + 2u);\n     } else if (a & 0x20u8 != 0u8) {\n-        ret tup((((a & 0x1fu8) as uint) << 16u) |\n-                ((data.(start + 1u) as uint) << 8u) |\n-                (data.(start + 2u) as uint), start + 3u);\n+        ret tup((a & 0x1fu8 as uint) << 16u |\n+                    (data.(start + 1u) as uint) << 8u |\n+                    (data.(start + 2u) as uint), start + 3u);\n     } else if (a & 0x10u8 != 0u8) {\n-        ret tup((((a & 0x0fu8) as uint) << 24u) |\n-                ((data.(start + 1u) as uint) << 16u) |\n-                ((data.(start + 2u) as uint) << 8u) |\n-                (data.(start + 3u) as uint), start + 4u);\n-    } else {\n-        log_err \"vint too big\"; fail;\n-    }\n+        ret tup((a & 0x0fu8 as uint) << 24u |\n+                    (data.(start + 1u) as uint) << 16u |\n+                    (data.(start + 2u) as uint) << 8u |\n+                    (data.(start + 3u) as uint), start + 4u);\n+    } else { log_err \"vint too big\"; fail; }\n }\n \n fn new_doc(vec[u8] data) -> doc {\n@@ -63,7 +61,7 @@ fn maybe_get_doc(doc d, uint tg) -> option::t[doc] {\n \n fn get_doc(doc d, uint tg) -> doc {\n     alt (maybe_get_doc(d, tg)) {\n-        case (some(?d)) {ret d;}\n+        case (some(?d)) { ret d; }\n         case (none) {\n             log_err \"failed to find block with tag \" + uint::to_str(tg, 10u);\n             fail;\n@@ -93,9 +91,7 @@ iter tagged_docs(doc d, uint tg) -> doc {\n     }\n }\n \n-fn doc_data(doc d) -> vec[u8] {\n-    ret vec::slice[u8](d.data, d.start, d.end);\n-}\n+fn doc_data(doc d) -> vec[u8] { ret vec::slice[u8](d.data, d.start, d.end); }\n \n fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n     auto sz = size;\n@@ -104,7 +100,7 @@ fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n     auto pos = start;\n     while (sz > 0u) {\n         sz -= 1u;\n-        val += (data.(pos) as uint) << (sz * 8u);\n+        val += (data.(pos) as uint) << sz * 8u;\n         pos += 1u;\n     }\n     ret val;\n@@ -114,45 +110,35 @@ fn doc_as_uint(doc d) -> uint {\n     ret be_uint_from_bytes(d.data, d.start, d.end - d.start);\n }\n \n-// ebml writing\n \n+// ebml writing\n type writer = rec(io::buf_writer writer, mutable vec[uint] size_positions);\n \n fn write_sized_vint(&io::buf_writer w, uint n, uint size) {\n     let vec[u8] buf;\n     alt (size) {\n-        case (1u) {\n-            buf = [0x80u8 | (n as u8)];\n-        }\n-        case (2u) {\n-            buf = [0x40u8 | ((n >> 8u) as u8),\n-                      (n & 0xffu) as u8];\n-        }\n+        case (1u) { buf = [0x80u8 | (n as u8)]; }\n+        case (2u) { buf = [0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n         case (3u) {\n-            buf = [0x20u8 | ((n >> 16u) as u8),\n-                      ((n >> 8u) & 0xffu) as u8,\n-                      (n & 0xffu) as u8];\n+            buf =\n+                [0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n+                 n & 0xffu as u8];\n         }\n         case (4u) {\n-            buf = [0x10u8 | ((n >> 24u) as u8),\n-                      ((n >> 16u) & 0xffu) as u8,\n-                      ((n >> 8u) & 0xffu) as u8,\n-                      (n & 0xffu) as u8];\n-        }\n-        case (_) {\n-            log_err \"vint to write too big\";\n-            fail;\n+            buf =\n+                [0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n+                 n >> 8u & 0xffu as u8, n & 0xffu as u8];\n         }\n+        case (_) { log_err \"vint to write too big\"; fail; }\n     }\n-\n     w.write(buf);\n }\n \n fn write_vint(&io::buf_writer w, uint n) {\n-    if (n < 0x7fu)          { write_sized_vint(w, n, 1u); ret; }\n-    if (n < 0x4000u)        { write_sized_vint(w, n, 2u); ret; }\n-    if (n < 0x200000u)      { write_sized_vint(w, n, 3u); ret; }\n-    if (n < 0x10000000u)    { write_sized_vint(w, n, 4u); ret; }\n+    if (n < 0x7fu) { write_sized_vint(w, n, 1u); ret; }\n+    if (n < 0x4000u) { write_sized_vint(w, n, 2u); ret; }\n+    if (n < 0x200000u) { write_sized_vint(w, n, 3u); ret; }\n+    if (n < 0x10000000u) { write_sized_vint(w, n, 4u); ret; }\n     log_err \"vint to write too big\";\n     fail;\n }\n@@ -162,13 +148,14 @@ fn create_writer(&io::buf_writer w) -> writer {\n     ret rec(writer=w, mutable size_positions=size_positions);\n }\n \n-// TODO: Provide a function to write the standard ebml header.\n \n+// TODO: Provide a function to write the standard ebml header.\n fn start_tag(&writer w, uint tag_id) {\n     // Write the tag ID:\n-    write_vint(w.writer, tag_id);\n \n+    write_vint(w.writer, tag_id);\n     // Write a placeholder four-byte size.\n+\n     w.size_positions += [w.writer.tell()];\n     let vec[u8] zeroes = [0u8, 0u8, 0u8, 0u8];\n     w.writer.write(zeroes);\n@@ -181,6 +168,5 @@ fn end_tag(&writer w) {\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n     w.writer.seek(cur_pos as int, io::seek_set);\n }\n-\n // TODO: optionally perform \"relaxations\" on end_tag to more efficiently\n // encode sizes; this is a fixed point iteration"}, {"sha": "47c9b0a23a6579ff708af7bbba245dd9c2fe74e8", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 160, "deletions": 296, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,3 +1,5 @@\n+\n+\n /* The 'fmt' extension is modeled on the posix printf system.\n  *\n  * A posix conversion ostensibly looks like this:\n@@ -12,10 +14,10 @@\n  * we also only support translating-to-rust a tiny subset of the possible\n  * combinations at the moment.\n  */\n-\n import option::none;\n import option::some;\n \n+\n /*\n  * We have a 'ct' (compile-time) module that parses format strings into a\n  * sequence of conversions. From those conversions AST fragments are built\n@@ -29,16 +31,8 @@ import option::some;\n \n // Functions used by the fmt extension at compile time\n mod ct {\n-    tag signedness {\n-        signed;\n-        unsigned;\n-    }\n-\n-    tag caseness {\n-        case_upper;\n-        case_lower;\n-    }\n-\n+    tag signedness { signed; unsigned; }\n+    tag caseness { case_upper; case_lower; }\n     tag ty {\n         ty_bool;\n         ty_str;\n@@ -48,16 +42,15 @@ mod ct {\n         ty_hex(caseness);\n         ty_octal;\n         // FIXME: More types\n-    }\n \n+    }\n     tag flag {\n         flag_left_justify;\n         flag_left_zero_pad;\n         flag_space_for_sign;\n         flag_sign_always;\n         flag_alternate;\n     }\n-\n     tag count {\n         count_is(int);\n         count_is_param(int);\n@@ -66,33 +59,29 @@ mod ct {\n     }\n \n     // A formatted conversion from an expression to a string\n-    type conv = rec(option::t[int] param,\n-                    vec[flag] flags,\n-                    count width,\n-                    count precision,\n-                    ty ty);\n+    type conv =\n+        rec(option::t[int] param,\n+            vec[flag] flags,\n+            count width,\n+            count precision,\n+            ty ty);\n \n-    // A fragment of the output sequence\n-    tag piece {\n-        piece_string(str);\n-        piece_conv(conv);\n-    }\n \n-    type error_fn = fn (str) -> !;\n+    // A fragment of the output sequence\n+    tag piece { piece_string(str); piece_conv(conv); }\n+    type error_fn = fn(str) -> !  ;\n \n     fn parse_fmt_string(str s, error_fn error) -> vec[piece] {\n         let vec[piece] pieces = [];\n         auto lim = str::byte_len(s);\n         auto buf = \"\";\n-\n         fn flush_buf(str buf, &mutable vec[piece] pieces) -> str {\n             if (str::byte_len(buf) > 0u) {\n                 auto piece = piece_string(buf);\n                 pieces += [piece];\n             }\n             ret \"\";\n         }\n-\n         auto i = 0u;\n         while (i < lim) {\n             auto curr = str::substr(s, i, 1u);\n@@ -110,228 +99,164 @@ mod ct {\n                     pieces += [res._0];\n                     i = res._1;\n                 }\n-            } else {\n-                buf += curr;\n-                i += 1u;\n-            }\n+            } else { buf += curr; i += 1u; }\n         }\n         buf = flush_buf(buf, pieces);\n         ret pieces;\n     }\n-\n     fn peek_num(str s, uint i, uint lim) -> option::t[tup(uint, uint)] {\n-        if (i >= lim) {\n-            ret none[tup(uint, uint)];\n-        }\n-\n+        if (i >= lim) { ret none[tup(uint, uint)]; }\n         auto c = s.(i);\n         if (!('0' as u8 <= c && c <= '9' as u8)) {\n             ret option::none[tup(uint, uint)];\n         }\n-\n-        auto n = (c - ('0' as u8)) as uint;\n+        auto n = c - ('0' as u8) as uint;\n         ret alt (peek_num(s, i + 1u, lim)) {\n-            case (none) {\n-                some[tup(uint, uint)](tup(n, i + 1u))\n-            }\n-            case (some(?next)) {\n-                auto m = next._0;\n-                auto j = next._1;\n-                some[tup(uint, uint)](tup(n * 10u + m, j))\n-            }\n-        };\n+                case (none) { some[tup(uint, uint)](tup(n, i + 1u)) }\n+                case (some(?next)) {\n+                    auto m = next._0;\n+                    auto j = next._1;\n+                    some[tup(uint, uint)](tup(n * 10u + m, j))\n+                }\n+            };\n     }\n-\n-    fn parse_conversion(str s, uint i, uint lim,\n-                        error_fn error) -> tup(piece, uint) {\n+    fn parse_conversion(str s, uint i, uint lim, error_fn error) ->\n+       tup(piece, uint) {\n         auto parm = parse_parameter(s, i, lim);\n         auto flags = parse_flags(s, parm._1, lim);\n         auto width = parse_count(s, flags._1, lim);\n         auto prec = parse_precision(s, width._1, lim);\n         auto ty = parse_type(s, prec._1, lim, error);\n-        ret tup(piece_conv(rec(param = parm._0,\n-                               flags = flags._0,\n-                               width = width._0,\n-                               precision = prec._0,\n-                               ty = ty._0)),\n-                ty._1);\n+        ret tup(piece_conv(rec(param=parm._0,\n+                               flags=flags._0,\n+                               width=width._0,\n+                               precision=prec._0,\n+                               ty=ty._0)), ty._1);\n     }\n-\n     fn parse_parameter(str s, uint i, uint lim) -> tup(option::t[int], uint) {\n-        if (i >= lim) {\n-            ret tup(none[int], i);\n-        }\n-\n+        if (i >= lim) { ret tup(none[int], i); }\n         auto num = peek_num(s, i, lim);\n         ret alt (num) {\n-            case (none) {\n-                tup(none[int], i)\n-            }\n-            case (some(?t)) {\n-                auto n = t._0;\n-                auto j = t._1;\n-                if (j < lim && s.(j) == '$' as u8) {\n-                    tup(some[int](n as int), j + 1u)\n+                case (none) { tup(none[int], i) }\n+                case (some(?t)) {\n+                    auto n = t._0;\n+                    auto j = t._1;\n+                    if (j < lim && s.(j) == '$' as u8) {\n+                        tup(some[int](n as int), j + 1u)\n+                    } else { tup(none[int], i) }\n                 }\n-                else {\n-                    tup(none[int], i)\n-                }\n-            }\n-        };\n+            };\n     }\n-\n     fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n         let vec[flag] noflags = [];\n-\n-        if (i >= lim) {\n-            ret tup(noflags, i);\n-        }\n-\n+        if (i >= lim) { ret tup(noflags, i); }\n         fn more_(flag f, str s, uint i, uint lim) -> tup(vec[flag], uint) {\n             auto next = parse_flags(s, i + 1u, lim);\n             auto rest = next._0;\n             auto j = next._1;\n             let vec[flag] curr = [f];\n             ret tup(curr + rest, j);\n         }\n-\n         auto more = bind more_(_, s, i, lim);\n-\n         auto f = s.(i);\n-        ret if (f == ('-' as u8)) {\n-            more(flag_left_justify)\n-        } else if (f == ('0' as u8)) {\n-            more(flag_left_zero_pad)\n-        } else if (f == (' ' as u8)) {\n-            more(flag_space_for_sign)\n-        } else if (f == ('+' as u8)) {\n-            more(flag_sign_always)\n-        } else if (f == ('#' as u8)) {\n-            more(flag_alternate)\n-        } else {\n-            tup(noflags, i)\n-        };\n+        ret if (f == '-' as u8) {\n+                more(flag_left_justify)\n+            } else if (f == '0' as u8) {\n+                more(flag_left_zero_pad)\n+            } else if (f == ' ' as u8) {\n+                more(flag_space_for_sign)\n+            } else if (f == '+' as u8) {\n+                more(flag_sign_always)\n+            } else if (f == '#' as u8) {\n+                more(flag_alternate)\n+            } else { tup(noflags, i) };\n     }\n-\n     fn parse_count(str s, uint i, uint lim) -> tup(count, uint) {\n         ret if (i >= lim) {\n-            tup(count_implied, i)\n-        } else if (s.(i) == ('*' as u8)) {\n-            auto param = parse_parameter(s, i + 1u, lim);\n-            auto j = param._1;\n-            alt (param._0) {\n-                case (none) {\n-                    tup(count_is_next_param, j)\n-                }\n-                case (some(?n)) {\n-                    tup(count_is_param(n), j)\n-                }\n-            }\n-        } else {\n-            auto num = peek_num(s, i, lim);\n-            alt (num) {\n-                case (none) {\n-                    tup(count_implied, i)\n+                tup(count_implied, i)\n+            } else if (s.(i) == '*' as u8) {\n+                auto param = parse_parameter(s, i + 1u, lim);\n+                auto j = param._1;\n+                alt (param._0) {\n+                    case (none) { tup(count_is_next_param, j) }\n+                    case (some(?n)) { tup(count_is_param(n), j) }\n                 }\n-                case (some(?num)) {\n-                    tup(count_is(num._0 as int), num._1)\n+            } else {\n+                auto num = peek_num(s, i, lim);\n+                alt (num) {\n+                    case (none) { tup(count_implied, i) }\n+                    case (some(?num)) { tup(count_is(num._0 as int), num._1) }\n                 }\n-            }\n-        };\n+            };\n     }\n-\n     fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n         ret if (i >= lim) {\n-            tup(count_implied, i)\n-        } else if (s.(i) == '.' as u8) {\n-            auto count = parse_count(s, i + 1u, lim);\n-            // If there were no digits specified, i.e. the precision\n-            // was \".\", then the precision is 0\n-            alt (count._0) {\n-                case (count_implied) {\n-                    tup(count_is(0), count._1)\n+                tup(count_implied, i)\n+            } else if (s.(i) == '.' as u8) {\n+                auto count = parse_count(s, i + 1u, lim);\n+\n+                // If there were no digits specified, i.e. the precision\n+                // was \".\", then the precision is 0\n+                alt (count._0) {\n+                    case (count_implied) { tup(count_is(0), count._1) }\n+                    case (_) { count }\n                 }\n-                case (_) {\n-                    count\n-                }\n-            }\n-        } else {\n-            tup(count_implied, i)\n-        };\n+            } else { tup(count_implied, i) };\n     }\n-\n     fn parse_type(str s, uint i, uint lim, error_fn error) -> tup(ty, uint) {\n-        if (i >= lim) {\n-            error(\"missing type in conversion\");\n-        }\n-\n+        if (i >= lim) { error(\"missing type in conversion\"); }\n         auto tstr = str::substr(s, i, 1u);\n-        auto t = if (str::eq(tstr, \"b\")) {\n-            ty_bool\n-        } else if (str::eq(tstr, \"s\")) {\n-            ty_str\n-        } else if (str::eq(tstr, \"c\")) {\n-            ty_char\n-        } else if (str::eq(tstr, \"d\")\n-                   || str::eq(tstr, \"i\")) {\n-            // TODO: Do we really want two signed types here?\n-            // How important is it to be printf compatible?\n-            ty_int(signed)\n-        } else if (str::eq(tstr, \"u\")) {\n-            ty_int(unsigned)\n-        } else if (str::eq(tstr, \"x\")) {\n-            ty_hex(case_lower)\n-        } else if (str::eq(tstr, \"X\")) {\n-            ty_hex(case_upper)\n-        } else if (str::eq(tstr, \"t\")) {\n-            ty_bits\n-        } else if (str::eq(tstr, \"o\")) {\n-            ty_octal\n-        } else {\n-            error(\"unknown type in conversion: \" + tstr)\n-        };\n-\n+        auto t =\n+            if (str::eq(tstr, \"b\")) {\n+                ty_bool\n+            } else if (str::eq(tstr, \"s\")) {\n+                ty_str\n+            } else if (str::eq(tstr, \"c\")) {\n+                ty_char\n+            } else if (str::eq(tstr, \"d\") || str::eq(tstr, \"i\")) {\n+\n+                // TODO: Do we really want two signed types here?\n+                // How important is it to be printf compatible?\n+                ty_int(signed)\n+            } else if (str::eq(tstr, \"u\")) {\n+                ty_int(unsigned)\n+            } else if (str::eq(tstr, \"x\")) {\n+                ty_hex(case_lower)\n+            } else if (str::eq(tstr, \"X\")) {\n+                ty_hex(case_upper)\n+            } else if (str::eq(tstr, \"t\")) {\n+                ty_bits\n+            } else if (str::eq(tstr, \"o\")) {\n+                ty_octal\n+            } else { error(\"unknown type in conversion: \" + tstr) };\n         ret tup(t, i + 1u);\n     }\n }\n \n+\n // Functions used by the fmt extension at runtime. For now there are a lot of\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it this way, I think.\n mod rt {\n-\n     tag flag {\n         flag_left_justify;\n         flag_left_zero_pad;\n         flag_space_for_sign;\n         flag_sign_always;\n         flag_alternate;\n+\n         // FIXME: This is a hack to avoid creating 0-length vec exprs,\n         // which have some difficulty typechecking currently. See\n         // comments in front::extfmt::make_flags\n         flag_none;\n     }\n-\n-    tag count {\n-        count_is(int);\n-        count_implied;\n-    }\n-\n-    tag ty {\n-        ty_default;\n-        ty_bits;\n-        ty_hex_upper;\n-        ty_hex_lower;\n-        ty_octal;\n-    }\n+    tag count { count_is(int); count_implied; }\n+    tag ty { ty_default; ty_bits; ty_hex_upper; ty_hex_lower; ty_octal; }\n \n     // FIXME: May not want to use a vector here for flags;\n     // instead just use a bool per flag\n-    type conv = rec(vec[flag] flags,\n-                    count width,\n-                    count precision,\n-                    ty ty);\n+    type conv = rec(vec[flag] flags, count width, count precision, ty ty);\n \n     fn conv_int(&conv cv, int i) -> str {\n         auto radix = 10u;\n@@ -346,191 +271,137 @@ mod rt {\n         }\n         ret pad(cv, s, pad_signed);\n     }\n-\n     fn conv_uint(&conv cv, uint u) -> str {\n         auto prec = get_int_precision(cv);\n-        auto res = alt (cv.ty) {\n-            case (ty_default) {\n-                uint_to_str_prec(u, 10u, prec)\n-            }\n-            case (ty_hex_lower) {\n-                uint_to_str_prec(u, 16u, prec)\n-            }\n-            case (ty_hex_upper) {\n-                str::to_upper(uint_to_str_prec(u, 16u, prec))\n-            }\n-            case (ty_bits) {\n-                uint_to_str_prec(u, 2u, prec)\n-            }\n-            case (ty_octal) {\n-                uint_to_str_prec(u, 8u, prec)\n-            }\n-        };\n+        auto res =\n+            alt (cv.ty) {\n+                case (ty_default) { uint_to_str_prec(u, 10u, prec) }\n+                case (ty_hex_lower) { uint_to_str_prec(u, 16u, prec) }\n+                case (ty_hex_upper) {\n+                    str::to_upper(uint_to_str_prec(u, 16u, prec))\n+                }\n+                case (ty_bits) { uint_to_str_prec(u, 2u, prec) }\n+                case (ty_octal) { uint_to_str_prec(u, 8u, prec) }\n+            };\n         ret pad(cv, res, pad_unsigned);\n     }\n-\n     fn conv_bool(&conv cv, bool b) -> str {\n-        auto s = if (b) {\n-            \"true\"\n-        } else {\n-            \"false\"\n-        };\n+        auto s = if (b) { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n+\n         ret conv_str(cv, s);\n     }\n-\n     fn conv_char(&conv cv, char c) -> str {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n-\n     fn conv_str(&conv cv, str s) -> str {\n-        auto unpadded = alt (cv.precision) {\n-            case (count_implied) {\n-                s\n-            }\n-            case (count_is(?max)) {\n-                // For strings, precision is the maximum characters displayed\n-                if (max as uint < str::char_len(s)) {\n-                    // FIXME: substr works on bytes, not chars!\n-                    str::substr(s, 0u, max as uint)\n-                } else {\n-                    s\n+        auto unpadded =\n+            alt (cv.precision) {\n+                case (count_implied) { s }\n+                case (count_is(?max)) {\n+\n+                    // For strings, precision is the maximum characters\n+                    // displayed\n+                    if (max as uint < str::char_len(s)) {\n+\n+                        // FIXME: substr works on bytes, not chars!\n+                        str::substr(s, 0u, max as uint)\n+                    } else { s }\n                 }\n-            }\n-        };\n+            };\n         ret pad(cv, unpadded, pad_nozero);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n     fn int_to_str_prec(int num, uint radix, uint prec) -> str {\n         ret if (num < 0) {\n-            \"-\" + uint_to_str_prec((-num) as uint, radix, prec)\n-        } else {\n-            uint_to_str_prec(num as uint, radix, prec)\n-        };\n+                \"-\" + uint_to_str_prec(-num as uint, radix, prec)\n+            } else { uint_to_str_prec(num as uint, radix, prec) };\n     }\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n     fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n         ret if (prec == 0u && num == 0u) {\n-            \"\"\n-        } else {\n-            auto s = uint::to_str(num, radix);\n-            auto len = str::char_len(s);\n-            if (len < prec) {\n-                auto diff = prec - len;\n-                auto pad = str_init_elt('0', diff);\n-                pad + s\n+                \"\"\n             } else {\n-                s\n-            }\n-        };\n+                auto s = uint::to_str(num, radix);\n+                auto len = str::char_len(s);\n+                if (len < prec) {\n+                    auto diff = prec - len;\n+                    auto pad = str_init_elt('0', diff);\n+                    pad + s\n+                } else { s }\n+            };\n     }\n-\n     fn get_int_precision(&conv cv) -> uint {\n         ret alt (cv.precision) {\n-            case (count_is(?c)) {\n-                c as uint\n-            }\n-            case (count_implied) {\n-                1u\n-            }\n-        };\n+                case (count_is(?c)) { c as uint }\n+                case (count_implied) { 1u }\n+            };\n     }\n \n     // FIXME: This might be useful in str: but needs to be utf8 safe first\n     fn str_init_elt(char c, uint n_elts) -> str {\n         auto svec = vec::init_elt[u8](c as u8, n_elts);\n         // FIXME: Using unsafe_from_bytes because rustboot\n         // can't figure out the is_utf8 predicate on from_bytes?\n-        ret str::unsafe_from_bytes(svec);\n-    }\n \n-    tag pad_mode {\n-        pad_signed;\n-        pad_unsigned;\n-        pad_nozero;\n+        ret str::unsafe_from_bytes(svec);\n     }\n-\n+    tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n     fn pad(&conv cv, str s, pad_mode mode) -> str {\n         auto uwidth;\n         alt (cv.width) {\n-            case (count_implied) {\n-                ret s;\n-            }\n+            case (count_implied) { ret s; }\n             case (count_is(?width)) {\n                 // FIXME: Maybe width should be uint\n+\n                 uwidth = width as uint;\n             }\n         }\n-\n         auto strlen = str::char_len(s);\n-        if (uwidth <= strlen) {\n-            ret s;\n-        }\n-\n+        if (uwidth <= strlen) { ret s; }\n         auto padchar = ' ';\n         auto diff = uwidth - strlen;\n         if (have_flag(cv.flags, flag_left_justify)) {\n             auto padstr = str_init_elt(padchar, diff);\n             ret s + padstr;\n         }\n-\n         auto might_zero_pad = false;\n         auto signed = false;\n-\n         alt (mode) {\n             case (pad_nozero) {\n                 // fallthrough\n+\n             }\n-            case (pad_signed) {\n-                might_zero_pad = true;\n-                signed = true;\n-            }\n-            case (pad_unsigned) {\n-                might_zero_pad = true;\n-            }\n+            case (pad_signed) { might_zero_pad = true; signed = true; }\n+            case (pad_unsigned) { might_zero_pad = true; }\n         }\n-\n         fn have_precision(&conv cv) -> bool {\n             ret alt (cv.precision) {\n-                case (count_implied) {\n-                    false\n-                }\n-                case (_) {\n-                    true\n-                }\n-            };\n+                    case (count_implied) { false }\n+                    case (_) { true }\n+                };\n         }\n-\n         auto zero_padding = false;\n-        if (might_zero_pad\n-            && have_flag(cv.flags, flag_left_zero_pad)\n-            && !have_precision(cv)) {\n-\n+        if (might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+                !have_precision(cv)) {\n             padchar = '0';\n             zero_padding = true;\n         }\n-\n         auto padstr = str_init_elt(padchar, diff);\n-\n         // This is completely heinous. If we have a signed value then\n         // potentially rip apart the intermediate result and insert some\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n-        if (signed\n-            && zero_padding\n-            && str::byte_len(s) > 0u) {\n \n+        if (signed && zero_padding && str::byte_len(s) > 0u) {\n             auto head = s.(0);\n-            if (head == '+' as u8\n-                || head == '-' as u8\n-                || head == ' ' as u8) {\n-\n+            if (head == '+' as u8 || head == '-' as u8 || head == ' ' as u8) {\n                 auto headstr = str::unsafe_from_bytes([head]);\n                 auto bytelen = str::byte_len(s);\n                 auto numpart = str::substr(s, 1u, bytelen - 1u);\n@@ -539,18 +410,11 @@ mod rt {\n         }\n         ret padstr + s;\n     }\n-\n     fn have_flag(vec[flag] flags, flag f) -> bool {\n-        for (flag candidate in flags) {\n-            if (candidate == f) {\n-                ret true;\n-            }\n-        }\n+        for (flag candidate in flags) { if (candidate == f) { ret true; } }\n         ret false;\n     }\n }\n-\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "fb609a86a95d4a5d8bb3c87bad3a96cc954b2d41", "filename": "src/lib/fs.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,20 +1,18 @@\n+\n+\n native \"rust\" mod rustrt {\n-  fn rust_file_is_dir(str path) -> int;\n+    fn rust_file_is_dir(str path) -> int;\n }\n \n-fn path_sep() -> str {\n-    ret str::from_char(os_fs::path_sep);\n-}\n+fn path_sep() -> str { ret str::from_char(os_fs::path_sep); }\n \n type path = str;\n \n fn dirname(path p) -> path {\n     let int i = str::rindex(p, os_fs::path_sep as u8);\n     if (i == -1) {\n         i = str::rindex(p, os_fs::alt_path_sep as u8);\n-        if (i == -1) {\n-            ret p;\n-        }\n+        if (i == -1) { ret p; }\n     }\n     ret str::substr(p, 0u, i as uint);\n }\n@@ -23,45 +21,40 @@ fn basename(path p) -> path {\n     let int i = str::rindex(p, os_fs::path_sep as u8);\n     if (i == -1) {\n         i = str::rindex(p, os_fs::alt_path_sep as u8);\n-        if (i == -1) {\n-            ret p;\n-        }\n+        if (i == -1) { ret p; }\n     }\n     auto len = str::byte_len(p);\n-    if ((i+1) as uint >= len) { ret p; }\n-\n-    ret str::slice(p, i+1 as uint, len);\n+    if (i + 1 as uint >= len) { ret p; }\n+    ret str::slice(p, i + 1 as uint, len);\n }\n \n+\n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n fn connect(path pre, path post) -> path {\n     auto len = str::byte_len(pre);\n-    ret if (pre.(len - 1u) == (os_fs::path_sep as u8)) { // Trailing '/'?\n-        pre + post\n-    } else {\n-        pre + path_sep() + post\n-    };\n+    ret if (pre.(len - 1u) == os_fs::path_sep as u8) {\n+             // Trailing '/'?\n+            pre + post\n+        } else { pre + path_sep() + post };\n }\n \n-fn file_is_dir(path p) -> bool {\n-  ret rustrt::rust_file_is_dir(p) != 0;\n-}\n+fn file_is_dir(path p) -> bool { ret rustrt::rust_file_is_dir(p) != 0; }\n \n fn list_dir(path p) -> vec[str] {\n-  auto pl = str::byte_len(p);\n-  if (pl == 0u || p.(pl - 1u) as char != os_fs::path_sep) {\n-    p += path_sep();\n-  }\n-  let vec[str] full_paths = [];\n-  for (str filename in os_fs::list_dir(p)) {\n-    if (!str::eq(filename, \".\")) {if (!str::eq(filename, \"..\")) {\n-      vec::push[str](full_paths, p + filename);\n-    }}\n-  }\n-  ret full_paths;\n+    auto pl = str::byte_len(p);\n+    if (pl == 0u || p.(pl - 1u) as char != os_fs::path_sep) {\n+        p += path_sep();\n+    }\n+    let vec[str] full_paths = [];\n+    for (str filename in os_fs::list_dir(p)) {\n+        if (!str::eq(filename, \".\")) {\n+            if (!str::eq(filename, \"..\")) {\n+                vec::push[str](full_paths, p + filename);\n+            }\n+        }\n+    }\n+    ret full_paths;\n }\n-\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "0fb8d79378f9a8b04dd3849564e0a6fc1a743125", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0", "patch": "@@ -1,9 +1,8 @@\n-fn getenv(str n) -> option::t[str] {\n-  auto s = os::libc::getenv(str::buf(n));\n-  ret if ((s as int) == 0) {\n-    option::none[str]\n-  } else {\n-    option::some[str](str::str_from_cstr(s))\n-  };\n-}\n \n+\n+fn getenv(str n) -> option::t[str] {\n+    auto s = os::libc::getenv(str::buf(n));\n+    ret if (s as int == 0) {\n+            option::none[str]\n+        } else { option::some[str](str::str_from_cstr(s)) };\n+}\n\\ No newline at end of file"}, {"sha": "0ee2cfa7885a5746f4f752ea729f6f2fd0af5239", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1221dca632cdbe2083c602f8833a47898187210f", "filename": "src/lib/int.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "49985b72fdd9c71d9db14bcb6480972bf60a71ac", "filename": "src/lib/io.rs", "status": "modified", "additions": 148, "deletions": 225, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "382510c1b1b177151516903217ac3e4590933ef3", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "2017c52e1dd07966a836a267491efdca859940e7", "filename": "src/lib/list.rs", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1a973b6742f9746217cc13a0c5b5b22a923b62c3", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "90b2693bdcfd4757ee56fbda3de6b8c80507a0ab", "filename": "src/lib/map.rs", "status": "modified", "additions": 139, "deletions": 182, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "47b443c8ff2338340825ebb40e439af850eb4a09", "filename": "src/lib/option.rs", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "27f1645551f6df6faaef8974fd2c503786580fb5", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e4805c9d82520a689e49e34c193788977c273974", "filename": "src/lib/rand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frand.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "43103435b59ba90c802f4180de242425d36d141a", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "394382d60fa60d398e4a48821f404ece844cf8a1", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 83, "deletions": 111, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "0c35e16cb93538874f36187b760c9cec52a57c20", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f0797ddc740ba868d0155dc0dd5ff3a087fd07ce", "filename": "src/lib/sort.rs", "status": "modified", "additions": 28, "deletions": 68, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "bb65e6c29c4d0a561b8d457e683d326d2d4bdbfb", "filename": "src/lib/str.rs", "status": "modified", "additions": 108, "deletions": 174, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a70f17dde1c6d187a8f943eb61d98d84a6b22303", "filename": "src/lib/sys.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "33ca245551ca373953409087883672dc03253eab", "filename": "src/lib/term.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "65d026162943f952572b5dea7f62a258d39e01f3", "filename": "src/lib/time.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftime.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "77e290dc5f6d28d27f1cc5b60d05620f92f104a4", "filename": "src/lib/u8.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu8.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c24bd3e12272d24e72014a25628bf0e359804d28", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a359f356341befd376f6d0e2b8b4c514a483ae8c", "filename": "src/lib/uint.rs", "status": "modified", "additions": 35, "deletions": 45, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "0abb3e1353a14041d3b6a5b3d5a62a49588dfdfd", "filename": "src/lib/util.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f9e80532b688e5cf66e08fd80398a0a73981aae1", "filename": "src/lib/vec.rs", "status": "modified", "additions": 79, "deletions": 172, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d4ac65e72a0d709ae27f8f48158b812345ae86c3", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "878eacb998d4d5b309d55aee036c60a687fa8c80", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b704db019d43db66a39b6bedc129f8fa12001bc0", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6213abc75ee0b8847cc82818e39045ea4b00d31c", "filename": "src/test/bench/99-bottles/99bob-pattern.rs", "status": "modified", "additions": 42, "deletions": 55, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "2a2675c9a1df8f9369226a0971289e026094ed64", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 29, "deletions": 40, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "22ebed0ba48885f8122dea4ac724896a1c48c6f5", "filename": "src/test/bench/99-bottles/99bob-tail.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "868cee4327f51142200074515bc881b5481d995d", "filename": "src/test/bench/shootout/ackermann.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Fackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Fackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fackermann.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "ebbcc69c9cce08a1ad8dd3877b96cc45490eab49", "filename": "src/test/bench/shootout/binarytrees.rs", "status": "modified", "additions": 40, "deletions": 61, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "02208a4845c0237037bcc56f3563c2c8727da193", "filename": "src/test/bench/shootout/fannkuchredux.rs", "status": "modified", "additions": 53, "deletions": 88, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b6e43c813ca25bd053e307929351526f7330e228", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 57, "deletions": 94, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "123035813225a0d302d91fd4e694582ce05543f6", "filename": "src/test/bench/shootout/fibo.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Ffibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Fbench%2Fshootout%2Ffibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffibo.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "39b2a36d01faf8aa74c2c70dc1c12e22a28b05c4", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "123b1087d9b6ea6ab059f93f6e3db89c287cd81d", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a74cf4b36e331bbeaf71e08cda2db4317884bc17", "filename": "src/test/run-fail/explicit-fail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f3bd1a5fea9172cb26ac466fb150ddfae3cf7bab", "filename": "src/test/run-fail/expr-alt-fail-fn.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1b653d879ba66c9ab729004b0af077dd496c4cbc", "filename": "src/test/run-fail/expr-alt-fail.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "fc716fc1c608356075032b20a4e13b5c63c2af01", "filename": "src/test/run-fail/expr-fn-fail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-fn-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-fn-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-fn-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "2e4d0cbe29ae4e96a196dd0e91cf20325f1a2916", "filename": "src/test/run-fail/expr-if-fail-fn.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a12b755e3b168c78fab4627d972cf4d2d2d62dd0", "filename": "src/test/run-fail/expr-if-fail.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-if-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fexpr-if-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-if-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a0520c288a4ce767c9ec45836a8c2a557a64cd5c", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a1a70db0d42773a966a1444cb88ca9fa7d156125", "filename": "src/test/run-fail/non-exhaustive-match.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "ac63209b153f23e3dba387754125e37276d24551", "filename": "src/test/run-fail/pred.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpred.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "318a9eb578671f24839e4d5d0af3c558be58ce79", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "96d0f219b8460c4108ea443b5aaa36ab7d253ad9", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1c1e34a258cf5b1e8d4203c648486d66c3bced20", "filename": "src/test/run-fail/trivial-message2.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Ftrivial-message2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Ftrivial-message2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftrivial-message2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f0318de3528359e893c2d555c560dd70a387e921", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b645ea181e3912c90931cc8beab00d48d55022a1", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4d96545237225d5d63eb220c36b985d20dffef9b", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f656cf6fdf4da3a6ecc5f115c8d2b34b2710af86", "filename": "src/test/run-pass/alt-bot.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "73db771c364027050ca5028634bcea33af58842d", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "593e79864bacf55c1d86c61271b0fc5d298ddbcd", "filename": "src/test/run-pass/alt-path.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-path.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e5d008b11879e0edb25052432ccfcf953fb4c898", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "8ec621cef4c4773a3de30c06a90c7e5912f10a8f", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "50fc85a1d9dc69a634ed878eb7fd43b350625d7e", "filename": "src/test/run-pass/alt-pattern-no-type-params.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c524c03467168d5dc651e6ebb0a8f91b50204e2a", "filename": "src/test/run-pass/alt-pattern-simple.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1fd798832a7a8f278b2b8135ffe140ce271327b8", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6e586a3f5667874bf1bb7aa0541588178e5f1160", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "94a14b89e7724fd357da5d9938302b88525ca50d", "filename": "src/test/run-pass/anon-objs.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fanon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fanon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-objs.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c94106a4f3b7f39b8e193330bd49b5a0cf4decd4", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "5d68b04ed8f484f08a06acf61cd07a2b00a9d609", "filename": "src/test/run-pass/arith-0.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-0.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "ec1c6adb600a90e88746bc05b18f6d154550db03", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "bbb7c7e23bb11049ddccfc642040528d1163cf4c", "filename": "src/test/run-pass/arith-2.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "75f7549b994713a0306f64a36f501729628f3b39", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6d605965516b884d0a73350587fd397db4e8f19e", "filename": "src/test/run-pass/artificial-block.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fartificial-block.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d367593ff33d92179936b838cd8b829cf89c2924", "filename": "src/test/run-pass/assign-assign.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassign-assign.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "5ef365dc500c862845e715ac54d8e553a3b344fa", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d8f969cadf8a7ff94c2e7018201a4d906753cd50", "filename": "src/test/run-pass/autoderef-full-lval.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "39218ff4906d5e45b1aaa9ad131a0f54f6db0a09", "filename": "src/test/run-pass/autoderef-objfn.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fautoderef-objfn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fautoderef-objfn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-objfn.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "edf4b9187723ee0aa153e551ecf131a091f05ed8", "filename": "src/test/run-pass/bind-exterior.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-exterior.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d14d52cdd7d5fec876746eba8aa981b93f7e4233", "filename": "src/test/run-pass/bind-interior.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-interior.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c9f730bc8899917261cc0474c7f1e1a250a19869", "filename": "src/test/run-pass/bind-obj-ctor.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "378f9f8e1044c62c81ee8f2de7772e5dac3a4f71", "filename": "src/test/run-pass/bind-thunk.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-thunk.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1d5b72c22f3bbedbc0f3a1e78ff9c5b7e7a08bf5", "filename": "src/test/run-pass/bind-trivial.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-trivial.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1134e6e6ced0737fe39740ae0d05f1b61e261860", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a18ffcf8e6e4902a270bbb72b6ad110f5c82616f", "filename": "src/test/run-pass/bool-not.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbool-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbool-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool-not.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e3a93520d4ac8e515899d1596b3510aef6a11315", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "41e5a899887fc5f0c2be313ca1a398816a40b198", "filename": "src/test/run-pass/box-in-tup.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9d05403e52514e286b29aa0a3603d256b9eb026f", "filename": "src/test/run-pass/box-inside-if.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f987e070599d319e28d2d72c93c279bcc5f91ea2", "filename": "src/test/run-pass/box-inside-if2.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c0003c3b45f371ac20adb06398db8cba8ce359b4", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3fc7d745cceda17545bc103a38b7f2ceda1ddd77", "filename": "src/test/run-pass/box.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b53cf5e02a8e5881fb7927c6a651524ff6a8837c", "filename": "src/test/run-pass/break-value.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbreak-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbreak-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak-value.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "29a03b126e8915274c292a166aefdf9aeec40bd6", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "276fa42e869907219932c51692aa6cb1ab2086af", "filename": "src/test/run-pass/cast.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d27e89cc3b6e898a35078faac78e6fb2c9fa0567", "filename": "src/test/run-pass/char.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchar.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9cd3b67821b9388309f2913afd90599ae1b6a657", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9a2ebceaf76e6e70ff3f80374979aef5caaf79aa", "filename": "src/test/run-pass/command-line-args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "2f4f09b4c95c1acd5d0b432f5167b973bddbeed4", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "659c47ccdf7dcd32e1ad1a7829d514322617d4e2", "filename": "src/test/run-pass/const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "319232816a023535f4087a64fa6b383461af7c7a", "filename": "src/test/run-pass/dead-code-one-arm-if.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6bd175dffbe7a90e896691317eef96bf6f22f98b", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "db5fe4bacb41ddbb079523480fecea8ad6ad2ee4", "filename": "src/test/run-pass/deep.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdeep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdeep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeep.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f293c2112864b1be610381f35b4dcbba5d9993ce", "filename": "src/test/run-pass/deref-lval.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-lval.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "2836e5207b660c266b6c862367676a526c38fcf8", "filename": "src/test/run-pass/deref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3fc875dd01a1d64cc6cf0bed3da120ca2439bd3c", "filename": "src/test/run-pass/div-mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiv-mod.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b28b4e304fab01062f115344423e08174af458fd", "filename": "src/test/run-pass/drop-bind-thunk-args.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-bind-thunk-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-bind-thunk-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-bind-thunk-args.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "5096aee312aa3da14a4b47111c1709914038bbd6", "filename": "src/test/run-pass/drop-on-empty-block-exit.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "705654a8d31ad39c2d34677808681e919708511d", "filename": "src/test/run-pass/drop-on-ret.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "0085b51cfb32eb0de294d5709f9bfa681804aa1f", "filename": "src/test/run-pass/drop-parametric-closure-with-bound-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3d8c9fb4930d36d4d59414a4b5150dbc77a96198", "filename": "src/test/run-pass/else-if.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Felse-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Felse-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Felse-if.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "eaa2de30d95f5e46e6feb1187524093fc5a7107e", "filename": "src/test/run-pass/empty-mutable-vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "805c14f8cd08a6f61366b7110d828896c110a013", "filename": "src/test/run-pass/export-abstract-tag.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-abstract-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-abstract-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-abstract-tag.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "799bb69bf8b8b97492b6d5ea91ab2a849e09a058", "filename": "src/test/run-pass/export-non-interference.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "af539923a9e1f45706eda8783484143c02a95755", "filename": "src/test/run-pass/export-non-interference2.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e06112b0d93fac99ea2efe312051706700a49936", "filename": "src/test/run-pass/export-non-interference3.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "22e5c5b6aeabe6857a7dfda0975f47a02a12645a", "filename": "src/test/run-pass/export-tag-variant.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-tag-variant.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "01b8059bf7a5304ab81ed0187660f2ec011e791e", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "52868f431a40cf681d056ed08d038c3d647f64d0", "filename": "src/test/run-pass/expr-alt-box.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d17105b33fb8657facb5922cb6001f86c8eac1fb", "filename": "src/test/run-pass/expr-alt-fail-all.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a956ac2e145096d6033819af7488a278d3c097f1", "filename": "src/test/run-pass/expr-alt-fail.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "ea9403daa0bb6e8d5d8f91288f1e5b2472d9c916", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "022ea63e8dc5dc5fd09c719b756d05b605d03277", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "55bad5c2f5600e4b73b3d8445c8ed477c6195d70", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "7802834b3a7b98a6d0f8ac692ed1964b97ce08f9", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "ace0d3720111e5a9c8d75356dbc57817b8525b15", "filename": "src/test/run-pass/expr-alt.rs", "status": "modified", "additions": 30, "deletions": 60, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6d886a739def86a4f554dfcd59e6012cb839a7c8", "filename": "src/test/run-pass/expr-block-box.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d7ac6ee489b261a320b5a7c5b74ecc7146027fec", "filename": "src/test/run-pass/expr-block-fn.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a3f75ebd44592d68bb83a7e7672ce672d5439a94", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "808191121069ce4af7d81f76b58042270b75ea2a", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4d22b7572b2278ae302d133219a541f7174f284a", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "20c3d8e71f659637d3547340499cf3d0e5c6c129", "filename": "src/test/run-pass/expr-block-ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-ref.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d15d4d5acfffcf42005034012c6008070e1afce7", "filename": "src/test/run-pass/expr-block-slot.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-slot.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "cb87ae862d4689b066883ae8b5c63c5c29c3a19d", "filename": "src/test/run-pass/expr-block.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "80018c41a937c84998ae6bddf66143bdc64938e3", "filename": "src/test/run-pass/expr-elseif-ref.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-elseif-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-elseif-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-elseif-ref.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4215312edb6e019f0ea1b9b0c6dda8d5b2765872", "filename": "src/test/run-pass/expr-elseif-ref2.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-elseif-ref2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-elseif-ref2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-elseif-ref2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9187e537f85a829a7ac99a84b083601e10a25168", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9bb7713757e8c8dc276b9dd92c2719c42cfe76c5", "filename": "src/test/run-pass/expr-if-box.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3d11fd0325badd26035eae2beb3beae412306cbd", "filename": "src/test/run-pass/expr-if-fail-all.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-fail-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-fail-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-fail-all.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "0ab671ac6993e4ccaaf6fd5e11359a8016476dcb", "filename": "src/test/run-pass/expr-if-fail.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-fail.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "0f0e4fe4eed84b257e02a710886c065c1649afaf", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4ee278447493527d50bf8972dfbfc8c7758c008f", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d01d46ffd014c336b69922b15a7112b55672e042", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4020ba3d13bb521cf1acde633662e38a1859c39a", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f728daaedfddb241977aec6462db6ed9ebaa5524", "filename": "src/test/run-pass/expr-if.rs", "status": "modified", "additions": 35, "deletions": 63, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexpr-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "8f65d7a428f43310c0c751e9636fdbc583a64947", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9fb719a43a8233daa4e1692dfa1f7f3c9e3925c3", "filename": "src/test/run-pass/fact.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffact.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a547a24063d7e4ce1f287f650dbd89a593d7a3b3", "filename": "src/test/run-pass/float-signature.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloat-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloat-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-signature.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "177293f28a38a3c83bad32fb81e157eb9c246613", "filename": "src/test/run-pass/float.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "8e892c724a1ecb17f3ebe9462fab4cea8d524b01", "filename": "src/test/run-pass/float2.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d14a85ed749ef7a0f8e7e3730b380451fb78cc1e", "filename": "src/test/run-pass/floatlits.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloatlits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffloatlits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloatlits.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "263ef7f63b2dfee5e1ac18e02b3337605d0b935d", "filename": "src/test/run-pass/fn-expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-expr.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "05a676b24d2d9b4825037d3edc0b919a444fd955", "filename": "src/test/run-pass/fn-lval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffn-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffn-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-lval.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "39ed0c991a84dbb8a6fe6a3c6beb515e12728098", "filename": "src/test/run-pass/foreach-box-drop.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "14489a40e441a90d24a5ed51827a79ac752babc8", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f2def141be7285b060cc5b752de40315109a9cb3", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1d906057f1e40a3574e1b1ddeaf49b3923d44c03", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "270c658cd43918033004802b97a9d4bac45b8a36", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e718aa64c8c4cae440b53ee4baeb0434118c35b8", "filename": "src/test/run-pass/foreach-simple.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fforeach-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "fdf6da1bfda5fa3c262751e17bbbc48da88aaec6", "filename": "src/test/run-pass/fun-call-variants.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "107eb6953dea64138bbaf18c59a45d13ef81a062", "filename": "src/test/run-pass/fun-indirect-call.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "179edf8365cdf47dbf2f23df137219737e85026f", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "048fcb91934c4eb1e6357380633ed84ddde9a0e7", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "59fd159ec2d4040c867a58a68ae086c7c2a1013f", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "56483cd9b94285770c9be650183f0debba994fb1", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "18e5ca2f8fc741d98ebd21bc099287305ee14be4", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1415448ffefaae54671053706f6f74715eacc1bd", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "78d12832ba764198607611c21372bbd412ba3647", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "47200fd10838b78436fbb14d9b6ddb2a71dea80c", "filename": "src/test/run-pass/generic-fn-box.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1e00481afa11cb4ce671a0c86f84c4b62553cdef", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "65c3492d5d1d2f24cbac96625dea27f6a2b908d6", "filename": "src/test/run-pass/generic-fn-twice.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-twice.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b010b6ea060a0bf8fbacb3c30c9e6590b891c046", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1b04cb0f8295aa3e11afb4d3e00ae5d8f60437de", "filename": "src/test/run-pass/generic-iter-frame.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9e90a448d32ed4f9ba4c1f65f67ea3d86355339e", "filename": "src/test/run-pass/generic-obj-with-derived-type.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d955a6bb9b78ab3f7dca4df68b1715037616ed9b", "filename": "src/test/run-pass/generic-obj.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "fd007f5862fd9e7417b6ec2d8b86ad944e39be6e", "filename": "src/test/run-pass/generic-recursive-tag.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "84c72a761449887395445067f70ab634202ea478", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9d335f583eb456a0287cb7b910ecaca2aab69b23", "filename": "src/test/run-pass/generic-tag-corruption.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "7b4ff49e9c21f7c5ad2450c0a9b26e26b5e27a0e", "filename": "src/test/run-pass/generic-tag-local.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-local.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6bac06e8e492b0a2252e389e40e3e84440055a91", "filename": "src/test/run-pass/generic-tag-values.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "ee00e94817bba9c3e5af2a3c850bf4cecc018a98", "filename": "src/test/run-pass/generic-tag.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b8a7b38934a46105604204ab10d1b162c6f37edc", "filename": "src/test/run-pass/generic-temporary.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "96f6520b0813a9b581d0e6af3c583fad4f8f9599", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "77ca707ae2fd196b21357a2dca1333e363418179", "filename": "src/test/run-pass/generic-type-synonym.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "66d210d319ce4fbae3c8272098e350c337263688", "filename": "src/test/run-pass/generic-type.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "5e442db7fbea203d9c9e3449171e54a7a86622e6", "filename": "src/test/run-pass/hello.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhello.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3bb40f924e2b5dd9d0847798cf4c28861318b927", "filename": "src/test/run-pass/i32-sub.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi32-sub.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b890a3ef8e69d101afb9cf6e33b0a55b87a1b884", "filename": "src/test/run-pass/i8-incr.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi8-incr.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "5ff8f80044c4b5407a59fad8f474c64f49d3bdb1", "filename": "src/test/run-pass/if-bot.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fif-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fif-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-bot.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "46d9980417a087ad0b3d67aa51a417e722027376", "filename": "src/test/run-pass/import2.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1ee63558fd54c93a1fcd5bf2b4c44743b78f1cc0", "filename": "src/test/run-pass/import3.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport3.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "16c5b4de82c6aacb8c32981c6a18d5ccde3af011", "filename": "src/test/run-pass/import4.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport4.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "2588485bfdafeeb93f875178791f3b7369ecdb0b", "filename": "src/test/run-pass/import8.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fimport8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport8.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f9ef1b040de87cb649d205130710f7cd68d58fa0", "filename": "src/test/run-pass/inner-module.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Finner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Finner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finner-module.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "491c8ad6f28a761c859e1e5e36ddfdba6829d3a0", "filename": "src/test/run-pass/int.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fint.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "24131877a9b553625d4d69bbe50fdbde603200b8", "filename": "src/test/run-pass/integral-indexing.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "df18f786f0596dfc204d18b784ec94dd8ca8a587", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "489fe8c39a3df044d3fa04743c3356e6d7c76628", "filename": "src/test/run-pass/item-name-overload.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fitem-name-overload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fitem-name-overload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-name-overload.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e1c97af2761b626b6c0165b16dd5b00e8e77a34a", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "5df91d2d4839f38c96e8c32a837e3b45fc45d1f4", "filename": "src/test/run-pass/iter-ret.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fiter-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fiter-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-ret.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "fb38efd1ac8b7abdfead9ac60c1c28ad0ccaaf95", "filename": "src/test/run-pass/large-records.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flarge-records.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flarge-records.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flarge-records.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "613f7fdc74818e73cdb63def7bb96ca9c19432a2", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3b65277ef7e2943749f4e9d883c11f49ec033e68", "filename": "src/test/run-pass/lazy-init.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flazy-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flazy-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-init.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c7917183eeac006f4290d443028938e6b7583fb7", "filename": "src/test/run-pass/leak-box-as-tydesc.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fleak-box-as-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fleak-box-as-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleak-box-as-tydesc.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3b4f2027250bb8b21c89f428b09a92636cf18b3e", "filename": "src/test/run-pass/leak-tag-copy.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fleak-tag-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fleak-tag-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleak-tag-copy.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e92d47f52d6e15d1c6aff20b98532197725a4cc8", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 266, "deletions": 273, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b054d217d4bef28bbcf98d01c2040aeea68e76e4", "filename": "src/test/run-pass/lib-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-box.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3d045920d1ddae88facce4027059a4f1aa517831", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 191, "deletions": 233, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "11a8ee2ebd49e83fd9ce0df4102d8c59417e4a1e", "filename": "src/test/run-pass/lib-fs.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-fs.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d044ae0f6480a78875d36be6883fa58a3bbc7a20", "filename": "src/test/run-pass/lib-getopts.rs", "status": "modified", "additions": 315, "deletions": 384, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-getopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-getopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-getopts.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "fce4a92ac60f24fcd02c312e9f138c0196662c29", "filename": "src/test/run-pass/lib-int.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "91ceadf439dab5f35ac1db787a42c33d6c0ac4b3", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "dc68fefddf39c9dbaeda3d61996a3d404cd90b5d", "filename": "src/test/run-pass/lib-list.rs", "status": "modified", "additions": 34, "deletions": 43, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-list.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d78bd0f4df08430abf63569f7f49d0f86793e2bd", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 259, "deletions": 339, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9b706cc60f89eef5d9bce39b00aeee593d98c0e2", "filename": "src/test/run-pass/lib-option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-option.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "96d94aa03da8e72845c852c044435d88ffc29d33", "filename": "src/test/run-pass/lib-qsort.rs", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "6dcbb3d6fa98be93ab5507c4abebd8b1548fc0c2", "filename": "src/test/run-pass/lib-qsort3.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-qsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-qsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort3.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f09b7eeddbbf6abbac41d4cd8ad4eac62974b96c", "filename": "src/test/run-pass/lib-rand.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-rand.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3fb53b3e69e2a23b5b4eff33cbaafb13e748fa00", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "20bbf6aefc54dcfab1df9d49bff5421a0b5f937a", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 21, "deletions": 44, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a00862f636399bd9059231fb374e5a9f5b35be42", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "97ed9169763994f7fba4879a03841642a958220b", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 98, "deletions": 115, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "8507c8a0ebd78907924a032429eaf769a85a85b3", "filename": "src/test/run-pass/lib-task.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-task.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4b001cb27db1b05b7a630982a345d4834dfbea29", "filename": "src/test/run-pass/lib-uint.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-uint.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "00ad2b848038fb0a02493348e274b8ebcb27c1d1", "filename": "src/test/run-pass/lib-vec-str-conversions.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9bcd098fc370f259eab30a15f11221a7bb465167", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 56, "deletions": 68, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "89b7aeb735a6ece85d9af16d21c37b4ca358fb38", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e81c0d12fd2de3a9976b72ef3061f8f417bda745", "filename": "src/test/run-pass/list.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flist.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "aa511bc4f94eea447962e07654e8d5092a0cf729", "filename": "src/test/run-pass/log-err-phi.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flog-err-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flog-err-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-err-phi.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "57e8492da9f7bc576bc93e4cc895ffbd24084eca", "filename": "src/test/run-pass/long-while.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flong-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Flong-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flong-while.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "229942176fcb8f129d8397ebdf0d2d1a128d2cf5", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "17c512e90b04bf81c98e6fcdf4e03860ae2392e5", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c6b8de4e400819590753b50e400160a5fdfc0495", "filename": "src/test/run-pass/mlist.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "210fa504902e725b81a3f6804093675400d61626", "filename": "src/test/run-pass/move-2.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmove-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmove-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "1433dcf23a3e6f824420b9d5bd5a848fd27c2408", "filename": "src/test/run-pass/move-4.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmove-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmove-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "7b52a9e089a03718b0df2cff73db62f8037561e9", "filename": "src/test/run-pass/multi-src/bar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "63305812ef6344438ef744903d9c8149f7d0123f", "filename": "src/test/run-pass/multi-src/foo.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "90eaa93fda0b6978c89ab8eb4622b3fe1c9ad59c", "filename": "src/test/run-pass/multiline-comment.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmultiline-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmultiline-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiline-comment.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4ca26374494cb022ebd54dfd690f218e1577fcde", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "12d507979f2e598dc89e113ce928e0c7099896b8", "filename": "src/test/run-pass/mutable-vec-drop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "732d3a27177d56ca746ac98b632fed4fb64cb0f6", "filename": "src/test/run-pass/mutual-recursion-group.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "e3d514eba2032af2933a0b49870ab59e9c3d2d9f", "filename": "src/test/run-pass/native-mod-src/inner.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "d3f6dc30f371d4162c49b4ec3962d05d698bb0bd", "filename": "src/test/run-pass/native-opaque-type.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "eac66adb58a0a623fa67e041f73f0af71c1d9031", "filename": "src/test/run-pass/native-src/native.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9605d11e47c3edf51e825b3be2a33feafa9b8305", "filename": "src/test/run-pass/native2.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnative2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3e63ca0f45d8db1d4c6f6f0daae1cc1125ee73d8", "filename": "src/test/run-pass/nested-alts.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnested-alts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnested-alts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-alts.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "54b628c79c834a2ba40918de7464bfb063226730", "filename": "src/test/run-pass/nested-obj-self.rs", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnested-obj-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnested-obj-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-obj-self.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "3bf982b465e31d08c99d5cb07f6188b96a5d8263", "filename": "src/test/run-pass/nested-pattern.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-pattern.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "bc7e70e0d6f9801c8ed95644759c4d032b6647a0", "filename": "src/test/run-pass/obj-as.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-as.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "90a50354c405e2634c9ea56156a00d93e37575dc", "filename": "src/test/run-pass/obj-drop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-drop.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4797fcc71cdda4d5c666e3d7f51261fce78c672d", "filename": "src/test/run-pass/obj-dtor-2.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "25e08d5e115475d04618a4e0aa1bd4af4abcb2d4", "filename": "src/test/run-pass/obj-dtor.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "4c8f8d5a5c21fdfa46a805dcd1cc7218900be258", "filename": "src/test/run-pass/obj-recursion.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-recursion.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "f46121a26fcd07f2466acbbe7f0a16e3c5a0147c", "filename": "src/test/run-pass/obj-return-polytypes.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-return-polytypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-return-polytypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-return-polytypes.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b1bbbaaf8a49c493aec58b4d159abafdf3b0ae67", "filename": "src/test/run-pass/obj-self-2.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-2.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "b8cb1b2d84aa8a1629d911ba05fcf8eb4f4cac19", "filename": "src/test/run-pass/obj-self-3.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-3.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "bbf840ada544c0b4f0a949925487f51a8d910ff0", "filename": "src/test/run-pass/obj-self-4.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-4.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "edbaa872f4be9b170b4559403e36d985bef46c2b", "filename": "src/test/run-pass/obj-self.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "c185bff7ba03597afcb991c46eae3c779b783500", "filename": "src/test/run-pass/obj-with-vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a2b860eed28fcfeaebe1cea3e066b980c9d0e4dd", "filename": "src/test/run-pass/opeq.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fopeq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fopeq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fopeq.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "624d431b45abacd53b0b50362822dce0d49b6653", "filename": "src/test/run-pass/operator-associativity.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-associativity.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "a97a4efae7035b7cf3547f890b64cedbb5ce6cc0", "filename": "src/test/run-pass/output-slot-variants.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Foutput-slot-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Foutput-slot-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foutput-slot-variants.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}, {"sha": "9f8ea5019a914d4f8e69908fee3e3f57e86e4b78", "filename": "src/test/run-pass/over-constrained-vregs.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce72993488af962892ea3991aef7b9f6e72e40f0/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs?ref=ce72993488af962892ea3991aef7b9f6e72e40f0"}]}