{"sha": "459f3b2cfa0e618d6e28ce564a363a9477567f71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OWYzYjJjZmEwZTYxOGQ2ZTI4Y2U1NjRhMzYzYTk0Nzc1NjdmNzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:49:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:49:57Z"}, "message": "rollup merge of #20056: MrFloya/iter_rename\n\nConflicts:\n\tsrc/libcollections/bit.rs\n\tsrc/libcore/str.rs", "tree": {"sha": "4d308abea1b026ac9db0e538f6d01170b173c89f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d308abea1b026ac9db0e538f6d01170b173c89f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/459f3b2cfa0e618d6e28ce564a363a9477567f71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/459f3b2cfa0e618d6e28ce564a363a9477567f71", "html_url": "https://github.com/rust-lang/rust/commit/459f3b2cfa0e618d6e28ce564a363a9477567f71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/459f3b2cfa0e618d6e28ce564a363a9477567f71/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6938d51122f37dd7ab213b88bc2d457c5a9da781", "url": "https://api.github.com/repos/rust-lang/rust/commits/6938d51122f37dd7ab213b88bc2d457c5a9da781", "html_url": "https://github.com/rust-lang/rust/commit/6938d51122f37dd7ab213b88bc2d457c5a9da781"}, {"sha": "22050e3ed44d9b4d79edced506b470a425e0d302", "url": "https://api.github.com/repos/rust-lang/rust/commits/22050e3ed44d9b4d79edced506b470a425e0d302", "html_url": "https://github.com/rust-lang/rust/commit/22050e3ed44d9b4d79edced506b470a425e0d302"}], "stats": {"total": 498, "additions": 248, "deletions": 250}, "files": [{"sha": "589e580cc912129fa5257763c567c7a0210be787", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -239,8 +239,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items { iter: self.data.iter() }\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.data.iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n@@ -260,8 +260,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems { iter: self.data.into_iter() }\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { iter: self.data.into_iter() }\n     }\n \n     /// Returns the greatest item in a queue, or `None` if it is empty.\n@@ -572,44 +572,44 @@ impl<T: Ord> BinaryHeap<T> {\n }\n \n /// `BinaryHeap` iterator.\n-pub struct Items<'a, T: 'a> {\n-    iter: slice::Items<'a, T>,\n+pub struct Iter <'a, T: 'a> {\n+    iter: slice::Iter<'a, T>,\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-pub struct MoveItems<T> {\n-    iter: vec::MoveItems<T>,\n+pub struct IntoIter<T> {\n+    iter: vec::IntoIter<T>,\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n pub struct Drain<'a, T: 'a> {"}, {"sha": "3b9b1eb1fb319f223259cadad983ce824cb9cc3c", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -186,7 +186,6 @@ fn blocks_for_bits(bits: uint) -> uint {\n     } else {\n         bits / u32::BITS + 1\n     }\n-\n }\n \n /// Computes the bitmask for the final word of the vector"}, {"sha": "ebd9bd1f5257e8016ee26bbf9c38a46cfd36cd80", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -88,36 +88,36 @@ pub struct BTreeMap<K, V> {\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n-struct AbsEntries<T> {\n+struct AbsIter<T> {\n     lca: T,\n     left: RingBuf<T>,\n     right: RingBuf<T>,\n     size: uint,\n }\n \n /// An iterator over a BTreeMap's entries.\n-pub struct Entries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<Traversal<'a, K, V>>\n+pub struct Iter<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<MutTraversal<'a, K, V>>\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-pub struct MoveEntries<K, V> {\n-    inner: AbsEntries<MoveTraversal<K, V>>\n+pub struct IntoIter<K, V> {\n+    inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n@@ -929,7 +929,7 @@ enum StackOp<T> {\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        Iterator<(K, V)> for AbsEntries<T> {\n+        Iterator<(K, V)> for AbsIter<T> {\n     // This function is pretty long, but only because there's a lot of cases to consider.\n     // Our iterator represents two search paths, left and right, to the smallest and largest\n     // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n@@ -995,7 +995,7 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        DoubleEndedIterator<(K, V)> for AbsEntries<T> {\n+        DoubleEndedIterator<(K, V)> for AbsIter<T> {\n     // next_back is totally symmetric to next\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n@@ -1032,34 +1032,34 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Entries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Iter<'a, K, V> {}\n \n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {}\n \n \n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> DoubleEndedIterator<(K, V)> for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-impl<K, V> ExactSizeIterator<(K, V)> for MoveEntries<K, V> {}\n+impl<K, V> ExactSizeIterator<(K, V)> for IntoIter<K, V> {}\n \n \n impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n@@ -1140,10 +1140,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a, K, V> {\n         let len = self.len();\n-        Entries {\n-            inner: AbsEntries {\n+        Iter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1172,10 +1172,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, K, V> {\n         let len = self.len();\n-        MutEntries {\n-            inner: AbsEntries {\n+        IterMut {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&mut self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1201,10 +1201,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        MoveEntries {\n-            inner: AbsEntries {\n+        IntoIter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),"}, {"sha": "2c3c546fdb7ff9c924984e491c4e625e6b17443b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -1382,14 +1382,14 @@ pub enum TraversalItem<K, V, E> {\n }\n \n /// A traversal over a node's entries and edges\n-pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n-                                                              slice::Items<'a, V>>,\n-                                                              slice::Items<'a, Node<K, V>>>>;\n+pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                              slice::Iter<'a, V>>,\n+                                                              slice::Iter<'a, Node<K, V>>>>;\n \n /// A mutable traversal over a node's entries and edges\n-pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n-                                                                 slice::MutItems<'a, V>>,\n-                                                                 slice::MutItems<'a, Node<K, V>>>>;\n+pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                                 slice::IterMut<'a, V>>,\n+                                                                 slice::IterMut<'a, Node<K, V>>>>;\n \n /// An owning traversal over a node's entries and edges\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;"}, {"sha": "3b403d45d82e6f3bc77c496c05eabe81deb98783", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -13,7 +13,7 @@\n \n use core::prelude::*;\n \n-use btree_map::{BTreeMap, Keys, MoveEntries};\n+use btree_map::{BTreeMap, Keys};\n use std::hash::Hash;\n use core::borrow::BorrowFrom;\n use core::default::Default;\n@@ -33,37 +33,37 @@ pub struct BTreeSet<T>{\n }\n \n /// An iterator over a BTreeSet's items.\n-pub struct Items<'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-pub struct MoveItems<T> {\n-    iter: Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>\n+pub struct IntoIter<T> {\n+    iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Difference<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct SymmetricDifference<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Intersection<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Union<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n@@ -107,8 +107,8 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items { iter: self.map.keys() }\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter { iter: self.map.keys() }\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n@@ -124,10 +124,10 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        MoveItems { iter: self.map.into_iter().map(first) }\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n }\n \n@@ -151,8 +151,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n@@ -175,8 +175,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> SymmetricDifference<'a, T> {\n+        SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n@@ -199,8 +199,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> Intersection<'a, T> {\n+        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the union, in ascending order.\n@@ -220,8 +220,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Return the number of elements in the set\n@@ -544,24 +544,24 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n@@ -573,7 +573,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -585,7 +585,7 @@ impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -597,7 +597,7 @@ impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -615,7 +615,7 @@ impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {"}, {"sha": "de2a7307440120f4d9f84a6daa51120628a3ad49", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -51,21 +51,21 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #11820: the &'a Option<> of the Link stops clone working.\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-impl<'a,T> Copy for Items<'a,T> {}\n+impl<'a,T> Copy for Iter<'a,T> {}\n \n /// An iterator over mutable references to the items of a `DList`.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n@@ -74,7 +74,7 @@ pub struct MutItems<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[deriving(Clone)]\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     list: DList<T>\n }\n \n@@ -394,19 +394,19 @@ impl<T> DList<T> {\n     /// Provides a forward iterator.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n             None => Rawlink::none(),\n         };\n-        MutItems{\n+        IterMut{\n             nelem: self.len(),\n             head: head_raw,\n             tail: self.list_tail,\n@@ -417,8 +417,8 @@ impl<T> DList<T> {\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems{list: self}\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter{list: self}\n     }\n \n     /// Returns `true` if the `DList` is empty.\n@@ -579,7 +579,7 @@ impl<T> Drop for DList<T> {\n }\n \n \n-impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n+impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -598,7 +598,7 @@ impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -612,9 +612,9 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a A> for Items<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n \n-impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -636,7 +636,7 @@ impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -650,7 +650,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a mut A> for MutItems<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n \n /// Allows mutating a `DList` while iterating.\n pub trait ListInsertion<A> {\n@@ -664,8 +664,8 @@ pub trait ListInsertion<A> {\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-// private methods for MutItems\n-impl<'a, A> MutItems<'a, A> {\n+// private methods for IterMut\n+impl<'a, A> IterMut<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n@@ -687,7 +687,7 @@ impl<'a, A> MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n+impl<'a, A> ListInsertion<A> for IterMut<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n@@ -702,7 +702,7 @@ impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     }\n }\n \n-impl<A> Iterator<A> for MoveItems<A> {\n+impl<A> Iterator<A> for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -712,7 +712,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n+impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }"}, {"sha": "fd04ce94247b7f2a352556dc0c6d519a4b4f3fae", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -178,8 +178,8 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns an iterator over an `EnumSet`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<E> {\n-        Items::new(self.bits)\n+    pub fn iter(&self) -> Iter<E> {\n+        Iter::new(self.bits)\n     }\n }\n \n@@ -208,18 +208,18 @@ impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n }\n \n /// An iterator over an EnumSet\n-pub struct Items<E> {\n+pub struct Iter<E> {\n     index: uint,\n     bits: uint,\n }\n \n-impl<E:CLike> Items<E> {\n-    fn new(bits: uint) -> Items<E> {\n-        Items { index: 0, bits: bits }\n+impl<E:CLike> Iter<E> {\n+    fn new(bits: uint) -> Iter<E> {\n+        Iter { index: 0, bits: bits }\n     }\n }\n \n-impl<E:CLike> Iterator<E> for Items<E> {\n+impl<E:CLike> Iterator<E> for Iter<E> {\n     fn next(&mut self) -> Option<E> {\n         if self.bits == 0 {\n             return None;"}, {"sha": "d4bd9b5228a8a069a3a11af4895a7e71d68512d2", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -377,8 +377,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items {\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter {\n             tail: self.tail,\n             head: self.head,\n             ring: unsafe { self.buffer_as_slice() }\n@@ -403,8 +403,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        MutItems {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        IterMut {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n@@ -415,8 +415,8 @@ impl<T> RingBuf<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems {\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter {\n             inner: self,\n         }\n     }\n@@ -1123,13 +1123,13 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n     head: uint\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1147,7 +1147,7 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1158,9 +1158,9 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (len, _) = self.size_hint();\n@@ -1178,19 +1178,19 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-// FIXME This was implemented differently from Items because of a problem\n+// FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n     head: uint,\n     cap: uint,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1211,7 +1211,7 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1225,14 +1225,14 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n // A by-value RingBuf iterator\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         self.inner.pop_front()\n@@ -1245,14 +1245,14 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n pub struct Drain<'a, T: 'a> {"}, {"sha": "d6d94f57acf45b88c6739aa9c3736980c833a799", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -37,7 +37,7 @@\n //!\n //! ## Structs\n //!\n-//! There are several structs that are useful for slices, such as `Items`, which\n+//! There are several structs that are useful for slices, such as `Iter`, which\n //! represents iteration over a slice.\n //!\n //! ## Traits\n@@ -104,7 +104,7 @@ use self::Direction::*;\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n-pub use core::slice::{Items, MutItems, PartialEqSliceExt};\n+pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n@@ -771,7 +771,7 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an iterator over the slice\n     #[unstable = \"iterator type may change\"]\n-    fn iter(&self) -> Items<T>;\n+    fn iter(&self) -> Iter<T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n@@ -970,7 +970,7 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an iterator that allows modifying each value\n     #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(&mut self) -> MutItems<T>;\n+    fn iter_mut(&mut self) -> IterMut<T>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[unstable = \"name may change\"]\n@@ -1137,7 +1137,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n         core_slice::SliceExt::iter(self)\n     }\n \n@@ -1246,7 +1246,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         core_slice::SliceExt::iter_mut(self)\n     }\n "}, {"sha": "fa0e4a2340e2aac37cad0a601e384b6efd4b44aa", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -888,7 +888,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = self.ptr;\n             let cap = self.cap;\n@@ -899,7 +899,7 @@ impl<T> Vec<T> {\n                 ptr.offset(self.len() as int) as *const T\n             };\n             mem::forget(self);\n-            MoveItems { allocation: ptr, cap: cap, ptr: begin, end: end }\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n     }\n \n@@ -1402,21 +1402,21 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n }\n \n /// An iterator that moves out of a vector.\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n \n-impl<T> MoveItems<T> {\n+impl<T> IntoIter<T> {\n     /// Drops all items that have not yet been moved and returns the empty vector.\n     #[inline]\n     #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n-            let MoveItems { allocation, cap, ptr: _ptr, end: _end } = self;\n+            let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n             Vec { ptr: allocation, cap: cap, len: 0 }\n         }\n@@ -1427,7 +1427,7 @@ impl<T> MoveItems<T> {\n     pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1461,7 +1461,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1484,10 +1484,10 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n #[unsafe_destructor]\n-impl<T> Drop for MoveItems<T> {\n+impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         if self.cap != 0 {"}, {"sha": "999025840caaabb8dce8884d69afe6d31f2e8e90", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -176,8 +176,8 @@ impl<V> VecMap<V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n-        Entries {\n+    pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n+        Iter {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter()\n@@ -207,8 +207,8 @@ impl<V> VecMap<V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'r>(&'r mut self) -> MutEntries<'r, V> {\n-        MutEntries {\n+    pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n+        IterMut {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter_mut()\n@@ -235,13 +235,13 @@ impl<V> VecMap<V> {\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(&mut self) -> MoveItems<V> {\n+    pub fn into_iter(&mut self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n         }\n \n         let values = replace(&mut self.v, vec!());\n-        MoveItems { iter: values.into_iter().enumerate().filter_map(filter) }\n+        IntoIter { iter: values.into_iter().enumerate().filter_map(filter) }\n     }\n \n     /// Return the number of elements in the map.\n@@ -605,42 +605,42 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-pub struct Entries<'a, V:'a> {\n+pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::Items<'a, Option<V>>\n+    iter: slice::Iter<'a, Option<V>>\n }\n \n-iterator! { impl Entries -> (uint, &'a V), as_ref }\n-double_ended_iterator! { impl Entries -> (uint, &'a V), as_ref }\n+iterator! { impl Iter -> (uint, &'a V), as_ref }\n+double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, V:'a> {\n+pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::MutItems<'a, Option<V>>\n+    iter: slice::IterMut<'a, Option<V>>\n }\n \n-iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n-double_ended_iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n+iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n+double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), uint, Entries<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n \n /// An iterator over the values of a map.\n pub struct Values<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), &'a V, Entries<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-pub struct MoveItems<V> {\n+pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n     (uint, V),\n-    Enumerate<vec::MoveItems<Option<V>>>,\n+    Enumerate<vec::IntoIter<Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n@@ -662,11 +662,11 @@ impl<'a, V> DoubleEndedIterator<&'a V> for Values<'a, V> {\n }\n \n \n-impl<V> Iterator<(uint, V)> for MoveItems<V> {\n+impl<V> Iterator<(uint, V)> for IntoIter<V> {\n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<V> DoubleEndedIterator<(uint, V)> for MoveItems<V> {\n+impl<V> DoubleEndedIterator<(uint, V)> for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n "}, {"sha": "fb26450ec758e063bb726af2811b2162ec81a958", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -89,7 +89,7 @@ pub struct Formatter<'a> {\n     precision: Option<uint>,\n \n     buf: &'a mut (FormatWriter+'a),\n-    curarg: slice::Items<'a, Argument<'a>>,\n+    curarg: slice::Iter<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n "}, {"sha": "26684864c4c49fac5caa115c34853204e1b9355b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -67,7 +67,7 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-    fn iter<'a>(&'a self) -> Items<'a, T>;\n+    fn iter<'a>(&'a self) -> Iter<'a, T>;\n     fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n                     where P: FnMut(&T) -> bool;\n     fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n@@ -92,7 +92,7 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n     fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n@@ -141,15 +141,15 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n+                Iter{ptr: p,\n                       end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                Items{ptr: p,\n+                Iter{ptr: p,\n                       end: p.offset(self.len() as int),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -286,15 +286,15 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n+                IterMut{ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                MutItems{ptr: p,\n+                IterMut{ptr: p,\n                          end: p.offset(self.len() as int),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -655,7 +655,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// The shared definition of the `Item` and `MutItems` iterators\n+// The shared definition of the `Item` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n@@ -738,14 +738,14 @@ macro_rules! make_slice {\n \n /// Immutable slice iterator\n #[experimental = \"needs review\"]\n-pub struct Items<'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n+impl<'a, T> ops::Slice<uint, [T]> for Iter<'a, T> {\n     fn as_slice_(&self) -> &[T] {\n         self.as_slice()\n     }\n@@ -763,7 +763,7 @@ impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> Items<'a, T> {\n+impl<'a, T> Iter<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n@@ -774,20 +774,20 @@ impl<'a, T> Items<'a, T> {\n     }\n }\n \n-impl<'a,T> Copy for Items<'a,T> {}\n+impl<'a,T> Copy for Iter<'a,T> {}\n \n-iterator!{struct Items -> *const T, &'a T}\n+iterator!{struct Iter -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n #[stable]\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n@@ -813,14 +813,14 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// Mutable slice iterator.\n #[experimental = \"needs review\"]\n-pub struct MutItems<'a, T: 'a> {\n+pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n+impl<'a, T> ops::Slice<uint, [T]> for IterMut<'a, T> {\n     fn as_slice_<'b>(&'b self) -> &'b [T] {\n         make_slice!(T -> &'b [T]: self.ptr, self.end)\n     }\n@@ -839,7 +839,7 @@ impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n }\n \n #[experimental]\n-impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n+impl<'a, T> ops::SliceMut<uint, [T]> for IterMut<'a, T> {\n     fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n         make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n     }\n@@ -857,7 +857,7 @@ impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> MutItems<'a, T> {\n+impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n@@ -870,10 +870,10 @@ impl<'a, T> MutItems<'a, T> {\n     }\n }\n \n-iterator!{struct MutItems -> *mut T, &'a mut T}\n+iterator!{struct IterMut -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n /// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n /// can be implemented once."}, {"sha": "f4a9e7e3f78220380af197ac7bac7842770e4b09", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -185,7 +185,7 @@ Section: Iterators\n /// Created with the method `.chars()`.\n #[deriving(Clone, Copy)]\n pub struct Chars<'a> {\n-    iter: slice::Items<'a, u8>\n+    iter: slice::Iter<'a, u8>\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -866,7 +866,7 @@ Section: Misc\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>)\n+fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n                                 -> Result<(), Utf8Error> {\n     let whole = iter.as_slice();\n     loop {\n@@ -1575,7 +1575,6 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n-\n impl<'a> Iterator<&'a str> for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }"}, {"sha": "88483b6c935435dc440afb03026c995fb4743af0", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -63,7 +63,7 @@ impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n }\n \n impl<'a,T> MaybeOwnedVector<'a,T> {\n-    pub fn iter(&'a self) -> slice::Items<'a,T> {\n+    pub fn iter(&'a self) -> slice::Iter<'a,T> {\n         match self {\n             &Growable(ref v) => v.as_slice().iter(),\n             &Borrowed(ref v) => v.iter(),"}, {"sha": "97301628a4512aa6f65cf37740e2bde2b1c5046b", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -370,7 +370,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n fn enabled(level: u32,\n            module: &str,\n-           iter: slice::Items<directive::LogDirective>)\n+           iter: slice::Iter<directive::LogDirective>)\n            -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {"}, {"sha": "4383192edafb05485f4984190b8ee7c6c17edaf9", "filename": "src/libregex/re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -540,8 +540,8 @@ impl Regex {\n }\n \n pub enum NamesIter<'a> {\n-    NamesIterNative(::std::slice::Items<'a, Option<&'static str>>),\n-    NamesIterDynamic(::std::slice::Items<'a, Option<String>>)\n+    NamesIterNative(::std::slice::Iter<'a, Option<&'static str>>),\n+    NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n }\n \n impl<'a> Iterator<Option<String>> for NamesIter<'a> {"}, {"sha": "967e7f070c5ae19697571b910e4234f723052c92", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -65,7 +65,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<slice::Items<'a, Option<ast::DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<ast::DefId>>> {\n         self.items.iter().enumerate()\n     }\n "}, {"sha": "6ae639e0313e0adaa7bd8e88b764f42586f649cb", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -18,7 +18,7 @@ use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n-use std::slice::Items;\n+use std::slice::Iter;\n use std::vec::Vec;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -400,7 +400,7 @@ impl<T> VecPerParamSpace<T> {\n         &self.get_slice(space)[index]\n     }\n \n-    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n         self.content.iter()\n     }\n "}, {"sha": "8028971a46346270ba41d91bfa83dae77c25d327", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -19,7 +19,7 @@ use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::rc::Rc;\n-use std::slice::Items;\n+use std::slice::Iter;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -304,7 +304,7 @@ impl<'tcx> ObligationCause<'tcx> {\n }\n \n impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n@@ -338,7 +338,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n }\n \n impl<'tcx, N> VtableImplData<'tcx, N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()\n     }\n \n@@ -365,7 +365,7 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n }\n \n impl<N> VtableBuiltinData<N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()\n     }\n "}, {"sha": "692f120737a5b6d1ad52a63ef7d4808c6ea1677d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -914,8 +914,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n-        MutEntries { inner: self.table.iter_mut() }\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut { inner: self.table.iter_mut() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n@@ -936,10 +936,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n \n-        MoveEntries {\n+        IntoIter {\n             inner: self.table.into_iter().map(last_two)\n         }\n     }\n@@ -1306,16 +1306,16 @@ pub struct Entries<'a, K: 'a, V: 'a> {\n }\n \n /// HashMap mutable values iterator\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n-    inner: table::MutEntries<'a, K, V>\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator\n-pub struct MoveEntries<K, V> {\n+pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n         (K, V),\n-        table::MoveEntries<K, V>,\n+        table::IntoIter<K, V>,\n         fn((SafeHash, K, V)) -> (K, V),\n     >\n }\n@@ -1374,12 +1374,12 @@ impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }"}, {"sha": "3d5be0429631e5fc85817a4b68c05b5bec42e710", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -23,7 +23,7 @@ use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n-use super::map::{mod, HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n+use super::map::{mod, HashMap, Keys, INITIAL_CAPACITY};\n \n // Future Optimization (FIXME!)\n // =============================\n@@ -736,7 +736,7 @@ pub struct Iter<'a, K: 'a> {\n \n /// HashSet move iterator\n pub struct IntoIter<K> {\n-    iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n+    iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator"}, {"sha": "8f2152c5a9ded3ce48be6add6520cf17df4c6b8b", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -664,17 +664,17 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n-    pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n-        MutEntries {\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut {\n             iter: self.raw_buckets(),\n             elems_left: self.size(),\n         }\n     }\n \n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n-        MoveEntries {\n+        IntoIter {\n             iter: RawBuckets {\n                 raw: raw,\n                 hashes_end: hashes_end,\n@@ -776,13 +776,13 @@ pub struct Entries<'a, K: 'a, V: 'a> {\n }\n \n /// Iterator over mutable references to entries in a table.\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n     elems_left: uint,\n }\n \n /// Iterator over the entries in a table, consuming the table.\n-pub struct MoveEntries<K, V> {\n+pub struct IntoIter<K, V> {\n     table: RawTable<K, V>,\n     iter: RawBuckets<'static, K, V>\n }\n@@ -809,7 +809,7 @@ impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n@@ -825,7 +825,7 @@ impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n     }\n }\n \n-impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(SafeHash, K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;"}, {"sha": "9b42a8f75406900b0819e45c9a54595959b59f86", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -73,9 +73,9 @@ impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n     }\n }\n \n-// HACK(eddyb) move this into libstd (value wrapper for slice::Items).\n+// HACK(eddyb) move this into libstd (value wrapper for slice::Iter).\n #[deriving(Clone)]\n-pub struct Values<'a, T:'a>(pub slice::Items<'a, T>);\n+pub struct Values<'a, T:'a>(pub slice::Iter<'a, T>);\n \n impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n     fn next(&mut self) -> Option<T> {"}, {"sha": "cf0201294ae54c02e9d941eafd370a22ea06c0ba", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -766,7 +766,7 @@ impl<'a> MethodDef<'a> {\n         let fields = if raw_fields.len() > 0 {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::MoveItems<(Span, Option<Ident>, P<Expr>)>>\n+            let mut other_fields: Vec<vec::IntoIter<(Span, Option<Ident>, P<Expr>)>>\n                 = raw_fields.collect();\n             first_field.map(|(span, opt_id, field)| {\n                 FieldInfo {"}, {"sha": "3023c547fb05302e1eccc647a0c16577788085bc", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -45,7 +45,7 @@ impl<T> OwnedSlice<T> {\n         &*self.data\n     }\n \n-    pub fn move_iter(self) -> vec::MoveItems<T> {\n+    pub fn move_iter(self) -> vec::IntoIter<T> {\n         self.into_vec().into_iter()\n     }\n "}, {"sha": "946181770c8e95d7437c88b21151046ba51aeaa6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use self::SmallVectorRepr::*;\n-use self::MoveItemsRepr::*;\n+use self::IntoIterRepr::*;\n \n use std::mem;\n use std::slice;\n@@ -111,17 +111,17 @@ impl<T> SmallVector<T> {\n \n     /// Deprecated: use `into_iter`.\n     #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveItems<T> {\n+    pub fn move_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n \n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         let repr = match self.repr {\n             Zero => ZeroIterator,\n             One(v) => OneIterator(v),\n             Many(vs) => ManyIterator(vs.into_iter())\n         };\n-        MoveItems { repr: repr }\n+        IntoIter { repr: repr }\n     }\n \n     pub fn len(&self) -> uint {\n@@ -135,17 +135,17 @@ impl<T> SmallVector<T> {\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n-pub struct MoveItems<T> {\n-    repr: MoveItemsRepr<T>,\n+pub struct IntoIter<T> {\n+    repr: IntoIterRepr<T>,\n }\n \n-enum MoveItemsRepr<T> {\n+enum IntoIterRepr<T> {\n     ZeroIterator,\n     OneIterator(T),\n-    ManyIterator(vec::MoveItems<T>),\n+    ManyIterator(vec::IntoIter<T>),\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     fn next(&mut self) -> Option<T> {\n         match self.repr {\n             ZeroIterator => None,"}, {"sha": "6aa6b02857fbe3d86646dea5d27e79a8f181a5e2", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -130,7 +130,7 @@ struct Table {\n \n struct Items<'a> {\n     cur: Option<&'a Entry>,\n-    items: slice::Items<'a, Option<Box<Entry>>>,\n+    items: slice::Iter<'a, Option<Box<Entry>>>,\n }\n \n impl Table {"}, {"sha": "de934286a7cba65010cb1500694953750dd42d74", "filename": "src/test/compile-fail/resolve-conflict-type-vs-import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::Items;\n-//~^ ERROR import `Items` conflicts with type in this module\n+use std::slice::Iter;\n+//~^ ERROR import `Iter` conflicts with type in this module\n \n-struct Items;\n+struct Iter;\n \n fn main() {\n }"}, {"sha": "1282077028ffbe93128ed341ade6c20e077831c9", "filename": "src/test/run-pass/issue-13167.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459f3b2cfa0e618d6e28ce564a363a9477567f71/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13167.rs?ref=459f3b2cfa0e618d6e28ce564a363a9477567f71", "patch": "@@ -11,7 +11,7 @@\n use std::slice;\n \n pub struct PhfMapEntries<'a, T: 'a> {\n-    iter: slice::Items<'a, (&'static str, T)>,\n+    iter: slice::Iter<'a, (&'static str, T)>,\n }\n \n impl<'a, T> Iterator<(&'static str, &'a T)> for PhfMapEntries<'a, T> {"}]}