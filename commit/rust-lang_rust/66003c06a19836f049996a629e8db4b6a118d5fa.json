{"sha": "66003c06a19836f049996a629e8db4b6a118d5fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MDAzYzA2YTE5ODM2ZjA0OTk5NmE2MjllOGRiNGI2YTExOGQ1ZmE=", "commit": {"author": {"name": "Alfie John", "email": "alfiej@fastmail.fm", "date": "2015-01-18T11:49:37Z"}, "committer": {"name": "Alfie John", "email": "alfiej@fastmail.fm", "date": "2015-01-18T11:49:37Z"}, "message": "docs: replace deprecated integer suffixes from examples", "tree": {"sha": "b1e31cecbd0c374f20063e156742da4449994058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1e31cecbd0c374f20063e156742da4449994058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66003c06a19836f049996a629e8db4b6a118d5fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66003c06a19836f049996a629e8db4b6a118d5fa", "html_url": "https://github.com/rust-lang/rust/commit/66003c06a19836f049996a629e8db4b6a118d5fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66003c06a19836f049996a629e8db4b6a118d5fa/comments", "author": null, "committer": null, "parents": [{"sha": "30f081e54843952e34b0632e1b0ec54547bf6e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/30f081e54843952e34b0632e1b0ec54547bf6e3c", "html_url": "https://github.com/rust-lang/rust/commit/30f081e54843952e34b0632e1b0ec54547bf6e3c"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "882486e292c047890fbe6ea6a27d32d1b4b037ad", "filename": "src/doc/reference.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/66003c06a19836f049996a629e8db4b6a118d5fa/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/66003c06a19836f049996a629e8db4b6a118d5fa/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=66003c06a19836f049996a629e8db4b6a118d5fa", "patch": "@@ -257,18 +257,18 @@ cases mentioned in [Number literals](#number-literals) below.\n \n | [Number literals](#number-literals)`*` | Example | Exponentiation | Suffixes |\n |----------------------------------------|---------|----------------|----------|\n-| Decimal integer | `98_222i` | `N/A` | Integer suffixes |\n-| Hex integer | `0xffi` | `N/A` | Integer suffixes |\n-| Octal integer | `0o77i` | `N/A` | Integer suffixes |\n-| Binary integer | `0b1111_0000i` | `N/A` | Integer suffixes |\n+| Decimal integer | `98_222is` | `N/A` | Integer suffixes |\n+| Hex integer | `0xffis` | `N/A` | Integer suffixes |\n+| Octal integer | `0o77is` | `N/A` | Integer suffixes |\n+| Binary integer | `0b1111_0000is` | `N/A` | Integer suffixes |\n | Floating-point | `123.0E+77f64` | `Optional` | Floating-point suffixes |\n \n `*` All number literals allow `_` as a visual separator: `1_234.0E+18f64`\n \n ##### Suffixes\n | Integer | Floating-point |\n |---------|----------------|\n-| `i` (`int`), `u` (`uint`), `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64` | `f32`, `f64` |\n+| `is` (`isize`), `us` (`usize`), `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64` | `f32`, `f64` |\n \n #### Character and string literals\n \n@@ -468,7 +468,7 @@ Like any literal, an integer literal may be followed (immediately,\n without any spaces) by an _integer suffix_, which forcibly sets the\n type of the literal. There are 10 valid values for an integer suffix:\n \n-* The `i` and `u` suffixes give the literal type `int` or `uint`,\n+* The `is` and `us` suffixes give the literal type `isize` or `usize`,\n   respectively.\n * Each of the signed and unsigned machine types `u8`, `i8`,\n   `u16`, `i16`, `u32`, `i32`, `u64` and `i64`\n@@ -483,9 +483,9 @@ context overconstrains the type, it is also considered a static type error.\n Examples of integer literals of various forms:\n \n ```\n-123i;                              // type int\n-123u;                              // type uint\n-123_u;                             // type uint\n+123is;                             // type isize\n+123us;                             // type usize\n+123_us                             // type usize\n 0xff_u8;                           // type u8\n 0o70_i16;                          // type i16\n 0b1111_1111_1001_0000_i32;         // type i32\n@@ -1002,11 +1002,11 @@ use std::option::Option::{Some, None};\n use std::collections::hash_map::{mod, HashMap};\n \n fn foo<T>(_: T){}\n-fn bar(map1: HashMap<String, uint>, map2: hash_map::HashMap<String, uint>){}\n+fn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n \n fn main() {\n-    // Equivalent to 'std::iter::range_step(0u, 10u, 2u);'\n-    range_step(0u, 10u, 2u);\n+    // Equivalent to 'std::iter::range_step(0us, 10, 2);'\n+    range_step(0us, 10, 2);\n \n     // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n     // std::option::Option::None]);'\n@@ -1611,7 +1611,7 @@ trait is in scope) to pointers to the trait name, used as a type.\n ```\n # trait Shape { }\n # impl Shape for int { }\n-# let mycircle = 0i;\n+# let mycircle = 0is;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n ```\n \n@@ -2821,7 +2821,7 @@ parentheses. They are used to create [tuple-typed](#tuple-types) values.\n ```{.tuple}\n (0,);\n (0.0, 4.5);\n-(\"a\", 4u, true);\n+(\"a\", 4us, true);\n ```\n \n ### Unit expressions\n@@ -2958,9 +2958,9 @@ constant expression that can be evaluated at compile time, such as a\n [literal](#literals) or a [static item](#static-items).\n \n ```\n-[1i, 2, 3, 4];\n+[1is, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n-[0i; 128];             // array with 128 zeros\n+[0is; 128];            // array with 128 zeros\n [0u8, 0u8, 0u8, 0u8];\n ```\n \n@@ -3133,7 +3133,7 @@ moves](#moved-and-copied-types) its right-hand operand to its left-hand\n operand.\n \n ```\n-# let mut x = 0i;\n+# let mut x = 0is;\n # let y = 0;\n \n x = y;\n@@ -3270,7 +3270,7 @@ conditional expression evaluates to `false`, the `while` expression completes.\n An example:\n \n ```\n-let mut i = 0u;\n+let mut i = 0us;\n \n while i < 10 {\n     println!(\"hello\");\n@@ -3349,8 +3349,8 @@ for e in v.iter() {\n An example of a for loop over a series of integers:\n \n ```\n-# fn bar(b:uint) { }\n-for i in range(0u, 256) {\n+# fn bar(b:usize) { }\n+for i in range(0us, 256) {\n     bar(i);\n }\n ```\n@@ -3520,11 +3520,11 @@ fn main() {\n ```\n \n Patterns can also dereference pointers by using the `&`, `&mut` and `box`\n-symbols, as appropriate. For example, these two matches on `x: &int` are\n+symbols, as appropriate. For example, these two matches on `x: &isize` are\n equivalent:\n \n ```\n-# let x = &3i;\n+# let x = &3is;\n let y = match *x { 0 => \"zero\", _ => \"some\" };\n let z = match x { &0 => \"zero\", _ => \"some\" };\n \n@@ -3545,7 +3545,7 @@ Multiple match patterns may be joined with the `|` operator. A range of values\n may be specified with `...`. For example:\n \n ```\n-# let x = 2i;\n+# let x = 2is;\n \n let message = match x {\n   0 | 1  => \"not many\",\n@@ -3886,16 +3886,16 @@ The type of a closure mapping an input of type `A` to an output of type `B` is\n An example of creating and calling a closure:\n \n ```rust\n-let captured_var = 10i;\n+let captured_var = 10is;\n \n let closure_no_args = |&:| println!(\"captured_var={}\", captured_var);\n \n-let closure_args = |&: arg: int| -> int {\n+let closure_args = |&: arg: isize| -> isize {\n   println!(\"captured_var={}, arg={}\", captured_var, arg);\n   arg // Note lack of semicolon after 'arg'\n };\n \n-fn call_closure<F: Fn(), G: Fn(int) -> int>(c1: F, c2: G) {\n+fn call_closure<F: Fn(), G: Fn(isize) -> isize>(c1: F, c2: G) {\n   c1();\n   c2(2);\n }\n@@ -3927,7 +3927,7 @@ trait Printable {\n   fn stringify(&self) -> String;\n }\n \n-impl Printable for int {\n+impl Printable for isize {\n   fn stringify(&self) -> String { self.to_string() }\n }\n \n@@ -3936,7 +3936,7 @@ fn print(a: Box<Printable>) {\n }\n \n fn main() {\n-   print(Box::new(10i) as Box<Printable>);\n+   print(Box::new(10is) as Box<Printable>);\n }\n ```\n "}]}