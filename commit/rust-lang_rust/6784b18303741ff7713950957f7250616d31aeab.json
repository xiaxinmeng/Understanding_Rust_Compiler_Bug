{"sha": "6784b18303741ff7713950957f7250616d31aeab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ODRiMTgzMDM3NDFmZjc3MTM5NTA5NTdmNzI1MDYxNmQzMWFlYWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-02T19:35:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-02T19:35:07Z"}, "message": "Win32 warning police.", "tree": {"sha": "712dd8841c3150c8839bb74e5f2d1e274bfb1497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/712dd8841c3150c8839bb74e5f2d1e274bfb1497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6784b18303741ff7713950957f7250616d31aeab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6784b18303741ff7713950957f7250616d31aeab", "html_url": "https://github.com/rust-lang/rust/commit/6784b18303741ff7713950957f7250616d31aeab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6784b18303741ff7713950957f7250616d31aeab/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a7de641dafbbffcc165eed847f768661220ee16", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a7de641dafbbffcc165eed847f768661220ee16", "html_url": "https://github.com/rust-lang/rust/commit/6a7de641dafbbffcc165eed847f768661220ee16"}], "stats": {"total": 231, "additions": 116, "deletions": 115}, "files": [{"sha": "d04331e00b3564e63fb0331366114c8bdd8b154d", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6784b18303741ff7713950957f7250616d31aeab/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6784b18303741ff7713950957f7250616d31aeab/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=6784b18303741ff7713950957f7250616d31aeab", "patch": "@@ -3,10 +3,6 @@ This is intended to be a low-level binding to libuv that very closely mimics\n the C libuv API. Does very little right now pending scheduler improvements.\n */\n \n-#[cfg(target_os = \"linux\")];\n-#[cfg(target_os = \"macos\")];\n-#[cfg(target_os = \"freebsd\")];\n-\n export sanity_check;\n export loop_t, idle_t;\n export loop_new, loop_delete, default_loop, run, unref;\n@@ -38,9 +34,6 @@ type handle_type = ctypes::enum;\n type close_cb = opaque_cb;\n type idle_cb = opaque_cb;\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n type handle_private_fields = {\n     a00: ctypes::c_int,\n     a01: ctypes::c_int,\n@@ -121,9 +114,6 @@ fn sanity_check() {\n                sys::size_of::<idle_t>());\n }\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n fn handle_fields_new() -> handle_fields {\n     {\n         loop: ptr::null(),\n@@ -154,46 +144,53 @@ fn idle_new() -> idle_t {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-\n-    #[test]\n-    fn test_sanity_check() {\n-        sanity_check();\n-    }\n-\n-    // From test-ref.c\n-    mod test_ref {\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+// FIXME: We're out of date on libuv and not testing\n+// it on windows presently. This needs to change.\n+mod os {\n \n-        #[test]\n-        fn ref() {\n-            let loop = loop_new();\n-            run(loop);\n-            loop_delete(loop);\n-        }\n+    #[cfg(test)]\n+    mod tests {\n \n         #[test]\n-        fn idle_ref() {\n-            let loop = loop_new();\n-            let h = idle_new();\n-            idle_init(loop, ptr::addr_of(h));\n-            idle_start(ptr::addr_of(h), ptr::null());\n-            unref(loop);\n-            run(loop);\n-            loop_delete(loop);\n+        fn test_sanity_check() {\n+            sanity_check();\n         }\n \n-        #[test]\n-        fn async_ref() {\n-            /*\n-            let loop = loop_new();\n-            let h = async_new();\n-            async_init(loop, ptr::addr_of(h), ptr::null());\n-            unref(loop);\n-            run(loop);\n-            loop_delete(loop);\n-            */\n+        // From test-ref.c\n+        mod test_ref {\n+\n+            #[test]\n+            fn ref() {\n+                let loop = loop_new();\n+                run(loop);\n+                loop_delete(loop);\n+            }\n+\n+            #[test]\n+            fn idle_ref() {\n+                let loop = loop_new();\n+                let h = idle_new();\n+                idle_init(loop, ptr::addr_of(h));\n+                idle_start(ptr::addr_of(h), ptr::null());\n+                unref(loop);\n+                run(loop);\n+                loop_delete(loop);\n+            }\n+\n+            #[test]\n+            fn async_ref() {\n+                /*\n+                let loop = loop_new();\n+                let h = async_new();\n+                async_init(loop, ptr::addr_of(h), ptr::null());\n+                unref(loop);\n+                run(loop);\n+                loop_delete(loop);\n+                */\n+            }\n         }\n     }\n }\n-"}, {"sha": "e7de8ec1dc8a437762b33b6d42a7b1c1babfb480", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/6784b18303741ff7713950957f7250616d31aeab/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6784b18303741ff7713950957f7250616d31aeab/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=6784b18303741ff7713950957f7250616d31aeab", "patch": "@@ -1,10 +1,5 @@\n // Some temporary libuv hacks for servo\n \n-#[cfg(target_os = \"linux\")];\n-#[cfg(target_os = \"macos\")];\n-#[cfg(target_os = \"freebsd\")];\n-\n-\n #[nolink]\n native mod rustrt {\n     fn rust_uvtmp_create_thread() -> thread;\n@@ -100,73 +95,82 @@ fn get_req_id(cd: connect_data) -> u32 {\n     ret rustrt::rust_uvtmp_get_req_id(cd);\n }\n \n-#[test]\n-fn test_start_stop() {\n-    let thread = create_thread();\n-    start_thread(thread);\n-    join_thread(thread);\n-    delete_thread(thread);\n-}\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+// FIXME: We're out of date on libuv and not testing\n+// it on windows presently. This needs to change.\n+mod os {\n \n-#[test]\n-#[ignore]\n-fn test_connect() {\n-    let thread = create_thread();\n-    start_thread(thread);\n-    let port = comm::port();\n-    let chan = comm::chan(port);\n-    connect(thread, 0u32, \"74.125.224.146\", chan);\n-    alt comm::recv(port) {\n-      connected(cd) {\n-        close_connection(thread, 0u32);\n-      }\n-      _ { fail \"test_connect: port isn't connected\"; }\n+    #[test]\n+    fn test_start_stop() {\n+        let thread = create_thread();\n+        start_thread(thread);\n+        join_thread(thread);\n+        delete_thread(thread);\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn test_connect() {\n+        let thread = create_thread();\n+        start_thread(thread);\n+        let port = comm::port();\n+        let chan = comm::chan(port);\n+        connect(thread, 0u32, \"74.125.224.146\", chan);\n+        alt comm::recv(port) {\n+          connected(cd) {\n+            close_connection(thread, 0u32);\n+          }\n+          _ { fail \"test_connect: port isn't connected\"; }\n+        }\n+        join_thread(thread);\n+        delete_thread(thread);\n     }\n-    join_thread(thread);\n-    delete_thread(thread);\n-}\n \n-#[test]\n-#[ignore]\n-fn test_http() {\n-    let thread = create_thread();\n-    start_thread(thread);\n-    let port = comm::port();\n-    let chan = comm::chan(port);\n-    connect(thread, 0u32, \"74.125.224.146\", chan);\n-    alt comm::recv(port) {\n-      connected(cd) {\n-        write(thread, 0u32, str::bytes(\"GET / HTTP/1.0\\n\\n\"), chan);\n+    #[test]\n+    #[ignore]\n+    fn test_http() {\n+        let thread = create_thread();\n+        start_thread(thread);\n+        let port = comm::port();\n+        let chan = comm::chan(port);\n+        connect(thread, 0u32, \"74.125.224.146\", chan);\n         alt comm::recv(port) {\n-          wrote(cd) {\n-            read_start(thread, 0u32, chan);\n-            let keep_going = true;\n-            while keep_going {\n-                alt comm::recv(port) {\n-                  read(_, buf, -1) {\n-                    keep_going = false;\n-                    delete_buf(buf);\n-                  }\n-                  read(_, buf, len) {\n-                    unsafe {\n-                        log(error, len);\n-                        let buf = vec::unsafe::from_buf(buf, len as uint);\n-                        let str = str::from_bytes(buf);\n-                        #error(\"read something\");\n-                        io::println(str);\n+          connected(cd) {\n+            write(thread, 0u32, str::bytes(\"GET / HTTP/1.0\\n\\n\"), chan);\n+            alt comm::recv(port) {\n+              wrote(cd) {\n+                read_start(thread, 0u32, chan);\n+                let keep_going = true;\n+                while keep_going {\n+                    alt comm::recv(port) {\n+                      read(_, buf, -1) {\n+                        keep_going = false;\n+                        delete_buf(buf);\n+                      }\n+                      read(_, buf, len) {\n+                        unsafe {\n+                            log(error, len);\n+                            let buf = vec::unsafe::from_buf(buf,\n+                                                            len as uint);\n+                            let str = str::from_bytes(buf);\n+                            #error(\"read something\");\n+                            io::println(str);\n+                        }\n+                        delete_buf(buf);\n+                      }\n+                      _ { fail \"test_http: protocol error\"; }\n                     }\n-                    delete_buf(buf);\n-                  }\n-                  _ { fail \"test_http: protocol error\"; }\n                 }\n+                close_connection(thread, 0u32);\n+              }\n+              _ { fail \"test_http: expected `wrote`\"; }\n             }\n-            close_connection(thread, 0u32);\n           }\n-          _ { fail \"test_http: expected `wrote`\"; }\n+          _ { fail \"test_http: port not connected\"; }\n         }\n-      }\n-      _ { fail \"test_http: port not connected\"; }\n+        join_thread(thread);\n+        delete_thread(thread);\n     }\n-    join_thread(thread);\n-    delete_thread(thread);\n-}\n+}\n\\ No newline at end of file"}, {"sha": "ddc1ebd7a356185c62f044dfb90a4e2a4554e08d", "filename": "src/libstd/win32_os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6784b18303741ff7713950957f7250616d31aeab/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6784b18303741ff7713950957f7250616d31aeab/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=6784b18303741ff7713950957f7250616d31aeab", "patch": "@@ -44,17 +44,17 @@ mod libc_constants {\n }\n \n type DWORD = u32;\n-type HMODULE = uint;\n+type HMODULE = c_uint;\n type LPTSTR = str::sbuf;\n type LPCTSTR = str::sbuf;\n \n type LPSECURITY_ATTRIBUTES = *ctypes::void;\n \n #[abi = \"stdcall\"]\n native mod kernel32 {\n-    fn GetEnvironmentVariableA(n: str::sbuf, v: str::sbuf, nsize: uint) ->\n-       uint;\n-    fn SetEnvironmentVariableA(n: str::sbuf, v: str::sbuf) -> int;\n+    fn GetEnvironmentVariableA(n: str::sbuf, v: str::sbuf, nsize: c_uint) ->\n+       c_uint;\n+    fn SetEnvironmentVariableA(n: str::sbuf, v: str::sbuf) -> c_int;\n     fn GetModuleFileNameA(hModule: HMODULE,\n                           lpFilename: LPTSTR,\n                           nSize: DWORD) -> DWORD;\n@@ -99,7 +99,7 @@ fn fclose(file: FILE) {\n     libc::fclose(file)\n }\n \n-fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n+fn fsync_fd(_fd: fd_t, _level: io::fsync::level) -> c_int {\n     // FIXME (1253)\n     fail;\n }"}]}