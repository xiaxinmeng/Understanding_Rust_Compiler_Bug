{"sha": "5878780e641239906a7a2986ccae048f7640be87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4Nzg3ODBlNjQxMjM5OTA2YTdhMjk4NmNjYWUwNDhmNzY0MGJlODc=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-09-01T07:23:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-01T07:23:23Z"}, "message": "Rollup merge of #88040 - nbdd0121:btreemap, r=m-ou-se\n\nBTree: remove Ord bound from new\n\n`K: Ord` bound is unnecessary on `BTree{Map,Set}::new` and their `Default` impl. No elements exist so there are nothing to compare anyway, so I don't think \"future proof\" would be a blocker here. This is analogous to `HashMap::new` not having a `K: Eq + Hash` bound.\n\n#79245 originally does this and for some reason drops the change to `new` and `Default`. I can see why changes to other methods like `entry` or `symmetric_difference` need to be careful but I couldn't find out any reason not to do it on `new`.\n\nRemoving the bound also makes the stabilisation of `const fn new` not depending on const trait bounds.\n\ncc `@steffahn` who suggests me to make this PR.\n\nr? `@dtolnay`", "tree": {"sha": "bc70bff308a0253fde7e2c588df60ac28f262008", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc70bff308a0253fde7e2c588df60ac28f262008"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5878780e641239906a7a2986ccae048f7640be87", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhLypsCRBK7hj4Ov3rIwAAArYIAKs7wiBPp+srjLuF1ipvVWUb\nN5dz9uA2ozRnmVrTLbuXEHdc45fO62oOXBGzlKepb74OfAZQ6FcQPaLgbCF7jYqr\nJHkfW/u4LpTdbpi3stxv7OQfxHmJqVWe29zNGbjgO2TtHZDSOrr23jf+/xhd/rSt\n0mvBSq4eZtVRtKlTx5FcuiywpB+Y24M/z9kY8MK3awmsTwE2trf61EFPzgyUNIM5\neYXyKBOJxO0GN3AC4TuieuVF6yxwzzLKAJK+Dxrd2AA3QOqFmC4mCT/tZWfKPws5\n2CkcGjpxieH/XHNZct8BkGv7kLaXAe7xW+zVUiKdB5O0+7HN79YGgQy2t/touj0=\n=dUPH\n-----END PGP SIGNATURE-----\n", "payload": "tree bc70bff308a0253fde7e2c588df60ac28f262008\nparent dcefd6871d40612e924bb63f5d8a3bddf934c0f4\nparent f33f266a8a20594736b8eb7c95a4d42478bec7cb\nauthor Mara Bos <m-ou.se@m-ou.se> 1630481003 +0200\ncommitter GitHub <noreply@github.com> 1630481003 +0200\n\nRollup merge of #88040 - nbdd0121:btreemap, r=m-ou-se\n\nBTree: remove Ord bound from new\n\n`K: Ord` bound is unnecessary on `BTree{Map,Set}::new` and their `Default` impl. No elements exist so there are nothing to compare anyway, so I don't think \"future proof\" would be a blocker here. This is analogous to `HashMap::new` not having a `K: Eq + Hash` bound.\n\n#79245 originally does this and for some reason drops the change to `new` and `Default`. I can see why changes to other methods like `entry` or `symmetric_difference` need to be careful but I couldn't find out any reason not to do it on `new`.\n\nRemoving the bound also makes the stabilisation of `const fn new` not depending on const trait bounds.\n\ncc `@steffahn` who suggests me to make this PR.\n\nr? `@dtolnay`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5878780e641239906a7a2986ccae048f7640be87", "html_url": "https://github.com/rust-lang/rust/commit/5878780e641239906a7a2986ccae048f7640be87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5878780e641239906a7a2986ccae048f7640be87/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcefd6871d40612e924bb63f5d8a3bddf934c0f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcefd6871d40612e924bb63f5d8a3bddf934c0f4", "html_url": "https://github.com/rust-lang/rust/commit/dcefd6871d40612e924bb63f5d8a3bddf934c0f4"}, {"sha": "f33f266a8a20594736b8eb7c95a4d42478bec7cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f33f266a8a20594736b8eb7c95a4d42478bec7cb", "html_url": "https://github.com/rust-lang/rust/commit/f33f266a8a20594736b8eb7c95a4d42478bec7cb"}], "stats": {"total": 68, "additions": 24, "deletions": 44}, "files": [{"sha": "70a838a35f9d202b0af56357af0a4da9382d0536", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=5878780e641239906a7a2986ccae048f7640be87", "patch": "@@ -233,9 +233,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         }\n \n         if self.is_empty() {\n-            // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n-            // Ord` constraint, which this method lacks.\n-            BTreeMap { root: None, length: 0 }\n+            BTreeMap::new()\n         } else {\n             clone_subtree(self.root.as_ref().unwrap().reborrow()) // unwrap succeeds because not empty\n         }\n@@ -499,10 +497,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeMap<K, V>\n-    where\n-        K: Ord,\n-    {\n+    pub const fn new() -> BTreeMap<K, V> {\n         BTreeMap { root: None, length: 0 }\n     }\n \n@@ -522,7 +517,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = BTreeMap { root: None, length: 0 };\n+        *self = BTreeMap::new();\n     }\n \n     /// Returns a reference to the value corresponding to the key.\n@@ -1957,7 +1952,7 @@ impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V> Default for BTreeMap<K, V> {\n+impl<K, V> Default for BTreeMap<K, V> {\n     /// Creates an empty `BTreeMap`.\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()"}, {"sha": "a99d6c49ab7b372b286d9d901985fe61129d5082", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=5878780e641239906a7a2986ccae048f7640be87", "patch": "@@ -1745,7 +1745,7 @@ fn test_send() {\n     }\n }\n \n-#[allow(dead_code)]\n+#[test]\n fn test_ord_absence() {\n     fn map<K>(mut map: BTreeMap<K, ()>) {\n         map.is_empty();\n@@ -1784,6 +1784,12 @@ fn test_ord_absence() {\n     fn map_clone<K: Clone>(mut map: BTreeMap<K, ()>) {\n         map.clone_from(&map.clone());\n     }\n+\n+    #[derive(Debug, Clone)]\n+    struct NonOrd;\n+    map(BTreeMap::<NonOrd, _>::new());\n+    map_debug(BTreeMap::<NonOrd, _>::new());\n+    map_clone(BTreeMap::<NonOrd, _>::default());\n }\n \n #[test]"}, {"sha": "ff0db22e0cc2d48519bbfac8ffb37f4752cce3a0", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=5878780e641239906a7a2986ccae048f7640be87", "patch": "@@ -246,10 +246,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeSet<T>\n-    where\n-        T: Ord,\n-    {\n+    pub const fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -1192,7 +1189,7 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Default for BTreeSet<T> {\n+impl<T> Default for BTreeSet<T> {\n     /// Creates an empty `BTreeSet`.\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()"}, {"sha": "0a87ae12d61a59a34f957903aef3d0958010b9e6", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=5878780e641239906a7a2986ccae048f7640be87", "patch": "@@ -607,7 +607,7 @@ fn test_send() {\n     }\n }\n \n-#[allow(dead_code)]\n+#[test]\n fn test_ord_absence() {\n     fn set<K>(mut set: BTreeSet<K>) {\n         set.is_empty();\n@@ -626,6 +626,12 @@ fn test_ord_absence() {\n     fn set_clone<K: Clone>(mut set: BTreeSet<K>) {\n         set.clone_from(&set.clone());\n     }\n+\n+    #[derive(Debug, Clone)]\n+    struct NonOrd;\n+    set(BTreeSet::<NonOrd>::new());\n+    set_debug(BTreeSet::<NonOrd>::new());\n+    set_clone(BTreeSet::<NonOrd>::default());\n }\n \n #[test]"}, {"sha": "f448b3eb7c3000e611694fc018e0ca038faae4cb", "filename": "library/alloc/tests/const_fns.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Ftests%2Fconst_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5878780e641239906a7a2986ccae048f7640be87/library%2Falloc%2Ftests%2Fconst_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fconst_fns.rs?ref=5878780e641239906a7a2986ccae048f7640be87", "patch": "@@ -1,29 +1,5 @@\n // Test const functions in the library\n \n-use core::cmp::Ordering;\n-\n-// FIXME remove this struct once we put `K: ?const Ord` on BTreeMap::new.\n-#[derive(PartialEq, Eq, PartialOrd)]\n-pub struct MyType;\n-\n-impl const Ord for MyType {\n-    fn cmp(&self, _: &Self) -> Ordering {\n-        Ordering::Equal\n-    }\n-\n-    fn max(self, _: Self) -> Self {\n-        Self\n-    }\n-\n-    fn min(self, _: Self) -> Self {\n-        Self\n-    }\n-\n-    fn clamp(self, _: Self, _: Self) -> Self {\n-        Self\n-    }\n-}\n-\n pub const MY_VEC: Vec<usize> = Vec::new();\n pub const MY_VEC2: Vec<usize> = Default::default();\n \n@@ -32,13 +8,13 @@ pub const MY_STRING2: String = Default::default();\n \n use std::collections::{BTreeMap, BTreeSet};\n \n-pub const MY_BTREEMAP: BTreeMap<MyType, MyType> = BTreeMap::new();\n-pub const MAP: &'static BTreeMap<MyType, MyType> = &MY_BTREEMAP;\n+pub const MY_BTREEMAP: BTreeMap<usize, usize> = BTreeMap::new();\n+pub const MAP: &'static BTreeMap<usize, usize> = &MY_BTREEMAP;\n pub const MAP_LEN: usize = MAP.len();\n pub const MAP_IS_EMPTY: bool = MAP.is_empty();\n \n-pub const MY_BTREESET: BTreeSet<MyType> = BTreeSet::new();\n-pub const SET: &'static BTreeSet<MyType> = &MY_BTREESET;\n+pub const MY_BTREESET: BTreeSet<usize> = BTreeSet::new();\n+pub const SET: &'static BTreeSet<usize> = &MY_BTREESET;\n pub const SET_LEN: usize = SET.len();\n pub const SET_IS_EMPTY: bool = SET.is_empty();\n "}]}