{"sha": "f5e991bee01104342ade57d8f2ea51527190c50d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZTk5MWJlZTAxMTA0MzQyYWRlNTdkOGYyZWE1MTUyNzE5MGM1MGQ=", "commit": {"author": {"name": "Gabriel Majeri", "email": "gabriel.majeri6@gmail.com", "date": "2018-09-09T11:22:58Z"}, "committer": {"name": "Gabriel Majeri", "email": "gabriel.majeri6@gmail.com", "date": "2018-09-27T17:13:32Z"}, "message": "Expand the documentation for the std::sync module\n\nProvides an overview on why synchronization is required,\nas well a short summary of what sync primitives are available.", "tree": {"sha": "fdae27a476567265e95fc138839e47ac7c1a08d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdae27a476567265e95fc138839e47ac7c1a08d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5e991bee01104342ade57d8f2ea51527190c50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e991bee01104342ade57d8f2ea51527190c50d", "html_url": "https://github.com/rust-lang/rust/commit/f5e991bee01104342ade57d8f2ea51527190c50d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5e991bee01104342ade57d8f2ea51527190c50d/comments", "author": {"login": "GabrielMajeri", "id": 3010346, "node_id": "MDQ6VXNlcjMwMTAzNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/3010346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GabrielMajeri", "html_url": "https://github.com/GabrielMajeri", "followers_url": "https://api.github.com/users/GabrielMajeri/followers", "following_url": "https://api.github.com/users/GabrielMajeri/following{/other_user}", "gists_url": "https://api.github.com/users/GabrielMajeri/gists{/gist_id}", "starred_url": "https://api.github.com/users/GabrielMajeri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GabrielMajeri/subscriptions", "organizations_url": "https://api.github.com/users/GabrielMajeri/orgs", "repos_url": "https://api.github.com/users/GabrielMajeri/repos", "events_url": "https://api.github.com/users/GabrielMajeri/events{/privacy}", "received_events_url": "https://api.github.com/users/GabrielMajeri/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GabrielMajeri", "id": 3010346, "node_id": "MDQ6VXNlcjMwMTAzNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/3010346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GabrielMajeri", "html_url": "https://github.com/GabrielMajeri", "followers_url": "https://api.github.com/users/GabrielMajeri/followers", "following_url": "https://api.github.com/users/GabrielMajeri/following{/other_user}", "gists_url": "https://api.github.com/users/GabrielMajeri/gists{/gist_id}", "starred_url": "https://api.github.com/users/GabrielMajeri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GabrielMajeri/subscriptions", "organizations_url": "https://api.github.com/users/GabrielMajeri/orgs", "repos_url": "https://api.github.com/users/GabrielMajeri/repos", "events_url": "https://api.github.com/users/GabrielMajeri/events{/privacy}", "received_events_url": "https://api.github.com/users/GabrielMajeri/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441519536c8bd138e8c651743249acd6814747a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/441519536c8bd138e8c651743249acd6814747a1", "html_url": "https://github.com/rust-lang/rust/commit/441519536c8bd138e8c651743249acd6814747a1"}], "stats": {"total": 123, "additions": 119, "deletions": 4}, "files": [{"sha": "e06e299406933869bca1bf590a15ca1c0e59beea", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f5e991bee01104342ade57d8f2ea51527190c50d/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e991bee01104342ade57d8f2ea51527190c50d/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=f5e991bee01104342ade57d8f2ea51527190c50d", "patch": "@@ -10,10 +10,125 @@\n \n //! Useful synchronization primitives.\n //!\n-//! This module contains useful safe and unsafe synchronization primitives.\n-//! Most of the primitives in this module do not provide any sort of locking\n-//! and/or blocking at all, but rather provide the necessary tools to build\n-//! other types of concurrent primitives.\n+//! ## The need for synchronization\n+//!\n+//! On an ideal single-core CPU, the timeline of events happening in a program\n+//! is linear, consistent with the order of operations in the code.\n+//!\n+//! Considering the following code, operating on some global static variables:\n+//!\n+//! ```rust\n+//! # static mut A: u32 = 0;\n+//! # static mut B: u32 = 0;\n+//! # static mut C: u32 = 0;\n+//! # unsafe {\n+//! A = 3;\n+//! B = 4;\n+//! A = A + B;\n+//! C = B;\n+//! println!(\"{} {} {}\", A, B, C);\n+//! C = A;\n+//! # }\n+//! ```\n+//!\n+//! It appears _as if_ some variables stored in memory are changed, an addition\n+//! is performed, result is stored in A and the variable C is modified twice.\n+//! When only a single thread is involved, the results are as expected:\n+//! the line `7 4 4` gets printed.\n+//!\n+//! As for what happens behind the scenes, when an optimizing compiler is used\n+//! the final generated machine code might look very different from the code:\n+//!\n+//! - first store to `C` might be moved before the store to `A` or `B`,\n+//!   _as if_ we had written `C = 4; A = 3; B = 4;`\n+//!\n+//! - last store to `C` might be removed, since we never read from it again.\n+//!\n+//! - assignment of `A + B` to `A` might be removed, the sum can be stored in a\n+//!   in a register until it gets printed, and the global variable never gets\n+//!   updated.\n+//!\n+//! - the final result could be determined just by looking at the code at compile time,\n+//!   so [constant folding] might turn the whole block into a simple `println!(\"7 4 4\")`\n+//!\n+//! The compiler is allowed to perform any combination of these optimizations, as long\n+//! as the final optimized code, when executed, produces the same results as the one\n+//! without optimizations.\n+//!\n+//! When multiprocessing is involved (either multiple CPU cores, or multiple\n+//! physical CPUs), access to global variables (which are shared between threads)\n+//! could lead to nondeterministic results, **even if** compiler optimizations\n+//! are disabled.\n+//!\n+//! Note that thanks to Rust's safety guarantees, accessing global (static)\n+//! variables requires `unsafe` code, assuming we don't use any of the\n+//! synchronization primitives in this module.\n+//!\n+//! [constant folding]: https://en.wikipedia.org/wiki/Constant_folding\n+//!\n+//! ## Out-of-order execution\n+//!\n+//! Instructions can execute in a different order from the one we define, due to\n+//! various reasons:\n+//!\n+//! - **Compiler** reordering instructions: if the compiler can issue an\n+//!   instruction at an earlier point, it will try to do so. For example, it\n+//!   might hoist memory loads at the top of a code block, so that the CPU can\n+//!   start [prefetching] the values from memory.\n+//!\n+//!   In single-threaded scenarios, this can cause issues when writing signal handlers\n+//!   or certain kinds of low-level code.\n+//!   Use [compiler fences] to prevent this reordering.\n+//!\n+//! - **Single processor** executing instructions [out-of-order]: modern CPUs are\n+//!   capable of [superscalar] execution, i.e. multiple instructions might be\n+//!   executing at the same time, even though the machine code describes a\n+//!   sequential process.\n+//!\n+//!   This kind of reordering is handled transparently by the CPU.\n+//!\n+//! - **Multiprocessor** system, where multiple hardware threads run at the same time.\n+//!   In multi-threaded scenarios, you can use two kinds of primitives to deal\n+//!   with synchronization:\n+//!   - [memory fences] to ensure memory accesses are made visibile to other\n+//!     CPUs in the right order.\n+//!   - [atomic operations] to ensure simultaneous access to the same memory\n+//!     location doesn't lead to undefined behavior.\n+//!\n+//! [prefetching]: https://en.wikipedia.org/wiki/Cache_prefetching\n+//! [compiler fences]: atomic::compiler_fence\n+//! [out-of-order]: https://en.wikipedia.org/wiki/Out-of-order_execution\n+//! [superscalar]: https://en.wikipedia.org/wiki/Superscalar_processor\n+//! [memory fences]: atomic::fence\n+//! [atomics operations]: atomic\n+//!\n+//! ## Higher-level synchronization objects\n+//!\n+//! Most of the low-level synchronization primitives are quite error-prone and\n+//! inconvenient to use, which is why the standard library also exposes some\n+//! higher-level synchronization objects.\n+//!\n+//! These abstractions can be built out of lower-level primitives. For efficiency,\n+//! the sync objects in the standard library are usually implemented with help\n+//! from the operating system's kernel, which is able to reschedule the threads\n+//! while they are blocked on acquiring a lock.\n+//!\n+//! ## Efficiency\n+//!\n+//! Higher-level synchronization mechanisms are usually heavy-weight.\n+//! While most atomic operations can execute instantaneously, acquiring a\n+//! [`Mutex`] can involve blocking until another thread releases it.\n+//! For [`RwLock`], while! any number of readers may acquire it without\n+//! blocking, each writer will have exclusive access.\n+//!\n+//! On the other hand, communication over [channels] can provide a fairly\n+//! high-level interface without sacrificing performance, at the cost of\n+//! somewhat more memory.\n+//!\n+//! The more synchronization exists between CPUs, the smaller the performance\n+//! gains from multithreading will be.\n+//!\n+//! [channels]: mpsc\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}