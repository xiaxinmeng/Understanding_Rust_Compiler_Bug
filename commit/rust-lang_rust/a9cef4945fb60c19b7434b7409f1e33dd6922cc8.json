{"sha": "a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2VmNDk0NWZiNjBjMTliNzQzNGI3NDA5ZjFlMzNkZDY5MjJjYzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-23T20:46:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-28T17:59:56Z"}, "message": "rustc_metadata: Privatize all fields of `CrateRoot`\n\nAll of them are read-only", "tree": {"sha": "0626b55dd58137787adcdc0f5f11d4cb0379eea9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0626b55dd58137787adcdc0f5f11d4cb0379eea9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "html_url": "https://github.com/rust-lang/rust/commit/a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "765133ac2e3f74b89417782f71d1aa505579523b", "url": "https://api.github.com/repos/rust-lang/rust/commits/765133ac2e3f74b89417782f71d1aa505579523b", "html_url": "https://github.com/rust-lang/rust/commit/765133ac2e3f74b89417782f71d1aa505579523b"}], "stats": {"total": 162, "additions": 105, "deletions": 57}, "files": [{"sha": "ae309a2aa1361a9d73b8e4321757a88e939be9ff", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "patch": "@@ -47,9 +47,9 @@ pub struct CrateLoader<'a> {\n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n     cstore.iter_crate_data(|cnum, data| {\n-        info!(\"  name: {}\", data.root.name);\n+        info!(\"  name: {}\", data.root.name());\n         info!(\"  cnum: {}\", cnum);\n-        info!(\"  hash: {}\", data.root.hash);\n+        info!(\"  hash: {}\", data.root.hash());\n         info!(\"  reqd: {:?}\", data.dep_kind());\n         let CrateSource { dylib, rlib, rmeta } = data.source();\n         dylib.as_ref().map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n@@ -101,10 +101,10 @@ impl<'a> CrateLoader<'a> {\n                       -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n-            if data.root.name != name { return }\n+            if data.root.name() != name { return }\n \n             match hash {\n-                Some(hash) if *hash == data.root.hash => { ret = Some(cnum); return }\n+                Some(hash) if *hash == data.root.hash() => { ret = Some(cnum); return }\n                 Some(..) => return,\n                 None => {}\n             }\n@@ -152,26 +152,26 @@ impl<'a> CrateLoader<'a> {\n                                   span: Span,\n                                   root: &CrateRoot<'_>) {\n         // Check for (potential) conflicts with the local crate\n-        if self.local_crate_name == root.name &&\n-           self.sess.local_crate_disambiguator() == root.disambiguator {\n+        if self.local_crate_name == root.name() &&\n+           self.sess.local_crate_disambiguator() == root.disambiguator() {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n                          compiled with the same `-C metadata` arguments. This \\\n                          will result in symbol conflicts between the two.\",\n-                        root.name)\n+                        root.name())\n         }\n \n         // Check for conflicts with any crate loaded so far\n         self.cstore.iter_crate_data(|_, other| {\n-            if other.root.name == root.name && // same crate-name\n-               other.root.disambiguator == root.disambiguator &&  // same crate-disambiguator\n-               other.root.hash != root.hash { // but different SVH\n+            if other.root.name() == root.name() && // same crate-name\n+               other.root.disambiguator() == root.disambiguator() &&  // same crate-disambiguator\n+               other.root.hash() != root.hash() { // but different SVH\n                 span_fatal!(self.sess, span, E0523,\n                         \"found two different crates with name `{}` that are \\\n                          not distinguished by differing `-C metadata`. This \\\n                          will result in symbol conflicts between the two.\",\n-                        root.name)\n+                        root.name())\n             }\n         });\n     }\n@@ -189,14 +189,14 @@ impl<'a> CrateLoader<'a> {\n \n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n-        let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash);\n+        let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n         let private_dep = self.sess.opts.externs.get(&name.as_str())\n             .map(|e| e.is_private_dep)\n             .unwrap_or(false);\n \n-        info!(\"register crate `{}` (private_dep = {})\", crate_root.name, private_dep);\n+        info!(\"register crate `{}` (private_dep = {})\", crate_root.name(), private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n@@ -207,7 +207,7 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths::new(crate_root.name, source.clone());\n+            crate_paths = CratePaths::new(crate_root.name(), source.clone());\n             &crate_paths\n         };\n \n@@ -221,7 +221,7 @@ impl<'a> CrateLoader<'a> {\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span))\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator(), span))\n         } else {\n             None\n         };\n@@ -378,7 +378,7 @@ impl<'a> CrateLoader<'a> {\n         if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n-                if data.root.name == root.name && root.hash == data.root.hash {\n+                if data.root.name() == root.name() && root.hash() == data.root.hash() {\n                     assert!(locator.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n@@ -494,13 +494,12 @@ impl<'a> CrateLoader<'a> {\n                                                           sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n-            needs_panic_runtime = needs_panic_runtime ||\n-                                  data.root.needs_panic_runtime;\n-            if data.root.panic_runtime {\n+            needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n+            if data.is_panic_runtime() {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.root.needs_panic_runtime);\n+                                          &|data| data.needs_panic_runtime());\n                 runtime_found = runtime_found || data.dep_kind() == DepKind::Explicit;\n             }\n         });\n@@ -536,19 +535,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.root.panic_runtime {\n+        if !data.is_panic_runtime() {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.root.panic_strategy != desired_strategy {\n+        if data.panic_strategy() != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.root.needs_panic_runtime);\n+                                  &|data| data.needs_panic_runtime());\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -622,7 +621,7 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.root.name == sym::std {\n+                if data.root.name() == sym::std {\n                     uses_std = true;\n                 }\n             });\n@@ -640,7 +639,7 @@ impl<'a> CrateLoader<'a> {\n                 let data = self.cstore.get_crate_data(cnum);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.root.sanitizer_runtime {\n+                if !data.is_sanitizer_runtime() {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -661,7 +660,7 @@ impl<'a> CrateLoader<'a> {\n             let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.root.profiler_runtime {\n+            if !data.is_profiler_runtime() {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -687,7 +686,7 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.root.needs_allocator;\n+            needs_allocator = needs_allocator || data.needs_allocator();\n         });\n         if !needs_allocator {\n             self.cstore.allocator_kind = None;\n@@ -723,7 +722,7 @@ impl<'a> CrateLoader<'a> {\n             None\n         };\n         self.cstore.iter_crate_data(|_, data| {\n-            if !data.root.has_global_allocator {\n+            if !data.has_global_allocator() {\n                 return\n             }\n             match global_allocator {\n@@ -732,14 +731,14 @@ impl<'a> CrateLoader<'a> {\n                                             conflicts with this global \\\n                                             allocator in: {}\",\n                                            other_crate,\n-                                           data.root.name));\n+                                           data.root.name()));\n                 }\n                 Some(None) => {\n                     self.sess.err(&format!(\"the `#[global_allocator]` in this \\\n                                             crate conflicts with global \\\n-                                            allocator in: {}\", data.root.name));\n+                                            allocator in: {}\", data.root.name()));\n                 }\n-                None => global_allocator = Some(Some(data.root.name)),\n+                None => global_allocator = Some(Some(data.root.name())),\n             }\n         });\n         if global_allocator.is_some() {\n@@ -753,7 +752,7 @@ impl<'a> CrateLoader<'a> {\n         // attribute.\n         let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n-            if data.root.has_default_lib_allocator {\n+            if data.has_default_lib_allocator() {\n                 has_default = true;\n             }\n         });\n@@ -787,9 +786,9 @@ impl<'a> CrateLoader<'a> {\n                 self.sess.err(&format!(\"the crate `{}` cannot depend \\\n                                         on a crate that needs {}, but \\\n                                         it depends on `{}`\",\n-                                       self.cstore.get_crate_data(krate).root.name,\n+                                       self.cstore.get_crate_data(krate).root.name(),\n                                        what,\n-                                       data.root.name));\n+                                       data.root.name()));\n             }\n         }\n "}, {"sha": "a7a4a96bb5221ca088a78fe7971bb60c37434686", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "patch": "@@ -597,7 +597,7 @@ impl<'a> CrateLocator<'a> {\n                                                \"multiple matching crates for `{}`\",\n                                                self.crate_name);\n                 let candidates = libraries.iter().filter_map(|(_, lib)| {\n-                    let crate_name = &lib.metadata.get_root().name.as_str();\n+                    let crate_name = &lib.metadata.get_root().name().as_str();\n                     match &(&lib.source.dylib, &lib.source.rlib) {\n                         &(&Some((ref pd, _)), &Some((ref pr, _))) => {\n                             Some(format!(\"\\ncrate `{}`: {}\\n{:>padding$}\",\n@@ -774,35 +774,36 @@ impl<'a> CrateLocator<'a> {\n         }\n \n         if self.exact_paths.is_empty() {\n-            if self.crate_name != root.name {\n+            if self.crate_name != root.name() {\n                 info!(\"Rejecting via crate name\");\n                 return None;\n             }\n         }\n \n-        if root.triple != self.triple {\n+        if root.triple() != &self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n                   self.triple,\n-                  root.triple);\n+                  root.triple());\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: root.triple.to_string(),\n+                got: root.triple().to_string(),\n             });\n             return None;\n         }\n \n-        if let Some(myhash) = self.hash {\n-            if *myhash != root.hash {\n-                info!(\"Rejecting via hash: expected {} got {}\", *myhash, root.hash);\n+        let hash = root.hash();\n+        if let Some(&expected_hash) = self.hash {\n+            if hash != expected_hash {\n+                info!(\"Rejecting via hash: expected {} got {}\", expected_hash, hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n-                    got: myhash.to_string(),\n+                    got: hash.to_string(),\n                 });\n                 return None;\n             }\n         }\n \n-        Some(root.hash)\n+        Some(hash)\n     }\n \n \n@@ -1021,7 +1022,7 @@ pub fn find_plugin_registrar(\n \n     match library.source.dylib {\n         Some(dylib) => {\n-            Some((dylib.0, library.metadata.get_root().disambiguator))\n+            Some((dylib.0, library.metadata.get_root().disambiguator()))\n         }\n         None => {\n             span_err!(sess, span, E0457,"}, {"sha": "db4762847791e5e89bca36fff8d9b29bd23ec7b8", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "patch": "@@ -558,6 +558,22 @@ impl CrateRoot<'_> {\n         self.proc_macro_data.is_some()\n     }\n \n+    crate fn name(&self) -> Symbol {\n+        self.name\n+    }\n+\n+    crate fn disambiguator(&self) -> CrateDisambiguator {\n+        self.disambiguator\n+    }\n+\n+    crate fn hash(&self) -> Svh {\n+        self.hash\n+    }\n+\n+    crate fn triple(&self) -> &TargetTriple {\n+        &self.triple\n+    }\n+\n     crate fn decode_crate_deps(\n         &self,\n         metadata: &'a MetadataBlob,\n@@ -1546,6 +1562,38 @@ impl<'a, 'tcx> CrateMetadata {\n     crate fn update_dep_kind(&self, f: impl FnOnce(DepKind) -> DepKind) {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n+\n+    crate fn panic_strategy(&self) -> PanicStrategy {\n+        self.root.panic_strategy\n+    }\n+\n+    crate fn needs_panic_runtime(&self) -> bool {\n+        self.root.needs_panic_runtime\n+    }\n+\n+    crate fn is_panic_runtime(&self) -> bool {\n+        self.root.panic_runtime\n+    }\n+\n+    crate fn is_sanitizer_runtime(&self) -> bool {\n+        self.root.sanitizer_runtime\n+    }\n+\n+    crate fn is_profiler_runtime(&self) -> bool {\n+        self.root.profiler_runtime\n+    }\n+\n+    crate fn needs_allocator(&self) -> bool {\n+        self.root.needs_allocator\n+    }\n+\n+    crate fn has_global_allocator(&self) -> bool {\n+        self.root.has_global_allocator\n+    }\n+\n+    crate fn has_default_lib_allocator(&self) -> bool {\n+        self.root.has_default_lib_allocator\n+    }\n }\n \n // Cannot be implemented on 'ProcMacro', as libproc_macro"}, {"sha": "4ea562fced304a756946eca01a319a35d881439f", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cef4945fb60c19b7434b7409f1e33dd6922cc8/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=a9cef4945fb60c19b7434b7409f1e33dd6922cc8", "patch": "@@ -173,16 +173,16 @@ macro_rules! Lazy {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct CrateRoot<'tcx> {\n-    pub name: Symbol,\n-    pub triple: TargetTriple,\n+    name: Symbol,\n+    triple: TargetTriple,\n     extra_filename: String,\n-    pub hash: Svh,\n-    pub disambiguator: CrateDisambiguator,\n-    pub panic_strategy: PanicStrategy,\n+    hash: Svh,\n+    disambiguator: CrateDisambiguator,\n+    panic_strategy: PanicStrategy,\n     edition: Edition,\n-    pub has_global_allocator: bool,\n+    has_global_allocator: bool,\n     has_panic_handler: bool,\n-    pub has_default_lib_allocator: bool,\n+    has_default_lib_allocator: bool,\n     plugin_registrar_fn: Option<DefIndex>,\n     proc_macro_decls_static: Option<DefIndex>,\n     proc_macro_stability: Option<attr::Stability>,\n@@ -207,12 +207,12 @@ crate struct CrateRoot<'tcx> {\n     proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     compiler_builtins: bool,\n-    pub needs_allocator: bool,\n-    pub needs_panic_runtime: bool,\n+    needs_allocator: bool,\n+    needs_panic_runtime: bool,\n     no_builtins: bool,\n-    pub panic_runtime: bool,\n-    pub profiler_runtime: bool,\n-    pub sanitizer_runtime: bool,\n+    panic_runtime: bool,\n+    profiler_runtime: bool,\n+    sanitizer_runtime: bool,\n     symbol_mangling_version: SymbolManglingVersion,\n }\n "}]}