{"sha": "4d47601a7e7324de1dd616a535248d908a1543fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNDc2MDFhN2U3MzI0ZGUxZGQ2MTZhNTM1MjQ4ZDkwOGExNTQzZmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T06:22:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T06:21:19Z"}, "message": "rusti: Remove usage of fmt!", "tree": {"sha": "62e1b6df1861d894ab27e2467a01099f876b444c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e1b6df1861d894ab27e2467a01099f876b444c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d47601a7e7324de1dd616a535248d908a1543fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d47601a7e7324de1dd616a535248d908a1543fe", "html_url": "https://github.com/rust-lang/rust/commit/4d47601a7e7324de1dd616a535248d908a1543fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d47601a7e7324de1dd616a535248d908a1543fe/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b80558be38226eb50e6f6d574d7f6ae7e727346", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b80558be38226eb50e6f6d574d7f6ae7e727346", "html_url": "https://github.com/rust-lang/rust/commit/1b80558be38226eb50e6f6d574d7f6ae7e727346"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "0053d7137768d3a9df03cd428fa9055bbb931ba5", "filename": "src/librusti/program.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4d47601a7e7324de1dd616a535248d908a1543fe/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d47601a7e7324de1dd616a535248d908a1543fe/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=4d47601a7e7324de1dd616a535248d908a1543fe", "patch": "@@ -100,7 +100,7 @@ impl Program {\n         // It's easy to initialize things if we don't run things...\n         for (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n-            code.push_str(fmt!(\"let%s %s: %s = fail!();\\n\", mt, *name, var.ty));\n+            code.push_str(format!(\"let{} {}: {} = fail!();\\n\", mt, *name, var.ty));\n             var.alter(*name, &mut code);\n         }\n         code.push_str(\"{\\n\");\n@@ -115,7 +115,7 @@ impl Program {\n         }\n \n         for p in new_locals.iter() {\n-            code.push_str(fmt!(\"assert_encodable(&%s);\\n\", *p.first_ref()));\n+            code.push_str(format!(\"assert_encodable(&{});\\n\", *p.first_ref()));\n         }\n         code.push_str(\"};}\");\n         return code;\n@@ -138,22 +138,22 @@ impl Program {\n         // variables. This works by totally legitimately using the 'code'\n         // pointer of the 'tls_key' function as a uint, and then casting it back\n         // up to a function\n-        code.push_str(fmt!(\"\n-            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe {\n-                let key = ::std::cast::transmute(%u);\n+        code.push_str(format!(\"\n+            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe \\\\{\n+                let key = ::std::cast::transmute({});\n                 ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n-            };\\n\", key as uint));\n+            \\\\};\\n\", key));\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n         for (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n-            code.push_str(fmt!(\"let%s %s: %s = {\n-                let data = __tls_map.get_copy(&~\\\"%s\\\");\n+            code.push_str(format!(\"let{} {}: {} = \\\\{\n+                let data = __tls_map.get_copy(&~\\\"{}\\\");\n                 let doc = ::extra::ebml::reader::Doc(data);\n                 let mut decoder = ::extra::ebml::reader::Decoder(doc);\n                 ::extra::serialize::Decodable::decode(&mut decoder)\n-            };\\n\", mt, *name, var.ty, *name));\n+            \\\\};\\n\", mt, *name, var.ty, *name));\n             var.alter(*name, &mut code);\n         }\n \n@@ -162,7 +162,7 @@ impl Program {\n         code.push_char('\\n');\n \n         match *to_print {\n-            Some(ref s) => { code.push_str(fmt!(\"pp({\\n%s\\n});\", *s)); }\n+            Some(ref s) => { code.push_str(format!(\"pp(\\\\{\\n{}\\n\\\\});\", *s)); }\n             None => {}\n         }\n \n@@ -174,14 +174,14 @@ impl Program {\n         // After the input code is run, we can re-serialize everything back out\n         // into tls map (to be read later on by this task)\n         for (name, var) in self.local_vars.iter() {\n-            code.push_str(fmt!(\"{\n-                let local: %s = %s;\n-                let bytes = do ::std::io::with_bytes_writer |io| {\n+            code.push_str(format!(\"\\\\{\n+                let local: {} = {};\n+                let bytes = do ::std::io::with_bytes_writer |io| \\\\{\n                     let mut enc = ::extra::ebml::writer::Encoder(io);\n                     local.encode(&mut enc);\n-                };\n-                __tls_map.insert(~\\\"%s\\\", @bytes);\n-            }\\n\", var.real_ty(), *name, *name));\n+                \\\\};\n+                __tls_map.insert(~\\\"{}\\\", @bytes);\n+            \\\\}\\n\", var.real_ty(), *name, *name));\n         }\n \n         // Close things up, and we're done.\n@@ -193,14 +193,14 @@ impl Program {\n     fn program_header(&self) -> ~str {\n         // up front, disable lots of annoying lints, then include all global\n         // state such as items, view items, and extern mods.\n-        let mut code = fmt!(\"\n-            #[allow(warnings)];\n+        let mut code = format!(\"\n+            \\\\#[allow(warnings)];\n \n             extern mod extra;\n-            %s // extern mods\n+            {} // extern mods\n \n             use extra::serialize::*;\n-            %s // view items\n+            {} // view items\n         \", self.externs, self.view_items);\n         for (_, s) in self.structs.iter() {\n             // The structs aren't really useful unless they're encodable\n@@ -236,7 +236,7 @@ impl Program {\n         for (name, value) in cons_map.move_iter() {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = (*value).clone(); }\n-                None => { fail!(\"unknown variable %s\", name) }\n+                None => { fail2!(\"unknown variable {}\", name) }\n             }\n         }\n     }\n@@ -272,7 +272,7 @@ impl Program {\n     /// Once the types are known, they are inserted into the local_vars map in\n     /// this Program (to be deserialized later on\n     pub fn register_new_vars(&mut self, blk: &ast::Block, tcx: ty::ctxt) {\n-        debug!(\"looking for new variables\");\n+        debug2!(\"looking for new variables\");\n         let newvars = @mut HashMap::new();\n         do each_user_local(blk) |local| {\n             let mutable = local.is_mutbl;\n@@ -378,7 +378,7 @@ impl Program {\n                     _ => {}\n                 }\n             }\n-            fail!(\"couldn't find user block\");\n+            fail2!(\"couldn't find user block\");\n         }\n     }\n }\n@@ -389,9 +389,9 @@ impl LocalVariable {\n     fn alter(&self, name: &str, code: &mut ~str) {\n         match self.alterations {\n             Some((ref real_ty, ref prefix)) => {\n-                code.push_str(fmt!(\"let%s %s: %s = %s%s;\\n\",\n-                                   self.mt(), name,\n-                                   *real_ty, *prefix, name));\n+                code.push_str(format!(\"let{} {}: {} = {}{};\\n\",\n+                                      self.mt(), name,\n+                                      *real_ty, *prefix, name));\n             }\n             None => {}\n         }"}, {"sha": "a3185ee943872d48047b5a7b7d0eb27815a2653c", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4d47601a7e7324de1dd616a535248d908a1543fe/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d47601a7e7324de1dd616a535248d908a1543fe/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=4d47601a7e7324de1dd616a535248d908a1543fe", "patch": "@@ -156,7 +156,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     //\n     // Stage 1: parse the input and filter it into the program (as necessary)\n     //\n-    debug!(\"parsing: %s\", input);\n+    debug2!(\"parsing: {}\", input);\n     let crate = parse_input(sess, input);\n     let mut to_run = ~[];       // statements to run (emitted back into code)\n     let new_locals = @mut ~[];  // new locals being defined\n@@ -231,11 +231,11 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     // Stage 2: run everything up to typeck to learn the types of the new\n     //          variables introduced into the program\n     //\n-    info!(\"Learning about the new types in the program\");\n+    info2!(\"Learning about the new types in the program\");\n     program.set_cache(); // before register_new_vars (which changes them)\n     let input = to_run.connect(\"\\n\");\n     let test = program.test_code(input, &result, *new_locals);\n-    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n+    debug2!(\"testing with ^^^^^^ {:?}\", (||{ println(test) })());\n     let dinput = driver::str_input(test.to_managed());\n     let cfg = driver::build_configuration(sess);\n \n@@ -252,9 +252,9 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     //\n     // Stage 3: Actually run the code in the JIT\n     //\n-    info!(\"actually running code\");\n+    info2!(\"actually running code\");\n     let code = program.code(input, &result);\n-    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n+    debug2!(\"actually running ^^^^^^ {:?}\", (||{ println(code) })());\n     let input = driver::str_input(code.to_managed());\n     let cfg = driver::build_configuration(sess);\n     let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n@@ -272,7 +272,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     // Stage 4: Inform the program that computation is done so it can update all\n     //          local variable bindings.\n     //\n-    info!(\"cleaning up after code\");\n+    info2!(\"cleaning up after code\");\n     program.consume_cache();\n \n     //\n@@ -284,7 +284,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     return (program, jit::consume_engine());\n \n     fn parse_input(sess: session::Session, input: &str) -> ast::Crate {\n-        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n+        let code = format!(\"fn main() \\\\{\\n {} \\n\\\\}\", input);\n         let input = driver::str_input(code.to_managed());\n         let cfg = driver::build_configuration(sess);\n         driver::phase_1_parse_input(sess, cfg.clone(), &input)\n@@ -302,7 +302,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n                 _ => {}\n             }\n         }\n-        fail!(\"main function was expected somewhere...\");\n+        fail2!(\"main function was expected somewhere...\");\n     }\n }\n \n@@ -355,7 +355,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             None => { },\n         }\n         if (should_compile) {\n-            println(fmt!(\"compiling %s...\", src_filename));\n+            println(format!(\"compiling {}...\", src_filename));\n             let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n             let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n             let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n@@ -429,7 +429,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for crate in loaded_crates.iter() {\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n-                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n+                repl.program.record_extern(format!(\"extern mod {};\", *crate));\n                 if !repl.lib_search_paths.iter().any(|x| x == &crate_dir) {\n                     repl.lib_search_paths.push(crate_dir);\n                 }\n@@ -445,7 +445,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             let mut end_multiline = false;\n             while (!end_multiline) {\n                 match get_line(use_rl, \"rusti| \") {\n-                    None => fail!(\"unterminated multiline command :{ .. :}\"),\n+                    None => fail2!(\"unterminated multiline command :\\\\{ .. :\\\\}\"),\n                     Some(line) => {\n                         if line.trim() == \":}\" {\n                             end_multiline = true;"}]}