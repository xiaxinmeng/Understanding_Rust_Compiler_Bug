{"sha": "661d721e20c5f7ba868cd5b259f2df7b0248c568", "node_id": "C_kwDOAAsO6NoAKDY2MWQ3MjFlMjBjNWY3YmE4NjhjZDViMjU5ZjJkZjdiMDI0OGM1Njg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-02T14:03:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-03T14:51:57Z"}, "message": "Add completion module tailored towards use trees", "tree": {"sha": "2984b0ab10c0eeafb486269e2f8c7bf7d0e7b1b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2984b0ab10c0eeafb486269e2f8c7bf7d0e7b1b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/661d721e20c5f7ba868cd5b259f2df7b0248c568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/661d721e20c5f7ba868cd5b259f2df7b0248c568", "html_url": "https://github.com/rust-lang/rust/commit/661d721e20c5f7ba868cd5b259f2df7b0248c568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/661d721e20c5f7ba868cd5b259f2df7b0248c568/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6940cca76065f7871e53ef2a95019e0841ff408d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6940cca76065f7871e53ef2a95019e0841ff408d", "html_url": "https://github.com/rust-lang/rust/commit/6940cca76065f7871e53ef2a95019e0841ff408d"}], "stats": {"total": 433, "additions": 269, "deletions": 164}, "files": [{"sha": "1e949771ea01ffb8a69adb4c2c89280a41ab9cf9", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -481,7 +481,7 @@ impl HirDisplay for Module {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n             Some(name) => write!(f, \"mod {}\", name),\n-            None if self.crate_root(f.db) == *self => match self.krate().display_name(f.db) {\n+            None if self.is_crate_root(f.db) => match self.krate().display_name(f.db) {\n                 Some(name) => write!(f, \"extern crate {}\", name),\n                 None => write!(f, \"extern crate {{unknown}}\"),\n             },"}, {"sha": "032da5f50af6d1e9f12efdfcd504ef84b6b38402", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -452,6 +452,11 @@ impl Module {\n         Module { id: def_map.module_id(def_map.root()) }\n     }\n \n+    pub fn is_crate_root(self, db: &dyn HirDatabase) -> bool {\n+        let def_map = db.crate_def_map(self.id.krate());\n+        def_map.root() == self.id.local_id\n+    }\n+\n     /// Iterates over all child modules.\n     pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {\n         let def_map = self.id.def_map(db.upcast());"}, {"sha": "715bd28e21d7ca14b798ca4d44693a2a913e4de1", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -4,17 +4,18 @@ pub(crate) mod attribute;\n pub(crate) mod dot;\n pub(crate) mod flyimport;\n pub(crate) mod fn_param;\n+pub(crate) mod format_string;\n pub(crate) mod keyword;\n pub(crate) mod lifetime;\n pub(crate) mod mod_;\n+pub(crate) mod use_;\n pub(crate) mod pattern;\n pub(crate) mod postfix;\n pub(crate) mod qualified_path;\n pub(crate) mod record;\n pub(crate) mod snippet;\n pub(crate) mod trait_impl;\n pub(crate) mod unqualified_path;\n-pub(crate) mod format_string;\n \n use std::iter;\n "}, {"sha": "1a1fa533c16a58a840edeae4ab4954948decdc81", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -1,9 +1,10 @@\n-//! Completion for attributes\n+//! Completion for (built-in) attributes, derives and lints.\n //!\n-//! This module uses a bit of static metadata to provide completions\n-//! for built-in attributes.\n-//! Non-built-in attribute (excluding derives attributes) completions are done in [`super::unqualified_path`].\n+//! This module uses a bit of static metadata to provide completions for builtin-in attributes and lints.\n \n+use std::iter;\n+\n+use hir::ScopeDef;\n use ide_db::{\n     helpers::{\n         generated_lints::{\n@@ -85,24 +86,45 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n         _ => return,\n     };\n \n-    if !is_trivial_path {\n-        return;\n-    }\n+    match qualifier {\n+        Some((path, qualifier)) => {\n+            let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n+                .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n+            if is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n \n-    if let Some((_, Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))))) = qualifier {\n-        for (name, def) in module.scope(ctx.db, ctx.module) {\n-            if let Some(def) = module_or_attr(def) {\n-                acc.add_resolution(ctx, name, def);\n+            let module = match qualifier {\n+                Some(hir::PathResolution::Def(hir::ModuleDef::Module(it))) => it,\n+                _ => return,\n+            };\n+\n+            for (name, def) in module.scope(ctx.db, ctx.module) {\n+                if let Some(def) = module_or_attr(def) {\n+                    acc.add_resolution(ctx, name, def);\n+                }\n             }\n+            return;\n         }\n-        return;\n-    }\n-\n-    ctx.process_all_names(&mut |name, def| {\n-        if let Some(def) = module_or_attr(def) {\n-            acc.add_resolution(ctx, name, def);\n+        // fresh use tree with leading colon2, only show crate roots\n+        None if !is_trivial_path => {\n+            ctx.process_all_names(&mut |name, res| match res {\n+                ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+                _ => (),\n+            });\n         }\n-    });\n+        // only show modules in a fresh UseTree\n+        None => {\n+            ctx.process_all_names(&mut |name, def| {\n+                if let Some(def) = module_or_attr(def) {\n+                    acc.add_resolution(ctx, name, def);\n+                }\n+            });\n+            [\"self::\", \"super::\", \"crate::\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n+        }\n+    }\n \n     let attributes = annotated_item_kind.and_then(|kind| {\n         if ast::Expr::can_cast(kind) {"}, {"sha": "14195e8149a72bfbc7abcd0722950804833632a7", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -1,10 +1,8 @@\n //! Completion of paths, i.e. `some::prefix::$0`.\n \n-use std::iter;\n-\n use hir::{ScopeDef, Trait};\n use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode};\n+use syntax::ast;\n \n use crate::{\n     completions::module_or_fn_macro,\n@@ -17,14 +15,11 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n-    let ((path, resolution), use_tree_parent, kind) = match ctx.path_context {\n+    let ((path, resolution), kind) = match ctx.path_context {\n         // let ... else, syntax would come in really handy here right now\n-        Some(PathCompletionContext {\n-            qualifier: Some(ref qualifier),\n-            use_tree_parent,\n-            kind,\n-            ..\n-        }) => (qualifier, use_tree_parent, kind),\n+        Some(PathCompletionContext { qualifier: Some(ref qualifier), kind, .. }) => {\n+            (qualifier, kind)\n+        }\n         _ => return,\n     };\n \n@@ -86,52 +81,23 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n             return;\n         }\n-        Some(PathKind::Attr { .. }) => {\n+        Some(PathKind::Attr { .. } | PathKind::Use) => {\n             return;\n         }\n-        Some(PathKind::Use) => {\n-            if iter::successors(Some(path.clone()), |p| p.qualifier())\n-                .all(|p| p.segment().and_then(|s| s.super_token()).is_some())\n-            {\n-                acc.add_keyword(ctx, \"super::\");\n-            }\n-            // only show `self` in a new use-tree when the qualifier doesn't end in self\n-            if use_tree_parent\n-                && !matches!(\n-                    path.segment().and_then(|it| it.kind()),\n-                    Some(ast::PathSegmentKind::SelfKw)\n-                )\n-            {\n-                acc.add_keyword(ctx, \"self\");\n-            }\n+        Some(PathKind::Pat) => (),\n+        _ => {\n+            // Add associated types on type parameters and `Self`.\n+            ctx.scope.assoc_type_shorthand_candidates(&resolution, |_, alias| {\n+                acc.add_type_alias(ctx, alias);\n+                None::<()>\n+            });\n         }\n-        _ => (),\n-    }\n-\n-    if !matches!(kind, Some(PathKind::Pat)) {\n-        // Add associated types on type parameters and `Self`.\n-        ctx.scope.assoc_type_shorthand_candidates(&resolution, |_, alias| {\n-            acc.add_type_alias(ctx, alias);\n-            None::<()>\n-        });\n     }\n \n     match resolution {\n         hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n             let module_scope = module.scope(ctx.db, ctx.module);\n             for (name, def) in module_scope {\n-                if let Some(PathKind::Use) = kind {\n-                    if let ScopeDef::Unknown = def {\n-                        if let Some(ast::NameLike::NameRef(name_ref)) = ctx.name_syntax.as_ref() {\n-                            if name_ref.syntax().text() == name.to_smol_str().as_str() {\n-                                // for `use self::foo$0`, don't suggest `foo` as a completion\n-                                cov_mark::hit!(dont_complete_current_use);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-\n                 let add_resolution = match def {\n                     // Don't suggest attribute macros and derives.\n                     ScopeDef::MacroDef(mac) => mac.is_fn_like(),"}, {"sha": "1f78cfdf755636402df523d083a1473a292d226c", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -20,25 +20,11 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         _ => return,\n     };\n \n-    if let Some(PathKind::Use) = kind {\n-        // only show modules in a fresh UseTree\n-        cov_mark::hit!(unqualified_path_only_modules_in_import);\n-        ctx.process_all_names(&mut |name, res| {\n-            if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n-                acc.add_resolution(ctx, name, res);\n-            }\n-        });\n-\n-        [\"self::\", \"super::\", \"crate::\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n-        return;\n-    }\n-    [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n-\n     match kind {\n-        Some(PathKind::Vis { .. }) => return,\n-        Some(PathKind::Attr { .. }) => return,\n+        Some(PathKind::Vis { .. } | PathKind::Attr { .. } | PathKind::Use { .. }) => return,\n         _ => (),\n     }\n+    [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n \n     match &ctx.completion_location {\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {"}, {"sha": "b536095862fceac052a869f13cf02ecbca66ff85", "filename": "crates/ide_completion/src/completions/use_.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -0,0 +1,109 @@\n+//! Completion for use trees\n+//!\n+//! This module uses a bit of static metadata to provide completions\n+//! for built-in attributes.\n+//! Non-built-in attribute (excluding derives attributes) completions are done in [`super::unqualified_path`].\n+\n+use std::iter;\n+\n+use hir::ScopeDef;\n+use syntax::{ast, AstNode};\n+\n+use crate::{\n+    context::{CompletionContext, PathCompletionContext, PathKind},\n+    Completions,\n+};\n+\n+pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (is_trivial_path, qualifier, use_tree_parent) = match ctx.path_context {\n+        Some(PathCompletionContext {\n+            kind: Some(PathKind::Use),\n+            is_trivial_path,\n+            use_tree_parent,\n+            ref qualifier,\n+            ..\n+        }) => (is_trivial_path, qualifier, use_tree_parent),\n+        _ => return,\n+    };\n+\n+    match qualifier {\n+        Some((path, qualifier)) => {\n+            let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n+                .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n+            if is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+            // only show `self` in a new use-tree when the qualifier doesn't end in self\n+            let not_preceded_by_self = use_tree_parent\n+                && !matches!(\n+                    path.segment().and_then(|it| it.kind()),\n+                    Some(ast::PathSegmentKind::SelfKw)\n+                );\n+            if not_preceded_by_self {\n+                acc.add_keyword(ctx, \"self\");\n+            }\n+\n+            let qualifier = match qualifier {\n+                Some(it) => it,\n+                None => return,\n+            };\n+\n+            match qualifier {\n+                hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+                    let module_scope = module.scope(ctx.db, ctx.module);\n+                    let unknown_is_current = |name: &hir::Name| {\n+                        matches!(\n+                            ctx.name_syntax.as_ref(),\n+                            Some(ast::NameLike::NameRef(name_ref))\n+                                if name_ref.syntax().text() == name.to_smol_str().as_str()\n+                        )\n+                    };\n+                    for (name, def) in module_scope {\n+                        let add_resolution = match def {\n+                            ScopeDef::Unknown if unknown_is_current(&name) => {\n+                                // for `use self::foo$0`, don't suggest `foo` as a completion\n+                                cov_mark::hit!(dont_complete_current_use);\n+                                continue;\n+                            }\n+                            ScopeDef::ModuleDef(_) | ScopeDef::MacroDef(_) | ScopeDef::Unknown => {\n+                                true\n+                            }\n+                            _ => false,\n+                        };\n+\n+                        if add_resolution {\n+                            acc.add_resolution(ctx, name, def);\n+                        }\n+                    }\n+                }\n+                hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n+                    cov_mark::hit!(enum_plain_qualified_use_tree);\n+                    e.variants(ctx.db)\n+                        .into_iter()\n+                        .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                }\n+                _ => {}\n+            }\n+        }\n+        // fresh use tree with leading colon2, only show crate roots\n+        None if !is_trivial_path => {\n+            cov_mark::hit!(use_tree_crate_roots_only);\n+            ctx.process_all_names(&mut |name, res| match res {\n+                ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+                _ => (),\n+            });\n+        }\n+        // only show modules in a fresh UseTree\n+        None => {\n+            cov_mark::hit!(unqualified_path_only_modules_in_import);\n+            ctx.process_all_names(&mut |name, res| {\n+                if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+            });\n+            [\"self::\", \"super::\", \"crate::\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n+        }\n+    }\n+}"}, {"sha": "2f7ca13ee88a75bd6db51201b14315d6ad72b209", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -153,6 +153,7 @@ pub fn completions(\n     let mut acc = Completions::default();\n     completions::attribute::complete_known_attribute_input(&mut acc, &ctx);\n     completions::attribute::complete_attribute(&mut acc, &ctx);\n+    completions::use_::complete_use_tree(&mut acc, &ctx);\n     completions::fn_param::complete_fn_param(&mut acc, &ctx);\n     completions::keyword::complete_expr_keyword(&mut acc, &ctx);\n     completions::snippet::complete_expr_snippet(&mut acc, &ctx);"}, {"sha": "5a9c48a3278ced514a0c356480fa7d609d551958", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 73, "deletions": 70, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -18,6 +18,9 @@ struct Foo;\n \"#,\n         expect![[r#\"\n             md proc_macros\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -33,9 +36,6 @@ struct Foo;\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     )\n }\n@@ -61,7 +61,10 @@ fn proc_macros_qualified() {\n #[proc_macros::$0]\n struct Foo;\n \"#,\n-        expect![[r#\"\"#]],\n+        expect![[r#\"\n+            at input_replace pub macro input_replace\n+            at identity      pub macro identity\n+        \"#]],\n     )\n }\n \n@@ -75,15 +78,15 @@ fn with_existing_attr() {\n     check(\n         r#\"#[no_mangle] #[$0] mcall!();\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     )\n }\n@@ -93,6 +96,9 @@ fn attr_on_source_file() {\n     check(\n         r#\"#![$0]\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -113,9 +119,6 @@ fn attr_on_source_file() {\n             at recursion_limit = \"\u2026\"\n             at type_length_limit = \u2026\n             at windows_subsystem = \"\u2026\"\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -125,6 +128,9 @@ fn attr_on_module() {\n     check(\n         r#\"#[$0] mod foo;\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -139,14 +145,14 @@ fn attr_on_module() {\n             at no_mangle\n             at macro_use\n             at path = \"\u2026\"\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n     check(\n         r#\"mod foo {#![$0]}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -160,9 +166,6 @@ fn attr_on_module() {\n             at must_use\n             at no_mangle\n             at no_implicit_prelude\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -172,6 +175,9 @@ fn attr_on_macro_rules() {\n     check(\n         r#\"#[$0] macro_rules! foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -186,9 +192,6 @@ fn attr_on_macro_rules() {\n             at no_mangle\n             at macro_export\n             at macro_use\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -198,6 +201,9 @@ fn attr_on_macro_def() {\n     check(\n         r#\"#[$0] macro foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -210,9 +216,6 @@ fn attr_on_macro_def() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -222,6 +225,9 @@ fn attr_on_extern_crate() {\n     check(\n         r#\"#[$0] extern crate foo;\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -235,9 +241,6 @@ fn attr_on_extern_crate() {\n             at must_use\n             at no_mangle\n             at macro_use\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -247,6 +250,9 @@ fn attr_on_use() {\n     check(\n         r#\"#[$0] use foo;\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -259,9 +265,6 @@ fn attr_on_use() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -271,6 +274,9 @@ fn attr_on_type_alias() {\n     check(\n         r#\"#[$0] type foo = ();\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -283,9 +289,6 @@ fn attr_on_type_alias() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -301,6 +304,9 @@ struct Foo;\n         expect![[r#\"\n             md core\n             at derive           pub macro derive\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -316,9 +322,6 @@ struct Foo;\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -328,6 +331,9 @@ fn attr_on_enum() {\n     check(\n         r#\"#[$0] enum Foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -343,9 +349,6 @@ fn attr_on_enum() {\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -355,6 +358,9 @@ fn attr_on_const() {\n     check(\n         r#\"#[$0] const FOO: () = ();\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -367,9 +373,6 @@ fn attr_on_const() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -379,6 +382,9 @@ fn attr_on_static() {\n     check(\n         r#\"#[$0] static FOO: () = ()\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -396,9 +402,6 @@ fn attr_on_static() {\n             at link_section = \"\u2026\"\n             at global_allocator\n             at used\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -408,6 +411,9 @@ fn attr_on_trait() {\n     check(\n         r#\"#[$0] trait Foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -421,9 +427,6 @@ fn attr_on_trait() {\n             at must_use\n             at no_mangle\n             at must_use\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -433,6 +436,9 @@ fn attr_on_impl() {\n     check(\n         r#\"#[$0] impl () {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -446,14 +452,14 @@ fn attr_on_impl() {\n             at must_use\n             at no_mangle\n             at automatically_derived\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n     check(\n         r#\"impl () {#![$0]}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -466,9 +472,6 @@ fn attr_on_impl() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -478,6 +481,9 @@ fn attr_on_extern_block() {\n     check(\n         r#\"#[$0] extern {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -491,14 +497,14 @@ fn attr_on_extern_block() {\n             at must_use\n             at no_mangle\n             at link\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n     check(\n         r#\"extern {#![$0]}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -512,9 +518,6 @@ fn attr_on_extern_block() {\n             at must_use\n             at no_mangle\n             at link\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -524,16 +527,16 @@ fn attr_on_variant() {\n     check(\n         r#\"enum Foo { #[$0] Bar }\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -543,6 +546,9 @@ fn attr_on_fn() {\n     check(\n         r#\"#[$0] fn main() {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -570,9 +576,6 @@ fn attr_on_fn() {\n             at target_feature = \"\u2026\"\n             at test\n             at track_caller\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -583,15 +586,15 @@ fn attr_on_expr() {\n     check(\n         r#\"fn main() { #[$0] foo() }\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -601,6 +604,9 @@ fn attr_in_source_file_end() {\n     check(\n         r#\"#[$0]\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at automatically_derived\n             at cfg(\u2026)\n@@ -637,9 +643,6 @@ fn attr_in_source_file_end() {\n             at track_caller\n             at used\n             at warn(\u2026)\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }"}, {"sha": "ac7e75bd38e720d0bcc952ca4b4376051dd1f730", "filename": "crates/ide_completion/src/tests/use_tree.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -134,6 +134,25 @@ struct Bar;\n     );\n }\n \n+#[test]\n+fn enum_plain_qualified_use_tree() {\n+    cov_mark::check!(enum_plain_qualified_use_tree);\n+    check(\n+        r#\"\n+use Foo::$0\n+\n+enum Foo { Variant }\n+impl Foo {\n+    const CONST: () = ()\n+    fn func() {}\n+}\n+\"#,\n+        expect![[r#\"\n+            ev Variant ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn self_qualified_use_tree() {\n     check("}, {"sha": "8fdfeccb9a8cf1eadd3849dacab34aca8b751b92", "filename": "crates/ide_completion/src/tests/visibility.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Ftests%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_completion%2Fsrc%2Ftests%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fvisibility.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -17,9 +17,6 @@ pub($0)\n \"#,\n         expect![[r#\"\n             kw in\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -30,11 +27,7 @@ fn after_in_kw() {\n         r#\"\n pub(in $0)\n \"#,\n-        expect![[r#\"\n-            kw self\n-            kw super\n-            kw crate\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n }\n "}, {"sha": "7ea2bc63f25cad0df0f52d4b1909b003cd70411b", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661d721e20c5f7ba868cd5b259f2df7b0248c568/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=661d721e20c5f7ba868cd5b259f2df7b0248c568", "patch": "@@ -223,7 +223,7 @@ impl Definition {\n         // def is crate root\n         // FIXME: We don't do searches for crates currently, as a crate does not actually have a single name\n         if let &Definition::Module(module) = self {\n-            if module.crate_root(db) == module {\n+            if module.is_crate_root(db) {\n                 return SearchScope::reverse_dependencies(db, module.krate());\n             }\n         }\n@@ -378,7 +378,7 @@ impl<'a> FindUsages<'a> {\n \n         let name = match self.def {\n             // special case crate modules as these do not have a proper name\n-            Definition::Module(module) if module.crate_root(self.sema.db) == module => {\n+            Definition::Module(module) if module.is_crate_root(self.sema.db) => {\n                 // FIXME: This assumes the crate name is always equal to its display name when it really isn't\n                 module\n                     .krate()\n@@ -460,7 +460,7 @@ impl<'a> FindUsages<'a> {\n             Definition::Module(module) => {\n                 let scope = search_scope.intersection(&SearchScope::module(self.sema.db, module));\n \n-                let is_crate_root = module.crate_root(self.sema.db) == module;\n+                let is_crate_root = module.is_crate_root(self.sema.db);\n \n                 for (text, file_id, search_range) in scope_files(sema, &scope) {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());"}]}