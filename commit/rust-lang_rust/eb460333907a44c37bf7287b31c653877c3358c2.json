{"sha": "eb460333907a44c37bf7287b31c653877c3358c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNDYwMzMzOTA3YTQ0YzM3YmY3Mjg3YjMxYzY1Mzg3N2MzMzU4YzI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-11-06T18:01:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-11-06T18:09:01Z"}, "message": "More orthogonal API", "tree": {"sha": "1f048935ea6b51cc1e5f01d0613552264b31f02d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f048935ea6b51cc1e5f01d0613552264b31f02d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb460333907a44c37bf7287b31c653877c3358c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb460333907a44c37bf7287b31c653877c3358c2", "html_url": "https://github.com/rust-lang/rust/commit/eb460333907a44c37bf7287b31c653877c3358c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb460333907a44c37bf7287b31c653877c3358c2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "735aaa7b39b4d3d789ad75c167bbf322a65ca257", "url": "https://api.github.com/repos/rust-lang/rust/commits/735aaa7b39b4d3d789ad75c167bbf322a65ca257", "html_url": "https://github.com/rust-lang/rust/commit/735aaa7b39b4d3d789ad75c167bbf322a65ca257"}], "stats": {"total": 86, "additions": 38, "deletions": 48}, "files": [{"sha": "5957834d307349f2dd4047a58816f1f9bf941520", "filename": "crates/assists/src/handlers/convert_integer_literal.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eb460333907a44c37bf7287b31c653877c3358c2/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb460333907a44c37bf7287b31c653877c3358c2/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=eb460333907a44c37bf7287b31c653877c3358c2", "patch": "@@ -1,4 +1,4 @@\n-use syntax::{ast, ast::Radix, AstNode};\n+use syntax::{ast, ast::Radix, AstToken};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n \n@@ -14,15 +14,13 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // const _: i32 = 0b1010;\n // ```\n pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let literal = ctx.find_node_at_offset::<ast::Literal>()?;\n-    let (radix, value) = literal.as_int_number()?.value()?;\n+    let literal = ctx.find_node_at_offset::<ast::Literal>()?.as_int_number()?;\n+    let radix = literal.radix();\n+    let value = literal.value()?;\n+    let suffix = literal.suffix();\n \n     let range = literal.syntax().text_range();\n     let group_id = GroupLabel(\"Convert integer base\".into());\n-    let suffix = match literal.kind() {\n-        ast::LiteralKind::IntNumber { suffix } => suffix,\n-        _ => return None,\n-    };\n \n     for &target_radix in Radix::ALL {\n         if target_radix == radix {\n@@ -36,16 +34,11 @@ pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext) ->\n             Radix::Hexadecimal => format!(\"0x{:X}\", value),\n         };\n \n-        let label = format!(\n-            \"Convert {} to {}{}\",\n-            literal,\n-            converted,\n-            suffix.as_deref().unwrap_or_default()\n-        );\n+        let label = format!(\"Convert {} to {}{}\", literal, converted, suffix.unwrap_or_default());\n \n         // Appends the type suffix back into the new literal if it exists.\n-        if let Some(suffix) = &suffix {\n-            converted.push_str(&suffix);\n+        if let Some(suffix) = suffix {\n+            converted.push_str(suffix);\n         }\n \n         acc.add_group("}, {"sha": "8d3fad5a6c6f6f42896109f3ef9885aa9244ee35", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/eb460333907a44c37bf7287b31c653877c3358c2/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb460333907a44c37bf7287b31c653877c3358c2/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=eb460333907a44c37bf7287b31c653877c3358c2", "patch": "@@ -166,6 +166,7 @@ impl HasStringValue for ast::String {\n     }\n }\n \n+// FIXME: merge `ast::RawString` and `ast::String`.\n impl HasStringValue for ast::RawString {\n     fn value(&self) -> Option<Cow<'_, str>> {\n         let text = self.text().as_str();\n@@ -544,29 +545,46 @@ impl ast::IntNumber {\n         \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\",\n     ];\n \n-    // FIXME: should probably introduce string token type?\n-    // https://github.com/rust-analyzer/rust-analyzer/issues/6308\n-    pub fn value(&self) -> Option<(Radix, u128)> {\n+    pub fn radix(&self) -> Radix {\n+        match self.text().get(..2).unwrap_or_default() {\n+            \"0b\" => Radix::Binary,\n+            \"0o\" => Radix::Octal,\n+            \"0x\" => Radix::Hexadecimal,\n+            _ => Radix::Decimal,\n+        }\n+    }\n+\n+    pub fn value(&self) -> Option<u128> {\n         let token = self.syntax();\n \n         let mut text = token.text().as_str();\n-        for suffix in ast::IntNumber::SUFFIXES {\n-            if let Some(without_suffix) = text.strip_suffix(suffix) {\n-                text = without_suffix;\n-                break;\n-            }\n+        if let Some(suffix) = self.suffix() {\n+            text = &text[..text.len() - suffix.len()]\n         }\n \n+        let radix = self.radix();\n+        text = &text[radix.prefix_len()..];\n+\n         let buf;\n         if text.contains(\"_\") {\n             buf = text.replace('_', \"\");\n             text = buf.as_str();\n         };\n \n-        let radix = Radix::identify(text)?;\n-        let digits = &text[radix.prefix_len()..];\n-        let value = u128::from_str_radix(digits, radix as u32).ok()?;\n-        Some((radix, value))\n+        let value = u128::from_str_radix(text, radix as u32).ok()?;\n+        Some(value)\n+    }\n+\n+    pub fn suffix(&self) -> Option<&str> {\n+        let text = self.text();\n+        // FIXME: don't check a fixed set of suffixes, `1_0_1___lol` is valid\n+        // syntax, suffix is `lol`.\n+        ast::IntNumber::SUFFIXES.iter().find_map(|suffix| {\n+            if text.ends_with(suffix) {\n+                return Some(&text[text.len() - suffix.len()..]);\n+            }\n+            None\n+        })\n     }\n }\n \n@@ -586,27 +604,6 @@ impl Radix {\n     pub const ALL: &'static [Radix] =\n         &[Radix::Binary, Radix::Octal, Radix::Decimal, Radix::Hexadecimal];\n \n-    fn identify(literal_text: &str) -> Option<Self> {\n-        // We cannot express a literal in anything other than decimal in under 3 characters, so we return here if possible.\n-        if literal_text.len() < 3 && literal_text.chars().all(|c| c.is_digit(10)) {\n-            return Some(Self::Decimal);\n-        }\n-\n-        let res = match &literal_text[..2] {\n-            \"0b\" => Radix::Binary,\n-            \"0o\" => Radix::Octal,\n-            \"0x\" => Radix::Hexadecimal,\n-            _ => Radix::Decimal,\n-        };\n-\n-        // Checks that all characters after the base prefix are all valid digits for that base.\n-        if literal_text[res.prefix_len()..].chars().all(|c| c.is_digit(res as u32)) {\n-            Some(res)\n-        } else {\n-            None\n-        }\n-    }\n-\n     const fn prefix_len(&self) -> usize {\n         match self {\n             Self::Decimal => 0,"}]}