{"sha": "4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNzllMmZhMDhiZjMxMTI1ZWZhMWE5ZDhiYzNjODViMTZlMmMyZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-08T18:11:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-08T18:11:06Z"}, "message": "Auto merge of #39645 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 11 pull requests\n\n- Successful merges: #39462, #39512, #39529, #39557, #39561, #39582, #39583, #39597, #39622, #39624, #39630\n- Failed merges:", "tree": {"sha": "58de9050e9127eb919f6f11cb93bd951b457b644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58de9050e9127eb919f6f11cb93bd951b457b644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "html_url": "https://github.com/rust-lang/rust/commit/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f6a5c4431e09d355a0ba319a630e02a1e38361", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f6a5c4431e09d355a0ba319a630e02a1e38361", "html_url": "https://github.com/rust-lang/rust/commit/10f6a5c4431e09d355a0ba319a630e02a1e38361"}, {"sha": "62d22678d4a7c6a34837137073d8767166d6db1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/62d22678d4a7c6a34837137073d8767166d6db1e", "html_url": "https://github.com/rust-lang/rust/commit/62d22678d4a7c6a34837137073d8767166d6db1e"}], "stats": {"total": 3528, "additions": 1922, "deletions": 1606}, "files": [{"sha": "2df1a83db81ffb3a5fa806a3ffd44863e582ae3b", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -1,4 +1,4 @@\n-Version 1.15.1 (2017-02-07)\n+Version 1.15.1 (2017-02-08)\n ===========================\n \n * [Fix IntoIter::as_mut_slice's signature][39466]"}, {"sha": "a66ed46fe464f5bb1185e4a25a4fb4d2a50b4ba0", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -24,6 +24,7 @@ use Build;\n pub fn clean(build: &Build) {\n     rm_rf(build, \"tmp\".as_ref());\n     rm_rf(build, &build.out.join(\"tmp\"));\n+    rm_rf(build, &build.out.join(\"dist\"));\n \n     for host in build.config.host.iter() {\n         let entries = match build.out.join(host).read_dir() {"}, {"sha": "02b2171a224d0ae2b0111a5445f83b54fc88c9c3", "filename": "src/libcollections/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -16,7 +16,6 @@ std_unicode = { path = \"../libstd_unicode\" }\n name = \"collectionstest\"\n path = \"../libcollectionstest/lib.rs\"\n \n-# FIXME: need to extract benchmarks to separate crate\n-#[[bench]]\n-#name = \"collectionstest\"\n-#path = \"../libcollectionstest/lib.rs\"\n+[[bench]]\n+name = \"collectionsbenches\"\n+path = \"../libcollections/benches/lib.rs\""}, {"sha": "744afb991b00e99ebf4eff3cc8c7836796d6139c", "filename": "src/libcollections/benches/btree/map.rs", "status": "renamed", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fbtree%2Fmap.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+use std::iter::Iterator;\n+use std::vec::Vec;\n+use std::collections::BTreeMap;\n+use std::__rand::{Rng, thread_rng};\n+use test::{Bencher, black_box};\n+\n macro_rules! map_insert_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use std::__rand::{thread_rng, Rng};\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let n: usize = $n;\n             let mut map = $map::new();\n             // setup\n@@ -39,9 +43,7 @@ macro_rules! map_insert_rand_bench {\n macro_rules! map_insert_seq_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n             let n: usize = $n;\n             // setup\n@@ -64,12 +66,7 @@ macro_rules! map_insert_seq_bench {\n macro_rules! map_find_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use std::iter::Iterator;\n-            use std::__rand::{thread_rng, Rng};\n-            use std::vec::Vec;\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n             let n: usize = $n;\n \n@@ -97,9 +94,7 @@ macro_rules! map_find_rand_bench {\n macro_rules! map_find_seq_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n             let n: usize = $n;\n \n@@ -118,3 +113,45 @@ macro_rules! map_find_seq_bench {\n         }\n     )\n }\n+\n+map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n+map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+\n+map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n+map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+\n+map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n+map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+\n+map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n+map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+\n+fn bench_iter(b: &mut Bencher, size: i32) {\n+    let mut map = BTreeMap::<i32, i32>::new();\n+    let mut rng = thread_rng();\n+\n+    for _ in 0..size {\n+        map.insert(rng.gen(), rng.gen());\n+    }\n+\n+    b.iter(|| {\n+        for entry in &map {\n+            black_box(entry);\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn iter_20(b: &mut Bencher) {\n+    bench_iter(b, 20);\n+}\n+\n+#[bench]\n+pub fn iter_1000(b: &mut Bencher) {\n+    bench_iter(b, 1000);\n+}\n+\n+#[bench]\n+pub fn iter_100000(b: &mut Bencher) {\n+    bench_iter(b, 100000);\n+}", "previous_filename": "src/libcollectionstest/bench.rs"}, {"sha": "f436b0ac0c0375063da64723236781c25f628b41", "filename": "src/libcollections/benches/btree/mod.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fbtree%2Fmod.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod map;"}, {"sha": "1a21db5e344e3556e232eda8a5e89a588440e2fd", "filename": "src/libcollections/benches/lib.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Flib.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+#![feature(rand)]\n+#![feature(test)]\n+\n+extern crate test;\n+\n+mod btree;\n+mod linked_list;\n+mod string;\n+mod str;\n+mod slice;\n+mod vec;\n+mod vec_deque;"}, {"sha": "bbac44553f18a267bfd7b016a3677d5e3e77ede5", "filename": "src/libcollections/benches/linked_list.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Flinked_list.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::LinkedList;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_collect_into(b: &mut Bencher) {\n+    let v = &[0; 64];\n+    b.iter(|| {\n+        let _: LinkedList<_> = v.iter().cloned().collect();\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_front(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_front(0);\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_back(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_back(0);\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_back_pop_back(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_back(0);\n+        m.pop_back();\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_front_pop_front(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_front(0);\n+        m.pop_front();\n+    })\n+}\n+\n+#[bench]\n+fn bench_iter(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_mut(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let mut m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter_mut().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_rev(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter().rev().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_mut_rev(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let mut m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter_mut().rev().count() == 128);\n+    })\n+}"}, {"sha": "eb4b76509f913693d45627b0e21aa5d1ea094ad2", "filename": "src/libcollections/benches/slice.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fslice.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,280 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{mem, ptr};\n+use std::__rand::{Rng, thread_rng};\n+\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn iterator(b: &mut Bencher) {\n+    // peculiar numbers to stop LLVM from optimising the summation\n+    // out.\n+    let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for x in &v {\n+            sum += *x;\n+        }\n+        // sum == 11806, to stop dead code elimination.\n+        if sum == 0 {\n+            panic!()\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn mut_iterator(b: &mut Bencher) {\n+    let mut v = vec![0; 100];\n+\n+    b.iter(|| {\n+        let mut i = 0;\n+        for x in &mut v {\n+            *x = i;\n+            i += 1;\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn concat(b: &mut Bencher) {\n+    let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n+    b.iter(|| {\n+        xss.concat();\n+    });\n+}\n+\n+#[bench]\n+fn join(b: &mut Bencher) {\n+    let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n+    b.iter(|| xss.join(&0));\n+}\n+\n+#[bench]\n+fn push(b: &mut Bencher) {\n+    let mut vec = Vec::<i32>::new();\n+    b.iter(|| {\n+        vec.push(0);\n+        black_box(&vec);\n+    });\n+}\n+\n+#[bench]\n+fn starts_with_same_vector(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    b.iter(|| vec.starts_with(&vec))\n+}\n+\n+#[bench]\n+fn starts_with_single_element(b: &mut Bencher) {\n+    let vec: Vec<_> = vec![0];\n+    b.iter(|| vec.starts_with(&vec))\n+}\n+\n+#[bench]\n+fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    let mut match_vec: Vec<_> = (0..99).collect();\n+    match_vec.push(0);\n+    b.iter(|| vec.starts_with(&match_vec))\n+}\n+\n+#[bench]\n+fn ends_with_same_vector(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    b.iter(|| vec.ends_with(&vec))\n+}\n+\n+#[bench]\n+fn ends_with_single_element(b: &mut Bencher) {\n+    let vec: Vec<_> = vec![0];\n+    b.iter(|| vec.ends_with(&vec))\n+}\n+\n+#[bench]\n+fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    let mut match_vec: Vec<_> = (0..100).collect();\n+    match_vec[0] = 200;\n+    b.iter(|| vec.starts_with(&match_vec))\n+}\n+\n+#[bench]\n+fn contains_last_element(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    b.iter(|| vec.contains(&99))\n+}\n+\n+#[bench]\n+fn zero_1kb_from_elem(b: &mut Bencher) {\n+    b.iter(|| vec![0u8; 1024]);\n+}\n+\n+#[bench]\n+fn zero_1kb_set_memory(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut v = Vec::<u8>::with_capacity(1024);\n+        unsafe {\n+            let vp = v.as_mut_ptr();\n+            ptr::write_bytes(vp, 0, 1024);\n+            v.set_len(1024);\n+        }\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn zero_1kb_loop_set(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut v = Vec::<u8>::with_capacity(1024);\n+        unsafe {\n+            v.set_len(1024);\n+        }\n+        for i in 0..1024 {\n+            v[i] = 0;\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn zero_1kb_mut_iter(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut v = Vec::<u8>::with_capacity(1024);\n+        unsafe {\n+            v.set_len(1024);\n+        }\n+        for x in &mut v {\n+            *x = 0;\n+        }\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn random_inserts(b: &mut Bencher) {\n+    let mut rng = thread_rng();\n+    b.iter(|| {\n+        let mut v = vec![(0, 0); 30];\n+        for _ in 0..100 {\n+            let l = v.len();\n+            v.insert(rng.gen::<usize>() % (l + 1), (1, 1));\n+        }\n+    })\n+}\n+#[bench]\n+fn random_removes(b: &mut Bencher) {\n+    let mut rng = thread_rng();\n+    b.iter(|| {\n+        let mut v = vec![(0, 0); 130];\n+        for _ in 0..100 {\n+            let l = v.len();\n+            v.remove(rng.gen::<usize>() % l);\n+        }\n+    })\n+}\n+\n+fn gen_ascending(len: usize) -> Vec<u64> {\n+    (0..len as u64).collect()\n+}\n+\n+fn gen_descending(len: usize) -> Vec<u64> {\n+    (0..len as u64).rev().collect()\n+}\n+\n+fn gen_random(len: usize) -> Vec<u64> {\n+    let mut rng = thread_rng();\n+    rng.gen_iter::<u64>().take(len).collect()\n+}\n+\n+fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n+    let mut rng = thread_rng();\n+    let mut v = gen_ascending(len);\n+    for _ in (0usize..).take_while(|x| x * x <= len) {\n+        let x = rng.gen::<usize>() % len;\n+        let y = rng.gen::<usize>() % len;\n+        v.swap(x, y);\n+    }\n+    v\n+}\n+\n+fn gen_mostly_descending(len: usize) -> Vec<u64> {\n+    let mut rng = thread_rng();\n+    let mut v = gen_descending(len);\n+    for _ in (0usize..).take_while(|x| x * x <= len) {\n+        let x = rng.gen::<usize>() % len;\n+        let y = rng.gen::<usize>() % len;\n+        v.swap(x, y);\n+    }\n+    v\n+}\n+\n+fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n+    let mut rng = thread_rng();\n+    rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n+}\n+\n+fn gen_big_ascending(len: usize) -> Vec<[u64; 16]> {\n+    (0..len as u64).map(|x| [x; 16]).take(len).collect()\n+}\n+\n+fn gen_big_descending(len: usize) -> Vec<[u64; 16]> {\n+    (0..len as u64).rev().map(|x| [x; 16]).take(len).collect()\n+}\n+\n+macro_rules! sort_bench {\n+    ($name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            b.iter(|| $gen($len).sort());\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+        }\n+    }\n+}\n+\n+sort_bench!(sort_small_random, gen_random, 10);\n+sort_bench!(sort_small_ascending, gen_ascending, 10);\n+sort_bench!(sort_small_descending, gen_descending, 10);\n+\n+sort_bench!(sort_small_big_random, gen_big_random, 10);\n+sort_bench!(sort_small_big_ascending, gen_big_ascending, 10);\n+sort_bench!(sort_small_big_descending, gen_big_descending, 10);\n+\n+sort_bench!(sort_medium_random, gen_random, 100);\n+sort_bench!(sort_medium_ascending, gen_ascending, 100);\n+sort_bench!(sort_medium_descending, gen_descending, 100);\n+\n+sort_bench!(sort_large_random, gen_random, 10000);\n+sort_bench!(sort_large_ascending, gen_ascending, 10000);\n+sort_bench!(sort_large_descending, gen_descending, 10000);\n+sort_bench!(sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n+sort_bench!(sort_large_mostly_descending, gen_mostly_descending, 10000);\n+\n+sort_bench!(sort_large_big_random, gen_big_random, 10000);\n+sort_bench!(sort_large_big_ascending, gen_big_ascending, 10000);\n+sort_bench!(sort_large_big_descending, gen_big_descending, 10000);\n+\n+#[bench]\n+fn sort_large_random_expensive(b: &mut Bencher) {\n+    let len = 10000;\n+    b.iter(|| {\n+        let mut v = gen_random(len);\n+        let mut count = 0;\n+        v.sort_by(|a: &u64, b: &u64| {\n+            count += 1;\n+            if count % 1_000_000_000 == 0 {\n+                panic!(\"should not happen\");\n+            }\n+            (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n+        });\n+        black_box(count);\n+    });\n+    b.bytes = len as u64 * mem::size_of::<u64>() as u64;\n+}\n\\ No newline at end of file"}, {"sha": "7f727078101c463ef62d85ca1c48e828d02bfa8c", "filename": "src/libcollections/benches/str.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fstr.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,298 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn char_iterator(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| s.chars().count());\n+}\n+\n+#[bench]\n+fn char_iterator_for(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| {\n+        for ch in s.chars() { black_box(ch); }\n+    });\n+}\n+\n+#[bench]\n+fn char_iterator_ascii(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| s.chars().count());\n+}\n+\n+#[bench]\n+fn char_iterator_rev(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| s.chars().rev().count());\n+}\n+\n+#[bench]\n+fn char_iterator_rev_for(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| {\n+        for ch in s.chars().rev() { black_box(ch); }\n+    });\n+}\n+\n+#[bench]\n+fn char_indicesator(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    let len = s.chars().count();\n+\n+    b.iter(|| assert_eq!(s.char_indices().count(), len));\n+}\n+\n+#[bench]\n+fn char_indicesator_rev(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    let len = s.chars().count();\n+\n+    b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n+}\n+\n+#[bench]\n+fn split_unicode_ascii(b: &mut Bencher) {\n+    let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+    b.iter(|| assert_eq!(s.split('V').count(), 3));\n+}\n+\n+#[bench]\n+fn split_ascii(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+\n+    b.iter(|| assert_eq!(s.split(' ').count(), len));\n+}\n+\n+#[bench]\n+fn split_extern_fn(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+    fn pred(c: char) -> bool { c == ' ' }\n+\n+    b.iter(|| assert_eq!(s.split(pred).count(), len));\n+}\n+\n+#[bench]\n+fn split_closure(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+\n+    b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n+}\n+\n+#[bench]\n+fn split_slice(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+\n+    let c: &[char] = &[' '];\n+    b.iter(|| assert_eq!(s.split(c).count(), len));\n+}\n+\n+#[bench]\n+fn bench_join(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    let sep = \"\u2192\";\n+    let v = vec![s, s, s, s, s, s, s, s, s, s];\n+    b.iter(|| {\n+        assert_eq!(v.join(sep).len(), s.len() * 10 + sep.len() * 9);\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_short_short(b: &mut Bencher) {\n+    let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+    let needle = \"sit\";\n+\n+    b.iter(|| {\n+        assert!(haystack.contains(needle));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_short_long(b: &mut Bencher) {\n+    let haystack = \"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum.\";\n+    let needle = \"english\";\n+\n+    b.iter(|| {\n+        assert!(!haystack.contains(needle));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_bad_naive(b: &mut Bencher) {\n+    let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+    let needle = \"aaaaaaaab\";\n+\n+    b.iter(|| {\n+        assert!(!haystack.contains(needle));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_equal(b: &mut Bencher) {\n+    let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+    let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+\n+    b.iter(|| {\n+        assert!(haystack.contains(needle));\n+    })\n+}\n+\n+macro_rules! make_test_inner {\n+    ($s:ident, $code:expr, $name:ident, $str:expr) => {\n+        #[bench]\n+        fn $name(bencher: &mut Bencher) {\n+            let mut $s = $str;\n+            black_box(&mut $s);\n+            bencher.iter(|| $code);\n+        }\n+    }\n+}\n+\n+macro_rules! make_test {\n+    ($name:ident, $s:ident, $code:expr) => {\n+        mod $name {\n+            use test::Bencher;\n+            use test::black_box;\n+\n+            // Short strings: 65 bytes each\n+            make_test_inner!($s, $code, short_ascii,\n+                \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n+            make_test_inner!($s, $code, short_mixed,\n+                \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n+            make_test_inner!($s, $code, short_pile_of_poo,\n+                \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n+            make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum!\");\n+        }\n+    }\n+}\n+\n+make_test!(chars_count, s, s.chars().count());\n+\n+make_test!(contains_bang_str, s, s.contains(\"!\"));\n+make_test!(contains_bang_char, s, s.contains('!'));\n+\n+make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n+\n+make_test!(split_a_str, s, s.split(\"a\").count());\n+\n+make_test!(trim_ascii_char, s, {\n+    use std::ascii::AsciiExt;\n+    s.trim_matches(|c: char| c.is_ascii())\n+});\n+make_test!(trim_left_ascii_char, s, {\n+    use std::ascii::AsciiExt;\n+    s.trim_left_matches(|c: char| c.is_ascii())\n+});\n+make_test!(trim_right_ascii_char, s, {\n+    use std::ascii::AsciiExt;\n+    s.trim_right_matches(|c: char| c.is_ascii())\n+});\n+\n+make_test!(find_underscore_char, s, s.find('_'));\n+make_test!(rfind_underscore_char, s, s.rfind('_'));\n+make_test!(find_underscore_str, s, s.find(\"_\"));\n+\n+make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n+make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n+make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n+\n+make_test!(split_space_char, s, s.split(' ').count());\n+make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n+\n+make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n+make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n+\n+make_test!(split_space_str, s, s.split(\" \").count());\n+make_test!(split_ad_str, s, s.split(\"ad\").count());"}, {"sha": "36be21d978e1fdac8574e031a233a2915d062762", "filename": "src/libcollections/benches/string.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fstring.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::repeat;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_with_capacity(b: &mut Bencher) {\n+    b.iter(|| String::with_capacity(100));\n+}\n+\n+#[bench]\n+fn bench_push_str(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    b.iter(|| {\n+        let mut r = String::new();\n+        r.push_str(s);\n+    });\n+}\n+\n+const REPETITIONS: u64 = 10_000;\n+\n+#[bench]\n+fn bench_push_str_one_byte(b: &mut Bencher) {\n+    b.bytes = REPETITIONS;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push_str(\"a\")\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_char_one_byte(b: &mut Bencher) {\n+    b.bytes = REPETITIONS;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push('a')\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_char_two_bytes(b: &mut Bencher) {\n+    b.bytes = REPETITIONS * 2;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push('\u00e2')\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n+    let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+              Lorem ipsum dolor sit amet, consectetur. \";\n+\n+    assert_eq!(100, s.len());\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n+    let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n+    assert_eq!(100, s.len());\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_invalid(b: &mut Bencher) {\n+    let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n+    let s = repeat(0xf5).take(100).collect::<Vec<_>>();\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(&s);\n+    });\n+}\n+\n+#[bench]\n+fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    // ensure our operation produces an exact-size string before we benchmark it\n+    let mut r = String::with_capacity(s.len());\n+    r.push_str(s);\n+    assert_eq!(r.len(), r.capacity());\n+    b.iter(|| {\n+        let mut r = String::with_capacity(s.len());\n+        r.push_str(s);\n+        r.shrink_to_fit();\n+        r\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_str(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    b.iter(|| String::from(s))\n+}\n+\n+#[bench]\n+fn bench_from(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    b.iter(|| String::from(s))\n+}\n+\n+#[bench]\n+fn bench_to_string(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    b.iter(|| s.to_string())\n+}"}, {"sha": "414901170683effec41392bb7c3002e44a156d5a", "filename": "src/libcollections/benches/vec.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fvec.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,492 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::Bencher;\n+use std::iter::{FromIterator, repeat};\n+\n+#[bench]\n+fn bench_new(b: &mut Bencher) {\n+    b.iter(|| {\n+        let v: Vec<u32> = Vec::new();\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), 0);\n+    })\n+}\n+\n+fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let v: Vec<u32> = Vec::with_capacity(src_len);\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), src_len);\n+    })\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0000(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 0)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0010(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 10)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0100(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 100)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_1000(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 1000)\n+}\n+\n+fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = (0..src_len).collect::<Vec<_>>();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_fn_0000(b: &mut Bencher) {\n+    do_bench_from_fn(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_fn_0010(b: &mut Bencher) {\n+    do_bench_from_fn(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_fn_0100(b: &mut Bencher) {\n+    do_bench_from_fn(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_fn_1000(b: &mut Bencher) {\n+    do_bench_from_fn(b, 1000)\n+}\n+\n+fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst: Vec<usize> = repeat(5).take(src_len).collect();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().all(|x| *x == 5));\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_elem_0000(b: &mut Bencher) {\n+    do_bench_from_elem(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_elem_0010(b: &mut Bencher) {\n+    do_bench_from_elem(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_elem_0100(b: &mut Bencher) {\n+    do_bench_from_elem(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_elem_1000(b: &mut Bencher) {\n+    do_bench_from_elem(b, 1000)\n+}\n+\n+fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = src.clone()[..].to_vec();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_slice_0000(b: &mut Bencher) {\n+    do_bench_from_slice(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_slice_0010(b: &mut Bencher) {\n+    do_bench_from_slice(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_slice_0100(b: &mut Bencher) {\n+    do_bench_from_slice(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_slice_1000(b: &mut Bencher) {\n+    do_bench_from_slice(b, 1000)\n+}\n+\n+fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst: Vec<_> = FromIterator::from_iter(src.clone());\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_iter_0000(b: &mut Bencher) {\n+    do_bench_from_iter(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_iter_0010(b: &mut Bencher) {\n+    do_bench_from_iter(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_iter_0100(b: &mut Bencher) {\n+    do_bench_from_iter(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_iter_1000(b: &mut Bencher) {\n+    do_bench_from_iter(b, 1000)\n+}\n+\n+fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend(src.clone());\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0000(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0010(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0100(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_1000(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_extend_0010_0010(b: &mut Bencher) {\n+    do_bench_extend(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_extend_0100_0100(b: &mut Bencher) {\n+    do_bench_extend(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_extend_1000_1000(b: &mut Bencher) {\n+    do_bench_extend(b, 1000, 1000)\n+}\n+\n+fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend_from_slice(&src);\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0000(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0010(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0100(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_1000(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_push_all_0010_0010(b: &mut Bencher) {\n+    do_bench_push_all(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_0100_0100(b: &mut Bencher) {\n+    do_bench_push_all(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_1000_1000(b: &mut Bencher) {\n+    do_bench_push_all(b, 1000, 1000)\n+}\n+\n+fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend(src.clone());\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 1000, 1000)\n+}\n+\n+fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = src.clone();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_clone_0000(b: &mut Bencher) {\n+    do_bench_clone(b, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_0010(b: &mut Bencher) {\n+    do_bench_clone(b, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_0100(b: &mut Bencher) {\n+    do_bench_clone(b, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_1000(b: &mut Bencher) {\n+    do_bench_clone(b, 1000)\n+}\n+\n+fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = (times * src_len) as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+\n+        for _ in 0..times {\n+            dst.clone_from(&src);\n+\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 1000, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 1000, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 1000, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 1000, 100)\n+}"}, {"sha": "380645e7cd03a9236f31f2ff4cdd88b61fa54aac", "filename": "src/libcollections/benches/vec_deque.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollections%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fvec_deque.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::VecDeque;\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn bench_new(b: &mut Bencher) {\n+    b.iter(|| {\n+        let ring: VecDeque<i32> = VecDeque::new();\n+        black_box(ring);\n+    })\n+}\n+\n+#[bench]\n+fn bench_grow_1025(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut deq = VecDeque::new();\n+        for i in 0..1025 {\n+            deq.push_front(i);\n+        }\n+        black_box(deq);\n+    })\n+}\n+\n+#[bench]\n+fn bench_iter_1000(b: &mut Bencher) {\n+    let ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for &i in &ring {\n+            sum += i;\n+        }\n+        black_box(sum);\n+    })\n+}\n+\n+#[bench]\n+fn bench_mut_iter_1000(b: &mut Bencher) {\n+    let mut ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for i in &mut ring {\n+            sum += *i;\n+        }\n+        black_box(sum);\n+    })\n+}"}, {"sha": "11be13426e49cebb93ade022297b828e801485a5", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -606,52 +606,3 @@ fn test_split_off_large_random_sorted() {\n     assert!(map.into_iter().eq(data.clone().into_iter().filter(|x| x.0 < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| x.0 >= key)));\n }\n-\n-mod bench {\n-    use std::collections::BTreeMap;\n-    use std::__rand::{Rng, thread_rng};\n-\n-    use test::{Bencher, black_box};\n-\n-    map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-    map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n-\n-    map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-    map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n-\n-    map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-    map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n-\n-    map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-    map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n-\n-    fn bench_iter(b: &mut Bencher, size: i32) {\n-        let mut map = BTreeMap::<i32, i32>::new();\n-        let mut rng = thread_rng();\n-\n-        for _ in 0..size {\n-            map.insert(rng.gen(), rng.gen());\n-        }\n-\n-        b.iter(|| {\n-            for entry in &map {\n-                black_box(entry);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn iter_20(b: &mut Bencher) {\n-        bench_iter(b, 20);\n-    }\n-\n-    #[bench]\n-    pub fn iter_1000(b: &mut Bencher) {\n-        bench_iter(b, 1000);\n-    }\n-\n-    #[bench]\n-    pub fn iter_100000(b: &mut Bencher) {\n-        bench_iter(b, 100000);\n-    }\n-}"}, {"sha": "57e3c2df059e122775f7d98f0c082980a7a4c7bb", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -35,10 +35,6 @@ extern crate std_unicode;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n-#[cfg(test)]\n-#[macro_use]\n-mod bench;\n-\n mod binary_heap;\n mod btree;\n mod cow_str;"}, {"sha": "a59724a017b1241de3e9995727a719782b76ea7f", "filename": "src/libcollectionstest/linked_list.rs", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flinked_list.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -10,8 +10,6 @@\n \n use std::collections::LinkedList;\n \n-use test;\n-\n #[test]\n fn test_basic() {\n     let mut m = LinkedList::<Box<_>>::new();\n@@ -356,81 +354,6 @@ fn test_extend() {\n     assert!(a.iter().eq(&[1, 2, 3, 4, 5, 6, 7]));\n }\n \n-#[bench]\n-fn bench_collect_into(b: &mut test::Bencher) {\n-    let v = &[0; 64];\n-    b.iter(|| {\n-        let _: LinkedList<_> = v.iter().cloned().collect();\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_front(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_front(0);\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_back(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_back(0);\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_back(0);\n-        m.pop_back();\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_front(0);\n-        m.pop_front();\n-    })\n-}\n-\n-#[bench]\n-fn bench_iter(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter().count() == 128);\n-    })\n-}\n-#[bench]\n-fn bench_iter_mut(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let mut m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter_mut().count() == 128);\n-    })\n-}\n-#[bench]\n-fn bench_iter_rev(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter().rev().count() == 128);\n-    })\n-}\n-#[bench]\n-fn bench_iter_mut_rev(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let mut m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter_mut().rev().count() == 128);\n-    })\n-}\n-\n #[test]\n fn test_contains() {\n     let mut l = LinkedList::new();"}, {"sha": "a7f7baf38518c186751d04f02574ba9bdac7e7ba", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -1170,276 +1170,3 @@ fn test_copy_from_slice_dst_shorter() {\n     let mut dst = [0; 3];\n     dst.copy_from_slice(&src);\n }\n-\n-mod bench {\n-    use std::{mem, ptr};\n-    use std::__rand::{Rng, thread_rng};\n-\n-    use test::{Bencher, black_box};\n-\n-    #[bench]\n-    fn iterator(b: &mut Bencher) {\n-        // peculiar numbers to stop LLVM from optimising the summation\n-        // out.\n-        let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n-\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for x in &v {\n-                sum += *x;\n-            }\n-            // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {\n-                panic!()\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn mut_iterator(b: &mut Bencher) {\n-        let mut v = vec![0; 100];\n-\n-        b.iter(|| {\n-            let mut i = 0;\n-            for x in &mut v {\n-                *x = i;\n-                i += 1;\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| {\n-            xss.concat();\n-        });\n-    }\n-\n-    #[bench]\n-    fn join(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| xss.join(&0));\n-    }\n-\n-    #[bench]\n-    fn push(b: &mut Bencher) {\n-        let mut vec = Vec::<i32>::new();\n-        b.iter(|| {\n-            vec.push(0);\n-            black_box(&vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| vec.starts_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<_> = vec![0];\n-        b.iter(|| vec.starts_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        let mut match_vec: Vec<_> = (0..99).collect();\n-        match_vec.push(0);\n-        b.iter(|| vec.starts_with(&match_vec))\n-    }\n-\n-    #[bench]\n-    fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| vec.ends_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<_> = vec![0];\n-        b.iter(|| vec.ends_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        let mut match_vec: Vec<_> = (0..100).collect();\n-        match_vec[0] = 200;\n-        b.iter(|| vec.starts_with(&match_vec))\n-    }\n-\n-    #[bench]\n-    fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| vec.contains(&99))\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_from_elem(b: &mut Bencher) {\n-        b.iter(|| vec![0u8; 1024]);\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_set_memory(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                let vp = v.as_mut_ptr();\n-                ptr::write_bytes(vp, 0, 1024);\n-                v.set_len(1024);\n-            }\n-            v\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_loop_set(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                v.set_len(1024);\n-            }\n-            for i in 0..1024 {\n-                v[i] = 0;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_mut_iter(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                v.set_len(1024);\n-            }\n-            for x in &mut v {\n-                *x = 0;\n-            }\n-            v\n-        });\n-    }\n-\n-    #[bench]\n-    fn random_inserts(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = vec![(0, 0); 30];\n-            for _ in 0..100 {\n-                let l = v.len();\n-                v.insert(rng.gen::<usize>() % (l + 1), (1, 1));\n-            }\n-        })\n-    }\n-    #[bench]\n-    fn random_removes(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = vec![(0, 0); 130];\n-            for _ in 0..100 {\n-                let l = v.len();\n-                v.remove(rng.gen::<usize>() % l);\n-            }\n-        })\n-    }\n-\n-    fn gen_ascending(len: usize) -> Vec<u64> {\n-        (0..len as u64).collect()\n-    }\n-\n-    fn gen_descending(len: usize) -> Vec<u64> {\n-        (0..len as u64).rev().collect()\n-    }\n-\n-    fn gen_random(len: usize) -> Vec<u64> {\n-        let mut rng = thread_rng();\n-        rng.gen_iter::<u64>().take(len).collect()\n-    }\n-\n-    fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n-        let mut rng = thread_rng();\n-        let mut v = gen_ascending(len);\n-        for _ in (0usize..).take_while(|x| x * x <= len) {\n-            let x = rng.gen::<usize>() % len;\n-            let y = rng.gen::<usize>() % len;\n-            v.swap(x, y);\n-        }\n-        v\n-    }\n-\n-    fn gen_mostly_descending(len: usize) -> Vec<u64> {\n-        let mut rng = thread_rng();\n-        let mut v = gen_descending(len);\n-        for _ in (0usize..).take_while(|x| x * x <= len) {\n-            let x = rng.gen::<usize>() % len;\n-            let y = rng.gen::<usize>() % len;\n-            v.swap(x, y);\n-        }\n-        v\n-    }\n-\n-    fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n-        let mut rng = thread_rng();\n-        rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n-    }\n-\n-    fn gen_big_ascending(len: usize) -> Vec<[u64; 16]> {\n-        (0..len as u64).map(|x| [x; 16]).take(len).collect()\n-    }\n-\n-    fn gen_big_descending(len: usize) -> Vec<[u64; 16]> {\n-        (0..len as u64).rev().map(|x| [x; 16]).take(len).collect()\n-    }\n-\n-    macro_rules! sort_bench {\n-        ($name:ident, $gen:expr, $len:expr) => {\n-            #[bench]\n-            fn $name(b: &mut Bencher) {\n-                b.iter(|| $gen($len).sort());\n-                b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n-            }\n-        }\n-    }\n-\n-    sort_bench!(sort_small_random, gen_random, 10);\n-    sort_bench!(sort_small_ascending, gen_ascending, 10);\n-    sort_bench!(sort_small_descending, gen_descending, 10);\n-\n-    sort_bench!(sort_small_big_random, gen_big_random, 10);\n-    sort_bench!(sort_small_big_ascending, gen_big_ascending, 10);\n-    sort_bench!(sort_small_big_descending, gen_big_descending, 10);\n-\n-    sort_bench!(sort_medium_random, gen_random, 100);\n-    sort_bench!(sort_medium_ascending, gen_ascending, 100);\n-    sort_bench!(sort_medium_descending, gen_descending, 100);\n-\n-    sort_bench!(sort_large_random, gen_random, 10000);\n-    sort_bench!(sort_large_ascending, gen_ascending, 10000);\n-    sort_bench!(sort_large_descending, gen_descending, 10000);\n-    sort_bench!(sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n-    sort_bench!(sort_large_mostly_descending, gen_mostly_descending, 10000);\n-\n-    sort_bench!(sort_large_big_random, gen_big_random, 10000);\n-    sort_bench!(sort_large_big_ascending, gen_big_ascending, 10000);\n-    sort_bench!(sort_large_big_descending, gen_big_descending, 10000);\n-\n-    #[bench]\n-    fn sort_large_random_expensive(b: &mut Bencher) {\n-        let len = 10000;\n-        b.iter(|| {\n-            let mut v = gen_random(len);\n-            let mut count = 0;\n-            v.sort_by(|a: &u64, b: &u64| {\n-                count += 1;\n-                if count % 1_000_000_000 == 0 {\n-                    panic!(\"should not happen\");\n-                }\n-                (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n-            });\n-            black_box(count);\n-        });\n-        b.bytes = len as u64 * mem::size_of::<u64>() as u64;\n-    }\n-}"}, {"sha": "6221888f5e55e7777ed4fdbe43ea6f0493592c30", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -1564,294 +1564,3 @@ fn different_str_pattern_forwarding_lifetimes() {\n \n     foo::<&str>(\"x\");\n }\n-\n-mod bench {\n-    use test::{Bencher, black_box};\n-\n-    #[bench]\n-    fn char_iterator(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_for(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| {\n-            for ch in s.chars() { black_box(ch); }\n-        });\n-    }\n-\n-    #[bench]\n-    fn char_iterator_ascii(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_rev(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().rev().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_rev_for(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| {\n-            for ch in s.chars().rev() { black_box(ch); }\n-        });\n-    }\n-\n-    #[bench]\n-    fn char_indicesator(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.chars().count();\n-\n-        b.iter(|| assert_eq!(s.char_indices().count(), len));\n-    }\n-\n-    #[bench]\n-    fn char_indicesator_rev(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.chars().count();\n-\n-        b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_unicode_ascii(b: &mut Bencher) {\n-        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        b.iter(|| assert_eq!(s.split('V').count(), 3));\n-    }\n-\n-    #[bench]\n-    fn split_ascii(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(' ').count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_extern_fn(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-        fn pred(c: char) -> bool { c == ' ' }\n-\n-        b.iter(|| assert_eq!(s.split(pred).count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_closure(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_slice(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        let c: &[char] = &[' '];\n-        b.iter(|| assert_eq!(s.split(c).count(), len));\n-    }\n-\n-    #[bench]\n-    fn bench_join(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let sep = \"\u2192\";\n-        let v = vec![s, s, s, s, s, s, s, s, s, s];\n-        b.iter(|| {\n-            assert_eq!(v.join(sep).len(), s.len() * 10 + sep.len() * 9);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_short_short(b: &mut Bencher) {\n-        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-        let needle = \"sit\";\n-\n-        b.iter(|| {\n-            assert!(haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_short_long(b: &mut Bencher) {\n-        let haystack = \"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum.\";\n-        let needle = \"english\";\n-\n-        b.iter(|| {\n-            assert!(!haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_bad_naive(b: &mut Bencher) {\n-        let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n-        let needle = \"aaaaaaaab\";\n-\n-        b.iter(|| {\n-            assert!(!haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_equal(b: &mut Bencher) {\n-        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-        let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-\n-        b.iter(|| {\n-            assert!(haystack.contains(needle));\n-        })\n-    }\n-\n-    macro_rules! make_test_inner {\n-        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n-            #[bench]\n-            fn $name(bencher: &mut Bencher) {\n-                let mut $s = $str;\n-                black_box(&mut $s);\n-                bencher.iter(|| $code);\n-            }\n-        }\n-    }\n-\n-    macro_rules! make_test {\n-        ($name:ident, $s:ident, $code:expr) => {\n-            mod $name {\n-                use test::Bencher;\n-                use test::black_box;\n-\n-                // Short strings: 65 bytes each\n-                make_test_inner!($s, $code, short_ascii,\n-                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n-                make_test_inner!($s, $code, short_mixed,\n-                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n-                make_test_inner!($s, $code, short_pile_of_poo,\n-                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n-                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum!\");\n-            }\n-        }\n-    }\n-\n-    make_test!(chars_count, s, s.chars().count());\n-\n-    make_test!(contains_bang_str, s, s.contains(\"!\"));\n-    make_test!(contains_bang_char, s, s.contains('!'));\n-\n-    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n-\n-    make_test!(split_a_str, s, s.split(\"a\").count());\n-\n-    make_test!(trim_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_left_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_left_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_right_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_right_matches(|c: char| c.is_ascii())\n-    });\n-\n-    make_test!(find_underscore_char, s, s.find('_'));\n-    make_test!(rfind_underscore_char, s, s.rfind('_'));\n-    make_test!(find_underscore_str, s, s.find(\"_\"));\n-\n-    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n-    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n-    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n-\n-    make_test!(split_space_char, s, s.split(' ').count());\n-    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n-\n-    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n-    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n-\n-    make_test!(split_space_str, s, s.split(\" \").count());\n-    make_test!(split_ad_str, s, s.split(\"ad\").count());\n-}"}, {"sha": "f77dd510303c74b3564b2acbdda66080aef50a9e", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -9,9 +9,6 @@\n // except according to those terms.\n \n use std::borrow::Cow;\n-use std::iter::repeat;\n-\n-use test::Bencher;\n \n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B>;\n@@ -436,125 +433,3 @@ fn test_into_boxed_str() {\n     let ys = xs.into_boxed_str();\n     assert_eq!(&*ys, \"hello my name is bob\");\n }\n-\n-#[bench]\n-fn bench_with_capacity(b: &mut Bencher) {\n-    b.iter(|| String::with_capacity(100));\n-}\n-\n-#[bench]\n-fn bench_push_str(b: &mut Bencher) {\n-    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-    b.iter(|| {\n-        let mut r = String::new();\n-        r.push_str(s);\n-    });\n-}\n-\n-const REPETITIONS: u64 = 10_000;\n-\n-#[bench]\n-fn bench_push_str_one_byte(b: &mut Bencher) {\n-    b.bytes = REPETITIONS;\n-    b.iter(|| {\n-        let mut r = String::new();\n-        for _ in 0..REPETITIONS {\n-            r.push_str(\"a\")\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_char_one_byte(b: &mut Bencher) {\n-    b.bytes = REPETITIONS;\n-    b.iter(|| {\n-        let mut r = String::new();\n-        for _ in 0..REPETITIONS {\n-            r.push('a')\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_char_two_bytes(b: &mut Bencher) {\n-    b.bytes = REPETITIONS * 2;\n-    b.iter(|| {\n-        let mut r = String::new();\n-        for _ in 0..REPETITIONS {\n-            r.push('\u00e2')\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-    let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-              Lorem ipsum dolor sit amet, consectetur. \";\n-\n-    assert_eq!(100, s.len());\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(s);\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-    let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n-    assert_eq!(100, s.len());\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(s);\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-    let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(s);\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-    let s = repeat(0xf5).take(100).collect::<Vec<_>>();\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(&s);\n-    });\n-}\n-\n-#[bench]\n-fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    // ensure our operation produces an exact-size string before we benchmark it\n-    let mut r = String::with_capacity(s.len());\n-    r.push_str(s);\n-    assert_eq!(r.len(), r.capacity());\n-    b.iter(|| {\n-        let mut r = String::with_capacity(s.len());\n-        r.push_str(s);\n-        r.shrink_to_fit();\n-        r\n-    });\n-}\n-\n-#[bench]\n-fn bench_from_str(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| String::from(s))\n-}\n-\n-#[bench]\n-fn bench_from(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| String::from(s))\n-}\n-\n-#[bench]\n-fn bench_to_string(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| s.to_string())\n-}"}, {"sha": "edeedf1d40baf3d37b38d6c36928945c7828558a", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 0, "deletions": 483, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -10,13 +10,10 @@\n \n use std::ascii::AsciiExt;\n use std::borrow::Cow;\n-use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n use std::panic;\n use std::vec::{Drain, IntoIter};\n \n-use test::Bencher;\n-\n struct DropCounter<'a> {\n     count: &'a mut u32,\n }\n@@ -633,483 +630,3 @@ fn test_placement_panic() {\n     let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { vec.place_back() <- mkpanic(); }));\n     assert_eq!(vec.len(), 3);\n }\n-\n-#[bench]\n-fn bench_new(b: &mut Bencher) {\n-    b.iter(|| {\n-        let v: Vec<u32> = Vec::new();\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(v.capacity(), 0);\n-    })\n-}\n-\n-fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let v: Vec<u32> = Vec::with_capacity(src_len);\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(v.capacity(), src_len);\n-    })\n-}\n-\n-#[bench]\n-fn bench_with_capacity_0000(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 0)\n-}\n-\n-#[bench]\n-fn bench_with_capacity_0010(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 10)\n-}\n-\n-#[bench]\n-fn bench_with_capacity_0100(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 100)\n-}\n-\n-#[bench]\n-fn bench_with_capacity_1000(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 1000)\n-}\n-\n-fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst = (0..src_len).collect::<Vec<_>>();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    })\n-}\n-\n-#[bench]\n-fn bench_from_fn_0000(b: &mut Bencher) {\n-    do_bench_from_fn(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_fn_0010(b: &mut Bencher) {\n-    do_bench_from_fn(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_fn_0100(b: &mut Bencher) {\n-    do_bench_from_fn(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_fn_1000(b: &mut Bencher) {\n-    do_bench_from_fn(b, 1000)\n-}\n-\n-fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst: Vec<usize> = repeat(5).take(src_len).collect();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().all(|x| *x == 5));\n-    })\n-}\n-\n-#[bench]\n-fn bench_from_elem_0000(b: &mut Bencher) {\n-    do_bench_from_elem(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_elem_0010(b: &mut Bencher) {\n-    do_bench_from_elem(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_elem_0100(b: &mut Bencher) {\n-    do_bench_from_elem(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_elem_1000(b: &mut Bencher) {\n-    do_bench_from_elem(b, 1000)\n-}\n-\n-fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n-    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst = src.clone()[..].to_vec();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_from_slice_0000(b: &mut Bencher) {\n-    do_bench_from_slice(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_slice_0010(b: &mut Bencher) {\n-    do_bench_from_slice(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_slice_0100(b: &mut Bencher) {\n-    do_bench_from_slice(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_slice_1000(b: &mut Bencher) {\n-    do_bench_from_slice(b, 1000)\n-}\n-\n-fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n-    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst: Vec<_> = FromIterator::from_iter(src.clone());\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_from_iter_0000(b: &mut Bencher) {\n-    do_bench_from_iter(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_iter_0010(b: &mut Bencher) {\n-    do_bench_from_iter(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_iter_0100(b: &mut Bencher) {\n-    do_bench_from_iter(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_iter_1000(b: &mut Bencher) {\n-    do_bench_from_iter(b, 1000)\n-}\n-\n-fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-        dst.extend(src.clone());\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_extend_0000_0000(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_extend_0000_0010(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_extend_0000_0100(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_extend_0000_1000(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_extend_0010_0010(b: &mut Bencher) {\n-    do_bench_extend(b, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_extend_0100_0100(b: &mut Bencher) {\n-    do_bench_extend(b, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_extend_1000_1000(b: &mut Bencher) {\n-    do_bench_extend(b, 1000, 1000)\n-}\n-\n-fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-        dst.extend_from_slice(&src);\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_0000(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_0010(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_0100(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_1000(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_push_all_0010_0010(b: &mut Bencher) {\n-    do_bench_push_all(b, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_0100_0100(b: &mut Bencher) {\n-    do_bench_push_all(b, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_1000_1000(b: &mut Bencher) {\n-    do_bench_push_all(b, 1000, 1000)\n-}\n-\n-fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-        dst.extend(src.clone());\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 1000, 1000)\n-}\n-\n-fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n-    let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst = src.clone();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_clone_0000(b: &mut Bencher) {\n-    do_bench_clone(b, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_0010(b: &mut Bencher) {\n-    do_bench_clone(b, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_0100(b: &mut Bencher) {\n-    do_bench_clone(b, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_1000(b: &mut Bencher) {\n-    do_bench_clone(b, 1000)\n-}\n-\n-fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = (times * src_len) as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-\n-        for _ in 0..times {\n-            dst.clone_from(&src);\n-\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 1000, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 10, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 100, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 10, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 100, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 1000, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 1000, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 10, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 100, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 10, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 100, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 1000, 100)\n-}"}, {"sha": "1541061a1984214bf70a4260b2ab35136b98d894", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -12,8 +12,6 @@ use std::collections::VecDeque;\n use std::fmt::Debug;\n use std::collections::vec_deque::Drain;\n \n-use test;\n-\n use self::Taggy::*;\n use self::Taggypar::*;\n \n@@ -124,51 +122,6 @@ fn test_index_out_of_bounds() {\n     deq[3];\n }\n \n-#[bench]\n-fn bench_new(b: &mut test::Bencher) {\n-    b.iter(|| {\n-        let ring: VecDeque<i32> = VecDeque::new();\n-        test::black_box(ring);\n-    })\n-}\n-\n-#[bench]\n-fn bench_grow_1025(b: &mut test::Bencher) {\n-    b.iter(|| {\n-        let mut deq = VecDeque::new();\n-        for i in 0..1025 {\n-            deq.push_front(i);\n-        }\n-        test::black_box(deq);\n-    })\n-}\n-\n-#[bench]\n-fn bench_iter_1000(b: &mut test::Bencher) {\n-    let ring: VecDeque<_> = (0..1000).collect();\n-\n-    b.iter(|| {\n-        let mut sum = 0;\n-        for &i in &ring {\n-            sum += i;\n-        }\n-        test::black_box(sum);\n-    })\n-}\n-\n-#[bench]\n-fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-    let mut ring: VecDeque<_> = (0..1000).collect();\n-\n-    b.iter(|| {\n-        let mut sum = 0;\n-        for i in &mut ring {\n-            sum += *i;\n-        }\n-        test::black_box(sum);\n-    })\n-}\n-\n #[derive(Clone, PartialEq, Debug)]\n enum Taggy {\n     One(i32),"}, {"sha": "e847c7fa3a0ec9580c82431ebe0d86bd8a88e9c2", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -14,5 +14,5 @@ name = \"coretest\"\n path = \"../libcoretest/lib.rs\"\n \n [[bench]]\n-name = \"corebench\"\n-path = \"../libcore/bench/lib.rs\"\n+name = \"corebenches\"\n+path = \"../libcore/benches/lib.rs\""}, {"sha": "67e02cf9509b6cd8ba71db2be4dd19cea9946ce0", "filename": "src/libcore/benches/any.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fany.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/any.rs"}, {"sha": "55d9e3e0913801bf2a4106eee84d44015dfe6cb4", "filename": "src/libcore/benches/hash/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fhash%2Fmod.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/hash/mod.rs"}, {"sha": "3379c85bbec7d5985df61fa213c3da90127faeb3", "filename": "src/libcore/benches/hash/sip.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/hash/sip.rs"}, {"sha": "93d38a5bc83bbf1e392585821c90b82d5a72d3fb", "filename": "src/libcore/benches/iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/iter.rs"}, {"sha": "d2db329da799981b3a6d3a372211f21893603b6a", "filename": "src/libcore/benches/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/lib.rs"}, {"sha": "8e541d92a7f170c366b97c57c1912d9bd19f783d", "filename": "src/libcore/benches/mem.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fmem.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/mem.rs"}, {"sha": "562866e11777cf0e4db920ff0e9b0d4e60ea5c05", "filename": "src/libcore/benches/num/dec2flt/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/num/dec2flt/mod.rs"}, {"sha": "1de2bf4921f589996130885f363b550cbf179695", "filename": "src/libcore/benches/num/flt2dec/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/num/flt2dec/mod.rs"}, {"sha": "6824cf40ed2aec678ae771792ce01f9fb2a573da", "filename": "src/libcore/benches/num/flt2dec/strategy/dragon.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/num/flt2dec/strategy/dragon.rs"}, {"sha": "82e1a858fca9fc655a15967c43a88d7c6fd17711", "filename": "src/libcore/benches/num/flt2dec/strategy/grisu.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/num/flt2dec/strategy/grisu.rs"}, {"sha": "55f0bdb57ec820711fc8b8ddec0bc7981eaa6837", "filename": "src/libcore/benches/num/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/num/mod.rs"}, {"sha": "7f36a4b0771aa611d9cb2f07544787da0e28be9c", "filename": "src/libcore/benches/ops.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibcore%2Fbenches%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fops.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "previous_filename": "src/libcore/bench/ops.rs"}, {"sha": "7724658a9d6fead0f25ec19c116c9b26fd0e654e", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 84, "deletions": 35, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -176,46 +176,32 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Recreate the edges in the graph that are still clean.\n     let mut clean_work_products = FxHashSet();\n     let mut dirty_work_products = FxHashSet(); // incomplete; just used to suppress debug output\n+    let mut extra_edges = vec![];\n     for (source, targets) in &edge_map {\n         for target in targets {\n-            // If the target is dirty, skip the edge. If this is an edge\n-            // that targets a work-product, we can print the blame\n-            // information now.\n-            if let Some(blame) = dirty_raw_nodes.get(target) {\n-                if let DepNode::WorkProduct(ref wp) = *target {\n-                    if tcx.sess.opts.debugging_opts.incremental_info {\n-                        if dirty_work_products.insert(wp.clone()) {\n-                            // It'd be nice to pretty-print these paths better than just\n-                            // using the `Debug` impls, but wev.\n-                            println!(\"incremental: module {:?} is dirty because {:?} \\\n-                                      changed or was removed\",\n-                                     wp,\n-                                     blame.map_def(|&index| {\n-                                         Some(directory.def_path_string(tcx, index))\n-                                     }).unwrap());\n-                        }\n-                    }\n-                }\n-                continue;\n-            }\n-\n-            // If the source is dirty, the target will be dirty.\n-            assert!(!dirty_raw_nodes.contains_key(source));\n-\n-            // Retrace the source -> target edges to def-ids and then\n-            // create an edge in the graph. Retracing may yield none if\n-            // some of the data happens to have been removed; this ought\n-            // to be impossible unless it is dirty, so we can unwrap.\n-            let source_node = retraced.map(source).unwrap();\n-            let target_node = retraced.map(target).unwrap();\n-            let _task = tcx.dep_graph.in_task(target_node);\n-            tcx.dep_graph.read(source_node);\n-            if let DepNode::WorkProduct(ref wp) = *target {\n-                clean_work_products.insert(wp.clone());\n-            }\n+            process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+                          &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n         }\n     }\n \n+    // Subtle. Sometimes we have intermediate nodes that we can't recreate in the new graph.\n+    // This is pretty unusual but it arises in a scenario like this:\n+    //\n+    //     Hir(X) -> Foo(Y) -> Bar\n+    //\n+    // Note that the `Hir(Y)` is not an input to `Foo(Y)` -- this\n+    // almost never happens, but can happen in some obscure\n+    // scenarios. In that case, if `Y` is removed, then we can't\n+    // recreate `Foo(Y)` (the def-id `Y` no longer exists); what we do\n+    // then is to push the edge `Hir(X) -> Bar` onto `extra_edges`\n+    // (along with any other targets of `Foo(Y)`). We will then add\n+    // the edge from `Hir(X)` to `Bar` (or, if `Bar` itself cannot be\n+    // recreated, to the targets of `Bar`).\n+    while let Some((source, target)) = extra_edges.pop() {\n+        process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+                      &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n+    }\n+\n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n@@ -393,3 +379,66 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n            serialized_hashes.index_map.len());\n }\n \n+fn process_edges<'a, 'tcx, 'edges>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: &'edges DepNode<DefPathIndex>,\n+    target: &'edges DepNode<DefPathIndex>,\n+    edges: &'edges FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n+    directory: &DefIdDirectory,\n+    retraced: &RetracedDefIdDirectory,\n+    dirty_raw_nodes: &DirtyNodes,\n+    clean_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    dirty_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    extra_edges: &mut Vec<(&'edges DepNode<DefPathIndex>, &'edges DepNode<DefPathIndex>)>)\n+{\n+    // If the target is dirty, skip the edge. If this is an edge\n+    // that targets a work-product, we can print the blame\n+    // information now.\n+    if let Some(blame) = dirty_raw_nodes.get(target) {\n+        if let DepNode::WorkProduct(ref wp) = *target {\n+            if tcx.sess.opts.debugging_opts.incremental_info {\n+                if dirty_work_products.insert(wp.clone()) {\n+                    // It'd be nice to pretty-print these paths better than just\n+                    // using the `Debug` impls, but wev.\n+                    println!(\"incremental: module {:?} is dirty because {:?} \\\n+                              changed or was removed\",\n+                             wp,\n+                             blame.map_def(|&index| {\n+                                 Some(directory.def_path_string(tcx, index))\n+                             }).unwrap());\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    // If the source is dirty, the target will be dirty.\n+    assert!(!dirty_raw_nodes.contains_key(source));\n+\n+    // Retrace the source -> target edges to def-ids and then create\n+    // an edge in the graph. Retracing may yield none if some of the\n+    // data happens to have been removed.\n+    if let Some(source_node) = retraced.map(source) {\n+        if let Some(target_node) = retraced.map(target) {\n+            let _task = tcx.dep_graph.in_task(target_node);\n+            tcx.dep_graph.read(source_node);\n+            if let DepNode::WorkProduct(ref wp) = *target {\n+                clean_work_products.insert(wp.clone());\n+            }\n+        } else {\n+            // As discussed in `decode_dep_graph` above, sometimes the\n+            // target cannot be recreated again, in which case we add\n+            // edges to go from `source` to the targets of `target`.\n+            extra_edges.extend(\n+                edges[target].iter().map(|t| (source, t)));\n+        }\n+    } else {\n+        // It's also possible that the source can't be created! But we\n+        // can ignore such cases, because (a) if `source` is a HIR\n+        // node, it would be considered dirty; and (b) in other cases,\n+        // there must be some input to this node that is clean, and so\n+        // we'll re-create the edges over in the case where target is\n+        // undefined.\n+    }\n+}\n+"}, {"sha": "8feb07953db81b4df59b70fcc0d677136d0b8432", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -339,6 +339,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n enum FfiResult {\n     FfiSafe,\n+    FfiPhantom,\n     FfiUnsafe(&'static str),\n     FfiBadStruct(DefId, &'static str),\n     FfiBadUnion(DefId, &'static str),\n@@ -383,8 +384,11 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n+    fn check_type_for_ffi(&self,\n+                          cache: &mut FxHashSet<Ty<'tcx>>,\n+                          ty: Ty<'tcx>) -> FfiResult {\n         use self::FfiResult::*;\n+\n         let cx = self.cx.tcx;\n \n         // Protect against infinite recursion, for example\n@@ -397,6 +401,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         match ty.sty {\n             ty::TyAdt(def, substs) => {\n+                if def.is_phantom_data() {\n+                    return FfiPhantom;\n+                }\n                 match def.adt_kind() {\n                     AdtKind::Struct => {\n                         if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n@@ -405,18 +412,22 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                               consider adding a #[repr(C)] attribute to the type\");\n                         }\n \n-                        // We can't completely trust repr(C) markings; make sure the\n-                        // fields are actually safe.\n                         if def.struct_variant().fields.is_empty() {\n                             return FfiUnsafe(\"found zero-size struct in foreign module, consider \\\n                                               adding a member to this struct\");\n                         }\n \n+                        // We can't completely trust repr(C) markings; make sure the\n+                        // fields are actually safe.\n+                        let mut all_phantom = true;\n                         for field in &def.struct_variant().fields {\n                             let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n-                                FfiSafe => {}\n+                                FfiSafe => {\n+                                    all_phantom = false;\n+                                }\n+                                FfiPhantom => {}\n                                 FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n                                     return r;\n                                 }\n@@ -425,7 +436,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 }\n                             }\n                         }\n-                        FfiSafe\n+\n+                        if all_phantom { FfiPhantom } else { FfiSafe }\n                     }\n                     AdtKind::Union => {\n                         if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n@@ -434,11 +446,20 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                               consider adding a #[repr(C)] attribute to the type\");\n                         }\n \n+                        if def.struct_variant().fields.is_empty() {\n+                            return FfiUnsafe(\"found zero-size union in foreign module, consider \\\n+                                              adding a member to this union\");\n+                        }\n+\n+                        let mut all_phantom = true;\n                         for field in &def.struct_variant().fields {\n                             let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n-                                FfiSafe => {}\n+                                FfiSafe => {\n+                                    all_phantom = false;\n+                                }\n+                                FfiPhantom => {}\n                                 FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n                                     return r;\n                                 }\n@@ -447,7 +468,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 }\n                             }\n                         }\n-                        FfiSafe\n+\n+                        if all_phantom { FfiPhantom } else { FfiSafe }\n                     }\n                     AdtKind::Enum => {\n                         if def.variants.is_empty() {\n@@ -498,6 +520,10 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                     FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n                                         return r;\n                                     }\n+                                    FfiPhantom => {\n+                                        return FfiBadEnum(def.did,\n+                                                          \"Found phantom data in enum variant\");\n+                                    }\n                                     FfiUnsafe(s) => {\n                                         return FfiBadEnum(def.did, s);\n                                     }\n@@ -591,6 +617,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}\n+            FfiResult::FfiPhantom => {\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found zero-sized type composed only \\\n+                                            of phantom-data in a foreign-function.\"));\n+            }\n             FfiResult::FfiUnsafe(s) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n             }"}, {"sha": "07d36448ab0f8dcd4a4403b0525a4106e012569e", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -1369,14 +1369,14 @@ extern \"C\" {\n     pub fn LLVMRustDIBuilderCreateBasicType(Builder: DIBuilderRef,\n                                             Name: *const c_char,\n                                             SizeInBits: u64,\n-                                            AlignInBits: u64,\n+                                            AlignInBits: u32,\n                                             Encoding: c_uint)\n                                             -> DIBasicType;\n \n     pub fn LLVMRustDIBuilderCreatePointerType(Builder: DIBuilderRef,\n                                               PointeeTy: DIType,\n                                               SizeInBits: u64,\n-                                              AlignInBits: u64,\n+                                              AlignInBits: u32,\n                                               Name: *const c_char)\n                                               -> DIDerivedType;\n \n@@ -1386,7 +1386,7 @@ extern \"C\" {\n                                              File: DIFile,\n                                              LineNumber: c_uint,\n                                              SizeInBits: u64,\n-                                             AlignInBits: u64,\n+                                             AlignInBits: u32,\n                                              Flags: DIFlags,\n                                              DerivedFrom: DIType,\n                                              Elements: DIArray,\n@@ -1401,7 +1401,7 @@ extern \"C\" {\n                                              File: DIFile,\n                                              LineNo: c_uint,\n                                              SizeInBits: u64,\n-                                             AlignInBits: u64,\n+                                             AlignInBits: u32,\n                                              OffsetInBits: u64,\n                                              Flags: DIFlags,\n                                              Ty: DIType)\n@@ -1429,7 +1429,7 @@ extern \"C\" {\n                                                  isLocalToUnit: bool,\n                                                  Val: ValueRef,\n                                                  Decl: DIDescriptor,\n-                                                 AlignInBits: u64)\n+                                                 AlignInBits: u32)\n                                                  -> DIGlobalVariable;\n \n     pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n@@ -1442,19 +1442,19 @@ extern \"C\" {\n                                            AlwaysPreserve: bool,\n                                            Flags: DIFlags,\n                                            ArgNo: c_uint,\n-                                           AlignInBits: u64)\n+                                           AlignInBits: u32)\n                                            -> DIVariable;\n \n     pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,\n                                             Size: u64,\n-                                            AlignInBits: u64,\n+                                            AlignInBits: u32,\n                                             Ty: DIType,\n                                             Subscripts: DIArray)\n                                             -> DIType;\n \n     pub fn LLVMRustDIBuilderCreateVectorType(Builder: DIBuilderRef,\n                                              Size: u64,\n-                                             AlignInBits: u64,\n+                                             AlignInBits: u32,\n                                              Ty: DIType,\n                                              Subscripts: DIArray)\n                                              -> DIType;\n@@ -1489,7 +1489,7 @@ extern \"C\" {\n                                                   File: DIFile,\n                                                   LineNumber: c_uint,\n                                                   SizeInBits: u64,\n-                                                  AlignInBits: u64,\n+                                                  AlignInBits: u32,\n                                                   Elements: DIArray,\n                                                   ClassType: DIType)\n                                                   -> DIType;\n@@ -1500,7 +1500,7 @@ extern \"C\" {\n                                             File: DIFile,\n                                             LineNumber: c_uint,\n                                             SizeInBits: u64,\n-                                            AlignInBits: u64,\n+                                            AlignInBits: u32,\n                                             Flags: DIFlags,\n                                             Elements: DIArray,\n                                             RunTimeLang: c_uint,"}, {"sha": "9a761e17e75e89ff344efb230cc1c5b28d298ebd", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -27,6 +27,7 @@ use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n \n+use std::cmp;\n use std::ffi::CString;\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -754,10 +755,13 @@ pub fn run_passes(sess: &Session,\n     }\n \n     // Process the work items, optionally using worker threads.\n-    // NOTE: This code is not really adapted to incremental compilation where\n-    //       the compiler decides the number of codegen units (and will\n-    //       potentially create hundreds of them).\n-    let num_workers = work_items.len() - 1;\n+    // NOTE: We are hardcoding a limit of worker threads for now. With\n+    //       incremental compilation we can run into situations where we would\n+    //       open hundreds of threads otherwise -- which can make things slower\n+    //       if things don't fit into memory anymore, or can cause the compiler\n+    //       to crash because of too many open file handles. See #39280 for\n+    //       some discussion on how to improve this in the future.\n+    let num_workers = cmp::min(work_items.len() - 1, 32);\n     if num_workers <= 1 {\n         run_work_singlethreaded(sess, &trans.exported_symbols, work_items);\n     } else {"}, {"sha": "7578cc74dbf34bf990436ef8a412daaf56c8e99f", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -1783,7 +1783,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     is_local_to_unit,\n                                                     global,\n                                                     ptr::null_mut(),\n-                                                    global_align as u64,\n+                                                    global_align,\n         );\n     }\n }"}, {"sha": "729eae15ad696ae85693f1f7c43d47d3cffa7064", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -464,7 +464,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     cx.sess().opts.optimize != config::OptLevel::No,\n                     DIFlags::FlagZero,\n                     argument_index,\n-                    align as u64,\n+                    align,\n                 )\n             };\n             source_loc::set_debug_location(bcx,"}, {"sha": "15a1c990aadc6aa674f83abde74b3cd8da235673", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -24,6 +24,8 @@ use type_::Type;\n use syntax_pos::{self, Span};\n use syntax::ast;\n \n+use std::ops;\n+\n pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n@@ -49,12 +51,13 @@ pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo)\n }\n \n-pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n-    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n+pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u32) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n }\n \n-pub fn bytes_to_bits(bytes: u64) -> u64 {\n-    bytes * 8\n+pub fn bytes_to_bits<T>(bytes: T) -> T\n+    where T: ops::Mul<Output=T> + From<u8> {\n+    bytes * 8u8.into()\n }\n \n #[inline]"}, {"sha": "c7c5aabab97ae8002ce57b674d6623068c5090dd", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -35,6 +35,7 @@ use std::fmt::{self, Write};\n use std::slice;\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::codemap::Span;\n \n use html::render::derive_id;\n use html::toc::TocBuilder;\n@@ -424,7 +425,7 @@ pub fn render(w: &mut fmt::Formatter,\n     }\n }\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, start_line: usize) {\n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n     extern fn block(_ob: *mut hoedown_buffer,\n                     text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer,\n@@ -449,11 +450,12 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, start_line:\n             });\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n             let line = tests.get_line() + line;\n+            let filename = tests.get_filename();\n             tests.add_test(text.to_owned(),\n                            block_info.should_panic, block_info.no_run,\n                            block_info.ignore, block_info.test_harness,\n                            block_info.compile_fail, block_info.error_codes,\n-                           line);\n+                           line, filename);\n         }\n     }\n \n@@ -474,7 +476,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, start_line:\n         }\n     }\n \n-    tests.set_line(start_line);\n+    tests.set_position(position);\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);"}, {"sha": "70ef7c597e4d7ba55f3c81a5f46e477f3db2ea35", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -18,6 +18,7 @@ use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::Externs;\n+use syntax::codemap::DUMMY_SP;\n \n use externalfiles::{ExternalHtml, LoadStringError, load_string};\n \n@@ -154,9 +155,8 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n-                                       true, opts, maybe_sysroot, \"input\".to_string(),\n-                                       None);\n-    find_testable_code(&input_str, &mut collector, 0);\n+                                       true, opts, maybe_sysroot, None);\n+    find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests);\n     0"}, {"sha": "930cf401e74501b202a0f49b404c07301b34cf7e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -37,7 +37,7 @@ use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::{BytePos, DUMMY_SP, Pos};\n+use syntax_pos::{BytePos, DUMMY_SP, Pos, Span};\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -97,15 +97,13 @@ pub fn run(input: &str,\n         link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n     });\n     let opts = scrape_test_config(hir_forest.krate());\n-    let filename = input_path.to_str().unwrap_or(\"\").to_owned();\n     let mut collector = Collector::new(crate_name,\n                                        cfgs,\n                                        libs,\n                                        externs,\n                                        false,\n                                        opts,\n                                        maybe_sysroot,\n-                                       filename,\n                                        Some(codemap));\n \n     {\n@@ -391,15 +389,14 @@ pub struct Collector {\n     cratename: String,\n     opts: TestOptions,\n     maybe_sysroot: Option<PathBuf>,\n-    filename: String,\n-    start_line: usize,\n+    position: Span,\n     codemap: Option<Rc<CodeMap>>,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n-               filename: String, codemap: Option<Rc<CodeMap>>) -> Collector {\n+               codemap: Option<Rc<CodeMap>>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n@@ -412,17 +409,16 @@ impl Collector {\n             cratename: cratename,\n             opts: opts,\n             maybe_sysroot: maybe_sysroot,\n-            filename: filename,\n-            start_line: 0,\n+            position: DUMMY_SP,\n             codemap: codemap,\n         }\n     }\n \n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n-                    line: usize) {\n-        let name = format!(\"{} - line {}\", self.filename, line);\n+                    line: usize, filename: String) {\n+        let name = format!(\"{} - line {}\", filename, line);\n         self.cnt += 1;\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n@@ -467,16 +463,25 @@ impl Collector {\n     }\n \n     pub fn get_line(&self) -> usize {\n-        if let Some(ref codemap) = self.codemap{\n-            let line = codemap.lookup_char_pos(BytePos(self.start_line as u32)).line;\n+        if let Some(ref codemap) = self.codemap {\n+            let line = self.position.lo.to_usize();\n+            let line = codemap.lookup_char_pos(BytePos(line as u32)).line;\n             if line > 0 { line - 1 } else { line }\n         } else {\n-            self.start_line\n+            0\n         }\n     }\n \n-    pub fn set_line(&mut self, start_line: usize) {\n-        self.start_line = start_line;\n+    pub fn set_position(&mut self, position: Span) {\n+        self.position = position;\n+    }\n+\n+    pub fn get_filename(&self) -> String {\n+        if let Some(ref codemap) = self.codemap {\n+            codemap.span_to_filename(self.position)\n+        } else {\n+            \"<input>\".to_owned()\n+        }\n     }\n \n     pub fn register_header(&mut self, name: &str, level: u32) {\n@@ -520,7 +525,7 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         if let Some(doc) = attrs.doc_value() {\n             self.collector.cnt = 0;\n             markdown::find_testable_code(doc, self.collector,\n-                                         attrs.span.unwrap_or(DUMMY_SP).lo.to_usize());\n+                                         attrs.span.unwrap_or(DUMMY_SP));\n         }\n \n         nested(self);"}, {"sha": "4ff35738b50fbd085657154c517563fbab6e991c", "filename": "src/libstd/process.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -844,9 +844,9 @@ impl Child {\n     /// guaranteed to repeatedly return a successful exit status so long as the\n     /// child has already exited.\n     ///\n-    /// If the child has exited, then `Ok(status)` is returned. If the exit\n-    /// status is not available at this time then an error is returned with the\n-    /// error kind `WouldBlock`. If an error occurs, then that error is returned.\n+    /// If the child has exited, then `Ok(Some(status))` is returned. If the\n+    /// exit status is not available at this time then `Ok(None)` is returned.\n+    /// If an error occurs, then that error is returned.\n     ///\n     /// Note that unlike `wait`, this function will not attempt to drop stdin.\n     ///\n@@ -857,14 +857,13 @@ impl Child {\n     /// ```no_run\n     /// #![feature(process_try_wait)]\n     ///\n-    /// use std::io;\n     /// use std::process::Command;\n     ///\n     /// let mut child = Command::new(\"ls\").spawn().unwrap();\n     ///\n     /// match child.try_wait() {\n-    ///     Ok(status) => println!(\"exited with: {}\", status),\n-    ///     Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n+    ///     Ok(Some(status)) => println!(\"exited with: {}\", status),\n+    ///     Ok(None) => {\n     ///         println!(\"status not ready yet, let's really wait\");\n     ///         let res = child.wait();\n     ///         println!(\"result: {:?}\", res);\n@@ -873,8 +872,8 @@ impl Child {\n     /// }\n     /// ```\n     #[unstable(feature = \"process_try_wait\", issue = \"38903\")]\n-    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n-        self.handle.try_wait().map(ExitStatus)\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        Ok(self.handle.try_wait()?.map(ExitStatus))\n     }\n \n     /// Simultaneously waits for the child to exit and collect all remaining"}, {"sha": "60dc03fcf47e2aa7b5f0fed92d54aa493cc2d4e5", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -502,17 +502,17 @@ impl Process {\n         Ok(ExitStatus(status as i32))\n     }\n \n-    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n         if let Some(status) = self.status {\n-            return Ok(status)\n+            return Ok(Some(status))\n         }\n         let mut status = 0;\n         let pid = cvt(syscall::waitpid(self.pid, &mut status, syscall::WNOHANG))?;\n         if pid == 0 {\n-            Err(io::Error::from_raw_os_error(syscall::EWOULDBLOCK))\n+            Ok(None)\n         } else {\n             self.status = Some(ExitStatus(status as i32));\n-            Ok(ExitStatus(status as i32))\n+            Ok(Some(ExitStatus(status as i32)))\n         }\n     }\n }"}, {"sha": "0bb2e0c1a83d4469a534469b83ef8c363a08d901", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -165,7 +165,7 @@ impl Process {\n         Ok(ExitStatus::new(proc_info.rec.return_code))\n     }\n \n-    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n         use default::Default;\n         use sys::process::magenta::*;\n \n@@ -179,7 +179,7 @@ impl Process {\n             match status {\n                 0 => { }, // Success\n                 x if x == ERR_TIMED_OUT => {\n-                    return Err(io::Error::from(io::ErrorKind::WouldBlock));\n+                    return Ok(None);\n                 },\n                 _ => { panic!(\"Failed to wait on process handle: {}\", status); },\n             }\n@@ -192,7 +192,7 @@ impl Process {\n             return Err(io::Error::new(io::ErrorKind::InvalidData,\n                                       \"Failed to get exit status of process\"));\n         }\n-        Ok(ExitStatus::new(proc_info.rec.return_code))\n+        Ok(Some(ExitStatus::new(proc_info.rec.return_code)))\n     }\n }\n "}, {"sha": "bbc987209e300edf7c9ebde5a1cbf2f02f13b211", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -249,19 +249,19 @@ impl Process {\n         Ok(ExitStatus::new(status))\n     }\n \n-    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n         if let Some(status) = self.status {\n-            return Ok(status)\n+            return Ok(Some(status))\n         }\n         let mut status = 0 as c_int;\n         let pid = cvt(unsafe {\n             libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n         })?;\n         if pid == 0 {\n-            Err(io::Error::from_raw_os_error(libc::EWOULDBLOCK))\n+            Ok(None)\n         } else {\n             self.status = Some(ExitStatus::new(status));\n-            Ok(ExitStatus::new(status))\n+            Ok(Some(ExitStatus::new(status)))\n         }\n     }\n }"}, {"sha": "1afb3728c9d72e7d00d20a153631a312b72302e6", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -340,18 +340,18 @@ impl Process {\n         }\n     }\n \n-    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n         unsafe {\n             match c::WaitForSingleObject(self.handle.raw(), 0) {\n                 c::WAIT_OBJECT_0 => {}\n                 c::WAIT_TIMEOUT => {\n-                    return Err(io::Error::from_raw_os_error(c::WSAEWOULDBLOCK))\n+                    return Ok(None);\n                 }\n                 _ => return Err(io::Error::last_os_error()),\n             }\n             let mut status = 0;\n             cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n-            Ok(ExitStatus(status))\n+            Ok(Some(ExitStatus(status)))\n         }\n     }\n "}, {"sha": "1d67c2a2c2b74023c8f1fa1c7c5e4dc4ca8d9e6b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 89, "deletions": 78, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -60,11 +60,95 @@\n //! by two zero-length breaks. The algorithm will try its best to fit it on a\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n+//!\n+//! # Explanation\n+//!\n+//! In case you do not have the paper, here is an explanation of what's going\n+//! on.\n+//!\n+//! There is a stream of input tokens flowing through this printer.\n+//!\n+//! The printer buffers up to 3N tokens inside itself, where N is linewidth.\n+//! Yes, linewidth is chars and tokens are multi-char, but in the worst\n+//! case every token worth buffering is 1 char long, so it's ok.\n+//!\n+//! Tokens are String, Break, and Begin/End to delimit blocks.\n+//!\n+//! Begin tokens can carry an offset, saying \"how far to indent when you break\n+//! inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n+//! breaking. Consistent breaking means that after the first break, no attempt\n+//! will be made to flow subsequent breaks together onto lines. Inconsistent\n+//! is the opposite. Inconsistent breaking example would be, say:\n+//!\n+//! ```\n+//! foo(hello, there, good, friends)\n+//! ```\n+//!\n+//! breaking inconsistently to become\n+//!\n+//! ```\n+//! foo(hello, there\n+//!     good, friends);\n+//! ```\n+//!\n+//! whereas a consistent breaking would yield:\n+//!\n+//! ```\n+//! foo(hello,\n+//!     there\n+//!     good,\n+//!     friends);\n+//! ```\n+//!\n+//! That is, in the consistent-break blocks we value vertical alignment\n+//! more than the ability to cram stuff onto a line. But in all cases if it\n+//! can make a block a one-liner, it'll do so.\n+//!\n+//! Carrying on with high-level logic:\n+//!\n+//! The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n+//! 'right' indices denote the active portion of the ring buffer as well as\n+//! describing hypothetical points-in-the-infinite-stream at most 3N tokens\n+//! apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n+//! between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n+//! and point-in-infinite-stream senses freely.\n+//!\n+//! There is a parallel ring buffer, 'size', that holds the calculated size of\n+//! each token. Why calculated? Because for Begin/End pairs, the \"size\"\n+//! includes everything between the pair. That is, the \"size\" of Begin is\n+//! actually the sum of the sizes of everything between Begin and the paired\n+//! End that follows. Since that is arbitrarily far in the future, 'size' is\n+//! being rewritten regularly while the printer runs; in fact most of the\n+//! machinery is here to work out 'size' entries on the fly (and give up when\n+//! they're so obviously over-long that \"infinity\" is a good enough\n+//! approximation for purposes of line breaking).\n+//!\n+//! The \"input side\" of the printer is managed as an abstract process called\n+//! SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n+//! other words, the process of calculating 'size' entries.\n+//!\n+//! The \"output side\" of the printer is managed by an abstract process called\n+//! PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n+//! do with each token/size pair it consumes as it goes. It's trying to consume\n+//! the entire buffered window, but can't output anything until the size is >=\n+//! 0 (sizes are set to negative while they're pending calculation).\n+//!\n+//! So SCAN takes input and buffers tokens and pending calculations, while\n+//! PRINT gobbles up completed calculations and tokens from the buffer. The\n+//! theory is that the two can never get more than 3N tokens apart, because\n+//! once there's \"obviously\" too much data to fit on a line, in a size\n+//! calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n+//! it.\n+//!\n+//! In this implementation (following the paper, again) the SCAN process is\n+//! the method called `Printer::pretty_print`, and the 'PRINT' process is the method\n+//! called `Printer::print`.\n \n use std::collections::VecDeque;\n use std::fmt;\n use std::io;\n \n+/// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n pub enum Breaks {\n     Consistent,\n@@ -177,81 +261,6 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     }\n }\n \n-\n-/// In case you do not have the paper, here is an explanation of what's going\n-/// on.\n-///\n-/// There is a stream of input tokens flowing through this printer.\n-///\n-/// The printer buffers up to 3N tokens inside itself, where N is linewidth.\n-/// Yes, linewidth is chars and tokens are multi-char, but in the worst\n-/// case every token worth buffering is 1 char long, so it's ok.\n-///\n-/// Tokens are String, Break, and Begin/End to delimit blocks.\n-///\n-/// Begin tokens can carry an offset, saying \"how far to indent when you break\n-/// inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n-/// breaking. Consistent breaking means that after the first break, no attempt\n-/// will be made to flow subsequent breaks together onto lines. Inconsistent\n-/// is the opposite. Inconsistent breaking example would be, say:\n-///\n-///  foo(hello, there, good, friends)\n-///\n-/// breaking inconsistently to become\n-///\n-///  foo(hello, there\n-///      good, friends);\n-///\n-/// whereas a consistent breaking would yield:\n-///\n-///  foo(hello,\n-///      there\n-///      good,\n-///      friends);\n-///\n-/// That is, in the consistent-break blocks we value vertical alignment\n-/// more than the ability to cram stuff onto a line. But in all cases if it\n-/// can make a block a one-liner, it'll do so.\n-///\n-/// Carrying on with high-level logic:\n-///\n-/// The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n-/// 'right' indices denote the active portion of the ring buffer as well as\n-/// describing hypothetical points-in-the-infinite-stream at most 3N tokens\n-/// apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n-/// between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n-/// and point-in-infinite-stream senses freely.\n-///\n-/// There is a parallel ring buffer, 'size', that holds the calculated size of\n-/// each token. Why calculated? Because for Begin/End pairs, the \"size\"\n-/// includes everything between the pair. That is, the \"size\" of Begin is\n-/// actually the sum of the sizes of everything between Begin and the paired\n-/// End that follows. Since that is arbitrarily far in the future, 'size' is\n-/// being rewritten regularly while the printer runs; in fact most of the\n-/// machinery is here to work out 'size' entries on the fly (and give up when\n-/// they're so obviously over-long that \"infinity\" is a good enough\n-/// approximation for purposes of line breaking).\n-///\n-/// The \"input side\" of the printer is managed as an abstract process called\n-/// SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n-/// other words, the process of calculating 'size' entries.\n-///\n-/// The \"output side\" of the printer is managed by an abstract process called\n-/// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n-/// do with each token/size pair it consumes as it goes. It's trying to consume\n-/// the entire buffered window, but can't output anything until the size is >=\n-/// 0 (sizes are set to negative while they're pending calculation).\n-///\n-/// So SCAN takes input and buffers tokens and pending calculations, while\n-/// PRINT gobbles up completed calculations and tokens from the buffer. The\n-/// theory is that the two can never get more than 3N tokens apart, because\n-/// once there's \"obviously\" too much data to fit on a line, in a size\n-/// calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n-/// it.\n-///\n-/// In this implementation (following the paper, again) the SCAN process is\n-/// the method called 'pretty_print', and the 'PRINT' process is the method\n-/// called 'print'.\n pub struct Printer<'a> {\n     pub out: Box<io::Write+'a>,\n     buf_len: usize,\n@@ -292,7 +301,7 @@ impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.buf[self.right].token.clone()\n     }\n-    // be very careful with this!\n+    /// be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.buf[self.right].token = t;\n     }\n@@ -571,19 +580,21 @@ impl<'a> Printer<'a> {\n }\n \n // Convenience functions to talk to the printer.\n-//\n-// \"raw box\"\n+\n+/// \"raw box\"\n pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n     p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as isize,\n         breaks: b\n     }))\n }\n \n+/// Inconsistent breaking box\n pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n     rbox(p, indent, Breaks::Inconsistent)\n }\n \n+/// Consistent breaking box\n pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n     rbox(p, indent, Breaks::Consistent)\n }"}, {"sha": "4e201c254e39f4f9bc9bb17e029368b468f580ea", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -513,7 +513,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(\n \n extern \"C\" LLVMRustMetadataRef\n LLVMRustDIBuilderCreateBasicType(LLVMRustDIBuilderRef Builder, const char *Name,\n-                                 uint64_t SizeInBits, uint64_t AlignInBits,\n+                                 uint64_t SizeInBits, uint32_t AlignInBits,\n                                  unsigned Encoding) {\n   return wrap(Builder->createBasicType(Name, SizeInBits,\n #if LLVM_VERSION_LE(3, 9)\n@@ -524,15 +524,15 @@ LLVMRustDIBuilderCreateBasicType(LLVMRustDIBuilderRef Builder, const char *Name,\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreatePointerType(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef PointeeTy,\n-    uint64_t SizeInBits, uint64_t AlignInBits, const char *Name) {\n+    uint64_t SizeInBits, uint32_t AlignInBits, const char *Name) {\n   return wrap(Builder->createPointerType(unwrapDI<DIType>(PointeeTy),\n                                          SizeInBits, AlignInBits, Name));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n     LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n-    uint64_t AlignInBits, LLVMRustDIFlags Flags,\n+    uint32_t AlignInBits, LLVMRustDIFlags Flags,\n     LLVMRustMetadataRef DerivedFrom, LLVMRustMetadataRef Elements,\n     unsigned RunTimeLang, LLVMRustMetadataRef VTableHolder,\n     const char *UniqueId) {\n@@ -546,7 +546,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateMemberType(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n     LLVMRustMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n-    uint64_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n+    uint32_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n     LLVMRustMetadataRef Ty) {\n   return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n                                         unwrapDI<DIFile>(File), LineNo,\n@@ -573,7 +573,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Context, const char *Name,\n     const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n     LLVMRustMetadataRef Ty, bool IsLocalToUnit, LLVMValueRef V,\n-    LLVMRustMetadataRef Decl = nullptr, uint64_t AlignInBits = 0) {\n+    LLVMRustMetadataRef Decl = nullptr, uint32_t AlignInBits = 0) {\n   Constant *InitVal = cast<Constant>(unwrap(V));\n \n #if LLVM_VERSION_GE(4, 0)\n@@ -612,7 +612,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n     LLVMRustDIBuilderRef Builder, unsigned Tag, LLVMRustMetadataRef Scope,\n     const char *Name, LLVMRustMetadataRef File, unsigned LineNo,\n     LLVMRustMetadataRef Ty, bool AlwaysPreserve, LLVMRustDIFlags Flags,\n-    unsigned ArgNo, uint64_t AlignInBits) {\n+    unsigned ArgNo, uint32_t AlignInBits) {\n #if LLVM_VERSION_GE(3, 8)\n   if (Tag == 0x100) { // DW_TAG_auto_variable\n     return wrap(Builder->createAutoVariable(\n@@ -637,7 +637,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n \n extern \"C\" LLVMRustMetadataRef\n LLVMRustDIBuilderCreateArrayType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n-                                 uint64_t AlignInBits, LLVMRustMetadataRef Ty,\n+                                 uint32_t AlignInBits, LLVMRustMetadataRef Ty,\n                                  LLVMRustMetadataRef Subscripts) {\n   return wrap(\n       Builder->createArrayType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n@@ -646,7 +646,7 @@ LLVMRustDIBuilderCreateArrayType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n \n extern \"C\" LLVMRustMetadataRef\n LLVMRustDIBuilderCreateVectorType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n-                                  uint64_t AlignInBits, LLVMRustMetadataRef Ty,\n+                                  uint32_t AlignInBits, LLVMRustMetadataRef Ty,\n                                   LLVMRustMetadataRef Subscripts) {\n   return wrap(\n       Builder->createVectorType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n@@ -687,7 +687,7 @@ LLVMRustDIBuilderCreateEnumerator(LLVMRustDIBuilderRef Builder,\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n     LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n-    uint64_t AlignInBits, LLVMRustMetadataRef Elements,\n+    uint32_t AlignInBits, LLVMRustMetadataRef Elements,\n     LLVMRustMetadataRef ClassTy) {\n   return wrap(Builder->createEnumerationType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n@@ -698,7 +698,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n     LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n-    uint64_t AlignInBits, LLVMRustDIFlags Flags, LLVMRustMetadataRef Elements,\n+    uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMRustMetadataRef Elements,\n     unsigned RunTimeLang, const char *UniqueId) {\n   return wrap(Builder->createUnionType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,"}, {"sha": "608b1eb0872ad8243f502781da1fd75496474fa7", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -29,6 +29,9 @@ pub type RustBadRet = extern fn() -> Box<u32>;\n pub type CVoidRet = ();\n pub struct Foo;\n \n+#[repr(C)]\n+pub struct ZeroSizeWithPhantomData(::std::marker::PhantomData<i32>);\n+\n extern {\n     pub fn ptr_type1(size: *const Foo); //~ ERROR: found struct without\n     pub fn ptr_type2(size: *const Foo); //~ ERROR: found struct without\n@@ -40,6 +43,9 @@ extern {\n     pub fn tuple_type(p: (i32, i32)); //~ ERROR found Rust tuple type\n     pub fn tuple_type2(p: I32Pair); //~ ERROR found Rust tuple type\n     pub fn zero_size(p: ZeroSize); //~ ERROR found zero-size struct\n+    pub fn zero_size_phantom(p: ZeroSizeWithPhantomData); //~ ERROR found zero-sized type\n+    pub fn zero_size_phantom_toplevel()\n+        -> ::std::marker::PhantomData<bool>; //~ ERROR: found zero-sized type\n     pub fn fn_type(p: RustFn); //~ ERROR found function pointer with Rust\n     pub fn fn_type2(p: fn()); //~ ERROR found function pointer with Rust\n     pub fn fn_contained(p: RustBadRet); //~ ERROR: found struct without"}, {"sha": "5b53e94825300d2219b3b82e40423787e27af80e", "filename": "src/test/incremental/issue-39569.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Fincremental%2Fissue-39569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Fincremental%2Fissue-39569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39569.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for a weird corner case in our dep-graph reduction\n+// code. When we solve `CoerceUnsized<Foo>`, we find no impls, so we\n+// don't end up with an edge to any HIR nodes, but it still gets\n+// preserved in the dep graph.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+use std::sync::Arc;\n+\n+#[cfg(rpass1)]\n+struct Foo { x: usize }\n+\n+#[cfg(rpass1)]\n+fn main() {\n+    let x: Arc<Foo> = Arc::new(Foo { x: 22 });\n+    let y: Arc<Foo> = x;\n+}\n+\n+#[cfg(rpass2)]\n+struct FooX { x: usize }\n+\n+#[cfg(rpass2)]\n+fn main() {\n+    let x: Arc<FooX> = Arc::new(FooX { x: 22 });\n+    let y: Arc<FooX> = x;\n+}\n+"}, {"sha": "e217d07ed725d86ffc216de1eda7fb0f6b21059c", "filename": "src/test/run-pass/issue-34798.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frun-pass%2Fissue-34798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frun-pass%2Fissue-34798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34798.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![forbid(improper_ctypes)]\n+#![allow(dead_code)]\n+\n+#[repr(C)]\n+pub struct Foo {\n+    size: u8,\n+    __value: ::std::marker::PhantomData<i32>,\n+}\n+\n+#[repr(C)]\n+pub struct ZeroSizeWithPhantomData<T>(::std::marker::PhantomData<T>);\n+\n+#[repr(C)]\n+pub struct Bar {\n+    size: u8,\n+    baz: ZeroSizeWithPhantomData<i32>,\n+}\n+\n+extern \"C\" {\n+    pub fn bar(_: *mut Foo, _: *mut Bar);\n+}\n+\n+fn main() {\n+}"}, {"sha": "be87b7b3c87e42fbd50cd4905bc39d9bd9af7a3a", "filename": "src/test/run-pass/try-wait.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frun-pass%2Ftry-wait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frun-pass%2Ftry-wait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-wait.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -13,7 +13,6 @@\n #![feature(process_try_wait)]\n \n use std::env;\n-use std::io;\n use std::process::Command;\n use std::thread;\n use std::time::Duration;\n@@ -32,17 +31,17 @@ fn main() {\n                          .arg(\"sleep\")\n                          .spawn()\n                          .unwrap();\n-    let err = me.try_wait().unwrap_err();\n-    assert_eq!(err.kind(), io::ErrorKind::WouldBlock);\n-    let err = me.try_wait().unwrap_err();\n-    assert_eq!(err.kind(), io::ErrorKind::WouldBlock);\n+    let maybe_status = me.try_wait().unwrap();\n+    assert!(maybe_status.is_none());\n+    let maybe_status = me.try_wait().unwrap();\n+    assert!(maybe_status.is_none());\n \n     me.kill().unwrap();\n     me.wait().unwrap();\n \n-    let status = me.try_wait().unwrap();\n+    let status = me.try_wait().unwrap().unwrap();\n     assert!(!status.success());\n-    let status = me.try_wait().unwrap();\n+    let status = me.try_wait().unwrap().unwrap();\n     assert!(!status.success());\n \n     let mut me = Command::new(env::current_exe().unwrap())\n@@ -51,17 +50,17 @@ fn main() {\n                          .unwrap();\n     loop {\n         match me.try_wait() {\n-            Ok(res) => {\n+            Ok(Some(res)) => {\n                 assert!(res.success());\n                 break\n             }\n-            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n+            Ok(None) => {\n                 thread::sleep(Duration::from_millis(1));\n             }\n             Err(e) => panic!(\"error in try_wait: {}\", e),\n         }\n     }\n \n-    let status = me.try_wait().unwrap();\n+    let status = me.try_wait().unwrap().unwrap();\n     assert!(status.success());\n }"}, {"sha": "51daa8075262228632600e6a17ce339680ac201f", "filename": "src/test/rustdoc/test_option_check/bar.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frustdoc%2Ftest_option_check%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frustdoc%2Ftest_option_check%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest_option_check%2Fbar.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+// check-test-line-numbers-match\n+\n+/// This looks like another awesome test!\n+///\n+/// ```\n+/// println!(\"foo?\");\n+/// ```\n+pub fn foooo() {}"}, {"sha": "a9578c5f434a23e0ecb291cc0d989699cadd7be2", "filename": "src/test/rustdoc/test_option_check/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frustdoc%2Ftest_option_check%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftest%2Frustdoc%2Ftest_option_check%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest_option_check%2Ftest.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -11,6 +11,8 @@\n // compile-flags: --test\n // check-test-line-numbers-match\n \n+pub mod bar;\n+\n /// This is a Foo;\n ///\n /// ```"}, {"sha": "548a11439f5ccf44e645ba089f3050447a9cec40", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -11,7 +11,7 @@\n extern crate toml;\n extern crate rustc_serialize;\n \n-use std::collections::HashMap;\n+use std::collections::{BTreeMap, HashMap};\n use std::env;\n use std::fs::File;\n use std::io::{self, Read, Write};\n@@ -95,7 +95,6 @@ static MINGW: &'static [&'static str] = &[\n     \"x86_64-pc-windows-gnu\",\n ];\n \n-#[derive(RustcEncodable)]\n struct Manifest {\n     manifest_version: String,\n     date: String,\n@@ -171,8 +170,18 @@ impl Builder {\n         self.cargo_version = self.version(\"cargo\", \"x86_64-unknown-linux-gnu\");\n \n         self.digest_and_sign();\n-        let manifest = self.build_manifest();\n-        let manifest = toml::encode(&manifest).to_string();\n+        let Manifest { manifest_version, date, pkg } = self.build_manifest();\n+\n+        // Unfortunately we can't use derive(RustcEncodable) here because the\n+        // version field is called `manifest-version`, not `manifest_version`.\n+        // In lieu of that just create the table directly here with a `BTreeMap`\n+        // and wrap it up in a `Value::Table`.\n+        let mut manifest = BTreeMap::new();\n+        manifest.insert(\"manifest-version\".to_string(),\n+                        toml::encode(&manifest_version));\n+        manifest.insert(\"date\".to_string(), toml::encode(&date));\n+        manifest.insert(\"pkg\".to_string(), toml::encode(&pkg));\n+        let manifest = toml::Value::Table(manifest).to_string();\n \n         let filename = format!(\"channel-rust-{}.toml\", self.channel);\n         self.write_manifest(&manifest, &filename);"}, {"sha": "1a3d7a190be366bb1d655a1da9d88fc768252a5f", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "patch": "@@ -30,6 +30,7 @@ use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, ExitStatus};\n use std::str;\n+use std::collections::HashMap;\n \n use extract_gdb_version;\n \n@@ -1942,17 +1943,28 @@ actual:\\n\\\n         }\n     }\n \n-    fn check_rustdoc_test_option(&self, res: ProcRes) {\n-        let mut file = fs::File::open(&self.testpaths.file)\n+    fn get_lines<P: AsRef<Path>>(&self, path: &P,\n+                                 mut other_files: Option<&mut Vec<String>>) -> Vec<usize> {\n+        let mut file = fs::File::open(path)\n                                 .expect(\"markdown_test_output_check_entry File::open failed\");\n         let mut content = String::new();\n         file.read_to_string(&mut content)\n             .expect(\"markdown_test_output_check_entry read_to_string failed\");\n         let mut ignore = false;\n-        let mut v: Vec<usize> =\n-            content.lines()\n-                   .enumerate()\n-                   .filter_map(|(line_nb, line)| {\n+        content.lines()\n+               .enumerate()\n+               .filter_map(|(line_nb, line)| {\n+                   if (line.trim_left().starts_with(\"pub mod \") ||\n+                       line.trim_left().starts_with(\"mod \")) &&\n+                      line.ends_with(\";\") {\n+                       if let Some(ref mut other_files) = other_files {\n+                           other_files.push(line.rsplit(\"mod \")\n+                                      .next()\n+                                      .unwrap()\n+                                      .replace(\";\", \"\"));\n+                       }\n+                       None\n+                   } else {\n                        let sline = line.split(\"///\").last().unwrap_or(\"\");\n                        let line = sline.trim_left();\n                        if line.starts_with(\"```\") {\n@@ -1966,36 +1978,57 @@ actual:\\n\\\n                        } else {\n                            None\n                        }\n-                   })\n-                   .collect();\n+                   }\n+               })\n+               .collect()\n+    }\n+\n+    fn check_rustdoc_test_option(&self, res: ProcRes) {\n+        let mut other_files = Vec::new();\n+        let mut files: HashMap<String, Vec<usize>> = HashMap::new();\n+        files.insert(self.testpaths.file.to_str().unwrap().to_owned(),\n+                     self.get_lines(&self.testpaths.file, Some(&mut other_files)));\n+        for other_file in other_files {\n+            let mut path = self.testpaths.file.clone();\n+            path.set_file_name(&format!(\"{}.rs\", other_file));\n+            files.insert(path.to_str().unwrap().to_owned(), self.get_lines(&path, None));\n+        }\n \n         let mut tested = 0;\n         for _ in res.stdout.split(\"\\n\")\n                            .filter(|s| s.starts_with(\"test \"))\n                            .inspect(|s| {\n                                let tmp: Vec<&str> = s.split(\" - line \").collect();\n                                if tmp.len() == 2 {\n-                                   tested += 1;\n-                                   let line = tmp[1].split(\" ...\")\n-                                                    .next()\n-                                                    .unwrap_or(\"0\")\n-                                                    .parse()\n-                                                    .unwrap_or(0);\n-                                   if let Ok(pos) = v.binary_search(&line) {\n-                                       v.remove(pos);\n-                                   } else {\n-                                       self.fatal_proc_rec(\n-                                           &format!(\"Not found doc test: \\\"{}\\\" in {:?}\", s, v),\n-                                           &res);\n+                                   let path = tmp[0].rsplit(\"test \").next().unwrap();\n+                                   if let Some(ref mut v) = files.get_mut(path) {\n+                                       tested += 1;\n+                                       let line = tmp[1].split(\" ...\")\n+                                                        .next()\n+                                                        .unwrap_or(\"0\")\n+                                                        .parse()\n+                                                        .unwrap_or(0);\n+                                       if let Ok(pos) = v.binary_search(&line) {\n+                                           v.remove(pos);\n+                                       } else {\n+                                           self.fatal_proc_rec(\n+                                               &format!(\"Not found doc test: \\\"{}\\\" in \\\"{}\\\":{:?}\",\n+                                                        s, path, v),\n+                                               &res);\n+                                       }\n                                    }\n                                }\n                            }) {}\n         if tested == 0 {\n-            self.fatal_proc_rec(\"No test has been found\", &res);\n-        } else if v.len() != 0 {\n-            self.fatal_proc_rec(&format!(\"Not found test at line{} {:?}\",\n-                                         if v.len() > 1 { \"s\" } else { \"\" }, v),\n-                                &res);\n+            self.fatal_proc_rec(&format!(\"No test has been found... {:?}\", files), &res);\n+        } else {\n+            for (entry, v) in &files {\n+                if v.len() != 0 {\n+                    self.fatal_proc_rec(&format!(\"Not found test at line{} \\\"{}\\\":{:?}\",\n+                                                 if v.len() > 1 { \"s\" } else { \"\" }, entry, v),\n+                                        &res);\n+                }\n+            }\n         }\n     }\n "}]}