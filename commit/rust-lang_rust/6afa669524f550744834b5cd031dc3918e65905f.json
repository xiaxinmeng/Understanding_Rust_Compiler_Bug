{"sha": "6afa669524f550744834b5cd031dc3918e65905f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZmE2Njk1MjRmNTUwNzQ0ODM0YjVjZDAzMWRjMzkxOGU2NTkwNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-06T06:08:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-06T06:08:27Z"}, "message": "Auto merge of #25035 - Stebalien:iter, r=aturon\n\nSpecifically, make count, nth, and last call the corresponding methods on the underlying iterator where possible. This way, if the underlying iterator has an optimized count, nth, or last implementations (e.g. slice::Iter), these methods will propagate these optimizations.\r\n\r\nAdditionally, change Skip::next to take advantage of a potentially optimized nth method on the underlying iterator.\r\n\r\nThis covers:\r\n\r\n* core::iter::Chain: count, last, nth\r\n* core::iter::Enumerate: count, nth\r\n* core::iter::Peekable: count, last, nth\r\n* core::iter::Skip: count, last, next (should call nth), nth\r\n* core::iter::Take: nth\r\n* core::iter::Fuse: count, last, nth\r\n\r\nof #24214.", "tree": {"sha": "1f462ac678beb62923a0d033ffb1d56179bfd43e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f462ac678beb62923a0d033ffb1d56179bfd43e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6afa669524f550744834b5cd031dc3918e65905f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6afa669524f550744834b5cd031dc3918e65905f", "html_url": "https://github.com/rust-lang/rust/commit/6afa669524f550744834b5cd031dc3918e65905f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6afa669524f550744834b5cd031dc3918e65905f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b04c16bd6954a28e1bcf5fcfc7fb9a784ca2914", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b04c16bd6954a28e1bcf5fcfc7fb9a784ca2914", "html_url": "https://github.com/rust-lang/rust/commit/5b04c16bd6954a28e1bcf5fcfc7fb9a784ca2914"}, {"sha": "3fcbc31489cafc731d8c7212ffc7341fa5d80299", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fcbc31489cafc731d8c7212ffc7341fa5d80299", "html_url": "https://github.com/rust-lang/rust/commit/3fcbc31489cafc731d8c7212ffc7341fa5d80299"}], "stats": {"total": 378, "additions": 360, "deletions": 18}, "files": [{"sha": "37cabe60216982be9d03e3ec2f7ff261745c71a8", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 145, "deletions": 18, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/6afa669524f550744834b5cd031dc3918e65905f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa669524f550744834b5cd031dc3918e65905f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6afa669524f550744834b5cd031dc3918e65905f", "patch": "@@ -1472,6 +1472,32 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        (if !self.flag { self.a.count() } else { 0 }) + self.b.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        if !self.flag {\n+            for x in self.a.by_ref() {\n+                if n == 0 {\n+                    return Some(x)\n+                }\n+                n -= 1;\n+            }\n+            self.flag = true;\n+        }\n+        self.b.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        let a_last = if self.flag { None } else { self.a.last() };\n+        let b_last = self.b.last();\n+        b_last.or(a_last)\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n@@ -1777,6 +1803,20 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        self.iter.nth(n).map(|a| {\n+            let i = self.count + n;\n+            self.count = i + 1;\n+            (i, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1834,6 +1874,28 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         }\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked {\n+            Some(_) if n == 0 => self.peeked.take(),\n+            Some(_) => {\n+                self.peeked = None;\n+                self.iter.nth(n-1)\n+            },\n+            None => self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.iter.last().or(self.peeked)\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.iter.size_hint();\n@@ -1960,27 +2022,49 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        let mut next = self.iter.next();\n+    fn next(&mut self) -> Option<I::Item> {\n         if self.n == 0 {\n-            next\n+            self.iter.next()\n         } else {\n-            let mut n = self.n;\n-            while n > 0 {\n-                n -= 1;\n-                match next {\n-                    Some(_) => {\n-                        next = self.iter.next();\n-                        continue\n-                    }\n-                    None => {\n-                        self.n = 0;\n-                        return None\n-                    }\n-                }\n-            }\n+            let old_n = self.n;\n             self.n = 0;\n-            next\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n == 0 {\n+            self.iter.nth(n)\n+        } else {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            if self.iter.nth(to_skip-1).is_none() {\n+                return None;\n+            }\n+            self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count().saturating_sub(self.n)\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.last()\n+        } else {\n+            let next = self.next();\n+            if next.is_some() {\n+                // recurse. n should be 0.\n+                self.last().or(next)\n+            } else {\n+                None\n+            }\n         }\n     }\n \n@@ -2038,6 +2122,20 @@ impl<I> Iterator for Take<I> where I: Iterator{\n         }\n     }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper) = self.iter.size_hint();\n@@ -2199,6 +2297,35 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n         }\n     }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let nth = self.iter.nth(n);\n+            self.done = nth.is_none();\n+            nth\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            self.iter.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        if self.done {\n+            0\n+        } else {\n+            self.iter.count()\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.done {"}, {"sha": "0415c75aa5204cb6eaa43dd6f37296f5dd0a63de", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/6afa669524f550744834b5cd031dc3918e65905f/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa669524f550744834b5cd031dc3918e65905f/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=6afa669524f550744834b5cd031dc3918e65905f", "patch": "@@ -100,6 +100,42 @@ fn test_iterator_chain() {\n     assert_eq!(i, expected.len());\n }\n \n+#[test]\n+fn test_iterator_chain_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    for (i, x) in expected.iter().enumerate() {\n+        assert_eq!(Some(x), xs.iter().chain(ys.iter()).nth(i));\n+    }\n+    assert_eq!(zs.iter().chain(xs.iter()).nth(0), Some(&0));\n+\n+    let mut it = xs.iter().chain(zs.iter());\n+    assert_eq!(it.nth(5), Some(&5));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_chain_last() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    assert_eq!(xs.iter().chain(ys.iter()).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(ys.iter()).last(), Some(&60));\n+    assert_eq!(ys.iter().chain(zs.iter()).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(zs.iter()).last(), None);\n+}\n+\n+#[test]\n+fn test_iterator_chain_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    assert_eq!(xs.iter().chain(ys.iter()).count(), 10);\n+    assert_eq!(zs.iter().chain(ys.iter()).count(), 4);\n+}\n+\n #[test]\n fn test_filter_map() {\n     let it = (0..).step_by(1).take(10)\n@@ -116,6 +152,34 @@ fn test_iterator_enumerate() {\n     }\n }\n \n+#[test]\n+fn test_iterator_enumerate_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    for (i, &x) in xs.iter().enumerate() {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth(0) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth(1) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let (i, &x) = xs.iter().enumerate().nth(3).unwrap();\n+    assert_eq!(i, x);\n+    assert_eq!(i, 3);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    assert_eq!(xs.iter().count(), 6);\n+}\n+\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n@@ -148,6 +212,59 @@ fn test_iterator_peekable() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_iterator_peekable_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [10];\n+    let zs: [i32; 0] = [];\n+\n+    assert_eq!(xs.iter().peekable().count(), 6);\n+\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.count(), 6);\n+\n+    assert_eq!(ys.iter().peekable().count(), 1);\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&10));\n+    assert_eq!(it.count(), 1);\n+\n+    assert_eq!(zs.iter().peekable().count(), 0);\n+\n+    let mut it = zs.iter().peekable();\n+    assert_eq!(it.peek(), None);\n+\n+}\n+\n+#[test]\n+fn test_iterator_peekable_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.nth(0), Some(&0));\n+    assert_eq!(it.peek(), Some(&&1));\n+    assert_eq!(it.nth(1), Some(&2));\n+    assert_eq!(it.peek(), Some(&&3));\n+    assert_eq!(it.nth(2), Some(&5));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_peekable_last() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [0];\n+\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.last(), Some(&5));\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.last(), Some(&0));\n+}\n+\n #[test]\n fn test_iterator_take_while() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -189,6 +306,49 @@ fn test_iterator_skip() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_iterator_skip_nth() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    let mut it = xs.iter().skip(0);\n+    assert_eq!(it.nth(0), Some(&0));\n+    assert_eq!(it.nth(1), Some(&2));\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.nth(0), Some(&13));\n+    assert_eq!(it.nth(1), Some(&16));\n+\n+    let mut it = xs.iter().skip(12);\n+    assert_eq!(it.nth(0), None);\n+\n+}\n+\n+#[test]\n+fn test_iterator_skip_count() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    assert_eq!(xs.iter().skip(0).count(), 12);\n+    assert_eq!(xs.iter().skip(1).count(), 11);\n+    assert_eq!(xs.iter().skip(11).count(), 1);\n+    assert_eq!(xs.iter().skip(12).count(), 0);\n+    assert_eq!(xs.iter().skip(13).count(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_skip_last() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    assert_eq!(xs.iter().skip(0).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(1).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(11).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(12).last(), None);\n+    assert_eq!(xs.iter().skip(13).last(), None);\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&13));\n+    assert_eq!(it.last(), Some(&30));\n+}\n+\n #[test]\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -205,6 +365,30 @@ fn test_iterator_take() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_iterator_take_nth() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth(0) {\n+            assert_eq!(x, i);\n+            i += 1;\n+        }\n+    }\n+    assert_eq!(it.nth(1), Some(&5));\n+    assert_eq!(it.nth(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    let mut i = 1;\n+    while let Some(&x) = it.nth(1) {\n+        assert_eq!(x, i);\n+        i += 2;\n+    }\n+}\n+\n #[test]\n fn test_iterator_take_short() {\n     let xs = [0, 1, 2, 3];\n@@ -881,6 +1065,37 @@ fn test_fuse() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_fuse_nth() {\n+    let xs = [0, 1, 2];\n+    let mut it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.nth(2), Some(&2));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.nth(2), None);\n+    assert_eq!(it.len(), 0);\n+}\n+\n+#[test]\n+fn test_fuse_last() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.last(), Some(&2));\n+}\n+\n+#[test]\n+fn test_fuse_count() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.count(), 3);\n+    // Can't check len now because count consumes.\n+}\n+\n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n     let it: Vec<usize> = (0..300).collect();"}]}