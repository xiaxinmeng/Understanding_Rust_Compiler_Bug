{"sha": "b5f8cd5c20977119eb600b05edf699a1bde92a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZjhjZDVjMjA5NzcxMTllYjYwMGIwNWVkZjY5OWExYmRlOTJhMmM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-01-30T04:15:38Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-01-30T04:25:54Z"}, "message": "Fix ref-to-ptr coercions not working with NLL in certain cases\n\nImplicit coercions from references to pointers were lowered to slightly\ndifferent Mir than explicit casts (e.g. 'foo as *mut T'). This resulted\nin certain uses of self-referential structs compiling correctly when an\nexplicit cast was used, but not when the implicit coercion was used.\n\nTo fix this, this commit adds an outer 'Use' expr when applying a\nraw-ptr-borrow adjustment. This makes the lowered Mir for coercions\nidentical to that of explicit coercions, allowing the original code to\ncompile regardless of how the raw ptr cast occurs.\n\nFixes #47722", "tree": {"sha": "601168b12623431d7a5b9f8258c8e459acb27774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/601168b12623431d7a5b9f8258c8e459acb27774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5f8cd5c20977119eb600b05edf699a1bde92a2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlpv89IACgkQtAh+UQ6Y\nsWQLYA/8Cj02XvXazunRs8yjjtp4zbeARJJC1Q7Wn9LtuQ/yuUvtcbpvm1M4BKLm\n+uO8yC74hlUmfaEbQW4F4aLT0HLkCQ8mXCBSVao7q8ZErkgFpaQWM2rq5Z5mjBjp\n6dUDYLGLElLqsdNnIF1lTFfDc7DwRxDpLAhTbt9jHFbH11J2rCjZUn0zPpzIaGd6\nHUnEGOat5DWRCJMnTSHj6ihXZAnu/ae282fp1b+9FCtWejEJT/SWkQVu2m5euJvY\n6UkS7I2oyO1g2+XiCtKBtRjd96nLRNz217quaFIvPoSJ7rz40hd1Q/nr/QxaI9Tt\n4OIUjJYt1fVmGl4cm6oHcz+O/5KFmKZDzwVF5o4rno7GOiYcbHUqPZt6nDXQQiZ3\nTbpPLAjaS9J4eU6HHMZ9KrHAOGdIoxnyKOHxNoxL9j7apsIpqe85DfGW9oxlnfAg\nOVdnLAYty5D4IPBOJkZFJTEdl603cT6tHbA2kfzbwOsT8pesAixyg7TiDuDgiE53\nMlr7UPi5xk3fYIc629/OffYsbfw+7Fbcj20DcAJy2uRZL9aZB2i8Mod+7HhL3rG3\nT6UL3suWZa+vkN1jvAPKAvqzdibiyd0Y3TZlNWbvTdeWmXHtMY+wrlQzXdgPSfkS\nHQouyriASlRKwYlOIJduYKjuc12hqNOu7K2Ivz7+QgYSOEthKA8=\n=/3SR\n-----END PGP SIGNATURE-----", "payload": "tree 601168b12623431d7a5b9f8258c8e459acb27774\nparent 90eb44a5897c39e3dff9c7e48e3973671dcd9496\nauthor Aaron Hill <aa1ronham@gmail.com> 1517285738 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1517286354 -0500\n\nFix ref-to-ptr coercions not working with NLL in certain cases\n\nImplicit coercions from references to pointers were lowered to slightly\ndifferent Mir than explicit casts (e.g. 'foo as *mut T'). This resulted\nin certain uses of self-referential structs compiling correctly when an\nexplicit cast was used, but not when the implicit coercion was used.\n\nTo fix this, this commit adds an outer 'Use' expr when applying a\nraw-ptr-borrow adjustment. This makes the lowered Mir for coercions\nidentical to that of explicit coercions, allowing the original code to\ncompile regardless of how the raw ptr cast occurs.\n\nFixes #47722\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f8cd5c20977119eb600b05edf699a1bde92a2c", "html_url": "https://github.com/rust-lang/rust/commit/b5f8cd5c20977119eb600b05edf699a1bde92a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5f8cd5c20977119eb600b05edf699a1bde92a2c/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90eb44a5897c39e3dff9c7e48e3973671dcd9496", "url": "https://api.github.com/repos/rust-lang/rust/commits/90eb44a5897c39e3dff9c7e48e3973671dcd9496", "html_url": "https://github.com/rust-lang/rust/commit/90eb44a5897c39e3dff9c7e48e3973671dcd9496"}], "stats": {"total": 69, "additions": 65, "deletions": 4}, "files": [{"sha": "317b038c4829566bdddd7e9189553b60ca5e4431", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b5f8cd5c20977119eb600b05edf699a1bde92a2c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f8cd5c20977119eb600b05edf699a1bde92a2c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b5f8cd5c20977119eb600b05edf699a1bde92a2c", "patch": "@@ -145,7 +145,39 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     arg: expr.to_ref(),\n                 },\n             };\n-            ExprKind::Cast { source: expr.to_ref() }\n+            let cast_expr = Expr {\n+                temp_lifetime,\n+                ty: adjustment.target,\n+                span,\n+                kind: ExprKind::Cast { source: expr.to_ref() }\n+            };\n+\n+            // To ensure that both implicit and explicit coercions are\n+            // handled the same way, we insert an extra layer of indirection here.\n+            // For explicit casts (e.g. 'foo as *const T'), the source of the 'Use'\n+            // will be an ExprKind::Hair with the appropriate cast expression. Here,\n+            // we make our Use source the generated Cast from the original coercion.\n+            //\n+            // In both cases, this outer 'Use' ensures that the inner 'Cast' is handled by\n+            // as_operand, not by as_rvalue - causing the cast result to be stored in a temporary.\n+            // Ordinary, this is identical to using the cast directly as an rvalue. However, if the\n+            // source of the cast was previously borrowed as mutable, storing the cast in a\n+            // temporary gives the source a chance to expire before the cast is used. For\n+            // structs with a self-referential *mut ptr, this allows assignment to work as\n+            // expected.\n+            //\n+            // For example, consider the type 'struct Foo { field: *mut Foo }',\n+            // The method 'fn bar(&mut self) { self.field = self }'\n+            // triggers a coercion from '&mut self' to '*mut self'. In order\n+            // for the assignment to be valid, the implicit borrow\n+            // of 'self' involved in the coercion needs to end before the local\n+            // containing the '*mut T' is assigned to 'self.field' - otherwise,\n+            // we end up trying to assign to 'self.field' while we have another mutable borrow\n+            // active.\n+            //\n+            // We only need to worry about this kind of thing for coercions from refs to ptrs,\n+            // since they get rid of a borrow implicitly.\n+            ExprKind::Use { source: cast_expr.to_ref() }\n         }\n         Adjust::Unsize => {\n             ExprKind::Unsize { source: expr.to_ref() }"}, {"sha": "d8d83fb5b453707c69d2c8b46de919495d893358", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5f8cd5c20977119eb600b05edf699a1bde92a2c/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f8cd5c20977119eb600b05edf699a1bde92a2c/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=b5f8cd5c20977119eb600b05edf699a1bde92a2c", "patch": "@@ -52,12 +52,15 @@ fn main() {\n //         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         StorageLive(_4);\n+//         StorageLive(_5);\n //         Validate(Suspend(ReScope(Node(ItemLocalId(9)))), [(*_2): i32]);\n-//         _4 = &ReErased mut (*_2);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(9)))]);\n-//         _3 = move _4 as *mut i32 (Misc);\n+//         _5 = &ReErased mut (*_2);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(9)))]);\n+//         _4 = move _5 as *mut i32 (Misc);\n+//         _3 = move _4;\n //         EndRegion(ReScope(Node(ItemLocalId(9))));\n //         StorageDead(_4);\n+//         StorageDead(_5);\n //         Validate(Release, [_0: bool, _3: *mut i32]);\n //         _0 = const write_42(move _3) -> bb1;\n //     }"}, {"sha": "3b5d808e1f54686a80f3301baa4323767257e5a5", "filename": "src/test/run-pass/issue-47722.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5f8cd5c20977119eb600b05edf699a1bde92a2c/src%2Ftest%2Frun-pass%2Fissue-47722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f8cd5c20977119eb600b05edf699a1bde92a2c/src%2Ftest%2Frun-pass%2Fissue-47722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47722.rs?ref=b5f8cd5c20977119eb600b05edf699a1bde92a2c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Tests that automatic coercions from &mut T to *mut T\n+// allow borrows of T to expire immediately - essentially, that\n+// they work identically to 'foo as *mut T'\n+#![feature(nll)]\n+\n+struct SelfReference {\n+    self_reference: *mut SelfReference,\n+}\n+\n+impl SelfReference {\n+    fn set_self_ref(&mut self) {\n+        self.self_reference = self;\n+    }\n+}\n+\n+fn main() {}"}]}