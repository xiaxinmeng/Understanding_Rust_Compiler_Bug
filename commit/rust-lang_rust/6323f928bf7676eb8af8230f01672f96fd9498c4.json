{"sha": "6323f928bf7676eb8af8230f01672f96fd9498c4", "node_id": "C_kwDOAAsO6NoAKDYzMjNmOTI4YmY3Njc2ZWI4YWY4MjMwZjAxNjcyZjk2ZmQ5NDk4YzQ", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-11-13T01:00:47Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-11-13T01:00:47Z"}, "message": "Remove bigint_helper_methods for *signed* types\n\nThese are working well for *unsigned* types, for the the signed ones there are a bunch of questions about what the semantics and API should be.  And for the main \"helpers for big integer implementations\" use, there's no need for the signed versions anyway.\n\nAnd there are plenty of other methods which exist for unsigned types but not signed ones, like `next_power_of_two`, so this isn't unusual.\n\nFixes 90541", "tree": {"sha": "133bc1c1320bf01c51bc5e046a930d3223d48a32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/133bc1c1320bf01c51bc5e046a930d3223d48a32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6323f928bf7676eb8af8230f01672f96fd9498c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6323f928bf7676eb8af8230f01672f96fd9498c4", "html_url": "https://github.com/rust-lang/rust/commit/6323f928bf7676eb8af8230f01672f96fd9498c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6323f928bf7676eb8af8230f01672f96fd9498c4/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a2fd640e0df9ee8cc1e04280b0c3aff93c42da", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a2fd640e0df9ee8cc1e04280b0c3aff93c42da", "html_url": "https://github.com/rust-lang/rust/commit/14a2fd640e0df9ee8cc1e04280b0c3aff93c42da"}], "stats": {"total": 69, "additions": 1, "deletions": 68}, "files": [{"sha": "9a668d34b62789afce1421fe03fe8d4928de201c", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6323f928bf7676eb8af8230f01672f96fd9498c4/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6323f928bf7676eb8af8230f01672f96fd9498c4/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=6323f928bf7676eb8af8230f01672f96fd9498c4", "patch": "@@ -1511,33 +1511,6 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates `self + rhs + carry` without the ability to overflow.\n-        ///\n-        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n-        /// additional bit of overflow. This allows for chaining together multiple additions\n-        /// to create \"big integers\" which represent larger values.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (\", stringify!($SelfT), \"::MIN, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (\", stringify!($SelfT), \"::MIN + 1, false));\")]\n-        /// ```\n-        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n-        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n-        #[must_use = \"this returns the result of the operation, \\\n-                      without modifying the original\"]\n-        #[inline]\n-        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n-            let (sum, carry) = (self as $UnsignedT).carrying_add(rhs as $UnsignedT, carry);\n-            (sum as $SelfT, carry)\n-        }\n-\n         /// Calculates `self` + `rhs` with an unsigned `rhs`\n         ///\n         /// Returns a tuple of the addition along with a boolean indicating\n@@ -1589,33 +1562,6 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates `self - rhs - borrow` without the ability to overflow.\n-        ///\n-        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n-        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n-        /// to create \"big integers\" which represent larger values.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, false));\")]\n-        /// ```\n-        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n-        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n-        #[must_use = \"this returns the result of the operation, \\\n-                      without modifying the original\"]\n-        #[inline]\n-        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n-            let (sum, borrow) = (self as $UnsignedT).borrowing_sub(rhs as $UnsignedT, borrow);\n-            (sum as $SelfT, borrow)\n-        }\n-\n         /// Calculates `self` - `rhs` with an unsigned `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating"}, {"sha": "a8f2ded46594ebb8560b54354c396fe39575ecd4", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6323f928bf7676eb8af8230f01672f96fd9498c4/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6323f928bf7676eb8af8230f01672f96fd9498c4/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=6323f928bf7676eb8af8230f01672f96fd9498c4", "patch": "@@ -95,12 +95,6 @@ depending on the target pointer size.\n \n macro_rules! widening_impl {\n     ($SelfT:ty, $WideT:ty, $BITS:literal, unsigned) => {\n-        widening_impl!($SelfT, $WideT, $BITS, \"\");\n-    };\n-    ($SelfT:ty, $WideT:ty, $BITS:literal, signed) => {\n-        widening_impl!($SelfT, $WideT, $BITS, \"# //\");\n-    };\n-    ($SelfT:ty, $WideT:ty, $BITS:literal, $AdaptiveTestPrefix:literal) => {\n         /// Calculates the complete product `self * rhs` without the possibility to overflow.\n         ///\n         /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n@@ -154,7 +148,7 @@ macro_rules! widening_impl {\n         /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n         /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n         /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n-        #[doc = concat!($AdaptiveTestPrefix, \"assert_eq!(\",\n+        #[doc = concat!(\"assert_eq!(\",\n             stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n             \"(0, \", stringify!($SelfT), \"::MAX));\"\n         )]\n@@ -203,22 +197,19 @@ macro_rules! widening_impl {\n impl i8 {\n     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n-    widening_impl! { i8, i16, 8, signed }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n     int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n-    widening_impl! { i16, i32, 16, signed }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n-    widening_impl! { i32, i64, 32, signed }\n }\n \n #[lang = \"i64\"]\n@@ -227,7 +218,6 @@ impl i64 {\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n-    widening_impl! { i64, i128, 64, signed }\n }\n \n #[lang = \"i128\"]\n@@ -248,7 +238,6 @@ impl isize {\n     int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n-    widening_impl! { isize, i32, 16, signed }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -258,7 +247,6 @@ impl isize {\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n-    widening_impl! { isize, i64, 32, signed }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n@@ -269,7 +257,6 @@ impl isize {\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n-    widening_impl! { isize, i128, 64, signed }\n }\n \n /// If 6th bit set ascii is upper case."}]}