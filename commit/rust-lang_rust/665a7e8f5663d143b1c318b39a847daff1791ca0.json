{"sha": "665a7e8f5663d143b1c318b39a847daff1791ca0", "node_id": "C_kwDOAAsO6NoAKDY2NWE3ZThmNTY2M2QxNDNiMWMzMThiMzlhODQ3ZGFmZjE3OTFjYTA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T14:15:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T14:15:37Z"}, "message": "remove some provenance-related machine hooks that Miri no longer needs", "tree": {"sha": "94f38b8526cbe68e7621408623e3d2e901334364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94f38b8526cbe68e7621408623e3d2e901334364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/665a7e8f5663d143b1c318b39a847daff1791ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/665a7e8f5663d143b1c318b39a847daff1791ca0", "html_url": "https://github.com/rust-lang/rust/commit/665a7e8f5663d143b1c318b39a847daff1791ca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/665a7e8f5663d143b1c318b39a847daff1791ca0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ba93596586783efd41df7b8ea84f4f1e37f923", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ba93596586783efd41df7b8ea84f4f1e37f923", "html_url": "https://github.com/rust-lang/rust/commit/47ba93596586783efd41df7b8ea84f4f1e37f923"}], "stats": {"total": 63, "additions": 17, "deletions": 46}, "files": [{"sha": "71ccd1799fa95b19d26a49587ca129575d100dca", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=665a7e8f5663d143b1c318b39a847daff1791ca0", "patch": "@@ -135,9 +135,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether to enforce integers and floats being initialized.\n     fn enforce_number_init(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether to enforce integers and floats not having provenance.\n-    fn enforce_number_no_provenance(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n-\n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         true\n@@ -300,13 +297,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>>;\n \n-    /// Hook for returning a pointer from a transmute-like operation on an addr.\n-    /// This is only needed to support Miri's (unsound) \"allow-ptr-int-transmute\" flag.\n-    fn ptr_from_addr_transmute(\n-        ecx: &InterpCx<'mir, 'tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<Self::Provenance>>;\n-\n     /// Marks a pointer as exposed, allowing it's provenance\n     /// to be recovered. \"Pointer-to-int cast\"\n     fn expose_ptr(\n@@ -469,11 +459,6 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         true\n     }\n \n-    #[inline(always)]\n-    fn enforce_number_no_provenance(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n-    }\n-\n     #[inline(always)]\n     fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         true\n@@ -518,14 +503,6 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         ptr\n     }\n \n-    #[inline(always)]\n-    fn ptr_from_addr_transmute(\n-        _ecx: &InterpCx<$mir, $tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<AllocId>> {\n-        Pointer::from_addr(addr)\n-    }\n-\n     #[inline(always)]\n     fn ptr_from_addr_cast(\n         _ecx: &InterpCx<$mir, $tcx, Self>,"}, {"sha": "e7208fcd79a8fdfc2d1609e817f671804369a47c", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=665a7e8f5663d143b1c318b39a847daff1791ca0", "patch": "@@ -1186,7 +1186,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Err(ptr) => ptr.into(),\n                 Ok(bits) => {\n                     let addr = u64::try_from(bits).unwrap();\n-                    M::ptr_from_addr_transmute(&self, addr)\n+                    Pointer::from_addr(addr)\n                 }\n             },\n         )"}, {"sha": "1d0d25c6cf5d530d0d65468f03525ed169f3ae58", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=665a7e8f5663d143b1c318b39a847daff1791ca0", "patch": "@@ -363,17 +363,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abi::Scalar(s) if force => Some(s.primitive()),\n             _ => None,\n         };\n-        let read_provenance = |s: abi::Primitive, size| {\n-            // Should be just `s.is_ptr()`, but we support a Miri flag that accepts more\n-            // questionable ptr-int transmutes.\n-            let number_may_have_provenance = !M::enforce_number_no_provenance(self);\n-            s.is_ptr() || (number_may_have_provenance && size == self.pointer_size())\n-        };\n         if let Some(s) = scalar_layout {\n             let size = s.size(self);\n             assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n-            let scalar =\n-                alloc.read_scalar(alloc_range(Size::ZERO, size), read_provenance(s, size))?;\n+            let scalar = alloc\n+                .read_scalar(alloc_range(Size::ZERO, size), /*read_provenance*/ s.is_ptr())?;\n             return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n         }\n         let scalar_pair_layout = match mplace.layout.abi {\n@@ -391,10 +385,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let (a_size, b_size) = (a.size(self), b.size(self));\n             let b_offset = a_size.align_to(b.align(self).abi);\n             assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n-            let a_val =\n-                alloc.read_scalar(alloc_range(Size::ZERO, a_size), read_provenance(a, a_size))?;\n-            let b_val =\n-                alloc.read_scalar(alloc_range(b_offset, b_size), read_provenance(b, b_size))?;\n+            let a_val = alloc.read_scalar(\n+                alloc_range(Size::ZERO, a_size),\n+                /*read_provenance*/ a.is_ptr(),\n+            )?;\n+            let b_val = alloc\n+                .read_scalar(alloc_range(b_offset, b_size), /*read_provenance*/ b.is_ptr())?;\n             return Ok(Some(ImmTy {\n                 imm: Immediate::ScalarPair(a_val, b_val),\n                 layout: mplace.layout,"}, {"sha": "acc663198e5b6e652d665d50b1d8341bcaadc670", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/665a7e8f5663d143b1c318b39a847daff1791ca0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=665a7e8f5663d143b1c318b39a847daff1791ca0", "patch": "@@ -517,15 +517,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             { \"{:x}\", value } expected { \"initialized bytes\" }\n                     );\n                 }\n-                if M::enforce_number_no_provenance(self.ecx) {\n-                    // As a special exception we *do* match on a `Scalar` here, since we truly want\n-                    // to know its underlying representation (and *not* cast it to an integer).\n-                    let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n-                    if is_ptr {\n-                        throw_validation_failure!(self.path,\n-                            { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n-                        )\n-                    }\n+                // As a special exception we *do* match on a `Scalar` here, since we truly want\n+                // to know its underlying representation (and *not* cast it to an integer).\n+                let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n+                if is_ptr {\n+                    throw_validation_failure!(self.path,\n+                        { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n+                    )\n                 }\n                 Ok(true)\n             }\n@@ -906,7 +904,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 match alloc.check_bytes(\n                     alloc_range(Size::ZERO, size),\n                     /*allow_uninit*/ !M::enforce_number_init(self.ecx),\n-                    /*allow_ptr*/ !M::enforce_number_no_provenance(self.ecx),\n+                    /*allow_ptr*/ false,\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}"}]}