{"sha": "5fae56971d8487088c0099c82c0a5ce1638b5f62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYWU1Njk3MWQ4NDg3MDg4YzAwOTljODJjMGE1Y2UxNjM4YjVmNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-16T06:46:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-16T06:46:24Z"}, "message": "Auto merge of #76781 - RalfJung:rollup-ve66o2j, r=RalfJung\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #76056 (Add more info for Vec Drain doc)\n - #76062 (Vec slice example fix style and show type elision)\n - #76262 (Use inline(never) instead of cold)\n - #76335 (Make all methods of `Duration` unstably const)\n - #76366 (Add Arith Tests in Library)\n - #76369 (Move Various str tests in library)\n - #76534 (Add doc comments for From impls)\n - #76622 (Update bootstrap readme)\n - #76641 (Some cleanup changes and commenting)\n - #76662 (Fix liballoc test suite for Miri)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "6772919f40c26a12b7a08f55355355322592a3aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6772919f40c26a12b7a08f55355355322592a3aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62", "html_url": "https://github.com/rust-lang/rust/commit/5fae56971d8487088c0099c82c0a5ce1638b5f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e11660d1e6f227aa683e097b542ab038deef658", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e11660d1e6f227aa683e097b542ab038deef658", "html_url": "https://github.com/rust-lang/rust/commit/1e11660d1e6f227aa683e097b542ab038deef658"}, {"sha": "9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "html_url": "https://github.com/rust-lang/rust/commit/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35"}], "stats": {"total": 566, "additions": 292, "deletions": 274}, "files": [{"sha": "825221c22a8c100e5213ef490800cd84d62971fc", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -2280,6 +2280,12 @@ impl<'tcx> TyS<'tcx> {\n     ///\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n+    ///\n+    /// Note that we could never rely on the fact that a type such as `[_]` is\n+    /// trivially `!Sized` because we could be in a type environment with a\n+    /// bound such as `[_]: Copy`. A function with such a bound obviously never\n+    /// can be called, but that doesn't mean it shouldn't typecheck. This is why\n+    /// this method doesn't return `Option<bool>`.\n     pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))"}, {"sha": "bda4351b2f2d8437623583a2d208eae41526a296", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1512,12 +1512,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // avoid inundating the user with unnecessary errors, but we now\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n-                if self\n-                    .tcx\n-                    .lang_items()\n-                    .sized_trait()\n-                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                {\n+                if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n                     self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n                     return;\n                 }"}, {"sha": "2fad54013ad5bebc5d836fb7963b129f98f8658d", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -110,25 +110,15 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .map(|i| chalk_ir::AssocTypeId(i.def_id))\n             .collect();\n \n-        let well_known = if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .sized_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        let well_known = if self.interner.tcx.lang_items().sized_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n-        } else if self.interner.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false)\n-        {\n+        } else if self.interner.tcx.lang_items().copy_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n-        } else if self.interner.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false)\n-        {\n+        } else if self.interner.tcx.lang_items().clone_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n-        } else if self.interner.tcx.lang_items().drop_trait().map(|t| def_id == t).unwrap_or(false)\n-        {\n+        } else if self.interner.tcx.lang_items().drop_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n-        } else if self.interner.tcx.lang_items().fn_trait().map(|t| def_id == t).unwrap_or(false) {\n+        } else if self.interner.tcx.lang_items().fn_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n         } else if self\n             .interner"}, {"sha": "24d17fdd880ba8bc9585f93ce7c4e08dbaf7b59e", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1343,6 +1343,10 @@ impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T> From<BinaryHeap<T>> for Vec<T> {\n+    /// Converts a `BinaryHeap<T>` into a `Vec<T>`.\n+    ///\n+    /// This conversion requires no data movement or allocation, and has\n+    /// constant time complexity.\n     fn from(heap: BinaryHeap<T>) -> Vec<T> {\n         heap.data\n     }"}, {"sha": "65cfe9a9b49965c3b1576952c64f977c312b0ca4", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1089,11 +1089,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        // SAFETY: This buffer is only used to check the range. It might be partially\n-        // uninitialized, but `check_range` needs a contiguous slice.\n-        // https://github.com/rust-lang/rust/pull/75207#discussion_r471193682\n-        let buffer = unsafe { slice::from_raw_parts(self.ptr(), self.len()) };\n-        let Range { start, end } = buffer.check_range(range);\n+        let Range { start, end } = slice::check_range(self.len(), range);\n         let tail = self.wrap_add(self.tail, start);\n         let head = self.wrap_add(self.tail, end);\n         (tail, head)"}, {"sha": "55afdd94f4468ebc4403812291211b102d0b510e", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -91,6 +91,8 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n+pub use core::slice::check_range;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub use core::slice::ArrayChunks;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]"}, {"sha": "2b0ce5ede56308b1a907def495bc12d5215b0d27", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -49,6 +49,7 @@ use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n+use core::slice;\n use core::str::{lossy, pattern::Pattern};\n \n use crate::borrow::{Cow, ToOwned};\n@@ -1506,7 +1507,7 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let Range { start, end } = self.as_bytes().check_range(range);\n+        let Range { start, end } = slice::check_range(self.len(), range);\n         assert!(self.is_char_boundary(start));\n         assert!(self.is_char_boundary(end));\n "}, {"sha": "9dbea0dc9e68b9296d8d2dbdaebdb48635cb07d4", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -174,7 +174,9 @@ use crate::raw_vec::RawVec;\n ///\n /// // ... and that's all!\n /// // you can also do it like this:\n-/// let x : &[usize] = &v;\n+/// let u: &[usize] = &v;\n+/// // or like this:\n+/// let u: &[_] = &v;\n /// ```\n ///\n /// In Rust, it's more common to pass slices as arguments rather than vectors\n@@ -1310,7 +1312,7 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let Range { start, end } = self.check_range(range);\n+        let Range { start, end } = slice::check_range(len, range);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked\n@@ -3037,6 +3039,7 @@ impl<T> AsIntoIter for IntoIter<T> {\n /// A draining iterator for `Vec<T>`.\n ///\n /// This `struct` is created by [`Vec::drain`].\n+/// See its documentation for more.\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve"}, {"sha": "ed8ee2d8823c022449bdbf27caf8b4269fc140df", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1921,3 +1921,24 @@ fn different_str_pattern_forwarding_lifetimes() {\n \n     foo::<&str>(\"x\");\n }\n+\n+#[test]\n+fn test_str_multiline() {\n+    let a: String = \"this \\\n+is a test\"\n+        .to_string();\n+    let b: String = \"this \\\n+              is \\\n+              another \\\n+              test\"\n+        .to_string();\n+    assert_eq!(a, \"this is a test\".to_string());\n+    assert_eq!(b, \"this is another test\".to_string());\n+}\n+\n+#[test]\n+fn test_str_escapes() {\n+    let x = \"\\\\\\\\\\\n+    \";\n+    assert_eq!(x, r\"\\\\\"); // extraneous whitespace stripped\n+}"}, {"sha": "368ca4c543219a50d0d8e8a601185eeea7d4c5da", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -919,7 +919,7 @@ fn test_from_iter_partially_drained_in_place_specialization() {\n #[test]\n fn test_from_iter_specialization_with_iterator_adapters() {\n     fn assert_in_place_trait<T: InPlaceIterable>(_: &T) {};\n-    let src: Vec<usize> = vec![0usize; 65535];\n+    let src: Vec<usize> = vec![0usize; 256];\n     let srcptr = src.as_ptr();\n     let iter = src\n         .into_iter()"}, {"sha": "16fcb6231dc0981834e67af5d2a769f21421e746", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1,6 +1,6 @@\n //! Indexing implementations for `[T]`.\n \n-use crate::ops;\n+use crate::ops::{self, Bound, Range, RangeBounds};\n use crate::ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -62,6 +62,79 @@ pub(super) fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n \n+/// Performs bounds-checking of the given range.\n+/// The returned [`Range`] is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`]\n+/// for slices of the given length.\n+///\n+/// [`get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n+/// [`get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n+///\n+/// # Panics\n+///\n+/// Panics if the range is out of bounds.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(slice_check_range)]\n+/// use std::slice;\n+///\n+/// let v = [10, 40, 30];\n+/// assert_eq!(1..2, slice::check_range(v.len(), 1..2));\n+/// assert_eq!(0..2, slice::check_range(v.len(), ..2));\n+/// assert_eq!(1..3, slice::check_range(v.len(), 1..));\n+/// ```\n+///\n+/// Panics when [`Index::index`] would panic:\n+///\n+/// ```should_panic\n+/// #![feature(slice_check_range)]\n+///\n+/// std::slice::check_range(3, 2..1);\n+/// ```\n+///\n+/// ```should_panic\n+/// #![feature(slice_check_range)]\n+///\n+/// std::slice::check_range(3, 1..4);\n+/// ```\n+///\n+/// ```should_panic\n+/// #![feature(slice_check_range)]\n+///\n+/// std::slice::check_range(3, 1..=usize::MAX);\n+/// ```\n+///\n+/// [`Index::index`]: ops::Index::index\n+#[track_caller]\n+#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n+pub fn check_range<R: RangeBounds<usize>>(len: usize, range: R) -> Range<usize> {\n+    let start = match range.start_bound() {\n+        Bound::Included(&start) => start,\n+        Bound::Excluded(start) => {\n+            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+        }\n+        Bound::Unbounded => 0,\n+    };\n+\n+    let end = match range.end_bound() {\n+        Bound::Included(end) => {\n+            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+        }\n+        Bound::Excluded(&end) => end,\n+        Bound::Unbounded => len,\n+    };\n+\n+    if start > end {\n+        slice_index_order_fail(start, end);\n+    }\n+    if end > len {\n+        slice_end_index_len_fail(end, len);\n+    }\n+\n+    Range { start, end }\n+}\n+\n mod private_slice_index {\n     use super::ops;\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]"}, {"sha": "ba3185433c8d86639a019cd0f2ad9f46fb4869c5", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -12,7 +12,7 @@ use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics::assume;\n use crate::marker::{self, Copy};\n use crate::mem;\n-use crate::ops::{Bound, FnMut, Range, RangeBounds};\n+use crate::ops::{FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr::{self, NonNull};\n@@ -72,8 +72,8 @@ pub use sort::heapsort;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use index::SliceIndex;\n \n-use index::{slice_end_index_len_fail, slice_index_order_fail};\n-use index::{slice_end_index_overflow_fail, slice_start_index_overflow_fail};\n+#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n+pub use index::check_range;\n \n #[lang = \"slice\"]\n #[cfg(not(test))]\n@@ -378,79 +378,6 @@ impl<T> [T] {\n         unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n-    /// Converts a range over this slice to [`Range`].\n-    ///\n-    /// The returned range is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`].\n-    ///\n-    /// [`get_unchecked`]: #method.get_unchecked\n-    /// [`get_unchecked_mut`]: #method.get_unchecked_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the range is out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(1..2, v.check_range(1..2));\n-    /// assert_eq!(0..2, v.check_range(..2));\n-    /// assert_eq!(1..3, v.check_range(1..));\n-    /// ```\n-    ///\n-    /// Panics when [`Index::index`] would panic:\n-    ///\n-    /// ```should_panic\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// [10, 40, 30].check_range(2..1);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// [10, 40, 30].check_range(1..4);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// [10, 40, 30].check_range(1..=usize::MAX);\n-    /// ```\n-    ///\n-    /// [`Index::index`]: crate::ops::Index::index\n-    #[track_caller]\n-    #[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n-    pub fn check_range<R: RangeBounds<usize>>(&self, range: R) -> Range<usize> {\n-        let start = match range.start_bound() {\n-            Bound::Included(&start) => start,\n-            Bound::Excluded(start) => {\n-                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n-            }\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let len = self.len();\n-        let end = match range.end_bound() {\n-            Bound::Included(end) => {\n-                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n-            }\n-            Bound::Excluded(&end) => end,\n-            Bound::Unbounded => len,\n-        };\n-\n-        if start > end {\n-            slice_index_order_fail(start, end);\n-        }\n-        if end > len {\n-            slice_end_index_len_fail(end, len);\n-        }\n-\n-        Range { start, end }\n-    }\n-\n     /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n@@ -2794,7 +2721,7 @@ impl<T> [T] {\n     where\n         T: Copy,\n     {\n-        let Range { start: src_start, end: src_end } = self.check_range(src);\n+        let Range { start: src_start, end: src_end } = check_range(self.len(), src);\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         // SAFETY: the conditions for `ptr::copy` have all been checked above,"}, {"sha": "4e987a53b2cb236f12fd3618c80c579431bc56b5", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -112,6 +112,14 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T> From<T> for Poll<T> {\n+    /// Convert to a `Ready` variant.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use core::task::Poll;\n+    /// assert_eq!(Poll::from(true), Poll::Ready(true));\n+    /// ```\n     fn from(t: T) -> Poll<T> {\n         Poll::Ready(t)\n     }"}, {"sha": "6dc542dee58e65ff280a4c0b343aaea322457413", "filename": "library/core/src/time.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -693,7 +693,8 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n-    pub fn from_secs_f64(secs: f64) -> Duration {\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn from_secs_f64(secs: f64) -> Duration {\n         const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n         let nanos = secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n@@ -727,7 +728,8 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n-    pub fn from_secs_f32(secs: f32) -> Duration {\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn from_secs_f32(secs: f32) -> Duration {\n         const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n         let nanos = secs * (NANOS_PER_SEC as f32);\n         if !nanos.is_finite() {\n@@ -761,7 +763,8 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n-    pub fn mul_f64(self, rhs: f64) -> Duration {\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn mul_f64(self, rhs: f64) -> Duration {\n         Duration::from_secs_f64(rhs * self.as_secs_f64())\n     }\n \n@@ -782,7 +785,8 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n-    pub fn mul_f32(self, rhs: f32) -> Duration {\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn mul_f32(self, rhs: f32) -> Duration {\n         Duration::from_secs_f32(rhs * self.as_secs_f32())\n     }\n \n@@ -802,7 +806,8 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n-    pub fn div_f64(self, rhs: f64) -> Duration {\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn div_f64(self, rhs: f64) -> Duration {\n         Duration::from_secs_f64(self.as_secs_f64() / rhs)\n     }\n \n@@ -824,7 +829,8 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n-    pub fn div_f32(self, rhs: f32) -> Duration {\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn div_f32(self, rhs: f32) -> Duration {\n         Duration::from_secs_f32(self.as_secs_f32() / rhs)\n     }\n "}, {"sha": "04402117f7da6279c6a7ccf40423494bb52e0543", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -10,8 +10,11 @@\n #![feature(core_private_diy_float)]\n #![feature(debug_non_exhaustive)]\n #![feature(dec2flt)]\n+#![feature(div_duration)]\n+#![feature(duration_consts_2)]\n #![feature(duration_constants)]\n #![feature(duration_saturating_ops)]\n+#![feature(duration_zero)]\n #![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]"}, {"sha": "4acc760ffac9907e0d22509c140a679a82009572", "filename": "library/core/tests/num/i32.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Ftests%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Ftests%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi32.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1 +1,30 @@\n int_module!(i32, i32);\n+\n+#[test]\n+fn test_arith_operation() {\n+    let a: isize = 10;\n+    assert_eq!(a * (a - 1), 90);\n+    let i32_a: isize = 10;\n+    assert_eq!(i32_a, 10);\n+    assert_eq!(i32_a - 10, 0);\n+    assert_eq!(i32_a / 10, 1);\n+    assert_eq!(i32_a - 20, -10);\n+    assert_eq!(i32_a << 10, 10240);\n+    assert_eq!(i32_a << 16, 655360);\n+    assert_eq!(i32_a * 16, 160);\n+    assert_eq!(i32_a * i32_a * i32_a, 1000);\n+    assert_eq!(i32_a * i32_a * i32_a * i32_a, 10000);\n+    assert_eq!(i32_a * i32_a / i32_a * i32_a, 100);\n+    assert_eq!(i32_a * (i32_a - 1) << (2 + i32_a as usize), 368640);\n+    let i32_b: isize = 0x10101010;\n+    assert_eq!(i32_b + 1 - 1, i32_b);\n+    assert_eq!(i32_b << 1, i32_b << 1);\n+    assert_eq!(i32_b >> 1, i32_b >> 1);\n+    assert_eq!(i32_b & i32_b << 1, 0);\n+    assert_eq!(i32_b | i32_b << 1, 0x30303030);\n+    let i32_c: isize = 0x10101010;\n+    assert_eq!(\n+        i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3),\n+        i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3)\n+    );\n+}"}, {"sha": "7c43885040b3e3fde6fdad5eca2dca12eb6d2189", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -321,3 +321,104 @@ fn debug_formatting_precision_high() {\n     assert_eq!(format!(\"{:.10?}\", Duration::new(4, 001_000_000)), \"4.0010000000s\");\n     assert_eq!(format!(\"{:.20?}\", Duration::new(4, 001_000_000)), \"4.00100000000000000000s\");\n }\n+\n+#[test]\n+fn duration_const() {\n+    // test that the methods of `Duration` are usable in a const context\n+\n+    const DURATION: Duration = Duration::new(0, 123_456_789);\n+\n+    const SUB_SEC_MILLIS: u32 = DURATION.subsec_millis();\n+    assert_eq!(SUB_SEC_MILLIS, 123);\n+\n+    const SUB_SEC_MICROS: u32 = DURATION.subsec_micros();\n+    assert_eq!(SUB_SEC_MICROS, 123_456);\n+\n+    const SUB_SEC_NANOS: u32 = DURATION.subsec_nanos();\n+    assert_eq!(SUB_SEC_NANOS, 123_456_789);\n+\n+    const ZERO: Duration = Duration::zero();\n+    assert_eq!(ZERO, Duration::new(0, 0));\n+\n+    const IS_ZERO: bool = ZERO.is_zero();\n+    assert!(IS_ZERO);\n+\n+    const ONE: Duration = Duration::new(1, 0);\n+\n+    const SECONDS: u64 = ONE.as_secs();\n+    assert_eq!(SECONDS, 1);\n+\n+    const FROM_SECONDS: Duration = Duration::from_secs(1);\n+    assert_eq!(FROM_SECONDS, ONE);\n+\n+    const SECONDS_F32: f32 = ONE.as_secs_f32();\n+    assert_eq!(SECONDS_F32, 1.0);\n+\n+    const FROM_SECONDS_F32: Duration = Duration::from_secs_f32(1.0);\n+    assert_eq!(FROM_SECONDS_F32, ONE);\n+\n+    const SECONDS_F64: f64 = ONE.as_secs_f64();\n+    assert_eq!(SECONDS_F64, 1.0);\n+\n+    const FROM_SECONDS_F64: Duration = Duration::from_secs_f64(1.0);\n+    assert_eq!(FROM_SECONDS_F64, ONE);\n+\n+    const MILLIS: u128 = ONE.as_millis();\n+    assert_eq!(MILLIS, 1_000);\n+\n+    const FROM_MILLIS: Duration = Duration::from_millis(1_000);\n+    assert_eq!(FROM_MILLIS, ONE);\n+\n+    const MICROS: u128 = ONE.as_micros();\n+    assert_eq!(MICROS, 1_000_000);\n+\n+    const FROM_MICROS: Duration = Duration::from_micros(1_000_000);\n+    assert_eq!(FROM_MICROS, ONE);\n+\n+    const NANOS: u128 = ONE.as_nanos();\n+    assert_eq!(NANOS, 1_000_000_000);\n+\n+    const FROM_NANOS: Duration = Duration::from_nanos(1_000_000_000);\n+    assert_eq!(FROM_NANOS, ONE);\n+\n+    const MAX: Duration = Duration::new(u64::MAX, 999_999_999);\n+\n+    const CHECKED_ADD: Option<Duration> = MAX.checked_add(ONE);\n+    assert_eq!(CHECKED_ADD, None);\n+\n+    const CHECKED_SUB: Option<Duration> = ZERO.checked_sub(ONE);\n+    assert_eq!(CHECKED_SUB, None);\n+\n+    const CHECKED_MUL: Option<Duration> = ONE.checked_mul(1);\n+    assert_eq!(CHECKED_MUL, Some(ONE));\n+\n+    const MUL_F32: Duration = ONE.mul_f32(1.0);\n+    assert_eq!(MUL_F32, ONE);\n+\n+    const MUL_F64: Duration = ONE.mul_f64(1.0);\n+    assert_eq!(MUL_F64, ONE);\n+\n+    const CHECKED_DIV: Option<Duration> = ONE.checked_div(1);\n+    assert_eq!(CHECKED_DIV, Some(ONE));\n+\n+    const DIV_F32: Duration = ONE.div_f32(1.0);\n+    assert_eq!(DIV_F32, ONE);\n+\n+    const DIV_F64: Duration = ONE.div_f64(1.0);\n+    assert_eq!(DIV_F64, ONE);\n+\n+    const DIV_DURATION_F32: f32 = ONE.div_duration_f32(ONE);\n+    assert_eq!(DIV_DURATION_F32, 1.0);\n+\n+    const DIV_DURATION_F64: f64 = ONE.div_duration_f64(ONE);\n+    assert_eq!(DIV_DURATION_F64, 1.0);\n+\n+    const SATURATING_ADD: Duration = MAX.saturating_add(ONE);\n+    assert_eq!(SATURATING_ADD, MAX);\n+\n+    const SATURATING_SUB: Duration = ZERO.saturating_sub(ONE);\n+    assert_eq!(SATURATING_SUB, ZERO);\n+\n+    const SATURATING_MUL: Duration = MAX.saturating_mul(2);\n+    assert_eq!(SATURATING_MUL, MAX);\n+}"}, {"sha": "60a05dc5d545b74ea168a0a3c9d2b54251ead303", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -424,10 +424,9 @@ pub mod fast {\n         // thread_local's, or it is being recursively initialized.\n         //\n         // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n-        // be performed for every call to `Key::get`. The #[cold] hint makes\n-        // that less likely.\n+        // be performed for every call to `Key::get`.\n         // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-        #[cold]\n+        #[inline(never)]\n         unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n             if !mem::needs_drop::<T>() || self.try_register_dtor() {\n                 Some(self.inner.initialize(init))"}, {"sha": "a69bd1cc3bc530f3d7f230d8232cfa2c51cd9837", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -26,10 +26,10 @@ The script accepts commands, flags, and arguments to determine what to do:\n \n   ```\n   # build the whole compiler\n-  ./x.py build\n+  ./x.py build --stage 2\n \n   # build the stage1 compiler\n-  ./x.py build --stage 1\n+  ./x.py build\n \n   # build stage0 libstd\n   ./x.py build --stage 0 library/std\n@@ -43,8 +43,8 @@ The script accepts commands, flags, and arguments to determine what to do:\n   that belong to stage n or earlier:\n \n   ```\n-  # keep old build products for stage 0 and build stage 1\n-  ./x.py build --keep-stage 0 --stage 1\n+  # build stage 1, keeping old build products for stage 0\n+  ./x.py build --keep-stage 0\n   ```\n \n * `test` - a command for executing unit tests. Like the `build` command this\n@@ -123,24 +123,8 @@ that (b) leverage Rust as much as possible!\n \n ## Incremental builds\n \n-You can configure rustbuild to use incremental compilation. Because\n-incremental is new and evolving rapidly, if you want to use it, it is\n-recommended that you replace the snapshot with a locally installed\n-nightly build of rustc. You will want to keep this up to date.\n-\n-To follow this course of action, first thing you will want to do is to\n-install a nightly, presumably using `rustup`. You will then want to\n-configure your directory to use this build, like so:\n-\n-```sh\n-# configure to use local rust instead of downloading a beta.\n-# `--local-rust-root` is optional here. If elided, we will\n-# use whatever rustc we find on your PATH.\n-$ ./configure --local-rust-root=~/.cargo/ --enable-local-rebuild\n-```\n-\n-After that, you can use the `--incremental` flag to actually do\n-incremental builds:\n+You can configure rustbuild to use incremental compilation with the\n+`--incremental` flag:\n \n ```sh\n $ ./x.py build --incremental\n@@ -150,9 +134,7 @@ The `--incremental` flag will store incremental compilation artifacts\n in `build/<host>/stage0-incremental`. Note that we only use incremental\n compilation for the stage0 -> stage1 compilation -- this is because\n the stage1 compiler is changing, and we don't try to cache and reuse\n-incremental artifacts across different versions of the compiler. For\n-this reason, `--incremental` defaults to `--stage 1` (though you can\n-manually select a higher stage, if you prefer).\n+incremental artifacts across different versions of the compiler.\n \n You can always drop the `--incremental` to build as normal (but you\n will still be using the local nightly as your bootstrap).\n@@ -331,8 +313,8 @@ are:\n   `Config` struct.\n * Adding a sanity check? Take a look at `bootstrap/sanity.rs`.\n \n-If you have any questions feel free to reach out on `#infra` channel in the\n-[Rust Discord server][rust-discord] or ask on internals.rust-lang.org. When\n+If you have any questions feel free to reach out on the `#t-infra` channel in\n+the [Rust Zulip server][rust-zulip] or ask on internals.rust-lang.org. When\n you encounter bugs, please file issues on the rust-lang/rust issue tracker.\n \n-[rust-discord]: https://discord.gg/rust-lang\n+[rust-zulip]: https://rust-lang.zulipchat.com/#narrow/stream/242791-t-infra"}, {"sha": "46ba14aa67e60d7fb35ffd59ce961ec71d569451", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -840,7 +840,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n         let mut where_predicates =\n             where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n \n-        // Type parameters and have a Sized bound by default unless removed with\n+        // Type parameters have a Sized bound by default unless removed with\n         // ?Sized. Scan through the predicates and mark any type parameter with\n         // a Sized bound, removing the bounds as we find them.\n         //"}, {"sha": "bc0969e4f1fbadfb9454ab2b0c6855be6b94b5f9", "filename": "src/test/ui/consts/duration-consts-2.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fconsts%2Fduration-consts-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fconsts%2Fduration-consts-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fduration-consts-2.rs?ref=1e11660d1e6f227aa683e097b542ab038deef658", "patch": "@@ -1,67 +0,0 @@\n-// run-pass\n-\n-#![feature(const_panic)]\n-#![feature(duration_consts_2)]\n-#![feature(div_duration)]\n-#![feature(duration_saturating_ops)]\n-\n-use std::time::Duration;\n-\n-fn duration() {\n-    const ZERO : Duration = Duration::new(0, 0);\n-    assert_eq!(ZERO, Duration::from_secs(0));\n-\n-    const ONE : Duration = Duration::new(0, 1);\n-    assert_eq!(ONE, Duration::from_nanos(1));\n-\n-    const MAX : Duration = Duration::new(u64::MAX, 1_000_000_000 - 1);\n-\n-    const MAX_CHECKED_ADD_ZERO : Option<Duration> = MAX.checked_add(ZERO);\n-    assert_eq!(MAX_CHECKED_ADD_ZERO, Some(MAX));\n-\n-    const MAX_CHECKED_ADD_ONE : Option<Duration> = MAX.checked_add(ONE);\n-    assert_eq!(MAX_CHECKED_ADD_ONE, None);\n-\n-    const ONE_CHECKED_SUB_ONE : Option<Duration> = ONE.checked_sub(ONE);\n-    assert_eq!(ONE_CHECKED_SUB_ONE, Some(ZERO));\n-\n-    const ZERO_CHECKED_SUB_ONE : Option<Duration> = ZERO.checked_sub(ONE);\n-    assert_eq!(ZERO_CHECKED_SUB_ONE, None);\n-\n-    const ONE_CHECKED_MUL_ONE : Option<Duration> = ONE.checked_mul(1);\n-    assert_eq!(ONE_CHECKED_MUL_ONE, Some(ONE));\n-\n-    const MAX_CHECKED_MUL_TWO : Option<Duration> = MAX.checked_mul(2);\n-    assert_eq!(MAX_CHECKED_MUL_TWO, None);\n-\n-    const ONE_CHECKED_DIV_ONE : Option<Duration> = ONE.checked_div(1);\n-    assert_eq!(ONE_CHECKED_DIV_ONE, Some(ONE));\n-\n-    const ONE_CHECKED_DIV_ZERO : Option<Duration> = ONE.checked_div(0);\n-    assert_eq!(ONE_CHECKED_DIV_ZERO, None);\n-\n-    const MAX_AS_F32 : f32 = MAX.as_secs_f32();\n-    assert_eq!(MAX_AS_F32, 18446744000000000000.0_f32);\n-\n-    const MAX_AS_F64 : f64 = MAX.as_secs_f64();\n-    assert_eq!(MAX_AS_F64, 18446744073709552000.0_f64);\n-\n-    const ONE_AS_F32 : f32 = ONE.div_duration_f32(ONE);\n-    assert_eq!(ONE_AS_F32, 1.0_f32);\n-\n-    const ONE_AS_F64 : f64 = ONE.div_duration_f64(ONE);\n-    assert_eq!(ONE_AS_F64, 1.0_f64);\n-\n-    const MAX_SATURATING_ADD_ONE : Duration = MAX.saturating_add(ONE);\n-    assert_eq!(MAX_SATURATING_ADD_ONE, MAX);\n-\n-    const ZERO_SATURATING_SUB_ONE : Duration = ZERO.saturating_sub(ONE);\n-    assert_eq!(ZERO_SATURATING_SUB_ONE, ZERO);\n-\n-    const MAX_SATURATING_MUL_TWO : Duration = MAX.saturating_mul(2);\n-    assert_eq!(MAX_SATURATING_MUL_TWO, MAX);\n-}\n-\n-fn main() {\n-    duration();\n-}"}, {"sha": "7943cb908d1f1f4a10aa7447d8a76991ed409d4d", "filename": "src/test/ui/numbers-arithmetic/arith-0.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-0.rs?ref=1e11660d1e6f227aa683e097b542ab038deef658", "patch": "@@ -1,8 +0,0 @@\n-// run-pass\n-\n-\n-pub fn main() {\n-    let a: isize = 10;\n-    println!(\"{}\", a);\n-    assert_eq!(a * (a - 1), 90);\n-}"}, {"sha": "c13c8d8b7659d4761bfd8687c658a3cb5da49f8b", "filename": "src/test/ui/numbers-arithmetic/arith-1.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-1.rs?ref=1e11660d1e6f227aa683e097b542ab038deef658", "patch": "@@ -1,24 +0,0 @@\n-// run-pass\n-\n-\n-pub fn main() {\n-    let i32_a: isize = 10;\n-    assert_eq!(i32_a, 10);\n-    assert_eq!(i32_a - 10, 0);\n-    assert_eq!(i32_a / 10, 1);\n-    assert_eq!(i32_a - 20, -10);\n-    assert_eq!(i32_a << 10, 10240);\n-    assert_eq!(i32_a << 16, 655360);\n-    assert_eq!(i32_a * 16, 160);\n-    assert_eq!(i32_a * i32_a * i32_a, 1000);\n-    assert_eq!(i32_a * i32_a * i32_a * i32_a, 10000);\n-    assert_eq!(i32_a * i32_a / i32_a * i32_a, 100);\n-    assert_eq!(i32_a * (i32_a - 1) << (2 + i32_a as usize), 368640);\n-    let i32_b: isize = 0x10101010;\n-    assert_eq!(i32_b + 1 - 1, i32_b);\n-    assert_eq!(i32_b << 1, i32_b << 1);\n-    assert_eq!(i32_b >> 1, i32_b >> 1);\n-    assert_eq!(i32_b & i32_b << 1, 0);\n-    println!(\"{}\", i32_b | i32_b << 1);\n-    assert_eq!(i32_b | i32_b << 1, 0x30303030);\n-}"}, {"sha": "46c280677ce84836e18a17fdff8dffe6343c962c", "filename": "src/test/ui/numbers-arithmetic/arith-2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Farith-2.rs?ref=1e11660d1e6f227aa683e097b542ab038deef658", "patch": "@@ -1,9 +0,0 @@\n-// run-pass\n-\n-\n-\n-pub fn main() {\n-    let i32_c: isize = 0x10101010;\n-    assert_eq!(i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3),\n-                 i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3));\n-}"}, {"sha": "2b2e001d8bb7fa85e59eccbb61b2df3de22ee46a", "filename": "src/test/ui/str-multiline.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fstr-multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fstr-multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr-multiline.rs?ref=1e11660d1e6f227aa683e097b542ab038deef658", "patch": "@@ -1,13 +0,0 @@\n-// run-pass\n-\n-pub fn main() {\n-    let a: String = \"this \\\n-is a test\".to_string();\n-    let b: String =\n-        \"this \\\n-              is \\\n-              another \\\n-              test\".to_string();\n-    assert_eq!(a, \"this is a test\".to_string());\n-    assert_eq!(b, \"this is another test\".to_string());\n-}"}, {"sha": "cee5e27786cae29a70fff8d8831adfa02b94180e", "filename": "src/test/ui/string-escapes.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fstring-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e11660d1e6f227aa683e097b542ab038deef658/src%2Ftest%2Fui%2Fstring-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstring-escapes.rs?ref=1e11660d1e6f227aa683e097b542ab038deef658", "patch": "@@ -1,7 +0,0 @@\n-// run-pass\n-\n-fn main() {\n-    let x = \"\\\\\\\\\\\n-    \";\n-    assert_eq!(x, r\"\\\\\"); // extraneous whitespace stripped\n-}"}]}