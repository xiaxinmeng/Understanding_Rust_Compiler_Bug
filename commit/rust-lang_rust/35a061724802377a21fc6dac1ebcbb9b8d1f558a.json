{"sha": "35a061724802377a21fc6dac1ebcbb9b8d1f558a", "node_id": "C_kwDOAAsO6NoAKDM1YTA2MTcyNDgwMjM3N2EyMWZjNmRhYzFlYmNiYjliOGQxZjU1OGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T06:46:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T06:46:46Z"}, "message": "Auto merge of #98674 - RalfJung:miri-stacktrace-pruning, r=Mark-Simulacrum\n\nmiri: prune some atomic operation and raw pointer details from stacktrace\n\nSince Miri removes `track_caller` frames from the stacktrace, adding that attribute can help make backtraces more readable (similar to how it makes panic locations better). I made them only show up with `cfg(miri)` to make sure the extra arguments induced by `track_caller` do not cause any runtime performance trouble.\n\nThis is also testing the waters for whether the libs team is okay with having these attributes in their code, or whether you'd prefer if we find some other way to do this. If you are fine with this, we will probably want to add it to a lot more functions (all the other atomic operations, to start).\n\nBefore:\n```\nerror: Undefined Behavior: Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at alloc1727 (current vector clock = VClock([9, 0, 6]), conflicting timestamp = VClock([0, 6]))\n    --> /home/r/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:2594:23\n     |\n2594 |             SeqCst => intrinsics::atomic_load_seqcst(dst),\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at alloc1727 (current vector clock = VClock([9, 0, 6]), conflicting timestamp = VClock([0, 6]))\n     |\n     = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n     = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n\n     = note: inside `std::sync::atomic::atomic_load::<usize>` at /home/r/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:2594:23\n     = note: inside `std::sync::atomic::AtomicUsize::load` at /home/r/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:1719:26\nnote: inside closure at ../miri/tests/fail/data_race/atomic_read_na_write_race1.rs:22:13\n    --> ../miri/tests/fail/data_race/atomic_read_na_write_race1.rs:22:13\n     |\n22   |             (&*c.0).load(Ordering::SeqCst)\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nAfter:\n```\nerror: Undefined Behavior: Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at alloc1727 (current vector clock = VClock([9, 0, 6]), conflicting timestamp = VClock([0, 6]))\n  --> tests/fail/data_race/atomic_read_na_write_race1.rs:22:13\n   |\n22 |             (&*c.0).load(Ordering::SeqCst)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at alloc1727 (current vector clock = VClock([9, 0, 6]), conflicting timestamp = VClock([0, 6]))\n   |\n   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n\n   = note: inside closure at tests/fail/data_race/atomic_read_na_write_race1.rs:22:13\n```", "tree": {"sha": "91005623f0cd6864f55512400119291f65822a23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91005623f0cd6864f55512400119291f65822a23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35a061724802377a21fc6dac1ebcbb9b8d1f558a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35a061724802377a21fc6dac1ebcbb9b8d1f558a", "html_url": "https://github.com/rust-lang/rust/commit/35a061724802377a21fc6dac1ebcbb9b8d1f558a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35a061724802377a21fc6dac1ebcbb9b8d1f558a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dbc89de3f160f4fd91a1e20b72fc6b3157b2e04", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dbc89de3f160f4fd91a1e20b72fc6b3157b2e04", "html_url": "https://github.com/rust-lang/rust/commit/4dbc89de3f160f4fd91a1e20b72fc6b3157b2e04"}, {"sha": "13877a965d93100b5995da612a95612919a45cfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/13877a965d93100b5995da612a95612919a45cfa", "html_url": "https://github.com/rust-lang/rust/commit/13877a965d93100b5995da612a95612919a45cfa"}], "stats": {"total": 75, "additions": 75, "deletions": 0}, "files": [{"sha": "9ae31a31aaad34c5cd697df3af9e374e449150dd", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=35a061724802377a21fc6dac1ebcbb9b8d1f558a", "patch": "@@ -2625,6 +2625,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n #[cfg_attr(not(bootstrap), rustc_allowed_through_unstable_modules)]\n #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]"}, {"sha": "6cdbab3058941c3938adb71106e1518b4f60be20", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=35a061724802377a21fc6dac1ebcbb9b8d1f558a", "patch": "@@ -1144,6 +1144,7 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read(self) -> T\n     where\n         T: Sized,\n@@ -1164,6 +1165,7 @@ impl<T: ?Sized> *const T {\n     /// [`ptr::read_volatile`]: crate::ptr::read_volatile()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn read_volatile(self) -> T\n     where\n         T: Sized,\n@@ -1183,6 +1185,7 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read_unaligned(self) -> T\n     where\n         T: Sized,"}, {"sha": "40e28e636d8514394b088d4fb89c4763cdca9798", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=35a061724802377a21fc6dac1ebcbb9b8d1f558a", "patch": "@@ -1095,6 +1095,7 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read<T>(src: *const T) -> T {\n     // We are calling the intrinsics directly to avoid function calls in the generated code\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n@@ -1194,6 +1195,7 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n     let mut tmp = MaybeUninit::<T>::uninit();\n     // SAFETY: the caller must guarantee that `src` is valid for reads.\n@@ -1290,6 +1292,7 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // We are calling the intrinsics directly to avoid function calls in the generated code\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n@@ -1387,6 +1390,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n     // SAFETY: the caller must guarantee that `dst` is valid for writes.\n     // `dst` cannot overlap `src` because the caller has mutable access\n@@ -1460,6 +1464,7 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// ```\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n     unsafe {\n@@ -1530,6 +1535,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// ```\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {"}, {"sha": "e323f63115b85a7415bc12eebeca1c1719dda13d", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=35a061724802377a21fc6dac1ebcbb9b8d1f558a", "patch": "@@ -1258,6 +1258,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read(self) -> T\n     where\n         T: Sized,\n@@ -1278,6 +1279,7 @@ impl<T: ?Sized> *mut T {\n     /// [`ptr::read_volatile`]: crate::ptr::read_volatile()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn read_volatile(self) -> T\n     where\n         T: Sized,\n@@ -1297,6 +1299,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read_unaligned(self) -> T\n     where\n         T: Sized,\n@@ -1402,6 +1405,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn write(self, val: T)\n     where\n         T: Sized,\n@@ -1420,6 +1424,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn write_bytes(self, val: u8, count: usize)\n     where\n         T: Sized,\n@@ -1440,6 +1445,7 @@ impl<T: ?Sized> *mut T {\n     /// [`ptr::write_volatile`]: crate::ptr::write_volatile()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn write_volatile(self, val: T)\n     where\n         T: Sized,\n@@ -1459,6 +1465,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n     #[inline(always)]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn write_unaligned(self, val: T)\n     where\n         T: Sized,"}, {"sha": "5e2e0c4d8cc1b24cc33b2f91d48d4ea50fe92415", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a061724802377a21fc6dac1ebcbb9b8d1f558a/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=35a061724802377a21fc6dac1ebcbb9b8d1f558a", "patch": "@@ -449,6 +449,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn load(&self, order: Ordering) -> bool {\n         // SAFETY: any data races are prevented by atomic intrinsics and the raw\n         // pointer passed in is valid because we got it from a reference.\n@@ -476,6 +477,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn store(&self, val: bool, order: Ordering) {\n         // SAFETY: any data races are prevented by atomic intrinsics and the raw\n         // pointer passed in is valid because we got it from a reference.\n@@ -507,6 +509,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n@@ -563,6 +566,7 @@ impl AtomicBool {\n         note = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n     )]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -610,6 +614,7 @@ impl AtomicBool {\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[doc(alias = \"compare_and_swap\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange(\n         &self,\n         current: bool,\n@@ -664,6 +669,7 @@ impl AtomicBool {\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[doc(alias = \"compare_and_swap\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange_weak(\n         &self,\n         current: bool,\n@@ -715,6 +721,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n@@ -756,6 +763,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -807,6 +815,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n@@ -847,6 +856,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n@@ -884,6 +894,7 @@ impl AtomicBool {\n     #[inline]\n     #[unstable(feature = \"atomic_bool_fetch_not\", issue = \"98485\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_not(&self, order: Ordering) -> bool {\n         self.fetch_xor(true, order)\n     }\n@@ -958,6 +969,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"atomic_fetch_update\", since = \"1.53.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_update<F>(\n         &self,\n         set_order: Ordering,\n@@ -1165,6 +1177,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn load(&self, order: Ordering) -> *mut T {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_load(self.p.get(), order) }\n@@ -1193,6 +1206,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n@@ -1225,6 +1239,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.p.get(), ptr, order) }\n@@ -1280,6 +1295,7 @@ impl<T> AtomicPtr<T> {\n         note = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n     )]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1319,6 +1335,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange(\n         &self,\n         current: *mut T,\n@@ -1367,6 +1384,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange_weak(\n         &self,\n         current: *mut T,\n@@ -1427,6 +1445,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_fetch_update\", since = \"1.53.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_update<F>(\n         &self,\n         set_order: Ordering,\n@@ -1482,6 +1501,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_ptr_add(&self, val: usize, order: Ordering) -> *mut T {\n         self.fetch_byte_add(val.wrapping_mul(core::mem::size_of::<T>()), order)\n     }\n@@ -1526,6 +1546,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_ptr_sub(&self, val: usize, order: Ordering) -> *mut T {\n         self.fetch_byte_sub(val.wrapping_mul(core::mem::size_of::<T>()), order)\n     }\n@@ -1561,6 +1582,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_byte_add(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1604,6 +1626,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_byte_sub(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1662,6 +1685,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_or(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1719,6 +1743,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_and(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1774,6 +1799,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_xor(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -2085,6 +2111,7 @@ macro_rules! atomic_int {\n             /// ```\n             #[inline]\n             #[$stable]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn load(&self, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_load(self.v.get(), order) }\n@@ -2111,6 +2138,7 @@ macro_rules! atomic_int {\n             /// ```\n             #[inline]\n             #[$stable]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn store(&self, val: $int_type, order: Ordering) {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_store(self.v.get(), val, order); }\n@@ -2138,6 +2166,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_swap(self.v.get(), val, order) }\n@@ -2195,6 +2224,7 @@ macro_rules! atomic_int {\n                 note = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n             ]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn compare_and_swap(&self,\n                                     current: $int_type,\n                                     new: $int_type,\n@@ -2248,6 +2278,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable_cxchg]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn compare_exchange(&self,\n                                     current: $int_type,\n                                     new: $int_type,\n@@ -2296,6 +2327,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable_cxchg]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn compare_exchange_weak(&self,\n                                          current: $int_type,\n                                          new: $int_type,\n@@ -2331,6 +2363,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_add(self.v.get(), val, order) }\n@@ -2360,6 +2393,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_sub(self.v.get(), val, order) }\n@@ -2392,6 +2426,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_and(self.v.get(), val, order) }\n@@ -2424,6 +2459,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable_nand]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_nand(self.v.get(), val, order) }\n@@ -2456,6 +2492,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_or(self.v.get(), val, order) }\n@@ -2488,6 +2525,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_xor(self.v.get(), val, order) }\n@@ -2528,6 +2566,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_update<F>(&self,\n                                    set_order: Ordering,\n                                    fetch_order: Ordering,\n@@ -2581,6 +2620,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { $max_fn(self.v.get(), val, order) }\n@@ -2626,6 +2666,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { $min_fn(self.v.get(), val, order) }\n@@ -2939,6 +2980,7 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n }\n \n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n     // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n     unsafe {\n@@ -2953,6 +2995,7 @@ unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n }\n \n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n     unsafe {\n@@ -2968,6 +3011,7 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n     unsafe {\n@@ -2984,6 +3028,7 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n     unsafe {\n@@ -3000,6 +3045,7 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n     unsafe {\n@@ -3015,6 +3061,7 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange<T: Copy>(\n     dst: *mut T,\n     old: T,\n@@ -3057,6 +3104,7 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     dst: *mut T,\n     old: T,\n@@ -3099,6 +3147,7 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n     unsafe {\n@@ -3114,6 +3163,7 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n     unsafe {\n@@ -3129,6 +3179,7 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n     unsafe {\n@@ -3144,6 +3195,7 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n     unsafe {\n@@ -3160,6 +3212,7 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the max value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n     unsafe {\n@@ -3176,6 +3229,7 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the min value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n     unsafe {\n@@ -3192,6 +3246,7 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the max value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n     unsafe {\n@@ -3208,6 +3263,7 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the min value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n     unsafe {\n@@ -3298,6 +3354,7 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"fence\"]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub fn fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n@@ -3380,6 +3437,7 @@ pub fn fence(order: Ordering) {\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n #[rustc_diagnostic_item = \"compiler_fence\"]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub fn compiler_fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {"}]}