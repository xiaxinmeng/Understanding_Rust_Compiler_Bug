{"sha": "4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYmJiZTU5N2U0NGRiZWQwZGEzMDI3ZmJmNGU1NjQzOTBlMGRhZWI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-21T10:21:27Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-21T10:21:27Z"}, "message": "Move hash table iteration over to block-taking functions\n\nIssue #1056", "tree": {"sha": "688153be857cd96a9ea940b0d697b25f1f71d384", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/688153be857cd96a9ea940b0d697b25f1f71d384"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "html_url": "https://github.com/rust-lang/rust/commit/4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb4595c534ffcd0731ed778beb62bb80d7f9217", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb4595c534ffcd0731ed778beb62bb80d7f9217", "html_url": "https://github.com/rust-lang/rust/commit/9bb4595c534ffcd0731ed778beb62bb80d7f9217"}], "stats": {"total": 168, "additions": 82, "deletions": 86}, "files": [{"sha": "f005b0bb991aab17c3d464ea2cff52ec31bf1887", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -72,12 +72,8 @@ fn have_crate_data(cstore: cstore, cnum: ast::crate_num) -> bool {\n     ret p(cstore).metas.contains_key(cnum);\n }\n \n-iter iter_crate_data(cstore: cstore) ->\n-     @{key: ast::crate_num, val: crate_metadata} {\n-    for each kv: @{key: ast::crate_num, val: crate_metadata} in\n-             p(cstore).metas.items() {\n-        put kv;\n-    }\n+fn iter_crate_data(cstore: cstore, i: block(ast::crate_num, crate_metadata)) {\n+    p(cstore).metas.items {|k,v| i(k, v);};\n }\n \n fn add_used_crate_file(cstore: cstore, lib: str) {"}, {"sha": "f392d2367e4d57a154149867fefe9dcad784be63", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -371,20 +371,19 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer) ->\n    [entry<int>] {\n     let index: [entry<int>] = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n-    for each kvp: @{key: node_id, val: middle::ast_map::ast_node} in\n-             ecx.ccx.ast_map.items() {\n-        alt kvp.val {\n+    ecx.ccx.ast_map.items {|key, val|\n+        alt val {\n           middle::ast_map::node_item(i) {\n-            index += [{val: kvp.key, pos: ebml_w.writer.tell()}];\n+            index += [{val: key, pos: ebml_w.writer.tell()}];\n             encode_info_for_item(ecx, ebml_w, i, index);\n           }\n           middle::ast_map::node_native_item(i) {\n-            index += [{val: kvp.key, pos: ebml_w.writer.tell()}];\n+            index += [{val: key, pos: ebml_w.writer.tell()}];\n             encode_info_for_native_item(ecx, ebml_w, i);\n           }\n           _ { }\n         }\n-    }\n+    };\n     ebml::end_tag(ebml_w);\n     ret index;\n }\n@@ -544,9 +543,9 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n         // Pull the cnums and names out of cstore\n         let pairs: [mutable numname] = [mutable];\n-        for each hashkv: hashkv in cstore::iter_crate_data(cstore) {\n-            pairs += [mutable {crate: hashkv.key, ident: hashkv.val.name}];\n-        }\n+        cstore::iter_crate_data(cstore) {|key, val|\n+            pairs += [mutable {crate: key, ident: val.name}];\n+        };\n \n         // Sort by cnum\n         fn lteq(kv1: numname, kv2: numname) -> bool { kv1.crate <= kv2.crate }"}, {"sha": "d141a2a86e2c586548ed0d2c580cf6619f6d1aa7", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -86,14 +86,13 @@ fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n // the entire codebase adapting all the callsites to the different\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter<@K,\n-                           @V>(key_idx: fn(K) -> uint, idx_key: fn(uint) -> K)\n-   -> std::map::hashmap<K, V> {\n+fn new_smallintmap_adapter<@K, @V>(key_idx: fn(K) -> uint,\n+                                   idx_key: fn(uint) -> K)\n+    -> std::map::hashmap<K, V> {\n \n-    obj adapter<@K,\n-                @V>(map: smallintmap::smallintmap<V>,\n-                    key_idx: fn(K) -> uint,\n-                    idx_key: fn(uint) -> K) {\n+    obj adapter<@K, @V>(map: smallintmap::smallintmap<V>,\n+                        key_idx: fn(K) -> uint,\n+                        idx_key: fn(uint) -> K) {\n \n         fn size() -> uint { fail }\n \n@@ -117,22 +116,29 @@ fn new_smallintmap_adapter<@K,\n \n         fn rehash() { fail }\n \n-        iter items() -> @{key: K, val: V} {\n+        fn items(it: block(K, V)) {\n             let idx = 0u;\n-            for item: option::t<V> in map.v {\n+            for item in map.v {\n                 alt item {\n                   option::some(elt) {\n-                    let value = elt;\n-                    let key = idx_key(idx);\n-                    put @{key: key, val: value};\n+                    it(idx_key(idx), elt);\n                   }\n                   option::none. { }\n                 }\n                 idx += 1u;\n             }\n         }\n-        iter keys() -> K {\n-            for each p: @{key: K, val: V} in self.items() { put p.key; }\n+        fn keys(it: block(K)) {\n+            let idx = 0u;\n+            for item in map.v {\n+                if item != option::none { it(idx_key(idx)); }\n+                idx += 1u;\n+            }\n+        }\n+        fn values(it: block(V)) {\n+            for item in map.v {\n+                alt item { option::some(elt) { it(elt); } _ {} }\n+            }\n         }\n     }\n "}, {"sha": "1203a3e3419f1e4ad9e9d1ceacf2d6440375297d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -48,12 +48,8 @@ type scopes = list<scope>;\n tag import_state {\n     todo(ast::node_id, ast::ident, [ast::ident], codemap::span, scopes);\n     resolving(span);\n-    resolved(option::t<def>,\n-\n-             /* value */\n-             option::t<def>,\n-\n-             /* type */\n+    resolved(option::t<def>, /* value */\n+             option::t<def>, /* type */\n              option::t<def>); /* module */\n }\n \n@@ -241,15 +237,14 @@ fn map_crate(e: @env, c: @ast::crate) {\n }\n \n fn resolve_imports(e: env) {\n-    for each it: @{key: ast::node_id, val: import_state} in e.imports.items()\n-             {\n-        alt it.val {\n+    e.imports.values {|v|\n+        alt v {\n           todo(node_id, name, path, span, scopes) {\n             resolve_import(e, local_def(node_id), name, path, span, scopes);\n           }\n           resolved(_, _, _) { }\n         }\n-    }\n+    };\n     e.sess.abort_if_errors();\n }\n \n@@ -1188,12 +1183,9 @@ fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n fn check_for_collisions(e: @env, c: ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n-    for each m: @{key: ast::node_id, val: @indexed_mod} in e.mod_map.items() {\n-        for each name: @{key: ident, val: list<mod_index_entry>} in\n-                 m.val.index.items() {\n-            check_mod_name(*e, name.key, name.val);\n-        }\n-    }\n+    e.mod_map.values {|val|\n+        val.index.items {|k, v| check_mod_name(*e, k, v); };\n+    };\n     // Other scopes have to be checked the hard way.\n     let v =\n         @{visit_item: bind check_item(e, _, _, _),\n@@ -1426,7 +1418,7 @@ fn check_bad_exports(e: @env) {\n                                                     ns_type, inside));\n     }\n \n-    for each @{val: val, _} in e.mod_map.items() {\n+    e.mod_map.values {|val|\n         alt val.m {\n           some(m) {\n             for vi in m.view_items {\n@@ -1447,7 +1439,7 @@ fn check_bad_exports(e: @env) {\n           }\n           none. { }\n         }\n-    }\n+    };\n }\n \n // Local Variables:"}, {"sha": "87ddd1df14511dc392bd5f7083cceb38e1f9e987", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -1249,10 +1249,10 @@ fn make_generic_glue(cx: @local_ctxt, sp: span, t: ty::t, llfn: ValueRef,\n }\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n-    for each pair: @{key: ty::t, val: @tydesc_info} in ccx.tydescs.items() {\n+    ccx.tydescs.items {|key, val|\n         let glue_fn_ty = T_ptr(T_glue_fn(*ccx));\n         let cmp_fn_ty = T_ptr(T_cmp_glue_fn(*ccx));\n-        let ti = pair.val;\n+        let ti = val;\n         let take_glue =\n             alt ti.take_glue {\n               none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n@@ -1274,7 +1274,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n \n-        let shape = shape::shape_of(ccx, pair.key, ti.ty_params,\n+        let shape = shape::shape_of(ccx, key, ti.ty_params,\n                                     ti.is_obj_body);\n         let shape_tables =\n             llvm::LLVMConstPointerCast(ccx.shape_cx.llshapetables,\n@@ -1303,7 +1303,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n         llvm::LLVMSetGlobalConstant(gvar, True);\n         llvm::LLVMSetLinkage(gvar,\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    }\n+    };\n }\n \n fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n@@ -6144,10 +6144,10 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     let elts: [ValueRef] = [];\n-    for each item: @{key: str, val: ValueRef} in ccx.module_data.items() {\n-        let elt = C_struct([p2i(C_cstr(ccx, item.key)), p2i(item.val)]);\n+    ccx.module_data.items {|key, val|\n+        let elt = C_struct([p2i(C_cstr(ccx, key)), p2i(val)]);\n         elts += [elt];\n-    }\n+    };\n     let term = C_struct([C_int(0), C_int(0)]);\n     elts += [term];\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));"}, {"sha": "c6d59a72831e77e41ff9679a51aff26f164abd0b", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -356,10 +356,10 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             Br(bcx, guard_cx.llbb);\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n-            for each @{key: key, val: val} in data.id_map.items() {\n+            data.id_map.items {|key, val|\n                 let local = local_mem(option::get(assoc(key, m[0].bound)));\n                 bcx.fcx.lllocals.insert(val, local);\n-            }\n+            };\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_temp_expr(guard_cx, e);\n             guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n@@ -582,7 +582,7 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                      ids: ast_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n     let success = true;\n-    for each @{key: name, val: node_id} in ids.items() {\n+    ids.items {|name, node_id|\n         let llbbs = [];\n         let vals = [];\n         for ex: exit_node in map {\n@@ -597,10 +597,10 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n             let local = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n             bcx.fcx.lllocals.insert(node_id, local_mem(local));\n         } else { success = false; }\n-    }\n+    };\n     if success {\n         // Copy references that the alias analysis considered unsafe\n-        for each @{val: node_id, _} in ids.items() {\n+        ids.values {|node_id|\n             if bcx_ccx(bcx).copy_map.contains_key(node_id) {\n                 let local = alt bcx.fcx.lllocals.get(node_id) {\n                   local_mem(x) { x }\n@@ -613,7 +613,7 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                 add_clean(bcx, alloc, e_ty);\n                 bcx.fcx.lllocals.insert(node_id, local_mem(alloc));\n             }\n-        }\n+        };\n     } else {\n         Unreachable(bcx);\n     }"}, {"sha": "af4bb26a08a6fdf2549e3c578701679e83e0e720", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -539,10 +539,9 @@ fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n // non-exhaustive match in trans.\n fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n     let rslt: [norm_constraint] = [];\n-    for each p: @{key: def_id, val: constraint} in\n-             fcx.enclosing.constrs.items() {\n-        rslt += norm_a_constraint(p.key, p.val);\n-    }\n+    fcx.enclosing.constrs.items {|key, val|\n+        rslt += norm_a_constraint(key, val);\n+    };\n     ret rslt;\n }\n \n@@ -861,17 +860,16 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n     }\n \n \n-    for each p: @{key: def_id, val: constraint} in\n-             fcx.enclosing.constrs.items() {\n+    fcx.enclosing.constrs.values {|val|\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n-        let insts = find_instances(fcx, subst, p.val);\n+        let insts = find_instances(fcx, subst, val);\n         for p: {from: uint, to: uint} in insts {\n             if promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n         }\n-    }\n+    };\n }\n \n "}, {"sha": "d766ff11579d40739601ca360eff57168834a10d", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -172,12 +172,12 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option::t<bindings> {\n         alt sel(match_expr(e)) { none. { ret none; } _ { } }\n     }\n     let never_mind: bool = false;\n-    for each pair: @{key: ident, val: selector} in b.real_binders.items() {\n-        alt pair.val(match_expr(e)) {\n+    b.real_binders.items {|key, val|\n+        alt val(match_expr(e)) {\n           none. { never_mind = true; }\n-          some(mtc) { res.insert(pair.key, mtc); }\n+          some(mtc) { res.insert(key, mtc); }\n         }\n-    }\n+    };\n     //HACK: `ret` doesn't work in `for each`\n     if never_mind { ret none; }\n     ret some(res);\n@@ -243,7 +243,7 @@ fn follow_for_trans(cx: ext_ctxt, mmaybe: option::t<arb_depth<matchable>>,\n }\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n-iter free_vars(b: bindings, e: @expr) -> ident {\n+fn free_vars(b: bindings, e: @expr, it: block(ident)) {\n     let idents: hashmap<ident, ()> = new_str_hash::<()>();\n     fn mark_ident(&&i: ident, _fld: ast_fold, b: bindings,\n                   idents: hashmap<ident, ()>) -> ident {\n@@ -257,7 +257,7 @@ iter free_vars(b: bindings, e: @expr) -> ident {\n             with *default_ast_fold()};\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n-    for each id: ident in idents.keys() { put id; }\n+    idents.keys {|x| it(x); };\n }\n \n \n@@ -273,7 +273,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n             let repeat: option::t<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n-            for each fv: ident in free_vars(b, repeat_me) {\n+            free_vars(b, repeat_me) {|fv|\n                 let cur_pos = follow(b.get(fv), idx_path);\n                 alt cur_pos {\n                   leaf(_) { }\n@@ -295,7 +295,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                     }\n                   }\n                 }\n-            }\n+            };\n             alt repeat {\n               none. {\n                 cx.span_fatal(repeat_me.span,"}, {"sha": "ef5e8acae4656cf32a48a31dab1c921f038e90b5", "filename": "src/lib/map.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbbe597e44dbed0da3027fbf4e564390e0daeb/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=4ebbbe597e44dbed0da3027fbf4e564390e0daeb", "patch": "@@ -14,8 +14,9 @@ type hashmap<K, V> =\n         fn find(K) -> option::t<V>;\n         fn remove(K) -> option::t<V>;\n         fn rehash();\n-        iter items() -> @{key: K, val: V};\n-        iter keys() -> K;\n+        fn items(block(K, V));\n+        fn keys(block(K));\n+        fn values(block(V));\n     };\n type hashset<K> = hashmap<K, ()>;\n \n@@ -111,8 +112,7 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n             }\n         }\n     }\n-    obj hashmap<@K,\n-                @V>(hasher: hashfn<K>,\n+    obj hashmap<@K, @V>(hasher: hashfn<K>,\n                     eqer: eqfn<K>,\n                     mutable bkts: [mutable bucket<K, V>],\n                     mutable nbkts: uint,\n@@ -177,14 +177,19 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n             rehash(hasher, eqer, bkts, nbkts, newbkts, nbkts);\n             bkts = newbkts;\n         }\n-        iter items() -> @{key: K, val: V} {\n-            for b: bucket<K, V> in bkts {\n-                alt b { some(k, v) { put @{key: k, val: v}; } _ { } }\n+        fn items(it: block(K, V)) {\n+            for b in bkts {\n+                alt b { some(k, v) { it(copy k, copy v); } _ { } }\n             }\n         }\n-        iter keys() -> K {\n-            for b: bucket<K, V> in bkts {\n-                alt b { some(k, _) { put k; } _ { } }\n+        fn keys(it: block(K)) {\n+            for b in bkts {\n+                alt b { some(k, _) { it(copy k); } _ { } }\n+            }\n+        }\n+        fn values(it: block(V)) {\n+            for b in bkts {\n+                alt b { some(_, v) { it(copy v); } _ { } }\n             }\n         }\n     }"}]}