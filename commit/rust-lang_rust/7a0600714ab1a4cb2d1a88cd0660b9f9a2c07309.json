{"sha": "7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "node_id": "C_kwDOAAsO6NoAKDdhMDYwMDcxNGFiMWE0Y2IyZDFhODhjZDA2NjBiOWY5YTJjMDczMDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-27T05:01:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-27T05:01:19Z"}, "message": "Auto merge of #109091 - Nilstrieb:match-on-attr, r=cjgillot\n\nCleanup `codegen_fn_attrs`\n\nThe `match` control flow construct has been stable since 1.0, we should use it here.\n\nSorry for the hard to review diff, I did try to at least split it into two commits. But looking at before-after side-by-side (instead of whatever github is doing) is probably the easiest way to make sure that I didn't forget about anything.\n\nOn top of #109088, you can wait for that", "tree": {"sha": "08049e5010a66b2b679d78584cf819e98a5e1947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08049e5010a66b2b679d78584cf819e98a5e1947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "html_url": "https://github.com/rust-lang/rust/commit/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d5820784e442ec7e89474e2fa305440253ffaeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5820784e442ec7e89474e2fa305440253ffaeb", "html_url": "https://github.com/rust-lang/rust/commit/1d5820784e442ec7e89474e2fa305440253ffaeb"}, {"sha": "1d70bd497007e86b0c7713b66402057487ed68f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d70bd497007e86b0c7713b66402057487ed68f9", "html_url": "https://github.com/rust-lang/rust/commit/1d70bd497007e86b0c7713b66402057487ed68f9"}], "stats": {"total": 619, "additions": 326, "deletions": 293}, "files": [{"sha": "57856b4ddb1b7698eb03c7cf07d998a751887c00", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 326, "deletions": 293, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "patch": "@@ -10,6 +10,7 @@ use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self as ty, TyCtxt};\n use rustc_session::{lint, parse::feature_err};\n+use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};\n \n@@ -83,336 +84,368 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n             }\n         };\n \n-        if attr.has_name(sym::cold) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.has_name(sym::rustc_allocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.has_name(sym::ffi_returns_twice) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-        } else if attr.has_name(sym::ffi_pure) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-        } else if attr.has_name(sym::ffi_const) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-        } else if attr.has_name(sym::rustc_nounwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        } else if attr.has_name(sym::rustc_reallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n-        } else if attr.has_name(sym::rustc_deallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n-        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n-        } else if attr.has_name(sym::naked) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.has_name(sym::no_mangle) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.has_name(sym::no_coverage) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.has_name(sym::used) {\n-            let inner = attr.meta_item_list();\n-            match inner.as_deref() {\n-                Some([item]) if item.has_name(sym::linker) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(linker)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n-                }\n-                Some([item]) if item.has_name(sym::compiler) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(compiler)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-                }\n-                Some(_) => {\n-                    tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n-                }\n-                None => {\n-                    // Unfortunately, unconditionally using `llvm.used` causes\n-                    // issues in handling `.init_array` with the gold linker,\n-                    // but using `llvm.compiler.used` caused a nontrival amount\n-                    // of unintentional ecosystem breakage -- particularly on\n-                    // Mach-O targets.\n-                    //\n-                    // As a result, we emit `llvm.compiler.used` only on ELF\n-                    // targets. This is somewhat ad-hoc, but actually follows\n-                    // our pre-LLVM 13 behavior (prior to the ecosystem\n-                    // breakage), and seems to match `clang`'s behavior as well\n-                    // (both before and after LLVM 13), possibly because they\n-                    // have similar compatibility concerns to us. See\n-                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n-                    // and following comments for some discussion of this, as\n-                    // well as the comments in `rustc_codegen_llvm` where these\n-                    // flags are handled.\n-                    //\n-                    // Anyway, to be clear: this is still up in the air\n-                    // somewhat, and is subject to change in the future (which\n-                    // is a good thing, because this would ideally be a bit\n-                    // more firmed up).\n-                    let is_like_elf = !(tcx.sess.target.is_like_osx\n-                        || tcx.sess.target.is_like_windows\n-                        || tcx.sess.target.is_like_wasm);\n-                    codegen_fn_attrs.flags |= if is_like_elf {\n-                        CodegenFnAttrFlags::USED\n-                    } else {\n-                        CodegenFnAttrFlags::USED_LINKER\n-                    };\n-                }\n+        let Some(Ident { name, .. }) = attr.ident() else {\n+            continue;\n+        };\n+\n+        match name {\n+            sym::cold => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n             }\n-        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if let Some(fn_sig) = fn_sig()\n-                && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n-            {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0776,\n-                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n-                )\n-                .emit();\n+            sym::rustc_allocator => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n             }\n-            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n-                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n-                    .emit();\n+            sym::ffi_returns_twice => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-        } else if attr.has_name(sym::thread_local) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && let Some(fn_sig) = fn_sig()\n-                && fn_sig.skip_binder().abi() != abi::Abi::Rust\n-            {\n-                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n-                    .emit();\n+            sym::ffi_pure => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n             }\n-            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    sym::closure_track_caller,\n-                    attr.span,\n-                    \"`#[track_caller]` on closures is currently unstable\",\n-                )\n-                .emit();\n+            sym::ffi_const => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n+            }\n+            sym::rustc_nounwind => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+            }\n+            sym::rustc_reallocator => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n+            }\n+            sym::rustc_deallocator => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n+            }\n+            sym::rustc_allocator_zeroed => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n+            }\n+            sym::naked => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n+            }\n+            sym::no_mangle => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+            }\n+            sym::no_coverage => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+            }\n+            sym::rustc_std_internal_symbol => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+            }\n+            sym::used => {\n+                let inner = attr.meta_item_list();\n+                match inner.as_deref() {\n+                    Some([item]) if item.has_name(sym::linker) => {\n+                        if !tcx.features().used_with_arg {\n+                            feature_err(\n+                                &tcx.sess.parse_sess,\n+                                sym::used_with_arg,\n+                                attr.span,\n+                                \"`#[used(linker)]` is currently unstable\",\n+                            )\n+                            .emit();\n+                        }\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n+                    }\n+                    Some([item]) if item.has_name(sym::compiler) => {\n+                        if !tcx.features().used_with_arg {\n+                            feature_err(\n+                                &tcx.sess.parse_sess,\n+                                sym::used_with_arg,\n+                                attr.span,\n+                                \"`#[used(compiler)]` is currently unstable\",\n+                            )\n+                            .emit();\n+                        }\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n+                    }\n+                    Some(_) => {\n+                        tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n+                    }\n+                    None => {\n+                        // Unfortunately, unconditionally using `llvm.used` causes\n+                        // issues in handling `.init_array` with the gold linker,\n+                        // but using `llvm.compiler.used` caused a nontrival amount\n+                        // of unintentional ecosystem breakage -- particularly on\n+                        // Mach-O targets.\n+                        //\n+                        // As a result, we emit `llvm.compiler.used` only on ELF\n+                        // targets. This is somewhat ad-hoc, but actually follows\n+                        // our pre-LLVM 13 behavior (prior to the ecosystem\n+                        // breakage), and seems to match `clang`'s behavior as well\n+                        // (both before and after LLVM 13), possibly because they\n+                        // have similar compatibility concerns to us. See\n+                        // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n+                        // and following comments for some discussion of this, as\n+                        // well as the comments in `rustc_codegen_llvm` where these\n+                        // flags are handled.\n+                        //\n+                        // Anyway, to be clear: this is still up in the air\n+                        // somewhat, and is subject to change in the future (which\n+                        // is a good thing, because this would ideally be a bit\n+                        // more firmed up).\n+                        let is_like_elf = !(tcx.sess.target.is_like_osx\n+                            || tcx.sess.target.is_like_windows\n+                            || tcx.sess.target.is_like_wasm);\n+                        codegen_fn_attrs.flags |= if is_like_elf {\n+                            CodegenFnAttrFlags::USED\n+                        } else {\n+                            CodegenFnAttrFlags::USED_LINKER\n+                        };\n+                    }\n+                }\n             }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.has_name(sym::export_name) {\n-            if let Some(s) = attr.value_str() {\n-                if s.as_str().contains('\\0') {\n-                    // `#[export_name = ...]` will be converted to a null-terminated string,\n-                    // so it may not contain any null characters.\n+            sym::cmse_nonsecure_entry => {\n+                if let Some(fn_sig) = fn_sig()\n+                    && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n+                {\n                     struct_span_err!(\n                         tcx.sess,\n                         attr.span,\n-                        E0648,\n-                        \"`export_name` may not contain null characters\"\n+                        E0776,\n+                        \"`#[cmse_nonsecure_entry]` requires C ABI\"\n                     )\n                     .emit();\n                 }\n-                codegen_fn_attrs.export_name = Some(s);\n-            }\n-        } else if attr.has_name(sym::target_feature) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && let Some(fn_sig) = fn_sig()\n-                && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n-            {\n-                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n-                    // The `#[target_feature]` attribute is allowed on\n-                    // WebAssembly targets on all functions, including safe\n-                    // ones. Other targets require that `#[target_feature]` is\n-                    // only applied to unsafe functions (pending the\n-                    // `target_feature_11` feature) because on most targets\n-                    // execution of instructions that are not supported is\n-                    // considered undefined behavior. For WebAssembly which is a\n-                    // 100% safe target at execution time it's not possible to\n-                    // execute undefined instructions, and even if a future\n-                    // feature was added in some form for this it would be a\n-                    // deterministic trap. There is no undefined behavior when\n-                    // executing WebAssembly so `#[target_feature]` is allowed\n-                    // on safe functions (but again, only for WebAssembly)\n-                    //\n-                    // Note that this is also allowed if `actually_rustdoc` so\n-                    // if a target is documenting some wasm-specific code then\n-                    // it's not spuriously denied.\n-                    //\n-                    // This exception needs to be kept in sync with allowing\n-                    // `#[target_feature]` on `main` and `start`.\n-                } else if !tcx.features().target_feature_11 {\n-                    let mut err = feature_err(\n+                if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n+                    struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n+                    .emit();\n+                }\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n+            }\n+            sym::thread_local => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n+            }\n+            sym::track_caller => {\n+                if !tcx.is_closure(did.to_def_id())\n+                    && let Some(fn_sig) = fn_sig()\n+                    && fn_sig.skip_binder().abi() != abi::Abi::Rust\n+                {\n+                    struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n+                        .emit();\n+                }\n+                if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n+                    feature_err(\n                         &tcx.sess.parse_sess,\n-                        sym::target_feature_11,\n+                        sym::closure_track_caller,\n                         attr.span,\n-                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n-                    );\n-                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n-                    err.emit();\n-                } else {\n-                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                        \"`#[track_caller]` on closures is currently unstable\",\n+                    )\n+                    .emit();\n                 }\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n             }\n-            from_target_feature(\n-                tcx,\n-                attr,\n-                supported_target_features,\n-                &mut codegen_fn_attrs.target_features,\n-            );\n-        } else if attr.has_name(sym::linkage) {\n-            if let Some(val) = attr.value_str() {\n-                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n-                if tcx.is_foreign_item(did) {\n-                    codegen_fn_attrs.import_linkage = linkage;\n-                } else {\n-                    codegen_fn_attrs.linkage = linkage;\n+            sym::export_name => {\n+                if let Some(s) = attr.value_str() {\n+                    if s.as_str().contains('\\0') {\n+                        // `#[export_name = ...]` will be converted to a null-terminated string,\n+                        // so it may not contain any null characters.\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            attr.span,\n+                            E0648,\n+                            \"`export_name` may not contain null characters\"\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.export_name = Some(s);\n                 }\n             }\n-        } else if attr.has_name(sym::link_section) {\n-            if let Some(val) = attr.value_str() {\n-                if val.as_str().bytes().any(|b| b == 0) {\n-                    let msg = format!(\n-                        \"illegal null byte in link_section \\\n-                         value: `{}`\",\n-                        &val\n-                    );\n-                    tcx.sess.span_err(attr.span, &msg);\n-                } else {\n-                    codegen_fn_attrs.link_section = Some(val);\n+            sym::target_feature => {\n+                if !tcx.is_closure(did.to_def_id())\n+                    && let Some(fn_sig) = fn_sig()\n+                    && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n+                {\n+                    if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n+                        // The `#[target_feature]` attribute is allowed on\n+                        // WebAssembly targets on all functions, including safe\n+                        // ones. Other targets require that `#[target_feature]` is\n+                        // only applied to unsafe functions (pending the\n+                        // `target_feature_11` feature) because on most targets\n+                        // execution of instructions that are not supported is\n+                        // considered undefined behavior. For WebAssembly which is a\n+                        // 100% safe target at execution time it's not possible to\n+                        // execute undefined instructions, and even if a future\n+                        // feature was added in some form for this it would be a\n+                        // deterministic trap. There is no undefined behavior when\n+                        // executing WebAssembly so `#[target_feature]` is allowed\n+                        // on safe functions (but again, only for WebAssembly)\n+                        //\n+                        // Note that this is also allowed if `actually_rustdoc` so\n+                        // if a target is documenting some wasm-specific code then\n+                        // it's not spuriously denied.\n+                        //\n+                        // This exception needs to be kept in sync with allowing\n+                        // `#[target_feature]` on `main` and `start`.\n+                    } else if !tcx.features().target_feature_11 {\n+                        let mut err = feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::target_feature_11,\n+                            attr.span,\n+                            \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n+                        );\n+                        err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n+                        err.emit();\n+                    } else {\n+                        check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                    }\n+                }\n+                from_target_feature(\n+                    tcx,\n+                    attr,\n+                    supported_target_features,\n+                    &mut codegen_fn_attrs.target_features,\n+                );\n+            }\n+            sym::linkage => {\n+                if let Some(val) = attr.value_str() {\n+                    let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                    if tcx.is_foreign_item(did) {\n+                        codegen_fn_attrs.import_linkage = linkage;\n+                    } else {\n+                        codegen_fn_attrs.linkage = linkage;\n+                    }\n                 }\n             }\n-        } else if attr.has_name(sym::link_name) {\n-            codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.has_name(sym::link_ordinal) {\n-            link_ordinal_span = Some(attr.span);\n-            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n-                codegen_fn_attrs.link_ordinal = ordinal;\n-            }\n-        } else if attr.has_name(sym::no_sanitize) {\n-            no_sanitize_span = Some(attr.span);\n-            if let Some(list) = attr.meta_item_list() {\n-                for item in list.iter() {\n-                    if item.has_name(sym::address) {\n-                        codegen_fn_attrs.no_sanitize |=\n-                            SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS;\n-                    } else if item.has_name(sym::cfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n-                    } else if item.has_name(sym::kcfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n-                    } else if item.has_name(sym::memory) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.has_name(sym::memtag) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n-                    } else if item.has_name(sym::shadow_call_stack) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n-                    } else if item.has_name(sym::thread) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n-                    } else if item.has_name(sym::hwaddress) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+            sym::link_section => {\n+                if let Some(val) = attr.value_str() {\n+                    if val.as_str().bytes().any(|b| b == 0) {\n+                        let msg = format!(\n+                            \"illegal null byte in link_section \\\n+                             value: `{}`\",\n+                            &val\n+                        );\n+                        tcx.sess.span_err(attr.span, &msg);\n                     } else {\n-                        tcx.sess\n-                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                            .emit();\n+                        codegen_fn_attrs.link_section = Some(val);\n                     }\n                 }\n             }\n-        } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = attr.meta_item_list().and_then(|l| match &l[..] {\n-                [NestedMetaItem::MetaItem(set)] => {\n-                    let segments =\n-                        set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                    match segments.as_slice() {\n-                        [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                            if !tcx.sess.target.has_thumb_interworking {\n-                                struct_span_err!(\n-                                    tcx.sess.diagnostic(),\n-                                    attr.span,\n-                                    E0779,\n-                                    \"target does not support `#[instruction_set]`\"\n-                                )\n+            sym::link_name => {\n+                codegen_fn_attrs.link_name = attr.value_str();\n+            }\n+            sym::link_ordinal => {\n+                link_ordinal_span = Some(attr.span);\n+                if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n+                    codegen_fn_attrs.link_ordinal = ordinal;\n+                }\n+            }\n+            sym::no_sanitize => {\n+                no_sanitize_span = Some(attr.span);\n+                if let Some(list) = attr.meta_item_list() {\n+                    for item in list.iter() {\n+                        match item.ident().map(|ident| ident.name) {\n+                            Some(sym::address) => {\n+                                codegen_fn_attrs.no_sanitize |=\n+                                    SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS;\n+                            }\n+                            Some(sym::cfi) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                            }\n+                            Some(sym::kcfi) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n+                            }\n+                            Some(sym::memory) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n+                            }\n+                            Some(sym::memtag) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n+                            }\n+                            Some(sym::shadow_call_stack) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n+                            }\n+                            Some(sym::thread) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n+                            }\n+                            Some(sym::hwaddress) => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+                            }\n+                            _ => {\n+                                tcx.sess\n+                                .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                                .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n                                 .emit();\n-                                None\n-                            } else if segments[1] == sym::a32 {\n-                                Some(InstructionSetAttr::ArmA32)\n-                            } else if segments[1] == sym::t32 {\n-                                Some(InstructionSetAttr::ArmT32)\n-                            } else {\n-                                unreachable!()\n                             }\n                         }\n-                        _ => {\n-                            struct_span_err!(\n-                                tcx.sess.diagnostic(),\n-                                attr.span,\n-                                E0779,\n-                                \"invalid instruction set specified\",\n-                            )\n-                            .emit();\n-                            None\n-                        }\n                     }\n                 }\n-                [] => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0778,\n-                        \"`#[instruction_set]` requires an argument\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0779,\n-                        \"cannot specify more than one instruction set\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            })\n-        } else if attr.has_name(sym::repr) {\n-            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n-                Some(items) => match items.as_slice() {\n-                    [item] => match item.name_value_literal() {\n-                        Some((sym::align, literal)) => {\n-                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n-\n-                            match alignment {\n-                                Ok(align) => Some(align),\n-                                Err(msg) => {\n+            }\n+            sym::instruction_set => {\n+                codegen_fn_attrs.instruction_set =\n+                    attr.meta_item_list().and_then(|l| match &l[..] {\n+                        [NestedMetaItem::MetaItem(set)] => {\n+                            let segments =\n+                                set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                            match segments.as_slice() {\n+                                [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                                    if !tcx.sess.target.has_thumb_interworking {\n+                                        struct_span_err!(\n+                                            tcx.sess.diagnostic(),\n+                                            attr.span,\n+                                            E0779,\n+                                            \"target does not support `#[instruction_set]`\"\n+                                        )\n+                                        .emit();\n+                                        None\n+                                    } else if segments[1] == sym::a32 {\n+                                        Some(InstructionSetAttr::ArmA32)\n+                                    } else if segments[1] == sym::t32 {\n+                                        Some(InstructionSetAttr::ArmT32)\n+                                    } else {\n+                                        unreachable!()\n+                                    }\n+                                }\n+                                _ => {\n                                     struct_span_err!(\n                                         tcx.sess.diagnostic(),\n                                         attr.span,\n-                                        E0589,\n-                                        \"invalid `repr(align)` attribute: {}\",\n-                                        msg\n+                                        E0779,\n+                                        \"invalid instruction set specified\",\n                                     )\n                                     .emit();\n-\n                                     None\n                                 }\n                             }\n                         }\n-                        _ => None,\n-                    },\n-                    [] => None,\n-                    _ => None,\n-                },\n-                None => None,\n-            };\n+                        [] => {\n+                            struct_span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0778,\n+                                \"`#[instruction_set]` requires an argument\"\n+                            )\n+                            .emit();\n+                            None\n+                        }\n+                        _ => {\n+                            struct_span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0779,\n+                                \"cannot specify more than one instruction set\"\n+                            )\n+                            .emit();\n+                            None\n+                        }\n+                    })\n+            }\n+            sym::repr => {\n+                codegen_fn_attrs.alignment = if let Some(items) = attr.meta_item_list()\n+                    && let [item] = items.as_slice()\n+                    && let Some((sym::align, literal)) = item.name_value_literal()\n+                {\n+                    rustc_attr::parse_alignment(&literal.kind).map_err(|msg| {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0589,\n+                            \"invalid `repr(align)` attribute: {}\",\n+                            msg\n+                        )\n+                        .emit();\n+                    })\n+                    .ok()\n+                } else {\n+                    None\n+                };\n+            }\n+            _ => {}\n         }\n     }\n "}]}