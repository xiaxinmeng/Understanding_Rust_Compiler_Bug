{"sha": "bc61541423a3281b6305de1616939c9ead42364d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNjE1NDE0MjNhMzI4MWI2MzA1ZGUxNjE2OTM5YzllYWQ0MjM2NGQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-09T21:14:31Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-16T14:57:34Z"}, "message": "Make us error consistently in issue #21232, to fix #54986.\n\nTreat attempt to partially intialize local `l` as uses of a `mut` in `let mut l;`, to fix #54499.", "tree": {"sha": "7b1766127c2e0a456e71d4dc5ca310e69e2d3c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b1766127c2e0a456e71d4dc5ca310e69e2d3c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc61541423a3281b6305de1616939c9ead42364d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc61541423a3281b6305de1616939c9ead42364d", "html_url": "https://github.com/rust-lang/rust/commit/bc61541423a3281b6305de1616939c9ead42364d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc61541423a3281b6305de1616939c9ead42364d/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44a2f681a988eb5587bd98a0cb37730fbd33f576", "url": "https://api.github.com/repos/rust-lang/rust/commits/44a2f681a988eb5587bd98a0cb37730fbd33f576", "html_url": "https://github.com/rust-lang/rust/commit/44a2f681a988eb5587bd98a0cb37730fbd33f576"}], "stats": {"total": 129, "additions": 109, "deletions": 20}, "files": [{"sha": "546746aa72ebb9a929c9393439882d8c253c709a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bc61541423a3281b6305de1616939c9ead42364d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc61541423a3281b6305de1616939c9ead42364d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=bc61541423a3281b6305de1616939c9ead42364d", "patch": "@@ -51,16 +51,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         desired_action: InitializationRequiringAction,\n-        (place, span): (&Place<'tcx>, Span),\n+        (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n-            \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} place={:?} \\\n-             span={:?} mpi={:?}\",\n-            context, desired_action, place, span, mpi\n+            \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} \\\n+             moved_place={:?} used_place={:?} span={:?} mpi={:?}\",\n+            context, desired_action, moved_place, used_place, span, mpi\n         );\n \n-        let use_spans = self.move_spans(place, context.loc)\n+        let use_spans = self.move_spans(moved_place, context.loc)\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n@@ -75,7 +75,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .collect();\n \n         if move_out_indices.is_empty() {\n-            let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n+            let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n \n             if self.uninitialized_error_reported\n                 .contains(&root_place.clone())\n@@ -89,14 +89,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             self.uninitialized_error_reported.insert(root_place.clone());\n \n-            let item_msg = match self.describe_place_with_options(place, IncludingDowncast(true)) {\n+            let item_msg = match self.describe_place_with_options(used_place,\n+                                                                  IncludingDowncast(true)) {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n-                &self.describe_place_with_options(place, IncludingDowncast(true))\n+                &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n                     .unwrap_or(\"_\".to_owned()),\n                 Origin::Mir,\n             );\n@@ -111,7 +112,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         } else {\n             if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n                 if self.prefixes(&reported_place, PrefixSet::All)\n-                    .any(|p| p == place)\n+                    .any(|p| p == used_place)\n                 {\n                     debug!(\n                         \"report_use_of_moved_or_uninitialized place: error suppressed \\\n@@ -128,7 +129,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n-                self.describe_place_with_options(&place, IncludingDowncast(true)),\n+                self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n                 Origin::Mir,\n             );\n \n@@ -181,7 +182,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            if let Some(ty) = self.retrieve_type_for_place(place) {\n+            if let Some(ty) = self.retrieve_type_for_place(used_place) {\n                 let needs_note = match ty.sty {\n                     ty::Closure(id, _) => {\n                         let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -219,7 +220,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n \n             if let Some((_, mut old_err)) = self.move_error_reported\n-                .insert(move_out_indices, (place.clone(), err))\n+                .insert(move_out_indices, (used_place.clone(), err))\n             {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();"}, {"sha": "108d480be9a33c320c14dcd2c0d28e3ebdc82641", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 96, "deletions": 8, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/bc61541423a3281b6305de1616939c9ead42364d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc61541423a3281b6305de1616939c9ead42364d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=bc61541423a3281b6305de1616939c9ead42364d", "patch": "@@ -853,6 +853,7 @@ enum InitializationRequiringAction {\n     MatchOn,\n     Use,\n     Assignment,\n+    PartialAssignment,\n }\n \n struct RootPlace<'d, 'tcx: 'd> {\n@@ -868,6 +869,7 @@ impl InitializationRequiringAction {\n             InitializationRequiringAction::MatchOn => \"use\", // no good noun\n             InitializationRequiringAction::Use => \"use\",\n             InitializationRequiringAction::Assignment => \"assign\",\n+            InitializationRequiringAction::PartialAssignment => \"assign to part\",\n         }\n     }\n \n@@ -878,6 +880,7 @@ impl InitializationRequiringAction {\n             InitializationRequiringAction::MatchOn => \"matched on\",\n             InitializationRequiringAction::Use => \"used\",\n             InitializationRequiringAction::Assignment => \"assigned\",\n+            InitializationRequiringAction::PartialAssignment => \"partially assigned\",\n         }\n     }\n }\n@@ -1498,12 +1501,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         debug!(\"check_if_full_path_is_moved place: {:?}\", place_span.0);\n         match self.move_path_closest_to(place_span.0) {\n-            Ok(mpi) => {\n+            Ok((prefix, mpi)) => {\n                 if maybe_uninits.contains(mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n                         context,\n                         desired_action,\n-                        place_span,\n+                        (prefix, place_span.0, place_span.1),\n                         mpi,\n                     );\n                     return; // don't bother finding other problems.\n@@ -1561,7 +1564,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.report_use_of_moved_or_uninitialized(\n                     context,\n                     desired_action,\n-                    place_span,\n+                    (place_span.0, place_span.0, place_span.1),\n                     child_mpi,\n                 );\n                 return; // don't bother finding other problems.\n@@ -1579,14 +1582,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currently this can only occur if the place is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(\n+    fn move_path_closest_to<'a>(\n         &mut self,\n-        place: &Place<'tcx>,\n-    ) -> Result<MovePathIndex, NoMovePathFound> {\n+        place: &'a Place<'tcx>,\n+    ) -> Result<(&'a Place<'tcx>, MovePathIndex), NoMovePathFound> where 'cx: 'a {\n         let mut last_prefix = place;\n         for prefix in self.prefixes(place, PrefixSet::All) {\n             if let Some(mpi) = self.move_path_for_place(prefix) {\n-                return Ok(mpi);\n+                return Ok((prefix, mpi));\n             }\n             last_prefix = prefix;\n         }\n@@ -1667,6 +1670,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // recur further)\n                                     break;\n                                 }\n+\n+\n+                                // Once `let s; s.x = V; read(s.x);`,\n+                                // is allowed, remove this match arm.\n+                                ty::Adt(..) | ty::Tuple(..) => {\n+                                    check_parent_of_field(self, context, base, span, flow_state);\n+\n+                                    if let Some(local) = place.base_local() {\n+                                        // rust-lang/rust#21232,\n+                                        // #54499, #54986: during\n+                                        // period where we reject\n+                                        // partial initialization, do\n+                                        // not complain about\n+                                        // unnecessary `mut` on an\n+                                        // attempt to do a partial\n+                                        // initialization.\n+                                        self.used_mut.insert(local);\n+                                    }\n+                                }\n+\n                                 _ => {}\n                             }\n                         }\n@@ -1677,8 +1700,73 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-    }\n \n+        fn check_parent_of_field<'cx, 'gcx, 'tcx>(this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+                                                  context: Context,\n+                                                  base: &Place<'tcx>,\n+                                                  span: Span,\n+                                                  flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+        {\n+            // rust-lang/rust#21232: Until Rust allows reads from the\n+            // initialized parts of partially initialized structs, we\n+            // will, starting with the 2018 edition, reject attempts\n+            // to write to structs that are not fully initialized.\n+            //\n+            // In other words, *until* we allow this:\n+            //\n+            // 1. `let mut s; s.x = Val; read(s.x);`\n+            //\n+            // we will for now disallow this:\n+            //\n+            // 2. `let mut s; s.x = Val;`\n+            //\n+            // and also this:\n+            //\n+            // 3. `let mut s = ...; drop(s); s.x=Val;`\n+            //\n+            // This does not use check_if_path_or_subpath_is_moved,\n+            // because we want to *allow* reinitializations of fields:\n+            // e.g. want to allow\n+            //\n+            // `let mut s = ...; drop(s.x); s.x=Val;`\n+            //\n+            // This does not use check_if_full_path_is_moved on\n+            // `base`, because that would report an error about the\n+            // `base` as a whole, but in this scenario we *really*\n+            // want to report an error about the actual thing that was\n+            // moved, which may be some prefix of `base`.\n+\n+            // Shallow so that we'll stop at any dereference; we'll\n+            // report errors about issues with such bases elsewhere.\n+            let maybe_uninits = &flow_state.uninits;\n+\n+            // Find the shortest uninitialized prefix you can reach\n+            // without going over a Deref.\n+            let mut shortest_uninit_seen = None;\n+            for prefix in this.prefixes(base, PrefixSet::Shallow) {\n+                let mpi = match this.move_path_for_place(prefix) {\n+                    Some(mpi) => mpi, None => continue,\n+                };\n+\n+                if maybe_uninits.contains(mpi) {\n+                    debug!(\"check_parent_of_field updating shortest_uninit_seen from {:?} to {:?}\",\n+                           shortest_uninit_seen, Some((prefix, mpi)));\n+                    shortest_uninit_seen = Some((prefix, mpi));\n+                } else {\n+                    debug!(\"check_parent_of_field {:?} is definitely initialized\", (prefix, mpi));\n+                }\n+            }\n+\n+            if let Some((prefix, mpi)) = shortest_uninit_seen {\n+                this.report_use_of_moved_or_uninitialized(\n+                    context,\n+                    InitializationRequiringAction::PartialAssignment,\n+                    (prefix, base, span),\n+                    mpi,\n+                );\n+            }\n+        }\n+    }\n \n     /// Check the permissions for the given place and read or write kind\n     ///"}]}