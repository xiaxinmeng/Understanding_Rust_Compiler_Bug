{"sha": "713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMzAwNmM3YjZhZmMyNWVmOTBlY2Y3OGY4OGM5ZTlhYmIzMWY0Yjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-07T04:48:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-07T15:47:50Z"}, "message": "add mutability annotations to libcore", "tree": {"sha": "0fce77db8dec6394aa9bab7bb2b3a9df303fc95d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fce77db8dec6394aa9bab7bb2b3a9df303fc95d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "html_url": "https://github.com/rust-lang/rust/commit/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "674587cfe5a871336f6337eabae75b20882faff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/674587cfe5a871336f6337eabae75b20882faff5", "html_url": "https://github.com/rust-lang/rust/commit/674587cfe5a871336f6337eabae75b20882faff5"}], "stats": {"total": 402, "additions": 204, "deletions": 198}, "files": [{"sha": "280464e35f502c165cd89a76a7be1690b46a0462", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -180,7 +180,7 @@ fn select2<A: send, B: send>(\n         rustrt::rust_port_select(dptr, ports, n_ports, yield)\n     }\n \n-    let ports = [];\n+    let mut ports = [];\n     ports += [***p_a, ***p_b];\n     let n_ports = 2 as ctypes::size_t;\n     let yield = 0u;"}, {"sha": "0daee24650db3eace6539d216240a342d7462a38", "filename": "src/libcore/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -40,7 +40,7 @@ Function: lefts\n Extracts from a vector of either all the left values.\n */\n fn lefts<T: copy, U>(eithers: [t<T, U>]) -> [T] {\n-    let result: [T] = [];\n+    let mut result: [T] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n     }\n@@ -53,7 +53,7 @@ Function: rights\n Extracts from a vector of either all the right values\n */\n fn rights<T, U: copy>(eithers: [t<T, U>]) -> [U] {\n-    let result: [U] = [];\n+    let mut result: [U] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n     }\n@@ -70,8 +70,8 @@ right values.\n */\n fn partition<T: copy, U: copy>(eithers: [t<T, U>])\n     -> {lefts: [T], rights: [U]} {\n-    let lefts: [T] = [];\n-    let rights: [U] = [];\n+    let mut lefts: [T] = [];\n+    let mut rights: [U] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { lefts += [l]; } right(r) { rights += [r]; } }\n     }"}, {"sha": "106b478e9bfa9412a3d81b0a863afe615d3a7581", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -81,17 +81,17 @@ mod ct {\n     type error_fn = fn@(str) -> ! ;\n \n     fn parse_fmt_string(s: str, error: error_fn) -> [piece] unsafe {\n-        let pieces: [piece] = [];\n+        let mut pieces: [piece] = [];\n         let lim = str::len(s);\n-        let buf = \"\";\n+        let mut buf = \"\";\n         fn flush_buf(buf: str, &pieces: [piece]) -> str {\n             if str::len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];\n             }\n             ret \"\";\n         }\n-        let i = 0u;\n+        let mut i = 0u;\n         while i < lim {\n             let curr = str::slice(s, i, i+1u);\n             if str::eq(curr, \"%\") {\n@@ -285,7 +285,7 @@ mod rt {\n     fn conv_int(cv: conv, i: int) -> str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n-        let s = int_to_str_prec(i, radix, prec);\n+        let mut s = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n                 s = \"+\" + s;\n@@ -335,7 +335,7 @@ mod rt {\n               count_is(c) { (float::to_str_exact, c as uint) }\n               count_implied { (float::to_str, 6u) }\n         };\n-        let s = to_str(f, digits);\n+        let mut s = to_str(f, digits);\n         if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 s = \"+\" + s;\n@@ -389,42 +389,38 @@ mod rt {\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, }\n     fn pad(cv: conv, s: str, mode: pad_mode) -> str unsafe {\n-        let uwidth;\n-        alt cv.width {\n+        let uwidth = alt cv.width {\n           count_implied { ret s; }\n           count_is(width) {\n             // FIXME: Maybe width should be uint\n-\n-            uwidth = width as uint;\n+            width as uint\n           }\n-        }\n+        };\n         let strlen = str::char_len(s);\n         if uwidth <= strlen { ret s; }\n-        let padchar = ' ';\n+        let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n             let padstr = str_init_elt(diff, padchar);\n             ret s + padstr;\n         }\n-        let might_zero_pad = false;\n-        let signed = false;\n-        alt mode {\n-          pad_nozero {\n-            // fallthrough\n-\n-          }\n-          pad_signed { might_zero_pad = true; signed = true; }\n-          pad_unsigned { might_zero_pad = true; }\n-        }\n+        let {might_zero_pad, signed} = alt mode {\n+          pad_nozero {   {might_zero_pad:false, signed:false} }\n+          pad_signed {   {might_zero_pad:true,  signed:true } }\n+          pad_unsigned { {might_zero_pad:true,  signed:false} }\n+        };\n         fn have_precision(cv: conv) -> bool {\n             ret alt cv.precision { count_implied { false } _ { true } };\n         }\n-        let zero_padding = false;\n-        if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-               !have_precision(cv) {\n-            padchar = '0';\n-            zero_padding = true;\n-        }\n+        let zero_padding = {\n+            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+                !have_precision(cv) {\n+                padchar = '0';\n+                true\n+            } else {\n+                false\n+            }\n+        };\n         let padstr = str_init_elt(diff, padchar);\n         // This is completely heinous. If we have a signed value then\n         // potentially rip apart the intermediate result and insert some"}, {"sha": "09aa575e0032ae55d5d64893604f2f5c394303df", "filename": "src/libcore/float.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -49,14 +49,14 @@ exact - Whether to enforce the exact number of significant digits\n */\n fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     if is_NaN(num) { ret \"NaN\"; }\n-    let (num, accum) = if num < 0.0 { (-num, \"-\") } else { (num, \"\") };\n+    let mut (num, accum) = if num < 0.0 { (-num, \"-\") } else { (num, \"\") };\n     let trunc = num as uint;\n-    let frac = num - (trunc as float);\n+    let mut frac = num - (trunc as float);\n     accum += uint::str(trunc);\n     if (frac < epsilon && !exact) || digits == 0u { ret accum; }\n     accum += \".\";\n-    let i = digits;\n-    let epsilon = 1. / pow_with_uint(10u, i);\n+    let mut i = digits;\n+    let mut epsilon = 1. / pow_with_uint(10u, i);\n     while i > 0u && (frac >= epsilon || exact) {\n         frac *= 10.0;\n         epsilon *= 10.0;\n@@ -132,13 +132,13 @@ Otherwise, some(n) where n is the floating-point\n number represented by [num].\n */\n fn from_str(num: str) -> option<float> {\n-   let pos = 0u;                  //Current byte position in the string.\n-                                  //Used to walk the string in O(n).\n-   let len = str::len(num);  //Length of the string, in bytes.\n+   let mut pos = 0u;               //Current byte position in the string.\n+                                   //Used to walk the string in O(n).\n+   let len = str::len(num);        //Length of the string, in bytes.\n \n    if len == 0u { ret none; }\n-   let total = 0f;                //Accumulated result\n-   let c     = 'z';               //Latest char.\n+   let mut total = 0f;             //Accumulated result\n+   let mut c     = 'z';            //Latest char.\n \n    //The string must start with one of the following characters.\n    alt str::char_at(num, 0u) {\n@@ -147,7 +147,7 @@ fn from_str(num: str) -> option<float> {\n    }\n \n    //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n-   let neg = false;               //Sign of the result\n+   let mut neg = false;               //Sign of the result\n    alt str::char_at(num, 0u) {\n       '-' {\n           neg = true;\n@@ -179,7 +179,7 @@ fn from_str(num: str) -> option<float> {\n    }\n \n    if c == '.' {//Examine decimal part\n-      let decimal = 1f;\n+      let mut decimal = 1f;\n       while(pos < len) {\n          let char_range = str::char_range_at(num, pos);\n          c = char_range.ch;\n@@ -200,8 +200,8 @@ fn from_str(num: str) -> option<float> {\n    }\n \n    if (c == 'e') | (c == 'E') {//Examine exponent\n-      let exponent = 0u;\n-      let neg_exponent = false;\n+      let mut exponent = 0u;\n+      let mut neg_exponent = false;\n       if(pos < len) {\n           let char_range = str::char_range_at(num, pos);\n           c   = char_range.ch;\n@@ -275,9 +275,9 @@ fn pow_with_uint(base: uint, pow: uint) -> float {\n       }\n        ret 0.;\n    }\n-   let my_pow     = pow;\n-   let total      = 1f;\n-   let multiplier = base as float;\n+   let mut my_pow     = pow;\n+   let mut total      = 1f;\n+   let mut multiplier = base as float;\n    while (my_pow > 0u) {\n      if my_pow % 2u == 1u {\n        total = total * multiplier;"}, {"sha": "43d0e55edf0ef008a7a3863f915fdd297e7018c1", "filename": "src/libcore/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -93,7 +93,7 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n \n     \"];\n \n-    let po = comm::port();\n+    let mut po = comm::port();\n     let ch = comm::chan(po);\n     task::spawn {||\n         comm::send(ch, blk())"}, {"sha": "b3f10a3a9796efa52f782dc4bd98f10c7985dcfb", "filename": "src/libcore/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fi16.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -26,7 +26,7 @@ pure fn nonnegative(x: i16) -> bool { x >= 0i16 }\n \n #[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: i16, hi: i16, it: fn(i16)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1i16; }\n }\n "}, {"sha": "1e151f5d39dea52e858208b401721fcf8d248928", "filename": "src/libcore/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fi32.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -26,7 +26,7 @@ pure fn nonnegative(x: i32) -> bool { x >= 0i32 }\n \n #[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: i32, hi: i32, it: fn(i32)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1i32; }\n }\n "}, {"sha": "1eecf56c0b7687fb18a5d17bca30f0f3a87ee031", "filename": "src/libcore/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fi64.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -26,7 +26,7 @@ pure fn nonnegative(x: i64) -> bool { x >= 0i64 }\n \n #[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: i64, hi: i64, it: fn(i64)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1i64; }\n }\n "}, {"sha": "f88ca0f58924e855882596756c5fb734c5552421", "filename": "src/libcore/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fi8.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -26,7 +26,7 @@ pure fn nonnegative(x: i8) -> bool { x >= 0i8 }\n \n #[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: i8, hi: i8, it: fn(i8)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1i8; }\n }\n "}, {"sha": "8c3b8f195f7ece216bc439694a1b77e2216dfcb1", "filename": "src/libcore/int.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -90,7 +90,7 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: int, hi: int, it: fn(int)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1; }\n }\n \n@@ -106,15 +106,15 @@ radix - The base of the number\n */\n fn parse_buf(buf: [u8], radix: uint) -> option<int> {\n     if vec::len(buf) == 0u { ret none; }\n-    let i = vec::len(buf) - 1u;\n-    let start = 0u;\n-    let power = 1;\n+    let mut i = vec::len(buf) - 1u;\n+    let mut start = 0u;\n+    let mut power = 1;\n \n     if buf[0] == ('-' as u8) {\n         power = -1;\n         start = 1u;\n     }\n-    let n = 0;\n+    let mut n = 0;\n     while true {\n         alt char::to_digit(buf[i] as char, radix) {\n           some(d) { n += (d as int) * power; }\n@@ -161,9 +161,9 @@ Returns `base` raised to the power of `exponent`\n fn pow(base: int, exponent: uint) -> int {\n     if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n     if base     == 0  { ret 0; }\n-    let my_pow  = exponent;\n-    let acc     = 1;\n-    let multiplier = base;\n+    let mut my_pow  = exponent;\n+    let mut acc     = 1;\n+    let mut multiplier = base;\n     while(my_pow > 0u) {\n       if my_pow % 2u == 1u {\n          acc *= multiplier;"}, {"sha": "7fd98d6e97cd22d8782d25f3c5fc75ca25985e41", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -40,7 +40,7 @@ impl of iterable<char> for str {\n }\n \n fn enumerate<A,IA:iterable<A>>(self: IA, blk: fn(uint, A)) {\n-    let i = 0u;\n+    let mut i = 0u;\n     self.iter {|a|\n         blk(i, a);\n         i += 1u;\n@@ -82,7 +82,7 @@ fn flat_map<A,B,IA:iterable<A>,IB:iterable<B>>(\n }\n \n fn foldl<A,B,IA:iterable<A>>(self: IA, +b0: B, blk: fn(-B, A) -> B) -> B {\n-    let b <- b0;\n+    let mut b <- b0;\n     self.iter {|a|\n         b = blk(b, a);\n     }\n@@ -92,7 +92,7 @@ fn foldl<A,B,IA:iterable<A>>(self: IA, +b0: B, blk: fn(-B, A) -> B) -> B {\n fn foldr<A:copy,B,IA:iterable<A>>(\n     self: IA, +b0: B, blk: fn(A, -B) -> B) -> B {\n \n-    let b <- b0;\n+    let mut b <- b0;\n     reversed(self) {|a|\n         b = blk(a, b);\n     }\n@@ -119,7 +119,7 @@ fn count<A,IA:iterable<A>>(self: IA, x: A) -> uint {\n }\n \n fn repeat(times: uint, blk: fn()) {\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < times {\n         blk();\n         i += 1u;"}, {"sha": "f6b36f71bde3e6ee9bd8cb8051380cf46ace3f5c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -41,7 +41,7 @@ native mod rustrt {\n \n \n fn env() -> [(str,str)] {\n-    let pairs = [];\n+    let mut pairs = [];\n     for p in rustrt::rust_env_pairs() {\n         let vs = str::splitn_char(p, '=', 1u);\n         assert vec::len(vs) == 2u;\n@@ -87,7 +87,7 @@ mod win32 {\n     }\n \n     fn as_utf16_p<T>(s: str, f: fn(*u16) -> T) -> T {\n-        let t = str::to_utf16(s);\n+        let mut t = str::to_utf16(s);\n         // Null terminate before passing on.\n         t += [0u16];\n         vec::as_buf(t, f)\n@@ -468,13 +468,13 @@ fn list_dir(p: path) -> [str] {\n     #[cfg(target_os = \"win32\")]\n     fn star() -> str { \"*\" }\n \n-    let p = p;\n+    let mut p = p;\n     let pl = str::len(p);\n     if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n                     && p[pl - 1u] as char != path::consts::alt_path_sep) {\n         p += path::path_sep();\n     }\n-    let full_paths: [str] = [];\n+    let mut full_paths: [str] = [];\n     for filename: str in rustrt::rust_list_files(p + star()) {\n         if !str::eq(filename, \".\") {\n             if !str::eq(filename, \"..\") {"}, {"sha": "d03de47fa9519b826d029568fb77826839b32e24", "filename": "src/libcore/path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -112,8 +112,8 @@ with a single path separator between them.\n */\n \n fn connect(pre: path, post: path) -> path unsafe {\n-    let pre_ = pre;\n-    let post_ = post;\n+    let mut pre_ = pre;\n+    let mut post_ = post;\n     let sep = consts::path_sep as u8;\n     let pre_len  = str::len(pre);\n     let post_len = str::len(post);\n@@ -246,9 +246,9 @@ fn normalize(p: path) -> path {\n             ret [];\n         }\n \n-        let t = [];\n-        let i = vec::len(s);\n-        let skip = 0;\n+        let mut t = [];\n+        let mut i = vec::len(s);\n+        let mut skip = 0;\n         do {\n             i -= 1u;\n             if s[i] == \"..\" {\n@@ -261,7 +261,7 @@ fn normalize(p: path) -> path {\n                 }\n             }\n         } while i != 0u;\n-        let t = vec::reversed(t);\n+        let mut t = vec::reversed(t);\n         while skip > 0 {\n             t += [\"..\"];\n             skip -= 1;"}, {"sha": "0325e90c18bff2e247a129e19348ff4bc51c9963", "filename": "src/libcore/str.rs", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -127,7 +127,7 @@ Convert a byte to a UTF-8 string.  Fails if invalid UTF-8.\n */\n fn from_byte(b: u8) -> str unsafe {\n     assert b < 128u8;\n-    let v = [b, 0u8];\n+    let mut v = [b, 0u8];\n     let s: str = ::unsafe::reinterpret_cast(v);\n     ::unsafe::leak(v);\n     s\n@@ -176,7 +176,7 @@ Function: from_char\n Convert a char to a string\n */\n fn from_char(ch: char) -> str {\n-    let buf = \"\";\n+    let mut buf = \"\";\n     push_char(buf, ch);\n     ret buf;\n }\n@@ -187,7 +187,7 @@ Function: from_chars\n Convert a vector of chars to a string\n */\n fn from_chars(chs: [char]) -> str {\n-    let buf = \"\";\n+    let mut buf = \"\";\n     reserve(buf, chs.len());\n     for ch in chs { push_char(buf, ch); }\n     ret buf;\n@@ -199,7 +199,7 @@ Function: from_cstr\n Create a Rust string from a null-terminated C string\n */\n fn from_cstr(cstr: sbuf) -> str unsafe {\n-    let curr = cstr, i = 0u;\n+    let mut curr = cstr, i = 0u;\n     while *curr != 0u8 {\n         i += 1u;\n         curr = ptr::offset(cstr, i);\n@@ -213,7 +213,7 @@ Function: from_cstr_len\n Create a Rust string from a C string of the given length\n */\n fn from_cstr_len(cstr: sbuf, len: uint) -> str unsafe {\n-    let buf: [u8] = [];\n+    let mut buf: [u8] = [];\n     vec::reserve(buf, len + 1u);\n     vec::as_buf(buf) {|b| ptr::memcpy(b, cstr, len); }\n     vec::unsafe::set_len(buf, len);\n@@ -231,7 +231,7 @@ Function: concat\n Concatenate a vector of strings\n */\n fn concat(v: [str]) -> str {\n-    let s: str = \"\";\n+    let mut s: str = \"\";\n     for ss: str in v { s += ss; }\n     ret s;\n }\n@@ -242,7 +242,7 @@ Function: connect\n Concatenate a vector of strings, placing a given separator between each\n */\n fn connect(v: [str], sep: str) -> str {\n-    let s = \"\", first = true;\n+    let mut s = \"\", first = true;\n     for ss: str in v {\n         if first { first = false; } else { s += sep; }\n         s += ss;\n@@ -350,7 +350,8 @@ Function: chars\n Convert a string to a vector of characters\n */\n fn chars(s: str) -> [char] {\n-    let buf = [], i = 0u, len = len(s);\n+    let mut buf = [], i = 0u;\n+    let len = len(s);\n     while i < len {\n         let {ch, next} = char_range_at(s, i);\n         buf += [ch];\n@@ -408,8 +409,9 @@ fn split_char_nonempty(s: str, sep: char) -> [str] {\n fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n     -> [str] unsafe {\n     if sep < 128u as char {\n-        let result = [], b = sep as u8, l = len(s), done = 0u;\n-        let i = 0u, start = 0u;\n+        let b = sep as u8, l = len(s);\n+        let mut result = [], done = 0u;\n+        let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n@@ -458,7 +460,8 @@ fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n \n fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> [str] unsafe {\n-    let result = [], i = 0u, l = len(s), start = 0u, done = 0u;\n+    let l = len(s);\n+    let mut result = [], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n@@ -480,7 +483,7 @@ fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n-    let i = 0u, match_start = 0u, match_i = 0u;\n+    let mut i = 0u, match_start = 0u, match_i = 0u;\n \n     while i < l {\n         if s[i] == sep[match_i] {\n@@ -505,7 +508,7 @@ fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n }\n \n fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n-    let last_end = 0u;\n+    let mut last_end = 0u;\n     iter_matches(s, sep) {|from, to|\n         f(last_end, from);\n         last_end = to;\n@@ -522,15 +525,15 @@ Note that this has recently been changed.  For example:\n >  assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n */\n fn split_str(s: str, sep: str) -> [str] {\n-    let result = [];\n+    let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n     }\n     result\n }\n \n fn split_str_nonempty(s: str, sep: str) -> [str] {\n-    let result = [];\n+    let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n             unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n@@ -555,7 +558,8 @@ separated by LF ('\\n') and/or CR LF ('\\r\\n')\n */\n fn lines_any(s: str) -> [str] {\n     vec::map(lines(s), {|s|\n-        let l = len(s), cp = s;\n+        let l = len(s);\n+        let mut cp = s;\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n             unsafe { unsafe::set_len(cp, l - 1u); }\n         }\n@@ -607,7 +611,7 @@ Returns:\n The original string with all occurances of `from` replaced with `to`\n */\n fn replace(s: str, from: str, to: str) -> str unsafe {\n-    let result = \"\", first = true;\n+    let mut result = \"\", first = true;\n     iter_between_matches(s, from) {|start, end|\n         if first { first = false; } else { result += to; }\n         unsafe { result += unsafe::slice_bytes(s, start, end); }\n@@ -641,7 +645,7 @@ String hash function\n fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n-    let u: uint = 5381u;\n+    let mut u: uint = 5381u;\n     for c: u8 in s { u *= 33u; u += c as uint; }\n     ret u;\n }\n@@ -676,7 +680,7 @@ Function: map\n Apply a function to each character\n */\n fn map(ss: str, ff: fn(char) -> char) -> str {\n-    let result = \"\";\n+    let mut result = \"\";\n     reserve(result, len(ss));\n     chars_iter(ss) {|cc| str::push_char(result, ff(cc));}\n     result\n@@ -688,7 +692,7 @@ Function: bytes_iter\n Iterate over the bytes in a string\n */\n fn bytes_iter(ss: str, it: fn(u8)) {\n-    let pos = 0u;\n+    let mut pos = 0u;\n     let len = len(ss);\n \n     while (pos < len) {\n@@ -703,7 +707,8 @@ Function: chars_iter\n Iterate over the characters in a string\n */\n fn chars_iter(s: str, it: fn(char)) {\n-    let pos = 0u, len = len(s);\n+    let mut pos = 0u;\n+    let len = len(s);\n     while (pos < len) {\n         let {ch, next} = char_range_at(s, pos);\n         pos = next;\n@@ -778,7 +783,8 @@ fn find_char_between(s: str, c: char, start: uint, end: uint)\n     if c < 128u as char {\n         assert start <= end;\n         assert end <= len(s);\n-        let i = start, b = c as u8;\n+        let mut i = start;\n+        let b = c as u8;\n         while i < end {\n             if s[i] == b { ret some(i); }\n             i += 1u;\n@@ -815,7 +821,8 @@ fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n     if c < 128u as char {\n         assert start >= end;\n         assert start <= len(s);\n-        let i = start, b = c as u8;\n+        let mut i = start;\n+        let b = c as u8;\n         while i > end {\n             i -= 1u;\n             if s[i] == b { ret some(i); }\n@@ -851,7 +858,7 @@ fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     assert start <= end;\n     assert end <= len(s);\n     assert is_char_boundary(s, start);\n-    let i = start;\n+    let mut i = start;\n     while i < end {\n         let {ch, next} = char_range_at(s, i);\n         if f(ch) { ret some(i); }\n@@ -886,7 +893,7 @@ fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     assert start >= end;\n     assert start <= len(s);\n     assert is_char_boundary(s, start);\n-    let i = start;\n+    let mut i = start;\n     while i > end {\n         let {ch, prev} = char_range_at_reverse(s, i);\n         if f(ch) { ret some(prev); }\n@@ -897,7 +904,7 @@ fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n \n // Utility used by various searching functions\n fn match_at(haystack: str, needle: str, at: uint) -> bool {\n-    let i = at;\n+    let mut i = at;\n     for c in needle { if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n }\n@@ -931,7 +938,8 @@ fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n     if needle_len == 0u { ret some(start); }\n     if needle_len > end { ret none; }\n \n-    let i = start, e = end - needle_len;\n+    let mut i = start;\n+    let e = end - needle_len;\n     while i <= e {\n         if match_at(haystack, needle, i) { ret some(i); }\n         i += 1u;\n@@ -995,7 +1003,7 @@ Function: is_ascii\n Determines if a string contains only ASCII characters\n */\n fn is_ascii(s: str) -> bool {\n-    let i: uint = len(s);\n+    let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n@@ -1048,10 +1056,10 @@ Function: is_utf8\n Determines if a vector of bytes contains valid UTF-8\n */\n fn is_utf8(v: [const u8]) -> bool {\n-    let i = 0u;\n+    let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n-        let chsize = utf8_char_width(v[i]);\n+        let mut chsize = utf8_char_width(v[i]);\n         if chsize == 0u { ret false; }\n         if i + chsize > total { ret false; }\n         i += 1u;\n@@ -1067,7 +1075,7 @@ fn is_utf8(v: [const u8]) -> bool {\n \n fn is_utf16(v: [const u16]) -> bool {\n     let len = v.len();\n-    let i = 0u;\n+    let mut i = 0u;\n     while (i < len) {\n         let u = v[i];\n \n@@ -1085,12 +1093,11 @@ fn is_utf16(v: [const u16]) -> bool {\n     ret true;\n }\n \n-\n fn to_utf16(s: str) -> [u16] {\n-    let u = [];\n+    let mut u = [];\n     chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n-        let ch = cch as u32;\n+        let mut ch = cch as u32;\n \n         if (ch & 0xFFFF_u32) == ch {\n             // The BMP falls through (assuming non-surrogate, as it should)\n@@ -1110,9 +1117,9 @@ fn to_utf16(s: str) -> [u16] {\n \n fn utf16_chars(v: [const u16], f: fn(char)) {\n     let len = v.len();\n-    let i = 0u;\n+    let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n-        let u = v[i];\n+        let mut u = v[i];\n \n         if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n             f(u as char);\n@@ -1122,7 +1129,7 @@ fn utf16_chars(v: [const u16], f: fn(char)) {\n             let u2 = v[i+1u];\n             assert u >= 0xD800_u16 && u <= 0xDBFF_u16;\n             assert u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16;\n-            let c = (u - 0xD800_u16) as char;\n+            let mut c = (u - 0xD800_u16) as char;\n             c = c << 10;\n             c |= (u2 - 0xDC00_u16) as char;\n             c |= 0x1_0000_u32 as char;\n@@ -1134,7 +1141,7 @@ fn utf16_chars(v: [const u16], f: fn(char)) {\n \n \n fn from_utf16(v: [const u16]) -> str {\n-    let buf = \"\";\n+    let mut buf = \"\";\n     reserve(buf, v.len());\n     utf16_chars(v) {|ch| push_char(buf, ch); }\n     ret buf;\n@@ -1157,7 +1164,7 @@ Returns:\n fn count_chars(s: str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n-    let i = start, len = 0u;\n+    let mut i = start, len = 0u;\n     while i < end {\n         let {next, _} = char_range_at(s, i);\n         len += 1u;\n@@ -1172,7 +1179,8 @@ fn count_chars(s: str, start: uint, end: uint) -> uint {\n // `start`.\n fn count_bytes(s: str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n-    let end = start, cnt = n, l = len(s);\n+    let mut end = start, cnt = n;\n+    let l = len(s);\n     while cnt > 0u {\n         assert end < l;\n         let {next, _} = char_range_at(s, end);\n@@ -1260,9 +1268,9 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n     if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n-    let val = 0u;\n+    let mut val = 0u;\n     let end = i + w;\n-    let i = i + 1u;\n+    let mut i = i + 1u;\n     while i < end {\n         let byte = s[i];\n         assert (byte & 192u8 == tag_cont_u8);\n@@ -1289,7 +1297,7 @@ fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n // Given a byte position and a str, return the previous char and its position\n // This function can be used to iterate over a unicode string in reverse.\n fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n-    let prev = start;\n+    let mut prev = start;\n \n     // while there is a previous byte == 10......\n     while prev > 0u && ss[prev - 1u] & 192u8 == tag_cont_u8 {\n@@ -1327,7 +1335,7 @@ Safety note:\n  */\n fn all_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n-    let i = start;\n+    let mut i = start;\n     while i < end {\n         let {ch, next} = char_range_at(s, i);\n         if !it(ch) { ret false; }\n@@ -1366,7 +1374,7 @@ Example:\n \n */\n fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n-    let v: [u8] = ::unsafe::reinterpret_cast(s);\n+    let mut v: [u8] = ::unsafe::reinterpret_cast(s);\n     let r = f(v);\n     ::unsafe::leak(v);\n     r\n@@ -1421,7 +1429,7 @@ mod unsafe {\n    // Converts a vector of bytes to a string. Does not verify that the\n    // vector contains valid UTF-8.\n    unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n-       let vcopy: [u8] = v + [0u8];\n+       let mut vcopy: [u8] = v + [0u8];\n        let scopy: str = ::unsafe::reinterpret_cast(vcopy);\n        ::unsafe::leak(vcopy);\n        ret scopy;\n@@ -1448,7 +1456,7 @@ mod unsafe {\n        assert (begin <= end);\n        assert (end <= len(s));\n \n-       let v = as_bytes(s) { |v| vec::slice(v, begin, end) };\n+       let mut v = as_bytes(s) { |v| vec::slice(v, begin, end) };\n        v += [0u8];\n        let s: str = ::unsafe::reinterpret_cast(v);\n        ::unsafe::leak(v);"}, {"sha": "12a024117153364b907ab2157831e846cb515e22", "filename": "src/libcore/task.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -309,7 +309,7 @@ fn future_result(builder: task_builder) -> future::future<task_result> {\n fn future_task(builder: task_builder) -> future::future<task> {\n     #[doc = \"Get a future representing the handle to the new task\"];\n \n-    let po = comm::port();\n+    let mut po = comm::port();\n     let ch = comm::chan(po);\n     add_wrapper(builder) {|body|\n         fn~() {\n@@ -349,7 +349,7 @@ fn run_listener<A:send>(-builder: task_builder,\n \n     run(builder) {||\n         let po = comm::port();\n-        let ch = comm::chan(po);\n+        let mut ch = comm::chan(po);\n         comm::send(setup_ch, ch);\n         f(po);\n     }\n@@ -421,7 +421,7 @@ fn spawn_sched(mode: sched_mode, +f: fn~()) {\n \n     \")];\n \n-    let builder = mk_task_builder();\n+    let mut builder = mk_task_builder();\n     set_opts(builder, {\n         sched: some({\n             mode: mode,\n@@ -448,7 +448,7 @@ fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n \n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let builder = mk_task_builder();\n+    let mut builder = mk_task_builder();\n     unsupervise(builder);\n     let result = future_result(builder);\n     run(builder) {||\n@@ -467,7 +467,7 @@ fn yield() {\n     #[doc = \"Yield control to the task scheduler\"];\n \n     let task_ = rustrt::rust_get_task();\n-    let killed = false;\n+    let mut killed = false;\n     rusti::task_yield(task_, killed);\n     if killed && !failing() {\n         fail \"killed\";\n@@ -499,7 +499,7 @@ type rust_closure = ctypes::void;\n \n fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n \n-    let f = if opts.supervise {\n+    let mut f = if opts.supervise {\n         f\n     } else {\n         // FIXME: The runtime supervision API is weird here because it\n@@ -924,4 +924,4 @@ fn test_avoid_copying_the_body_unsupervise() {\n             f();\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "96ed71eae7e7079ca6b415ce39c68fa549ac8c35", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -37,7 +37,7 @@ impl <A: to_str copy, B: to_str copy, C: to_str copy> of to_str for (A, B, C){\n \n impl <A: to_str> of to_str for [A] {\n     fn to_str() -> str {\n-        let acc = \"[\", first = true;\n+        let mut acc = \"[\", first = true;\n         for elt in self {\n             if first { first = false; }\n             else { acc += \", \"; }"}, {"sha": "2d69a523e661e3eb89a6d025fb6235d6d7ea0bac", "filename": "src/libcore/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu16.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -26,7 +26,7 @@ pure fn nonnegative(x: u16) -> bool { x >= 0u16 }\n \n #[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: u16, hi: u16, it: fn(u16)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1u16; }\n }\n "}, {"sha": "267f36665542b2d3da4929bf1a6223a71e68e134", "filename": "src/libcore/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu32.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -60,7 +60,7 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: u32, hi: u32, it: fn(u32)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1u32; }\n }\n "}, {"sha": "1e6b02ef1b4cf2647ce1394692288fb8d3ba6bee", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -60,7 +60,7 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: u64, hi: u64, it: fn(u64)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1u64; }\n }\n \n@@ -98,9 +98,9 @@ fn to_str(n: u64, radix: uint) -> str {\n \n     if n == 0u64 { ret \"0\"; }\n \n-    let s = \"\";\n+    let mut s = \"\";\n \n-    let n = n;\n+    let mut n = n;\n     while n > 0u64 { s = digit(n % r64) + s; n /= r64; }\n     ret s;\n }\n@@ -119,8 +119,8 @@ Parse a string as an unsigned integer.\n */\n fn from_str(buf: str, radix: u64) -> option<u64> {\n     if str::len(buf) == 0u { ret none; }\n-    let i = str::len(buf) - 1u;\n-    let power = 1u64, n = 0u64;\n+    let mut i = str::len(buf) - 1u;\n+    let mut power = 1u64, n = 0u64;\n     while true {\n         alt char::to_digit(buf[i] as char, radix as uint) {\n           some(d) { n += d as u64 * power; }"}, {"sha": "eb433f4e9b36674a8826a649e4a4c47202bec6e1", "filename": "src/libcore/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu8.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -60,7 +60,7 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: u8, hi: u8, it: fn(u8)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1u8; }\n }\n "}, {"sha": "69981d2e9808ce32215ea1c2419e206d69760214", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -133,7 +133,7 @@ Iterate over the range [`lo`..`hi`)\n */\n #[inline(always)]\n fn range(lo: uint, hi: uint, it: fn(uint)) {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi { it(i); i += 1u; }\n }\n \n@@ -154,7 +154,7 @@ Returns:\n that is if `it` returned `false` at any point.\n */\n fn loop(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n-    let i = lo;\n+    let mut i = lo;\n     while i < hi {\n         if (!it(i)) { ret false; }\n         i += 1u;\n@@ -169,8 +169,8 @@ Returns the smallest power of 2 greater than or equal to `n`\n */\n fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n-    let tmp: uint = n - 1u;\n-    let shift: uint = 1u;\n+    let mut tmp: uint = n - 1u;\n+    let mut shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n     ret tmp + 1u;\n }\n@@ -191,9 +191,9 @@ buf must not be empty\n */\n fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n     if vec::len(buf) == 0u { ret none; }\n-    let i = vec::len(buf) - 1u;\n-    let power = 1u;\n-    let n = 0u;\n+    let mut i = vec::len(buf) - 1u;\n+    let mut power = 1u;\n+    let mut n = 0u;\n     while true {\n         alt char::to_digit(buf[i] as char, radix) {\n           some(d) { n += d * power; }\n@@ -219,7 +219,7 @@ Function: to_str\n Convert to a string in a given base\n */\n fn to_str(num: uint, radix: uint) -> str {\n-    let n = num;\n+    let mut n = num;\n     assert (0u < radix && radix <= 16u);\n     fn digit(n: uint) -> char {\n         ret alt n {\n@@ -243,13 +243,13 @@ fn to_str(num: uint, radix: uint) -> str {\n             };\n     }\n     if n == 0u { ret \"0\"; }\n-    let s: str = \"\";\n+    let mut s: str = \"\";\n     while n != 0u {\n         s += str::from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n-    let s1: str = \"\";\n-    let len: uint = str::len(s);\n+    let mut s1: str = \"\";\n+    let mut len: uint = str::len(s);\n     while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n     ret s1;\n }"}, {"sha": "310232dec9bfe8ec22e178e531d8ba05f5c7e634", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713006c7b6afc25ef90ecf78f88c9e9abb31f4b9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=713006c7b6afc25ef90ecf78f88c9e9abb31f4b9", "patch": "@@ -90,9 +90,9 @@ Creates an immutable vector of size `n_elts` and initializes the elements\n to the value returned by the function `op`.\n */\n fn init_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n-    let v = [];\n+    let mut v = [];\n     reserve(v, n_elts);\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < n_elts { v += [op(i)]; i += 1u; }\n     ret v;\n }\n@@ -106,9 +106,9 @@ Creates an immutable vector of size `n_elts` and initializes the elements\n to the value `t`.\n */\n fn init_elt<T: copy>(n_elts: uint, t: T) -> [T] {\n-    let v = [];\n+    let mut v = [];\n     reserve(v, n_elts);\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < n_elts { v += [t]; i += 1u; }\n     ret v;\n }\n@@ -217,9 +217,9 @@ Returns a copy of the elements from [`start`..`end`) from `v`.\n fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    let result = [];\n+    let mut result = [];\n     reserve(result, end - start);\n-    let i = start;\n+    let mut i = start;\n     while i < end { result += [v[i]]; i += 1u; }\n     ret result;\n }\n@@ -233,8 +233,8 @@ fn split<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n-    let start = 0u;\n-    let result = [];\n+    let mut start = 0u;\n+    let mut result = [];\n     while start < ln {\n         alt position_from(v, start, ln, f) {\n           none { break }\n@@ -258,9 +258,9 @@ fn splitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n-    let start = 0u;\n-    let count = n;\n-    let result = [];\n+    let mut start = 0u;\n+    let mut count = n;\n+    let mut result = [];\n     while start < ln && count > 0u {\n         alt position_from(v, start, ln, f) {\n           none { break }\n@@ -286,8 +286,8 @@ fn rsplit<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n-    let end = ln;\n-    let result = [];\n+    let mut end = ln;\n+    let mut result = [];\n     while end > 0u {\n         alt rposition_from(v, 0u, end, f) {\n           none { break }\n@@ -311,9 +311,9 @@ fn rsplitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n-    let end = ln;\n-    let count = n;\n-    let result = [];\n+    let mut end = ln;\n+    let mut count = n;\n+    let mut result = [];\n     while end > 0u && count > 0u {\n         alt rposition_from(v, 0u, end, f) {\n           none { break }\n@@ -385,7 +385,7 @@ initval - The value for the new elements\n */\n fn grow<T: copy>(&v: [const T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n }\n \n@@ -405,7 +405,7 @@ init_op - A function to call to retreive each appended element's value\n */\n fn grow_fn<T>(&v: [const T], n: uint, op: init_op<T>) {\n     reserve(v, next_power_of_two(len(v) + n));\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < n { v += [op(i)]; i += 1u; }\n }\n \n@@ -433,7 +433,7 @@ Function: map\n Apply a function to each element of a vector and return the results\n */\n fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n-    let result = [];\n+    let mut result = [];\n     reserve(result, len(v));\n     for elem: T in v { result += [f(elem)]; }\n     ret result;\n@@ -448,8 +448,8 @@ fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n                              f: fn(T, U) -> V) -> [V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n-    let u: [V] = [];\n-    let i = 0u;\n+    let mut u: [V] = [];\n+    let mut i = 0u;\n     while i < v0_len { u += [f(copy v0[i], copy v1[i])]; i += 1u; }\n     ret u;\n }\n@@ -464,7 +464,7 @@ the resulting vector.\n */\n fn filter_map<T: copy, U: copy>(v: [const T], f: fn(T) -> option<U>)\n     -> [U] {\n-    let result = [];\n+    let mut result = [];\n     for elem: T in v {\n         alt f(copy elem) {\n           none {/* no-op */ }\n@@ -484,7 +484,7 @@ Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n */\n fn filter<T: copy>(v: [T], f: fn(T) -> bool) -> [T] {\n-    let result = [];\n+    let mut result = [];\n     for elem: T in v {\n         if f(elem) { result += [elem]; }\n     }\n@@ -498,7 +498,7 @@ Concatenate a vector of vectors. Flattens a vector of vectors of T into\n a single vector of T.\n */\n fn concat<T: copy>(v: [const [const T]]) -> [T] {\n-    let new: [T] = [];\n+    let mut new: [T] = [];\n     for inner: [T] in v { new += inner; }\n     ret new;\n }\n@@ -509,8 +509,8 @@ Function: connect\n Concatenate a vector of vectors, placing a given separator between each\n */\n fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n-    let new: [T] = [];\n-    let first = true;\n+    let mut new: [T] = [];\n+    let mut first = true;\n     for inner: [T] in v {\n         if first { first = false; } else { push(new, sep); }\n         new += inner;\n@@ -524,7 +524,7 @@ Function: foldl\n Reduce a vector from left to right\n */\n fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n-    let accum = z;\n+    let mut accum = z;\n     iter(v) { |elt|\n         accum = p(accum, elt);\n     }\n@@ -537,7 +537,7 @@ Function: foldr\n Reduce a vector from right to left\n */\n fn foldr<T, U: copy>(v: [const T], z: U, p: fn(T, U) -> U) -> U {\n-    let accum = z;\n+    let mut accum = z;\n     riter(v) { |elt|\n         accum = p(elt, accum);\n     }\n@@ -566,7 +566,7 @@ If the vectors contains no elements then false is returned.\n fn any2<T, U>(v0: [const T], v1: [U], f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < v0_len && i < v1_len {\n         if f(v0[i], v1[i]) { ret true; };\n         i += 1u;\n@@ -596,7 +596,7 @@ If the vectors are not the same size then false is returned.\n fn all2<T, U>(v0: [const T], v1: [const U], f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { ret false; }\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < v0_len { if !f(v0[i], v1[i]) { ret false; }; i += 1u; }\n     ret true;\n }\n@@ -617,7 +617,7 @@ Function: count\n Returns the number of elements that are equal to a given value\n */\n fn count<T>(v: [const T], x: T) -> uint {\n-    let cnt = 0u;\n+    let mut cnt = 0u;\n     for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n@@ -716,7 +716,7 @@ fn position_from<T>(v: [const T], start: uint, end: uint,\n                     f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n-    let i = start;\n+    let mut i = start;\n     while i < end { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n@@ -761,7 +761,7 @@ fn rposition_from<T>(v: [const T], start: uint, end: uint,\n                      f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n-    let i = end;\n+    let mut i = end;\n     while i > start {\n         if f(v[i - 1u]) { ret some::<uint>(i - 1u); }\n         i -= 1u;\n@@ -784,7 +784,7 @@ and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n */\n fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n-    let as = [], bs = [];\n+    let mut as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n@@ -802,8 +802,9 @@ Preconditions:\n <same_length> (v, u)\n */\n fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n-    let zipped = [];\n-    let sz = len(v), i = 0u;\n+    let mut zipped = [];\n+    let sz = len(v);\n+    let mut i = 0u;\n     assert sz == len(u);\n     while i < sz { zipped += [(v[i], u[i])]; i += 1u; }\n     ret zipped;\n@@ -829,7 +830,7 @@ Function: reverse\n Reverse the order of elements in a vector, in place\n */\n fn reverse<T>(v: [mutable T]) {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n@@ -841,8 +842,8 @@ Function: reversed\n Returns a vector with the order of elements reversed\n */\n fn reversed<T: copy>(v: [const T]) -> [T] {\n-    let rs: [T] = [];\n-    let i = len::<T>(v);\n+    let mut rs: [T] = [];\n+    let mut i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n     while i != 0u { rs += [v[i]]; i -= 1u; }\n     rs += [v[0]];\n@@ -857,8 +858,8 @@ Returns a vector containing a range of chars\n */\n fn enum_chars(start: u8, end: u8) -> [char] {\n     assert start < end;\n-    let i = start;\n-    let r = [];\n+    let mut i = start;\n+    let mut r = [];\n     while i <= end { r += [i as char]; i += 1u as u8; }\n     ret r;\n }\n@@ -871,8 +872,8 @@ Returns a vector containing a range of uints\n */\n fn enum_uints(start: uint, end: uint) -> [uint] {\n     assert start < end;\n-    let i = start;\n-    let r = [];\n+    let mut i = start;\n+    let mut r = [];\n     while i <= end { r += [i]; i += 1u; }\n     ret r;\n }\n@@ -907,7 +908,7 @@ Iterates over two vectors in parallel\n */\n #[inline]\n fn iter2<U, T>(v: [ U], v2: [const T], f: fn(U, T)) {\n-    let i = 0;\n+    let mut i = 0;\n     for elt in v { f(elt, v2[i]); i += 1; }\n }\n \n@@ -921,7 +922,8 @@ element's value and index.\n */\n #[inline(always)]\n fn iteri<T>(v: [const T], f: fn(uint, T)) {\n-    let i = 0u, l = len(v);\n+    let mut i = 0u;\n+    let l = len(v);\n     while i < l { f(i, v[i]); i += 1u; }\n }\n \n@@ -947,7 +949,7 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n */\n fn riteri<T>(v: [const T], f: fn(uint, T)) {\n-    let i = len(v);\n+    let mut i = len(v);\n     while 0u < i {\n         i -= 1u;\n         f(i, v[i]);\n@@ -969,7 +971,7 @@ fn permute<T: copy>(v: [T], put: fn([T])) {\n   if ln == 0u {\n     put([]);\n   } else {\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < ln {\n       let elt = v[i];\n       let rest = slice(v, 0u, i) + slice(v, i+1u, ln);\n@@ -980,7 +982,7 @@ fn permute<T: copy>(v: [T], put: fn([T])) {\n }\n \n fn windowed <TT: copy> (nn: uint, xx: [const TT]) -> [[TT]] {\n-   let ww = [];\n+   let mut ww = [];\n \n    assert 1u <= nn;\n \n@@ -1153,7 +1155,7 @@ mod u8 {\n         // djb hash.\n         // FIXME: replace with murmur.\n \n-        let u: uint = 5381u;\n+        let mut u: uint = 5381u;\n         vec::iter(s, { |c| u *= 33u; u += c as uint; });\n         ret u;\n     }"}]}