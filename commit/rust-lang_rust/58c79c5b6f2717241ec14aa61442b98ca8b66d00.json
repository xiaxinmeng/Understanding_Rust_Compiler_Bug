{"sha": "58c79c5b6f2717241ec14aa61442b98ca8b66d00", "node_id": "C_kwDOAAsO6NoAKDU4Yzc5YzViNmYyNzE3MjQxZWMxNGFhNjE0NDJiOThjYThiNjZkMDA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-25T02:02:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-25T02:02:17Z"}, "message": "tweaks and feedback", "tree": {"sha": "2c3a7d8a6153ea24bfc5763ff656dfb71c32cb58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c3a7d8a6153ea24bfc5763ff656dfb71c32cb58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58c79c5b6f2717241ec14aa61442b98ca8b66d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58c79c5b6f2717241ec14aa61442b98ca8b66d00", "html_url": "https://github.com/rust-lang/rust/commit/58c79c5b6f2717241ec14aa61442b98ca8b66d00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58c79c5b6f2717241ec14aa61442b98ca8b66d00/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "html_url": "https://github.com/rust-lang/rust/commit/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2"}], "stats": {"total": 108, "additions": 48, "deletions": 60}, "files": [{"sha": "79414ada5eac900c2655e99287e598cbbf97091c", "filename": "src/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58c79c5b6f2717241ec14aa61442b98ca8b66d00/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c79c5b6f2717241ec14aa61442b98ca8b66d00/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=58c79c5b6f2717241ec14aa61442b98ca8b66d00", "patch": "@@ -646,7 +646,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let alloc: Allocation<Tag, Self::AllocExtra> = alloc.convert_tag_add_extra(\n             &ecx.tcx,\n             AllocExtra {\n-                stacked_borrows: stacks,\n+                stacked_borrows: stacks.map(RefCell::new),\n                 data_race: race_alloc,\n                 weak_memory: buffer_alloc,\n             },\n@@ -745,7 +745,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.read(alloc_id, range, machine.data_race.as_ref().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_read(\n+            stacked_borrows.borrow_mut().memory_read(\n                 alloc_id,\n                 tag,\n                 range,\n@@ -771,7 +771,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.write(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_written(\n+            stacked_borrows.get_mut().memory_written(\n                 alloc_id,\n                 tag,\n                 range,\n@@ -800,7 +800,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.deallocate(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_deallocated(\n+            stacked_borrows.get_mut().memory_deallocated(\n                 alloc_id,\n                 tag,\n                 range,"}, {"sha": "6fa70ddfc5d4e64b4dc61cc2286e0efcd50b170f", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 35, "deletions": 49, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/58c79c5b6f2717241ec14aa61442b98ca8b66d00/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c79c5b6f2717241ec14aa61442b98ca8b66d00/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=58c79c5b6f2717241ec14aa61442b98ca8b66d00", "patch": "@@ -25,7 +25,8 @@ use diagnostics::{AllocHistory, TagHistory};\n \n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n-pub type AllocExtra = Stacks;\n+// Even reading memory can have effects on the stack, so we need a `RefCell` here.\n+pub type AllocExtra = RefCell<Stacks>;\n \n /// Tracking pointer provenance\n #[derive(Copy, Clone, Hash, Eq)]\n@@ -131,7 +132,7 @@ pub struct Stack {\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n     /// * Except for `Untagged`, no tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n-    /// If this is `Some(id)`, then the actual current stack is unknown. THis can happen when\n+    /// If this is `Some(id)`, then the actual current stack is unknown. This can happen when\n     /// wildcard pointers are used to access this location. What we do know is that `borrows` are at\n     /// the top of the stack, and below it are arbitrarily many items whose `tag` is either\n     /// `Untagged` or strictly less than `id`.\n@@ -144,11 +145,11 @@ pub struct Stack {\n #[derive(Clone, Debug)]\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n-    stacks: RefCell<RangeMap<Stack>>,\n+    stacks: RangeMap<Stack>,\n     /// Stores past operations on this allocation\n-    history: RefCell<AllocHistory>,\n+    history: AllocHistory,\n     /// The set of tags that have been exposed inside this allocation.\n-    exposed_tags: RefCell<FxHashSet<SbTag>>,\n+    exposed_tags: FxHashSet<SbTag>,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -689,34 +690,14 @@ impl<'tcx> Stacks {\n         let stack = Stack { borrows: vec![item], unknown_bottom: None };\n \n         Stacks {\n-            stacks: RefCell::new(RangeMap::new(size, stack)),\n-            history: RefCell::new(AllocHistory::new()),\n-            exposed_tags: RefCell::new(FxHashSet::default()),\n+            stacks: RangeMap::new(size, stack),\n+            history: AllocHistory::new(),\n+            exposed_tags: FxHashSet::default(),\n         }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n-        &self,\n-        range: AllocRange,\n-        mut f: impl FnMut(\n-            Size,\n-            &mut Stack,\n-            &mut AllocHistory,\n-            &mut FxHashSet<SbTag>,\n-        ) -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        let mut stacks = self.stacks.borrow_mut();\n-        let history = &mut *self.history.borrow_mut();\n-        let exposed_tags = &mut *self.exposed_tags.borrow_mut();\n-        for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, history, exposed_tags)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Call `f` on every stack in the range.\n-    fn for_each_mut(\n         &mut self,\n         range: AllocRange,\n         mut f: impl FnMut(\n@@ -726,11 +707,8 @@ impl<'tcx> Stacks {\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        let stacks = self.stacks.get_mut();\n-        let history = &mut *self.history.get_mut();\n-        let exposed_tags = self.exposed_tags.get_mut();\n-        for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, history, exposed_tags)?;\n+        for (offset, stack) in self.stacks.iter_mut(range.start, range.size) {\n+            f(offset, stack, &mut self.history, &mut self.exposed_tags)?;\n         }\n         Ok(())\n     }\n@@ -777,8 +755,8 @@ impl Stacks {\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        let stacks = Stacks::new(size, perm, base_tag);\n-        stacks.history.borrow_mut().log_creation(\n+        let mut stacks = Stacks::new(size, perm, base_tag);\n+        stacks.history.log_creation(\n             None,\n             base_tag,\n             alloc_range(Size::ZERO, size),\n@@ -789,7 +767,7 @@ impl Stacks {\n \n     #[inline(always)]\n     pub fn memory_read<'tcx>(\n-        &self,\n+        &mut self,\n         alloc_id: AllocId,\n         tag: SbTagExtra,\n         range: AllocRange,\n@@ -832,7 +810,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each_mut(range, |offset, stack, history, exposed_tags| {\n+        self.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.access(\n                 AccessKind::Write,\n                 tag,\n@@ -855,7 +833,7 @@ impl Stacks {\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let state = state.borrow();\n-        self.for_each_mut(range, |offset, stack, history, exposed_tags| {\n+        self.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags)\n         })?;\n         Ok(())\n@@ -890,17 +868,19 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 return Ok(())\n             };\n             let extra = this.get_alloc_extra(alloc_id)?;\n-            let stacked_borrows =\n-                extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-            let mut alloc_history = stacked_borrows.history.borrow_mut();\n-            alloc_history.log_creation(\n+            let mut stacked_borrows = extra\n+                .stacked_borrows\n+                .as_ref()\n+                .expect(\"we should have Stacked Borrows data\")\n+                .borrow_mut();\n+            stacked_borrows.history.log_creation(\n                 Some(orig_tag),\n                 new_tag,\n                 alloc_range(base_offset, size),\n                 current_span,\n             );\n             if protect {\n-                alloc_history.log_protector(orig_tag, new_tag, current_span);\n+                stacked_borrows.history.log_protector(orig_tag, new_tag, current_span);\n             }\n             Ok(())\n         };\n@@ -976,8 +956,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n                 let extra = this.get_alloc_extra(alloc_id)?;\n-                let stacked_borrows =\n-                    extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+                let mut stacked_borrows = extra\n+                    .stacked_borrows\n+                    .as_ref()\n+                    .expect(\"we should have Stacked Borrows data\")\n+                    .borrow_mut();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -1015,13 +998,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows =\n-            alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n+        let mut stacked_borrows = alloc_extra\n+            .stacked_borrows\n+            .as_mut()\n+            .expect(\"we should have Stacked Borrows data\")\n+            .borrow_mut();\n         let item = Item { perm, tag: new_tag, protector };\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         let current_span = &mut machine.current_span(); // `get_alloc_extra_mut` invalidated our old `current_span`\n-        stacked_borrows.for_each_mut(range, |offset, stack, history, exposed_tags| {\n+        stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.grant(\n                 orig_tag,\n                 item,\n@@ -1177,7 +1163,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match this.get_alloc_extra(alloc_id) {\n             Ok(alloc_extra) => {\n                 trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id}\");\n-                alloc_extra.stacked_borrows.as_ref().unwrap().exposed_tags.borrow_mut().insert(tag);\n+                alloc_extra.stacked_borrows.as_ref().unwrap().borrow_mut().exposed_tags.insert(tag);\n             }\n             Err(err) => {\n                 trace!("}, {"sha": "a4a7f5e7a1e350bd3aa95df8d9aef94081092d8f", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58c79c5b6f2717241ec14aa61442b98ca8b66d00/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c79c5b6f2717241ec14aa61442b98ca8b66d00/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=58c79c5b6f2717241ec14aa61442b98ca8b66d00", "patch": "@@ -259,6 +259,6 @@ fn error_cause(stack: &Stack, tag: SbTagExtra) -> &'static str {\n             \", but that tag does not exist in the borrow stack for this location\"\n         }\n     } else {\n-        \", but no exposed tags are valid in the borrow stack for this location\"\n+        \", but no exposed tags have suitable permission in the borrow stack for this location\"\n     }\n }"}, {"sha": "28fa98b6020c0bf894bddb30d19f622f789601c2", "filename": "tests/fail/stacked_borrows/exposed_only_ro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58c79c5b6f2717241ec14aa61442b98ca8b66d00/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58c79c5b6f2717241ec14aa61442b98ca8b66d00/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr?ref=58c79c5b6f2717241ec14aa61442b98ca8b66d00", "patch": "@@ -1,10 +1,10 @@\n-error: Undefined Behavior: attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n   --> $DIR/exposed_only_ro.rs:LL:CC\n    |\n LL |     unsafe { *ptr = 0 };\n    |              ^^^^^^^^\n    |              |\n-   |              attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n+   |              attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental"}, {"sha": "19d0784591e496e5675ca90501e1683e8446e3a3", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed2.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58c79c5b6f2717241ec14aa61442b98ca8b66d00/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c79c5b6f2717241ec14aa61442b98ca8b66d00/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs?ref=58c79c5b6f2717241ec14aa61442b98ca8b66d00", "patch": "@@ -7,12 +7,14 @@ fn main() {\n         let exposed_ptr = addr as *mut i32;\n         // From the exposed ptr, we get a new unique ptr.\n         let root2 = &mut *exposed_ptr;\n-        // let _fool = root2 as *mut _; // this would [fool] us, since SRW(N+1) remains on the stack\n-        // Stack: Unknown(<N), Unique(N) [, SRW(N+1)]\n+        // let _fool = root2 as *mut _; // this would fool us, since SRW(N+1) remains on the stack\n+        // Stack: Unknown(<N), Unique(N)\n+        // Stack if _fool existed: Unknown(<N), Unique(N), SRW(N+1)\n         // And we test that it has uniqueness by doing a conflicting read.\n         let _val = *exposed_ptr;\n-        // Stack: Unknown(<N), Disabled(N) [, SRW(N+1)]\n-        // collapsed to Unknown(<N) [Unknown(<N+2)]\n+        // Stack: Unknown(<N), Disabled(N)\n+        // collapsed to Unknown(<N)\n+        // Stack if _fool existed: Unknown(<N), Disabled(N), SRW(N+1); collapsed to Unknown(<N+2) which would not cause an ERROR\n         let _val = *root2; //~ ERROR: borrow stack\n     }\n }"}]}