{"sha": "5724c6454950617c292daba89cdb9a3b4c862430", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MjRjNjQ1NDk1MDYxN2MyOTJkYWJhODljZGI5YTNiNGM4NjI0MzA=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-12T23:42:58Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-12T23:49:49Z"}, "message": "Revert linked failure (killing runtime)\n\nThis reverts commit 200a2ded3245eb0a1ca7b265ce83adba16d75b97.", "tree": {"sha": "12c612fa03bafbb757fb275b360c81bd0b0ad408", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12c612fa03bafbb757fb275b360c81bd0b0ad408"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5724c6454950617c292daba89cdb9a3b4c862430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5724c6454950617c292daba89cdb9a3b4c862430", "html_url": "https://github.com/rust-lang/rust/commit/5724c6454950617c292daba89cdb9a3b4c862430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5724c6454950617c292daba89cdb9a3b4c862430/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "html_url": "https://github.com/rust-lang/rust/commit/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9"}], "stats": {"total": 82, "additions": 23, "deletions": 59}, "files": [{"sha": "5f3cf1e5c260874e634ed00a5f66026c964a0912", "filename": "src/libcore/task.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5724c6454950617c292daba89cdb9a3b4c862430/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5724c6454950617c292daba89cdb9a3b4c862430/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=5724c6454950617c292daba89cdb9a3b4c862430", "patch": "@@ -591,21 +591,16 @@ class taskgroup {\n     let my_pos:     uint;\n     // let parent_group: taskgroup_arc; // TODO(bblum)\n     // TODO XXX bblum: add a list of empty slots to get runtime back\n-    // Indicates whether this is the main (root) taskgroup. If so, failure\n-    // here should take down the entire runtime.\n-    let is_main:    bool;\n-    new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint, is_main: bool) {\n-        self.tasks   = tasks;\n-        self.me      = me;\n-        self.my_pos  = my_pos;\n-        self.is_main = is_main;\n+    let mut failed: bool;\n+    new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint) {\n+        self.tasks = tasks; self.me = me; self.my_pos = my_pos;\n+        self.failed = true; // This will get un-set on successful exit.\n     }\n     // Runs on task exit.\n     drop {\n-        // If we are failing, the whole taskgroup needs to die.\n-        if rustrt::rust_task_is_unwinding(self.me) {\n+        if self.failed {\n             // Take everybody down with us.\n-            kill_taskgroup(self.tasks, self.me, self.my_pos, self.is_main);\n+            kill_taskgroup(self.tasks, self.me, self.my_pos);\n         } else {\n             // Remove ourselves from the group.\n             leave_taskgroup(self.tasks, self.me, self.my_pos);\n@@ -647,8 +642,7 @@ fn leave_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n-                  is_main: bool) {\n+fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -673,40 +667,32 @@ fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n                     rustrt::rust_task_kill_other(task);\n                 };\n             }\n-            // Only one task should ever do this.\n-            if is_main {\n-                rustrt::rust_task_kill_all(me);\n-            }\n         };\n-        // (note: multiple tasks may reach this point)\n     };\n }\n \n-fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n+fn share_parent_taskgroup() -> taskgroup_arc {\n     let me = rustrt::rust_get_task();\n     alt unsafe { local_get(me, taskgroup_key) } {\n         some(group) {\n-            // Clone the shared state for the child; propagate main-ness.\n-            (group.tasks.clone(), group.is_main)\n+            group.tasks.clone()\n         }\n         none {\n-            // Main task, doing first spawn ever.\n+            /* Main task, doing first spawn ever. */\n             let tasks = arc::exclusive(some(dvec::from_elem(some(me))));\n-            let group = @taskgroup(tasks.clone(), me, 0, true);\n+            let group = @taskgroup(tasks.clone(), me, 0);\n             unsafe { local_set(me, taskgroup_key, group); }\n-            // Tell child task it's also in the main group.\n-            (tasks, true)\n+            tasks\n         }\n     }\n }\n \n fn spawn_raw(opts: task_opts, +f: fn~()) {\n     // Decide whether the child needs to be in a new linked failure group.\n-    let (child_tg, is_main) = if opts.supervise {\n+    let child_tg: taskgroup_arc = if opts.supervise {\n         share_parent_taskgroup()\n     } else {\n-        // Detached from the parent group; create a new (non-main) one.\n-        (arc::exclusive(some(dvec::from_elem(none))), false)\n+        arc::exclusive(some(dvec::from_elem(none)))\n     };\n \n     unsafe {\n@@ -726,8 +712,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // Getting killed after here would leak the task.\n \n             let child_wrapper =\n-                make_child_wrapper(new_task, child_tg,\n-                                   opts.supervise, is_main, f);\n+                make_child_wrapper(new_task, child_tg, opts.supervise, f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n \n@@ -745,8 +730,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     }\n \n     fn make_child_wrapper(child_task: *rust_task, -child_tg: taskgroup_arc,\n-                          supervise: bool, is_main: bool,\n-                          -f: fn~()) -> fn~() {\n+                          supervise: bool, -f: fn~()) -> fn~() {\n         let child_tg_ptr = ~mut some(child_tg);\n         fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n@@ -762,12 +746,13 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // parent was already failing, so don't bother doing anything.\n             alt enlist_in_taskgroup(child_tg, child_task) {\n                 some(my_index) {\n-                    let group =\n-                        @taskgroup(child_tg, child_task, my_index, is_main);\n+                    let group = @taskgroup(child_tg, child_task, my_index);\n                     unsafe { local_set(child_task, taskgroup_key, group); }\n                     // Run the child's body.\n                     f();\n-                    // TLS cleanup code will exit the taskgroup.\n+                    // Report successful exit. (TLS cleanup code will tear\n+                    // down the group.)\n+                    group.failed = false;\n                 }\n                 none { }\n             }\n@@ -1021,7 +1006,6 @@ extern mod rustrt {\n     fn rust_task_inhibit_kill();\n     fn rust_task_allow_kill();\n     fn rust_task_kill_other(task: *rust_task);\n-    fn rust_task_kill_all(task: *rust_task);\n \n     #[rust_stack]\n     fn rust_get_task_local_data(task: *rust_task) -> *libc::c_void;"}, {"sha": "55f1f8bf17e4caa18da72d5dc711cd7bbbbc7886", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5724c6454950617c292daba89cdb9a3b4c862430", "patch": "@@ -863,11 +863,6 @@ rust_task_kill_other(rust_task *task) { /* Used for linked failure */\n     task->kill();\n }\n \n-extern \"C\" void\n-rust_task_kill_all(rust_task *task) {\n-    task->fail_sched_loop();\n-}\n-\n extern \"C\" rust_cond_lock*\n rust_create_cond_lock() {\n     return new rust_cond_lock();"}, {"sha": "4aed9a5e0611dd09ae26d9abb21d95f77753fcef", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=5724c6454950617c292daba89cdb9a3b4c862430", "patch": "@@ -260,8 +260,8 @@ rust_task *\n rust_sched_loop::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this->kernel, \"rust_task\")\n-        rust_task(this, task_state_newborn,\n-                  spawner, name, kernel->env->min_stack_size);\n+        rust_task (this, task_state_newborn,\n+                   spawner, name, kernel->env->min_stack_size);\n     DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n "}, {"sha": "3d88c05b3ff9b68791e74c14bf6169fce5cd337d", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=5724c6454950617c292daba89cdb9a3b4c862430", "patch": "@@ -129,11 +129,6 @@ cleanup_task(cleanup_args *args) {\n         // assert(task->task_local_data != NULL);\n         task->task_local_data_cleanup(task->task_local_data);\n         task->task_local_data = NULL;\n-    } else if (threw_exception) {\n-        // Edge case: If main never spawns any tasks, but fails anyway, TLS\n-        // won't be around to take down the kernel (task.rs:kill_taskgroup,\n-        // rust_task_kill_all). Do it here instead.\n-        task->fail_sched_loop();\n     }\n \n     // FIXME (#2676): For performance we should do the annihilator\n@@ -287,7 +282,6 @@ rust_task::kill() {\n     LOG(this, task, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n }\n \n-// TODO(bblum): Move this to rust_builtin.cpp (cleanup)\n extern \"C\" CDECL\n bool rust_task_is_unwinding(rust_task *rt) {\n     return rt->unwinding;\n@@ -321,12 +315,8 @@ rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n #else\n     die();\n     // FIXME (#908): Need unwinding on windows. This will end up aborting\n-    fail_sched_loop();\n-#endif\n-}\n-\n-void rust_task::fail_sched_loop() {\n     sched_loop->fail();\n+#endif\n }\n \n void"}, {"sha": "1d87a0ed56c1b8ebc3519e6113d463e30c7b0265", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=5724c6454950617c292daba89cdb9a3b4c862430", "patch": "@@ -275,10 +275,6 @@ rust_task : public kernel_owned<rust_task>\n     void fail();\n     void fail(char const *expr, char const *file, size_t line);\n \n-    // Propagate failure to the entire rust runtime.\n-    // TODO(bblum): maybe this can be done at rust-level?\n-    void fail_sched_loop();\n-\n     // Disconnect from our supervisor.\n     void unsupervise();\n "}, {"sha": "300d6bc79e8deb23a6c046e411978bd75c149c7a", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/5724c6454950617c292daba89cdb9a3b4c862430/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=5724c6454950617c292daba89cdb9a3b4c862430", "patch": "@@ -178,7 +178,6 @@ rust_port_task\n rust_task_inhibit_kill\n rust_task_allow_kill\n rust_task_kill_other\n-rust_task_kill_all\n rust_create_cond_lock\n rust_destroy_cond_lock\n rust_lock_cond_lock"}]}