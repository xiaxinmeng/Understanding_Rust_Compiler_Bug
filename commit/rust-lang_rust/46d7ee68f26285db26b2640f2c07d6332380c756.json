{"sha": "46d7ee68f26285db26b2640f2c07d6332380c756", "node_id": "C_kwDOAAsO6NoAKDQ2ZDdlZTY4ZjI2Mjg1ZGIyNmIyNjQwZjJjMDdkNjMzMjM4MGM3NTY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-03T18:46:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-03T18:46:45Z"}, "message": "Merge #11865\n\n11865: Fix: Select correct insert position for disabled group import r=jonasbb a=jonasbb\n\nThe logic for importing with and without `group_imports` differed\nsignificantly when no previous group existed. This lead to the problem\nof using the wrong position when importing inside a module (#11585) or\nwhen inner attributes are involved.\nThe existing code for grouped imports is better and takes these things\ninto account.\n\nThis PR changes the flow to use the pre-existing code for adding a new\nimport group even for the non-grouped import settings.\nSome coverage markers are updated and the `group` is removed, since they\nare now invoked in both cases (grouping and no grouping).\n\nTests are updated and two tests (empty module and inner attribute) are\nadded.\n\nFixes #11585\n\nCo-authored-by: Jonas Bushart <jonas@bushart.org>", "tree": {"sha": "b1261b79f5334e057317f1999caee9c162521097", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1261b79f5334e057317f1999caee9c162521097"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46d7ee68f26285db26b2640f2c07d6332380c756", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiSeuVCRBK7hj4Ov3rIwAABpoIAC2egobbzlkE0bT2gYJht3Vk\nf9yWiCGl7J+P5U3GcoHQjliLRdSBbruJ5bEtMGETfDaa4P0D9JaQDQsOiE1sFrWO\nIRADvK3f7VVWe7qvTcp5St0XLU7aV+ylcy1ebmQab2Iaq7xjhsJIA5o7hUQTD/BB\nWEjEOSRY/U16JQXCQxW0XAAUekKRAH34jZ+P6/1ZBrEkvDb8rtgp334We5aU7dmV\noi7NMfdznArMFmSCYhe9RVpnk9D7wOMmhZ/T7WFAtyU7Wp+D7q0I14Au/1nhzVAd\nr+ARgZ7TxiLn9IK7mTTmfEY7GejAP3XYxCDe/V23SbbITdAwlcehMcKeAl1eG8o=\n=vFPx\n-----END PGP SIGNATURE-----\n", "payload": "tree b1261b79f5334e057317f1999caee9c162521097\nparent 79a0fee082c6a8fac3dee5baf1f21669304e264d\nparent 156f9074e19346d79d8d7bc21ff643f50ba6a954\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649011605 +0000\ncommitter GitHub <noreply@github.com> 1649011605 +0000\n\nMerge #11865\n\n11865: Fix: Select correct insert position for disabled group import r=jonasbb a=jonasbb\n\nThe logic for importing with and without `group_imports` differed\nsignificantly when no previous group existed. This lead to the problem\nof using the wrong position when importing inside a module (#11585) or\nwhen inner attributes are involved.\nThe existing code for grouped imports is better and takes these things\ninto account.\n\nThis PR changes the flow to use the pre-existing code for adding a new\nimport group even for the non-grouped import settings.\nSome coverage markers are updated and the `group` is removed, since they\nare now invoked in both cases (grouping and no grouping).\n\nTests are updated and two tests (empty module and inner attribute) are\nadded.\n\nFixes #11585\n\nCo-authored-by: Jonas Bushart <jonas@bushart.org>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46d7ee68f26285db26b2640f2c07d6332380c756", "html_url": "https://github.com/rust-lang/rust/commit/46d7ee68f26285db26b2640f2c07d6332380c756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46d7ee68f26285db26b2640f2c07d6332380c756/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a0fee082c6a8fac3dee5baf1f21669304e264d", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a0fee082c6a8fac3dee5baf1f21669304e264d", "html_url": "https://github.com/rust-lang/rust/commit/79a0fee082c6a8fac3dee5baf1f21669304e264d"}, {"sha": "156f9074e19346d79d8d7bc21ff643f50ba6a954", "url": "https://api.github.com/repos/rust-lang/rust/commits/156f9074e19346d79d8d7bc21ff643f50ba6a954", "html_url": "https://github.com/rust-lang/rust/commit/156f9074e19346d79d8d7bc21ff643f50ba6a954"}], "stats": {"total": 199, "additions": 116, "deletions": 83}, "files": [{"sha": "a19969ecc4ac8660efc63bc0277572fa5851e3f8", "filename": "crates/ide_db/src/imports/insert_use.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/46d7ee68f26285db26b2640f2c07d6332380c756/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d7ee68f26285db26b2640f2c07d6332380c756/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use.rs?ref=46d7ee68f26285db26b2640f2c07d6332380c756", "patch": "@@ -337,67 +337,65 @@ fn insert_use_(\n             Some((path, has_tl, node))\n         });\n \n-    if !group_imports {\n+    if group_imports {\n+        // Iterator that discards anything thats not in the required grouping\n+        // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n+        let group_iter = path_node_iter\n+            .clone()\n+            .skip_while(|(path, ..)| ImportGroup::new(path) != group)\n+            .take_while(|(path, ..)| ImportGroup::new(path) == group);\n+\n+        // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n+        let mut last = None;\n+        // find the element that would come directly after our new import\n+        let post_insert: Option<(_, _, SyntaxNode)> = group_iter\n+            .inspect(|(.., node)| last = Some(node.clone()))\n+            .find(|&(ref path, has_tl, _)| {\n+                use_tree_path_cmp(insert_path, false, path, has_tl) != Ordering::Greater\n+            });\n+\n+        if let Some((.., node)) = post_insert {\n+            cov_mark::hit!(insert_group);\n+            // insert our import before that element\n+            return ted::insert(ted::Position::before(node), use_item.syntax());\n+        }\n+        if let Some(node) = last {\n+            cov_mark::hit!(insert_group_last);\n+            // there is no element after our new import, so append it to the end of the group\n+            return ted::insert(ted::Position::after(node), use_item.syntax());\n+        }\n+\n+        // the group we were looking for actually doesn't exist, so insert\n+\n+        let mut last = None;\n+        // find the group that comes after where we want to insert\n+        let post_group = path_node_iter\n+            .inspect(|(.., node)| last = Some(node.clone()))\n+            .find(|(p, ..)| ImportGroup::new(p) > group);\n+        if let Some((.., node)) = post_group {\n+            cov_mark::hit!(insert_group_new_group);\n+            ted::insert(ted::Position::before(&node), use_item.syntax());\n+            if let Some(node) = algo::non_trivia_sibling(node.into(), Direction::Prev) {\n+                ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+            }\n+            return;\n+        }\n+        // there is no such group, so append after the last one\n+        if let Some(node) = last {\n+            cov_mark::hit!(insert_group_no_group);\n+            ted::insert(ted::Position::after(&node), use_item.syntax());\n+            ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+            return;\n+        }\n+    } else {\n+        // There exists a group, so append to the end of it\n         if let Some((_, _, node)) = path_node_iter.last() {\n             cov_mark::hit!(insert_no_grouping_last);\n             ted::insert(ted::Position::after(node), use_item.syntax());\n-        } else {\n-            cov_mark::hit!(insert_no_grouping_last2);\n-            ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n-            ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n+            return;\n         }\n-        return;\n-    }\n-\n-    // Iterator that discards anything thats not in the required grouping\n-    // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n-    let group_iter = path_node_iter\n-        .clone()\n-        .skip_while(|(path, ..)| ImportGroup::new(path) != group)\n-        .take_while(|(path, ..)| ImportGroup::new(path) == group);\n-\n-    // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n-    let mut last = None;\n-    // find the element that would come directly after our new import\n-    let post_insert: Option<(_, _, SyntaxNode)> = group_iter\n-        .inspect(|(.., node)| last = Some(node.clone()))\n-        .find(|&(ref path, has_tl, _)| {\n-            use_tree_path_cmp(insert_path, false, path, has_tl) != Ordering::Greater\n-        });\n-\n-    if let Some((.., node)) = post_insert {\n-        cov_mark::hit!(insert_group);\n-        // insert our import before that element\n-        return ted::insert(ted::Position::before(node), use_item.syntax());\n-    }\n-    if let Some(node) = last {\n-        cov_mark::hit!(insert_group_last);\n-        // there is no element after our new import, so append it to the end of the group\n-        return ted::insert(ted::Position::after(node), use_item.syntax());\n     }\n \n-    // the group we were looking for actually doesn't exist, so insert\n-\n-    let mut last = None;\n-    // find the group that comes after where we want to insert\n-    let post_group = path_node_iter\n-        .inspect(|(.., node)| last = Some(node.clone()))\n-        .find(|(p, ..)| ImportGroup::new(p) > group);\n-    if let Some((.., node)) = post_group {\n-        cov_mark::hit!(insert_group_new_group);\n-        ted::insert(ted::Position::before(&node), use_item.syntax());\n-        if let Some(node) = algo::non_trivia_sibling(node.into(), Direction::Prev) {\n-            ted::insert(ted::Position::after(node), make::tokens::single_newline());\n-        }\n-        return;\n-    }\n-    // there is no such group, so append after the last one\n-    if let Some(node) = last {\n-        cov_mark::hit!(insert_group_no_group);\n-        ted::insert(ted::Position::after(&node), use_item.syntax());\n-        ted::insert(ted::Position::after(node), make::tokens::single_newline());\n-        return;\n-    }\n     // there are no imports in this file at all\n     if let Some(last_inner_element) = scope_syntax\n         .children_with_tokens()\n@@ -407,14 +405,14 @@ fn insert_use_(\n         })\n         .last()\n     {\n-        cov_mark::hit!(insert_group_empty_inner_attr);\n+        cov_mark::hit!(insert_empty_inner_attr);\n         ted::insert(ted::Position::after(&last_inner_element), use_item.syntax());\n         ted::insert(ted::Position::after(last_inner_element), make::tokens::single_newline());\n         return;\n     }\n     let l_curly = match scope {\n         ImportScope::File(_) => {\n-            cov_mark::hit!(insert_group_empty_file);\n+            cov_mark::hit!(insert_empty_file);\n             ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n             ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n             return;\n@@ -426,7 +424,7 @@ fn insert_use_(\n     };\n     match l_curly {\n         Some(b) => {\n-            cov_mark::hit!(insert_group_empty_module);\n+            cov_mark::hit!(insert_empty_module);\n             ted::insert(ted::Position::after(&b), make::tokens::single_newline());\n             ted::insert(ted::Position::after(&b), use_item.syntax());\n         }"}, {"sha": "acadb353b6ab8f21a90586e27cb43b7ea36cd9b7", "filename": "crates/ide_db/src/imports/insert_use/tests.rs", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/46d7ee68f26285db26b2640f2c07d6332380c756/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d7ee68f26285db26b2640f2c07d6332380c756/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs?ref=46d7ee68f26285db26b2640f2c07d6332380c756", "patch": "@@ -84,25 +84,6 @@ use external_crate2::bar::A;\",\n     );\n }\n \n-#[test]\n-fn insert_not_group_empty() {\n-    cov_mark::check!(insert_no_grouping_last2);\n-    check_with_config(\n-        \"use external_crate2::bar::A\",\n-        r\"\",\n-        r\"use external_crate2::bar::A;\n-\n-\",\n-        &InsertUseConfig {\n-            granularity: ImportGranularity::Item,\n-            enforce_granularity: true,\n-            prefix_kind: PrefixKind::Plain,\n-            group: false,\n-            skip_glob_imports: true,\n-        },\n-    );\n-}\n-\n #[test]\n fn insert_existing() {\n     check_crate(\"std::fs\", \"use std::fs;\", \"use std::fs;\")\n@@ -321,7 +302,9 @@ fn main() {}\",\n \n #[test]\n fn insert_empty_file() {\n-    cov_mark::check!(insert_group_empty_file);\n+    cov_mark::check_count!(insert_empty_file, 2);\n+\n+    // Default configuration\n     // empty files will get two trailing newlines\n     // this is due to the test case insert_no_imports above\n     check_crate(\n@@ -330,12 +313,30 @@ fn insert_empty_file() {\n         r\"use foo::bar;\n \n \",\n-    )\n+    );\n+\n+    // \"not group\" configuration\n+    check_with_config(\n+        \"use external_crate2::bar::A\",\n+        r\"\",\n+        r\"use external_crate2::bar::A;\n+\n+\",\n+        &InsertUseConfig {\n+            granularity: ImportGranularity::Item,\n+            enforce_granularity: true,\n+            prefix_kind: PrefixKind::Plain,\n+            group: false,\n+            skip_glob_imports: true,\n+        },\n+    );\n }\n \n #[test]\n fn insert_empty_module() {\n-    cov_mark::check!(insert_group_empty_module);\n+    cov_mark::check_count!(insert_empty_module, 2);\n+\n+    // Default configuration\n     check(\n         \"foo::bar\",\n         r\"\n@@ -347,19 +348,53 @@ mod x {\n }\n \",\n         ImportGranularity::Item,\n-    )\n+    );\n+\n+    // \"not group\" configuration\n+    check_with_config(\n+        \"foo::bar\",\n+        r\"mod x {$0}\",\n+        r\"mod x {\n+    use foo::bar;\n+}\",\n+        &InsertUseConfig {\n+            granularity: ImportGranularity::Item,\n+            enforce_granularity: true,\n+            prefix_kind: PrefixKind::Plain,\n+            group: false,\n+            skip_glob_imports: true,\n+        },\n+    );\n }\n \n #[test]\n fn insert_after_inner_attr() {\n-    cov_mark::check!(insert_group_empty_inner_attr);\n+    cov_mark::check_count!(insert_empty_inner_attr, 2);\n+\n+    // Default configuration\n     check_crate(\n         \"foo::bar\",\n         r\"#![allow(unused_imports)]\",\n         r\"#![allow(unused_imports)]\n \n use foo::bar;\",\n-    )\n+    );\n+\n+    // \"not group\" configuration\n+    check_with_config(\n+        \"foo::bar\",\n+        r\"#![allow(unused_imports)]\",\n+        r\"#![allow(unused_imports)]\n+\n+use foo::bar;\",\n+        &InsertUseConfig {\n+            granularity: ImportGranularity::Item,\n+            enforce_granularity: true,\n+            prefix_kind: PrefixKind::Plain,\n+            group: false,\n+            skip_glob_imports: true,\n+        },\n+    );\n }\n \n #[test]"}]}