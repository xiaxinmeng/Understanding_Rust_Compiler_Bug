{"sha": "80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "node_id": "C_kwDOAAsO6NoAKDgwZTRlNzJmY2QxODBlZjYyYmFhM2E1YzJlMDNmYWQ3NWU0MTg0OGI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-07T07:10:25Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-07T07:10:25Z"}, "message": "fully move `on_unimplemented` to error reporting", "tree": {"sha": "09abf8af5183a7913b2c010c41dfb910be8c8da3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09abf8af5183a7913b2c010c41dfb910be8c8da3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "html_url": "https://github.com/rust-lang/rust/commit/80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b735a7132acd58b3bd34c084e9ca5b4ca7450a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b735a7132acd58b3bd34c084e9ca5b4ca7450a2", "html_url": "https://github.com/rust-lang/rust/commit/9b735a7132acd58b3bd34c084e9ca5b4ca7450a2"}], "stats": {"total": 815, "additions": 404, "deletions": 411}, "files": [{"sha": "8f62df683cba1b6515acd86f24725640c34be886", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "patch": "@@ -26,6 +26,7 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n@@ -655,7 +656,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n+    let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>("}, {"sha": "50e2b0f89267d17a63d7a9b093078de9faedb05b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "patch": "@@ -23,10 +23,11 @@ use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedNote;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedNote,\n+    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode,\n };\n \n use std::cmp::Ordering;"}, {"sha": "a871a2501371cdb0a0f94f31ad3b0ddaa1979a9f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "patch": "@@ -3,14 +3,17 @@ pub mod suggestions;\n \n use super::{\n     FulfillmentContext, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n-    Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedDirective,\n-    OnUnimplementedNote, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n-    SelectionContext, SelectionError, TraitNotObjectSafe,\n+    Obligation, ObligationCause, ObligationCauseCode, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n-\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use crate::traits::query::normalize::AtExt as _;\n+use crate::traits::specialize::to_pretty_impl_header;\n+use on_unimplemented::OnUnimplementedNote;\n+use on_unimplemented::TypeErrCtxtExt as _;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -40,11 +43,6 @@ use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n use std::iter;\n use std::ops::ControlFlow;\n-\n-use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::query::normalize::AtExt as _;\n-use crate::traits::specialize::to_pretty_impl_header;\n-use on_unimplemented::TypeErrCtxtExt as _;\n use suggestions::TypeErrCtxtExt as _;\n \n pub use rustc_infer::traits::error_reporting::*;"}, {"sha": "82f0440b3078bb17efbb8d7406f528986eab5b9f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 393, "deletions": 5, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "patch": "@@ -1,14 +1,22 @@\n-use super::{\n-    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n-};\n+use super::{ObligationCauseCode, PredicateObligation};\n use crate::infer::error_reporting::TypeErrCtxt;\n+use rustc_ast::{MetaItem, NestedMetaItem};\n+use rustc_attr as attr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::SubstsRef;\n-use rustc_middle::ty::{self, GenericParamDefKind};\n-use rustc_span::symbol::sym;\n+use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc_parse_format::{ParseMode, Parser, Piece, Position};\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n use std::iter;\n \n+use crate::errors::{\n+    EmptyOnClauseInOnUnimplemented, InvalidOnClauseInOnUnimplemented, NoValueInOnUnimplemented,\n+};\n+\n use super::InferCtxtPrivExt;\n \n pub trait TypeErrCtxtExt<'tcx> {\n@@ -276,3 +284,383 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct OnUnimplementedFormatString(Symbol);\n+\n+#[derive(Debug)]\n+pub struct OnUnimplementedDirective {\n+    pub condition: Option<MetaItem>,\n+    pub subcommands: Vec<OnUnimplementedDirective>,\n+    pub message: Option<OnUnimplementedFormatString>,\n+    pub label: Option<OnUnimplementedFormatString>,\n+    pub note: Option<OnUnimplementedFormatString>,\n+    pub parent_label: Option<OnUnimplementedFormatString>,\n+    pub append_const_msg: Option<Option<Symbol>>,\n+}\n+\n+/// For the `#[rustc_on_unimplemented]` attribute\n+#[derive(Default)]\n+pub struct OnUnimplementedNote {\n+    pub message: Option<String>,\n+    pub label: Option<String>,\n+    pub note: Option<String>,\n+    pub parent_label: Option<String>,\n+    /// Append a message for `~const Trait` errors. `None` means not requested and\n+    /// should fallback to a generic message, `Some(None)` suggests using the default\n+    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n+    /// default one..\n+    pub append_const_msg: Option<Option<Symbol>>,\n+}\n+\n+impl<'tcx> OnUnimplementedDirective {\n+    fn parse(\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        items: &[NestedMetaItem],\n+        span: Span,\n+        is_root: bool,\n+    ) -> Result<Self, ErrorGuaranteed> {\n+        let mut errored = None;\n+        let mut item_iter = items.iter();\n+\n+        let parse_value = |value_str| {\n+            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n+        };\n+\n+        let condition = if is_root {\n+            None\n+        } else {\n+            let cond = item_iter\n+                .next()\n+                .ok_or_else(|| tcx.sess.emit_err(EmptyOnClauseInOnUnimplemented { span }))?\n+                .meta_item()\n+                .ok_or_else(|| tcx.sess.emit_err(InvalidOnClauseInOnUnimplemented { span }))?;\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n+                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n+                    errored = Some(guar);\n+                }\n+                true\n+            });\n+            Some(cond.clone())\n+        };\n+\n+        let mut message = None;\n+        let mut label = None;\n+        let mut note = None;\n+        let mut parent_label = None;\n+        let mut subcommands = vec![];\n+        let mut append_const_msg = None;\n+\n+        for item in item_iter {\n+            if item.has_name(sym::message) && message.is_none() {\n+                if let Some(message_) = item.value_str() {\n+                    message = parse_value(message_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::label) && label.is_none() {\n+                if let Some(label_) = item.value_str() {\n+                    label = parse_value(label_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::note) && note.is_none() {\n+                if let Some(note_) = item.value_str() {\n+                    note = parse_value(note_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::parent_label) && parent_label.is_none() {\n+                if let Some(parent_label_) = item.value_str() {\n+                    parent_label = parse_value(parent_label_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::on)\n+                && is_root\n+                && message.is_none()\n+                && label.is_none()\n+                && note.is_none()\n+            {\n+                if let Some(items) = item.meta_item_list() {\n+                    match Self::parse(tcx, item_def_id, &items, item.span(), false) {\n+                        Ok(subcommand) => subcommands.push(subcommand),\n+                        Err(reported) => errored = Some(reported),\n+                    };\n+                    continue;\n+                }\n+            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n+                if let Some(msg) = item.value_str() {\n+                    append_const_msg = Some(Some(msg));\n+                    continue;\n+                } else if item.is_word() {\n+                    append_const_msg = Some(None);\n+                    continue;\n+                }\n+            }\n+\n+            // nothing found\n+            tcx.sess.emit_err(NoValueInOnUnimplemented { span: item.span() });\n+        }\n+\n+        if let Some(reported) = errored {\n+            Err(reported)\n+        } else {\n+            Ok(OnUnimplementedDirective {\n+                condition,\n+                subcommands,\n+                message,\n+                label,\n+                note,\n+                parent_label,\n+                append_const_msg,\n+            })\n+        }\n+    }\n+\n+    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n+        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n+            return Ok(None);\n+        };\n+\n+        let result = if let Some(items) = attr.meta_item_list() {\n+            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n+        } else if let Some(value) = attr.value_str() {\n+            Ok(Some(OnUnimplementedDirective {\n+                condition: None,\n+                message: None,\n+                subcommands: vec![],\n+                label: Some(OnUnimplementedFormatString::try_parse(\n+                    tcx,\n+                    item_def_id,\n+                    value,\n+                    attr.span,\n+                )?),\n+                note: None,\n+                parent_label: None,\n+                append_const_msg: None,\n+            }))\n+        } else {\n+            let reported =\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"of_item: neither meta_item_list nor value_str\");\n+            return Err(reported);\n+        };\n+        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n+        result\n+    }\n+\n+    pub fn evaluate(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &[(Symbol, Option<String>)],\n+    ) -> OnUnimplementedNote {\n+        let mut message = None;\n+        let mut label = None;\n+        let mut note = None;\n+        let mut parent_label = None;\n+        let mut append_const_msg = None;\n+        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n+\n+        let options_map: FxHashMap<Symbol, String> =\n+            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n+\n+        for command in self.subcommands.iter().chain(Some(self)).rev() {\n+            if let Some(ref condition) = command.condition && !attr::eval_condition(\n+                condition,\n+                &tcx.sess.parse_sess,\n+                Some(tcx.features()),\n+                &mut |cfg| {\n+                    let value = cfg.value.map(|v| {\n+                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n+                    });\n+\n+                    options.contains(&(cfg.name, value))\n+                },\n+            ) {\n+                debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                continue;\n+            }\n+            debug!(\"evaluate: {:?} succeeded\", command);\n+            if let Some(ref message_) = command.message {\n+                message = Some(message_.clone());\n+            }\n+\n+            if let Some(ref label_) = command.label {\n+                label = Some(label_.clone());\n+            }\n+\n+            if let Some(ref note_) = command.note {\n+                note = Some(note_.clone());\n+            }\n+\n+            if let Some(ref parent_label_) = command.parent_label {\n+                parent_label = Some(parent_label_.clone());\n+            }\n+\n+            append_const_msg = command.append_const_msg;\n+        }\n+\n+        OnUnimplementedNote {\n+            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n+            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n+            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n+            parent_label: parent_label.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n+            append_const_msg,\n+        }\n+    }\n+}\n+\n+impl<'tcx> OnUnimplementedFormatString {\n+    fn try_parse(\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        from: Symbol,\n+        err_sp: Span,\n+    ) -> Result<Self, ErrorGuaranteed> {\n+        let result = OnUnimplementedFormatString(from);\n+        result.verify(tcx, item_def_id, err_sp)?;\n+        Ok(result)\n+    }\n+\n+    fn verify(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        span: Span,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        let trait_def_id = if tcx.is_trait(item_def_id) {\n+            item_def_id\n+        } else {\n+            tcx.trait_id_of_impl(item_def_id)\n+                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n+        };\n+        let trait_name = tcx.item_name(trait_def_id);\n+        let generics = tcx.generics_of(item_def_id);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n+        let mut result = Ok(());\n+        for token in parser {\n+            match token {\n+                Piece::String(_) => (), // Normal string, no need to check it\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => {\n+                        match Symbol::intern(s) {\n+                            // `{Self}` is allowed\n+                            kw::SelfUpper => (),\n+                            // `{ThisTraitsName}` is allowed\n+                            s if s == trait_name => (),\n+                            // `{from_method}` is allowed\n+                            sym::from_method => (),\n+                            // `{from_desugaring}` is allowed\n+                            sym::from_desugaring => (),\n+                            // `{ItemContext}` is allowed\n+                            sym::ItemContext => (),\n+                            // `{integral}` and `{integer}` and `{float}` are allowed\n+                            sym::integral | sym::integer_ | sym::float => (),\n+                            // So is `{A}` if A is a type parameter\n+                            s => match generics.params.iter().find(|param| param.name == s) {\n+                                Some(_) => (),\n+                                None => {\n+                                    let reported = struct_span_err!(\n+                                        tcx.sess,\n+                                        span,\n+                                        E0230,\n+                                        \"there is no parameter `{}` on {}\",\n+                                        s,\n+                                        if trait_def_id == item_def_id {\n+                                            format!(\"trait `{}`\", trait_name)\n+                                        } else {\n+                                            \"impl\".to_string()\n+                                        }\n+                                    )\n+                                    .emit();\n+                                    result = Err(reported);\n+                                }\n+                            },\n+                        }\n+                    }\n+                    // `{:1}` and `{}` are not to be used\n+                    Position::ArgumentIs(..) | Position::ArgumentImplicitlyIs(_) => {\n+                        let reported = struct_span_err!(\n+                            tcx.sess,\n+                            span,\n+                            E0231,\n+                            \"only named substitution parameters are allowed\"\n+                        )\n+                        .emit();\n+                        result = Err(reported);\n+                    }\n+                },\n+            }\n+        }\n+\n+        result\n+    }\n+\n+    pub fn format(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &FxHashMap<Symbol, String>,\n+    ) -> String {\n+        let name = tcx.item_name(trait_ref.def_id);\n+        let trait_str = tcx.def_path_str(trait_ref.def_id);\n+        let generics = tcx.generics_of(trait_ref.def_id);\n+        let generic_map = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| {\n+                let value = match param.kind {\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                        trait_ref.substs[param.index as usize].to_string()\n+                    }\n+                    GenericParamDefKind::Lifetime => return None,\n+                };\n+                let name = param.name;\n+                Some((name, value))\n+            })\n+            .collect::<FxHashMap<Symbol, String>>();\n+        let empty_string = String::new();\n+\n+        let s = self.0.as_str();\n+        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n+        let item_context = (options.get(&sym::ItemContext)).unwrap_or(&empty_string);\n+        parser\n+            .map(|p| match p {\n+                Piece::String(s) => s,\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => {\n+                        let s = Symbol::intern(s);\n+                        match generic_map.get(&s) {\n+                            Some(val) => val,\n+                            None if s == name => &trait_str,\n+                            None => {\n+                                if let Some(val) = options.get(&s) {\n+                                    val\n+                                } else if s == sym::from_desugaring || s == sym::from_method {\n+                                    // don't break messages using these two arguments incorrectly\n+                                    &empty_string\n+                                } else if s == sym::ItemContext {\n+                                    &item_context\n+                                } else if s == sym::integral {\n+                                    \"{integral}\"\n+                                } else if s == sym::integer_ {\n+                                    \"{integer}\"\n+                                } else if s == sym::float {\n+                                    \"{float}\"\n+                                } else {\n+                                    bug!(\n+                                        \"broken on_unimplemented {:?} for {:?}: \\\n+                                      no argument matching {:?}\",\n+                                        self.0,\n+                                        trait_ref,\n+                                        s\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n+                },\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "408dc7d3bd8f81f662f8d4abe79724d368843fda", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e4e72fcd180ef62baa3a5c2e03fad75e41848b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=80e4e72fcd180ef62baa3a5c2e03fad75e41848b", "patch": "@@ -12,7 +12,6 @@ pub mod error_reporting;\n mod fulfill;\n pub mod misc;\n mod object_safety;\n-mod on_unimplemented;\n pub mod outlives_bounds;\n mod project;\n pub mod query;\n@@ -58,7 +57,6 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::{normalize, normalize_projection_type, normalize_to};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};"}, {"sha": "fb062ea71c4ce775bf6c74cf4c153dde6a74a1f3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/9b735a7132acd58b3bd34c084e9ca5b4ca7450a2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b735a7132acd58b3bd34c084e9ca5b4ca7450a2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=9b735a7132acd58b3bd34c084e9ca5b4ca7450a2", "patch": "@@ -1,393 +0,0 @@\n-use rustc_ast::{MetaItem, NestedMetaItem};\n-use rustc_attr as attr;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n-use rustc_parse_format::{ParseMode, Parser, Piece, Position};\n-use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n-\n-use crate::errors::{\n-    EmptyOnClauseInOnUnimplemented, InvalidOnClauseInOnUnimplemented, NoValueInOnUnimplemented,\n-};\n-\n-#[derive(Clone, Debug)]\n-pub struct OnUnimplementedFormatString(Symbol);\n-\n-#[derive(Debug)]\n-pub struct OnUnimplementedDirective {\n-    pub condition: Option<MetaItem>,\n-    pub subcommands: Vec<OnUnimplementedDirective>,\n-    pub message: Option<OnUnimplementedFormatString>,\n-    pub label: Option<OnUnimplementedFormatString>,\n-    pub note: Option<OnUnimplementedFormatString>,\n-    pub parent_label: Option<OnUnimplementedFormatString>,\n-    pub append_const_msg: Option<Option<Symbol>>,\n-}\n-\n-#[derive(Default)]\n-/// For the `#[rustc_on_unimplemented]` attribute\n-pub struct OnUnimplementedNote {\n-    pub message: Option<String>,\n-    pub label: Option<String>,\n-    pub note: Option<String>,\n-    pub parent_label: Option<String>,\n-    /// Append a message for `~const Trait` errors. `None` means not requested and\n-    /// should fallback to a generic message, `Some(None)` suggests using the default\n-    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n-    /// default one..\n-    pub append_const_msg: Option<Option<Symbol>>,\n-}\n-\n-impl<'tcx> OnUnimplementedDirective {\n-    fn parse(\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        items: &[NestedMetaItem],\n-        span: Span,\n-        is_root: bool,\n-    ) -> Result<Self, ErrorGuaranteed> {\n-        let mut errored = None;\n-        let mut item_iter = items.iter();\n-\n-        let parse_value = |value_str| {\n-            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n-        };\n-\n-        let condition = if is_root {\n-            None\n-        } else {\n-            let cond = item_iter\n-                .next()\n-                .ok_or_else(|| tcx.sess.emit_err(EmptyOnClauseInOnUnimplemented { span }))?\n-                .meta_item()\n-                .ok_or_else(|| tcx.sess.emit_err(InvalidOnClauseInOnUnimplemented { span }))?;\n-            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n-                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n-                    errored = Some(guar);\n-                }\n-                true\n-            });\n-            Some(cond.clone())\n-        };\n-\n-        let mut message = None;\n-        let mut label = None;\n-        let mut note = None;\n-        let mut parent_label = None;\n-        let mut subcommands = vec![];\n-        let mut append_const_msg = None;\n-\n-        for item in item_iter {\n-            if item.has_name(sym::message) && message.is_none() {\n-                if let Some(message_) = item.value_str() {\n-                    message = parse_value(message_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::label) && label.is_none() {\n-                if let Some(label_) = item.value_str() {\n-                    label = parse_value(label_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::note) && note.is_none() {\n-                if let Some(note_) = item.value_str() {\n-                    note = parse_value(note_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::parent_label) && parent_label.is_none() {\n-                if let Some(parent_label_) = item.value_str() {\n-                    parent_label = parse_value(parent_label_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::on)\n-                && is_root\n-                && message.is_none()\n-                && label.is_none()\n-                && note.is_none()\n-            {\n-                if let Some(items) = item.meta_item_list() {\n-                    match Self::parse(tcx, item_def_id, &items, item.span(), false) {\n-                        Ok(subcommand) => subcommands.push(subcommand),\n-                        Err(reported) => errored = Some(reported),\n-                    };\n-                    continue;\n-                }\n-            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n-                if let Some(msg) = item.value_str() {\n-                    append_const_msg = Some(Some(msg));\n-                    continue;\n-                } else if item.is_word() {\n-                    append_const_msg = Some(None);\n-                    continue;\n-                }\n-            }\n-\n-            // nothing found\n-            tcx.sess.emit_err(NoValueInOnUnimplemented { span: item.span() });\n-        }\n-\n-        if let Some(reported) = errored {\n-            Err(reported)\n-        } else {\n-            Ok(OnUnimplementedDirective {\n-                condition,\n-                subcommands,\n-                message,\n-                label,\n-                note,\n-                parent_label,\n-                append_const_msg,\n-            })\n-        }\n-    }\n-\n-    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n-        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n-            return Ok(None);\n-        };\n-\n-        let result = if let Some(items) = attr.meta_item_list() {\n-            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n-        } else if let Some(value) = attr.value_str() {\n-            Ok(Some(OnUnimplementedDirective {\n-                condition: None,\n-                message: None,\n-                subcommands: vec![],\n-                label: Some(OnUnimplementedFormatString::try_parse(\n-                    tcx,\n-                    item_def_id,\n-                    value,\n-                    attr.span,\n-                )?),\n-                note: None,\n-                parent_label: None,\n-                append_const_msg: None,\n-            }))\n-        } else {\n-            let reported =\n-                tcx.sess.delay_span_bug(DUMMY_SP, \"of_item: neither meta_item_list nor value_str\");\n-            return Err(reported);\n-        };\n-        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n-        result\n-    }\n-\n-    pub fn evaluate(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        options: &[(Symbol, Option<String>)],\n-    ) -> OnUnimplementedNote {\n-        let mut message = None;\n-        let mut label = None;\n-        let mut note = None;\n-        let mut parent_label = None;\n-        let mut append_const_msg = None;\n-        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n-\n-        let options_map: FxHashMap<Symbol, String> =\n-            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n-\n-        for command in self.subcommands.iter().chain(Some(self)).rev() {\n-            if let Some(ref condition) = command.condition && !attr::eval_condition(\n-                condition,\n-                &tcx.sess.parse_sess,\n-                Some(tcx.features()),\n-                &mut |cfg| {\n-                    let value = cfg.value.map(|v| {\n-                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n-                    });\n-\n-                    options.contains(&(cfg.name, value))\n-                },\n-            ) {\n-                debug!(\"evaluate: skipping {:?} due to condition\", command);\n-                continue;\n-            }\n-            debug!(\"evaluate: {:?} succeeded\", command);\n-            if let Some(ref message_) = command.message {\n-                message = Some(message_.clone());\n-            }\n-\n-            if let Some(ref label_) = command.label {\n-                label = Some(label_.clone());\n-            }\n-\n-            if let Some(ref note_) = command.note {\n-                note = Some(note_.clone());\n-            }\n-\n-            if let Some(ref parent_label_) = command.parent_label {\n-                parent_label = Some(parent_label_.clone());\n-            }\n-\n-            append_const_msg = command.append_const_msg;\n-        }\n-\n-        OnUnimplementedNote {\n-            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n-            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n-            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n-            parent_label: parent_label.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n-            append_const_msg,\n-        }\n-    }\n-}\n-\n-impl<'tcx> OnUnimplementedFormatString {\n-    fn try_parse(\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        from: Symbol,\n-        err_sp: Span,\n-    ) -> Result<Self, ErrorGuaranteed> {\n-        let result = OnUnimplementedFormatString(from);\n-        result.verify(tcx, item_def_id, err_sp)?;\n-        Ok(result)\n-    }\n-\n-    fn verify(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        span: Span,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        let trait_def_id = if tcx.is_trait(item_def_id) {\n-            item_def_id\n-        } else {\n-            tcx.trait_id_of_impl(item_def_id)\n-                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n-        };\n-        let trait_name = tcx.item_name(trait_def_id);\n-        let generics = tcx.generics_of(item_def_id);\n-        let s = self.0.as_str();\n-        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n-        let mut result = Ok(());\n-        for token in parser {\n-            match token {\n-                Piece::String(_) => (), // Normal string, no need to check it\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => {\n-                        match Symbol::intern(s) {\n-                            // `{Self}` is allowed\n-                            kw::SelfUpper => (),\n-                            // `{ThisTraitsName}` is allowed\n-                            s if s == trait_name => (),\n-                            // `{from_method}` is allowed\n-                            sym::from_method => (),\n-                            // `{from_desugaring}` is allowed\n-                            sym::from_desugaring => (),\n-                            // `{ItemContext}` is allowed\n-                            sym::ItemContext => (),\n-                            // `{integral}` and `{integer}` and `{float}` are allowed\n-                            sym::integral | sym::integer_ | sym::float => (),\n-                            // So is `{A}` if A is a type parameter\n-                            s => match generics.params.iter().find(|param| param.name == s) {\n-                                Some(_) => (),\n-                                None => {\n-                                    let reported = struct_span_err!(\n-                                        tcx.sess,\n-                                        span,\n-                                        E0230,\n-                                        \"there is no parameter `{}` on {}\",\n-                                        s,\n-                                        if trait_def_id == item_def_id {\n-                                            format!(\"trait `{}`\", trait_name)\n-                                        } else {\n-                                            \"impl\".to_string()\n-                                        }\n-                                    )\n-                                    .emit();\n-                                    result = Err(reported);\n-                                }\n-                            },\n-                        }\n-                    }\n-                    // `{:1}` and `{}` are not to be used\n-                    Position::ArgumentIs(..) | Position::ArgumentImplicitlyIs(_) => {\n-                        let reported = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0231,\n-                            \"only named substitution parameters are allowed\"\n-                        )\n-                        .emit();\n-                        result = Err(reported);\n-                    }\n-                },\n-            }\n-        }\n-\n-        result\n-    }\n-\n-    pub fn format(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        options: &FxHashMap<Symbol, String>,\n-    ) -> String {\n-        let name = tcx.item_name(trait_ref.def_id);\n-        let trait_str = tcx.def_path_str(trait_ref.def_id);\n-        let generics = tcx.generics_of(trait_ref.def_id);\n-        let generic_map = generics\n-            .params\n-            .iter()\n-            .filter_map(|param| {\n-                let value = match param.kind {\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                        trait_ref.substs[param.index as usize].to_string()\n-                    }\n-                    GenericParamDefKind::Lifetime => return None,\n-                };\n-                let name = param.name;\n-                Some((name, value))\n-            })\n-            .collect::<FxHashMap<Symbol, String>>();\n-        let empty_string = String::new();\n-\n-        let s = self.0.as_str();\n-        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n-        let item_context = (options.get(&sym::ItemContext)).unwrap_or(&empty_string);\n-        parser\n-            .map(|p| match p {\n-                Piece::String(s) => s,\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => {\n-                        let s = Symbol::intern(s);\n-                        match generic_map.get(&s) {\n-                            Some(val) => val,\n-                            None if s == name => &trait_str,\n-                            None => {\n-                                if let Some(val) = options.get(&s) {\n-                                    val\n-                                } else if s == sym::from_desugaring || s == sym::from_method {\n-                                    // don't break messages using these two arguments incorrectly\n-                                    &empty_string\n-                                } else if s == sym::ItemContext {\n-                                    &item_context\n-                                } else if s == sym::integral {\n-                                    \"{integral}\"\n-                                } else if s == sym::integer_ {\n-                                    \"{integer}\"\n-                                } else if s == sym::float {\n-                                    \"{float}\"\n-                                } else {\n-                                    bug!(\n-                                        \"broken on_unimplemented {:?} for {:?}: \\\n-                                      no argument matching {:?}\",\n-                                        self.0,\n-                                        trait_ref,\n-                                        s\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n-                },\n-            })\n-            .collect()\n-    }\n-}"}]}