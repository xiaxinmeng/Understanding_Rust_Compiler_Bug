{"sha": "812744001494e89940569be20044fd1bbceafbb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMjc0NDAwMTQ5NGU4OTk0MDU2OWJlMjAwNDRmZDFiYmNlYWZiYjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-11T08:53:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-11T08:53:16Z"}, "message": "Merge pull request #391 from bjorn3/clippy_fixes\n\nClippy fixes", "tree": {"sha": "d8396baf41f31346b36c8faaa4db8080cb95292c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8396baf41f31346b36c8faaa4db8080cb95292c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/812744001494e89940569be20044fd1bbceafbb7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbRcV8CRBK7hj4Ov3rIwAAdHIIAD1uS2oi2UVlhgpmQuyxDjpF\n2FBHC9GfY3xqENTsc2f59IXkuuhXcmP7G792fXo7iF11Qj7f3G/Hu70N6rWPLf2Z\nLYtTEtMMg6F19B50D2lCOyxSU4p+03t5ZHS2iH2nMhgqcInjqba5dGqba90e8O/F\na09lLvl6vGHJTnnwq8Pj8p/Mg2pBqimcJBVfTqVD8oR1NVhlZi1jZ/w+EyFIyohC\nAgTF6KyPRzUewYjvjsGXuNv0Hxx8OeZ+rTwoh5XY+GJA8gncgok4GW1dzXWZcmBt\nlh0ZIKS9xRLAEKZjwSrZt6Zf2I1NDlE4nuBi/tli24lAFRvLW8pcIHwx//+Hk0I=\n=p/FZ\n-----END PGP SIGNATURE-----\n", "payload": "tree d8396baf41f31346b36c8faaa4db8080cb95292c\nparent 9143a69f4b3ef4bda77afddefe934be363e39f31\nparent 52bf4732fd51332632f4154bb45df13871320ceb\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1531299196 +0200\ncommitter GitHub <noreply@github.com> 1531299196 +0200\n\nMerge pull request #391 from bjorn3/clippy_fixes\n\nClippy fixes"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/812744001494e89940569be20044fd1bbceafbb7", "html_url": "https://github.com/rust-lang/rust/commit/812744001494e89940569be20044fd1bbceafbb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/812744001494e89940569be20044fd1bbceafbb7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9143a69f4b3ef4bda77afddefe934be363e39f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/9143a69f4b3ef4bda77afddefe934be363e39f31", "html_url": "https://github.com/rust-lang/rust/commit/9143a69f4b3ef4bda77afddefe934be363e39f31"}, {"sha": "52bf4732fd51332632f4154bb45df13871320ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/52bf4732fd51332632f4154bb45df13871320ceb", "html_url": "https://github.com/rust-lang/rust/commit/52bf4732fd51332632f4154bb45df13871320ceb"}], "stats": {"total": 112, "additions": 52, "deletions": 60}, "files": [{"sha": "d2149ee5dbe7d3ee75280440acf226f16237b25f", "filename": "src/fn_call.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n-                    let ptr = self.memory.allocate(Size::from_bytes(size), align, Some(MemoryKind::C.into()))?;\n+                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MemoryKind::C.into())?;\n                     self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n                 }\n             }\n@@ -268,7 +268,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 )?;\n                 let mut args = self.frame().mir.args_iter();\n \n-                let arg_local = args.next().ok_or(\n+                let arg_local = args.next().ok_or_else(||\n                     EvalErrorKind::AbiViolation(\n                         \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n                             .to_owned(),\n@@ -395,7 +395,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     let value_copy = self.memory.allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n-                        Some(MemoryKind::Env.into()),\n+                        MemoryKind::Env.into(),\n                     )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n@@ -504,7 +504,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_type = args[0].ty.builtin_deref(true)\n-                                   .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                                   .ok_or_else(|| EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = self.layout_of(key_type)?.size;\n \n                 // Create key and write it into the memory where key_ptr wants it\n@@ -656,7 +656,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n-                                               Some(MemoryKind::Rust.into()))?;\n+                                               MemoryKind::Rust.into())?;\n                 self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::alloc::::__rust_alloc_zeroed\" => {\n@@ -670,7 +670,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n-                                               Some(MemoryKind::Rust.into()))?;\n+                                               MemoryKind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n@@ -747,7 +747,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         // current frame.\n         self.dump_local(dest);\n         self.goto_block(dest_block);\n-        return Ok(());\n+        Ok(())\n     }\n \n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {"}, {"sha": "aa699b509fad8a4210c7ac177b475afdcfe2082f", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+         if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.ptr_signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let Scalar::Ptr(ptr) = ptr {\n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             Ok(ptr)\n         } else {\n             err!(Overflow(mir::BinOp::Mul))\n-        };\n+        }\n     }\n \n     fn value_to_isize("}, {"sha": "88bca91aa2de5ab2c0ff251e50976be06c9de031", "filename": "src/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -5,6 +5,8 @@\n     inclusive_range_methods,\n )]\n \n+#![cfg_attr(feature = \"cargo-clippy\", allow(cast_lossless))]\n+\n #[macro_use]\n extern crate log;\n \n@@ -24,7 +26,6 @@ use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::ty::subst::Subst;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::middle::const_val;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n@@ -172,7 +173,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // Return value\n         let size = ecx.tcx.data_layout.pointer_size;\n         let align = ecx.tcx.data_layout.pointer_align;\n-        let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n+        let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n         cleanup_ptr = Some(ret_ptr);\n \n         // Push our stack frame\n@@ -211,7 +212,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n         let ptr_size = ecx.memory.pointer_size();\n         let ptr_align = ecx.tcx.data_layout.pointer_align;\n-        let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n+        let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, MemoryKind::Stack)?;\n         ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n         ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n         ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n@@ -270,10 +271,10 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                     block.terminator().source_info.span\n                 };\n \n-                let mut err = const_val::struct_error(ecx.tcx.tcx.at(span), \"constant evaluation error\");\n+                let mut err = struct_error(ecx.tcx.tcx.at(span), \"constant evaluation error\");\n                 let (frames, span) = ecx.generate_stacktrace(None);\n                 err.span_label(span, e.to_string());\n-                for const_val::FrameInfo { span, location, .. } in frames {\n+                for FrameInfo { span, location, .. } in frames {\n                     err.span_note(span, &format!(\"inside call to `{}`\", location));\n                 }\n                 err.emit();\n@@ -405,7 +406,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let ptr = ecx.memory.allocate(\n             layout.size,\n             layout.align,\n-            None,\n+            MemoryKind::Stack,\n         )?;\n \n         // Step 4: Cache allocation id for recursive statics\n@@ -428,14 +429,11 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 let frame = ecx.frame_mut();\n                 let bb = &frame.mir.basic_blocks()[frame.block];\n                 if bb.statements.len() == frame.stmt && !bb.is_cleanup {\n-                    match bb.terminator().kind {\n-                        ::rustc::mir::TerminatorKind::Return => {\n-                            for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n-                                // Don't deallocate locals, because the return value might reference them\n-                                frame.storage_dead(local);\n-                            }\n+                    if let ::rustc::mir::TerminatorKind::Return = bb.terminator().kind {\n+                        for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n+                            // Don't deallocate locals, because the return value might reference them\n+                            frame.storage_dead(local);\n                         }\n-                        _ => {}\n                     }\n                 }\n             }\n@@ -479,7 +477,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 value: Value::Scalar(Scalar::from_u128(match layout.size.bytes() {\n                     0 => 1 as u128,\n                     size => size as u128,\n-                }.into())),\n+                })),\n                 ty: usize,\n             },\n             dest,"}, {"sha": "3b67c9bb7f3e4ef020095a2f25a45fc253f30fb5", "filename": "src/locks.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -241,11 +241,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n                     // All is well\n                     continue 'locks;\n                 }\n-            } else {\n-                if !is_our_lock {\n-                    // All is well.\n-                    continue 'locks;\n-                }\n+            } else if !is_our_lock {\n+                // All is well.\n+                continue 'locks;\n             }\n             // If we get here, releasing this is an error except for NoLock.\n             if lock.active != NoLock {\n@@ -377,7 +375,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             }\n             // Clean up the map\n             alloc_locks.retain(|lock| match lock.active {\n-                NoLock => lock.suspended.len() > 0,\n+                NoLock => !lock.suspended.is_empty(),\n                 _ => true,\n             });\n         }"}, {"sha": "1440f1dab4e0fc8187cadb09490907e0d329d7b0", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset(\n-                    left.into(),\n+                    left,\n                     pointee_ty,\n                     right.to_bits(self.memory.pointer_size())? as i64,\n                 )?;"}, {"sha": "fcffaf7128f11704a663a0b41b983486868527ef", "filename": "src/range_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -19,7 +19,7 @@ pub struct RangeMap<T> {\n // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n // This kind of search breaks, if `end < start`, so don't do that!\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-struct Range {\n+pub struct Range {\n     start: u64,\n     end: u64, // Invariant: end > start\n }\n@@ -189,7 +189,7 @@ impl<T> RangeMap<T> {\n         F: FnMut(&T) -> bool,\n     {\n         let mut remove = Vec::new();\n-        for (range, data) in self.map.iter() {\n+        for (range, data) in &self.map {\n             if !f(data) {\n                 remove.push(*range);\n             }"}, {"sha": "45805f3aa8cc1199e15b24ede7dfecf42b95f57e", "filename": "src/tls.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -30,38 +30,38 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             },\n         );\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n+        new_key\n     }\n \n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.remove(&key) {\n+        match self.data.thread_local.remove(&key) {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n-        return match self.data.thread_local.get(&key) {\n+        match self.data.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.get_mut(&key) {\n+        match self.data.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n                 *data = new_data;\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     /// Returns a dtor, its argument and its index, if one is supposed to run\n@@ -104,7 +104,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n                 }\n             }\n         }\n-        return Ok(None);\n+        Ok(None)\n     }\n }\n \n@@ -124,8 +124,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 Place::undef(),\n                 StackPopCleanup::None,\n             )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(\n-                EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n+            let arg_local = self.frame().mir.args_iter().next().ok_or_else(\n+                || EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n             )?;\n             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);"}, {"sha": "758fd5d274701c409415b8e42f1504a0978eaf8d", "filename": "src/validation.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/812744001494e89940569be20044fd1bbceafbb7/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812744001494e89940569be20044fd1bbceafbb7/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=812744001494e89940569be20044fd1bbceafbb7", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::subst::{Substs, Subst};\n use rustc::traits::{self, TraitEngine};\n use rustc::infer::InferCtxt;\n use rustc::middle::region;\n-use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{ConstValue};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::interpret::HasMemory;\n \n@@ -135,10 +135,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n     }\n \n     fn abstract_place(&self, place: &mir::Place<'tcx>) -> EvalResult<'tcx, AbsPlace<'tcx>> {\n-        Ok(match place {\n-            &mir::Place::Local(l) => AbsPlace::Local(l),\n-            &mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n-            &mir::Place::Projection(ref p) =>\n+        Ok(match *place {\n+            mir::Place::Local(l) => AbsPlace::Local(l),\n+            mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n+            mir::Place::Projection(ref p) =>\n                 AbsPlace::Projection(Box::new(self.abstract_place_projection(&*p)?)),\n         })\n     }\n@@ -378,11 +378,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         mut layout: ty::layout::TyLayout<'tcx>,\n         i: usize,\n     ) -> EvalResult<'tcx, Ty<'tcx>> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                layout = layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n+        if let Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } = base {\n+            layout = layout.for_variant(&self, variant_index);\n         }\n         let tcx = self.tcx.tcx;\n         Ok(match layout.ty.sty {\n@@ -667,12 +664,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n                     // we record the region of this borrow to the context.\n                     if query.re == None {\n-                        match *region {\n-                            ReScope(scope) => query.re = Some(scope),\n-                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                            // this functions' Subst will be erased.\n-                            _ => {}\n+                        if let ReScope(scope) = *region {\n+                            query.re = Some(scope);\n                         }\n+                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n                     }\n                     self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)?;\n                 }\n@@ -719,14 +715,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 TyArray(elem_ty, len) => {\n                     let len = match len.val {\n-                        ConstVal::Unevaluated(def_id, substs) => {\n+                        ConstValue::Unevaluated(def_id, substs) => {\n                             self.tcx.const_eval(self.tcx.param_env(def_id).and(GlobalId {\n                                 instance: Instance::new(def_id, substs),\n                                 promoted: None,\n                             }))\n                                 .map_err(|_err|EvalErrorKind::MachineError(\"<already reported>\".to_string()))?\n                         }\n-                        ConstVal::Value(_) => len,\n+                        _ => len,\n                     };\n                     let len = len.unwrap_usize(self.tcx.tcx);\n                     for i in 0..len {\n@@ -772,7 +768,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                             let variant_idx = self.read_discriminant_as_variant_index(query.place.1, query.ty)?;\n                             let variant = &adt.variants[variant_idx];\n \n-                            if variant.fields.len() > 0 {\n+                            if !variant.fields.is_empty() {\n                                 // Downcast to this variant, if needed\n                                 let place = if adt.is_enum() {\n                                     ("}]}