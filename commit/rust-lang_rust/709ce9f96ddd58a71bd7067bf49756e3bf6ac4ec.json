{"sha": "709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwOWNlOWY5NmRkZDU4YTcxYmQ3MDY3YmY0OTc1NmUzYmY2YWM0ZWM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-30T19:28:27Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-30T21:14:56Z"}, "message": "kill the fake provided method stubs\n\nthis simplifies the code while reducing the size of libcore.rlib by\n3.3 MiB (~1M of which is bloat a separate patch of mine removes\ntoo), while reducing rustc memory usage on small crates by 18MiB.\n\nThis also simplifies the code considerably.", "tree": {"sha": "8a9c3d326252449707eedc6c7ad02308a491e9ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a9c3d326252449707eedc6c7ad02308a491e9ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "html_url": "https://github.com/rust-lang/rust/commit/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/comments", "author": null, "committer": null, "parents": [{"sha": "3e6d7243ae9749eff27fd320cb422e42291e79d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6d7243ae9749eff27fd320cb422e42291e79d4", "html_url": "https://github.com/rust-lang/rust/commit/3e6d7243ae9749eff27fd320cb422e42291e79d4"}], "stats": {"total": 473, "additions": 139, "deletions": 334}, "files": [{"sha": "a6cbb4ec50490467bed45a7a6fac0d6582477826", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -180,7 +180,7 @@ pub const tag_mod_child: usize = 0x7b;\n pub const tag_misc_info: usize = 0x108; // top-level only\n pub const tag_misc_info_crate_items: usize = 0x7c;\n \n-pub const tag_item_method_provided_source: usize = 0x7d;\n+// GAP 0x7d\n pub const tag_item_impl_vtables: usize = 0x7e;\n \n pub const tag_impls: usize = 0x109; // top-level only"}, {"sha": "77863ee3c87a2f8509052fbf4166134b97b0fd6d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -187,12 +187,6 @@ fn item_def_id(d: rbml::Doc, cdata: Cmd) -> DefId {\n     translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n }\n \n-fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<DefId> {\n-    reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n-        translated_def_id(cdata, doc)\n-    })\n-}\n-\n fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n     reader::tagged_docs(d, tag_items_data_item_reexport)\n }\n@@ -276,11 +270,14 @@ fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n     match fam {\n         Constant  => {\n             // Check whether we have an associated const item.\n-            if item_sort(item) == Some('C') {\n-                DlDef(def::DefAssociatedConst(did))\n-            } else {\n-                // Regular const item.\n-                DlDef(def::DefConst(did))\n+            match item_sort(item) {\n+                Some('C') | Some('c') => {\n+                    DlDef(def::DefAssociatedConst(did))\n+                }\n+                _ => {\n+                    // Regular const item.\n+                    DlDef(def::DefConst(did))\n+                }\n             }\n         }\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n@@ -818,7 +815,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n     reader::tagged_docs(cdata.lookup_item(impl_id), tag_item_impl_item).map(|doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n-            Some('C') => ty::ConstTraitItemId(def_id),\n+            Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n             Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n             Some('t') => ty::TypeTraitItemId(def_id),\n             _ => panic!(\"unknown impl item sort\"),\n@@ -864,24 +861,22 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(item_doc);\n \n     match item_sort(item_doc) {\n-        Some('C') => {\n+        sort @ Some('C') | sort @ Some('c') => {\n             let ty = doc_type(item_doc, tcx, cdata);\n-            let default = get_provided_source(item_doc, cdata);\n             ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n                 name: name,\n                 ty: ty,\n                 vis: vis,\n                 def_id: def_id,\n                 container: container,\n-                default: default,\n+                has_value: sort == Some('C')\n             }))\n         }\n         Some('r') | Some('p') => {\n             let generics = doc_generics(item_doc, tcx, cdata, tag_method_ty_generics);\n             let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n             let fty = doc_method_fty(item_doc, tcx, cdata);\n             let explicit_self = get_explicit_self(item_doc);\n-            let provided_source = get_provided_source(item_doc, cdata);\n \n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n                                                         generics,\n@@ -890,8 +885,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                                         explicit_self,\n                                                         vis,\n                                                         def_id,\n-                                                        container,\n-                                                        provided_source)))\n+                                                        container)))\n         }\n         Some('t') => {\n             let ty = maybe_doc_type(item_doc, tcx, cdata);\n@@ -913,7 +907,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n-            Some('C') => ty::ConstTraitItemId(def_id),\n+            Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n             Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n             Some('t') => ty::TypeTraitItemId(def_id),\n             _ => panic!(\"unknown trait item sort\"),\n@@ -967,18 +961,19 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n             let did = item_def_id(ac_id, cdata);\n             let ac_doc = cdata.lookup_item(did.node);\n \n-            if item_sort(ac_doc) == Some('C') {\n-                let trait_item = get_impl_or_trait_item(intr.clone(),\n-                                                        cdata,\n-                                                        did.node,\n-                                                        tcx);\n-                if let ty::ConstTraitItem(ref ac) = trait_item {\n-                    Some((*ac).clone())\n-                } else {\n-                    None\n+            match item_sort(ac_doc) {\n+                Some('C') | Some('c') => {\n+                    let trait_item = get_impl_or_trait_item(intr.clone(),\n+                                                            cdata,\n+                                                            did.node,\n+                                                            tcx);\n+                    if let ty::ConstTraitItem(ref ac) = trait_item {\n+                        Some((*ac).clone())\n+                    } else {\n+                        None\n+                    }\n                 }\n-            } else {\n-                None\n+                _ => None\n             }\n         })\n     }).collect()"}, {"sha": "0d83103e0bb495573d1271b44d71d1f65198b061", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -609,13 +609,6 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.wr_tagged_u8(tag_item_trait_parent_sort, sort as u8);\n }\n \n-fn encode_provided_source(rbml_w: &mut Encoder,\n-                          source_opt: Option<DefId>) {\n-    if let Some(source) = source_opt {\n-        rbml_w.wr_tagged_u64(tag_item_method_provided_source, def_to_u64(source));\n-    }\n-}\n-\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n@@ -776,7 +769,6 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         _ => encode_family(rbml_w, METHOD_FAMILY)\n     }\n-    encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n fn encode_info_for_associated_const(ecx: &EncodeContext,\n@@ -795,7 +787,6 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_name(rbml_w, associated_const.name);\n     encode_visibility(rbml_w, associated_const.vis);\n     encode_family(rbml_w, 'C');\n-    encode_provided_source(rbml_w, associated_const.default);\n \n     encode_parent_item(rbml_w, DefId::local(parent_id));\n     encode_item_sort(rbml_w, 'C');\n@@ -1367,13 +1358,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_def_id(rbml_w, associated_const.def_id);\n                     encode_visibility(rbml_w, associated_const.vis);\n \n-                    encode_provided_source(rbml_w, associated_const.default);\n-\n                     let elem = ast_map::PathName(associated_const.name);\n                     encode_path(rbml_w,\n                                 path.clone().chain(Some(elem)));\n \n-                    encode_item_sort(rbml_w, 'C');\n                     encode_family(rbml_w, 'C');\n \n                     encode_bounds_and_type_for_item(rbml_w, ecx,\n@@ -1429,7 +1417,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n-                hir::ConstTraitItem(_, _) => {\n+                hir::ConstTraitItem(_, ref default) => {\n+                    if default.is_some() {\n+                        encode_item_sort(rbml_w, 'C');\n+                    } else {\n+                        encode_item_sort(rbml_w, 'c');\n+                    }\n+\n                     encode_inlined_item(ecx, rbml_w,\n                                         InlinedItemRef::TraitItem(def_id, trait_item));\n                 }"}, {"sha": "57f04af2ba9138103fc05397540fa3356e2a8f75", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -235,8 +235,6 @@ pub struct ctxt<'tcx> {\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n-    /// A mapping of fake provided method def_ids to the default implementation\n-    pub provided_method_sources: RefCell<DefIdMap<DefId>>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n@@ -471,7 +469,6 @@ impl<'tcx> ctxt<'tcx> {\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n-            provided_method_sources: RefCell::new(DefIdMap()),\n             inherent_impls: RefCell::new(DefIdMap()),\n             impl_items: RefCell::new(DefIdMap()),\n             used_unsafe: RefCell::new(NodeSet()),"}, {"sha": "7ec39619d9cfd4be156c7eff57016589ecbbc825", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -235,9 +235,6 @@ pub struct Method<'tcx> {\n     pub vis: hir::Visibility,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n-\n-    // If this method is provided, we need to know where it came from\n-    pub provided_source: Option<DefId>\n }\n \n impl<'tcx> Method<'tcx> {\n@@ -248,8 +245,7 @@ impl<'tcx> Method<'tcx> {\n                explicit_self: ExplicitSelfCategory,\n                vis: hir::Visibility,\n                def_id: DefId,\n-               container: ImplOrTraitItemContainer,\n-               provided_source: Option<DefId>)\n+               container: ImplOrTraitItemContainer)\n                -> Method<'tcx> {\n        Method {\n             name: name,\n@@ -260,7 +256,6 @@ impl<'tcx> Method<'tcx> {\n             vis: vis,\n             def_id: def_id,\n             container: container,\n-            provided_source: provided_source\n         }\n     }\n \n@@ -293,7 +288,7 @@ pub struct AssociatedConst<'tcx> {\n     pub vis: hir::Visibility,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n-    pub default: Option<DefId>,\n+    pub has_value: bool\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -2105,10 +2100,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn provided_source(&self, id: DefId) -> Option<DefId> {\n-        self.provided_method_sources.borrow().get(&id).cloned()\n-    }\n-\n     pub fn provided_trait_methods(&self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n         if id.is_local() {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id.node).node {\n@@ -2477,16 +2468,9 @@ impl<'tcx> ctxt<'tcx> {\n             // the map. This is a bit unfortunate.\n             for impl_item_def_id in &impl_items {\n                 let method_def_id = impl_item_def_id.def_id();\n-                match self.impl_or_trait_item(method_def_id) {\n-                    MethodTraitItem(method) => {\n-                        if let Some(source) = method.provided_source {\n-                            self.provided_method_sources\n-                                .borrow_mut()\n-                                .insert(method_def_id, source);\n-                        }\n-                    }\n-                    _ => {}\n-                }\n+                // load impl items eagerly for convenience\n+                // FIXME: we may want to load these lazily\n+                self.impl_or_trait_item(method_def_id);\n             }\n \n             // Store the implementation info."}, {"sha": "a431bbaeeb8e37c081f448c0dd60b465f1218340", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -14,7 +14,7 @@ use back::svh::Svh;\n use middle::const_eval::{self, ConstVal, ErrKind};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def_id::DefId;\n-use middle::subst;\n+use middle::subst::{self, Subst, Substs};\n use middle::infer;\n use middle::pat_util;\n use middle::traits;\n@@ -26,6 +26,7 @@ use util::num::ToPrimitive;\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n+use std::rc::Rc;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n@@ -646,6 +647,58 @@ impl<'tcx> ty::ctxt<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct ImplMethod<'tcx> {\n+    pub method: Rc<ty::Method<'tcx>>,\n+    pub substs: Substs<'tcx>,\n+    pub is_provided: bool\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    #[inline(never)] // is this perfy enough?\n+    pub fn get_impl_method(&self,\n+                           impl_def_id: DefId,\n+                           substs: Substs<'tcx>,\n+                           name: Name)\n+                           -> ImplMethod<'tcx>\n+    {\n+        // there don't seem to be nicer accessors to these:\n+        let impl_or_trait_items_map = self.impl_or_trait_items.borrow();\n+\n+        for impl_item in &self.impl_items.borrow()[&impl_def_id] {\n+            if let ty::MethodTraitItem(ref meth) =\n+                impl_or_trait_items_map[&impl_item.def_id()] {\n+                if meth.name == name {\n+                    return ImplMethod {\n+                        method: meth.clone(),\n+                        substs: substs,\n+                        is_provided: false\n+                    }\n+                }\n+            }\n+        }\n+\n+        // It is not in the impl - get the default from the trait.\n+        let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n+        for trait_item in self.trait_items(trait_ref.def_id).iter() {\n+            if let &ty::MethodTraitItem(ref meth) = trait_item {\n+                if meth.name == name {\n+                    let impl_to_trait_substs = self\n+                        .make_substs_for_receiver_types(&trait_ref, meth);\n+                    return ImplMethod {\n+                        method: meth.clone(),\n+                        substs: impl_to_trait_substs.subst(self, &substs),\n+                        is_provided: true\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.sess.bug(&format!(\"method {:?} not found in {:?}\",\n+                               name, impl_def_id))\n+    }\n+}\n+\n impl<'tcx> ty::TyS<'tcx> {\n     fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n                        bound: ty::BuiltinBound,"}, {"sha": "2090527ca202d1fa301c1d24a06b353d29b9e725", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -725,19 +725,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                            span: Span,\n                            method_id: DefId,\n                            name: ast::Name) {\n-        // If the method is a default method, we need to use the def_id of\n-        // the default implementation.\n-        let method_id = match self.tcx.impl_or_trait_item(method_id) {\n-            ty::MethodTraitItem(method_type) => {\n-                method_type.provided_source.unwrap_or(method_id)\n-            }\n-            _ => {\n-                self.tcx.sess\n-                    .span_bug(span,\n-                              \"got non-method item in check_static_method\")\n-            }\n-        };\n-\n         self.report_error(self.ensure_public(span,\n                                              method_id,\n                                              None,"}, {"sha": "cfa77d57bf619f7f646018e2a3316682cf358311", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 72, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -26,7 +26,7 @@ use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::infer::normalize_associated_type;\n use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n use rustc::front::map as hir_map;\n use trans::adt;\n use trans::base;\n@@ -398,77 +398,14 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     assert!(!substs.types.has_escaping_regions());\n     let substs = substs.erase_regions();\n \n-    // Load the info for the appropriate trait if necessary.\n-    match tcx.trait_of_item(def_id) {\n-        None => {}\n-        Some(trait_id) => {\n-            tcx.populate_implementations_for_trait_if_necessary(trait_id)\n-        }\n-    }\n-\n-    // We need to do a bunch of special handling for default methods.\n-    // We need to modify the def_id and our substs in order to monomorphize\n-    // the function.\n-    let (is_default, def_id, substs) = match tcx.provided_source(def_id) {\n-        None => {\n-            (false, def_id, tcx.mk_substs(substs))\n-        }\n-        Some(source_id) => {\n-            // There are two relevant substitutions when compiling\n-            // default methods. First, there is the substitution for\n-            // the type parameters of the impl we are using and the\n-            // method we are calling. This substitution is the substs\n-            // argument we already have.\n-            // In order to compile a default method, though, we need\n-            // to consider another substitution: the substitution for\n-            // the type parameters on trait; the impl we are using\n-            // implements the trait at some particular type\n-            // parameters, and we need to substitute for those first.\n-            // So, what we need to do is find this substitution and\n-            // compose it with the one we already have.\n-\n-            let impl_id = tcx.impl_or_trait_item(def_id).container()\n-                                                             .id();\n-            let impl_or_trait_item = tcx.impl_or_trait_item(source_id);\n-            match impl_or_trait_item {\n-                ty::MethodTraitItem(method) => {\n-                    let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n-\n-                    // Compute the first substitution\n-                    let first_subst =\n-                        tcx.make_substs_for_receiver_types(&trait_ref, &*method)\n-                        .erase_regions();\n-\n-                    // And compose them\n-                    let new_substs = tcx.mk_substs(first_subst.subst(tcx, &substs));\n-\n-                    debug!(\"trans_fn_with_vtables - default method: \\\n-                            substs = {:?}, trait_subst = {:?}, \\\n-                            first_subst = {:?}, new_subst = {:?}\",\n-                           substs, trait_ref.substs,\n-                           first_subst, new_substs);\n-\n-                    (true, source_id, new_substs)\n-                }\n-                _ => {\n-                    tcx.sess.bug(\"trans_fn_ref_with_vtables() tried \\\n-                                  to translate a non-method?!\")\n-                }\n-            }\n-        }\n-    };\n-\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n \n-    // We must monomorphise if the fn has type parameters, is a default method,\n-    // or is a named tuple constructor.\n-    let must_monomorphise = if !substs.types.is_empty() || is_default {\n-        true\n-    } else if def_id.is_local() {\n+    fn is_named_tuple_constructor(tcx: &ty::ctxt, def_id: DefId) -> bool {\n+        if !def_id.is_local() { return false; }\n         let map_node = session::expect(\n-            ccx.sess(),\n+            &tcx.sess,\n             tcx.map.find(def_id.node),\n             || \"local item should be in ast map\".to_string());\n \n@@ -480,9 +417,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             hir_map::NodeStructCtor(_) => true,\n             _ => false\n         }\n-    } else {\n-        false\n-    };\n+    }\n+    let must_monomorphise =\n+        !substs.types.is_empty() || is_named_tuple_constructor(tcx, def_id);\n \n     debug!(\"trans_fn_ref_with_substs({:?}) must_monomorphise: {}\",\n            def_id, must_monomorphise);\n@@ -497,6 +434,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             MethodCallKey(_) => None,\n         };\n \n+        let substs = tcx.mk_substs(substs);\n         let (val, fn_ty, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, substs, opt_ref_id);\n         if must_cast && node != ExprId(0) {\n@@ -561,10 +499,10 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let llty = type_of::type_of_fn_from_ty(ccx, fn_type);\n     let llptrty = llty.ptr_to();\n     if common::val_ty(val) != llptrty {\n-        debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");\n+        debug!(\"trans_fn_ref_with_substs(): casting pointer!\");\n         val = consts::ptrcast(val, llptrty);\n     } else {\n-        debug!(\"trans_fn_ref_with_vtables(): not casting pointer!\");\n+        debug!(\"trans_fn_ref_with_substs(): not casting pointer!\");\n     }\n \n     Datum::new(val, fn_type, Rvalue::new(ByValue))"}, {"sha": "614453830c63a47f392abd635485a8ffda83f6a3", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 40, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -250,10 +250,10 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                      impl_self,\n                                                      rcvr_method));\n \n-            let mth_id = method_with_name(ccx, impl_did, mname);\n-            trans_fn_ref_with_substs(ccx, mth_id, ExprId(expr_id),\n+            let mth = tcx.get_impl_method(impl_did, callee_substs, mname);\n+            trans_fn_ref_with_substs(ccx, mth.method.def_id, ExprId(expr_id),\n                                      param_substs,\n-                                     callee_substs)\n+                                     mth.substs)\n         }\n         traits::VtableObject(ref data) => {\n             let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n@@ -269,28 +269,6 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn method_with_name(ccx: &CrateContext, impl_id: DefId, name: ast::Name)\n-                    -> DefId {\n-    match ccx.impl_method_cache().borrow().get(&(impl_id, name)).cloned() {\n-        Some(m) => return m,\n-        None => {}\n-    }\n-\n-    let impl_items = ccx.tcx().impl_items.borrow();\n-    let impl_items =\n-        impl_items.get(&impl_id)\n-                  .expect(\"could not find impl while translating\");\n-    let meth_did = impl_items.iter()\n-                             .find(|&did| {\n-                                ccx.tcx().impl_or_trait_item(did.def_id()).name() == name\n-                             }).expect(\"could not find method while \\\n-                                        translating\");\n-\n-    ccx.impl_method_cache().borrow_mut().insert((impl_id, name),\n-                                              meth_did.def_id());\n-    meth_did.def_id()\n-}\n-\n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           self_expr: Option<&hir::Expr>,\n@@ -312,20 +290,19 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         item\")\n                 }\n             };\n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n-\n             // create a concatenated set of substitutions which includes\n             // those from the impl and those from the method:\n             let callee_substs =\n                 combine_impl_and_methods_tps(\n                     bcx, MethodCallKey(method_call), vtable_impl.substs);\n \n+            let mth = bcx.tcx().get_impl_method(impl_did, callee_substs, mname);\n             // translate the function\n             let datum = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                 mth_id,\n+                                                 mth.method.def_id,\n                                                  MethodCallKey(method_call),\n                                                  bcx.fcx.param_substs,\n-                                                 callee_substs);\n+                                                 mth.substs);\n \n             Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n@@ -738,33 +715,28 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let impl_method_def_id = method_with_name(ccx, impl_id, name);\n-            let impl_method_type = match tcx.impl_or_trait_item(impl_method_def_id) {\n-                ty::MethodTraitItem(m) => m,\n-                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n-            };\n+            let mth = tcx.get_impl_method(impl_id, substs.clone(), name);\n \n-            debug!(\"emit_vtable_methods: impl_method_type={:?}\",\n-                   impl_method_type);\n+            debug!(\"emit_vtable_methods: mth={:?}\", mth);\n \n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this\n             // particular set of type parameters. Note that this\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n-            if tcx.provided_source(impl_method_def_id).is_some() {\n-                let predicates = impl_method_type.predicates.predicates.subst(tcx, &substs);\n+            if mth.is_provided {\n+                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"emit_vtable_methods: predicates do not hold\");\n                     return nullptr;\n                 }\n             }\n \n             trans_fn_ref_with_substs(ccx,\n-                                     impl_method_def_id,\n+                                     mth.method.def_id,\n                                      ExprId(0),\n                                      param_substs,\n-                                     substs.clone()).val\n+                                     mth.substs).val\n         })\n         .collect()\n }"}, {"sha": "821615d0341f0e8e08cb48ed37ca96dbc9e2af90", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -182,7 +182,14 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 CandidateSource::ImplSource(impl_did) => {\n                     // Provide the best span we can. Use the item, if local to crate, else\n                     // the impl, if local to crate (item may be defaulted), else the call site.\n-                    let item = impl_item(fcx.tcx(), impl_did, item_name).unwrap();\n+                    let item = impl_item(fcx.tcx(), impl_did, item_name)\n+                        .or_else(|| {\n+                            trait_item(\n+                                fcx.tcx(),\n+                                fcx.tcx().impl_trait_ref(impl_did).unwrap().def_id,\n+                                item_name\n+                            )\n+                        }).unwrap();\n                     let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n                     let item_span = fcx.tcx().map.def_id_span(item.def_id(), impl_span);\n "}, {"sha": "e62f5b82e7a6ec7e23eeef3c8c6d6232688299c4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -989,7 +989,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check for missing items from trait\n     let provided_methods = tcx.provided_trait_methods(impl_trait_ref.def_id);\n-    let associated_consts = tcx.associated_consts(impl_trait_ref.def_id);\n     let mut missing_items = Vec::new();\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n@@ -1004,9 +1003,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         _ => false,\n                     }\n                 });\n-                let is_provided =\n-                    associated_consts.iter().any(|ac| ac.default.is_some() &&\n-                                                 ac.name == associated_const.name);\n+                let is_provided = associated_const.has_value;\n+\n                 if !is_implemented {\n                     if !is_provided {\n                         missing_items.push(associated_const.name);"}, {"sha": "714bd1d2bc5f30b15dd92101596d2622868d7f04", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 120, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -22,10 +22,10 @@ use middle::subst::{self, Subst};\n use middle::traits;\n use middle::ty;\n use middle::ty::RegionEscape;\n-use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n+use middle::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use middle::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n-use middle::ty::{TyParam, TypeScheme, TyRawPtr};\n+use middle::ty::{TyParam, TyRawPtr};\n use middle::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n use middle::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use middle::ty::{TyUint, TyClosure, TyBox, TyBareFn};\n@@ -168,65 +168,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         tcx.impl_items.borrow_mut().insert(impl_did, impl_items);\n     }\n \n-    // Creates default method IDs and performs type substitutions for an impl\n-    // and trait pair. Then, for each provided method in the trait, inserts a\n-    // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(\n-            &self,\n-            impl_id: DefId,\n-            trait_ref: &ty::TraitRef<'tcx>,\n-            all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n-        let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={:?})\",\n-               impl_id, trait_ref);\n-\n-        let impl_type_scheme = tcx.lookup_item_type(impl_id);\n-\n-        let prov = tcx.provided_trait_methods(trait_ref.def_id);\n-        for trait_method in &prov {\n-            // Synthesize an ID.\n-            let new_id = tcx.sess.next_node_id();\n-            let new_did = DefId::local(new_id);\n-\n-            debug!(\"new_did={:?} trait_method={:?}\", new_did, trait_method);\n-\n-            // Create substitutions for the various trait parameters.\n-            let new_method_ty =\n-                Rc::new(subst_receiver_types_in_method_ty(\n-                    tcx,\n-                    impl_id,\n-                    &impl_type_scheme,\n-                    trait_ref,\n-                    new_did,\n-                    &**trait_method,\n-                    Some(trait_method.def_id)));\n-\n-            debug!(\"new_method_ty={:?}\", new_method_ty);\n-            all_impl_items.push(MethodTraitItemId(new_did));\n-\n-            // construct the polytype for the method based on the\n-            // method_ty.  it will have all the generics from the\n-            // impl, plus its own.\n-            let new_polytype = ty::TypeScheme {\n-                generics: new_method_ty.generics.clone(),\n-                ty: tcx.mk_fn(Some(new_did),\n-                              tcx.mk_bare_fn(new_method_ty.fty.clone()))\n-            };\n-            debug!(\"new_polytype={:?}\", new_polytype);\n-\n-            tcx.register_item_type(new_did, new_polytype);\n-            tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n-            tcx.impl_or_trait_items\n-               .borrow_mut()\n-               .insert(new_did, ty::MethodTraitItem(new_method_ty));\n-\n-            // Pair the new synthesized ID up with the\n-            // ID of the method.\n-            self.crate_context.tcx.provided_method_sources.borrow_mut()\n-                .insert(new_did, trait_method.def_id);\n-        }\n-    }\n-\n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n         match self.inherent_impls.borrow().get(&base_def_id) {\n             Some(implementation_list) => {\n@@ -252,8 +193,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                let mut items: Vec<ImplOrTraitItemId> =\n-                        impl_items.iter().map(|impl_item| {\n+                impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n                         hir::ConstImplItem(..) => {\n                             ConstTraitItemId(DefId::local(impl_item.id))\n@@ -265,14 +205,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                             TypeTraitItemId(DefId::local(impl_item.id))\n                         }\n                     }\n-                }).collect();\n-\n-                let def_id = DefId::local(item.id);\n-                if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(def_id) {\n-                    self.instantiate_default_methods(def_id, &trait_ref, &mut items);\n-                }\n-\n-                items\n+                }).collect()\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n@@ -575,55 +508,6 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n                \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n }\n \n-fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                           impl_id: DefId,\n-                                           impl_type_scheme: &ty::TypeScheme<'tcx>,\n-                                           trait_ref: &ty::TraitRef<'tcx>,\n-                                           new_def_id: DefId,\n-                                           method: &ty::Method<'tcx>,\n-                                           provided_source: Option<DefId>)\n-                                           -> ty::Method<'tcx>\n-{\n-    let combined_substs = tcx.make_substs_for_receiver_types(trait_ref, method);\n-\n-    debug!(\"subst_receiver_types_in_method_ty: combined_substs={:?}\",\n-           combined_substs);\n-\n-    let method_predicates = method.predicates.subst(tcx, &combined_substs);\n-    let mut method_generics = method.generics.subst(tcx, &combined_substs);\n-\n-    // replace the type parameters declared on the trait with those\n-    // from the impl\n-    for &space in &[subst::TypeSpace, subst::SelfSpace] {\n-        method_generics.types.replace(\n-            space,\n-            impl_type_scheme.generics.types.get_slice(space).to_vec());\n-        method_generics.regions.replace(\n-            space,\n-            impl_type_scheme.generics.regions.get_slice(space).to_vec());\n-    }\n-\n-    debug!(\"subst_receiver_types_in_method_ty: method_generics={:?}\",\n-           method_generics);\n-\n-    let method_fty = method.fty.subst(tcx, &combined_substs);\n-\n-    debug!(\"subst_receiver_types_in_method_ty: method_ty={:?}\",\n-           method.fty);\n-\n-    ty::Method::new(\n-        method.name,\n-        method_generics,\n-        method_predicates,\n-        method_fty,\n-        method.explicit_self,\n-        method.vis,\n-        new_def_id,\n-        ImplContainer(impl_id),\n-        provided_source\n-    )\n-}\n-\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,"}, {"sha": "a59e6f54c81d7d30c214e5fce90e175076c475ae", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -599,8 +599,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     explicit_self_category,\n                                     vis,\n                                     def_id,\n-                                    container,\n-                                    None);\n+                                    container);\n \n     let fty = ccx.tcx.mk_fn(Some(def_id),\n                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n@@ -647,21 +646,20 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       id: ast::NodeId,\n                                       vis: hir::Visibility,\n                                       ty: ty::Ty<'tcx>,\n-                                      default: Option<&hir::Expr>)\n+                                      has_value: bool)\n {\n     ccx.tcx.predicates.borrow_mut().insert(DefId::local(id),\n                                            ty::GenericPredicates::empty());\n \n     write_ty_to_tcx(ccx.tcx, id, ty);\n-    let default_id = default.map(|expr| DefId::local(expr.id));\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n         vis: vis,\n         def_id: DefId::local(id),\n         container: container,\n         ty: ty,\n-        default: default_id,\n+        has_value: has_value\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n        .insert(DefId::local(id), ty::ConstTraitItem(associated_const));\n@@ -837,7 +835,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     span_err!(tcx.sess, impl_item.span, E0201, \"duplicate {}\", desc);\n                 }\n \n-                if let hir::ConstImplItem(ref ty, ref expr) = impl_item.node {\n+                if let hir::ConstImplItem(ref ty, _) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &*ty);\n                     tcx.register_item_type(DefId::local(impl_item.id),\n@@ -848,7 +846,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     convert_associated_const(ccx, ImplContainer(DefId::local(it.id)),\n                                              impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n-                                             ty, Some(&*expr));\n+                                             ty, true /* has_value */);\n                 }\n             }\n \n@@ -926,7 +924,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                });\n                         convert_associated_const(ccx, TraitContainer(DefId::local(it.id)),\n                                                  trait_item.name, trait_item.id,\n-                                                 hir::Public, ty, default.as_ref().map(|d| &**d));\n+                                                 hir::Public, ty, default.is_some());\n                     }\n                     _ => {}\n                 }"}, {"sha": "ee772411c4e9af85b8b8ce01b8c385a546d4ee06", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=709ce9f96ddd58a71bd7067bf49756e3bf6ac4ec", "patch": "@@ -317,10 +317,11 @@ pub fn build_impl(cx: &DocContext,\n             ty::ConstTraitItem(ref assoc_const) => {\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n-                let default = match assoc_const.default {\n-                    Some(_) => Some(const_eval::lookup_const_by_id(tcx, did, None)\n-                                               .unwrap().span.to_src(cx)),\n-                    None => None,\n+                let default = if assoc_const.has_value {\n+                    Some(const_eval::lookup_const_by_id(tcx, did, None)\n+                         .unwrap().span.to_src(cx))\n+                } else {\n+                    None\n                 };\n                 Some(clean::Item {\n                     name: Some(assoc_const.name.clean(cx)),\n@@ -339,9 +340,6 @@ pub fn build_impl(cx: &DocContext,\n                 if method.vis != hir::Public && associated_trait.is_none() {\n                     return None\n                 }\n-                if method.provided_source.is_some() {\n-                    return None\n-                }\n                 let mut item = method.clean(cx);\n                 item.inner = match item.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {"}]}