{"sha": "c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZmRkZGNiNjAwMWI2YmQwY2Q3YTYzOTdiOWUwMWUwMTllNTUzZmY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-10-25T17:23:18Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-11-04T02:52:42Z"}, "message": "Move crate type checking later\n\nThis allows us to directly pass in a lint buffer", "tree": {"sha": "f8c78bda306b04a8658b32e188c4d0b260347022", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c78bda306b04a8658b32e188c4d0b260347022"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "html_url": "https://github.com/rust-lang/rust/commit/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea1ff8c07c3937cab6e8d02c2a9f0fbb508046a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea1ff8c07c3937cab6e8d02c2a9f0fbb508046a5", "html_url": "https://github.com/rust-lang/rust/commit/ea1ff8c07c3937cab6e8d02c2a9f0fbb508046a5"}], "stats": {"total": 113, "additions": 62, "deletions": 51}, "files": [{"sha": "2bcddeaf1962db3f3a2b298c96c74b1dfab0e18d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "patch": "@@ -1469,7 +1469,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n }\n \n-pub fn default_lib_output() -> CrateType {\n+pub const fn default_lib_output() -> CrateType {\n     CrateType::Rlib\n }\n "}, {"sha": "b6395ccb50078efc3872a52fb1a6ca23fea053c5", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "patch": "@@ -295,6 +295,8 @@ fn configure_and_expand_inner<'a>(\n         krate\n     });\n \n+    util::check_attr_crate_type(&krate.attrs, &mut resolver.lint_buffer);\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );"}, {"sha": "d0c15073f1640ae2f33f5d768bc32003d557a083", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=c0fdddcb6001b6bd0cd7a6397b9e01e019e553ff", "patch": "@@ -526,63 +526,72 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n }\n \n+pub(crate) fn check_attr_crate_type(attrs: &[ast::Attribute], lint_buffer: &mut lint::LintBuffer) {\n+    // Unconditionally collect crate types from attributes to make them used\n+    for a in attrs.iter() {\n+        if a.check_name(sym::crate_type) {\n+            if let Some(n) = a.value_str() {\n+                if let Some(_) = categorize_crate_type(n) {\n+                    return;\n+                }\n+\n+                if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().kind {\n+                    let span = spanned.span;\n+                    let lev_candidate = find_best_match_for_name(\n+                        CRATE_TYPES.iter().map(|(k, _)| k),\n+                        &n.as_str(),\n+                        None\n+                    );\n+                    if let Some(candidate) = lev_candidate {\n+                        lint_buffer.buffer_lint_with_diagnostic(\n+                            lint::builtin::UNKNOWN_CRATE_TYPES,\n+                            ast::CRATE_NODE_ID,\n+                            span,\n+                            \"invalid `crate_type` value\",\n+                            lint::builtin::BuiltinLintDiagnostics::\n+                                UnknownCrateTypes(\n+                                    span,\n+                                    \"did you mean\".to_string(),\n+                                    format!(\"\\\"{}\\\"\", candidate)\n+                                )\n+                        );\n+                    } else {\n+                        lint_buffer.buffer_lint(\n+                            lint::builtin::UNKNOWN_CRATE_TYPES,\n+                            ast::CRATE_NODE_ID,\n+                            span,\n+                            \"invalid `crate_type` value\"\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+const CRATE_TYPES: &[(Symbol, config::CrateType)] = &[\n+    (sym::rlib, config::CrateType::Rlib),\n+    (sym::dylib, config::CrateType::Dylib),\n+    (sym::cdylib, config::CrateType::Cdylib),\n+    (sym::lib, config::default_lib_output()),\n+    (sym::staticlib, config::CrateType::Staticlib),\n+    (sym::proc_dash_macro, config::CrateType::ProcMacro),\n+    (sym::bin, config::CrateType::Executable),\n+];\n+\n+fn categorize_crate_type(s: Symbol) -> Option<config::CrateType> {\n+    Some(CRATE_TYPES.iter().find(|(key, _)| *key == s)?.1)\n+}\n+\n pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n     // Unconditionally collect crate types from attributes to make them used\n     let attr_types: Vec<config::CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n             if a.check_name(sym::crate_type) {\n                 match a.value_str() {\n-                    Some(sym::rlib) => Some(config::CrateType::Rlib),\n-                    Some(sym::dylib) => Some(config::CrateType::Dylib),\n-                    Some(sym::cdylib) => Some(config::CrateType::Cdylib),\n-                    Some(sym::lib) => Some(config::default_lib_output()),\n-                    Some(sym::staticlib) => Some(config::CrateType::Staticlib),\n-                    Some(sym::proc_dash_macro) => Some(config::CrateType::ProcMacro),\n-                    Some(sym::bin) => Some(config::CrateType::Executable),\n-                    Some(n) => {\n-                        let crate_types = vec![\n-                            sym::rlib,\n-                            sym::dylib,\n-                            sym::cdylib,\n-                            sym::lib,\n-                            sym::staticlib,\n-                            sym::proc_dash_macro,\n-                            sym::bin\n-                        ];\n-\n-                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().kind {\n-                            let span = spanned.span;\n-                            let lev_candidate = find_best_match_for_name(\n-                                crate_types.iter(),\n-                                &n.as_str(),\n-                                None\n-                            );\n-                            if let Some(candidate) = lev_candidate {\n-                                session.buffer_lint_with_diagnostic_late(\n-                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                    ast::CRATE_NODE_ID,\n-                                    span,\n-                                    \"invalid `crate_type` value\",\n-                                    lint::builtin::BuiltinLintDiagnostics::\n-                                        UnknownCrateTypes(\n-                                            span,\n-                                            \"did you mean\".to_string(),\n-                                            format!(\"\\\"{}\\\"\", candidate)\n-                                        )\n-                                );\n-                            } else {\n-                                session.buffer_lint_late(\n-                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                    ast::CRATE_NODE_ID,\n-                                    span,\n-                                    \"invalid `crate_type` value\"\n-                                );\n-                            }\n-                        }\n-                        None\n-                    }\n-                    None => None\n+                    Some(s) => categorize_crate_type(s),\n+                    _ => None,\n                 }\n             } else {\n                 None"}]}