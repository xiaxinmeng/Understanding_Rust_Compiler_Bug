{"sha": "918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxOGE3MzE0YThkNDlkODcwZmY5NWY4ZWQ2YzdiZGM1ODk1MTM4Yzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-21T23:56:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-21T23:56:16Z"}, "message": "auto merge of #11129 : SimonSapin/rust/foo-vs-foo_opt, r=alexcrichton\n\n[On 2013-12-06, I wrote to the rust-dev mailing list](https://mail.mozilla.org/pipermail/rust-dev/2013-December/007263.html):\r\n\r\n> Subject: Let\u2019s avoid having both foo() and foo_opt()\r\n>\r\n> We have some functions and methods such as [std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that may succeed and give a result, or fail when the input is invalid.\r\n>\r\n> 1. Sometimes we assume the input is valid and don\u2019t want to deal with the error case. Task failure works nicely.\r\n>\r\n> 2. Sometimes we do want to do something different on invalid input, so returning an `Option<T>` works best.\r\n>\r\n> And so we end up with both `from_utf8` and `from_utf8`. This particular case is worse because we also have `from_utf8_owned` and `from_utf8_owned_opt`, to cover everything.\r\n>\r\n> Multiplying names like this is just not good design. I\u2019d like to reduce this pattern.\r\n>\r\n> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the Option. I think we should rename every `foo_opt()` function or method to just `foo`, remove the old `foo()` behavior, and tell people (through documentation) to use `foo().unwrap()` if they want it back?\r\n>\r\n> The downsides are that unwrap is more verbose and gives less helpful error messages on task failure. But I think it\u2019s worth it.\r\n\r\n\r\nThe email discussion has gone around long enough. Let\u2019s discuss a concrete proposal. For the following functions or methods, I removed `foo` (that caused task failure) and renamed `foo_opt` (that returns `Option`) to just `foo`.\r\n\r\nVector methods:\r\n\r\n* `get_opt` (rename only, `get` did not exist as it would have been just `[]`)\r\n* `head_opt`\r\n* `last_opt`\r\n* `pop_opt`\r\n* `shift_opt`\r\n* `remove_opt`\r\n\r\n`std::path::BytesContainer` method:\r\n\r\n* `container_as_str_opt`\r\n\r\n`std::str` functions:\r\n\r\n* `from_utf8_opt`\r\n* `from_utf8_owned_opt` (also remove the now unused `not_utf8` condition)\r\n\r\nIs there something else that should recieve the same treatement?\r\n\r\nI did not rename `recv_opt` on channels based on @brson\u2019s [feedback](https://mail.mozilla.org/pipermail/rust-dev/2013-December/007270.html).\r\n\r\nFeel free to pick only some of these commits.", "tree": {"sha": "fcd89f5349850b34b6ed3c7fd7b04ad421705db1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd89f5349850b34b6ed3c7fd7b04ad421705db1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "html_url": "https://github.com/rust-lang/rust/commit/918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "505572b3f830c8f5140efaaf2adf8293e29b0db9", "url": "https://api.github.com/repos/rust-lang/rust/commits/505572b3f830c8f5140efaaf2adf8293e29b0db9", "html_url": "https://github.com/rust-lang/rust/commit/505572b3f830c8f5140efaaf2adf8293e29b0db9"}, {"sha": "ec422d70c3b10974b81eac6988fc5b3fa6ce60bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec422d70c3b10974b81eac6988fc5b3fa6ce60bc", "html_url": "https://github.com/rust-lang/rust/commit/ec422d70c3b10974b81eac6988fc5b3fa6ce60bc"}], "stats": {"total": 984, "additions": 398, "deletions": 586}, "files": [{"sha": "ee4d74ce1698b884ae825125c137b104a5a8e2be", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -159,10 +159,10 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n         let mut strs: ~[~str] = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n \n         match strs.len() {\n-          1u => (strs.pop(), ~\"\"),\n+          1u => (strs.pop().unwrap(), ~\"\"),\n           2u => {\n-              let end = strs.pop();\n-              (strs.pop(), end)\n+              let end = strs.pop().unwrap();\n+              (strs.pop().unwrap(), end)\n           }\n           n => fail!(\"Expected 1 or 2 strings, not {}\", n)\n         }"}, {"sha": "83fb267b0e720528a99a1ecce148f3b0a9de9746", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -66,8 +66,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8_owned(output),\n-                err: str::from_utf8_owned(error)\n+                out: str::from_utf8_owned(output).unwrap(),\n+                err: str::from_utf8_owned(error).unwrap()\n             })\n         },\n         None => None"}, {"sha": "1d8e5a707edebbc7e6f57dc575565551bf291a88", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -154,7 +154,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end();\n-    let src = str::from_utf8_owned(src);\n+    let src = str::from_utf8_owned(src).unwrap();\n     let mut srcs = ~[src];\n \n     let mut round = 0;\n@@ -176,7 +176,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end();\n-            str::from_utf8_owned(s)\n+            str::from_utf8_owned(s).unwrap()\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n         };\n@@ -308,7 +308,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n                                   config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n-                                  str::from_utf8(exe_file.filename().unwrap()));\n+                                  str::from_utf8(exe_file.filename().unwrap()).unwrap());\n \n             let mut process = procsrv::run_background(\"\", config.adb_path,\n                                                       [~\"shell\",adb_arg.clone()],\n@@ -788,7 +788,7 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n     let exe_file = make_exe_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push(exe_file.as_str().unwrap().to_owned());\n-    let prog = args.shift();\n+    let prog = args.shift().unwrap();\n     return ProcArgs {prog: prog, args: args};\n }\n \n@@ -917,7 +917,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     // get bare program string\n     let mut tvec: ~[~str] = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n-    let prog_short = tvec.pop();\n+    let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n     let copy_result = procsrv::run(\"\", config.adb_path,\n@@ -1100,7 +1100,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n fn count_extracted_lines(p: &Path) -> uint {\n     let x = File::open(&p.with_extension(\"ll\")).read_to_end();\n-    let x = str::from_utf8_owned(x);\n+    let x = str::from_utf8_owned(x).unwrap();\n     x.lines().len()\n }\n "}, {"sha": "1fcce6d01eea1d1eb78d356e190d32927ffc8edf", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -198,7 +198,7 @@ impl<'a> FromBase64 for &'a str {\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.from_base64();\n      *     if res.is_ok() {\n-     *       let optBytes = str::from_utf8_owned_opt(res.unwrap());\n+     *       let optBytes = str::from_utf8_owned(res.unwrap());\n      *       if optBytes.is_some() {\n      *         println!(\"decoded from base64: {}\", optBytes.unwrap());\n      *       }"}, {"sha": "115700e7408a3b7288100633e0c189080bf6b236", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1049,11 +1049,11 @@ mod tests {\n             match r % 6 {\n                 0 => {\n                     m.pop_back();\n-                    if v.len() > 0 { v.pop(); }\n+                    v.pop();\n                 }\n                 1 => {\n                     m.pop_front();\n-                    if v.len() > 0 { v.shift(); }\n+                    v.shift();\n                 }\n                 2 | 4 =>  {\n                     m.push_front(-i);"}, {"sha": "aac8253b8428add2924158e230bc861662771a09", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -30,7 +30,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data.slice(self.start, self.end))\n+        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n     }\n \n     pub fn as_str(&self) -> ~str {\n@@ -651,7 +651,7 @@ pub mod writer {\n         }\n \n         pub fn end_tag(&mut self) {\n-            let last_size_pos = self.size_positions.pop();\n+            let last_size_pos = self.size_positions.pop().unwrap();\n             let cur_pos = self.writer.tell();\n             self.writer.seek(last_size_pos as i64, io::SeekSet);\n             let size = (cur_pos as uint - last_size_pos - 4);"}, {"sha": "3e2aa511b81fccd4f172a26f918c942cd192b153", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -122,7 +122,7 @@ impl Iterator<Path> for Paths {\n                 return None;\n             }\n \n-            let (path,idx) = self.todo.pop();\n+            let (path,idx) = self.todo.pop().unwrap();\n             let ref pattern = self.dir_patterns[idx];\n \n             if pattern.matches_with(match path.filename_str() {"}, {"sha": "343d6aac437a048952e10c71946bea193b4530c8", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -96,7 +96,7 @@ impl<'a> FromHex for &'a str {\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n-     *     let result_str = str::from_utf8_owned(bytes);\n+     *     let result_str = str::from_utf8_owned(bytes).unwrap();\n      *     println!(\"{}\", result_str);\n      * }\n      * ```"}, {"sha": "a35c474337d61ec2106c067d5df4d0db54f4135a", "filename": "src/libextra/json.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -312,7 +312,7 @@ impl<'a> Encoder<'a> {\n     /// Encode the specified struct into a json str\n     pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n         let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8_owned(buff)\n+        str::from_utf8_owned(buff).unwrap()\n     }\n }\n \n@@ -684,7 +684,7 @@ impl Json{\n     pub fn to_pretty_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer);\n-        str::from_utf8_owned(s.unwrap())\n+        str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n }\n \n@@ -1028,7 +1028,7 @@ impl<T : Iterator<char>> Parser<T> {\n         while !self.eof() {\n             self.parse_whitespace();\n \n-            if self.ch != '\\\"' {\n+            if self.ch != '\"' {\n                 return self.error(~\"key must be a string\");\n             }\n \n@@ -1067,7 +1067,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n-    let s = str::from_utf8_owned(rdr.read_to_end());\n+    let s = str::from_utf8_owned(rdr.read_to_end()).unwrap();\n     let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n@@ -1117,7 +1117,7 @@ impl Decoder {\n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n         debug!(\"read_nil\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Null => (),\n             value => self.expected(\"null\", &value)\n         }\n@@ -1137,15 +1137,15 @@ impl serialize::Decoder for Decoder {\n \n     fn read_bool(&mut self) -> bool {\n         debug!(\"read_bool\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Boolean(b) => b,\n             value => self.expected(\"boolean\", &value)\n         }\n     }\n \n     fn read_f64(&mut self) -> f64 {\n         debug!(\"read_f64\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Number(f) => f,\n             value => self.expected(\"number\", &value)\n         }\n@@ -1168,7 +1168,7 @@ impl serialize::Decoder for Decoder {\n \n     fn read_str(&mut self) -> ~str {\n         debug!(\"read_str\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             String(s) => s,\n             value => self.expected(\"string\", &value)\n         }\n@@ -1184,7 +1184,7 @@ impl serialize::Decoder for Decoder {\n                             f: |&mut Decoder, uint| -> T)\n                             -> T {\n         debug!(\"read_enum_variant(names={:?})\", names);\n-        let name = match self.stack.pop() {\n+        let name = match self.stack.pop().unwrap() {\n             String(s) => s,\n             Object(mut o) => {\n                 let n = match o.pop(&~\"variant\") {\n@@ -1249,7 +1249,7 @@ impl serialize::Decoder for Decoder {\n                       -> T {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n-        self.stack.pop();\n+        self.stack.pop().unwrap();\n         value\n     }\n \n@@ -1259,7 +1259,7 @@ impl serialize::Decoder for Decoder {\n                             f: |&mut Decoder| -> T)\n                             -> T {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Object(mut obj) => {\n                 let value = match obj.pop(&name.to_owned()) {\n                     None => self.missing_field(name, obj),\n@@ -1302,15 +1302,15 @@ impl serialize::Decoder for Decoder {\n     }\n \n     fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n     fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_seq()\");\n-        let len = match self.stack.pop() {\n+        let len = match self.stack.pop().unwrap() {\n             List(list) => {\n                 let len = list.len();\n                 for v in list.move_rev_iter() {\n@@ -1330,7 +1330,7 @@ impl serialize::Decoder for Decoder {\n \n     fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_map()\");\n-        let len = match self.stack.pop() {\n+        let len = match self.stack.pop().unwrap() {\n             Object(obj) => {\n                 let len = obj.len();\n                 for (key, value) in obj.move_iter() {\n@@ -1541,7 +1541,7 @@ impl to_str::ToStr for Json {\n     fn to_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n         self.to_writer(&mut s as &mut io::Writer);\n-        str::from_utf8_owned(s.unwrap())\n+        str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n }\n \n@@ -1732,7 +1732,7 @@ mod tests {\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8_owned(m.unwrap())\n+        str::from_utf8_owned(m.unwrap()).unwrap()\n     }\n \n     #[test]"}, {"sha": "8729cf1b68553ece9aee7b3bc46b0eb8443a1d22", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -385,7 +385,7 @@ impl Integer for BigUint {\n         }\n \n         let mut shift = 0;\n-        let mut n = *other.data.last();\n+        let mut n = *other.data.last().unwrap();\n         while n < (1 << BigDigit::bits - 2) {\n             n <<= 1;\n             shift += 1;\n@@ -434,7 +434,7 @@ impl Integer for BigUint {\n             }\n \n             let an = a.data.slice(a.data.len() - n, a.data.len());\n-            let bn = *b.data.last();\n+            let bn = *b.data.last().unwrap();\n             let mut d = ~[];\n             let mut carry = 0;\n             for elt in an.rev_iter() {\n@@ -798,7 +798,7 @@ impl BigUint {\n     /// Determines the fewest bits necessary to express the `BigUint`.\n     pub fn bits(&self) -> uint {\n         if self.is_zero() { return 0; }\n-        let zeros = self.data.last().leading_zeros();\n+        let zeros = self.data.last().unwrap().leading_zeros();\n         return self.data.len()*BigDigit::bits - (zeros as uint);\n     }\n }"}, {"sha": "33b3931e9897a1eb7e5b28677a62d2e74ce910c9", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -59,7 +59,7 @@ impl<T:Ord> PriorityQueue<T> {\n \n     /// Pop the greatest item from the queue - fails if empty\n     pub fn pop(&mut self) -> T {\n-        let mut item = self.data.pop();\n+        let mut item = self.data.pop().unwrap();\n         if !self.is_empty() {\n             swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n@@ -234,8 +234,8 @@ mod tests {\n         sorted.sort();\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top(), sorted.last());\n-            assert_eq!(heap.pop(), sorted.pop());\n+            assert_eq!(heap.top(), sorted.last().unwrap());\n+            assert_eq!(heap.pop(), sorted.pop().unwrap());\n         }\n     }\n "}, {"sha": "096e588277468d78473d285efdef21340f1594d0", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1001,7 +1001,7 @@ mod tests {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30);\n-            let out = str::from_utf8_owned(m.unwrap());\n+            let out = str::from_utf8_owned(m.unwrap()).unwrap();\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "bd9eadc078d1bf57fafac98033f68bec5ea8c25c", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -121,7 +121,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 match cur {\n                     '%' => { output.push(c); state = Nothing },\n                     'c' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n                             _       => return Err(~\"a non-char was used with %c\")\n@@ -133,104 +133,104 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             String(s) => stack.push(Number(s.len() as int)),\n                             _         => return Err(~\"a non-str was used with %l\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '+' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n                             _ => return Err(~\"non-numbers on stack with +\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '-' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n                             _ => return Err(~\"non-numbers on stack with -\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '*' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n                             _ => return Err(~\"non-numbers on stack with *\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '/' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n                             _ => return Err(~\"non-numbers on stack with /\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'm' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n                             _ => return Err(~\"non-numbers on stack with %\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '&' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n                             _ => return Err(~\"non-numbers on stack with &\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '|' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n                             _ => return Err(~\"non-numbers on stack with |\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '^' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n                             _ => return Err(~\"non-numbers on stack with ^\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '=' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n                             _ => return Err(~\"non-numbers on stack with =\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '>' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n                             _ => return Err(~\"non-numbers on stack with >\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '<' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n                             _ => return Err(~\"non-numbers on stack with <\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'A' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n                             _ => return Err(~\"non-numbers on stack with logical and\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'O' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n                             _ => return Err(~\"non-numbers on stack with logical or\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '!' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n                             _ => return Err(~\"non-number on stack with logical not\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '~' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n                             _         => return Err(~\"non-number on stack with %~\")\n                         }\n@@ -246,7 +246,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     // printf-style support for %doxXs\n                     'd'|'o'|'x'|'X'|'s' => if stack.len() > 0 {\n                         let flags = Flags::new();\n-                        let res = format(stack.pop(), FormatOp::from_char(cur), flags);\n+                        let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap())\n                     } else { return Err(~\"stack is empty\") },\n@@ -270,7 +270,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     // conditionals\n                     '?' => (),\n                     't' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n                             _         => return Err(~\"non-number on stack with conditional\")\n@@ -293,12 +293,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n-                        vars.sta[idx] = stack.pop();\n+                        vars.sta[idx] = stack.pop().unwrap();\n                     } else { return Err(~\"stack is empty\") }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n-                        vars.dyn[idx] = stack.pop();\n+                        vars.dyn[idx] = stack.pop().unwrap();\n                     } else { return Err(~\"stack is empty\") }\n                 } else {\n                     return Err(~\"bad variable name in %P\");\n@@ -341,7 +341,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 old_state = Nothing;\n                 match (*fstate, cur) {\n                     (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n-                        let res = format(stack.pop(), FormatOp::from_char(cur), *flags);\n+                        let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap());\n                         old_state = state; // will cause state to go to Nothing"}, {"sha": "23478728330ebc69557e217a8dc9d7f7942d9ed2", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -216,7 +216,7 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // don't read NUL\n-    let names_str = str::from_utf8_owned(file.read_bytes(names_bytes as uint - 1));\n+    let names_str = str::from_utf8_owned(file.read_bytes(names_bytes as uint - 1)).unwrap();\n \n     let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n "}, {"sha": "1b98a9af548ae69064db118a6e76a25dc62a5e26", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -704,7 +704,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures();\n     let s = match st.out {\n-        Raw(ref m) => str::from_utf8(m.get_ref()),\n+        Raw(ref m) => str::from_utf8(m.get_ref()).unwrap(),\n         Pretty(_) => unreachable!()\n     };\n \n@@ -753,7 +753,7 @@ fn run_tests(opts: &TestOpts,\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n-            let test = remaining.pop();\n+            let test = remaining.pop().unwrap();\n             if concurrency == 1 {\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests"}, {"sha": "3e5b9b797d31b6a3e3b38f1a2cb6d19bb4ba08a9", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1030,7 +1030,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    str::from_utf8_owned(buf)\n+    str::from_utf8_owned(buf).unwrap()\n }\n \n #[cfg(test)]"}, {"sha": "62b28074a27491f11839eccdaa47dec207517420", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -359,7 +359,7 @@ macro_rules! define_iterator {\n                         }\n                         self.stack.push(node);\n                     } else {\n-                        let node = self.stack.pop();\n+                        let node = self.stack.pop().unwrap();\n                         let next_node = if forward {\n                             addr!(& $($addr_mut)* node.right)\n                         } else {\n@@ -496,7 +496,7 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n                 left: left,\n                 right: right,\n                 level: level\n-            } = self.stack.pop();\n+            } = self.stack.pop().unwrap();\n \n             match left {\n                 Some(~left) => {\n@@ -1164,7 +1164,7 @@ mod test_treemap {\n \n             30.times(|| {\n                 let r = rng.gen_range(0, ctrl.len());\n-                let (key, _) = ctrl.remove(r);\n+                let (key, _) = ctrl.remove(r).unwrap();\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);"}, {"sha": "9163a892039139199dd390f717c5eab4a7edff34", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -313,7 +313,7 @@ impl Uuid {\n             s[i*2+0] = digit[0];\n             s[i*2+1] = digit[1];\n         }\n-        str::from_utf8_owned(s)\n+        str::from_utf8_owned(s).unwrap()\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hyphen."}, {"sha": "cccca1309f4c3918581f6fc755b2dd32fad05385", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -243,7 +243,7 @@ fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n-    str::from_utf8_owned(writer.unwrap())\n+    str::from_utf8_owned(writer.unwrap()).unwrap()\n }\n \n // FIXME(#5121)\n@@ -491,7 +491,7 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n-        let file_content = from_utf8_owned(File::open(&pth).read_to_end());\n+        let file_content = from_utf8_owned(File::open(&pth).read_to_end()).unwrap();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);"}, {"sha": "ef96f55451558759710a9ba6d89bef73cb0d7827", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -84,7 +84,7 @@ impl BasicLoop {\n             }\n             RemoveRemote(i) => {\n                 match self.remotes.iter().position(|&(id, _)| id == i) {\n-                    Some(i) => { self.remotes.remove(i); }\n+                    Some(i) => { self.remotes.remove(i).unwrap(); }\n                     None => unreachable!()\n                 }\n             }"}, {"sha": "989b8dc31f8a8d584f8e1a489eabb866cb78f6a0", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1285,8 +1285,11 @@ mod test {\n                 ports.push(port);\n             });\n \n-            while !ports.is_empty() {\n-                ports.pop().recv();\n+            loop {\n+                match ports.pop() {\n+                    Some(port) => port.recv(),\n+                    None => break,\n+                }\n             }\n         }\n     }"}, {"sha": "661ae5b7297b2fd0c8293db433569c1a132407a5", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -57,8 +57,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n                                  o.status));\n-                sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output)));\n-                sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error)));\n+                sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output).unwrap()));\n+                sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error).unwrap()));\n                 sess.abort_if_errors();\n             }\n             o\n@@ -141,7 +141,7 @@ impl Archive {\n     /// Lists all files in an archive\n     pub fn files(&self) -> ~[~str] {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n-        str::from_utf8(output.output).lines().map(|s| s.to_owned()).collect()\n+        str::from_utf8(output.output).unwrap().lines().map(|s| s.to_owned()).collect()\n     }\n \n     fn add_archive(&mut self, archive: &Path, name: &str, skip: &[&str]) {"}, {"sha": "63c4d9f4a2976ee270e7cdcdd50934fb41bb9d3e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -298,7 +298,7 @@ pub mod write {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n                     sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n-                    sess.note(str::from_utf8_owned(prog.error + prog.output));\n+                    sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n                     sess.abort_if_errors();\n                 }\n             },\n@@ -1007,7 +1007,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n                 sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n-                sess.note(str::from_utf8_owned(prog.error + prog.output));\n+                sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "a0a9800926ebc829e018cac3a37cdad70de32c1d", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -179,17 +179,17 @@ impl Visitor<()> for Context {\n     fn visit_mac(&mut self, macro: &ast::Mac, _: ()) {\n         let ast::MacInvocTT(ref path, _, _) = macro.node;\n \n-        if path.segments.last().identifier == self.sess.ident_of(\"macro_rules\") {\n+        if path.segments.last().unwrap().identifier == self.sess.ident_of(\"macro_rules\") {\n             self.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n                 not stable enough for use and are subject to change\");\n         }\n \n-        else if path.segments.last().identifier == self.sess.ident_of(\"asm\") {\n+        else if path.segments.last().unwrap().identifier == self.sess.ident_of(\"asm\") {\n             self.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n                 stable enough for use and is subject to change\");\n         }\n \n-        else if path.segments.last().identifier == self.sess.ident_of(\"log_syntax\") {\n+        else if path.segments.last().unwrap().identifier == self.sess.ident_of(\"log_syntax\") {\n             self.gate_feature(\"log_syntax\", path.span, \"`log_syntax!` is not \\\n                 stable enough for use and is subject to change\");\n         }"}, {"sha": "f7ee736f144de60bc042287af91252e6421ae6c1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -190,7 +190,7 @@ pub fn describe_debug_flags() {\n \n pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     let mut args = args.to_owned();\n-    let binary = args.shift();\n+    let binary = args.shift().unwrap();\n \n     if args.is_empty() { usage(binary); return; }\n \n@@ -234,7 +234,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if \"-\" == ifile {\n-            let src = str::from_utf8_owned(io::stdin().read_to_end());\n+            let src = str::from_utf8_owned(io::stdin().read_to_end()).unwrap();\n             d::StrInput(src.to_managed())\n         } else {\n             d::FileInput(Path::new(ifile))"}, {"sha": "a7c82ba4317782bf7fc833617f51d927a4469935", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1989,5 +1989,5 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         abbrevs: tyencode::ac_no_abbrevs};\n     let mut wr = MemWriter::new();\n     tyencode::enc_ty(&mut wr, cx, t);\n-    str::from_utf8_owned(wr.get_ref().to_owned())\n+    str::from_utf8_owned(wr.get_ref().to_owned()).unwrap()\n }"}, {"sha": "4f19d461c854c7216d0f42fc67a8d4407e0f6199", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -97,7 +97,7 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n \n fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n     scan(st, is_last, |bytes| {\n-            st.tcx.sess.ident_of(str::from_utf8(bytes))\n+            st.tcx.sess.ident_of(str::from_utf8(bytes).unwrap())\n         })\n }\n \n@@ -476,7 +476,7 @@ fn parse_abi_set(st: &mut PState) -> AbiSet {\n     let mut abis = AbiSet::empty();\n     while peek(st) != ']' {\n          scan(st, |c| c == ',', |bytes| {\n-                 let abi_str = str::from_utf8(bytes).to_owned();\n+                 let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n                  let abi = abi::lookup(abi_str).expect(abi_str);\n                  abis.add(abi);\n               });"}, {"sha": "965aab31f142682272e137bdd637d64aa3ac8146", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -72,7 +72,7 @@ pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n             None => {\n                 let wr = &mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n-                let s = str::from_utf8(wr.get_ref()).to_managed();\n+                let s = str::from_utf8(wr.get_ref()).unwrap().to_managed();\n                 let mut short_names_cache = cx.tcx\n                                               .short_names_cache\n                                               .borrow_mut();"}, {"sha": "e45ea77b49e1dfcb6d3794974dd68fa3f34a5903", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -339,7 +339,7 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n \n     pub fn pop_repeating_id(&mut self, id: ast::NodeId) {\n-        let popped = self.repeating_ids.pop();\n+        let popped = self.repeating_ids.pop().unwrap();\n         assert_eq!(id, popped);\n     }\n \n@@ -445,7 +445,7 @@ impl<'a> GatherLoanCtxt<'a> {\n             return;\n         }\n \n-        let root_ub = { *self.repeating_ids.last() }; // FIXME(#5074)\n+        let root_ub = { *self.repeating_ids.last().unwrap() }; // FIXME(#5074)\n \n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed."}, {"sha": "dc0b700da522a7d7b9a772e7b18622bb0e862427", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -495,7 +495,7 @@ impl CFGBuilder {\n                   label: Option<ast::Name>) -> LoopScope {\n         match label {\n             None => {\n-                return *self.loop_scopes.last();\n+                return *self.loop_scopes.last().unwrap();\n             }\n \n             Some(_) => {"}, {"sha": "835f53a50ac795288ff6e9755c6f5f87c6446647", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -504,7 +504,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n                     // add the bits from any early return via `break`,\n                     // `continue`, or `return` into `func_bits`\n-                    let loop_scope = loop_scopes.pop();\n+                    let loop_scope = loop_scopes.pop().unwrap();\n                     join_bits(&self.dfcx.oper, loop_scope.break_bits, func_bits);\n \n                     // add `func_bits` to the entry bits for `expr`,\n@@ -563,7 +563,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n-                let new_loop_scope = loop_scopes.pop();\n+                let new_loop_scope = loop_scopes.pop().unwrap();\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n@@ -588,7 +588,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n \n-                let new_loop_scope = loop_scopes.pop();\n+                let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }"}, {"sha": "c333bc58feee12975650a1b9455a70c0f43c58e6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -129,7 +129,7 @@ impl MarkSymbolVisitor {\n     fn mark_live_symbols(&mut self) {\n         let mut scanned = HashSet::new();\n         while self.worklist.len() > 0 {\n-            let id = self.worklist.pop();\n+            let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n                 continue\n             }"}, {"sha": "7e6db24a4a319138a685e0eedbd3e39571378f6b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -524,7 +524,7 @@ impl<'a> Context<'a> {\n         // rollback\n         self.is_doc_hidden = old_is_doc_hidden;\n         pushed.times(|| {\n-            let (lint, lvl, src) = self.lint_stack.pop();\n+            let (lint, lvl, src) = self.lint_stack.pop().unwrap();\n             self.set_level(lint, lvl, src);\n         })\n     }\n@@ -1077,7 +1077,7 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     match (&p.node, def_map.get().find(&p.id)) {\n         (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n-            let ident = path.segments.last().identifier;\n+            let ident = path.segments.last().unwrap().identifier;\n             let s = cx.tcx.sess.str_of(ident);\n             if s.chars().any(|c| c.is_lowercase()) {\n                 cx.span_lint(NonUppercasePatternStatics, path.span,"}, {"sha": "d8bf115eb42b298f0c7b0166ba702fae29e86201", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -790,7 +790,7 @@ impl Liveness {\n \n     pub fn last_loop_scope(&self) -> NodeId {\n         let loop_scope = self.loop_scope.borrow();\n-        *loop_scope.get().last()\n+        *loop_scope.get().last().unwrap()\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n@@ -825,7 +825,7 @@ impl Liveness {\n                 }\n             }\n         }\n-        str::from_utf8_owned(wr.unwrap())\n+        str::from_utf8_owned(wr.unwrap()).unwrap()\n     }\n \n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n@@ -1593,7 +1593,7 @@ impl Liveness {\n             } else {\n                 let ends_with_stmt = match body.expr {\n                     None if body.stmts.len() > 0 =>\n-                        match body.stmts.last().node {\n+                        match body.stmts.last().unwrap().node {\n                             StmtSemi(e, _) => {\n                                 let t_stmt = ty::expr_ty(self.tcx, e);\n                                 ty::get(t_stmt).sty == ty::get(t_ret).sty\n@@ -1603,7 +1603,7 @@ impl Liveness {\n                     _ => false\n                 };\n                 if ends_with_stmt {\n-                    let last_stmt = body.stmts.last();\n+                    let last_stmt = body.stmts.last().unwrap();\n                     let span_semicolon = Span {\n                         lo: last_stmt.span.hi,\n                         hi: last_stmt.span.hi,"}, {"sha": "3d5267cd9285cce528250e63c097eb6e288cb9c9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -595,7 +595,7 @@ impl<'a> PrivacyVisitor<'a> {\n             match *self.last_private_map.get(&path_id) {\n                 resolve::AllPublic => {},\n                 resolve::DependsOn(def) => {\n-                    let name = token::ident_to_str(&path.segments.last()\n+                    let name = token::ident_to_str(&path.segments.last().unwrap()\n                                                         .identifier);\n                     self.ensure_public(span, def, Some(origdid),\n                                        format!(\"{} `{}`\", tyname, name));"}, {"sha": "66d706e3621c10b53d45140e8b10e7bbbd600cff", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -284,7 +284,7 @@ impl ReachableContext {\n                 if worklist.get().len() == 0 {\n                     break\n                 }\n-                let search_item = worklist.get().pop();\n+                let search_item = worklist.get().pop().unwrap();\n                 if scanned.contains(&search_item) {\n                     continue\n                 }"}, {"sha": "082c755b8321e37646db0aad730375388e500c7c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1476,7 +1476,7 @@ impl Resolver {\n                     match view_path.node {\n                         ViewPathSimple(binding, ref full_path, id) => {\n                             let source_ident =\n-                                full_path.segments.last().identifier;\n+                                full_path.segments.last().unwrap().identifier;\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n                             self.build_import_directive(module_,\n@@ -4303,7 +4303,7 @@ impl Resolver {\n \n                 // First, check to see whether the name is a primitive type.\n                 if path.segments.len() == 1 {\n-                    let id = path.segments.last().identifier;\n+                    let id = path.segments.last().unwrap().identifier;\n \n                     match self.primitive_type_table\n                             .primitive_types\n@@ -4342,7 +4342,7 @@ impl Resolver {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n                                         type {:?}\",\n                                        self.session.str_of(path.segments\n-                                                               .last()\n+                                                               .last().unwrap()\n                                                                .identifier),\n                                        def);\n                                 result_def = Some(def);\n@@ -4561,7 +4561,7 @@ impl Resolver {\n                                 path.span,\n                                 format!(\"`{}` is not an enum variant or constant\",\n                                      self.session.str_of(\n-                                         path.segments.last().identifier)))\n+                                         path.segments.last().unwrap().identifier)))\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4592,7 +4592,7 @@ impl Resolver {\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                      self.session\n                                          .str_of(path.segments\n-                                                     .last()\n+                                                     .last().unwrap()\n                                                      .identifier)));\n                         }\n                         None => {\n@@ -4601,7 +4601,7 @@ impl Resolver {\n                                                     struct or const `{}`\",\n                                                     self.session\n                                                         .str_of(path.segments\n-                                                                    .last()\n+                                                                    .last().unwrap()\n                                                                     .identifier)));\n                         }\n                     }\n@@ -4722,7 +4722,7 @@ impl Resolver {\n \n         let unqualified_def =\n                 self.resolve_identifier(path.segments\n-                                            .last()\n+                                            .last().unwrap()\n                                             .identifier,\n                                         namespace,\n                                         check_ribs,\n@@ -4883,7 +4883,7 @@ impl Resolver {\n             }\n         }\n \n-        let ident = path.segments.last().identifier;\n+        let ident = path.segments.last().unwrap().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module,\n                                                         ident,\n                                                         namespace) {\n@@ -4952,7 +4952,7 @@ impl Resolver {\n             }\n         }\n \n-        let name = path.segments.last().identifier;\n+        let name = path.segments.last().unwrap().identifier;\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace) {"}, {"sha": "5bd8eb6386fcff4d055f44f7cf84c096270fa5ae", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -575,7 +575,7 @@ fn enter_default<'r,'b>(\n     // non guarded matches, and thus by exhaustiveness, we know that\n     // we don't need any default cases. If the check *isn't* nonexhaustive\n     // (because chk is Some), then we need the defaults anyways.\n-    let is_exhaustive = match matches.last_opt() {\n+    let is_exhaustive = match matches.last() {\n         Some(m) if m.data.arm.guard.is_some() && chk.is_infallible() => true,\n         _ => false\n     };\n@@ -913,7 +913,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n     // to not always merge conditions.\n     fn add_veclen_to_set(set: &mut ~[Opt], i: uint,\n                          len: uint, vlo: VecLenOpt) {\n-        match set.last_opt() {\n+        match set.last() {\n             // If the last condition in the list matches the one we want\n             // to add, then extend its range. Otherwise, make a new\n             // vec_len with a range just covering the new entry."}, {"sha": "c654bbbd709d9637bfba6d3533930aaf090a5846", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -2014,7 +2014,7 @@ fn exported_name(ccx: &CrateContext, path: ast_map::Path,\n \n         // Don't mangle\n         _ if attr::contains_name(attrs, \"no_mangle\")\n-            => path_elem_to_str(*path.last(), token::get_ident_interner()),\n+            => path_elem_to_str(*path.last().unwrap(), token::get_ident_interner()),\n \n         // Usual name mangling\n         _ => mangle_exported_name(ccx, path, ty)"}, {"sha": "1f0e99de264a86c5a8230caf4587294bdebb2f01", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -396,8 +396,11 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         let llbb = self.get_or_create_landing_pad();\n \n         // Push the scopes we removed back on:\n-        while !popped_scopes.is_empty() {\n-            self.push_scope(popped_scopes.pop());\n+        loop {\n+            match popped_scopes.pop() {\n+                Some(scope) => self.push_scope(scope),\n+                None => break\n+            }\n         }\n \n         assert_eq!(self.scopes_len(), orig_scopes_len);\n@@ -470,12 +473,12 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                self.scopes_len() - 1);\n \n         let mut scopes = self.scopes.borrow_mut();\n-        scopes.get().pop()\n+        scopes.get().pop().unwrap()\n     }\n \n     fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n         let scopes = self.scopes.borrow();\n-        f(scopes.get().last())\n+        f(scopes.get().last().unwrap())\n     }\n \n     fn trans_cleanups_to_exit_scope(&self,\n@@ -568,7 +571,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n             // and this scope is that loop, then stop popping and set\n             // `prev_llbb` to the appropriate exit block from the loop.\n             popped_scopes.push(self.pop_scope());\n-            let scope = popped_scopes.last();\n+            let scope = popped_scopes.last().unwrap();\n             match label {\n                 UnwindExit | ReturnExit => { }\n                 LoopExit(id, exit) => {\n@@ -608,7 +611,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         // At this point, `popped_scopes` is empty, and so the final block\n         // that we return to the user is `Cleanup(AST 24)`.\n         while !popped_scopes.is_empty() {\n-            let mut scope = popped_scopes.pop();\n+            let mut scope = popped_scopes.pop().unwrap();\n \n             if scope.cleanups.iter().any(|c| cleanup_is_suitable_for(*c, label))\n             {"}, {"sha": "4c5ed91e5f74750f1b94f37494778cae715548eb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -2036,7 +2036,7 @@ fn trait_metadata(cx: &CrateContext,\n     // assigned the correct name, size, namespace, and source location. But it does not describe\n     // the trait's methods.\n     let path = ty::item_path(cx.tcx, def_id);\n-    let ident = path.last().ident();\n+    let ident = path.last().unwrap().ident();\n     let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n                ppaux::mutability_to_str(mutability) +\n                token::ident_to_str(&ident);\n@@ -2361,7 +2361,7 @@ fn populate_scope_map(cx: &CrateContext,\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name);\n-        let parent_scope = scope_stack.last().scope_metadata;\n+        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n             llvm::LLVMDIBuilderCreateLexicalBlock(\n@@ -2377,11 +2377,11 @@ fn populate_scope_map(cx: &CrateContext,\n         inner_walk(cx, scope_stack, scope_map);\n \n         // pop artificial scopes\n-        while scope_stack.last().ident.is_some() {\n+        while scope_stack.last().unwrap().ident.is_some() {\n             scope_stack.pop();\n         }\n \n-        if scope_stack.last().scope_metadata != scope_metadata {\n+        if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n             cx.sess.span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n         }\n \n@@ -2392,11 +2392,12 @@ fn populate_scope_map(cx: &CrateContext,\n                   block: &ast::Block,\n                   scope_stack: &mut ~[ScopeStackEntry],\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-        scope_map.insert(block.id, scope_stack.last().scope_metadata);\n+        scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n         for statement in block.stmts.iter() {\n-            scope_map.insert(ast_util::stmt_id(*statement), scope_stack.last().scope_metadata);\n+            scope_map.insert(ast_util::stmt_id(*statement),\n+                             scope_stack.last().unwrap().scope_metadata);\n \n             match statement.node {\n                 ast::StmtDecl(decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n@@ -2417,7 +2418,7 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n             codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n-                scope_map.insert(local.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n \n@@ -2477,7 +2478,7 @@ fn populate_scope_map(cx: &CrateContext,\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess.codemap.lookup_char_pos(pat.span.lo);\n                         let file_metadata = file_metadata(cx, loc.file.name);\n-                        let parent_scope = scope_stack.last().scope_metadata;\n+                        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n                             llvm::LLVMDIBuilderCreateLexicalBlock(\n@@ -2495,27 +2496,27 @@ fn populate_scope_map(cx: &CrateContext,\n \n                     } else {\n                         // Push a new entry anyway so the name can be found\n-                        let prev_metadata = scope_stack.last().scope_metadata;\n+                        let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n                         scope_stack.push(ScopeStackEntry {\n                             scope_metadata: prev_metadata,\n                             ident: Some(ident)\n                         });\n                     }\n                 }\n \n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &sub_pat in sub_pat_opt.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatWild | ast::PatWildMulti => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             }\n \n             ast::PatEnum(_, ref sub_pats_opt) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for ref sub_pats in sub_pats_opt.iter() {\n                     for &p in sub_pats.iter() {\n@@ -2525,39 +2526,39 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatStruct(_, ref field_pats, _) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &ast::FieldPat { pat: sub_pat, .. } in field_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatTup(ref sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &sub_pat in sub_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatUniq(sub_pat) | ast::PatRegion(sub_pat) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_pattern(cx, sub_pat, scope_stack, scope_map);\n             }\n \n             ast::PatLit(exp) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, exp, scope_stack, scope_map);\n             }\n \n             ast::PatRange(exp1, exp2) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, exp1, scope_stack, scope_map);\n                 walk_expr(cx, exp2, scope_stack, scope_map);\n             }\n \n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &sub_pat in front_sub_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n@@ -2579,7 +2580,7 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n-        scope_map.insert(exp.id, scope_stack.last().scope_metadata);\n+        scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n \n         match exp.node {\n             ast::ExprLogLevel |\n@@ -2606,14 +2607,14 @@ fn populate_scope_map(cx: &CrateContext,\n             },\n \n             ast::ExprUnary(node_id, _, sub_exp) => {\n-                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, sub_exp, scope_stack, scope_map);\n             }\n \n             ast::ExprAssignOp(node_id, _, lhs, rhs) |\n             ast::ExprIndex(node_id, lhs, rhs)        |\n             ast::ExprBinary(node_id, _, lhs, rhs)    => {\n-                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, lhs, scope_stack, scope_map);\n                 walk_expr(cx, rhs, scope_stack, scope_map);\n             }\n@@ -2720,7 +2721,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMethodCall(node_id, receiver_exp, _, _, ref args, _) => {\n-                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, receiver_exp, scope_stack, scope_map);\n \n                 for arg_exp in args.iter() {"}, {"sha": "01fb18d73c26a5efa6ae110653e34b2847b19c91", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -2336,7 +2336,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n                 let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n-                seen.pop();\n+                seen.pop().unwrap();\n                 r\n             }\n \n@@ -2357,7 +2357,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                         type_requires(cx, seen, r_ty, sty)\n                     })\n                 });\n-                seen.pop();\n+                seen.pop().unwrap();\n                 r\n             }\n         };"}, {"sha": "2e25ac941a66dda43031b72dc07eb7c6864b7a67", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -170,9 +170,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let expected_num_region_params = decl_generics.region_param_defs.len();\n-    let supplied_num_region_params = path.segments.last().lifetimes.len();\n+    let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        path.segments.last().lifetimes.map(\n+        path.segments.last().unwrap().lifetimes.map(\n             |l| ast_region_to_region(this.tcx(), l))\n     } else {\n         let anon_regions =\n@@ -373,7 +373,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n-            if !path.segments.last().lifetimes.is_empty() {\n+            if !path.segments.last().unwrap().lifetimes.is_empty() {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"region parameters are not allowed on this type\");"}, {"sha": "86d347fdac0d2d0f43d9917c38d29f42aae500e9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -3827,9 +3827,9 @@ pub fn instantiate_path(fcx: @FnCtxt,\n     // determine the region parameters, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n     let num_expected_regions = tpt.generics.region_param_defs.len();\n-    let num_supplied_regions = pth.segments.last().lifetimes.len();\n+    let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        pth.segments.last().lifetimes.map(\n+        pth.segments.last().unwrap().lifetimes.map(\n             |l| ast_region_to_region(fcx.tcx(), l))\n     } else {\n         if num_supplied_regions != 0 {"}, {"sha": "daf5bdd9ea3158c5a3468edaadd6282b4c5bcd62", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -107,7 +107,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n                     self.relate(r);\n                     self.stack.push(r);\n                     ty_fold::super_fold_ty(self, mt.ty);\n-                    self.stack.pop();\n+                    self.stack.pop().unwrap();\n                 }\n \n                 _ => {"}, {"sha": "68fb4b1e579a6d5204398055fd8cd9d5dd8e5b49", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -489,7 +489,7 @@ pub fn uok() -> ures {\n fn rollback_to<V:Clone + Vid,T:Clone>(vb: &mut ValsAndBindings<V, T>,\n                                       len: uint) {\n     while vb.bindings.len() != len {\n-        let (vid, old_v) = vb.bindings.pop();\n+        let (vid, old_v) = vb.bindings.pop().unwrap();\n         vb.vals.insert(vid.to_uint(), old_v);\n     }\n }"}, {"sha": "536bbd0b20da031b1e62cfe45bf276832ce7abd6", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -150,22 +150,22 @@ impl RegionVarBindings {\n         debug!(\"RegionVarBindings: commit()\");\n         let mut undo_log = self.undo_log.borrow_mut();\n         while undo_log.get().len() > 0 {\n-            undo_log.get().pop();\n+            undo_log.get().pop().unwrap();\n         }\n     }\n \n     pub fn rollback_to(&self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n         while undo_log.get().len() > snapshot {\n-            let undo_item = undo_log.get().pop();\n+            let undo_item = undo_log.get().pop().unwrap();\n             debug!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n                 let mut var_origins = self.var_origins.borrow_mut();\n                 assert_eq!(var_origins.get().len(), vid.to_uint() + 1);\n-                var_origins.get().pop();\n+                var_origins.get().pop().unwrap();\n               }\n               AddConstraint(ref constraint) => {\n                 let mut constraints = self.constraints.borrow_mut();\n@@ -1234,7 +1234,7 @@ impl RegionVarBindings {\n         process_edges(self, &mut state, graph, orig_node_idx, dir);\n \n         while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop();\n+            let node_idx = state.stack.pop().unwrap();\n             let classification = var_data[node_idx.to_uint()].classification;\n \n             // check whether we've visited this node on some previous walk"}, {"sha": "85585ecaf5483b005645684fff77b3d5d242b4a1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -242,7 +242,7 @@ impl ResolveState {\n                 ty::mk_var(tcx, vid)\n               }\n             };\n-            self.v_seen.pop();\n+            self.v_seen.pop().unwrap();\n             return t1;\n         }\n     }"}, {"sha": "9b1caaa152ce3b341542ebcc1fe13379392eb445", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -164,7 +164,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         info: |&render::Cache| -> Option<(~[~str], &'static str)>) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n-    let last = path.segments.last();\n+    let last = path.segments.last().unwrap();\n     if last.lifetimes.len() > 0 || last.types.len() > 0 {\n         let mut counter = 0;\n         generics.push_str(\"&lt;\");\n@@ -230,13 +230,13 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                     }\n                     match shortty {\n                         \"mod\" => {\n-                            url.push_str(*fqp.last());\n+                            url.push_str(*fqp.last().unwrap());\n                             url.push_str(\"/index.html\");\n                         }\n                         _ => {\n                             url.push_str(shortty);\n                             url.push_str(\".\");\n-                            url.push_str(*fqp.last());\n+                            url.push_str(*fqp.last().unwrap());\n                             url.push_str(\".html\");\n                         }\n                     }\n@@ -457,7 +457,7 @@ impl fmt::Default for clean::ViewPath {\n     fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) {\n         match *v {\n             clean::SimpleImport(ref name, ref src) => {\n-                if *name == src.path.segments.last().name {\n+                if *name == src.path.segments.last().unwrap().name {\n                     write!(f.buf, \"use {};\", *src);\n                 } else {\n                     write!(f.buf, \"use {} = {};\", *name, *src);"}, {"sha": "5d0728c8cdf77c6ff4ac6df1216a8f53d1ab6830", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -112,7 +112,7 @@ pub fn render(w: &mut io::Writer, s: &str) {\n         unsafe {\n             let my_opaque: &my_opaque = cast::transmute(opaque);\n             vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n-                let text = str::from_utf8(text);\n+                let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().filter(|l| stripped_filtered_line(*l).is_none());\n                 let text = lines.to_owned_vec().connect(\"\\n\");\n \n@@ -172,14 +172,14 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             let (test, shouldfail, ignore) =\n                 vec::raw::buf_as_slice((*lang).data,\n                                        (*lang).size as uint, |lang| {\n-                    let s = str::from_utf8(lang);\n+                    let s = str::from_utf8(lang).unwrap();\n                     (s.contains(\"rust\"), s.contains(\"should_fail\"),\n                      s.contains(\"ignore\"))\n                 });\n             if !test { return }\n             vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let tests: &mut ::test::Collector = intrinsics::transmute(opaque);\n-                let text = str::from_utf8(text);\n+                let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().map(|l| stripped_filtered_line(l).unwrap_or(l));\n                 let text = lines.to_owned_vec().connect(\"\\n\");\n                 tests.add_test(text, ignore, shouldfail);"}, {"sha": "b0a56cb402b5ffe57a100c22333148f6c9217fae", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -275,7 +275,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n             if i > 0 { write!(w, \",\"); }\n             write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                   id, short, *fqp.last());\n+                   id, short, *fqp.last().unwrap());\n         }\n         write!(w, \"\\\\};\");\n         w.flush();\n@@ -427,7 +427,7 @@ impl<'a> SourceCollector<'a> {\n                 }\n             }\n         }\n-        let contents = str::from_utf8_owned(contents);\n+        let contents = str::from_utf8_owned(contents).unwrap();\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n@@ -522,15 +522,15 @@ impl DocFolder for Cache {\n                     clean::TyMethodItem(..) |\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n-                        Some((Some(*self.parent_stack.last()),\n+                        Some((Some(*self.parent_stack.last().unwrap()),\n                               self.stack.slice_to(self.stack.len() - 1)))\n \n                     }\n                     clean::MethodItem(..) => {\n                         if self.parent_stack.len() == 0 {\n                             None\n                         } else {\n-                            let last = self.parent_stack.last();\n+                            let last = self.parent_stack.last().unwrap();\n                             let amt = match self.paths.find(last) {\n                                 Some(&(_, \"trait\")) => self.stack.len() - 1,\n                                 Some(..) | None => self.stack.len(),\n@@ -635,8 +635,8 @@ impl DocFolder for Cache {\n             i => i,\n         };\n \n-        if pushed { self.stack.pop(); }\n-        if parent_pushed { self.parent_stack.pop(); }\n+        if pushed { self.stack.pop().unwrap(); }\n+        if parent_pushed { self.parent_stack.pop().unwrap(); }\n         self.privmod = orig_privmod;\n         return ret;\n     }\n@@ -673,7 +673,7 @@ impl Context {\n         self.dst = prev;\n         let len = self.root_path.len();\n         self.root_path.truncate(len - 3);\n-        self.current.pop();\n+        self.current.pop().unwrap();\n \n         return ret;\n     }\n@@ -693,11 +693,13 @@ impl Context {\n         local_data::set(cache_key, Arc::new(cache));\n \n         let mut work = ~[(self, item)];\n-        while work.len() > 0 {\n-            let (mut cx, item) = work.pop();\n-            cx.item(item, |cx, item| {\n-                work.push((cx.clone(), item));\n-            })\n+        loop {\n+            match work.pop() {\n+                Some((mut cx, item)) => cx.item(item, |cx, item| {\n+                    work.push((cx.clone(), item));\n+                }),\n+                None => break,\n+            }\n         }\n     }\n "}, {"sha": "393be290506e127582f5ca899f6c33019f9dd1f2", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -330,7 +330,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             crate.encode(&mut encoder);\n         }\n-        str::from_utf8_owned(w.unwrap())\n+        str::from_utf8_owned(w.unwrap()).unwrap()\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "239abbe546ff0ddfecd1bfe00fb3ae8c196ebfde", "filename": "src/librustpkg/crate_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -121,7 +121,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n             None\n         }\n         else {\n-            let last = self.components.pop();\n+            let last = self.components.pop().unwrap();\n             self.remaining.unshift(last);\n             // converting to str and then back is a little unfortunate\n             Some((Path::new(self.components.connect(\"/\")),"}, {"sha": "c9db8af0b8a9ce17e9b5547a93e2a521515b0456", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -193,7 +193,7 @@ impl<'a> PkgScript<'a> {\n                         Some(output) => {\n                             debug!(\"run_custom: second pkg command did {:?}\", output.status);\n                             // Run the configs() function to get the configs\n-                            let cfgs = str::from_utf8(output.output).words()\n+                            let cfgs = str::from_utf8(output.output).unwrap().words()\n                                 .map(|w| w.to_owned()).collect();\n                             Some((cfgs, output.status))\n                         },"}, {"sha": "4b7aaf7e340d94af8593dac8dfc07102d3c5b70a", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -38,8 +38,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                                                        target.as_str().unwrap().to_owned()]);\n             let outp = opt_outp.expect(\"Failed to exec `git`\");\n             if !outp.status.success() {\n-                println!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n-                println!(\"{}\", str::from_utf8_owned(outp.error));\n+                println!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n+                println!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n                 return DirToUse(target.clone());\n             }\n             else {\n@@ -54,8 +54,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                              format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                              ~\"checkout\", format!(\"{}\", *s)]).expect(\"Failed to exec `git`\");\n                         if !outp.status.success() {\n-                            println!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n-                            println!(\"{}\", str::from_utf8_owned(outp.error));\n+                            println!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n+                            println!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n                             return DirToUse(target.clone());\n                         }\n                     }\n@@ -114,8 +114,8 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n                                                target.as_str().unwrap().to_owned()]);\n     let outp = opt_outp.expect(\"Failed to exec `git`\");\n     if !outp.status.success() {\n-         debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n-         debug!(\"{}\", str::from_utf8_owned(outp.error));\n+         debug!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n+         debug!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n          cond.raise((source.to_owned(), target.clone()))\n     }\n     else {\n@@ -125,8 +125,8 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n                                                          target);\n                     let outp = opt_outp.expect(\"Failed to exec `git`\");\n                     if !outp.status.success() {\n-                        debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n-                        debug!(\"{}\", str::from_utf8_owned(outp.error));\n+                        debug!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n+                        debug!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n                         cond.raise((source.to_owned(), target.clone()))\n                     }\n             }"}, {"sha": "c0b4a246d35d76216c10780a4249373af24d1809", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -143,7 +143,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n     let rslt = prog.finish_with_output();\n     if !rslt.status.success() {\n         fail!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n-           rslt.status, str::from_utf8(rslt.output), str::from_utf8(rslt.error));\n+           rslt.status, str::from_utf8(rslt.output).unwrap(), str::from_utf8(rslt.error).unwrap());\n     }\n }\n \n@@ -279,13 +279,13 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     }).expect(format!(\"failed to exec `{}`\", cmd));\n     let output = prog.finish_with_output();\n     debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n-           cmd, args, str::from_utf8(output.output),\n-           str::from_utf8(output.error),\n+           cmd, args, str::from_utf8(output.output).unwrap(),\n+           str::from_utf8(output.error).unwrap(),\n            output.status);\n     if !output.status.success() {\n         debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} {} ---\",\n               cmd, args, output.status,\n-              str::from_utf8(output.output), str::from_utf8(output.error));\n+              str::from_utf8(output.output).unwrap(), str::from_utf8(output.error).unwrap());\n         Fail(output)\n     }\n     else {\n@@ -445,7 +445,7 @@ fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let mut result = ~[];\n     let p_output = command_line_test(args, &os::getcwd());\n-    let test_output = str::from_utf8(p_output.output);\n+    let test_output = str::from_utf8(p_output.output).unwrap();\n     for s in test_output.split('\\n') {\n         result.push(s.to_owned());\n     }\n@@ -459,7 +459,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n         Fail(_) => fail!(\"Command-line test failed\"),\n         Success(r) => r\n     };\n-    let test_output = str::from_utf8(p_output.output);\n+    let test_output = str::from_utf8(p_output.output).unwrap();\n     for s in test_output.split('\\n') {\n         result.push(s.to_owned());\n     }\n@@ -1191,15 +1191,15 @@ fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n     let workspace = create_local_package(&CrateId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n-    assert_eq!(str::from_utf8_owned(output.output), expected_info);\n+    assert_eq!(str::from_utf8_owned(output.output).unwrap(), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n     let workspace = create_local_package(&CrateId::new(\"foo\"));\n     command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n     let output = command_line_test([~\"list\"], workspace.path());\n-    assert!(!str::from_utf8(output.output).contains(\"foo\"));\n+    assert!(!str::from_utf8(output.output).unwrap().contains(\"foo\"));\n }\n \n #[test]\n@@ -1269,8 +1269,8 @@ fn test_extern_mod() {\n     let outp = prog.finish_with_output();\n     if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n-              str::from_utf8(outp.output),\n-              str::from_utf8(outp.error));\n+              str::from_utf8(outp.output).unwrap(),\n+              str::from_utf8(outp.error).unwrap());\n     }\n     assert!(exec_file.exists() && is_executable(&exec_file));\n }\n@@ -1324,8 +1324,8 @@ fn test_extern_mod_simpler() {\n     let outp = prog.finish_with_output();\n     if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n-              str::from_utf8(outp.output),\n-              str::from_utf8(outp.error));\n+              str::from_utf8(outp.output).unwrap(),\n+              str::from_utf8(outp.error).unwrap());\n     }\n     assert!(exec_file.exists() && is_executable(&exec_file));\n }\n@@ -2092,7 +2092,7 @@ fn test_rustpkg_test_creates_exec() {\n fn test_rustpkg_test_output() {\n     let workspace = create_local_package_with_test(&CrateId::new(\"foo\"));\n     let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n-    let output_str = str::from_utf8(output.output);\n+    let output_str = str::from_utf8(output.output).unwrap();\n     // The first two assertions are separate because test output may\n     // contain color codes, which could appear between \"test f\" and \"ok\".\n     assert!(output_str.contains(\"test f\"));\n@@ -2123,7 +2123,7 @@ fn test_rustpkg_test_cfg() {\n               \"#[test] #[cfg(not(foobar))] fn f() { assert!('a' != 'a'); }\");\n     let output = command_line_test([~\"test\", ~\"--cfg\", ~\"foobar\", ~\"foo\"],\n                                    foo_workspace);\n-    let output_str = str::from_utf8(output.output);\n+    let output_str = str::from_utf8(output.output).unwrap();\n     assert!(output_str.contains(\"0 passed; 0 failed; 0 ignored; 0 measured\"));\n }\n \n@@ -2424,8 +2424,8 @@ fn correct_error_dependency() {\n         Fail(ProcessOutput{ error: error, output: output, .. }) => {\n             assert!(str::is_utf8(error));\n             assert!(str::is_utf8(output));\n-            let error_str = str::from_utf8(error);\n-            let out_str   = str::from_utf8(output);\n+            let error_str = str::from_utf8(error).unwrap();\n+            let out_str   = str::from_utf8(output).unwrap();\n             debug!(\"ss = {}\", error_str);\n             debug!(\"out_str = {}\", out_str);\n             if out_str.contains(\"Package badpkg depends on some_package_that_doesnt_exist\") &&"}, {"sha": "77dbb33551808351ab15a2fcf04833d7c5c9057b", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -115,7 +115,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n         }\n \n         let mut output = None;\n-        let output_text = str::from_utf8(outp.output);\n+        let output_text = str::from_utf8(outp.output).unwrap();\n         for l in output_text.lines() {\n             if !l.is_whitespace() {\n                 output = Some(l);\n@@ -147,8 +147,8 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n         let outp = opt_outp.expect(\"Failed to exec `git`\");\n         if outp.status.success() {\n             debug!(\"Cloned it... ( {}, {} )\",\n-                   str::from_utf8(outp.output),\n-                   str::from_utf8(outp.error));\n+                   str::from_utf8(outp.output).unwrap(),\n+                   str::from_utf8(outp.error).unwrap());\n             let mut output = None;\n             let git_dir = tmp_dir.join(\".git\");\n             debug!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n@@ -158,7 +158,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                                                [\"--git-dir=\" + git_dir.as_str().unwrap(),\n                                                 ~\"tag\", ~\"-l\"]);\n             let outp = opt_outp.expect(\"Failed to exec `git`\");\n-            let output_text = str::from_utf8(outp.output);\n+            let output_text = str::from_utf8(outp.output).unwrap();\n             debug!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n             for l in output_text.lines() {\n                 debug!(\"A line of output: {}\", l);"}, {"sha": "8f7ced93fb0c6a7defbc7fa3e19a65d3a99dd90c", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -488,7 +488,7 @@ mod test {\n \n             let nread = result.unwrap();\n             assert!(nread > 0);\n-            let read_str = str::from_utf8(read_mem.slice_to(nread as uint));\n+            let read_str = str::from_utf8(read_mem.slice_to(nread as uint)).unwrap();\n             assert_eq!(read_str, \"hello\");\n         }\n         // unlink"}, {"sha": "c735e325068247e0ed7bfaefa70a16081beed8c6", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -167,7 +167,7 @@ impl CString {\n         if self.buf.is_null() { return None; }\n         let buf = self.as_bytes();\n         let buf = buf.slice_to(buf.len()-1); // chop off the trailing NUL\n-        str::from_utf8_opt(buf)\n+        str::from_utf8(buf)\n     }\n \n     /// Return a CString iterator."}, {"sha": "411f9f254593fc50484f05c4972e223f1d09fa3d", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -691,7 +691,7 @@ pub fn format(args: &Arguments) -> ~str {\n pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n     write_unsafe(&mut output as &mut io::Writer, fmt, args);\n-    return str::from_utf8_owned(output.unwrap());\n+    return str::from_utf8_owned(output.unwrap()).unwrap();\n }\n \n impl<'a> Formatter<'a> {\n@@ -812,7 +812,7 @@ impl<'a> Formatter<'a> {\n \n     fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n         ::uint::to_str_bytes(value, 10, |buf| {\n-            let valuestr = str::from_utf8(buf);\n+            let valuestr = str::from_utf8(buf).unwrap();\n             for piece in pieces.iter() {\n                 self.run(piece, Some(valuestr));\n             }"}, {"sha": "745273a1d74be3064559d44f578b0589a9ea86c7", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -370,7 +370,7 @@ mod test {\n \n     impl Reader for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            self.lengths.shift_opt()\n+            self.lengths.shift()\n         }\n     }\n "}, {"sha": "cb98ff21105bba7eb386c7413bf255f482cd3044", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -519,7 +519,7 @@ pub struct Directories {\n \n impl Iterator<Path> for Directories {\n     fn next(&mut self) -> Option<Path> {\n-        match self.stack.shift_opt() {\n+        match self.stack.shift() {\n             Some(path) => {\n                 if path.is_dir() {\n                     self.stack.push_all_move(readdir(&path));\n@@ -754,7 +754,7 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match read_stream.read(read_buf).unwrap() {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8_owned(read_buf.slice_to(n).to_owned())\n+                n => str::from_utf8_owned(read_buf.slice_to(n).to_owned()).unwrap()\n             };\n             assert_eq!(read_str, message.to_owned());\n         }\n@@ -805,7 +805,7 @@ mod test {\n             }\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n+        let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message);\n     })\n \n@@ -829,7 +829,7 @@ mod test {\n             tell_pos_post_read = read_stream.tell();\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n+        let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n         assert_eq!(tell_pos_post_read, message.len() as u64);\n@@ -854,7 +854,7 @@ mod test {\n             read_stream.read(read_mem);\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n+        let read_str = str::from_utf8(read_mem).unwrap();\n         assert!(read_str == final_msg.to_owned());\n     })\n \n@@ -876,15 +876,15 @@ mod test {\n \n             read_stream.seek(-4, SeekEnd);\n             read_stream.read(read_mem);\n-            assert_eq!(str::from_utf8(read_mem), chunk_three);\n+            assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_three);\n \n             read_stream.seek(-9, SeekCur);\n             read_stream.read(read_mem);\n-            assert_eq!(str::from_utf8(read_mem), chunk_two);\n+            assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_two);\n \n             read_stream.seek(0, SeekSet);\n             read_stream.read(read_mem);\n-            assert_eq!(str::from_utf8(read_mem), chunk_one);\n+            assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n         }\n         unlink(filename);\n     })\n@@ -958,7 +958,7 @@ mod test {\n             {\n                 let n = f.filestem_str();\n                 File::open(f).read(mem);\n-                let read_str = str::from_utf8(mem);\n+                let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n"}, {"sha": "30827983360692f3029be5f6ddcbc55c8f5b26bd", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -607,7 +607,7 @@ pub trait Reader {\n     /// This function will raise all the same conditions as the `read` method,\n     /// along with raising a condition if the input is not valid UTF-8.\n     fn read_to_str(&mut self) -> ~str {\n-        match str::from_utf8_owned_opt(self.read_to_end()) {\n+        match str::from_utf8_owned(self.read_to_end()) {\n             Some(s) => s,\n             None => {\n                 io_error::cond.raise(standard_error(InvalidInput));\n@@ -1117,7 +1117,7 @@ pub trait Buffer: Reader {\n     /// The task will also fail if sequence of bytes leading up to\n     /// the newline character are not valid UTF-8.\n     fn read_line(&mut self) -> Option<~str> {\n-        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n+        self.read_until('\\n' as u8).map(|line| str::from_utf8_owned(line).unwrap())\n     }\n \n     /// Create an iterator that reads a line on each iteration until EOF.\n@@ -1202,7 +1202,7 @@ pub trait Buffer: Reader {\n                 }\n             }\n         }\n-        match str::from_utf8_opt(buf.slice_to(width)) {\n+        match str::from_utf8(buf.slice_to(width)) {\n             Some(s) => Some(s.char_at(0)),\n             None => None\n         }"}, {"sha": "c3fb3e97edfde7f8fef9fde17c3182f694342b2b", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -161,8 +161,11 @@ impl Drop for Process {\n     fn drop(&mut self) {\n         // Close all I/O before exiting to ensure that the child doesn't wait\n         // forever to print some text or something similar.\n-        for _ in range(0, self.io.len()) {\n-            self.io.pop();\n+        loop {\n+            match self.io.pop() {\n+                Some(_) => (),\n+                None => break,\n+            }\n         }\n \n         self.wait();\n@@ -251,7 +254,7 @@ mod tests {\n         loop {\n             match input.read(buf) {\n                 None => { break }\n-                Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n))); }\n+                Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n)).unwrap()); }\n             }\n         }\n         return ret;"}, {"sha": "bf9e6b739f2a4a4c9ceb6c195a2ca628f62dcdc7", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -351,7 +351,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n \n-            let extra_digit = ascii2value(buf.pop());\n+            let extra_digit = ascii2value(buf.pop().unwrap());\n             if extra_digit >= radix / 2 { // -> need to round\n                 let mut i: int = buf.len() as int - 1;\n                 loop {\n@@ -427,7 +427,7 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits);\n-    (str::from_utf8_owned(bytes), special)\n+    (str::from_utf8_owned(bytes).unwrap(), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}, {"sha": "6464d6021ee53e3adf3b2f30822bf05ff9781b6d", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -189,7 +189,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If the path is not representable in utf-8, this returns None.\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_opt(self.as_vec())\n+        str::from_utf8(self.as_vec())\n     }\n \n     /// Returns the path as a byte vector\n@@ -220,7 +220,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `dirname` for details.\n     #[inline]\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_opt(self.dirname())\n+        str::from_utf8(self.dirname())\n     }\n     /// Returns the file component of `self`, as a byte vector.\n     /// If `self` represents the root of the file hierarchy, returns None.\n@@ -230,7 +230,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `filename` for details.\n     #[inline]\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filename().and_then(str::from_utf8_opt)\n+        self.filename().and_then(str::from_utf8)\n     }\n     /// Returns the stem of the filename of `self`, as a byte vector.\n     /// The stem is the portion of the filename just before the last '.'.\n@@ -252,7 +252,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `filestem` for details.\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filestem().and_then(str::from_utf8_opt)\n+        self.filestem().and_then(str::from_utf8)\n     }\n     /// Returns the extension of the filename of `self`, as an optional byte vector.\n     /// The extension is the portion of the filename just after the last '.'.\n@@ -275,7 +275,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `extension` for details.\n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().and_then(str::from_utf8_opt)\n+        self.extension().and_then(str::from_utf8)\n     }\n \n     /// Replaces the filename portion of the path with the given byte vector or string.\n@@ -426,7 +426,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         let t: Option<T> = None;\n         if BytesContainer::is_str(t) {\n             for p in paths.iter() {\n-                self.push(p.container_as_str())\n+                self.push(p.container_as_str().unwrap())\n             }\n         } else {\n             for p in paths.iter() {\n@@ -499,19 +499,10 @@ pub trait BytesContainer {\n     fn container_into_owned_bytes(self) -> ~[u8] {\n         self.container_as_bytes().to_owned()\n     }\n-    /// Returns the receiver interpreted as a utf-8 string\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises `str::null_byte` if not utf-8\n-    #[inline]\n-    fn container_as_str<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.container_as_bytes())\n-    }\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]\n-    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_opt(self.container_as_bytes())\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_utf8(self.container_as_bytes())\n     }\n     /// Returns whether .container_as_str() is guaranteed to not fail\n     // FIXME (#8888): Remove unused arg once ::<for T> works\n@@ -589,11 +580,7 @@ impl<'a> BytesContainer for &'a str {\n         self.as_bytes()\n     }\n     #[inline]\n-    fn container_as_str<'a>(&'a self) -> &'a str {\n-        *self\n-    }\n-    #[inline]\n-    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         Some(*self)\n     }\n     #[inline]\n@@ -610,11 +597,7 @@ impl BytesContainer for ~str {\n         self.into_bytes()\n     }\n     #[inline]\n-    fn container_as_str<'a>(&'a self) -> &'a str {\n-        self.as_slice()\n-    }\n-    #[inline]\n-    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         Some(self.as_slice())\n     }\n     #[inline]\n@@ -627,11 +610,7 @@ impl BytesContainer for @str {\n         self.as_bytes()\n     }\n     #[inline]\n-    fn container_as_str<'a>(&'a self) -> &'a str {\n-        self.as_slice()\n-    }\n-    #[inline]\n-    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         Some(self.as_slice())\n     }\n     #[inline]"}, {"sha": "e95bd2d8ca2f3ddfd7dcbcd3ae87e51f0b1a4f09", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -402,13 +402,13 @@ impl Path {\n     /// Returns an iterator that yields each component of the path as Option<&str>.\n     /// See components() for details.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        self.components().map(str::from_utf8_opt)\n+        self.components().map(str::from_utf8)\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n     /// See components() for details.\n     pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n-        self.rev_components().map(str::from_utf8_opt)\n+        self.rev_components().map(str::from_utf8)\n     }\n }\n \n@@ -426,7 +426,7 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n         else if comp == bytes!(\"..\") {\n             if is_abs && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n-            else { comps.pop(); changed = true }\n+            else { comps.pop().unwrap(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if changed {\n@@ -691,7 +691,7 @@ mod tests {\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = Path::new($path);\n-                    let left = path.$op().map(|x| str::from_utf8(x));\n+                    let left = path.$op().map(|x| str::from_utf8(x).unwrap());\n                     assert_eq!(left, $exp);\n                 }\n             );"}, {"sha": "666b8977cc972d1607862b14ff905178913129e7", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -129,11 +129,7 @@ impl BytesContainer for Path {\n         self.into_vec()\n     }\n     #[inline]\n-    fn container_as_str<'a>(&'a self) -> &'a str {\n-        self.as_str().unwrap()\n-    }\n-    #[inline]\n-    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         self.as_str()\n     }\n     #[inline]\n@@ -146,11 +142,7 @@ impl<'a> BytesContainer for &'a Path {\n         self.as_vec()\n     }\n     #[inline]\n-    fn container_as_str<'a>(&'a self) -> &'a str {\n-        self.as_str().unwrap()\n-    }\n-    #[inline]\n-    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         self.as_str()\n     }\n     #[inline]\n@@ -162,10 +154,10 @@ impl GenericPathUnsafe for Path {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n+    /// Fails if not valid UTF-8.\n     #[inline]\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n-        let (prefix, path) = Path::normalize_(path.container_as_str());\n+        let (prefix, path) = Path::normalize_(path.container_as_str().unwrap());\n         assert!(!path.is_empty());\n         let mut ret = Path{ repr: path, prefix: prefix, sepidx: None };\n         ret.update_sepidx();\n@@ -176,9 +168,9 @@ impl GenericPathUnsafe for Path {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n+    /// Fails if not valid UTF-8.\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n-        let filename = filename.container_as_str();\n+        let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n             None if \"..\" == self.repr => {\n                 let mut s = str::with_capacity(3 + filename.len());\n@@ -224,7 +216,7 @@ impl GenericPathUnsafe for Path {\n     /// the new path is relative to. Otherwise, the new path will be treated\n     /// as if it were absolute and will replace the receiver outright.\n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n-        let path = path.container_as_str();\n+        let path = path.container_as_str().unwrap();\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n             let rest = path.slice_from(prefix_len(prefix));\n@@ -311,7 +303,7 @@ impl GenericPathUnsafe for Path {\n impl GenericPath for Path {\n     #[inline]\n     fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n-        let s = path.container_as_str_opt();\n+        let s = path.container_as_str();\n         match s {\n             None => None,\n             Some(s) => {\n@@ -599,7 +591,7 @@ impl Path {\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n-    /// Raises the `str::not_utf8` condition if invalid UTF-8.\n+    /// Fails if invalid UTF-8.\n     #[inline]\n     pub fn new<T: BytesContainer>(path: T) -> Path {\n         GenericPath::new(path)\n@@ -1025,7 +1017,7 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n             };\n             if (is_abs || has_abs_prefix) && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(\"..\"); n_up += 1 }\n-            else { comps.pop(); changed = true }\n+            else { comps.pop().unwrap(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if !changed && !prefix_is_verbatim(prefix) {"}, {"sha": "8919f9f890311cc04d6610d3c2722d6d7c2c967a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -123,7 +123,7 @@ impl<'a> MovePtr for ReprVisitor<'a> {\n         self.ptr_stk.push(self.ptr);\n     }\n     fn pop_ptr(&mut self) {\n-        self.ptr = self.ptr_stk.pop();\n+        self.ptr = self.ptr_stk.pop().unwrap();\n     }\n }\n \n@@ -471,7 +471,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         let mut write = false;\n-        match self.var_stk.pop() {\n+        match self.var_stk.pop().unwrap() {\n             SearchingFor(sought) => {\n                 if disr_val == sought {\n                     self.var_stk.push(Matched);\n@@ -534,7 +534,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                         _sz: uint,\n                         _align: uint)\n                         -> bool {\n-        match self.var_stk.pop() {\n+        match self.var_stk.pop().unwrap() {\n             SearchingFor(..) => fail!(\"enum value matched no variant\"),\n             _ => true\n         }\n@@ -608,7 +608,7 @@ pub fn repr_to_str<T>(t: &T) -> ~str {\n \n     let mut result = io::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t);\n-    str::from_utf8_owned(result.unwrap())\n+    str::from_utf8_owned(result.unwrap()).unwrap()\n }\n \n #[cfg(test)]\n@@ -626,7 +626,7 @@ fn test_repr() {\n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n         write_repr(&mut m as &mut io::Writer, t);\n-        let s = str::from_utf8_owned(m.unwrap());\n+        let s = str::from_utf8_owned(m.unwrap()).unwrap();\n         assert_eq!(s.as_slice(), e);\n     }\n "}, {"sha": "f460d3f494408d5ef9b4dbef0682f263e44143ee", "filename": "src/libstd/run.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -372,7 +372,7 @@ mod tests {\n \n         let run::ProcessOutput {status, output, error}\n              = run::process_output(\"echo\", [~\"hello\"]).expect(\"failed to exec `echo`\");\n-        let output_str = str::from_utf8_owned(output);\n+        let output_str = str::from_utf8_owned(output).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -439,7 +439,7 @@ mod tests {\n                 None => break\n             }\n         }\n-        str::from_utf8_owned(res)\n+        str::from_utf8_owned(res).unwrap()\n     }\n \n     #[test]\n@@ -467,7 +467,7 @@ mod tests {\n             .expect(\"failed to exec `echo`\");\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n-        let output_str = str::from_utf8_owned(output);\n+        let output_str = str::from_utf8_owned(output).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -486,7 +486,7 @@ mod tests {\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n-        let output_str = str::from_utf8_owned(output);\n+        let output_str = str::from_utf8_owned(output).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -533,7 +533,7 @@ mod tests {\n     fn test_keep_current_working_dir() {\n         let mut prog = run_pwd(None);\n \n-        let output = str::from_utf8_owned(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n@@ -551,7 +551,7 @@ mod tests {\n         let parent_dir = os::getcwd().dir_path();\n         let mut prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8_owned(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat();\n@@ -590,7 +590,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -604,7 +604,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -623,7 +623,7 @@ mod tests {\n         new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n \n         let mut prog = run_env(Some(new_env));\n-        let output = str::from_utf8_owned(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"));\n     }"}, {"sha": "95a02e1631a9af9aea6d13e63edcaf2588dafb33", "filename": "src/libstd/str.rs", "status": "modified", "additions": 11, "deletions": 70, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -117,38 +117,13 @@ use default::Default;\n use send_str::{SendStr, SendStrOwned};\n use unstable::raw::Repr;\n \n-/*\n-Section: Conditions\n-*/\n-\n-condition! {\n-    pub not_utf8: (~str) -> ~str;\n-}\n-\n /*\n Section: Creating a string\n */\n \n-/// Consumes a vector of bytes to create a new utf-8 string\n-///\n-/// # Failure\n-///\n-/// Raises the `not_utf8` condition if invalid UTF-8\n-pub fn from_utf8_owned(vv: ~[u8]) -> ~str {\n-    use str::not_utf8::cond;\n-\n-    if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n-        cond.raise(format!(\"from_utf8: input is not UTF-8; first bad byte is {}\",\n-                           first_bad_byte))\n-    } else {\n-        unsafe { raw::from_utf8_owned(vv) }\n-    }\n-}\n-\n /// Consumes a vector of bytes to create a new utf-8 string.\n /// Returns None if the vector contains invalid UTF-8.\n-pub fn from_utf8_owned_opt(vv: ~[u8]) -> Option<~str> {\n+pub fn from_utf8_owned(vv: ~[u8]) -> Option<~str> {\n     if is_utf8(vv) {\n         Some(unsafe { raw::from_utf8_owned(vv) })\n     } else {\n@@ -161,17 +136,8 @@ pub fn from_utf8_owned_opt(vv: ~[u8]) -> Option<~str> {\n /// Once the slice has been validated as utf-8, it is transmuted in-place and\n /// returned as a '&str' instead of a '&[u8]'\n ///\n-/// # Failure\n-///\n-/// Fails if invalid UTF-8\n-pub fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n-    from_utf8_opt(v).expect(\"from_utf8: not utf-8\")\n-}\n-\n-/// Converts a vector to a string slice without performing any allocations.\n-///\n /// Returns None if the slice is not utf-8.\n-pub fn from_utf8_opt<'a>(v: &'a [u8]) -> Option<&'a str> {\n+pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n     if is_utf8(v) {\n         Some(unsafe { raw::from_utf8(v) })\n     } else { None }\n@@ -666,7 +632,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n     fn next(&mut self) -> Option<char> {\n         use unicode::decompose::canonical_combining_class;\n \n-        match self.buffer.head_opt() {\n+        match self.buffer.head() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.shift();\n@@ -703,7 +669,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n             self.sorted = true;\n         }\n \n-        match self.buffer.shift_opt() {\n+        match self.buffer.shift() {\n             Some((c, 0)) => {\n                 self.sorted = false;\n                 Some(c)\n@@ -3436,7 +3402,7 @@ mod tests {\n         let s1: ~str = ~\"All mimsy were the borogoves\";\n \n         let v: ~[u8] = s1.as_bytes().to_owned();\n-        let s2: ~str = from_utf8(v).to_owned();\n+        let s2: ~str = from_utf8(v).unwrap().to_owned();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -3961,50 +3927,25 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8() {\n         let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8(xs), \"hello\");\n-\n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8(xs), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_str_from_utf8_invalid() {\n-        let xs = bytes!(\"hello\", 0xff);\n-        let _ = from_utf8(xs);\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8_opt() {\n-        let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8_opt(xs), Some(\"hello\"));\n+        assert_eq!(from_utf8(xs), Some(\"hello\"));\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_opt(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(from_utf8(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"hello\", 0xff);\n-        assert_eq!(from_utf8_opt(xs), None);\n+        assert_eq!(from_utf8(xs), None);\n     }\n \n     #[test]\n     fn test_str_from_utf8_owned() {\n         let xs = bytes!(\"hello\").to_owned();\n-        assert_eq!(from_utf8_owned(xs), ~\"hello\");\n-\n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\").to_owned();\n-        assert_eq!(from_utf8_owned(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8_owned_opt() {\n-        let xs = bytes!(\"hello\").to_owned();\n-        assert_eq!(from_utf8_owned_opt(xs), Some(~\"hello\"));\n+        assert_eq!(from_utf8_owned(xs), Some(~\"hello\"));\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\").to_owned();\n-        assert_eq!(from_utf8_owned_opt(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(from_utf8_owned(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"hello\", 0xff).to_owned();\n-        assert_eq!(from_utf8_owned_opt(xs), None);\n+        assert_eq!(from_utf8_owned(xs), None);\n     }\n \n     #[test]"}, {"sha": "e99e9ef09403a1e289ef9c1fe6ce940fc393adb1", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -157,7 +157,7 @@ impl<T: Send> BufferPool<T> {\n         unsafe {\n             self.pool.with(|pool| {\n                 match pool.iter().position(|x| x.size() >= (1 << bits)) {\n-                    Some(i) => pool.remove(i),\n+                    Some(i) => pool.remove(i).unwrap(),\n                     None => ~Buffer::new(bits)\n                 }\n             })"}, {"sha": "27e949a56408ab903a8db8ecae9a970d432ba5d6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 42, "deletions": 156, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -941,11 +941,9 @@ pub trait ImmutableVector<'a, T> {\n \n     /// Returns the element of a vector at the given index, or `None` if the\n     /// index is out of bounds\n-    fn get_opt(&self, index: uint) -> Option<&'a T>;\n-    /// Returns the first element of a vector, failing if the vector is empty.\n-    fn head(&self) -> &'a T;\n+    fn get(&self, index: uint) -> Option<&'a T>;\n     /// Returns the first element of a vector, or `None` if it is empty\n-    fn head_opt(&self) -> Option<&'a T>;\n+    fn head(&self) -> Option<&'a T>;\n     /// Returns all but the first element of a vector\n     fn tail(&self) -> &'a [T];\n     /// Returns all but the first `n' elements of a vector\n@@ -954,10 +952,8 @@ pub trait ImmutableVector<'a, T> {\n     fn init(&self) -> &'a [T];\n     /// Returns all but the last `n' elements of a vector\n     fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, failing if the vector is empty.\n-    fn last(&self) -> &'a T;\n     /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last_opt(&self) -> Option<&'a T>;\n+    fn last(&self) -> Option<&'a T>;\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n@@ -1118,18 +1114,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn get_opt(&self, index: uint) -> Option<&'a T> {\n+    fn get(&self, index: uint) -> Option<&'a T> {\n         if index < self.len() { Some(&self[index]) } else { None }\n     }\n \n     #[inline]\n-    fn head(&self) -> &'a T {\n-        if self.len() == 0 { fail!(\"head: empty vector\") }\n-        &self[0]\n-    }\n-\n-    #[inline]\n-    fn head_opt(&self) -> Option<&'a T> {\n+    fn head(&self) -> Option<&'a T> {\n         if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n \n@@ -1150,13 +1140,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn last(&self) -> &'a T {\n-        if self.len() == 0 { fail!(\"last: empty vector\") }\n-        &self[self.len() - 1]\n-    }\n-\n-    #[inline]\n-    fn last_opt(&self) -> Option<&'a T> {\n+    fn last(&self) -> Option<&'a T> {\n             if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n@@ -1397,14 +1381,10 @@ pub trait OwnedVector<T> {\n     /// assert!(a == ~[~1, ~2, ~3, ~4]);\n     /// ```\n     fn push_all_move(&mut self, rhs: ~[T]);\n-    /// Remove the last element from a vector and return it, failing if it is empty\n-    fn pop(&mut self) -> T;\n     /// Remove the last element from a vector and return it, or `None` if it is empty\n-    fn pop_opt(&mut self) -> Option<T>;\n-    /// Removes the first element from a vector and return it\n-    fn shift(&mut self) -> T;\n+    fn pop(&mut self) -> Option<T>;\n     /// Removes the first element from a vector and return it, or `None` if it is empty\n-    fn shift_opt(&mut self) -> Option<T>;\n+    fn shift(&mut self) -> Option<T>;\n     /// Prepend an element to the vector\n     fn unshift(&mut self, x: T);\n \n@@ -1419,18 +1399,14 @@ pub trait OwnedVector<T> {\n     /// # Example\n     /// ```rust\n     /// let mut v = ~[1, 2, 3];\n-    /// assert_eq!(v.remove_opt(1), Some(2));\n+    /// assert_eq!(v.remove(1), Some(2));\n     /// assert_eq!(v, ~[1, 3]);\n     ///\n-    /// assert_eq!(v.remove_opt(4), None);\n+    /// assert_eq!(v.remove(4), None);\n     /// // v is unchanged:\n     /// assert_eq!(v, ~[1, 3]);\n     /// ```\n-    fn remove_opt(&mut self, i: uint) -> Option<T>;\n-\n-    /// Remove and return the element at position i within v, shifting\n-    /// all elements after position i one position to the left.\n-    fn remove(&mut self, i: uint) -> T;\n+    fn remove(&mut self, i: uint) -> Option<T>;\n \n     /**\n      * Remove an element from anywhere in the vector and return it, replacing it\n@@ -1581,7 +1557,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    fn pop_opt(&mut self) -> Option<T> {\n+    fn pop(&mut self) -> Option<T> {\n         match self.len() {\n             0  => None,\n             ln => {\n@@ -1596,19 +1572,11 @@ impl<T> OwnedVector<T> for ~[T] {\n \n \n     #[inline]\n-    fn pop(&mut self) -> T {\n-        self.pop_opt().expect(\"pop: empty vector\")\n+    fn shift(&mut self) -> Option<T> {\n+        self.remove(0)\n     }\n \n     #[inline]\n-    fn shift(&mut self) -> T {\n-        self.shift_opt().expect(\"shift: empty vector\")\n-    }\n-\n-    fn shift_opt(&mut self) -> Option<T> {\n-        self.remove_opt(0)\n-    }\n-\n     fn unshift(&mut self, x: T) {\n         self.insert(0, x)\n     }\n@@ -1632,15 +1600,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    #[inline]\n-    fn remove(&mut self, i: uint) -> T {\n-        match self.remove_opt(i) {\n-            Some(t) => t,\n-            None => fail!(\"remove: the len is {} but the index is {}\", self.len(), i)\n-        }\n-    }\n-\n-    fn remove_opt(&mut self, i: uint) -> Option<T> {\n+    fn remove(&mut self, i: uint) -> Option<T> {\n         let len = self.len();\n         if i < len {\n             unsafe { // infallible\n@@ -1668,7 +1628,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         if index < ln - 1 {\n             self.swap(index, ln - 1);\n         }\n-        self.pop()\n+        self.pop().unwrap()\n     }\n     fn truncate(&mut self, newlen: uint) {\n         let oldlen = self.len();\n@@ -3043,38 +3003,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_get_opt() {\n+    fn test_get() {\n         let mut a = ~[11];\n-        assert_eq!(a.get_opt(1), None);\n+        assert_eq!(a.get(1), None);\n         a = ~[11, 12];\n-        assert_eq!(a.get_opt(1).unwrap(), &12);\n+        assert_eq!(a.get(1).unwrap(), &12);\n         a = ~[11, 12, 13];\n-        assert_eq!(a.get_opt(1).unwrap(), &12);\n+        assert_eq!(a.get(1).unwrap(), &12);\n     }\n \n     #[test]\n     fn test_head() {\n-        let mut a = ~[11];\n-        assert_eq!(a.head(), &11);\n-        a = ~[11, 12];\n-        assert_eq!(a.head(), &11);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_head_empty() {\n-        let a: ~[int] = ~[];\n-        a.head();\n-    }\n-\n-    #[test]\n-    fn test_head_opt() {\n         let mut a = ~[];\n-        assert_eq!(a.head_opt(), None);\n+        assert_eq!(a.head(), None);\n         a = ~[11];\n-        assert_eq!(a.head_opt().unwrap(), &11);\n+        assert_eq!(a.head().unwrap(), &11);\n         a = ~[11, 12];\n-        assert_eq!(a.head_opt().unwrap(), &11);\n+        assert_eq!(a.head().unwrap(), &11);\n     }\n \n     #[test]\n@@ -3139,27 +3084,12 @@ mod tests {\n \n     #[test]\n     fn test_last() {\n-        let mut a = ~[11];\n-        assert_eq!(a.last(), &11);\n-        a = ~[11, 12];\n-        assert_eq!(a.last(), &12);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_last_empty() {\n-        let a: ~[int] = ~[];\n-        a.last();\n-    }\n-\n-    #[test]\n-    fn test_last_opt() {\n         let mut a = ~[];\n-        assert_eq!(a.last_opt(), None);\n+        assert_eq!(a.last(), None);\n         a = ~[11];\n-        assert_eq!(a.last_opt().unwrap(), &11);\n+        assert_eq!(a.last().unwrap(), &11);\n         a = ~[11, 12];\n-        assert_eq!(a.last_opt().unwrap(), &12);\n+        assert_eq!(a.last().unwrap(), &12);\n     }\n \n     #[test]\n@@ -3214,28 +3144,16 @@ mod tests {\n         assert_eq!(vec.slice_to(0), &[]);\n     }\n \n-    #[test]\n-    fn test_pop() {\n-        // Test on-heap pop.\n-        let mut v = ~[1, 2, 3, 4, 5];\n-        let e = v.pop();\n-        assert_eq!(v.len(), 4u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n-        assert_eq!(v[2], 3);\n-        assert_eq!(v[3], 4);\n-        assert_eq!(e, 5);\n-    }\n \n     #[test]\n-    fn test_pop_opt() {\n+    fn test_pop() {\n         let mut v = ~[5];\n-        let e = v.pop_opt();\n+        let e = v.pop();\n         assert_eq!(v.len(), 0);\n         assert_eq!(e, Some(5));\n-        let f = v.pop_opt();\n+        let f = v.pop();\n         assert_eq!(f, None);\n-        let g = v.pop_opt();\n+        let g = v.pop();\n         assert_eq!(g, None);\n     }\n \n@@ -3645,21 +3563,11 @@ mod tests {\n     #[test]\n     fn test_shift() {\n         let mut x = ~[1, 2, 3];\n-        assert_eq!(x.shift(), 1);\n+        assert_eq!(x.shift(), Some(1));\n         assert_eq!(&x, &~[2, 3]);\n-        assert_eq!(x.shift(), 2);\n-        assert_eq!(x.shift(), 3);\n-        assert_eq!(x.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_shift_opt() {\n-        let mut x = ~[1, 2, 3];\n-        assert_eq!(x.shift_opt(), Some(1));\n-        assert_eq!(&x, &~[2, 3]);\n-        assert_eq!(x.shift_opt(), Some(2));\n-        assert_eq!(x.shift_opt(), Some(3));\n-        assert_eq!(x.shift_opt(), None);\n+        assert_eq!(x.shift(), Some(2));\n+        assert_eq!(x.shift(), Some(3));\n+        assert_eq!(x.shift(), None);\n         assert_eq!(x.len(), 0);\n     }\n \n@@ -3697,48 +3605,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_remove_opt() {\n+    fn test_remove() {\n         let mut a = ~[1,2,3,4];\n \n-        assert_eq!(a.remove_opt(2), Some(3));\n+        assert_eq!(a.remove(2), Some(3));\n         assert_eq!(a, ~[1,2,4]);\n \n-        assert_eq!(a.remove_opt(2), Some(4));\n+        assert_eq!(a.remove(2), Some(4));\n         assert_eq!(a, ~[1,2]);\n \n-        assert_eq!(a.remove_opt(2), None);\n+        assert_eq!(a.remove(2), None);\n         assert_eq!(a, ~[1,2]);\n \n-        assert_eq!(a.remove_opt(0), Some(1));\n+        assert_eq!(a.remove(0), Some(1));\n         assert_eq!(a, ~[2]);\n \n-        assert_eq!(a.remove_opt(0), Some(2));\n-        assert_eq!(a, ~[]);\n-\n-        assert_eq!(a.remove_opt(0), None);\n-        assert_eq!(a.remove_opt(10), None);\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut a = ~[1, 2, 3, 4];\n-        a.remove(2);\n-        assert_eq!(a, ~[1, 2, 4]);\n-\n-        let mut a = ~[1, 2, 3];\n-        a.remove(0);\n-        assert_eq!(a, ~[2, 3]);\n-\n-        let mut a = ~[1];\n-        a.remove(0);\n+        assert_eq!(a.remove(0), Some(2));\n         assert_eq!(a, ~[]);\n-    }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_remove_oob() {\n-        let mut a = ~[1, 2, 3];\n-        a.remove(3);\n+        assert_eq!(a.remove(0), None);\n+        assert_eq!(a.remove(10), None);\n     }\n \n     #[test]"}, {"sha": "0585f1abecc0c0aab585d1d5b4043883f1f16f42", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -106,7 +106,7 @@ fn pretty_ty(ty: &Ty, itr: @IdentInterner, out: &mut ~str) {\n         // need custom handling.\n         TyNil => { out.push_str(\"$NIL$\"); return }\n         TyPath(ref path, _, _) => {\n-            out.push_str(itr.get(path.segments.last().identifier.name));\n+            out.push_str(itr.get(path.segments.last().unwrap().identifier.name));\n             return\n         }\n         TyTup(ref tys) => {\n@@ -139,7 +139,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> PathElem {\n     match *trait_ref {\n         None => pretty = ~\"\",\n         Some(ref trait_ref) => {\n-            pretty = itr.get(trait_ref.path.segments.last().identifier.name).to_owned();\n+            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name).to_owned();\n             pretty.push_char('$');\n         }\n     };\n@@ -340,7 +340,7 @@ impl<F: FoldOps> Folder for Ctx<F> {\n             _ => {}\n         }\n \n-        self.path.pop();\n+        self.path.pop().unwrap();\n \n         SmallVector::one(i)\n     }"}, {"sha": "47ae146d19b31b87d4cc1f569391726a6994067f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -31,7 +31,7 @@ pub fn path_name_i(idents: &[Ident]) -> ~str {\n // totally scary function: ignores all but the last element, should have\n // a different name\n pub fn path_to_ident(path: &Path) -> Ident {\n-    path.segments.last().identifier\n+    path.segments.last().unwrap().identifier\n }\n \n pub fn local_def(id: NodeId) -> DefId {\n@@ -904,7 +904,7 @@ pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n /// case pop and discard (so two of the same marks cancel)\n pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n     if (marks.len() > 0) && (getLast(marks) == mark) {\n-        marks.pop();\n+        marks.pop().unwrap();\n     } else {\n         marks.push(mark);\n     }\n@@ -913,7 +913,7 @@ pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n // get the last element of a mutable array.\n // FIXME #4903: , must be a separate procedure for now.\n pub fn getLast(arr: &~[Mrk]) -> Mrk {\n-    *arr.last()\n+    *arr.last().unwrap()\n }\n \n // are two paths equal when compared unhygienically?"}, {"sha": "ebf02f7691e40dc6db437b96ed1cd5ed12663d54", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -269,12 +269,9 @@ impl CodeMap {\n \n     pub fn new_filemap(&self, filename: FileName, src: @str) -> @FileMap {\n         let mut files = self.files.borrow_mut();\n-        let start_pos = if files.get().len() == 0 {\n-            0\n-        } else {\n-            let last_start = files.get().last().start_pos.to_uint();\n-            let last_len = files.get().last().src.len();\n-            last_start + last_len\n+        let start_pos = match files.get().last() {\n+            None => 0,\n+            Some(last) => last.start_pos.to_uint() + last.src.len(),\n         };\n \n         let filemap = @FileMap {"}, {"sha": "86982201303507736fd75150af2225fd97178693", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -356,7 +356,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn print_backtrace(&self) { }\n     pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n-    pub fn mod_pop(&mut self) { self.mod_path.pop(); }\n+    pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> ~[ast::Ident] { self.mod_path.clone() }\n     pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n         match ei {"}, {"sha": "3c0d7aaf4f3a82a578870e060341d618ac206c66", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -253,7 +253,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 lifetimes: OptVec<ast::Lifetime>,\n                 types: ~[P<ast::Ty>])\n                 -> ast::Path {\n-        let last_identifier = idents.pop();\n+        let last_identifier = idents.pop().unwrap();\n         let mut segments: ~[ast::PathSegment] = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {"}, {"sha": "fe519a31efa6b3e656ec8af74eba4ffb8e7a3e0f", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -841,7 +841,7 @@ impl<'a> MethodDef<'a> {\n                                                      matching,\n                                                      matches_so_far,\n                                                      match_count + 1);\n-                matches_so_far.pop();\n+                matches_so_far.pop().unwrap();\n                 arms.push(cx.arm(trait_.span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n@@ -875,7 +875,7 @@ impl<'a> MethodDef<'a> {\n                                                          new_matching,\n                                                          matches_so_far,\n                                                          match_count + 1);\n-                    matches_so_far.pop();\n+                    matches_so_far.pop().unwrap();\n \n                     let arm = cx.arm(trait_.span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n@@ -920,7 +920,7 @@ enum StructType {\n // general helper methods.\n impl<'a> TraitDef<'a> {\n     fn set_expn_info(&self, mut to_set: Span) -> Span {\n-        let trait_name = match self.path.path.last_opt() {\n+        let trait_name = match self.path.path.last() {\n             None => self.cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };"}, {"sha": "1c349c4343ac5697efb870ae60fb8eb4079589ff", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -42,7 +42,7 @@ pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n     match ctx.registrars.len() {\n         0 => None,\n         1 => {\n-            let (node_id, _) = ctx.registrars.pop();\n+            let (node_id, _) = ctx.registrars.pop().unwrap();\n             Some(ast::DefId {\n                 crate: ast::LOCAL_CRATE,\n                 node: node_id"}, {"sha": "a9f94da7a98cbea0a1680b7edd0746b59600c21a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -109,7 +109,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n         Ok(bytes) => bytes,\n     };\n-    match str::from_utf8_owned_opt(bytes) {\n+    match str::from_utf8_owned(bytes) {\n         Some(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information"}, {"sha": "492852c6a79760a51c34ea21f68fb572305b4244", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -238,8 +238,11 @@ pub fn parse(sess: @ParseSess,\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n \n         /* we append new items to this while we go */\n-        while !cur_eis.is_empty() { /* for each Earley Item */\n-            let ei = cur_eis.pop();\n+        loop {\n+            let ei = match cur_eis.pop() {\n+                None => break, /* for each Earley Item */\n+                Some(ei) => ei,\n+            };\n \n             let idx = ei.idx;\n             let len = ei.elts.len();\n@@ -347,7 +350,7 @@ pub fn parse(sess: @ParseSess,\n             if eof_eis.len() == 1u {\n                 let mut v = ~[];\n                 for dv in eof_eis[0u].matches.mut_iter() {\n-                    v.push(dv.pop());\n+                    v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, v));\n             } else if eof_eis.len() > 1u {\n@@ -376,13 +379,13 @@ pub fn parse(sess: @ParseSess,\n             } else if next_eis.len() > 0u {\n                 /* Now process the next token */\n                 while next_eis.len() > 0u {\n-                    cur_eis.push(next_eis.pop());\n+                    cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n                 let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n-                let mut ei = bb_eis.pop();\n+                let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@MatchedNonterminal("}, {"sha": "20d544f52c90f8a035a89f5ad0a9e57064ec52a2", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -190,7 +190,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n         if !r.stack.get().dotdotdoted || {\n                 let repeat_idx = r.repeat_idx.borrow();\n                 let repeat_len = r.repeat_len.borrow();\n-                *repeat_idx.get().last() == *repeat_len.get().last() - 1\n+                *repeat_idx.get().last().unwrap() ==\n+                *repeat_len.get().last().unwrap() - 1\n             } {\n \n             match r.stack.get().up {\n@@ -203,8 +204,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                     {\n                         let mut repeat_idx = r.repeat_idx.borrow_mut();\n                         let mut repeat_len = r.repeat_len.borrow_mut();\n-                        repeat_idx.get().pop();\n-                        repeat_len.get().pop();\n+                        repeat_idx.get().pop().unwrap();\n+                        repeat_len.get().pop().unwrap();\n                     }\n                 }\n "}, {"sha": "ce3042cb9cde5d6ea2be5cde9991010f03836b53", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -48,17 +48,17 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pub fn pop(&mut self) -> T {\n+    pub fn pop(&mut self) -> Option<T> {\n         match *self {\n             Vec(ref mut v) => v.pop(),\n-            Empty => fail!(\"pop from empty opt_vec\")\n+            Empty => None\n         }\n     }\n \n-    pub fn last<'a>(&'a self) -> &'a T {\n+    pub fn last<'a>(&'a self) -> Option<&'a T> {\n         match *self {\n             Vec(ref v) => v.last(),\n-            Empty => fail!(\"last on empty opt_vec\")\n+            Empty => None\n         }\n     }\n "}, {"sha": "22ece367b8028962c23072669696b330952b3c00", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -351,7 +351,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     path: @str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[Comment], ~[Literal]) {\n-    let src = str::from_utf8_owned(srdr.read_to_end()).to_managed();\n+    let src = str::from_utf8_owned(srdr.read_to_end()).unwrap().to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "9713f331147c01b931a438abbad04545a6c48461", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -246,7 +246,7 @@ pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n             unreachable!()\n         }\n     };\n-    match str::from_utf8_owned_opt(bytes) {\n+    match str::from_utf8_owned(bytes) {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_managed(),\n                                      path.as_str().unwrap().to_managed());\n@@ -315,7 +315,7 @@ mod test {\n         let mut writer = MemWriter::new();\n         let mut encoder = extra::json::Encoder::new(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n-        str::from_utf8_owned(writer.unwrap())\n+        str::from_utf8_owned(writer.unwrap()).unwrap()\n     }\n \n     // produce a codemap::span"}, {"sha": "4e1703fe6b0c796e42550234d017f7659a8cb657", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -1753,19 +1753,19 @@ impl Parser {\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n-            self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n+            self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n             while self.token == token::COMMA {\n                 self.bump();\n                 if self.token != token::RPAREN {\n                     es.push(self.parse_expr());\n-                    self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n+                    self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n                 }\n                 else {\n                     trailing_comma = true;\n                 }\n             }\n             hi = self.span.hi;\n-            self.commit_expr_expecting(*es.last(), token::RPAREN);\n+            self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n \n             return if es.len() == 1 && !trailing_comma {\n                 self.mk_expr(lo, self.span.hi, ExprParen(es[0]))\n@@ -1924,7 +1924,8 @@ impl Parser {\n \n                     fields.push(self.parse_field());\n                     while self.token != token::RBRACE {\n-                        self.commit_expr(fields.last().expr, &[token::COMMA], &[token::RBRACE]);\n+                        self.commit_expr(fields.last().unwrap().expr,\n+                                         &[token::COMMA], &[token::RBRACE]);\n \n                         if self.eat(&token::DOTDOT) {\n                             base = Some(self.parse_expr());\n@@ -1939,7 +1940,7 @@ impl Parser {\n                     }\n \n                     hi = pth.span.hi;\n-                    self.commit_expr_expecting(fields.last().expr, token::RBRACE);\n+                    self.commit_expr_expecting(fields.last().unwrap().expr, token::RBRACE);\n                     ex = ExprStruct(pth, fields, base);\n                     return self.mk_expr(lo, hi, ex);\n                 }\n@@ -2092,7 +2093,7 @@ impl Parser {\n                   // This is a conservative error: only report the last unclosed delimiter. The\n                   // previous unclosed delimiters could actually be closed! The parser just hasn't\n                   // gotten to them yet.\n-                  match p.open_braces.last_opt() {\n+                  match p.open_braces.last() {\n                       None => {}\n                       Some(&sp) => p.span_note(sp, \"unclosed delimiter\"),\n                   };\n@@ -2157,7 +2158,7 @@ impl Parser {\n \n                 // Parse the close delimiter.\n                 result.push(parse_any_tt_tok(self));\n-                self.open_braces.pop();\n+                self.open_braces.pop().unwrap();\n \n                 TTDelim(@result)\n             }\n@@ -3592,7 +3593,7 @@ impl Parser {\n                 }\n             );\n \n-        let variadic = match args.pop_opt() {\n+        let variadic = match args.pop() {\n             Some(None) => true,\n             Some(x) => {\n                 // Need to put back that last arg\n@@ -4217,7 +4218,7 @@ impl Parser {\n     }\n \n     fn pop_mod_path(&mut self) {\n-        self.mod_path_stack.pop();\n+        self.mod_path_stack.pop().unwrap();\n     }\n \n     // read a module from a source file."}, {"sha": "902d9e1c28468e16e933c5278a41eb4189367e20", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -511,7 +511,7 @@ impl Printer {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n-            print_stack.pop();\n+            print_stack.pop().unwrap();\n           }\n           Break(b) => {\n             let top = self.get_top();"}, {"sha": "54e9a8bd62937f378677e4f6d9f72b551d95ff2d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -78,7 +78,7 @@ pub fn ibox(s: &mut State, u: uint) {\n pub fn end(s: &mut State) {\n     {\n         let mut boxes = s.boxes.borrow_mut();\n-        boxes.get().pop();\n+        boxes.get().pop().unwrap();\n     }\n     pp::end(&mut s.s);\n }\n@@ -1090,11 +1090,11 @@ pub fn print_call_pre(s: &mut State,\n     match sugar {\n         ast::DoSugar => {\n             head(s, \"do\");\n-            Some(base_args.pop())\n+            Some(base_args.pop().unwrap())\n         }\n         ast::ForSugar => {\n             head(s, \"for\");\n-            Some(base_args.pop())\n+            Some(base_args.pop().unwrap())\n         }\n         ast::NoSugar => None\n     }\n@@ -1947,7 +1947,7 @@ pub fn print_view_path(s: &mut State, vp: &ast::ViewPath) {\n     match vp.node {\n       ast::ViewPathSimple(ident, ref path, _) => {\n         // FIXME(#6993) can't compare identifiers directly here\n-        if path.segments.last().identifier.name != ident.name {\n+        if path.segments.last().unwrap().identifier.name != ident.name {\n             print_ident(s, ident);\n             space(&mut s.s);\n             word_space(s, \"=\");\n@@ -2316,7 +2316,7 @@ pub fn print_string(s: &mut State, st: &str, style: ast::StrStyle) {\n // downcasts.\n unsafe fn get_mem_writer(writer: &mut ~io::Writer) -> ~str {\n     let (_, wr): (uint, ~MemWriter) = cast::transmute_copy(writer);\n-    let result = str::from_utf8_owned(wr.get_ref().to_owned());\n+    let result = str::from_utf8_owned(wr.get_ref().to_owned()).unwrap();\n     cast::forget(wr);\n     result\n }"}, {"sha": "6ad2d8f8c8d66ec1831ca779ed9cd4fb3cd7a0d5", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -65,7 +65,7 @@ fn shift_push() {\n     let mut v2 = ~[];\n \n     while v1.len() > 0 {\n-        v2.push(v1.shift());\n+        v2.push(v1.shift().unwrap());\n     }\n }\n "}, {"sha": "a5838f2017385f56bcda105ce7c03b2e8fe7bfec", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -40,7 +40,7 @@ fn recv(p: &pipe) -> uint {\n             while state.is_empty() {\n                 cond.wait();\n             }\n-            state.pop()\n+            state.pop().unwrap()\n         })\n     }\n }"}, {"sha": "fa7026b6569f9dfb16eeb6e463b406e267e1a440", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -37,7 +37,7 @@ fn recv(p: &pipe) -> uint {\n         while state.is_empty() {\n             cond.wait();\n         }\n-        state.pop()\n+        state.pop().unwrap()\n     })\n }\n "}, {"sha": "61e76b992830086668bac89431142a9aa19b1d88", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -59,7 +59,7 @@ impl Code {\n         }\n \n         reverse(result);\n-        str::from_utf8_owned(result)\n+        str::from_utf8_owned(result).unwrap()\n     }\n }\n "}, {"sha": "c5b01e68fc4e8f1824093eb7dc7c9487dffb72ff", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -187,7 +187,7 @@ fn to_utf8(raw_sol: &List<u64>) -> ~str {\n             if m & 1 << i != 0 {sol[i] = '0' as u8 + id;}\n         }\n     }\n-    std::str::from_utf8_owned(sol)\n+    std::str::from_utf8_owned(sol).unwrap()\n }\n \n // Prints a solution in ~str form."}, {"sha": "db46c3db439a7ef0508138d9a171df205b534d09", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -91,7 +91,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 unique: ~Cons((), @*st.unique),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n-                vec: st.vec + &[@Cons((), *st.vec.last())],\n+                vec: st.vec + &[@Cons((), *st.vec.last().unwrap())],\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}, {"sha": "3442e971f4fe5d9b6b34554956274f5a8df5354c", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -62,14 +62,14 @@ fn test_destroy_actually_kills(force: bool) {\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()])\n             .expect(\"failed to exec `ps`\");\n-        str::from_utf8_owned(output).contains(pid.to_str())\n+        str::from_utf8_owned(output).unwrap().contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()])\n             .expect(\"failed to exec `/system/bin/ps`\");\n-        str::from_utf8_owned(output).contains(~\"root\")\n+        str::from_utf8_owned(output).unwrap().contains(~\"root\")\n     }\n \n     #[cfg(windows)]"}, {"sha": "96a6e1c4f6061973fa227443fe5ca9a4ef172c71", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -81,7 +81,7 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(&str::from_utf8(k).to_owned()) {\n+                match reducers.find(&str::from_utf8(k).unwrap().to_owned()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }\n                 }"}, {"sha": "76759d04ab4ae34959adb3fd322d14af526a80b7", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918a7314a8d49d870ff95f8ed6c7bdc5895138c9/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=918a7314a8d49d870ff95f8ed6c7bdc5895138c9", "patch": "@@ -260,7 +260,7 @@ fn test_write() {\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = str::from_utf8_owned(buf.unwrap());\n+    let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n     t!(s, \"34helloline\\nbar\\n\");\n }\n \n@@ -284,7 +284,7 @@ fn test_format_args() {\n         format_args!(|args| { fmt::write(w, args) }, \"test\");\n         format_args!(|args| { fmt::write(w, args) }, \"{test}\", test=3);\n     }\n-    let s = str::from_utf8_owned(buf.unwrap());\n+    let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n     t!(s, \"1test3\");\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");"}]}