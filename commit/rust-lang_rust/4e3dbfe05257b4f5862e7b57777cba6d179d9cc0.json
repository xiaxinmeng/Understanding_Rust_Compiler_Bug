{"sha": "4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlM2RiZmUwNTI1N2I0ZjU4NjJlN2I1Nzc3N2NiYTZkMTc5ZDljYzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-06T02:06:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-08T06:32:54Z"}, "message": "librustc: Remove structural record types from the compiler", "tree": {"sha": "62d9b6044fa74d11807e0f69dd56680e1747830e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62d9b6044fa74d11807e0f69dd56680e1747830e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "html_url": "https://github.com/rust-lang/rust/commit/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "239e64242c2f35b223403be611ad6a25ce8e76c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/239e64242c2f35b223403be611ad6a25ce8e76c2", "html_url": "https://github.com/rust-lang/rust/commit/239e64242c2f35b223403be611ad6a25ce8e76c2"}], "stats": {"total": 399, "additions": 28, "deletions": 371}, "files": [{"sha": "33a5aa651438e99582bc502f6863958ffebf5ca1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -299,16 +299,6 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         let v = parse_vstore(st);\n         return ty::mk_estr(st.tcx, v);\n       }\n-      'R' => {\n-        assert (next(st) == '[');\n-        let mut fields: ~[ty::field] = ~[];\n-        while peek(st) != ']' {\n-            let name = st.tcx.sess.ident_of(parse_str(st, '='));\n-            fields.push(ty::field { ident: name, mt: parse_mt(st, conv) });\n-        }\n-        st.pos = st.pos + 1u;\n-        return ty::mk_rec(st.tcx, fields);\n-      }\n       'T' => {\n         assert (next(st) == '[');\n         let mut params = ~[];"}, {"sha": "caad6335ce512c36a0334b3cb6a901e6cd73ad03", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -283,15 +283,6 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n         enc_vstore(w, cx, v);\n       }\n       ty::ty_unboxed_vec(mt) => { w.write_char('U'); enc_mt(w, cx, mt); }\n-      ty::ty_rec(fields) => {\n-        w.write_str(&\"R[\");\n-        for fields.each |field| {\n-            w.write_str(*cx.tcx.sess.str_of(field.ident));\n-            w.write_char('=');\n-            enc_mt(w, cx, field.mt);\n-        }\n-        w.write_char(']');\n-      }\n       ty::ty_closure(ref f) => {\n         w.write_char('f');\n         enc_closure_ty(w, cx, f);"}, {"sha": "60e08e7dc986d8001080b9d4b292b4a849f39735", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -352,7 +352,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n                  -> Option<ctor> {\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n-      ty::ty_rec(_) | ty::ty_struct(*) => {\n+      ty::ty_struct(*) => {\n         for m.each |r| {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n@@ -449,7 +449,6 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n     match /*bad*/copy ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n-      ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match ctor { variant(id) => id,\n@@ -548,19 +547,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     _ => None\n                 }\n             }\n-            pat_rec(ref flds, _) => {\n-                let ty_flds = match /*bad*/copy ty::get(left_ty).sty {\n-                    ty::ty_rec(flds) => flds,\n-                    _ => fail!(~\"bad type for pat_rec\")\n-                };\n-                let args = vec::map(ty_flds, |ty_fld| {\n-                    match flds.find(|f| f.ident == ty_fld.ident) {\n-                        Some(f) => f.pat,\n-                        _ => wild()\n-                    }\n-                });\n-                Some(vec::append(args, vec::from_slice(r.tail())))\n-            }\n+            pat_rec(ref flds, _) => fail!(),\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n                 match cx.tcx.def_map.get(&pat_id) {"}, {"sha": "3590840d50fc624872b2b0ee7123af027590755f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -1114,15 +1114,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n                    f_name: ast::ident,\n                    node_id: ast::node_id)\n                 -> Option<ast::mutability> {\n-    // Need to refactor so that records/class fields can be treated uniformly.\n+    // Need to refactor so that struct/enum fields can be treated uniformly.\n     match /*bad*/copy ty::get(base_ty).sty {\n-      ty::ty_rec(fields) => {\n-        for fields.each |f| {\n-            if f.ident == f_name {\n-                return Some(f.mt.mutbl);\n-            }\n-        }\n-      }\n       ty::ty_struct(did, _) => {\n         for ty::lookup_struct_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {"}, {"sha": "c3f8f94d4d4a544d653cf65acd82fb14690bf4f9", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -480,7 +480,6 @@ pub impl VisitContext {\n                     // then `with` is consumed, otherwise it is only read\n                     let with_ty = ty::expr_ty(self.tcx, *with_expr);\n                     let with_fields = match ty::get(with_ty).sty {\n-                        ty::ty_rec(ref f) => copy *f,\n                         ty::ty_struct(did, ref substs) => {\n                             ty::struct_fields(self.tcx, did, substs)\n                         }"}, {"sha": "38a8a118e4e37a7936be989d9e10030122ec8312", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -729,12 +729,6 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, cx, visitor);\n       }\n \n-      ast::ty_rec(ref fields) => {\n-        for (*fields).each |field| {\n-            visit_mt(field.node.mt, cx, visitor);\n-        }\n-      }\n-\n       ast::ty_path(path, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {"}, {"sha": "4ad61c190a94b6808d1918f5fffb9afb25389492", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -11,10 +11,10 @@\n /*!\n  * # Representation of Algebraic Data Types\n  *\n- * This module determines how to represent enums, structs, tuples, and\n- * (deprecated) structural records based on their monomorphized types;\n- * it is responsible both for choosing a representation and\n- * translating basic operations on values of those types.\n+ * This module determines how to represent enums, structs, and tuples\n+ * based on their monomorphized types; it is responsible both for\n+ * choosing a representation and translating basic operations on\n+ * values of those types.\n  *\n  * Note that the interface treats everything as a general case of an\n  * enum, so structs/tuples/etc. have one pseudo-variant with\n@@ -131,11 +131,6 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n         ty::ty_tup(ref elems) => {\n             Univariant(mk_struct(cx, *elems), NonStruct)\n         }\n-        ty::ty_rec(ref fields) => {\n-            // XXX: Are these in the right order?\n-            Univariant(mk_struct(cx, fields.map(|f| f.mt.ty)),\n-                       StructWithoutDtor)\n-        }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n             let dt = ty::ty_dtor(cx.tcx, def_id).is_present();"}, {"sha": "445818be940c4d96866b4b2a9318de3d08d4039d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -639,7 +639,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n \n     let mut cx = cx;\n     match /*bad*/copy ty::get(t).sty {\n-      ty::ty_rec(*) | ty::ty_struct(*) => {\n+      ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {"}, {"sha": "02b68afff4a82d2c5d5eaafaeef0d1c79f79f91c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -473,33 +473,6 @@ fn add_member(cx: @mut StructCtxt,\n     cx.total_size += size * 8;\n }\n \n-fn create_record(cx: @CrateContext, t: ty::t, fields: ~[ast::ty_field],\n-                 span: span) -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n-    let scx = create_structure(file_node,\n-                               cx.sess.str_of(\n-                                   ((/*bad*/copy cx.dbg_cx).get().names)\n-                                   (~\"rec\")),\n-                               line_from_span(cx.sess.codemap,\n-                                              span) as int);\n-    for fields.each |field| {\n-        let field_t = ty::get_field(cx.tcx, t, field.node.ident).mt.ty;\n-        let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n-        let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, *cx.sess.str_of(field.node.ident),\n-                   line_from_span(cx.sess.codemap, field.span) as int,\n-                   size as int, align as int, ty_md.node);\n-    }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n-}\n-\n fn create_boxed_type(cx: @CrateContext, outer: ty::t, _inner: ty::t,\n                      span: span, boxed: @Metadata<TyDescMetadata>)\n     -> @Metadata<TyDescMetadata> {\n@@ -628,16 +601,6 @@ fn create_ty(_cx: @CrateContext, _t: ty::t, _ty: @ast::Ty)\n                                         mutbl: mt.mutbl}) }\n           ty::ty_uniq(mt) { ast::ty_uniq({ty: t_to_ty(cx, mt.ty, span),\n                                           mutbl: mt.mutbl}) }\n-          ty::ty_rec(fields) {\n-            let fs = ~[];\n-            for field in fields {\n-                fs.push({node: {ident: field.ident,\n-                               mt: {ty: t_to_ty(cx, field.mt.ty, span),\n-                                    mutbl: field.mt.mutbl}},\n-                        span: span});\n-            }\n-            ast::ty_rec(fs)\n-          }\n           ty::ty_vec(mt) { ast::ty_vec({ty: t_to_ty(cx, mt.ty, span),\n                                         mutbl: mt.mutbl}) }\n           _ {\n@@ -673,10 +636,6 @@ fn create_ty(_cx: @CrateContext, _t: ty::t, _ty: @ast::Ty)\n         return create_ty(cx, t, inferred);\n       }\n \n-      ast::ty_rec(fields) {\n-        return create_record(cx, t, fields, ty.span);\n-      }\n-\n       ast::ty_vec(mt) {\n         let inner_t = ty::sequence_element_type(cx.tcx, t);\n         let inner_ast_t = t_to_ty(cx, inner_t, mt.ty.span);"}, {"sha": "5278496277a5ef77a134183d3f55ca8c93ae5ce7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -1141,10 +1141,6 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          node_id_opt: Option<ast::node_id>,\n                          op: fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n-        ty::ty_rec(ref fields) => {\n-            op(0, *fields)\n-        }\n-\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_mutable_fields(tcx, did, substs))\n         }"}, {"sha": "4b9aad2558c86938ed2cc4244704c5b22451a3af", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -200,20 +200,6 @@ pub impl Reflector {\n               self.visit(~\"rptr\", extra)\n           }\n \n-          ty::ty_rec(fields) => {\n-              let extra = ~[self.c_uint(vec::len(fields))]\n-                  + self.c_size_and_align(t);\n-              do self.bracketed(~\"rec\", extra) |this| {\n-                for fields.eachi |i, field| {\n-                    let extra = ~[this.c_uint(i),\n-                                  this.c_slice(\n-                                      bcx.ccx().sess.str_of(field.ident))]\n-                        + this.c_mt(field.mt);\n-                    this.visit(~\"rec_field\", extra);\n-                }\n-            }\n-          }\n-\n           ty::ty_tup(tys) => {\n               let extra = ~[self.c_uint(vec::len(tys))]\n                   + self.c_size_and_align(t);"}, {"sha": "8aabfdfa63876d52f7f6634d89ad49aff6172bb8", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -142,8 +142,7 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n \n-        ty::ty_tup(*) | ty::ty_rec(*) | ty::ty_struct(*)\n-        | ty::ty_enum(*) => {\n+        ty::ty_tup(*) | ty::ty_struct(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n             T_struct(adt::sizing_fields_of(cx, repr))\n         }\n@@ -240,7 +239,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n-      ty::ty_tup(*) | ty::ty_rec(*) => {\n+      ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n           T_struct(adt::fields_of(cx, repr))\n       }"}, {"sha": "213e244593a3125e6158c2f99df2c00c75a136b4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 73, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -506,7 +506,6 @@ pub enum sty {\n     ty_evec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n-    ty_rec(~[field]),\n     ty_bare_fn(BareFnTy),\n     ty_closure(ClosureTy),\n     ty_trait(def_id, substs, vstore),\n@@ -899,7 +898,6 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         flags |= rflags(r);\n         flags |= get(m.ty).flags;\n       }\n-      &ty_rec(ref flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n@@ -1028,8 +1026,6 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n-pub fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n-\n pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: ctxt, +fty: ClosureTy) -> t {\n@@ -1163,9 +1159,6 @@ pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_trait(_, ref substs, _) => {\n         for (*substs).tps.each |subty| { maybe_walk_ty(*subty, f); }\n       }\n-      ty_rec(fields) => {\n-        for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n-      }\n       ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n       ty_bare_fn(ref ft) => {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n@@ -1223,14 +1216,6 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_trait(did, ref substs, vst) => {\n             ty_trait(did, fold_substs(substs, fldop), vst)\n         }\n-        ty_rec(fields) => {\n-            let new_fields = do vec::map(fields) |fl| {\n-                let new_ty = fldop(fl.mt.ty);\n-                let new_mt = mt { ty: new_ty, mutbl: fl.mt.mutbl };\n-                field { ident: fl.ident, mt: new_mt }\n-            };\n-            ty_rec(new_fields)\n-        }\n         ty_tup(ts) => {\n             let new_ts = vec::map(ts, |tt| fldop(*tt));\n             ty_tup(new_ts)\n@@ -1478,9 +1463,7 @@ pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) |\n-      ty_closure(_) |\n-      ty_trait(*) |\n+      ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_closure(_) | ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n       => true,\n@@ -1513,7 +1496,6 @@ pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match /*bad*/copy get(ty).sty {\n-      ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n       _ => fail!(~\"get_element_type called on invalid type\")\n     }\n@@ -1639,9 +1621,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             encountered_box = true;\n             true\n           }\n-          ty_nil | ty_bot | ty_bool |\n-          ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_rec(_) | ty_tup(_) | ty_ptr(_) => {\n+          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty_tup(_) | ty_ptr(_) => {\n             true\n           }\n           ty_enum(did, ref substs) => {\n@@ -1962,12 +1943,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_NONE\n             }\n \n-            ty_rec(ref flds) => {\n-                flds.foldl(\n-                    TC_NONE,\n-                    |tc, f| tc + tc_mt(cx, f.mt, cache))\n-            }\n-\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let flds_tc = flds.foldl(\n@@ -2151,10 +2126,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             n\n           }\n \n-          ty_rec(flds) => {\n-            flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n-          }\n-\n           ty_struct(did, ref substs) => {\n             let flds = struct_fields(cx, did, substs);\n             flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n@@ -2253,12 +2224,6 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false           // unsafe ptrs can always be NULL\n           }\n \n-          ty_rec(fields) => {\n-            do vec::any(fields) |field| {\n-                type_requires(cx, seen, r_ty, field.mt.ty)\n-            }\n-          }\n-\n           ty_trait(_, _, _) => {\n             false\n           }\n@@ -2327,14 +2292,6 @@ pub fn type_structurally_contains(cx: ctxt,\n         }\n         return false;\n       }\n-      ty_rec(fields) => {\n-        for fields.each |field| {\n-            if type_structurally_contains(cx, field.mt.ty, test) {\n-                return true;\n-            }\n-        }\n-        return false;\n-      }\n       ty_struct(did, ref substs) => {\n         for lookup_struct_fields(cx, did).each |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n@@ -2423,11 +2380,6 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n             if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n       }\n-      ty_rec(flds) => {\n-        for flds.each |f| {\n-            if !type_is_pod(cx, f.mt.ty) { result = false; }\n-        }\n-      }\n       ty_tup(elts) => {\n         for elts.each |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n@@ -2675,9 +2627,6 @@ impl to_bytes::IterBytes for sty {\n           ty_tup(ref ts) =>\n           to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n \n-          ty_rec(ref fs) =>\n-          to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n-\n           ty_bare_fn(ref ft) =>\n           to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n \n@@ -3220,23 +3169,6 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-pub fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n-    match vec::find(get_fields(rec_ty), |f| f.ident == id) {\n-      Some(f) => f,\n-      // Do we only call this when we know the field is legit?\n-      None => fail!(fmt!(\"get_field: ty doesn't have a field %s\",\n-                         *tcx.sess.str_of(id)))\n-    }\n-}\n-\n-pub fn get_fields(rec_ty:t) -> ~[field] {\n-    match /*bad*/copy get(rec_ty).sty {\n-      ty_rec(fields) => fields,\n-      // Can we check at the caller?\n-      _ => fail!(~\"get_fields: not a record type\")\n-    }\n-}\n-\n pub fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n     let mut i = 0u;\n     for meths.each |m| { if m.ident == id { return Some(i); } i += 1u; }\n@@ -3376,7 +3308,6 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_unboxed_vec(_) => ~\"unboxed vector\",\n       ty_ptr(_) => ~\"*-ptr\",\n       ty_rptr(_, _) => ~\"&-ptr\",\n-      ty_rec(_) => ~\"record\",\n       ty_bare_fn(_) => ~\"extern fn\",\n       ty_closure(_) => ~\"fn\",\n       ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n@@ -4141,7 +4072,7 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n-          ty_rec(_) | ty_tup(_) | ty_enum(_, _) => tycat_struct,\n+          ty_tup(_) | ty_enum(_, _) => tycat_struct,\n           ty_bot => tycat_bot,\n           _ => tycat_other\n         }"}, {"sha": "0b6c07832f634a5c767000b46e6f1615804fe3a7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -336,13 +336,6 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, *t));\n         ty::mk_tup(tcx, flds)\n       }\n-      ast::ty_rec(ref fields) => {\n-        let flds = do (*fields).map |f| {\n-            let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n-            field {ident: f.node.ident, mt: tm}\n-        };\n-        ty::mk_rec(tcx, flds)\n-      }\n       ast::ty_bare_fn(ref bf) => {\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n                                             bf.abi, &bf.decl))"}, {"sha": "119a59a526c30cfc88a540c17961e00ecc4525b3", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -415,39 +415,10 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n       ast::pat_rec(fields, etc) => {\n-        let ex_fields = match structure_of(fcx, pat.span, expected) {\n-          ty::ty_rec(fields) => fields,\n-          _ => {\n-            tcx.sess.span_fatal\n-                (pat.span,\n-                fmt!(\"mismatched types: expected `%s` but found record\",\n-                     fcx.infcx().ty_to_str(expected)));\n-          }\n-        };\n-        let f_count = vec::len(fields);\n-        let ex_f_count = vec::len(ex_fields);\n-        if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            tcx.sess.span_fatal\n-                (pat.span, fmt!(\"mismatched types: expected a record \\\n-                      with %u fields, found one with %u \\\n-                      fields\",\n-                                ex_f_count, f_count));\n-        }\n-\n-        for fields.each |f| {\n-            match vec::find(ex_fields, |a| f.ident == a.ident) {\n-              Some(field) => {\n-                check_pat(pcx, f.pat, field.mt.ty);\n-              }\n-              None => {\n-                tcx.sess.span_fatal(pat.span,\n-                                    fmt!(\"mismatched types: did not \\\n-                                          expect a record with a field `%s`\",\n-                                          *tcx.sess.str_of(f.ident)));\n-              }\n-            }\n-        }\n-        fcx.write_ty(pat.id, expected);\n+        tcx.sess.span_fatal\n+            (pat.span,\n+            fmt!(\"mismatched types: expected `%s` but found record\",\n+                 fcx.infcx().ty_to_str(expected)));\n       }\n       ast::pat_struct(path, fields, etc) => {\n         // Grab the class data that we care about."}, {"sha": "b7c4fff801faf2a40e675b870a1e5bc5ed8688d7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -907,9 +907,8 @@ pub impl LookupContext/&self {\n             ty_infer(FloatVar(_)) |\n             ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n-            ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |\n-            ty_struct(*) | ty_tup(*) | ty_estr(*) | ty_evec(*) |\n-            ty_trait(*) | ty_closure(*) => {\n+            ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n+            ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))"}, {"sha": "b5e744fabab74f3da2af9b40d6b2ba8a629615da", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 89, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -606,14 +606,6 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_ty(t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n-        // If this is a record ty, check for duplicate fields\n-        match t.node {\n-            ast::ty_rec(ref fields) => {\n-              check_no_duplicate_fields(ccx.tcx, (*fields).map(|f|\n-                                              (f.node.ident, f.span)));\n-            }\n-            _ => ()\n-        }\n       }\n       ast::item_foreign_mod(m) => {\n         if syntax::attr::foreign_abi(it.attrs) ==\n@@ -1698,22 +1690,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let n_tys = tys.len();\n \n         match structure_of(fcx, expr.span, base_t) {\n-            ty::ty_rec(fields) => {\n-                match ty::field_idx(field, fields) {\n-                    Some(ix) => {\n-                        if n_tys > 0 {\n-                            tcx.sess.span_err(\n-                                expr.span,\n-                                ~\"can't provide type parameters \\\n-                                  to a field access\");\n-                        }\n-                        fcx.write_ty(expr.id, fields[ix].mt.ty);\n-                        fcx.write_autoderef_adjustment(base.id, derefs);\n-                        return bot;\n-                    }\n-                    _ => ()\n-                }\n-            }\n             ty::ty_struct(base_id, ref substs) => {\n                 // This is just for fields -- the same code handles\n                 // methods in both classes and traits\n@@ -2533,71 +2509,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(ref fields, base) => {\n-        for base.each |b| { check_expr_with_opt_hint(fcx, *b, expected); }\n-        let expected = option::or(expected,\n-                                  base.map(|b| fcx.expr_ty(*b)));\n-        let flds = unpack_expected(fcx, expected, |sty|\n-            match *sty {\n-                ty::ty_rec(ref flds) => Some(copy *flds),\n-                _ => None\n-            }\n-        );\n-        let fields_t = fields.map(|f| {\n-            let hint_mt =\n-                flds.chain_ref(\n-                    |flds| vec::find(*flds, |tf| tf.ident == f.node.ident));\n-            let hint = hint_mt.map(|tf| tf.mt.ty);\n-            bot |= check_expr_with_opt_hint(fcx, f.node.expr, hint);\n-            let expr_t = fcx.expr_ty(f.node.expr);\n-            let expr_mt = ty::mt {ty: expr_t, mutbl: f.node.mutbl};\n-            // for the most precise error message,\n-            // should be f.node.expr.span, not f.span\n-            respan(f.node.expr.span, field {ident: f.node.ident, mt: expr_mt})\n-        });\n-        match base {\n-          None => {\n-            fn get_node(f: &spanned<field>) -> field { f.node }\n-            let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n-            fcx.write_ty(id, typ);\n-            /* Check for duplicate fields */\n-            /* Only do this check if there's no base expr -- the reason is\n-               that we're extending a record we know has no dup fields, and\n-               it would be ill-typed anyway if we duplicated one of its\n-               fields */\n-            check_no_duplicate_fields(tcx, (*fields).map(|f|\n-                                                    (f.node.ident, f.span)));\n-          }\n-          Some(bexpr) => {\n-            let bexpr_t = fcx.expr_ty(bexpr);\n-            let base_fields =  match structure_of(fcx, expr.span, bexpr_t) {\n-              ty::ty_rec(flds) => flds,\n-              _ => {\n-                  fcx.type_error_message(expr.span, |_actual| {\n-                      ~\"record update has non-record base\"\n-                  }, bexpr_t, None);\n-                fcx.write_ty(id, ty::mk_err(tcx));\n-                return true;\n-              }\n-            };\n-            fcx.write_ty(id, bexpr_t);\n-            for fields_t.each |f| {\n-                let mut found = false;\n-                for base_fields.each |bf| {\n-                    if f.node.ident == bf.ident {\n-                        demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n-                        found = true;\n-                    }\n-                }\n-                if !found {\n-                    tcx.sess.span_err(f.span,\n-                                        ~\"unknown field in record update: \" +\n-                                        *tcx.sess.str_of(f.node.ident));\n-                    fcx.write_ty(id, ty::mk_err(tcx));\n-                    return true;\n-                }\n-            }\n-          }\n-        }\n+        fail!()\n       }\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path."}, {"sha": "f08cdbe1d41e8d162b783b30513413c07157f7e7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -28,7 +28,7 @@ use middle::ty::{lookup_item_type, param_bounds, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n-use middle::ty::{ty_rec, ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n+use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n use middle::ty::{type_is_ty_var};\n@@ -103,9 +103,8 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         }\n \n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n-        ty_estr(*) | ty_evec(*) | ty_rec(*) |\n-        ty_bare_fn(*) | ty_closure(*) | ty_tup(*) | ty_infer(*) |\n-        ty_param(*) | ty_self | ty_type | ty_opaque_box |\n+        ty_estr(*) | ty_evec(*) | ty_bare_fn(*) | ty_closure(*) | ty_tup(*) |\n+        ty_infer(*) | ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err => {\n             debug!(\"(getting base type) no base type; found %?\",\n                    get(original_type).sty);"}, {"sha": "1f5e9707e2ddd2aabca34f3061916d0482aa88e6", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -546,17 +546,6 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_rec(as_), ty::ty_rec(bs)) => {\n-        if vec::same_length(as_, bs) {\n-            map_vec2(as_, bs, |a,b| {\n-                self.flds(*a, *b)\n-            }).chain(|flds| Ok(ty::mk_rec(tcx, flds)) )\n-        } else {\n-            Err(ty::terr_record_size(expected_found(self, as_.len(),\n-                                                    bs.len())))\n-        }\n-      }\n-\n       (ty::ty_tup(as_), ty::ty_tup(bs)) => {\n         if vec::same_length(as_, bs) {\n             map_vec2(as_, bs, |a, b| self.tys(*a, *b) )"}, {"sha": "7add8dd2dbe0d3d58fae7eb4daf5c958b38c7238", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -22,9 +22,8 @@ use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n-use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n-use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n-use middle::ty::{ty_unboxed_vec};\n+use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n+use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n use metadata::encoder;\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -414,10 +413,6 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_unboxed_vec(tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n       ty_type => ~\"type\",\n-      ty_rec(elems) => {\n-        let strs = elems.map(|fld| field_to_str(cx, *fld));\n-        ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n-      }\n       ty_tup(elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\""}, {"sha": "256e48a69b33548de9560bcfbe36a74796871ee7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -935,7 +935,6 @@ pub enum ty_ {\n     ty_fixed_length_vec(mt, uint),\n     ty_ptr(mt),\n     ty_rptr(@region, mt),\n-    ty_rec(~[ty_field]),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),"}, {"sha": "3fbc1571c1bbbaa20e5df482522e8180c1c55d87", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -613,7 +613,6 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n         ty_vec(ref mt) => ty_vec(fold_mt(mt, fld)),\n         ty_ptr(ref mt) => ty_ptr(fold_mt(mt, fld)),\n         ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, fld)),\n-        ty_rec(ref fields) => ty_rec(fields.map(|f| fold_field(*f, fld))),\n         ty_closure(ref f) => {\n             ty_closure(@TyClosure {\n                 sigil: f.sigil,"}, {"sha": "b159e79a09c6cd5f83cd93311525710eaae518a4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -51,7 +51,7 @@ use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n use ast::{ty_field, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n use ast::{ty_infer, ty_mac, ty_method};\n-use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rec, ty_rptr};\n+use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, type_value_ns, uniq};\n use ast::{unnamed_field, unsafe_blk, unsafe_fn, variant, view_item};\n use ast::{view_item_, view_item_extern_mod, view_item_use};\n@@ -659,7 +659,7 @@ pub impl Parser {\n                 self.unexpected_last(&token::RBRACE);\n             }\n             self.obsolete(*self.last_span, ObsoleteRecordType);\n-            ty_rec(elems)\n+            ty_nil\n         } else if *self.token == token::LBRACKET {\n             self.expect(&token::LBRACKET);\n             let mt = self.parse_mt();"}, {"sha": "1d7d4d0d65f6e5b5b5a48736c4d85f0143a8ea1b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -402,20 +402,6 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n           print_region(s, ~\"&\", region, ~\"/\");\n           print_mt(s, mt);\n       }\n-      ast::ty_rec(ref fields) => {\n-        word(s.s, ~\"{\");\n-        fn print_field(s: @ps, f: ast::ty_field) {\n-            cbox(s, indent_unit);\n-            print_mutability(s, f.node.mt.mutbl);\n-            print_ident(s, f.node.ident);\n-            word_space(s, ~\":\");\n-            print_type(s, f.node.mt.ty);\n-            end(s);\n-        }\n-        fn get_span(f: ast::ty_field) -> codemap::span { return f.span; }\n-        commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n-        word(s.s, ~\",}\");\n-      }\n       ast::ty_tup(elts) => {\n         popen(s);\n         commasep(s, inconsistent, elts, print_type);"}, {"sha": "47fe1b5ba0b20068db94853c85add7c69ef70f34", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3dbfe05257b4f5862e7b57777cba6d179d9cc0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4e3dbfe05257b4f5862e7b57777cba6d179d9cc0", "patch": "@@ -232,11 +232,6 @@ pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n         ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n             (v.visit_ty)(mt.ty, e, v);\n         },\n-        ty_rec(ref flds) => {\n-            for flds.each |f| {\n-                (v.visit_ty)(f.node.mt.ty, e, v);\n-            }\n-        },\n         ty_tup(ref ts) => {\n             for ts.each |tt| {\n                 (v.visit_ty)(*tt, e, v);"}]}