{"sha": "70a9ce626d5faeb9b5de54a9f44043ea46691e31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYTljZTYyNmQ1ZmFlYjliNWRlNTRhOWY0NDA0M2VhNDY2OTFlMzE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-17T22:07:38Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-17T22:15:20Z"}, "message": "Implement slice-borrowing on estr-uniq and str values.", "tree": {"sha": "ad82626104b7abc1ede25369b1314e46ba2886cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad82626104b7abc1ede25369b1314e46ba2886cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70a9ce626d5faeb9b5de54a9f44043ea46691e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70a9ce626d5faeb9b5de54a9f44043ea46691e31", "html_url": "https://github.com/rust-lang/rust/commit/70a9ce626d5faeb9b5de54a9f44043ea46691e31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70a9ce626d5faeb9b5de54a9f44043ea46691e31/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fac7fcc1234aca0969a4a9c6eeddaf21a25b73fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fac7fcc1234aca0969a4a9c6eeddaf21a25b73fe", "html_url": "https://github.com/rust-lang/rust/commit/fac7fcc1234aca0969a4a9c6eeddaf21a25b73fe"}], "stats": {"total": 159, "additions": 95, "deletions": 64}, "files": [{"sha": "568a97947dc3be711347dc83d8f7d9938f09f1b5", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=70a9ce626d5faeb9b5de54a9f44043ea46691e31", "patch": "@@ -810,12 +810,29 @@ impl assignment for infer_ctxt {\n                 let nr_b = ty::mk_uniq(self.tcx, mt_b);\n                 self.crosspolinate(a_node_id, a, nr_b, r_b)\n               }\n+              (ty::ty_estr(vs_a),\n+               ty::ty_estr(ty::vstore_slice(r_b)))\n+              if is_borrowable(vs_a) {\n+                let nr_b = ty::mk_estr(self.tcx, vs_a);\n+                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+              }\n+              (ty::ty_str,\n+               ty::ty_estr(ty::vstore_slice(r_b))) {\n+                let nr_b = ty::mk_str(self.tcx);\n+                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+              }\n+\n               (ty::ty_evec(mt_a, vs_a),\n                ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n               if is_borrowable(vs_a) {\n                 let nr_b = ty::mk_evec(self.tcx, mt_b, vs_a);\n                 self.crosspolinate(a_node_id, a, nr_b, r_b)\n               }\n+              (ty::ty_vec(mt_a),\n+               ty::ty_evec(mt_b, ty::vstore_slice(r_b))) {\n+                let nr_b = ty::mk_vec(self.tcx, mt_b);\n+                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+              }\n               _ {\n                 self.sub_tys(a, b)\n               }"}, {"sha": "a049ae2fde3ffe3161aca0070eea85a1144804e4", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 35, "deletions": 64, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=70a9ce626d5faeb9b5de54a9f44043ea46691e31", "patch": "@@ -2257,6 +2257,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n     ret {bcx: bcx, val: val, kind: owned};\n }\n \n+\n fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n                idx: @ast::expr) -> lval_result {\n     let _icx = cx.insn_ctxt(\"trans_index\");\n@@ -2286,43 +2287,17 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let scaled_ix = Mul(bcx, ix_val, unit_sz);\n     maybe_name_value(cx.ccx(), scaled_ix, \"scaled_ix\");\n \n-    let (lim,  body) = alt ty::get(base_ty).struct {\n-      ty::ty_estr(ty::vstore_fixed(n)) |\n-      ty::ty_evec(_, ty::vstore_fixed(n)) {\n-        // FIXME: support static bounds-check elimination\n-        // and/or error checking here.\n-        let lim = C_uint(bcx.ccx(), n);\n-        let body = GEPi(bcx, v, [0, 0]);\n-        (lim, body)\n-      }\n-\n-      ty::ty_estr(ty::vstore_slice(_)) |\n-      ty::ty_evec(_, ty::vstore_slice(_)) {\n-        let body = Load(bcx, GEPi(bcx, v, [0, abi::slice_elt_base]));\n-        let lim = Load(bcx, GEPi(bcx, v, [0, abi::slice_elt_len]));\n-        (lim, body)\n-      }\n-\n-      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) {\n-        bcx.sess().unimpl(#fmt(\"unsupported evec/estr type trans_index\"));\n-      }\n-\n-      _ {\n-        let lim = tvec::get_fill(bcx, v);\n-        let body = tvec::get_dataptr(bcx, v, type_of(ccx, unit_ty));\n-        (lim, body)\n-      }\n-    };\n+    let (base, len) = tvec::get_base_and_len(bcx, v, base_ty);\n \n-    #debug(\"trans_index: lim %s\", val_str(bcx.ccx().tn, lim));\n-    #debug(\"trans_index: body %s\", val_str(bcx.ccx().tn, body));\n+    #debug(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n+    #debug(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n \n-    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, lim);\n+    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n     let bcx = with_cond(bcx, bounds_check) {|bcx|\n         // fail: bad bounds check.\n         trans_fail(bcx, some(ex.span), \"bounds check\")\n     };\n-    let elt = InBoundsGEP(bcx, body, [ix_val]);\n+    let elt = InBoundsGEP(bcx, base, [ix_val]);\n     ret lval_owned(bcx, PointerCast(bcx, elt, T_ptr(llunitty)));\n }\n \n@@ -2543,6 +2518,7 @@ fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n                   &temp_cleanups: [ValueRef], ret_flag: option<ValueRef>)\n     -> result {\n+    #debug(\"+++ trans_arg_expr on %s\", expr_to_str(e));\n     let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n@@ -2563,6 +2539,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     let lv = adapt_borrowed_value(lv, arg, e);\n     let mut bcx = lv.bcx;\n     let mut val = lv.val;\n+    #debug(\"   adapted value: %s\", val_str(bcx.ccx().tn, val));\n     let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n     if is_bot {\n         // For values of type _|_, we generate an\n@@ -2572,50 +2549,52 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         val = llvm::LLVMGetUndef(lldestty);\n     } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n         let mut copied = false;\n-        let imm = ty::type_is_immediate(e_ty);\n+        let imm = ty::type_is_immediate(arg.ty);\n         if arg_mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n         }\n         if ccx.maps.copy_map.contains_key(e.id) && lv.kind != temporary {\n             if !copied {\n-                let alloc = alloc_ty(bcx, e_ty);\n+                let alloc = alloc_ty(bcx, arg.ty);\n                 bcx = copy_val(bcx, INIT, alloc,\n-                               load_if_immediate(bcx, val, e_ty), e_ty);\n+                               load_if_immediate(bcx, val, arg.ty), arg.ty);\n                 val = alloc;\n-            } else { bcx = take_ty(bcx, val, e_ty); }\n-            add_clean(bcx, val, e_ty);\n+            } else { bcx = take_ty(bcx, val, arg.ty); }\n+            add_clean(bcx, val, arg.ty);\n         }\n         if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n     } else if arg_mode == ast::by_copy || arg_mode == ast::by_move {\n-        let alloc = alloc_ty(bcx, e_ty);\n+        let alloc = alloc_ty(bcx, arg.ty);\n         let move_out = arg_mode == ast::by_move ||\n             ccx.maps.last_uses.contains_key(e.id);\n         if lv.kind == temporary { revoke_clean(bcx, val); }\n-        if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n-            memmove_ty(bcx, alloc, val, e_ty);\n-            if move_out && ty::type_needs_drop(ccx.tcx, e_ty) {\n-                bcx = zero_alloca(bcx, val, e_ty);\n+        if lv.kind == owned || !ty::type_is_immediate(arg.ty) {\n+            memmove_ty(bcx, alloc, val, arg.ty);\n+            if move_out && ty::type_needs_drop(ccx.tcx, arg.ty) {\n+                bcx = zero_alloca(bcx, val, arg.ty);\n             }\n         } else { Store(bcx, val, alloc); }\n         val = alloc;\n         if lv.kind != temporary && !move_out {\n-            bcx = take_ty(bcx, val, e_ty);\n+            bcx = take_ty(bcx, val, arg.ty);\n         }\n \n         // In the event that failure occurs before the call actually\n         // happens, have to cleanup this copy:\n-        add_clean_temp_mem(bcx, val, e_ty);\n+        add_clean_temp_mem(bcx, val, arg.ty);\n         temp_cleanups += [val];\n-    } else if ty::type_is_immediate(e_ty) && lv.kind != owned {\n-        val = do_spill(bcx, val, e_ty);\n+    } else if ty::type_is_immediate(arg.ty) && lv.kind != owned {\n+        val = do_spill(bcx, val, arg.ty);\n     }\n \n     if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n+        #debug(\"    casting from %s\", val_str(bcx.ccx().tn, val));\n         val = PointerCast(bcx, val, lldestty);\n     }\n+    #debug(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n     ret rslt(bcx, val);\n }\n \n@@ -2642,25 +2621,17 @@ fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n         ret lv; // no change needed at runtime (I think)\n       }\n \n-      ty::ty_estr(ty::vstore_box) |\n-      ty::ty_evec(_, ty::vstore_box) {\n-        bcx.tcx().sess.span_unimpl(\n-            e.span, #fmt[\"borrowing a value of type %s\",\n-                         ty_to_str(bcx.tcx(), e_ty)]);\n-      }\n-\n-      ty::ty_estr(ty::vstore_uniq) |\n-      ty::ty_evec(_, ty::vstore_uniq) {\n-        bcx.tcx().sess.span_unimpl(\n-            e.span, #fmt[\"borrowing a value of type %s\",\n-                         ty_to_str(bcx.tcx(), e_ty)]);\n-      }\n-\n-      ty::ty_estr(ty::vstore_fixed(_)) |\n-      ty::ty_evec(_, ty::vstore_fixed(_)) {\n-        bcx.tcx().sess.span_unimpl(\n-            e.span, #fmt[\"borrowing a value of type %s\",\n-                         ty_to_str(bcx.tcx(), e_ty)]);\n+      ty::ty_str | ty::ty_vec(_) |\n+      ty::ty_estr(_) |\n+      ty::ty_evec(_, _) {\n+        let ccx = bcx.ccx();\n+        let unit_ty = ty::sequence_element_type(ccx.tcx, e_ty);\n+        let llunit_ty = type_of(ccx, unit_ty);\n+        let (base, len) = tvec::get_base_and_len(bcx, lv.val, e_ty);\n+        let p = alloca(bcx, T_struct([T_ptr(llunit_ty), ccx.int_type]));\n+        Store(bcx, base, GEPi(bcx, p, [0, abi::slice_elt_base]));\n+        Store(bcx, len, GEPi(bcx, p, [0, abi::slice_elt_len]));\n+        ret lval_temp(bcx, p);\n       }\n \n       _ {"}, {"sha": "d2374b06167b1c36640e1975116b1cbe45e47ea9", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=70a9ce626d5faeb9b5de54a9f44043ea46691e31", "patch": "@@ -145,6 +145,40 @@ fn trans_vstore(bcx: block, e: @ast::expr,\n     }\n }\n \n+fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n+    -> (ValueRef, ValueRef) {\n+\n+    let tcx = cx.ccx().tcx;\n+    let vec_ty = ty::type_autoderef(tcx, e_ty);\n+    let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n+    let vstore = alt ty::get(vec_ty).struct {\n+      ty::ty_estr(vst) | ty::ty_evec(_, vst) { vst }\n+      _ { ty::vstore_uniq }\n+    };\n+\n+    alt vstore {\n+      ty::vstore_fixed(n) {\n+        let base = GEPi(cx, v, [0, 0]);\n+        let len = C_uint(cx.ccx(), n);\n+        (base, len)\n+      }\n+      ty::vstore_slice(_) {\n+        let base = Load(cx, GEPi(cx, v, [0, abi::slice_elt_base]));\n+        let len = Load(cx, GEPi(cx, v, [0, abi::slice_elt_len]));\n+        (base, len)\n+      }\n+      ty::vstore_uniq {\n+        let base = tvec::get_dataptr(cx, v,\n+                                     type_of::type_of(cx.ccx(), unit_ty));\n+        let len = tvec::get_fill(cx, v);\n+        (base, len)\n+      }\n+      ty::vstore_box {\n+        cx.ccx().sess.unimpl(\"unhandled tvec::get_base_and_len\");\n+      }\n+    }\n+}\n+\n fn trans_estr(bcx: block, s: str, vstore: ast::vstore,\n               dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");"}, {"sha": "2794a03f5ffb78a01606cfd2d9ef8b5ec28d64f7", "filename": "src/test/run-pass/regions-borrow-estr-uniq.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Ftest%2Frun-pass%2Fregions-borrow-estr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a9ce626d5faeb9b5de54a9f44043ea46691e31/src%2Ftest%2Frun-pass%2Fregions-borrow-estr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-estr-uniq.rs?ref=70a9ce626d5faeb9b5de54a9f44043ea46691e31", "patch": "@@ -0,0 +1,9 @@\n+fn foo(x: str/&) -> u8 {\n+    x[0]\n+}\n+\n+fn main() {\n+    let p = \"hello\"/~;\n+    let r = foo(p);\n+    assert r == 'h' as u8;\n+}"}]}