{"sha": "32502404e5ed78b927cc9807eac0cf6cd3623450", "node_id": "C_kwDOAAsO6NoAKDMyNTAyNDA0ZTVlZDc4YjkyN2NjOTgwN2VhYzBjZjZjZDM2MjM0NTA", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-10-08T20:30:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-08T20:30:38Z"}, "message": "Rollup merge of #86506 - b-naber:gen_trait_impl_inconsistent, r=jackh726\n\nDon't normalize xform_ret_ty during method candidate assembly\n\nFixes https://github.com/rust-lang/rust/issues/85671\n\nNormalizing the return type of a method candidate together with the expected receiver type of the method can lead to valid method candidates being rejected during probing. Specifically in the example of the fixed issue we have a `self_ty` of the form `&A<&[Coef]>` whereas the `impl_ty` of the method would be `&A<_>`, if we normalize the projection in the return type we unify the inference variable with `Cont`, which will lead us to reject the candidate in the sup type check in `consider_probe`. Since we don't actually need the normalized return type during candidate assembly, we postpone the normalization until we consider candidates in `consider_probe`.", "tree": {"sha": "b30def107f10609fe81c12f2ad5911446f5b1c72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b30def107f10609fe81c12f2ad5911446f5b1c72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32502404e5ed78b927cc9807eac0cf6cd3623450", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhYKpvCRBK7hj4Ov3rIwAA+44IAD06eUJF8MJ01VHo3M00an3R\nyW/mnTy5PIUAl0VaQox2fPDF5iSWXzLu5+sdjGrrjdufpfg3F90kJa5J2LjVD2fN\nLfmio0TBOm7QzXsF0Iqh0Wz3boaBBZVgBXvcXiqm/UVOKUzcnUrUkqnI/z3qIPij\nWFw43HDCYWLR0Me+zsif46RRERrZUDuoe01aRyAlNWvrDGqHzMLX1Zd5eBfbLlEY\nu9/RlmoSr98AKZTCfFQ4w4fBQvwvp13vysHlxDg4wrLzABvTGaXiph4WjpiRI0BK\nLUt+bKkZ/J3gQJ/4cqBuLTH0g84/CkzE7FVGUqOD4wfPs9gU3/tPe0POTjG7h1Y=\n=raJI\n-----END PGP SIGNATURE-----\n", "payload": "tree b30def107f10609fe81c12f2ad5911446f5b1c72\nparent 87df4dd70f13f248a4d2d22cdd96ee59d161d741\nparent 3215403dde605b310826d8985261d8eeed3ea983\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1633725038 +0200\ncommitter GitHub <noreply@github.com> 1633725038 +0200\n\nRollup merge of #86506 - b-naber:gen_trait_impl_inconsistent, r=jackh726\n\nDon't normalize xform_ret_ty during method candidate assembly\n\nFixes https://github.com/rust-lang/rust/issues/85671\n\nNormalizing the return type of a method candidate together with the expected receiver type of the method can lead to valid method candidates being rejected during probing. Specifically in the example of the fixed issue we have a `self_ty` of the form `&A<&[Coef]>` whereas the `impl_ty` of the method would be `&A<_>`, if we normalize the projection in the return type we unify the inference variable with `Cont`, which will lead us to reject the candidate in the sup type check in `consider_probe`. Since we don't actually need the normalized return type during candidate assembly, we postpone the normalization until we consider candidates in `consider_probe`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32502404e5ed78b927cc9807eac0cf6cd3623450", "html_url": "https://github.com/rust-lang/rust/commit/32502404e5ed78b927cc9807eac0cf6cd3623450", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32502404e5ed78b927cc9807eac0cf6cd3623450/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87df4dd70f13f248a4d2d22cdd96ee59d161d741", "url": "https://api.github.com/repos/rust-lang/rust/commits/87df4dd70f13f248a4d2d22cdd96ee59d161d741", "html_url": "https://github.com/rust-lang/rust/commit/87df4dd70f13f248a4d2d22cdd96ee59d161d741"}, {"sha": "3215403dde605b310826d8985261d8eeed3ea983", "url": "https://api.github.com/repos/rust-lang/rust/commits/3215403dde605b310826d8985261d8eeed3ea983", "html_url": "https://github.com/rust-lang/rust/commit/3215403dde605b310826d8985261d8eeed3ea983"}], "stats": {"total": 88, "additions": 74, "deletions": 14}, "files": [{"sha": "6eeb28e32f1e996b99432b3b2016d8e9881d0c25", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/32502404e5ed78b927cc9807eac0cf6cd3623450/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32502404e5ed78b927cc9807eac0cf6cd3623450/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=32502404e5ed78b927cc9807eac0cf6cd3623450", "patch": "@@ -753,17 +753,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n             let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n+            debug!(\"impl_ty: {:?}\", impl_ty);\n+\n             // Determine the receiver type that the method itself expects.\n-            let xform_tys = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            debug!(\"xform_self_ty: {:?}, xform_ret_ty: {:?}\", xform_self_ty, xform_ret_ty);\n \n             // We can't use normalize_associated_types_in as it will pollute the\n             // fcx's fulfillment context after this probe is over.\n+            // Note: we only normalize `xform_self_ty` here since the normalization\n+            // of the return type can lead to inference results that prohibit\n+            // valid canidates from being found, see issue #85671\n+            // FIXME Postponing the normalization of the return type likely only hides a deeper bug,\n+            // which might be caused by the `param_env` itself. The clauses of the `param_env`\n+            // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n+            // see isssue #89650\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: (xform_self_ty, xform_ret_ty), obligations } =\n-                traits::normalize(selcx, self.param_env, cause, xform_tys);\n+            let traits::Normalized { value: xform_self_ty, obligations } =\n+                traits::normalize(selcx, self.param_env, cause, xform_self_ty);\n             debug!(\n-                \"assemble_inherent_impl_probe: xform_self_ty = {:?}/{:?}\",\n+                \"assemble_inherent_impl_probe after normalization: xform_self_ty = {:?}/{:?}\",\n                 xform_self_ty, xform_ret_ty\n             );\n \n@@ -1420,6 +1430,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             };\n \n             let mut result = ProbeResult::Match;\n+            let mut xform_ret_ty = probe.xform_ret_ty;\n+            debug!(?xform_ret_ty);\n+\n             let selcx = &mut traits::SelectionContext::new(self);\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n@@ -1428,7 +1441,17 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n             match probe.kind {\n-                InherentImplCandidate(substs, ref ref_obligations) => {\n+                InherentImplCandidate(ref substs, ref ref_obligations) => {\n+                    // `xform_ret_ty` hasn't been normalized yet, only `xform_self_ty`,\n+                    // see the reasons mentioned in the comments in `assemble_inherent_impl_probe`\n+                    // for why this is necessary\n+                    let traits::Normalized {\n+                        value: normalized_xform_ret_ty,\n+                        obligations: normalization_obligations,\n+                    } = traits::normalize(selcx, self.param_env, cause.clone(), probe.xform_ret_ty);\n+                    xform_ret_ty = normalized_xform_ret_ty;\n+                    debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n+\n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container.id();\n                     let impl_bounds = self.tcx.predicates_of(impl_def_id);\n@@ -1442,7 +1465,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     let candidate_obligations = impl_obligations\n                         .chain(norm_obligations.into_iter())\n-                        .chain(ref_obligations.iter().cloned());\n+                        .chain(ref_obligations.iter().cloned())\n+                        .chain(normalization_obligations.into_iter());\n+\n                     // Evaluate those obligations to see if they might possibly hold.\n                     for o in candidate_obligations {\n                         let o = self.resolve_vars_if_possible(o);\n@@ -1527,9 +1552,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n \n             if let ProbeResult::Match = result {\n-                if let (Some(return_ty), Some(xform_ret_ty)) =\n-                    (self.return_type, probe.xform_ret_ty)\n-                {\n+                if let (Some(return_ty), Some(xform_ret_ty)) = (self.return_type, xform_ret_ty) {\n                     let xform_ret_ty = self.resolve_vars_if_possible(xform_ret_ty);\n                     debug!(\n                         \"comparing return_ty {:?} with xform ret ty {:?}\",\n@@ -1669,6 +1692,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.static_candidates.push(source);\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn xform_self_ty(\n         &self,\n         item: &ty::AssocItem,\n@@ -1683,9 +1707,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn xform_method_sig(&self, method: DefId, substs: SubstsRef<'tcx>) -> ty::FnSig<'tcx> {\n         let fn_sig = self.tcx.fn_sig(method);\n-        debug!(\"xform_self_ty(fn_sig={:?}, substs={:?})\", fn_sig, substs);\n+        debug!(?fn_sig);\n \n         assert!(!substs.has_escaping_bound_vars());\n "}, {"sha": "ce8173169b1b3aa2f25510f9b06824d299442e78", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr?ref=32502404e5ed78b927cc9807eac0cf6cd3623450", "patch": "@@ -6,7 +6,6 @@ LL |     let _result = &Some(42).as_deref();\n    |\n    = note: the following trait bounds were not satisfied:\n            `{integer}: Deref`\n-           `<{integer} as Deref>::Target = _`\n \n error: aborting due to previous error\n "}, {"sha": "e4e9705b07db5e59cf61369e83427b85590f279c", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref_mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr?ref=32502404e5ed78b927cc9807eac0cf6cd3623450", "patch": "@@ -6,7 +6,7 @@ LL |     let _result = &mut Some(42).as_deref_mut();\n    |\n    = note: the following trait bounds were not satisfied:\n            `{integer}: DerefMut`\n-           `<{integer} as Deref>::Target = _`\n+           `{integer}: Deref`\n \n error: aborting due to previous error\n "}, {"sha": "a3b9ac6775805243dd4a23147146762d6907fac9", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr?ref=32502404e5ed78b927cc9807eac0cf6cd3623450", "patch": "@@ -6,7 +6,6 @@ LL |     let _result = &Ok(42).as_deref();\n    |\n    = note: the following trait bounds were not satisfied:\n            `{integer}: Deref`\n-           `<{integer} as Deref>::Target = _`\n \n error: aborting due to previous error\n "}, {"sha": "98a7091dd0583c8a0f27efae8e7ecac5483e59e8", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr?ref=32502404e5ed78b927cc9807eac0cf6cd3623450", "patch": "@@ -6,7 +6,7 @@ LL |     let _result = &mut Ok(42).as_deref_mut();\n    |\n    = note: the following trait bounds were not satisfied:\n            `{integer}: DerefMut`\n-           `<{integer} as Deref>::Target = _`\n+           `{integer}: Deref`\n \n error: aborting due to previous error\n "}, {"sha": "337ec307ef3261ea57afc3c4f45dee857cee263a", "filename": "src/test/ui/resolve/issue-85671.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fresolve%2Fissue-85671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32502404e5ed78b927cc9807eac0cf6cd3623450/src%2Ftest%2Fui%2Fresolve%2Fissue-85671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-85671.rs?ref=32502404e5ed78b927cc9807eac0cf6cd3623450", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+\n+// Some trait with a function that returns a slice:\n+pub trait AsSlice {\n+    type Element;\n+    fn as_slice(&self) -> &[Self::Element];\n+}\n+\n+// Some type\n+pub struct A<Cont>(Cont);\n+\n+// Here we say that if A wraps a slice, then it implements AsSlice\n+impl<'a, Element> AsSlice for A<&'a [Element]> {\n+    type Element = Element;\n+    fn as_slice(&self) -> &[Self::Element] {\n+        self.0\n+    }\n+}\n+\n+impl<Cont> A<Cont> {\n+    // We want this function to work\n+    pub fn failing<Coef>(&self)\n+    where\n+        Self: AsSlice<Element = Coef>,\n+    {\n+        self.as_ref_a().as_ref_a();\n+    }\n+\n+    pub fn as_ref_a<Coef>(&self) -> A<&[<Self as AsSlice>::Element]>\n+    where\n+        Self: AsSlice<Element = Coef>,\n+    {\n+        A(self.as_slice())\n+    }\n+}\n+\n+fn main() {}"}]}