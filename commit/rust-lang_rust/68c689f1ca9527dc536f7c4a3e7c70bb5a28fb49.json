{"sha": "68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YzY4OWYxY2E5NTI3ZGM1MzZmN2M0YTNlN2M3MGJiNWEyOGZiNDk=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T05:35:35Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T06:14:26Z"}, "message": "Convert @[BigDigit] to ~[BigDigit]", "tree": {"sha": "c297d5afa102ba94199183b51d4b6bea6b053813", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c297d5afa102ba94199183b51d4b6bea6b053813"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "html_url": "https://github.com/rust-lang/rust/commit/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54b548795f603bb790853ff6dd0190dc3f32b7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/54b548795f603bb790853ff6dd0190dc3f32b7b9", "html_url": "https://github.com/rust-lang/rust/commit/54b548795f603bb790853ff6dd0190dc3f32b7b9"}], "stats": {"total": 533, "additions": 254, "deletions": 279}, "files": [{"sha": "515e7a2cac805ce60f5bb6175f15c914d151dd73", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 254, "deletions": 279, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "patch": "@@ -59,7 +59,7 @@ A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n (a + b * BigDigit::base + c * BigDigit::base^2).\n */\n pub struct BigUint {\n-    priv data: @[BigDigit]\n+    priv data: ~[BigDigit]\n }\n \n impl BigUint : Eq {\n@@ -101,19 +101,19 @@ impl BigUint : Shr<uint, BigUint> {\n }\n \n impl BigUint : Zero {\n-    static pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n+    static pure fn zero() -> BigUint { BigUint::new(~[]) }\n }\n \n impl BigUint : One {\n-    static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n+    static pub pure fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl BigUint : Num {\n     pure fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n-        let sum = do at_vec::from_fn(new_len) |i| {\n+        let sum = do vec::from_fn(new_len) |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -122,15 +122,15 @@ impl BigUint : Num {\n             carry = hi;\n             lo\n         };\n-        if carry == 0 { return BigUint::from_at_vec(sum) };\n-        return BigUint::from_at_vec(sum + [carry]);\n+        if carry == 0 { return BigUint::new(sum) };\n+        return BigUint::new(sum + [carry]);\n     }\n \n     pure fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n-        let diff = do at_vec::from_fn(new_len) |i| {\n+        let diff = do vec::from_fn(new_len) |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -146,7 +146,7 @@ impl BigUint : Num {\n         };\n \n         assert borrow == 0;     // <=> assert (self >= other);\n-        return BigUint::from_at_vec(diff);\n+        return BigUint::new(diff);\n     }\n \n     pure fn mul(&self, other: &BigUint) -> BigUint {\n@@ -167,28 +167,34 @@ impl BigUint : Num {\n \n         let ll = sLo * oLo;\n         let hh = sHi * oHi;\n-        let mm =  match (sub_sign(sHi, sLo), sub_sign(oHi, oLo)) {\n-            ((s1, n1), (s2, n2)) if s1 * s2 < 0 => hh + ll + (n1 * n2),\n-            ((s1, n1), (s2, n2)) if s1 * s2 > 0 => hh + ll - (n1 * n2),\n-            _   => hh + ll,\n+        let mm = {\n+            let (s1, n1) = sub_sign(sHi, sLo);\n+            let (s2, n2) = sub_sign(oHi, oLo);\n+            if s1 * s2 < 0 {\n+                hh + ll + (n1 * n2)\n+            } else if s1 * s2 > 0 {\n+                hh + ll - (n1 * n2)\n+            } else {\n+                hh + ll\n+            }\n         };\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n         pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n-            if n == 1 { return *a; }\n+            if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do at_vec::map(a.data) |ai| {\n+            let prod = do vec::map(a.data) |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n             };\n-            if carry == 0 { return BigUint::from_at_vec(prod) };\n-            return BigUint::from_at_vec(prod + [carry]);\n+            if carry == 0 { return BigUint::new(prod) };\n+            return BigUint::new(prod + [carry]);\n         }\n \n         pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n@@ -206,11 +212,13 @@ impl BigUint : Num {\n         }\n     }\n \n-    pure fn div(&self, other: &BigUint) -> BigUint{\n-        self.divmod(other).first()\n+    pure fn div(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.divmod(other);\n+        return d;\n     }\n     pure fn modulo(&self, other: &BigUint) -> BigUint {\n-        self.divmod(other).second()\n+        let (_, m) = self.divmod(other);\n+        return m;\n     }\n \n     pure fn neg(&self) -> BigUint { fail }\n@@ -225,32 +233,29 @@ impl BigUint : Num {\n }\n \n pub impl BigUint {\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn new(v: ~[BigDigit]) -> BigUint {\n+        // omit trailing zeros\n+        let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n+\n+        if new_len == v.len() { return BigUint { data: v }; }\n+        let mut v = v;\n+        unsafe { v.truncate(new_len); }\n+        return BigUint { data: v };\n+    }\n+\n     /// Creates and initializes an BigUint.\n     static pub pure fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n-            (0,  n0) => BigUint::from_at_vec(@[n0]),\n-            (n1, n0) => BigUint::from_at_vec(@[n0, n1])\n+            (0,  n0) => BigUint::new(~[n0]),\n+            (n1, n0) => BigUint::new(~[n0, n1])\n         }\n     }\n \n     /// Creates and initializes an BigUint.\n     static pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        // omit trailing zeros\n-        let new_len = slice.rposition(|n| *n != 0)\n-            .map_default(0, |p| *p + 1);\n-\n-        return BigUint { data: at_vec::from_fn(new_len, |i| slice[i]) };\n-    }\n-\n-    /// Creates and initializes an BigUint.\n-    static pub pure fn from_at_vec(at_vec: @[BigDigit]) -> BigUint {\n-        // omit trailing zeros\n-        let new_len = at_vec.rposition(|n| *n != 0)\n-            .map_default(0, |p| *p + 1);\n-\n-        if new_len == at_vec.len() { return BigUint { data: at_vec }; }\n-        return BigUint { data: at_vec::from_fn(new_len, |i| at_vec[i]) };\n+        return BigUint::new(vec::from_slice(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n@@ -282,7 +287,7 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn abs(&self) -> BigUint { *self }\n+    pure fn abs(&self) -> BigUint { copy *self }\n \n     /// Compare two BigUint value.\n     pure fn cmp(&self, other: &BigUint) -> int {\n@@ -303,10 +308,10 @@ pub impl BigUint {\n     pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n-        if *other == One::one() { return (*self, Zero::zero()); }\n+        if *other == One::one() { return (copy *self, Zero::zero()); }\n \n         match self.cmp(other) {\n-            s if s < 0 => return (Zero::zero(), *self),\n+            s if s < 0 => return (Zero::zero(), copy *self),\n             0          => return (One::one(), Zero::zero()),\n             _          => {} // Do nothing\n         }\n@@ -321,13 +326,12 @@ pub impl BigUint {\n         let (d, m) = divmod_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n-\n         pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut r = a;\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n             while r >= b {\n-                let mut (d0, d_unit, b_unit) = div_estimate(r, b, n);\n+                let mut (d0, d_unit, b_unit) = div_estimate(&r, &b, n);\n                 let mut prod = b * d0;\n                 while prod > r {\n                     d0   -= d_unit;\n@@ -344,10 +348,10 @@ pub impl BigUint {\n             return (d, r);\n         }\n \n-        pure fn div_estimate(a: BigUint, b: BigUint, n: uint)\n+        pure fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n-                return (Zero::zero(), Zero::zero(), a);\n+                return (Zero::zero(), Zero::zero(), copy *a);\n             }\n \n             let an = vec::view(a.data, a.data.len() - n, a.data.len());\n@@ -363,17 +367,22 @@ pub impl BigUint {\n             }\n \n             let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n+            if shift == 0 {\n+                return (BigUint::new(d), One::one(), copy *b);\n+            }\n             return (BigUint::from_slice(d).shl_unit(shift),\n                     One::one::<BigUint>().shl_unit(shift),\n                     b.shl_unit(shift));\n         }\n     }\n \n     pure fn quot(&self, other: &BigUint) -> BigUint {\n-        self.quotrem(other).first()\n+        let (q, _) = self.quotrem(other);\n+        return q;\n     }\n     pure fn rem(&self, other: &BigUint) -> BigUint {\n-        self.quotrem(other).second()\n+        let (_, r) = self.quotrem(other);\n+        return r;\n     }\n     pure fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.divmod(other)\n@@ -397,12 +406,16 @@ pub impl BigUint {\n \n     pure fn to_str_radix(&self, radix: uint) -> ~str {\n         assert 1 < radix && radix <= 16;\n+        let (base, max_len) = get_radix_base(radix);\n+        if base == BigDigit::base {\n+            return fill_concat(self.data, radix, max_len)\n+        }\n+        return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n-        pure fn convert_base(n: &BigUint, base: uint) -> @[BigDigit] {\n-            if base == BigDigit::base { return n.data; }\n+        pure fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n-            let mut result = @[];\n-            let mut r      = *n;\n+            let mut result = ~[];\n+            let mut r      = n;\n             while r > divider {\n                 let (d, r0) = r.divmod(&divider);\n                 result += [r0.to_uint() as BigDigit];\n@@ -421,52 +434,47 @@ pub impl BigUint {\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n             })), ['0'])\n         }\n-\n-        let (base, max_len) = get_radix_base(radix);\n-        return fill_concat(convert_base(self, base), radix, max_len);\n     }\n \n-    priv pure fn shl_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return *self; }\n+    priv pure fn shl_unit(self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return self; }\n \n-        return BigUint::from_at_vec(at_vec::from_elem(n_unit, 0) + self.data);\n+        return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n-    priv pure fn shl_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return *self; }\n+    priv pure fn shl_bits(self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return self; }\n \n         let mut carry = 0;\n-        let shifted = do at_vec::map(self.data) |elem| {\n+        let shifted = do vec::map(self.data) |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n         };\n-        if carry == 0 { return BigUint::from_at_vec(shifted); }\n-        return BigUint::from_at_vec(shifted + [carry]);\n+        if carry == 0 { return BigUint::new(shifted); }\n+        return BigUint::new(shifted + [carry]);\n     }\n \n-    priv pure fn shr_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return *self; }\n+    priv pure fn shr_unit(self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             vec::view(self.data, n_unit, self.data.len())\n         );\n     }\n \n-    priv pure fn shr_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return *self; }\n+    priv pure fn shr_bits(self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return self; }\n \n         let mut borrow = 0;\n-        let mut shifted = @[];\n+        let mut shifted = ~[];\n         for vec::rev_each(self.data) |elem| {\n-            // internal compiler error: no enclosing scope with id 10671\n-            // shifted = @[(*elem >> n_bits) | borrow] + shifted;\n-            shifted = at_vec::append(@[(*elem >> n_bits) | borrow], shifted);\n+            shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n             borrow = *elem << (uint::bits - n_bits);\n         }\n-        return BigUint::from_at_vec(shifted);\n+        return BigUint::new(shifted);\n     }\n }\n \n@@ -582,8 +590,8 @@ impl BigInt : One {\n impl BigInt : Num {\n     pure fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)      => *other,\n-            (_,    Zero)   => *self,\n+            (Zero, _)      => copy *other,\n+            (_,    Zero)   => copy *self,\n             (Plus, Plus)   => BigInt::from_biguint(Plus,\n                                                    self.data + other.data),\n             (Plus, Minus)  => self - (-*other),\n@@ -594,7 +602,7 @@ impl BigInt : Num {\n     pure fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n-            (_,    Zero) => *self,\n+            (_,    Zero) => copy *self,\n             (Plus, Plus) => match self.data.cmp(&other.data) {\n                 s if s < 0 =>\n                     BigInt::from_biguint(Minus, other.data - self.data),\n@@ -620,13 +628,15 @@ impl BigInt : Num {\n         }\n     }\n     pure fn div(&self, other: &BigInt) -> BigInt {\n-        self.divmod(other).first()\n+        let (d, _) = self.divmod(other);\n+        return d;\n     }\n     pure fn modulo(&self, other: &BigInt) -> BigInt {\n-        self.divmod(other).second()\n+        let (_, m) = self.divmod(other);\n+        return m;\n     }\n     pure fn neg(&self) -> BigInt {\n-        BigInt::from_biguint(self.sign.neg(), self.data)\n+        BigInt::from_biguint(self.sign.neg(), copy self.data)\n     }\n \n     pure fn to_int(&self) -> int {\n@@ -652,6 +662,11 @@ impl BigInt : Num {\n }\n \n pub impl BigInt {\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::new(v))\n+    }\n+\n     /// Creates and initializes an BigInt.\n     static pub pure fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n@@ -671,12 +686,6 @@ pub impl BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n-    /// Creates and initializes an BigInt.\n-    static pub pure fn from_at_vec(sign: Sign, at_vec: @[BigDigit])\n-        -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::from_at_vec(at_vec))\n-    }\n-\n     /// Creates and initializes an BigInt.\n     static pub pure fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n@@ -697,7 +706,9 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n-    pure fn abs(&self) -> BigInt { BigInt::from_biguint(Plus, self.data) }\n+    pure fn abs(&self) -> BigInt {\n+        BigInt::from_biguint(Plus, copy self.data)\n+    }\n \n     pure fn cmp(&self, other: &BigInt) -> int {\n         let ss = self.sign, os = other.sign;\n@@ -735,10 +746,12 @@ pub impl BigInt {\n     }\n \n     pure fn quot(&self, other: &BigInt) -> BigInt {\n-        self.quotrem(other).first()\n+        let (q, _) = self.quotrem(other);\n+        return q;\n     }\n     pure fn rem(&self, other: &BigInt) -> BigInt {\n-        self.quotrem(other).second()\n+        let (_, r) = self.quotrem(other);\n+        return r;\n     }\n \n     pure fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n@@ -783,16 +796,15 @@ pub impl BigInt {\n mod biguint_tests {\n     #[test]\n     fn test_from_slice() {\n-        let pairs = [\n-            (&[1],                &[1]),\n-            (&[0, 0],             &[]),\n-            (&[1, 2, 0, 0],       &[1, 2]),\n-            (&[0, 0, 1, 2, 0, 0], &[0, 0, 1, 2]),\n-            (&[-1],               &[-1])\n-        ];\n-        for pairs.each |p| {\n-            assert p.second() == BigUint::from_slice(p.first()).data;\n+        fn check(slice: &[BigDigit], data: &[BigDigit]) {\n+            assert data == BigUint::from_slice(slice).data;\n         }\n+        check(~[1], ~[1]);\n+        check(~[0, 0, 0], ~[]);\n+        check(~[1, 2, 0, 0], ~[1, 2]);\n+        check(~[0, 0, 1, 2], ~[0, 0, 1, 2]);\n+        check(~[0, 0, 1, 2, 0, 0], ~[0, 0, 1, 2]);\n+        check(~[-1], ~[-1]);\n     }\n \n     #[test]\n@@ -834,99 +846,76 @@ mod biguint_tests {\n \n     #[test]\n     fn test_shl() {\n-        assert BigUint::from_at_vec(@[]) << 3 == BigUint::from_at_vec(@[]);\n-        assert BigUint::from_at_vec(@[1, 1, 1]) << 3 ==\n-            BigUint::from_at_vec(@[1 << 3, 1 << 3, 1 << 3]);\n-\n-        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 2 ==\n-            BigUint::from_at_vec(@[0, 1]);\n-        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 3 ==\n-            BigUint::from_at_vec(@[0, 2]);\n-        assert (BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)])\n-                << (3 + BigDigit::bits)) ==\n-            BigUint::from_at_vec(@[0, 0, 2]);\n-\n-        assert BigUint::from_at_vec(\n-            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n-        ) << 4 == BigUint::from_at_vec(\n-            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n-        );\n-        assert BigUint::from_at_vec(\n-            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n-        ) << 16 == BigUint::from_at_vec(\n-                @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n-            );\n+        fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n+            assert BigUint::new(v) << shift == BigUint::new(ans);\n+        }\n+\n+        check(~[], 3, ~[]);\n+        check(~[1, 1, 1], 3, ~[1 << 3, 1 << 3, 1 << 3]);\n+        check(~[1 << (BigDigit::bits - 2)], 2, ~[0, 1]);\n+        check(~[1 << (BigDigit::bits - 2)], 3, ~[0, 2]);\n+        check(~[1 << (BigDigit::bits - 2)], 3 + BigDigit::bits, ~[0, 0, 2]);\n+        check(~[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98], 4,\n+              ~[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]);\n+        check(~[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777], 16,\n+              ~[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]);\n     }\n \n     #[test]\n     fn test_shr() {\n-        assert BigUint::from_at_vec(@[]) >> 3 == BigUint::from_at_vec(@[]);\n-        assert BigUint::from_at_vec(@[1, 1, 1]) >> 3 == BigUint::from_at_vec(\n-            @[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]\n-        );\n-\n-        assert BigUint::from_at_vec(@[1 << 2]) >> 2 ==\n-            BigUint::from_at_vec(@[1]);\n-        assert BigUint::from_at_vec(@[1, 2]) >> 3 ==\n-            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n-        assert BigUint::from_at_vec(@[1, 1, 2]) >> (3 + BigDigit::bits) ==\n-            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n-\n-        assert BigUint::from_at_vec(\n-            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n-        ) >> 4 == BigUint::from_at_vec(\n-            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n-        );\n+        fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n+            assert BigUint::new(v) >> shift == BigUint::new(ans);\n+        }\n \n-        assert BigUint::from_at_vec(\n-            @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n-        ) >> 16 == BigUint::from_at_vec(\n-            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n-        );\n+        check(~[], 3, ~[]);\n+        check(~[1, 1, 1], 3,\n+              ~[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]);\n+        check(~[1 << 2], 2, ~[1]);\n+        check(~[1, 2], 3, ~[1 << (BigDigit::bits - 2)]);\n+        check(~[1, 1, 2], 3 + BigDigit::bits, ~[1 << (BigDigit::bits - 2)]);\n+        check(~[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf], 4,\n+              ~[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]);\n+        check(~[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888],\n+              16,\n+              ~[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]);\n     }\n \n     #[test]\n     fn test_convert_int() {\n-        fn check_conv(b: BigUint, i: int) {\n+        fn check(v: ~[BigDigit], i: int) {\n+            let b = BigUint::new(v);\n             assert b == Num::from_int(i);\n             assert b.to_int() == i;\n         }\n \n-        check_conv(Zero::zero(), 0);\n-        check_conv(BigUint::from_at_vec(@[1]), 1);\n-\n-        check_conv(BigUint::from_at_vec(@[-1]),\n-                   (uint::max_value >> BigDigit::bits) as int);\n-        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n-                   ((uint::max_value >> BigDigit::bits) + 1) as int);\n-        check_conv(BigUint::from_at_vec(@[-1, -1 >> 1]),\n-                   int::max_value);\n+        check(~[], 0);\n+        check(~[1], 1);\n+        check(~[-1], (uint::max_value >> BigDigit::bits) as int);\n+        check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n+        check(~[-1, -1 >> 1], int::max_value);\n \n-        assert BigUint::from_at_vec(@[0, -1]).to_int() == int::max_value;\n-        assert BigUint::from_at_vec(@[0, 0, 1]).to_int() == int::max_value;\n-        assert BigUint::from_at_vec(@[0, 0, -1]).to_int() == int::max_value;\n+        assert BigUint::new(~[0, -1]).to_int() == int::max_value;\n+        assert BigUint::new(~[0, 0, 1]).to_int() == int::max_value;\n+        assert BigUint::new(~[0, 0, -1]).to_int() == int::max_value;\n     }\n \n     #[test]\n     fn test_convert_uint() {\n-        fn check_conv(b: BigUint, u: uint) {\n+        fn check(v: ~[BigDigit], u: uint) {\n+            let b = BigUint::new(v);\n             assert b == BigUint::from_uint(u);\n             assert b.to_uint() == u;\n         }\n \n-        check_conv(Zero::zero(), 0);\n-        check_conv(BigUint::from_at_vec(@[ 1]), 1);\n-        check_conv(BigUint::from_at_vec(@[-1]),\n-                   uint::max_value >> BigDigit::bits);\n-        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n-                   (uint::max_value >> BigDigit::bits) + 1);\n-        check_conv(BigUint::from_at_vec(@[ 0, -1]),\n-                   uint::max_value << BigDigit::bits);\n-        check_conv(BigUint::from_at_vec(@[-1, -1]),\n-                   uint::max_value);\n+        check(~[], 0);\n+        check(~[ 1], 1);\n+        check(~[-1], uint::max_value >> BigDigit::bits);\n+        check(~[ 0,  1], (uint::max_value >> BigDigit::bits) + 1);\n+        check(~[ 0, -1], uint::max_value << BigDigit::bits);\n+        check(~[-1, -1], uint::max_value);\n \n-        assert BigUint::from_at_vec(@[0, 0, 1]).to_uint()  == uint::max_value;\n-        assert BigUint::from_at_vec(@[0, 0, -1]).to_uint() == uint::max_value;\n+        assert BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value;\n+        assert BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value;\n     }\n \n     const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n@@ -1127,37 +1116,43 @@ mod biguint_tests {\n             return f;\n         }\n \n-        assert factor(3) == BigUint::from_str_radix(~\"6\", 10).get();\n-        assert factor(10) == BigUint::from_str_radix(~\"3628800\", 10).get();\n-        assert factor(20) == BigUint::from_str_radix(\n-            ~\"2432902008176640000\", 10).get();\n-        assert factor(30) == BigUint::from_str_radix(\n-            ~\"265252859812191058636308480000000\", 10).get();\n+        fn check(n: uint, s: &str) {\n+            let n = factor(n);\n+            let ans = match BigUint::from_str_radix(s, 10) {\n+                Some(x) => x, None => fail\n+            };\n+            assert n == ans;\n+        }\n+\n+        check(3, \"6\");\n+        check(10, \"3628800\");\n+        check(20, \"2432902008176640000\");\n+        check(30, \"265252859812191058636308480000000\");\n     }\n }\n \n #[cfg(test)]\n mod bigint_tests {\n     #[test]\n     fn test_from_biguint() {\n-        assert BigInt::from_biguint(Plus, BigUint::from_uint(1)) ==\n-            BigInt { sign: Plus, data: BigUint::from_uint(1) };\n-        assert BigInt::from_biguint(Plus, Zero::zero()) ==\n-            BigInt { sign: Zero, data: Zero::zero() };\n-        assert BigInt::from_biguint(Minus, BigUint::from_uint(1)) ==\n-            BigInt { sign: Minus, data: BigUint::from_uint(1) };\n-        assert BigInt::from_biguint(Zero, BigUint::from_uint(1)) ==\n-            BigInt { sign: Zero, data: Zero::zero() };\n+        fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n+            let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n+            let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n+            assert inp == ans;\n+        }\n+        check(Plus, 1, Plus, 1);\n+        check(Plus, 0, Zero, 0);\n+        check(Minus, 1, Minus, 1);\n+        check(Zero, 1, Zero, 0);\n     }\n \n     #[test]\n     fn test_cmp() {\n-        let uints = [ &[2], &[1, 1], &[2, 1], &[1, 1, 1] ]\n-            .map(|data| BigUint::from_slice(*data));\n-        let nums: ~[BigInt]\n-            = vec::reversed(uints).map(|bu| BigInt::from_biguint(Minus, *bu))\n-            + [ Zero::zero() ]\n-            + uints.map(|bu| BigInt::from_biguint(Plus, *bu));\n+        let vs = [ &[2], &[1, 1], &[2, 1], &[1, 1, 1] ];\n+        let mut nums = vec::reversed(vs)\n+            .map(|s| BigInt::from_slice(Minus, *s));\n+        nums.push(Zero::zero());\n+        nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n         for nums.eachi |i, ni| {\n             for vec::view(nums, i, nums.len()).eachi |j0, nj| {\n@@ -1194,59 +1189,57 @@ mod bigint_tests {\n \n     #[test]\n     fn test_convert_int() {\n-        fn check_conv(b: BigInt, i: int) {\n+        fn check(b: BigInt, i: int) {\n             assert b == Num::from_int(i);\n             assert b.to_int() == i;\n         }\n \n-        check_conv(Zero::zero(), 0);\n-        check_conv(One::one(), 1);\n-        check_conv(\n-            BigInt::from_biguint(\n-                Plus, BigUint::from_uint(int::max_value as uint)),\n-            int::max_value);\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(BigInt::from_biguint(\n+            Plus, BigUint::from_uint(int::max_value as uint)\n+        ), int::max_value);\n \n         assert BigInt::from_biguint(\n             Plus, BigUint::from_uint(int::max_value as uint + 1)\n         ).to_int() == int::max_value;\n         assert BigInt::from_biguint(\n-            Plus, BigUint::from_at_vec(@[1, 2, 3])\n+            Plus, BigUint::new(~[1, 2, 3])\n         ).to_int() == int::max_value;\n \n-        check_conv(\n-            BigInt::from_biguint(\n-                Minus, BigUint::from_uint(-int::min_value as uint)),\n-            int::min_value);\n+        check(BigInt::from_biguint(\n+            Minus, BigUint::from_uint(-int::min_value as uint)\n+        ), int::min_value);\n         assert BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint + 1)\n         ).to_int() == int::min_value;\n         assert BigInt::from_biguint(\n-            Minus, BigUint::from_at_vec(@[1, 2, 3])\n+            Minus, BigUint::new(~[1, 2, 3])\n         ).to_int() == int::min_value;\n     }\n \n     #[test]\n     fn test_convert_uint() {\n-        fn check_conv(b: BigInt, u: uint) {\n+        fn check(b: BigInt, u: uint) {\n             assert b == BigInt::from_uint(u);\n             assert b.to_uint() == u;\n         }\n \n-        check_conv(Zero::zero(), 0);\n-        check_conv(One::one(), 1);\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n \n-        check_conv(\n+        check(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n             uint::max_value);\n         assert BigInt::from_biguint(\n-            Plus, BigUint::from_at_vec(@[1, 2, 3])\n+            Plus, BigUint::new(~[1, 2, 3])\n         ).to_uint() == uint::max_value;\n \n         assert BigInt::from_biguint(\n             Minus, BigUint::from_uint(uint::max_value)\n         ).to_uint() == 0;\n         assert BigInt::from_biguint(\n-            Minus, BigUint::from_at_vec(@[1, 2, 3])\n+            Minus, BigUint::new(~[1, 2, 3])\n         ).to_uint() == 0;\n     }\n \n@@ -1363,44 +1356,39 @@ mod bigint_tests {\n \n     #[test]\n     fn test_divmod() {\n-        fn check_divmod_sub(a: BigInt, b: BigInt) {\n-            let (d, m) = a.divmod(&b);\n+        fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n+            let (d, m) = a.divmod(b);\n             if m.is_not_zero() {\n                 assert m.sign == b.sign;\n             }\n             assert m.abs() <= b.abs();\n-            assert a == b * d + m;\n-        }\n-        fn check_divmod(a: BigInt, b: BigInt, c: BigInt, d: BigInt) {\n-            check_divmod_sub(a, b);\n-            check_divmod_sub(a, -b);\n-            check_divmod_sub(-a, b);\n-            check_divmod_sub(-a, -b);\n-\n-            if d.is_zero() {\n-                assert a.divmod(&b)     == (c, Zero::zero());\n-                assert (-a).divmod(&b)  == (-c, Zero::zero());\n-                assert (a).divmod(&-b)  == (-c, Zero::zero());\n-                assert (-a).divmod(&-b) == (c, Zero::zero());\n+            assert *a == b * d + m;\n+            assert d == *ans_d;\n+            assert m == *ans_m;\n+        }\n+\n+        fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n+            if m.is_zero() {\n+                check_sub(a, b, d, m);\n+                check_sub(a, &b.neg(), &d.neg(), m);\n+                check_sub(&a.neg(), b, &d.neg(), m);\n+                check_sub(&a.neg(), &b.neg(), d, m);\n             } else {\n-                // a == bc + d\n-                assert a.divmod(&b) == (c, d);\n-                // a == (-b)(-c - 1) + (d - b)\n-                assert a.divmod(&-b) == (-c - One::one(), d - b);\n-                // (-a) == b (-c - 1) + (b - d)\n-                assert (-a).divmod(&b) == (-c - One::one(), b - d);\n-                // (-a) == (-b)(c) - d\n-                assert (-a).divmod(&-b) == (c, -d);\n+                check_sub(a, b, d, m);\n+                check_sub(a, &b.neg(), &(d.neg() - One::one()), &(m - *b));\n+                check_sub(&a.neg(), b, &(d.neg() - One::one()), &(b - *m));\n+                check_sub(&a.neg(), &b.neg(), d, &m.neg());\n             }\n         }\n+\n         for mul_triples.each |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            if a.is_not_zero() { check_divmod(c, a, b, Zero::zero()); }\n-            if b.is_not_zero() { check_divmod(c, b, a, Zero::zero()); }\n+            if a.is_not_zero() { check(&c, &a, &b, &Zero::zero()); }\n+            if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1411,52 +1399,39 @@ mod bigint_tests {\n             let d = BigInt::from_slice(Plus, dVec);\n \n             if b.is_not_zero() {\n-                check_divmod(a, b, c, d);\n+                check(&a, &b, &c, &d);\n             }\n         }\n     }\n \n \n     #[test]\n     fn test_quotrem() {\n-        fn check_quotrem_sub(a: BigInt, b: BigInt) {\n-            let (q, r) = a.quotrem(&b);\n+        fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n+            let (q, r) = a.quotrem(b);\n             if r.is_not_zero() {\n                 assert r.sign == a.sign;\n             }\n             assert r.abs() <= b.abs();\n-            assert a == b * q + r;\n-        }\n-        fn check_quotrem(a: BigInt, b: BigInt, c: BigInt, d: BigInt) {\n-            check_quotrem_sub(a, b);\n-            check_quotrem_sub(a, -b);\n-            check_quotrem_sub(-a, b);\n-            check_quotrem_sub(-a, -b);\n-\n-            if d.is_zero() {\n-                assert a.quotrem(&b)     == (c, Zero::zero());\n-                assert (-a).quotrem(&b)  == (-c, Zero::zero());\n-                assert (a).quotrem(&-b)  == (-c, Zero::zero());\n-                assert (-a).quotrem(&-b) == (c, Zero::zero());\n-            } else {\n-                // a == bc + d\n-                assert a.quotrem(&b) == (c, d);\n-                // a == (-b)(-c) + d\n-                assert a.quotrem(&-b) == (-c, d);\n-                // (-a) == b (-c) + (-d)\n-                assert (-a).quotrem(&b) == (-c, -d);\n-                // (-a) == (-b)(c) - d\n-                assert (-a).quotrem(&-b) == (c, -d);\n-            }\n+            assert *a == b * q + r;\n+            assert q == *ans_q;\n+            assert r == *ans_r;\n+        }\n+\n+        fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n+            check_sub(a, b, q, r);\n+            check_sub(a, &b.neg(), &q.neg(), r);\n+            check_sub(&a.neg(), b, &q.neg(), &r.neg());\n+            check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n         for mul_triples.each |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            if a.is_not_zero() { check_quotrem(c, a, b, Zero::zero()); }\n-            if b.is_not_zero() { check_quotrem(c, b, a, Zero::zero()); }\n+            if a.is_not_zero() { check(&c, &a, &b, &Zero::zero()); }\n+            if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1467,45 +1442,45 @@ mod bigint_tests {\n             let d = BigInt::from_slice(Plus, dVec);\n \n             if b.is_not_zero() {\n-                check_quotrem(a, b, c, d);\n+                check(&a, &b, &c, &d);\n             }\n         }\n     }\n \n     #[test]\n     fn test_to_str_radix() {\n-        assert BigInt::from_biguint(Plus, BigUint::from_uint(10))\n-            .to_str_radix(10) == ~\"10\";\n-        assert One::one::<BigInt>().to_str_radix(10) == ~\"1\";\n-        assert Zero::zero::<BigInt>().to_str_radix(10) == ~\"0\";\n-        assert (-One::one::<BigInt>()).to_str_radix(10) == ~\"-1\";\n-        assert BigInt::from_biguint(Minus, BigUint::from_uint(10))\n-            .to_str_radix(10) == ~\"-10\";\n+        fn check(n: int, ans: &str) {\n+            assert ans == Num::from_int::<BigInt>(n).to_str_radix(10);\n+        }\n+        check(10, \"10\");\n+        check(1, \"1\");\n+        check(0, \"0\");\n+        check(-1, \"-1\");\n+        check(-10, \"-10\");\n     }\n \n \n     #[test]\n     fn test_from_str_radix() {\n-        assert BigInt::from_biguint(Plus, BigUint::from_uint(10)) ==\n-            BigInt::from_str_radix(~\"10\", 10).get();\n-        assert One::one::<BigInt>() == BigInt::from_str_radix(~\"1\", 10).get();\n-        assert Zero::zero::<BigInt>() == BigInt::from_str_radix(~\"0\", 10).get();\n-        assert (-One::one::<BigInt>()) == BigInt::from_str_radix(~\"-1\", 10).get();\n-        assert BigInt::from_biguint(Minus, BigUint::from_uint(10)) ==\n-            BigInt::from_str_radix(~\"-10\", 10).get();\n-\n-        assert BigInt::from_str_radix(~\"Z\", 10) == None;\n-        assert BigInt::from_str_radix(~\"_\", 2) == None;\n-        assert BigInt::from_str_radix(~\"-1\", 10) ==\n-            Some(BigInt::from_biguint(Minus, One::one()));\n+        fn check(s: &str, ans: Option<int>) {\n+            let ans = ans.map(|&n| Num::from_int(n));\n+            assert BigInt::from_str_radix(s, 10) == ans;\n+        }\n+        check(\"10\", Some(10));\n+        check(\"1\", Some(1));\n+        check(\"0\", Some(0));\n+        check(\"-1\", Some(-1));\n+        check(\"-10\", Some(-10));\n+        check(\"Z\", None);\n+        check(\"_\", None);\n     }\n \n     #[test]\n     fn test_neg() {\n-        assert -BigInt::from_at_vec(Plus,  @[1, 1, 1]) ==\n-            BigInt::from_at_vec(Minus, @[1, 1, 1]);\n-        assert -BigInt::from_at_vec(Minus, @[1, 1, 1]) ==\n-            BigInt::from_at_vec(Plus,  @[1, 1, 1]);\n+        assert -BigInt::new(Plus,  ~[1, 1, 1]) ==\n+            BigInt::new(Minus, ~[1, 1, 1]);\n+        assert -BigInt::new(Minus, ~[1, 1, 1]) ==\n+            BigInt::new(Plus,  ~[1, 1, 1]);\n         assert -Zero::zero::<BigInt>() == Zero::zero::<BigInt>();\n     }\n }"}]}