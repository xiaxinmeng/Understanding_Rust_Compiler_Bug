{"sha": "68bd495f0b2355e390c5dc382e17d056c113d069", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YmQ0OTVmMGIyMzU1ZTM5MGM1ZGMzODJlMTdkMDU2YzExM2QwNjk=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-15T06:02:38Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-16T01:41:55Z"}, "message": "Remove core::num::strconv", "tree": {"sha": "5630fed3bc9ba64a05eeab3128d79a5498f25104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5630fed3bc9ba64a05eeab3128d79a5498f25104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68bd495f0b2355e390c5dc382e17d056c113d069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68bd495f0b2355e390c5dc382e17d056c113d069", "html_url": "https://github.com/rust-lang/rust/commit/68bd495f0b2355e390c5dc382e17d056c113d069", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68bd495f0b2355e390c5dc382e17d056c113d069/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29bc9c632eda71c6b4a8b35db637971953b58d03", "url": "https://api.github.com/repos/rust-lang/rust/commits/29bc9c632eda71c6b4a8b35db637971953b58d03", "html_url": "https://github.com/rust-lang/rust/commit/29bc9c632eda71c6b4a8b35db637971953b58d03"}], "stats": {"total": 693, "additions": 282, "deletions": 411}, "files": [{"sha": "e7b0f626bf8725d26118e84c2a0d6695911e222f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 3, "deletions": 61, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=68bd495f0b2355e390c5dc382e17d056c113d069", "patch": "@@ -16,10 +16,8 @@\n \n use intrinsics;\n use mem;\n-use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::{Float, FromStrRadix};\n-use num::strconv;\n-use str::FromStr;\n+use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::from_str_radix;\n use option::Option;\n \n pub const RADIX: uint = 2u;\n@@ -431,61 +429,5 @@ impl Float for f32 {\n #[allow(missing_docs)]\n #[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n pub fn from_str_hex(src: &str) -> Option<f32> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f32 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as\n-    ///\n-    /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f32> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl FromStrRadix for f32 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n+    from_str_radix(src, 16)\n }"}, {"sha": "e82be19011073950dbde530693578feb588c2b6d", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 3, "deletions": 56, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=68bd495f0b2355e390c5dc382e17d056c113d069", "patch": "@@ -16,10 +16,8 @@\n \n use intrinsics;\n use mem;\n-use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::{Float, FromStrRadix};\n-use num::strconv;\n-use str::FromStr;\n+use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::from_str_radix;\n use option::Option;\n \n // FIXME(#5527): These constants should be deprecated once associated\n@@ -437,56 +435,5 @@ impl Float for f64 {\n #[allow(missing_docs)]\n #[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n pub fn from_str_hex(src: &str) -> Option<f64> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f64 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as:\n-    ///\n-    /// * '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f64> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl FromStrRadix for f64 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n+    from_str_radix(src, 16)\n }"}, {"sha": "0f8950344c8a0524a175125d488fd3449b81911a", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=68bd495f0b2355e390c5dc382e17d056c113d069", "patch": "@@ -32,20 +32,4 @@ pub const MIN: $T = (-1 as $T) << (BITS - 1);\n #[unstable]\n pub const MAX: $T = !MIN;\n \n-#[experimental = \"might need to return Result\"]\n-impl ::str::FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> ::option::Option<$T> {\n-        ::num::strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl ::num::FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> ::option::Option<$T> {\n-        ::num::strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n ))"}, {"sha": "f5505ff8e762519a448ded962091fcf0ebca08d6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 276, "deletions": 3, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=68bd495f0b2355e390c5dc382e17d056c113d069", "patch": "@@ -14,20 +14,21 @@\n \n #![allow(missing_docs)]\n \n-use intrinsics;\n use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n+use char::Char;\n use clone::Clone;\n use cmp::{PartialEq, Eq};\n use cmp::{PartialOrd, Ord};\n+use intrinsics;\n+use iter::Iterator;\n use kinds::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n-\n-pub mod strconv;\n+use str::{FromStr, from_str, StrPrelude};\n \n /// Simultaneous division and remainder\n #[inline]\n@@ -1386,6 +1387,278 @@ pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n+macro_rules! from_str_radix_float_impl {\n+    ($T:ty) => {\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStr for $T {\n+            /// Convert a string in base 10 to a float.\n+            /// Accepts an optional decimal exponent.\n+            ///\n+            /// This function accepts strings such as\n+            ///\n+            /// * '3.14'\n+            /// * '+3.14', equivalent to '3.14'\n+            /// * '-3.14'\n+            /// * '2.5E10', or equivalently, '2.5e10'\n+            /// * '2.5E-10'\n+            /// * '.' (understood as 0)\n+            /// * '5.'\n+            /// * '.5', or, equivalently,  '0.5'\n+            /// * '+inf', 'inf', '-inf', 'NaN'\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            ///\n+            /// # Return value\n+            ///\n+            /// `None` if the string did not represent a valid number.  Otherwise,\n+            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            #[inline]\n+            fn from_str(src: &str) -> Option<$T> {\n+                from_str_radix(src, 10)\n+            }\n+        }\n+\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStrRadix for $T {\n+            /// Convert a string in a given base to a float.\n+            ///\n+            /// Due to possible conflicts, this function does **not** accept\n+            /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+            /// does it recognize exponents of any kind.\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            /// * radix - The base to use. Must lie in the range [2 .. 36]\n+            ///\n+            /// # Return value\n+            ///\n+            /// `None` if the string did not represent a valid number. Otherwise,\n+            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+               assert!(radix >= 2 && radix <= 36,\n+                       \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+                       radix);\n+\n+                // Special values\n+                match src {\n+                    \"inf\"   => return Some(Float::infinity()),\n+                    \"-inf\"  => return Some(Float::neg_infinity()),\n+                    \"NaN\"   => return Some(Float::nan()),\n+                    _       => {},\n+                }\n+\n+                let (is_positive, src) =  match src.slice_shift_char() {\n+                    (None, _)        => return None,\n+                    (Some('-'), \"\")  => return None,\n+                    (Some('-'), src) => (false, src),\n+                    (Some(_), _)     => (true,  src),\n+                };\n+\n+                // The significand to accumulate\n+                let mut sig = if is_positive { 0.0 } else { -0.0 };\n+                // Necessary to detect overflow\n+                let mut prev_sig = sig;\n+                let mut cs = src.chars().enumerate();\n+                // Exponent prefix and exponent index offset\n+                let mut exp_info = None::<(char, uint)>;\n+\n+                // Parse the integer part of the significand\n+                for (i, c) in cs {\n+                    match c.to_digit(radix) {\n+                        Some(digit) => {\n+                            // shift significand one digit left\n+                            sig = sig * (radix as $T);\n+\n+                            // add/subtract current digit depending on sign\n+                            if is_positive {\n+                                sig = sig + ((digit as int) as $T);\n+                            } else {\n+                                sig = sig - ((digit as int) as $T);\n+                            }\n+\n+                            // Detect overflow by comparing to last value, except\n+                            // if we've not seen any non-zero digits.\n+                            if prev_sig != 0.0 {\n+                                if is_positive && sig <= prev_sig\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && sig >= prev_sig\n+                                    { return Some(Float::neg_infinity()); }\n+\n+                                // Detect overflow by reversing the shift-and-add process\n+                                if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n+                                    { return Some(Float::neg_infinity()); }\n+                            }\n+                            prev_sig = sig;\n+                        },\n+                        None => match c {\n+                            'e' | 'E' | 'p' | 'P' => {\n+                                exp_info = Some((c, i + 1));\n+                                break;  // start of exponent\n+                            },\n+                            '.' => {\n+                                break;  // start of fractional part\n+                            },\n+                            _ => {\n+                                return None;\n+                            },\n+                        },\n+                    }\n+                }\n+\n+                // If we are not yet at the exponent parse the fractional\n+                // part of the significand\n+                if exp_info.is_none() {\n+                    let mut power = 1.0;\n+                    for (i, c) in cs {\n+                        match c.to_digit(radix) {\n+                            Some(digit) => {\n+                                // Decrease power one order of magnitude\n+                                power = power / (radix as $T);\n+                                // add/subtract current digit depending on sign\n+                                sig = if is_positive {\n+                                    sig + (digit as $T) * power\n+                                } else {\n+                                    sig - (digit as $T) * power\n+                                };\n+                                // Detect overflow by comparing to last value\n+                                if is_positive && sig < prev_sig\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && sig > prev_sig\n+                                    { return Some(Float::neg_infinity()); }\n+                                prev_sig = sig;\n+                            },\n+                            None => match c {\n+                                'e' | 'E' | 'p' | 'P' => {\n+                                    exp_info = Some((c, i + 1));\n+                                    break; // start of exponent\n+                                },\n+                                _ => {\n+                                    return None; // invalid number\n+                                },\n+                            },\n+                        }\n+                    }\n+                }\n+\n+                // Parse and calculate the exponent\n+                let exp = match exp_info {\n+                    Some((c, offset)) => {\n+                        let base = match c {\n+                            'E' | 'e' if radix == 10 => 10u as $T,\n+                            'P' | 'p' if radix == 16 => 2u as $T,\n+                            _ => return None,\n+                        };\n+\n+                        // Parse the exponent as decimal integer\n+                        let src = src[offset..];\n+                        let (is_positive, exp) = match src.slice_shift_char() {\n+                            (Some('-'), src) => (false, from_str::<uint>(src)),\n+                            (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                            (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                            (None, _)        => return None,\n+                        };\n+\n+                        match (is_positive, exp) {\n+                            (true,  Some(exp)) => base.powi(exp as i32),\n+                            (false, Some(exp)) => 1.0 / base.powi(exp as i32),\n+                            (_, None)          => return None,\n+                        }\n+                    },\n+                    None => 1.0, // no exponent\n+                };\n+\n+                Some(sig * exp)\n+            }\n+        }\n+    }\n+}\n+from_str_radix_float_impl!(f32)\n+from_str_radix_float_impl!(f64)\n+\n+macro_rules! from_str_radix_int_impl {\n+    ($T:ty) => {\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStr for $T {\n+            #[inline]\n+            fn from_str(src: &str) -> Option<$T> {\n+                from_str_radix(src, 10)\n+            }\n+        }\n+\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStrRadix for $T {\n+            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+                assert!(radix >= 2 && radix <= 36,\n+                       \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+                       radix);\n+\n+                let is_signed_ty = (0 as $T) > Int::min_value();\n+\n+                match src.slice_shift_char() {\n+                    (Some('-'), src) if is_signed_ty => {\n+                        // The number is negative\n+                        let mut result = 0;\n+                        for c in src.chars() {\n+                            let x = match c.to_digit(radix) {\n+                                Some(x) => x,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_mul(radix as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_sub(x as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                        }\n+                        Some(result)\n+                    },\n+                    (Some(_), _) => {\n+                        // The number is signed\n+                        let mut result = 0;\n+                        for c in src.chars() {\n+                            let x = match c.to_digit(radix) {\n+                                Some(x) => x,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_mul(radix as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_add(x as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                        }\n+                        Some(result)\n+                    },\n+                    (None, _) => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+from_str_radix_int_impl!(int)\n+from_str_radix_int_impl!(i8)\n+from_str_radix_int_impl!(i16)\n+from_str_radix_int_impl!(i32)\n+from_str_radix_int_impl!(i64)\n+from_str_radix_int_impl!(uint)\n+from_str_radix_int_impl!(u8)\n+from_str_radix_int_impl!(u16)\n+from_str_radix_int_impl!(u32)\n+from_str_radix_int_impl!(u64)\n+\n // DEPRECATED\n \n macro_rules! trait_impl {"}, {"sha": "daa2a8e234318f5f26cfa7bd2d265392453c8c39", "filename": "src/libcore/num/strconv.rs", "status": "removed", "additions": 0, "deletions": 259, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -1,259 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-#![allow(missing_docs)]\n-\n-use char::Char;\n-use iter::Iterator;\n-use num;\n-use num::{Int, Float};\n-use option::{None, Option, Some};\n-use str::{from_str, StrPrelude};\n-\n-pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-    let radix_t: T = num::cast(radix as int).unwrap();\n-\n-    // Special values\n-    match src {\n-        \"inf\"   => return Some(Float::infinity()),\n-        \"-inf\"  => return Some(Float::neg_infinity()),\n-        \"NaN\"   => return Some(Float::nan()),\n-        _       => {},\n-    }\n-\n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (None, _)        => return None,\n-        (Some('-'), \"\")  => return None,\n-        (Some('-'), src) => (false, src),\n-        (Some(_), _)     => (true,  src),\n-    };\n-\n-    // The significand to accumulate\n-    let mut sig = if is_positive { _0 } else { -_0 };\n-    // Necessary to detect overflow\n-    let mut prev_sig = sig;\n-    let mut cs = src.chars().enumerate();\n-    // Exponent prefix and exponent index offset\n-    let mut exp_info = None::<(char, uint)>;\n-\n-    // Parse the integer part of the significand\n-    for (i, c) in cs {\n-        match c.to_digit(radix) {\n-            Some(digit) => {\n-                // shift significand one digit left\n-                sig = sig * radix_t;\n-\n-                // add/subtract current digit depending on sign\n-                if is_positive {\n-                    sig = sig + num::cast(digit as int).unwrap();\n-                } else {\n-                    sig = sig - num::cast(digit as int).unwrap();\n-                }\n-\n-                // Detect overflow by comparing to last value, except\n-                // if we've not seen any non-zero digits.\n-                if prev_sig != _0 {\n-                    if is_positive && sig <= prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig >= prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-\n-                    // Detect overflow by reversing the shift-and-add process\n-                    let digit: T = num::cast(digit as int).unwrap();\n-                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n-                        { return Some(Float::neg_infinity()); }\n-                }\n-                prev_sig = sig;\n-            },\n-            None => match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp_info = Some((c, i + 1));\n-                    break;  // start of exponent\n-                },\n-                '.' => {\n-                    break;  // start of fractional part\n-                },\n-                _ => {\n-                    return None;\n-                },\n-            },\n-        }\n-    }\n-\n-    // If we are not yet at the exponent parse the fractional\n-    // part of the significand\n-    if exp_info.is_none() {\n-        let mut power = _1;\n-        for (i, c) in cs {\n-            match c.to_digit(radix) {\n-                Some(digit) => {\n-                    let digit: T = num::cast(digit).unwrap();\n-                    // Decrease power one order of magnitude\n-                    power = power / radix_t;\n-                    // add/subtract current digit depending on sign\n-                    sig = if is_positive {\n-                        sig + digit * power\n-                    } else {\n-                        sig - digit * power\n-                    };\n-                    // Detect overflow by comparing to last value\n-                    if is_positive && sig < prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig > prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-                    prev_sig = sig;\n-                },\n-                None => match c {\n-                    'e' | 'E' | 'p' | 'P' => {\n-                        exp_info = Some((c, i + 1));\n-                        break; // start of exponent\n-                    },\n-                    _ => {\n-                        return None; // invalid number\n-                    },\n-                },\n-            }\n-        }\n-    }\n-\n-    // Parse and calculate the exponent\n-    let exp = match exp_info {\n-        Some((c, offset)) => {\n-            let base: T = match c {\n-                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n-                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n-                _ => return None,\n-            };\n-\n-            // Parse the exponent as decimal integer\n-            let src = src[offset..];\n-            let (is_positive, exp) = match src.slice_shift_char() {\n-                (Some('-'), src) => (false, from_str::<uint>(src)),\n-                (Some('+'), src) => (true,  from_str::<uint>(src)),\n-                (Some(_), _)     => (true,  from_str::<uint>(src)),\n-                (None, _)        => return None,\n-            };\n-\n-            match (is_positive, exp) {\n-                (true,  Some(exp)) => base.powi(exp as i32),\n-                (false, Some(exp)) => _1 / base.powi(exp as i32),\n-                (_, None)          => return None,\n-            }\n-        },\n-        None => _1, // no exponent\n-    };\n-\n-    Some(sig * exp)\n-}\n-\n-pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n-\n-    fn cast<T: Int>(x: uint) -> T {\n-        num::cast(x).unwrap()\n-    }\n-\n-    let _0: T = Int::zero();\n-    let _1: T = Int::one();\n-    let is_signed = _0 > Int::min_value();\n-\n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (Some('-'), src) if is_signed => (false, src),\n-        (Some(_), _) => (true, src),\n-        (None, _) => return None,\n-    };\n-\n-    let mut xs = src.chars().map(|c| {\n-        c.to_digit(radix).map(cast)\n-    });\n-    let radix = cast(radix);\n-    let mut result = _0;\n-\n-    if is_positive {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_add(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    } else {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_sub(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    }\n-\n-    Some(result)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use num::Float;\n-\n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n-        assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n-        assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n-        assert_eq!(f, Some(Float::infinity()))\n-        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n-        assert_eq!(fe, Some(Float::infinity()))\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix_float(\"-123.456\", 10);\n-        assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix_float(\"123.456\", 10);\n-        assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix_float(\"-0.0\", 10);\n-        assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"0.0\", 10);\n-        assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"1.0\", 10);\n-        assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix_float(\"-1.0\", 10);\n-        assert_eq!(x5, Some(-1.0));\n-    }\n-}"}, {"sha": "2a94f851646c4f4bda95d17039f994689629941b", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bd495f0b2355e390c5dc382e17d056c113d069/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=68bd495f0b2355e390c5dc382e17d056c113d069", "patch": "@@ -23,20 +23,4 @@ pub const MIN: $T = 0 as $T;\n #[unstable]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n-#[experimental = \"might need to return Result\"]\n-impl ::str::FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> ::option::Option<$T> {\n-        ::num::strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl ::num::FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> ::option::Option<$T> {\n-        ::num::strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n ))"}]}