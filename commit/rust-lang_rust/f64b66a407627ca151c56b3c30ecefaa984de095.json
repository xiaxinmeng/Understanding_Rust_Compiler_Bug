{"sha": "f64b66a407627ca151c56b3c30ecefaa984de095", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NGI2NmE0MDc2MjdjYTE1MWM1NmIzYzMwZWNlZmFhOTg0ZGUwOTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-27T22:54:46Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-30T04:43:06Z"}, "message": "Do not downgrade NLL errors for bind_by_move_pattern_guards when AST says it is OK.", "tree": {"sha": "21437d74bb799d63658c7838e788647377da51f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21437d74bb799d63658c7838e788647377da51f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f64b66a407627ca151c56b3c30ecefaa984de095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f64b66a407627ca151c56b3c30ecefaa984de095", "html_url": "https://github.com/rust-lang/rust/commit/f64b66a407627ca151c56b3c30ecefaa984de095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f64b66a407627ca151c56b3c30ecefaa984de095/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b88a9eba8abbac87eddcb2998beea09589c2c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b88a9eba8abbac87eddcb2998beea09589c2c9", "html_url": "https://github.com/rust-lang/rust/commit/04b88a9eba8abbac87eddcb2998beea09589c2c9"}], "stats": {"total": 74, "additions": 47, "deletions": 27}, "files": [{"sha": "5ab1b90642a6aeca10cca42616910a2b47fc2252", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=f64b66a407627ca151c56b3c30ecefaa984de095", "patch": "@@ -461,7 +461,7 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query check_match(key: DefId) -> () {\n+        query check_match(key: DefId) -> SignalledError {\n             cache_on_disk_if { key.is_local() }\n         }\n "}, {"sha": "fb2ad2aa54d7affedadaa6c5fb0819361a7c45d8", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=f64b66a407627ca151c56b3c30ecefaa984de095", "patch": "@@ -4,7 +4,7 @@ use crate::hir::def::{DefKind, Export};\n use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n use crate::infer::canonical::{self, Canonical};\n use crate::lint;\n-use crate::middle::borrowck::BorrowCheckResult;\n+use crate::middle::borrowck::{BorrowCheckResult, SignalledError};\n use crate::middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary, ForeignModule};\n use crate::middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use crate::middle::privacy::AccessLevels;"}, {"sha": "3bbd7ae5c352f80deea01b64aff840de6a0b9ce2", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=f64b66a407627ca151c56b3c30ecefaa984de095", "patch": "@@ -66,6 +66,13 @@ fn borrowck(tcx: TyCtxt<'_>, owner_def_id: DefId) -> &BorrowCheckResult {\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n+    let signalled_error = tcx.check_match(owner_def_id);\n+    if let SignalledError::SawSomeError = signalled_error {\n+        return tcx.arena.alloc(BorrowCheckResult {\n+            signalled_any_error: SignalledError::SawSomeError,\n+        })\n+    }\n+\n     let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n \n     match tcx.hir().get(owner_id) {"}, {"sha": "47f31fa0a82b1e20f6b3bac0ea04544021d62e51", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64b66a407627ca151c56b3c30ecefaa984de095/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f64b66a407627ca151c56b3c30ecefaa984de095", "patch": "@@ -4,6 +4,7 @@ use super::_match::WitnessPreference::*;\n \n use super::{Pattern, PatternContext, PatternError, PatternKind};\n \n+use rustc::middle::borrowck::SignalledError;\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n@@ -26,21 +27,24 @@ use std::slice;\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n+crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) -> SignalledError {\n     let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         tcx.hir().body_owned_by(id)\n     } else {\n-        return;\n+        return SignalledError::NoErrorsSeen;\n     };\n \n-    MatchVisitor {\n+    let mut visitor = MatchVisitor {\n         tcx,\n         body_owner: def_id,\n         tables: tcx.body_tables(body_id),\n         region_scope_tree: &tcx.region_scope_tree(def_id),\n         param_env: tcx.param_env(def_id),\n         identity_substs: InternalSubsts::identity_for_item(tcx, def_id),\n-    }.visit_body(tcx.hir().body(body_id));\n+        signalled_error: SignalledError::NoErrorsSeen,\n+    };\n+    visitor.visit_body(tcx.hir().body(body_id));\n+    visitor.signalled_error\n }\n \n fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBuilder<'_> {\n@@ -54,6 +58,7 @@ struct MatchVisitor<'a, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: SubstsRef<'tcx>,\n     region_scope_tree: &'a region::ScopeTree,\n+    signalled_error: SignalledError,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n@@ -64,11 +69,8 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n \n-        match ex.node {\n-            hir::ExprKind::Match(ref scrut, ref arms, source) => {\n-                self.check_match(scrut, arms, source);\n-            }\n-            _ => {}\n+        if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.node {\n+            self.check_match(scrut, arms, source);\n         }\n     }\n \n@@ -130,27 +132,29 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n-    fn check_patterns(&self, has_guard: bool, pats: &[P<Pat>]) {\n+    fn check_patterns(&mut self, has_guard: bool, pats: &[P<Pat>]) {\n         check_legality_of_move_bindings(self, has_guard, pats);\n         for pat in pats {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n     }\n \n     fn check_match(\n-        &self,\n+        &mut self,\n         scrut: &hir::Expr,\n         arms: &'tcx [hir::Arm],\n-        source: hir::MatchSource)\n-    {\n+        source: hir::MatchSource\n+    ) {\n         for arm in arms {\n             // First, check legality of move bindings.\n             self.check_patterns(arm.guard.is_some(), &arm.pats);\n \n             // Second, if there is a guard on each arm, make sure it isn't\n             // assigning or borrowing anything mutably.\n             if let Some(ref guard) = arm.guard {\n-                if !self.tcx.features().bind_by_move_pattern_guards {\n+                if self.tcx.features().bind_by_move_pattern_guards {\n+                    self.signalled_error = SignalledError::SawSomeError;\n+                } else {\n                     check_for_mutation_in_guard(self, &guard);\n                 }\n             }\n@@ -548,7 +552,7 @@ fn maybe_point_at_variant(\n \n // Legality of move bindings checking\n fn check_legality_of_move_bindings(\n-    cx: &MatchVisitor<'_, '_>,\n+    cx: &mut MatchVisitor<'_, '_>,\n     has_guard: bool,\n     pats: &[P<Pat>],\n ) {\n@@ -565,7 +569,12 @@ fn check_legality_of_move_bindings(\n         })\n     }\n     let span_vec = &mut Vec::new();\n-    let check_move = |p: &Pat, sub: Option<&Pat>, span_vec: &mut Vec<Span>| {\n+    let check_move = |\n+        cx: &mut MatchVisitor<'_, '_>,\n+        p: &Pat,\n+        sub: Option<&Pat>,\n+        span_vec: &mut Vec<Span>,\n+    | {\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n@@ -574,15 +583,19 @@ fn check_legality_of_move_bindings(\n                              \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n-        } else if has_guard && !cx.tcx.features().bind_by_move_pattern_guards {\n-            let mut err = struct_span_err!(cx.tcx.sess, p.span, E0008,\n-                                           \"cannot bind by-move into a pattern guard\");\n-            err.span_label(p.span, \"moves value into pattern guard\");\n-            if cx.tcx.sess.opts.unstable_features.is_nightly_build() {\n-                err.help(\"add `#![feature(bind_by_move_pattern_guards)]` to the \\\n-                          crate attributes to enable\");\n+        } else if has_guard {\n+            if cx.tcx.features().bind_by_move_pattern_guards {\n+                cx.signalled_error = SignalledError::SawSomeError;\n+            } else {\n+                let mut err = struct_span_err!(cx.tcx.sess, p.span, E0008,\n+                                            \"cannot bind by-move into a pattern guard\");\n+                err.span_label(p.span, \"moves value into pattern guard\");\n+                if cx.tcx.sess.opts.unstable_features.is_nightly_build() {\n+                    err.help(\"add `#![feature(bind_by_move_pattern_guards)]` to the \\\n+                            crate attributes to enable\");\n+                }\n+                err.emit();\n             }\n-            err.emit();\n         } else if let Some(_by_ref_span) = by_ref_span {\n             span_vec.push(p.span);\n         }\n@@ -596,7 +609,7 @@ fn check_legality_of_move_bindings(\n                         ty::BindByValue(..) => {\n                             let pat_ty = cx.tables.node_type(p.hir_id);\n                             if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n-                                check_move(p, sub.as_ref().map(|p| &**p), span_vec);\n+                                check_move(cx, p, sub.as_ref().map(|p| &**p), span_vec);\n                             }\n                         }\n                         _ => {}"}]}