{"sha": "e6b9db08841c5d215c56790e35f951a99275001d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YjlkYjA4ODQxYzVkMjE1YzU2NzkwZTM1Zjk1MWE5OTI3NTAwMWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-30T04:05:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-30T18:04:12Z"}, "message": "refactor region manipulation routines to eliminate duplication\n\nfn subtyping is starting to work, but it's exposing bugs in the\ncode which checks for iface conformance, which doesn't properly\nskolemize the self region", "tree": {"sha": "5ccc929c4d6e172ea0dfd34c7e134a295482f6d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ccc929c4d6e172ea0dfd34c7e134a295482f6d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6b9db08841c5d215c56790e35f951a99275001d", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b9db08841c5d215c56790e35f951a99275001d", "html_url": "https://github.com/rust-lang/rust/commit/e6b9db08841c5d215c56790e35f951a99275001d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6b9db08841c5d215c56790e35f951a99275001d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b744f52620821ed665eb1ac9c36f862a0b72eaf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b744f52620821ed665eb1ac9c36f862a0b72eaf4", "html_url": "https://github.com/rust-lang/rust/commit/b744f52620821ed665eb1ac9c36f862a0b72eaf4"}], "stats": {"total": 305, "additions": 119, "deletions": 186}, "files": [{"sha": "20c9db7b3fdefe8d1286a7f29833c5d4ffd4417b", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 62, "deletions": 92, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e6b9db08841c5d215c56790e35f951a99275001d", "patch": "@@ -70,7 +70,7 @@ import astconv::{ast_conv, ast_ty_to_ty};\n import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n import middle::ty::tys_in_fn_ty;\n-import regionmanip::{universally_quantify_from_sty,\n+import regionmanip::{replace_bound_regions_in_fn_ty,\n                      region_of, replace_bound_regions,\n                      collect_bound_regions_in_tys};\n import rscope::*;\n@@ -84,7 +84,6 @@ type fn_ctxt =\n      // Used by loop bodies that return from the outer function\n      indirect_ret_ty: option<ty::t>,\n      purity: ast::purity,\n-     proto: ast::proto,\n      infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, ty_vid>,\n \n@@ -128,55 +127,41 @@ fn check_bare_fn(ccx: @crate_ctxt,\n                  id: ast::node_id,\n                  self_ty: option<ty::t>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    let ret_ty = ty::ty_fn_ret(fty);\n-    let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n-    check_fn(ccx, ast::proto_bare, decl, body,\n-             ret_ty, arg_tys, false, none, self_ty);\n+    let fn_ty = alt check ty::get(fty).struct { ty::ty_fn(f) {f} };\n+    check_fn(ccx, self_ty, fn_ty, decl, body, false, none);\n }\n \n fn check_fn(ccx: @crate_ctxt,\n-            proto: ast::proto,\n+            self_ty: option<ty::t>,\n+            fn_ty: ty::fn_ty,\n             decl: ast::fn_decl,\n             body: ast::blk,\n-            ret_ty: ty::t,\n-            arg_tys: [ty::t],\n             indirect_ret: bool,\n-            old_fcx: option<@fn_ctxt>,\n-            self_ty: option<ty::t>) {\n+            old_fcx: option<@fn_ctxt>) {\n \n     let tcx = ccx.tcx;\n \n-    let isr = {\n-        // Find the list of in-scope regions.  These are derived from the\n-        // various regions that are bound in the argument, return, and self\n-        // types.  For each of those bound regions, we will create a mapping\n-        // to a free region tied to the node_id of this function.  For an\n-        // in-depth discussion of why we must distinguish bound/free regions,\n-        // see the big comment in region.rs.\n-        let all_tys = arg_tys + [ret_ty] + self_ty.to_vec();\n-        let old_isr = option::map_default(old_fcx, @nil) {\n-            |fcx| fcx.in_scope_regions };\n-        collect_bound_regions_in_tys(tcx, old_isr, all_tys) {\n-            |br| ty::re_free(body.node.id, br) }\n-    };\n+    // ______________________________________________________________________\n+    // First, we have to replace any bound regions in the fn and self\n+    // types with free ones.  The free region references will be bound\n+    // the node_id of the body block.\n \n-    // Replace the bound regions that appear in the arg tys, ret ty, etc with\n-    // the free versions we just collected.\n-    let arg_tys = arg_tys.map {\n-        |arg_ty| replace_bound_regions(tcx, body.span, isr, arg_ty)\n-    };\n-    let ret_ty = {\n-        replace_bound_regions(tcx, body.span, isr, ret_ty)\n-    };\n-    let self_ty = option::map(self_ty) {\n-        |self_ty| replace_bound_regions(tcx, body.span, isr, self_ty)\n+    let {isr, self_ty, fn_ty} = {\n+        let old_isr = option::map_default(old_fcx, @nil,\n+                                         { |fcx| fcx.in_scope_regions });\n+        replace_bound_regions_in_fn_ty(tcx, old_isr, self_ty, fn_ty,\n+                                       { |br| ty::re_free(body.node.id, br) })\n     };\n \n+    let arg_tys = fn_ty.inputs.map { |a| a.ty };\n+    let ret_ty = fn_ty.output;\n+\n     #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n            arg_tys.map {|a| ty_to_str(tcx, a) },\n            ty_to_str(tcx, ret_ty),\n            option::map(self_ty) {|st| ty_to_str(tcx, st) }];\n \n+    // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n@@ -211,7 +196,6 @@ fn check_fn(ccx: @crate_ctxt,\n           ret_ty: ret_ty,\n           indirect_ret_ty: indirect_ret_ty,\n           purity: purity,\n-          proto: proto,\n           infcx: infcx,\n           locals: locals,\n           mut blocks: [],\n@@ -708,74 +692,66 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(\n-        fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, fty: ty::t,\n+        fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, in_fty: ty::t,\n         args: [option<@ast::expr>]) -> {fty: ty::t, bot: bool} {\n \n         let mut bot = false;\n \n         // Replace all region parameters in the arguments and return\n         // type with fresh region variables.\n \n-        #debug[\"check_call_or_bind: before universal quant., fty=%s\",\n-               fcx.infcx.ty_to_str(fty)];\n+        #debug[\"check_call_or_bind: before universal quant., in_fty=%s\",\n+               fcx.infcx.ty_to_str(in_fty)];\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n         // process the types bound by the function but not by any nested\n         // functions.  Therefore, we match one level of structure.\n-        let fty =\n-            alt structure_of(fcx, sp, fty) {\n-              sty @ ty::ty_fn(inner_fty) {\n-                let all_tys = tys_in_fn_ty(inner_fty);\n-                universally_quantify_from_sty(fcx, sp, all_tys, sty)\n+        let fn_ty =\n+            alt structure_of(fcx, sp, in_fty) {\n+              sty @ ty::ty_fn(fn_ty) {\n+                replace_bound_regions_in_fn_ty(\n+                    fcx.ccx.tcx, @nil, none, fn_ty,\n+                    { |_br| fcx.infcx.next_region_var() }).fn_ty\n               }\n               sty {\n-                #debug[\"not a fn ty: %?\", sty];\n-\n-                // if not a function type, we're gonna' report an error at\n-                // some point, since the user is trying to call this thing\n-                fty\n+                // I would like to make this span_err, but it's\n+                // really hard due to the way that expr_bind() is\n+                // written.\n+                fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n+                                                 expected function or native \\\n+                                                 function but found \"\n+                                            + fcx.infcx.ty_to_str(in_fty));\n               }\n             };\n \n+        let fty = ty::mk_fn(fcx.tcx(), fn_ty);\n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n                fcx.infcx.ty_to_str(fty)];\n \n         let supplied_arg_count = vec::len(args);\n \n-        // Grab the argument types\n-        let arg_tys = alt structure_of(fcx, sp, fty) {\n-          ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n-            let expected_arg_count = vec::len(arg_tys);\n-            if expected_arg_count == supplied_arg_count {\n-                arg_tys.map { |a| a.ty }\n-            } else {\n-                fcx.ccx.tcx.sess.span_err(\n-                    sp, #fmt[\"this function takes %u parameter%s but %u \\\n-                              parameter%s supplied\", expected_arg_count,\n-                             if expected_arg_count == 1u {\n-                                 \"\"\n-                             } else {\n-                                 \"s\"\n-                             },\n-                             supplied_arg_count,\n-                             if supplied_arg_count == 1u {\n-                                 \" was\"\n-                             } else {\n-                                 \"s were\"\n-                             }]);\n-                fcx.infcx.next_ty_vars(supplied_arg_count)\n-            }\n-          }\n-\n-          _ {\n-            // I would like to make this span_err, but it's really hard due to\n-            // the way that expr_bind() is written.\n-            fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n-                                             expected function or native \\\n-                                             function but found \"\n-                                        + fcx.infcx.ty_to_str(fty));\n-          }\n+        // Grab the argument types, supplying fresh type variables\n+        // if the wrong number of arguments were supplied\n+        let expected_arg_count = vec::len(fn_ty.inputs);\n+        let arg_tys = if expected_arg_count == supplied_arg_count {\n+            fn_ty.inputs.map { |a| a.ty }\n+        } else {\n+            fcx.ccx.tcx.sess.span_err(\n+                sp, #fmt[\"this function takes %u parameter%s but %u \\\n+                          parameter%s supplied\", expected_arg_count,\n+                         if expected_arg_count == 1u {\n+                             \"\"\n+                         } else {\n+                             \"s\"\n+                         },\n+                         supplied_arg_count,\n+                         if supplied_arg_count == 1u {\n+                             \" was\"\n+                         } else {\n+                             \"s were\"\n+                         }]);\n+            fcx.infcx.next_ty_vars(supplied_arg_count)\n         };\n \n         // Check the arguments.\n@@ -1049,21 +1025,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n \n         // construct the function type\n-        let fty = ty::mk_fn(tcx,\n-                            astconv::ty_of_fn_decl(fcx, fcx, proto, decl,\n-                                                   expected_tys));\n+        let fn_ty = astconv::ty_of_fn_decl(fcx, fcx, proto,\n+                                           decl, expected_tys);\n+        let fty = ty::mk_fn(tcx, fn_ty);\n \n         #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n                expr_to_str(expr), fcx.infcx.ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n-        let ret_ty = ty::ty_fn_ret(fty);\n-        let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n-\n-        check_fn(fcx.ccx, proto, decl, body,\n-                 ret_ty, arg_tys, is_loop_body, some(fcx),\n-                 fcx.self_ty);\n+        check_fn(fcx.ccx, fcx.self_ty, fn_ty, decl, body,\n+                 is_loop_body, some(fcx));\n     }\n \n \n@@ -1825,7 +1797,6 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           ret_ty: rty,\n           indirect_ret_ty: none,\n           purity: ast::pure_fn,\n-          proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash(),\n           mut blocks: [],\n@@ -1865,7 +1836,6 @@ fn check_enum_variants(ccx: @crate_ctxt,\n           ret_ty: rty,\n           indirect_ret_ty: none,\n           purity: ast::pure_fn,\n-          proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash(),\n           mut blocks: [],"}, {"sha": "76a3acb702e872fb7e1a6406a198b7bf816ddb53", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e6b9db08841c5d215c56790e35f951a99275001d", "patch": "@@ -1,7 +1,6 @@\n /* Code to handle method lookups (which can be quite complex) */\n \n import syntax::ast_map;\n-import regionmanip::universally_quantify_from_sty;\n import middle::typeck::infer::methods; // next_ty_vars\n \n enum lookup = {"}, {"sha": "41451c9e15059b955d28061327538545bc7cb2fd", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e6b9db08841c5d215c56790e35f951a99275001d", "patch": "@@ -2,33 +2,40 @@ import syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n \n-// Extracts the bound regions from bound_tys and then replaces those same\n-// regions in `sty` with fresh region variables, returning the resulting type.\n-// Does not descend into fn types.  This is used when deciding whether an impl\n-// applies at a given call site.\n-fn universally_quantify_from_sty(fcx: @fn_ctxt,\n-                                 span: span,\n-                                 bound_tys: [ty::t],\n-                                 sty: ty::sty) -> ty::t {\n-\n-    #debug[\"universally_quantify_from_sty(bound_tys=%?)\",\n-           bound_tys.map {|x| fcx.infcx.ty_to_str(x) }];\n-    indent {||\n-        let tcx = fcx.tcx();\n-        let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |br|\n-            let rvar = fcx.infcx.next_region_var();\n-            #debug[\"Bound region %s maps to %s\",\n-                   bound_region_to_str(fcx.ccx.tcx, br),\n-                   region_to_str(fcx.ccx.tcx, rvar)];\n-            rvar\n-        };\n-        let t_res = ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n-            replace_bound_regions(tcx, span, isr, t)\n-        };\n-        #debug[\"Result of universal quant. is %s\",\n-               fcx.infcx.ty_to_str(t_res)];\n-        t_res\n-    }\n+fn replace_bound_regions_in_fn_ty(\n+    tcx: ty::ctxt,\n+    isr: isr_alist,\n+    self_ty: option<ty::t>,\n+    fn_ty: ty::fn_ty,\n+    mapf: fn(ty::bound_region) -> ty::region) -> {isr: isr_alist,\n+                                                  self_ty: option<ty::t>,\n+                                                  fn_ty: ty::fn_ty} {\n+\n+    let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n+    for self_ty.each { |t| all_tys += [t] }\n+\n+    #debug[\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n+           self_ty.map { |t| ty_to_str(tcx, t) },\n+           ty_to_str(tcx, ty::mk_fn(tcx, fn_ty)),\n+           all_tys.map { |t| ty_to_str(tcx, t) }];\n+    let _i = indenter();\n+\n+    let isr = collect_bound_regions_in_tys(tcx, isr, all_tys) { |br|\n+        #debug[\"br=%?\", br];\n+        mapf(br)\n+    };\n+    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty)) { |t|\n+        replace_bound_regions(tcx, isr, t)\n+    };\n+    let t_self = self_ty.map { |t| replace_bound_regions(tcx, isr, t) };\n+\n+    #debug[\"result of replace_bound_regions_in_fn_ty: self_ty=%?, fn_ty=%s\",\n+           t_self.map { |t| ty_to_str(tcx, t) },\n+           ty_to_str(tcx, t_fn)];\n+\n+    ret {isr: isr,\n+         self_ty: t_self,\n+         fn_ty: alt check ty::get(t_fn).struct { ty::ty_fn(o) {o} }};\n }\n \n // Takes `isr`, a mapping from in-scope region names (\"isr\"s) to their\n@@ -38,7 +45,6 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n // with the corresponding bindings in `isr`.\n fn replace_bound_regions(\n     tcx: ty::ctxt,\n-    span: span,\n     isr: isr_alist,\n     ty: ty::t) -> ty::t {\n \n@@ -58,8 +64,7 @@ fn replace_bound_regions(\n               // within that remain bound:\n               none if in_fn { r }\n               none {\n-                tcx.sess.span_bug(\n-                    span,\n+                tcx.sess.bug(\n                     #fmt[\"Bound region not found in \\\n                           in_scope_regions list: %s\",\n                          region_to_str(tcx, r)]);"}, {"sha": "8579da8ed9330764c55beac6be430a598d214629", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 22, "deletions": 63, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b9db08841c5d215c56790e35f951a99275001d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=e6b9db08841c5d215c56790e35f951a99275001d", "patch": "@@ -153,8 +153,7 @@ import syntax::ast::{ret_style};\n import util::ppaux::{ty_to_str, mt_to_str};\n import result::{result, extensions, ok, err, map_vec, map_vec2, iter_vec2};\n import ty::{mk_fn, type_is_bot};\n-import check::regionmanip::{collect_bound_regions_in_tys,\n-                            replace_bound_regions};\n+import check::regionmanip::{replace_bound_regions_in_fn_ty};\n import driver::session::session;\n import util::common::{indent, indenter};\n \n@@ -1622,72 +1621,32 @@ impl of combine for sub {\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n-\n-        // FIXME: This code is kinda redundant with\n-        // regionmanip::universally_quantify_from_sty, except for the\n-        // `sty` part.  Fix somehow?\n-\n-        // a_isr is a mapping from all the bound regions in `a` to\n-        // freshly created region variables for them.\n-        let a_isr =\n-            collect_bound_regions_in_tys(self.tcx,\n-                                         @nil,\n-                                         tys_in_fn_ty(a)) {\n-            |br|\n-\n-            // N.B.: The name of the bound region doesn't have\n-            // anything to do with the region variable that's created\n-            // for it.  The only thing we're doing with `br` here is\n-            // using it in the debug message.\n-            let rvar = self.infcx().next_region_var();\n-            #debug[\"Bound region %s maps to %s\",\n-                   bound_region_to_str(self.tcx, br),\n-                   region_to_str(self.tcx, rvar)];\n-            rvar\n+        let {fn_ty: a_fn_ty, _} = {\n+            replace_bound_regions_in_fn_ty(self.tcx, @nil, none, a) { |br|\n+                // N.B.: The name of the bound region doesn't have\n+                // anything to do with the region variable that's created\n+                // for it.  The only thing we're doing with `br` here is\n+                // using it in the debug message.\n+                let rvar = self.infcx().next_region_var();\n+                #debug[\"Bound region %s maps to %s\",\n+                       bound_region_to_str(self.tcx, br),\n+                       region_to_str(self.tcx, rvar)];\n+                rvar\n+            }\n         };\n \n-        let a_ty = replace_bound_regions(self.tcx,\n-                                         ast_util::dummy_sp(),\n-                                         a_isr,\n-                                         mk_fn(self.tcx, a));\n-        #debug[\"a_ty: %s\", self.infcx().ty_to_str(a_ty)];\n-\n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n+        let {fn_ty: b_fn_ty, _} = {\n+            replace_bound_regions_in_fn_ty(self.tcx, @nil, none, b) { |br|\n+                // FIXME: eventually re_skolemized (issue #2263)\n+                ty::re_bound(br)\n+            }\n+        };\n \n-        // a_isr is a mapping from all the bound regions in `b` to\n-        // the result of calling re_bound on them.\n-        let b_isr =\n-            collect_bound_regions_in_tys(self.tcx,\n-                                         @nil,\n-                                         tys_in_fn_ty(b)) {\n-            |br| ty::re_bound(br) };\n-            // FIXME: or maybe re_skolemized? What would that look like?\n-            // (issue #2263)\n-\n-        let b_ty = replace_bound_regions(self.tcx,\n-                                         ast_util::dummy_sp(),\n-                                         b_isr,\n-                                         mk_fn(self.tcx, b));\n-        #debug[\"b_ty: %s\", self.infcx().ty_to_str(b_ty)];\n-\n-        // Turn back into ty::fn_ty.\n-        alt (ty::get(a_ty).struct, ty::get(b_ty).struct) {\n-          (ty::ty_fn(a_fn_ty), ty::ty_fn(b_fn_ty)) {\n-            // Try to compare the supertype and subtype now that they've been\n-            // instantiated.\n-            super_fns(self, a_fn_ty, b_fn_ty)\n-\n-          }\n-          _ {\n-            // Shouldn't happen.\n-            self.infcx().tcx.sess.bug(\n-                #fmt[\"%s: at least one of %s and %s isn't a fn_ty\",\n-                     self.tag(),\n-                     self.infcx().ty_to_str(a_ty),\n-                     self.infcx().ty_to_str(b_ty)]);\n-          }\n-        }\n+        // Try to compare the supertype and subtype now that they've been\n+        // instantiated.\n+        super_fns(self, a_fn_ty, b_fn_ty)\n     }\n \n     // Traits please:"}]}