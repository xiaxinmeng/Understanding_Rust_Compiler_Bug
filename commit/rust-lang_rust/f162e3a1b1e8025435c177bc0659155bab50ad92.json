{"sha": "f162e3a1b1e8025435c177bc0659155bab50ad92", "node_id": "C_kwDOAAsO6NoAKGYxNjJlM2ExYjFlODAyNTQzNWMxNzdiYzA2NTkxNTViYWI1MGFkOTI", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-09T02:03:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-09T02:03:51Z"}, "message": "Rollup merge of #100508 - BoxyUwU:make_less_things_late_bound, r=nikomatsakis\n\navoid making substs of type aliases late bound when used as fn args\n\nfixes #47511\nfixes #85533\n(although I did not know theses issues existed when i was working on this :upside_down_face:)\n\ncurrently `Alias<...>` is treated the same as `Struct<...>` when deciding if generics should be late bound or early bound but this is not correct as `Alias` might normalize to a projection which does not constrain the generics.\n\nI think this needs more tests before merging\nmore explanation of PR [here](https://hackmd.io/v44a-QVjTIqqhK9uretyQg?view)\n\nHackmd inline for future readers:\n---\n\nThis assumes reader is familiar with the concept of early/late bound lifetimes. There's a section on rustc-dev-guide if not (although i think some details are a bit out of date)\n\n## problem & background\n\nNot all lifetimes on a fn can be late bound:\n```rust\nfn foo<'a>() -> &'a ();\nimpl<'a> Fn<()> for FooFnDef {\n    type Output = &'a (); // uh oh unconstrained lifetime\n}\n```\nso we make make them early bound\n```rust\nfn foo<'a>() -> &'a ();\nimpl<'a> Fn<()> for FooFnDef<'a> {// wow look at all that lifetimey\n     type Output = &'a ();\n}\n```\n(Closures have the same constraint however it is not enforced leading to soundness bugs, [#84385](https://github.com/rust-lang/rust/pull/84385) implements this \"downgrading late bound to early bound\" for closures)\n\nlifetimes on fn items are only late bound when they are \"constrained\" by the fn args:\n```rust\nfn foo<'a>(_: &'a ()) -> &'a ();\n//               late bound, not present on `FooFnItem`\n//               vv\nimpl<'a> Trait<(&'a (),)> for FooFnItem {\n    type Output = &'a ();\n}\n\n// projections do not constrain inputs\nfn bar<'a, T: Trait>(_: <T as Trait<'a>>::Assoc) -> &'a (); //  early bound\n                                                            //  vv\nimpl<'a, T: Trait> Fn<(<T as Trait<'a>>::Assoc,)> for BarFnItem<'a, T> {\n    type Output = &'a ();\n}\n```\n\ncurrent logic for determining if inputs \"constrain\" a lifetime works off of HIR so does not normalize aliases. It also assumes that any path with no self type constrains all its substs (i.e. `Foo<'a, u32>` has no self type but `T::Assoc` does). This falls apart for top level type aliases (see linked issues):\n\n```rust\ntype Alias<'a, T> = <T as Trait<'a>>::Assoc;\n//                      wow look its a path with no self type uwu\n//                      i bet that constrains `'a` so it should be latebound\n//                      vvvvvvvvvvv\nfn foo<'a, T: Trait>(_: Alias<'a, T>) -> &'a ();\n//                     `Alias` normalized to make things clearer\n//                     vvvvvvvvvvvvvvvvvvvvvvv\nimpl<'a, T: Trait> Fn<(<T as Trait<'a>>::Assoc,)> for FooFnDef<T> {\n    type Output = &'a ();\n    // oh no `'a` isnt constrained wah wah waaaah *trumbone noises*\n    // i think, idk what musical instrument that is\n}\n```\n\n## solution\n\nThe PR solves this by having the hir visitor that checks for lifetimes in constraining uses check if the path is a `DefKind::Alias`. If it is we \"\"normalize\"\" it by calling `type_of` and walking the returned type. This is a bit hacky as it requires a mapping between the substs on the path in hir, and the generics of the `type Alias<...>` which is on the ty layer.\n\nAlternative solutions may involve calculating the \"late boundness\" of lifetimes after/during astconv rather than relying on hir at all. We already have code to determine whether a lifetime SHOULD be late bound or not as this is currently how the error for `fn foo<'a, T: Trait>(_: Alias<'a, T>) -> &'a ();` gets emitted.\n\nIt is probably not possible to do this right now, late boundness is used by `generics_of` and `gather_explicit_predicates_of` as we currently do not put late bound lifetimes in `Generics`. Although this seems sus to me as the long term goal is to make all generics late bound which would result in `generics_of(function)` being empty? [#103448](https://github.com/rust-lang/rust/pull/103448) places all lifetimes in `Generics` regardless of late boundness so that may be a good step towards making this possible.", "tree": {"sha": "18ceabcaed776fd527cc9fac65dc2b764c078d93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ceabcaed776fd527cc9fac65dc2b764c078d93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f162e3a1b1e8025435c177bc0659155bab50ad92", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjawqHCRBK7hj4Ov3rIwAAw70IAFXf4UlD7YWMsufCcEpVBE6Y\n0RQSlRKclmw5AaOih3eUls8fhO6KNosh6OwOxVUrqLDN2F1yncm4X1oT588KUXwR\ngvfroS6m+i+yU0g04iFqeqqblQG63RS3KUgMtPBmig7j2LKroP4idukBC580Pli5\naT4sOEiKZ96Zk9RWAXVjtP1wAwhGdLXrKQW723Nenv/egeDPWJUOQHG+m2z0MQ8W\nMVGXJLyDHSUv5B7e006hxJRadm9VZj8FC5vw+RfPVV707Lahlx3MOUmA2cYeKtob\n52X/4dmyvdtOua96osYbsyiMtLD4+Gz8LWms6njZrEYVLeccjs7N8N4ju3yIi+A=\n=dKYX\n-----END PGP SIGNATURE-----\n", "payload": "tree 18ceabcaed776fd527cc9fac65dc2b764c078d93\nparent 8d36948b1519c77a54867523453fef3e0c3a648b\nparent 983a90d7160b5e6054827f42c0ecf9aa52cebcd4\nauthor Manish Goregaokar <manishsmail@gmail.com> 1667959431 -0500\ncommitter GitHub <noreply@github.com> 1667959431 -0500\n\nRollup merge of #100508 - BoxyUwU:make_less_things_late_bound, r=nikomatsakis\n\navoid making substs of type aliases late bound when used as fn args\n\nfixes #47511\nfixes #85533\n(although I did not know theses issues existed when i was working on this :upside_down_face:)\n\ncurrently `Alias<...>` is treated the same as `Struct<...>` when deciding if generics should be late bound or early bound but this is not correct as `Alias` might normalize to a projection which does not constrain the generics.\n\nI think this needs more tests before merging\nmore explanation of PR [here](https://hackmd.io/v44a-QVjTIqqhK9uretyQg?view)\n\nHackmd inline for future readers:\n---\n\nThis assumes reader is familiar with the concept of early/late bound lifetimes. There's a section on rustc-dev-guide if not (although i think some details are a bit out of date)\n\n## problem & background\n\nNot all lifetimes on a fn can be late bound:\n```rust\nfn foo<'a>() -> &'a ();\nimpl<'a> Fn<()> for FooFnDef {\n    type Output = &'a (); // uh oh unconstrained lifetime\n}\n```\nso we make make them early bound\n```rust\nfn foo<'a>() -> &'a ();\nimpl<'a> Fn<()> for FooFnDef<'a> {// wow look at all that lifetimey\n     type Output = &'a ();\n}\n```\n(Closures have the same constraint however it is not enforced leading to soundness bugs, [#84385](https://github.com/rust-lang/rust/pull/84385) implements this \"downgrading late bound to early bound\" for closures)\n\nlifetimes on fn items are only late bound when they are \"constrained\" by the fn args:\n```rust\nfn foo<'a>(_: &'a ()) -> &'a ();\n//               late bound, not present on `FooFnItem`\n//               vv\nimpl<'a> Trait<(&'a (),)> for FooFnItem {\n    type Output = &'a ();\n}\n\n// projections do not constrain inputs\nfn bar<'a, T: Trait>(_: <T as Trait<'a>>::Assoc) -> &'a (); //  early bound\n                                                            //  vv\nimpl<'a, T: Trait> Fn<(<T as Trait<'a>>::Assoc,)> for BarFnItem<'a, T> {\n    type Output = &'a ();\n}\n```\n\ncurrent logic for determining if inputs \"constrain\" a lifetime works off of HIR so does not normalize aliases. It also assumes that any path with no self type constrains all its substs (i.e. `Foo<'a, u32>` has no self type but `T::Assoc` does). This falls apart for top level type aliases (see linked issues):\n\n```rust\ntype Alias<'a, T> = <T as Trait<'a>>::Assoc;\n//                      wow look its a path with no self type uwu\n//                      i bet that constrains `'a` so it should be latebound\n//                      vvvvvvvvvvv\nfn foo<'a, T: Trait>(_: Alias<'a, T>) -> &'a ();\n//                     `Alias` normalized to make things clearer\n//                     vvvvvvvvvvvvvvvvvvvvvvv\nimpl<'a, T: Trait> Fn<(<T as Trait<'a>>::Assoc,)> for FooFnDef<T> {\n    type Output = &'a ();\n    // oh no `'a` isnt constrained wah wah waaaah *trumbone noises*\n    // i think, idk what musical instrument that is\n}\n```\n\n## solution\n\nThe PR solves this by having the hir visitor that checks for lifetimes in constraining uses check if the path is a `DefKind::Alias`. If it is we \"\"normalize\"\" it by calling `type_of` and walking the returned type. This is a bit hacky as it requires a mapping between the substs on the path in hir, and the generics of the `type Alias<...>` which is on the ty layer.\n\nAlternative solutions may involve calculating the \"late boundness\" of lifetimes after/during astconv rather than relying on hir at all. We already have code to determine whether a lifetime SHOULD be late bound or not as this is currently how the error for `fn foo<'a, T: Trait>(_: Alias<'a, T>) -> &'a ();` gets emitted.\n\nIt is probably not possible to do this right now, late boundness is used by `generics_of` and `gather_explicit_predicates_of` as we currently do not put late bound lifetimes in `Generics`. Although this seems sus to me as the long term goal is to make all generics late bound which would result in `generics_of(function)` being empty? [#103448](https://github.com/rust-lang/rust/pull/103448) places all lifetimes in `Generics` regardless of late boundness so that may be a good step towards making this possible.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f162e3a1b1e8025435c177bc0659155bab50ad92", "html_url": "https://github.com/rust-lang/rust/commit/f162e3a1b1e8025435c177bc0659155bab50ad92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f162e3a1b1e8025435c177bc0659155bab50ad92/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d36948b1519c77a54867523453fef3e0c3a648b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d36948b1519c77a54867523453fef3e0c3a648b", "html_url": "https://github.com/rust-lang/rust/commit/8d36948b1519c77a54867523453fef3e0c3a648b"}, {"sha": "983a90d7160b5e6054827f42c0ecf9aa52cebcd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/983a90d7160b5e6054827f42c0ecf9aa52cebcd4", "html_url": "https://github.com/rust-lang/rust/commit/983a90d7160b5e6054827f42c0ecf9aa52cebcd4"}], "stats": {"total": 213, "additions": 184, "deletions": 29}, "files": [{"sha": "c64177eea3f831f388189c3879f89ef9aa9c8567", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 99, "deletions": 5, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt, TypeSuperVisitable, TypeVisitor};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -1781,7 +1781,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n \n     let mut late_bound = FxIndexSet::default();\n \n-    let mut constrained_by_input = ConstrainedCollector::default();\n+    let mut constrained_by_input = ConstrainedCollector { regions: Default::default(), tcx };\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n     }\n@@ -1834,12 +1834,65 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n     debug!(?late_bound);\n     return Some(tcx.arena.alloc(late_bound));\n \n-    #[derive(Default)]\n-    struct ConstrainedCollector {\n+    /// Visits a `ty::Ty` collecting information about what generic parameters are constrained.\n+    ///\n+    /// The visitor does not operate on `hir::Ty` so that it can be called on the rhs of a `type Alias<...> = ...;`\n+    /// which may live in a separate crate so there would not be any hir available. Instead we use the `type_of`\n+    /// query to obtain a `ty::Ty` which will be present even in cross crate scenarios. It also naturally\n+    /// handles cycle detection as we go through the query system.\n+    ///\n+    /// This is necessary in the first place for the following case:\n+    /// ```\n+    /// type Alias<'a, T> = <T as Trait<'a>>::Assoc;\n+    /// fn foo<'a>(_: Alias<'a, ()>) -> Alias<'a, ()> { ... }\n+    /// ```\n+    ///\n+    /// If we conservatively considered `'a` unconstrained then we could break users who had written code before\n+    /// we started correctly handling aliases. If we considered `'a` constrained then it would become late bound\n+    /// causing an error during astconv as the `'a` is not constrained by the input type `<() as Trait<'a>>::Assoc`\n+    /// but appears in the output type `<() as Trait<'a>>::Assoc`.\n+    ///\n+    /// We must therefore \"look into\" the `Alias` to see whether we should consider `'a` constrained or not.\n+    ///\n+    /// See #100508 #85533 #47511 for additional context\n+    struct ConstrainedCollectorPostAstConv {\n+        arg_is_constrained: Box<[bool]>,\n+    }\n+\n+    use std::ops::ControlFlow;\n+    use ty::Ty;\n+    impl<'tcx> TypeVisitor<'tcx> for ConstrainedCollectorPostAstConv {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<!> {\n+            match t.kind() {\n+                ty::Param(param_ty) => {\n+                    self.arg_is_constrained[param_ty.index as usize] = true;\n+                }\n+                ty::Projection(_) => return ControlFlow::Continue(()),\n+                _ => (),\n+            }\n+            t.super_visit_with(self)\n+        }\n+\n+        fn visit_const(&mut self, _: ty::Const<'tcx>) -> ControlFlow<!> {\n+            ControlFlow::Continue(())\n+        }\n+\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<!> {\n+            debug!(\"r={:?}\", r.kind());\n+            if let ty::RegionKind::ReEarlyBound(region) = r.kind() {\n+                self.arg_is_constrained[region.index as usize] = true;\n+            }\n+\n+            ControlFlow::Continue(())\n+        }\n+    }\n+\n+    struct ConstrainedCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n         regions: FxHashSet<LocalDefId>,\n     }\n \n-    impl<'v> Visitor<'v> for ConstrainedCollector {\n+    impl<'v> Visitor<'v> for ConstrainedCollector<'_> {\n         fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n             match ty.kind {\n                 hir::TyKind::Path(\n@@ -1850,6 +1903,47 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                     // (defined above)\n                 }\n \n+                hir::TyKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { res: Res::Def(DefKind::TyAlias, alias_def), segments, span },\n+                )) => {\n+                    // See comments on `ConstrainedCollectorPostAstConv` for why this arm does not just consider\n+                    // substs to be unconstrained.\n+                    let generics = self.tcx.generics_of(alias_def);\n+                    let mut walker = ConstrainedCollectorPostAstConv {\n+                        arg_is_constrained: vec![false; generics.params.len()].into_boxed_slice(),\n+                    };\n+                    walker.visit_ty(self.tcx.type_of(alias_def));\n+\n+                    match segments.last() {\n+                        Some(hir::PathSegment { args: Some(args), .. }) => {\n+                            let tcx = self.tcx;\n+                            for constrained_arg in\n+                                args.args.iter().enumerate().flat_map(|(n, arg)| {\n+                                    match walker.arg_is_constrained.get(n) {\n+                                        Some(true) => Some(arg),\n+                                        Some(false) => None,\n+                                        None => {\n+                                            tcx.sess.delay_span_bug(\n+                                                *span,\n+                                                format!(\n+                                                    \"Incorrect generic arg count for alias {:?}\",\n+                                                    alias_def\n+                                                ),\n+                                            );\n+                                            None\n+                                        }\n+                                    }\n+                                })\n+                            {\n+                                self.visit_generic_arg(constrained_arg);\n+                            }\n+                        }\n+                        Some(_) => (),\n+                        None => bug!(\"Path with no segments or self type\"),\n+                    }\n+                }\n+\n                 hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently"}, {"sha": "9998ee0e8d0c69c801528a509eb6371d10af4f86", "filename": "src/test/ui/issues/issue-47511.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d36948b1519c77a54867523453fef3e0c3a648b/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d36948b1519c77a54867523453fef3e0c3a648b/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr?ref=8d36948b1519c77a54867523453fef3e0c3a648b", "patch": "@@ -1,18 +0,0 @@\n-error[E0581]: return type references an anonymous lifetime, which is not constrained by the fn input types\n-  --> $DIR/issue-47511.rs:8:15\n-   |\n-LL | fn f(_: X) -> X {\n-   |               ^\n-   |\n-   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n-   = note: consider introducing a named lifetime parameter\n-\n-error[E0581]: return type references lifetime `'a`, which is not constrained by the fn input types\n-  --> $DIR/issue-47511.rs:12:23\n-   |\n-LL | fn g<'a>(_: X<'a>) -> X<'a> {\n-   |                       ^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0581`."}, {"sha": "5b9dc0e43087c1e8ec5f6e4894bf574406e649b3", "filename": "src/test/ui/late-bound-lifetimes/auxiliary/upstream_alias.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fauxiliary%2Fupstream_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fauxiliary%2Fupstream_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fauxiliary%2Fupstream_alias.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -0,0 +1,5 @@\n+pub trait Trait<'a> {\n+    type Assoc;\n+}\n+\n+pub type Alias<'a, T> = <T as Trait<'a>>::Assoc;"}, {"sha": "4154c279243236dac6c800e776743609e2d605df", "filename": "src/test/ui/late-bound-lifetimes/cross_crate_alias.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fcross_crate_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fcross_crate_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fcross_crate_alias.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:upstream_alias.rs\n+// check-pass\n+\n+extern crate upstream_alias;\n+\n+fn foo<'a, T: for<'b> upstream_alias::Trait<'b>>(_: upstream_alias::Alias<'a, T>) -> &'a () {\n+    todo!()\n+}\n+\n+fn main() {}"}, {"sha": "e56a34218e231c82d7f1c07e59cd449ee6706979", "filename": "src/test/ui/late-bound-lifetimes/downgraded_to_early_through_alias.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fdowngraded_to_early_through_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fdowngraded_to_early_through_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fdowngraded_to_early_through_alias.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+trait Gats<'a> {\n+    type Assoc;\n+    type Assoc2;\n+}\n+\n+trait Trait: for<'a> Gats<'a> {\n+    fn foo<'a>(_: &mut <Self as Gats<'a>>::Assoc) -> <Self as Gats<'a>>::Assoc2;\n+}\n+\n+impl<'a> Gats<'a> for () {\n+    type Assoc = &'a u32;\n+    type Assoc2 = ();\n+}\n+\n+type GatsAssoc<'a, T> = <T as Gats<'a>>::Assoc;\n+type GatsAssoc2<'a, T> = <T as Gats<'a>>::Assoc2;\n+\n+impl Trait for () {\n+    fn foo<'a>(_: &mut GatsAssoc<'a, Self>) -> GatsAssoc2<'a, Self> {}\n+}\n+\n+fn main() {}"}, {"sha": "7894435154082c91d2779695f04fbf5575fe22c9", "filename": "src/test/ui/late-bound-lifetimes/issue-47511.rs", "status": "renamed", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fissue-47511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fissue-47511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fissue-47511.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -1,9 +1,4 @@\n-// check-fail\n-// known-bug: #47511\n-\n-// Regression test for #47511: anonymous lifetimes can appear\n-// unconstrained in a return type, but only if they appear just once\n-// in the input, as the input to a projection.\n+// check-pass\n \n fn f(_: X) -> X {\n     unimplemented!()", "previous_filename": "src/test/ui/issues/issue-47511.rs"}, {"sha": "91839673c1f7a492fc28e9e63af62d9b1c1b395a", "filename": "src/test/ui/late-bound-lifetimes/late_bound_through_alias.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Flate_bound_through_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Flate_bound_through_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Flate_bound_through_alias.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+fn f(_: X) -> X {\n+    unimplemented!()\n+}\n+\n+fn g<'a>(_: X<'a>) -> X<'a> {\n+    unimplemented!()\n+}\n+\n+type X<'a> = &'a ();\n+\n+fn main() {\n+    let _: for<'a> fn(X<'a>) -> X<'a> = g;\n+    let _: for<'a> fn(X<'a>) -> X<'a> = f;\n+}"}, {"sha": "0b331e2039f25a94134cc41749ec3d415260722a", "filename": "src/test/ui/late-bound-lifetimes/mismatched_arg_count.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fmismatched_arg_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fmismatched_arg_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fmismatched_arg_count.rs?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -0,0 +1,12 @@\n+// ensures that we don't ICE when there are too many args supplied to the alias.\n+\n+trait Trait<'a> {\n+    type Assoc;\n+}\n+\n+type Alias<'a, T> = <T as Trait<'a>>::Assoc;\n+\n+fn bar<'a, T: Trait<'a>>(_: Alias<'a, 'a, T>) {}\n+//~^ error: this type alias takes 1 lifetime argument but 2 lifetime arguments were supplied\n+\n+fn main() {}"}, {"sha": "3704d9bb957ed2af6a2bfe18408047dfbb9175fe", "filename": "src/test/ui/late-bound-lifetimes/mismatched_arg_count.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fmismatched_arg_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f162e3a1b1e8025435c177bc0659155bab50ad92/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fmismatched_arg_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fmismatched_arg_count.stderr?ref=f162e3a1b1e8025435c177bc0659155bab50ad92", "patch": "@@ -0,0 +1,17 @@\n+error[E0107]: this type alias takes 1 lifetime argument but 2 lifetime arguments were supplied\n+  --> $DIR/mismatched_arg_count.rs:9:29\n+   |\n+LL | fn bar<'a, T: Trait<'a>>(_: Alias<'a, 'a, T>) {}\n+   |                             ^^^^^     -- help: remove this lifetime argument\n+   |                             |\n+   |                             expected 1 lifetime argument\n+   |\n+note: type alias defined here, with 1 lifetime parameter: `'a`\n+  --> $DIR/mismatched_arg_count.rs:7:6\n+   |\n+LL | type Alias<'a, T> = <T as Trait<'a>>::Assoc;\n+   |      ^^^^^ --\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}]}