{"sha": "4717f07989fe4a5d8e473961b86a613d4bb07f35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MTdmMDc5ODlmZTRhNWQ4ZTQ3Mzk2MWI4NmE2MTNkNGJiMDdmMzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T00:36:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T00:36:20Z"}, "message": "rollup merge of #20248: steveklabnik/gh20038\n\nA part of #20038\n\nThis is just the beginning of what needs to be done, but it's some of it.\n\n/cc @aturon", "tree": {"sha": "5f71acec09255b1fe107f248e5c4b7e88b0ace6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f71acec09255b1fe107f248e5c4b7e88b0ace6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4717f07989fe4a5d8e473961b86a613d4bb07f35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4717f07989fe4a5d8e473961b86a613d4bb07f35", "html_url": "https://github.com/rust-lang/rust/commit/4717f07989fe4a5d8e473961b86a613d4bb07f35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4717f07989fe4a5d8e473961b86a613d4bb07f35/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fabf421f059a47ffa1faf570823c8511e73c4e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fabf421f059a47ffa1faf570823c8511e73c4e2", "html_url": "https://github.com/rust-lang/rust/commit/6fabf421f059a47ffa1faf570823c8511e73c4e2"}, {"sha": "b8ffad5964e328340de0c03779577eb14caa16fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8ffad5964e328340de0c03779577eb14caa16fc", "html_url": "https://github.com/rust-lang/rust/commit/b8ffad5964e328340de0c03779577eb14caa16fc"}], "stats": {"total": 473, "additions": 233, "deletions": 240}, "files": [{"sha": "29c98e22ee9788d70fb19cecbcc0d9bb929ad5c4", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -1,6 +1,6 @@\n-% The Rust Tasks and Communication Guide\n+% The Rust Threads and Communication Guide\n \n-**NOTE** This guide is badly out of date an needs to be rewritten.\n+**NOTE** This guide is badly out of date and needs to be rewritten.\n \n # Introduction\n \n@@ -9,36 +9,36 @@ primitives. This guide will describe the concurrency model in Rust, how it\n relates to the Rust type system, and introduce the fundamental library\n abstractions for constructing concurrent programs.\n \n-Tasks provide failure isolation and recovery. When a fatal error occurs in Rust\n+Threads provide failure isolation and recovery. When a fatal error occurs in Rust\n code as a result of an explicit call to `panic!()`, an assertion failure, or\n-another invalid operation, the runtime system destroys the entire task. Unlike\n+another invalid operation, the runtime system destroys the entire thread. Unlike\n in languages such as Java and C++, there is no way to `catch` an exception.\n-Instead, tasks may monitor each other to see if they panic.\n+Instead, threads may monitor each other to see if they panic.\n \n-Tasks use Rust's type system to provide strong memory safety guarantees.  In\n-particular, the type system guarantees that tasks cannot induce a data race\n+Threads use Rust's type system to provide strong memory safety guarantees.  In\n+particular, the type system guarantees that threads cannot induce a data race\n from shared mutable state.\n \n # Basics\n \n-At its simplest, creating a task is a matter of calling the `spawn` function\n-with a closure argument. `spawn` executes the closure in the new task.\n+At its simplest, creating a thread is a matter of calling the `spawn` function\n+with a closure argument. `spawn` executes the closure in the new thread.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n \n-// Print something profound in a different task using a named function\n-fn print_message() { println!(\"I am running in a different task!\"); }\n+// Print something profound in a different thread using a named function\n+fn print_message() { println!(\"I am running in a different thread!\"); }\n spawn(print_message);\n \n // Alternatively, use a `move ||` expression instead of a named function.\n // `||` expressions evaluate to an unnamed closure. The `move` keyword\n // indicates that the closure should take ownership of any variables it\n // touches.\n-spawn(move || println!(\"I am also running in a different task!\"));\n+spawn(move || println!(\"I am also running in a different thread!\"));\n ```\n \n-In Rust, a task is not a concept that appears in the language semantics.\n+In Rust, a thread is not a concept that appears in the language semantics.\n Instead, Rust's type system provides all the tools necessary to implement safe\n concurrency: particularly, ownership. The language leaves the implementation\n details to the standard library.\n@@ -49,26 +49,26 @@ argument a closure (of type `F`) that it will run exactly once. This\n closure is limited to capturing `Send`-able data from its environment\n (that is, data which is deeply owned). Limiting the closure to `Send`\n ensures that `spawn` can safely move the entire closure and all its\n-associated state into an entirely different task for execution.\n+associated state into an entirely different thread for execution.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n-# fn generate_task_number() -> int { 0 }\n+# use std::thread::spawn;\n+# fn generate_thread_number() -> int { 0 }\n // Generate some state locally\n-let child_task_number = generate_task_number();\n+let child_thread_number = generate_thread_number();\n \n spawn(move || {\n-    // Capture it in the remote task. The `move` keyword indicates\n-    // that this closure should move `child_task_number` into its\n+    // Capture it in the remote thread. The `move` keyword indicates\n+    // that this closure should move `child_thread_number` into its\n     // environment, rather than capturing a reference into the\n     // enclosing stack frame.\n-    println!(\"I am child number {}\", child_task_number);\n+    println!(\"I am child number {}\", child_thread_number);\n });\n ```\n \n ## Communication\n \n-Now that we have spawned a new task, it would be nice if we could communicate\n+Now that we have spawned a new thread, it would be nice if we could communicate\n with it. For this, we use *channels*. A channel is simply a pair of endpoints:\n one for sending messages and another for receiving messages.\n \n@@ -78,7 +78,7 @@ of a channel, and a **receiver** is the receiving endpoint. Consider the followi\n example of calculating two results concurrently:\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n \n@@ -102,12 +102,12 @@ into its component parts).\n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n ```\n \n-The child task will use the sender to send data to the parent task, which will\n+The child thread will use the sender to send data to the parent thread, which will\n wait to receive the data on the receiver. The next statement spawns the child\n-task.\n+thread.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n spawn(move || {\n@@ -116,10 +116,10 @@ spawn(move || {\n });\n ```\n \n-Notice that the creation of the task closure transfers `tx` to the child task\n+Notice that the creation of the thread closure transfers `tx` to the child thread\n implicitly: the closure captures `tx` in its environment. Both `Sender` and\n-`Receiver` are sendable types and may be captured into tasks or otherwise\n-transferred between them. In the example, the child task runs an expensive\n+`Receiver` are sendable types and may be captured into threads or otherwise\n+transferred between them. In the example, the child thread runs an expensive\n computation, then sends the result over the captured channel.\n \n Finally, the parent continues with some other expensive computation, then waits\n@@ -137,7 +137,7 @@ The `Sender` and `Receiver` pair created by `channel` enables efficient\n communication between a single sender and a single receiver, but multiple\n senders cannot use a single `Sender` value, and multiple receivers cannot use a\n single `Receiver` value.  What if our example needed to compute multiple\n-results across a number of tasks? The following program is ill-typed:\n+results across a number of threads? The following program is ill-typed:\n \n ```{rust,ignore}\n # fn some_expensive_computation() -> int { 42 }\n@@ -160,7 +160,7 @@ Instead we can clone the `tx`, which allows for multiple senders.\n let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n-    // Create a new channel handle to distribute to the child task\n+    // Create a new channel handle to distribute to the child thread\n     let child_tx = tx.clone();\n     spawn(move || {\n         child_tx.send(some_expensive_computation(init_val));\n@@ -172,7 +172,7 @@ let result = rx.recv() + rx.recv() + rx.recv();\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n-tasks to send data to a single receiver. It upgrades the channel internally in\n+threads to send data to a single receiver. It upgrades the channel internally in\n order to allow this functionality, which means that channels that are not\n cloned can avoid the overhead required to handle multiple senders. But this\n fact has no bearing on the channel's usage: the upgrade is transparent.\n@@ -182,9 +182,9 @@ simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n \n-// Create a vector of ports, one for each child task\n+// Create a vector of ports, one for each child thread\n let rxs = Vec::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n     spawn(move || {\n@@ -256,18 +256,18 @@ fn main() {\n \n ## Sharing without copying: Arc\n \n-To share data between tasks, a first approach would be to only use channel as\n+To share data between threads, a first approach would be to only use channel as\n we have seen previously. A copy of the data to share would then be made for\n-each task. In some cases, this would add up to a significant amount of wasted\n+each thread. In some cases, this would add up to a significant amount of wasted\n memory and would require copying the same data more than necessary.\n \n To tackle this issue, one can use an Atomically Reference Counted wrapper\n (`Arc`) as implemented in the `sync` library of Rust. With an Arc, the data\n-will no longer be copied for each task. The Arc acts as a reference to the\n+will no longer be copied for each thread. The Arc acts as a reference to the\n shared data and only this reference is shared and cloned.\n \n Here is a small example showing how to use Arcs. We wish to run concurrently\n-several computations on a single large vector of floats. Each task needs the\n+several computations on a single large vector of floats. Each thread needs the\n full vector to perform its duty.\n \n ```{rust,ignore}\n@@ -284,10 +284,10 @@ fn main() {\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n-        let task_numbers = numbers_arc.clone();\n+        let thread_numbers = numbers_arc.clone();\n \n         spawn(move || {\n-            println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n+            println!(\"{}-norm = {}\", num, pnorm(thread_numbers.as_slice(), num));\n         });\n     }\n }\n@@ -306,8 +306,8 @@ let numbers_arc = Arc::new(numbers);\n # }\n ```\n \n-and a clone is captured for each task via a procedure. This only copies\n-the wrapper and not its contents. Within the task's procedure, the captured\n+and a clone is captured for each thread via a procedure. This only copies\n+the wrapper and not its contents. Within the thread's procedure, the captured\n Arc reference can be used as a shared reference to the underlying vector as\n if it were local.\n \n@@ -319,29 +319,29 @@ if it were local.\n # let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n # let num = 4;\n-let task_numbers = numbers_arc.clone();\n+let thread_numbers = numbers_arc.clone();\n spawn(move || {\n-    // Capture task_numbers and use it as if it was the underlying vector\n-    println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n+    // Capture thread_numbers and use it as if it was the underlying vector\n+    println!(\"{}-norm = {}\", num, pnorm(thread_numbers.as_slice(), num));\n });\n # }\n ```\n \n-# Handling task panics\n+# Handling thread panics\n \n Rust has a built-in mechanism for raising exceptions. The `panic!()` macro\n (which can also be written with an error string as an argument: `panic!(\n ~reason)`) and the `assert!` construct (which effectively calls `panic!()` if a\n-boolean expression is false) are both ways to raise exceptions. When a task\n-raises an exception, the task unwinds its stack\u2014running destructors and\n+boolean expression is false) are both ways to raise exceptions. When a thread\n+raises an exception, the thread unwinds its stack\u2014running destructors and\n freeing memory along the way\u2014and then exits. Unlike exceptions in C++,\n-exceptions in Rust are unrecoverable within a single task: once a task panics,\n+exceptions in Rust are unrecoverable within a single thread: once a thread panics,\n there is no way to \"catch\" the exception.\n \n-While it isn't possible for a task to recover from panicking, tasks may notify\n+While it isn't possible for a thread to recover from panicking, threads may notify\n each other if they panic. The simplest way of handling a panic is with the\n `try` function, which is similar to `spawn`, but immediately blocks and waits\n-for the child task to finish. `try` returns a value of type\n+for the child thread to finish. `try` returns a value of type\n `Result<T, Box<Any + Send>>`. `Result` is an `enum` type with two variants:\n `Ok` and `Err`. In this case, because the type arguments to `Result` are `int`\n and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n@@ -364,19 +364,19 @@ assert!(result.is_err());\n \n Unlike `spawn`, the function spawned using `try` may return a value, which\n `try` will dutifully propagate back to the caller in a [`Result`] enum. If the\n-child task terminates successfully, `try` will return an `Ok` result; if the\n-child task panics, `try` will return an `Error` result.\n+child thread terminates successfully, `try` will return an `Ok` result; if the\n+child thread panics, `try` will return an `Error` result.\n \n [`Result`]: std/result/index.html\n \n-> *Note:* A panicked task does not currently produce a useful error\n+> *Note:* A panicked thread does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the\n-> future, it may be possible for tasks to intercept the value passed to\n+> future, it may be possible for threads to intercept the value passed to\n > `panic!()`.\n \n But not all panics are created equal. In some cases you might need to abort\n the entire program (perhaps you're writing an assert which, if it trips,\n indicates an unrecoverable logic error); in other cases you might want to\n contain the panic at a certain boundary (perhaps a small piece of input from\n the outside world, which you happen to be processing in parallel, is malformed\n-such that the processing task cannot proceed).\n+such that the processing thread cannot proceed)."}, {"sha": "dd0af170228c350934cb764c814634b2bdee2188", "filename": "src/doc/guide.md", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -3032,7 +3032,7 @@ test foo ... FAILED\n failures:\n \n ---- foo stdout ----\n-        task 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n+        thread 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n \n \n \n@@ -3041,7 +3041,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n+thread '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n ```\n \n Lots of output! Let's break this down:\n@@ -3084,7 +3084,7 @@ failed, especially as we accumulate more tests.\n failures:\n \n ---- foo stdout ----\n-        task 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n+        thread 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n \n \n \n@@ -3093,7 +3093,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n+thread '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n ```\n \n After all the tests run, Rust will show us any output from our failed tests.\n@@ -4259,7 +4259,7 @@ is that a moving closure always takes ownership of all variables that\n it uses. Ordinary closures, in contrast, just create a reference into\n the enclosing stack frame. Moving closures are most useful with Rust's\n concurrency features, and so we'll just leave it at this for\n-now. We'll talk about them more in the \"Tasks\" section of the guide.\n+now. We'll talk about them more in the \"Threads\" section of the guide.\n \n ## Accepting closures as arguments\n \n@@ -5209,9 +5209,7 @@ as you can see, there's no overhead of deciding which version to call here,\n hence 'statically dispatched'. The downside is that we have two copies of\n the same function, so our binary is a little bit larger.\n \n-# Tasks\n-\n-**NOTE**: this section is currently out of date and will be rewritten soon.\n+# Threads \n \n Concurrency and parallelism are topics that are of increasing interest to a\n broad subsection of software developers. Modern computers are often multi-core,\n@@ -5220,24 +5218,22 @@ processor. Rust's semantics lend themselves very nicely to solving a number of\n issues that programmers have with concurrency. Many concurrency errors that are\n runtime errors in other languages are compile-time errors in Rust.\n \n-Rust's concurrency primitive is called a **task**. Tasks are similar to\n-threads, and do not share memory in an unsafe manner, preferring message\n-passing to communicate. It's worth noting that tasks are implemented as a\n-library, and not part of the language. This means that in the future, other\n-concurrency libraries can be written for Rust to help in specific scenarios.\n-Here's an example of creating a task:\n+Rust's concurrency primitive is called a **thread**. It's worth noting that\n+threads are implemented as a library, and not part of the language. This means\n+that in the future, other concurrency libraries can be written for Rust to help\n+in specific scenarios. Here's an example of creating a thread:\n \n ```{rust,ignore}\n spawn(move || {\n-    println!(\"Hello from a task!\");\n+    println!(\"Hello from a thread!\");\n });\n ```\n \n The `spawn` function takes a closure as an argument, and runs that\n-closure in a new task. Typically, you will want to use a moving\n+closure in a new thread. Typically, you will want to use a moving\n closure, so that the closure takes ownership of any variables that it\n touches.  This implies that those variables are not usable from the\n-parent task after the child task is spawned:\n+parent thread after the child thread is spawned:\n \n ```{rust,ignore}\n let mut x = vec![1i, 2i, 3i];\n@@ -5253,15 +5249,15 @@ println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n other languages would let us do this, but it's not safe to do\n so. Rust's borrow checker catches the error.\n \n-If tasks were only able to capture these values, they wouldn't be very useful.\n-Luckily, tasks can communicate with each other through **channel**s. Channels\n+If threads were only able to capture these values, they wouldn't be very useful.\n+Luckily, threads can communicate with each other through **channel**s. Channels\n work like this:\n \n ```{rust,ignore}\n let (tx, rx) = channel();\n \n spawn(move || {\n-    tx.send(\"Hello from a task!\".to_string());\n+    tx.send(\"Hello from a thread!\".to_string());\n });\n \n let message = rx.recv();\n@@ -5274,14 +5270,14 @@ receive the message on the `Receiver<T>` side with the `recv()` method.  This\n method blocks until it gets a message. There's a similar method, `.try_recv()`,\n which returns an `Result<T, TryRecvError>` and does not block.\n \n-If you want to send messages to the task as well, create two channels!\n+If you want to send messages to the thread as well, create two channels!\n \n ```{rust,ignore}\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n spawn(move || {\n-    tx1.send(\"Hello from a task!\".to_string());\n+    tx1.send(\"Hello from a thread!\".to_string());\n     let message = rx2.recv();\n     println!(\"{}\", message);\n });\n@@ -5292,9 +5288,9 @@ println!(\"{}\", message);\n tx2.send(\"Goodbye from main!\".to_string());\n ```\n \n-The closure has one sending end and one receiving end, and the main\n-task has one of each as well. Now they can talk back and forth in\n-whatever way they wish.\n+The closure has one sending end and one receiving end, and the main thread has\n+one of each as well. Now they can talk back and forth in whatever way they\n+wish.\n \n Notice as well that because `Sender` and `Receiver` are generic, while you can\n pass any kind of information through the channel, the ends are strongly typed.\n@@ -5333,7 +5329,7 @@ we'll just get the value immediately.\n \n ## Success and failure\n \n-Tasks don't always succeed, they can also panic. A task that wishes to panic\n+Threads don't always succeed, they can also panic. A thread that wishes to panic\n can call the `panic!` macro, passing a message:\n \n ```{rust,ignore}\n@@ -5342,14 +5338,14 @@ spawn(move || {\n });\n ```\n \n-If a task panics, it is not possible for it to recover. However, it can\n-notify other tasks that it has panicked. We can do this with `task::try`:\n+If a thread panics, it is not possible for it to recover. However, it can\n+notify other thread that it has panicked. We can do this with `thread::try`:\n \n ```{rust,ignore}\n-use std::task;\n+use std::thread;\n use std::rand;\n \n-let result = task::try(move || {\n+let result = thread::try(move || {\n     if rand::random() {\n         println!(\"OK\");\n     } else {\n@@ -5358,7 +5354,7 @@ let result = task::try(move || {\n });\n ```\n \n-This task will randomly panic or succeed. `task::try` returns a `Result`\n+This thread will randomly panic or succeed. `thread::try` returns a `Result`\n type, so we can handle the response like any other computation that may\n fail.\n "}, {"sha": "e54bf0eb24282d3670d04549bbf752b6a73ce4ab", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -58,7 +58,7 @@ a guide that can help you out:\n * [Strings](guide-strings.html)\n * [Pointers](guide-pointers.html)\n * [Crates and modules](guide-crates.html)\n-* [Tasks and Communication](guide-tasks.html)\n+* [Threads and Communication](guide-threads.html)\n * [Error Handling](guide-error-handling.html)\n * [Foreign Function Interface](guide-ffi.html)\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)"}, {"sha": "50470ef3fce382b4f1c665524d72ac8f4d1629e1", "filename": "src/doc/reference.md", "status": "modified", "additions": 51, "deletions": 54, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -899,8 +899,8 @@ mirrors the module hierarchy.\n // Load the `vec` module from `vec.rs`\n mod vec;\n \n-mod task {\n-    // Load the `local_data` module from `task/local_data.rs`\n+mod thread {\n+    // Load the `local_data` module from `thread/local_data.rs`\n     mod local_data;\n }\n ```\n@@ -909,9 +909,9 @@ The directories and files used for loading external file modules can be\n influenced with the `path` attribute.\n \n ```{.ignore}\n-#[path = \"task_files\"]\n-mod task {\n-    // Load the `local_data` module from `task_files/tls.rs`\n+#[path = \"thread_files\"]\n+mod thread {\n+    // Load the `local_data` module from `thread_files/tls.rs`\n     #[path = \"tls.rs\"]\n     mod local_data;\n }\n@@ -1188,7 +1188,7 @@ code safe, in the surrounding context.\n Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n or implement features not directly present in the language. For example, Rust\n provides the language features necessary to implement memory-safe concurrency\n-in the language but the implementation of tasks and message passing is in the\n+in the language but the implementation of threads and message passing is in the\n standard library.\n \n Rust's type system is a conservative approximation of the dynamic safety\n@@ -1500,7 +1500,7 @@ be modified by the program. One of Rust's goals is to make concurrency bugs\n hard to run into, and this is obviously a very large source of race conditions\n or other bugs. For this reason, an `unsafe` block is required when either\n reading or writing a mutable static variable. Care should be taken to ensure\n-that modifications to a mutable static are safe with respect to other tasks\n+that modifications to a mutable static are safe with respect to other threads\n running in the same process.\n \n Mutable statics are still very useful, however. They can be used with C\n@@ -2253,11 +2253,11 @@ A complete list of the built-in language items follows:\n * `drop`\n   : Have destructors.\n * `send`\n-  : Able to be sent across task boundaries.\n+  : Able to be sent across thread boundaries.\n * `sized`\n   : Has a size known at compile time.\n * `sync`\n-  : Able to be safely shared between tasks when aliased.\n+  : Able to be safely shared between threads when aliased.\n \n #### Operators\n \n@@ -2621,7 +2621,7 @@ The currently implemented features of the reference compiler are:\n                    LLVM's implementation which works in concert with the kernel\n                    loader and dynamic linker. This is not necessarily available\n                    on all platforms, and usage of it is discouraged (rust\n-                   focuses more on task-local data instead of thread-local\n+                   focuses more on thread-local data instead of thread-local\n                    data).\n \n * `trace_macros` - Allows use of the `trace_macros` macro, which is a nasty\n@@ -2939,7 +2939,7 @@ array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can\n be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access is\n-bounds-checked at run-time. When the check fails, it will put the task in a\n+bounds-checked at run-time. When the check fails, it will put the thread in a\n _panicked state_.\n \n ```{should-fail}\n@@ -3950,7 +3950,7 @@ Types in Rust are categorized into kinds, based on various properties of the\n components of the type. The kinds are:\n \n * `Send`\n-  : Types of this kind can be safely sent between tasks.\n+  : Types of this kind can be safely sent between threads.\n     This kind includes scalars, boxes, procs, and\n     structural types containing only other owned types.\n     All `Send` types are `'static`.\n@@ -3998,21 +3998,21 @@ to sendable.\n \n # Memory and concurrency models\n \n-Rust has a memory model centered around concurrently-executing _tasks_. Thus\n+Rust has a memory model centered around concurrently-executing _threads_. Thus\n its memory model and its concurrency model are best discussed simultaneously,\n as parts of each only make sense when considered from the perspective of the\n other.\n \n When reading about the memory model, keep in mind that it is partitioned in\n-order to support tasks; and when reading about tasks, keep in mind that their\n+order to support threads; and when reading about threads, keep in mind that their\n isolation and communication mechanisms are only possible due to the ownership\n and lifetime semantics of the memory model.\n \n ## Memory model\n \n A Rust program's memory consists of a static set of *items*, a set of\n-[tasks](#tasks) each with its own *stack*, and a *heap*. Immutable portions of\n-the heap may be shared between tasks, mutable portions may not.\n+[threads](#threads) each with its own *stack*, and a *heap*. Immutable portions of\n+the heap may be shared between threads, mutable portions may not.\n \n Allocations in the stack consist of *slots*, and allocations in the heap\n consist of *boxes*.\n@@ -4023,8 +4023,8 @@ The _items_ of a program are those functions, modules and types that have their\n value calculated at compile-time and stored uniquely in the memory image of the\n rust process. Items are neither dynamically allocated nor freed.\n \n-A task's _stack_ consists of activation frames automatically allocated on entry\n-to each function as the task executes. A stack allocation is reclaimed when\n+A thread's _stack_ consists of activation frames automatically allocated on entry\n+to each function as the thread executes. A stack allocation is reclaimed when\n control leaves the frame containing it.\n \n The _heap_ is a general term that describes boxes.  The lifetime of an\n@@ -4034,10 +4034,10 @@ in the heap, heap allocations may outlive the frame they are allocated within.\n \n ### Memory ownership\n \n-A task owns all memory it can *safely* reach through local variables, as well\n+A thread owns all memory it can *safely* reach through local variables, as well\n as boxes and references.\n \n-When a task sends a value that has the `Send` trait to another task, it loses\n+When a thread sends a value that has the `Send` trait to another thread, it loses\n ownership of the value sent and can no longer refer to it. This is statically\n guaranteed by the combined use of \"move semantics\", and the compiler-checked\n _meaning_ of the `Send` trait: it is only instantiated for (transitively)\n@@ -4046,12 +4046,12 @@ sendable kinds of data constructor and pointers, never including references.\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-When a task finishes, its stack is necessarily empty and it therefore has no\n+When a thread finishes, its stack is necessarily empty and it therefore has no\n references to any boxes; the remainder of its heap is immediately freed.\n \n ### Memory slots\n \n-A task's stack contains slots.\n+A thread's stack contains slots.\n \n A _slot_ is a component of a stack frame, either a function parameter, a\n [temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n@@ -4105,72 +4105,69 @@ let y = x;\n // attempting to use `x` will result in an error here\n ```\n \n-## Tasks\n+## Threads\n \n-An executing Rust program consists of a tree of tasks. A Rust _task_ consists\n-of an entry function, a stack, a set of outgoing communication channels and\n-incoming communication ports, and ownership of some portion of the heap of a\n-single operating-system process.\n+Rust's primary concurrency mechanism is called a **thread**.\n \n-### Communication between tasks\n+### Communication between threads\n \n-Rust tasks are isolated and generally unable to interfere with one another's\n+Rust threads are isolated and generally unable to interfere with one another's\n memory directly, except through [`unsafe` code](#unsafe-functions).  All\n-contact between tasks is mediated by safe forms of ownership transfer, and data\n+contact between threads is mediated by safe forms of ownership transfer, and data\n races on memory are prohibited by the type system.\n \n-When you wish to send data between tasks, the values are restricted to the\n+When you wish to send data between threads, the values are restricted to the\n [`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n-kind ensures that no references move between tasks. Thus access to an entire\n+kind ensures that no references move between threads. Thus access to an entire\n data structure can be mediated through its owning \"root\" value; no further\n locking or copying is required to avoid data races within the substructure of\n such a value.\n \n-### Task lifecycle\n+### Thread\n \n-The _lifecycle_ of a task consists of a finite set of states and events that\n-cause transitions between the states. The lifecycle states of a task are:\n+The _lifecycle_ of a threads consists of a finite set of states and events that\n+cause transitions between the states. The lifecycle states of a thread are:\n \n * running\n * blocked\n * panicked\n * dead\n \n-A task begins its lifecycle &mdash; once it has been spawned &mdash; in the\n+A thread begins its lifecycle &mdash; once it has been spawned &mdash; in the\n *running* state. In this state it executes the statements of its entry\n function, and any functions called by the entry function.\n \n-A task may transition from the *running* state to the *blocked* state any time\n+A thread may transition from the *running* state to the *blocked* state any time\n it makes a blocking communication call. When the call can be completed &mdash;\n when a message arrives at a sender, or a buffer opens to receive a message\n-&mdash; then the blocked task will unblock and transition back to *running*.\n+&mdash; then the blocked thread will unblock and transition back to *running*.\n \n-A task may transition to the *panicked* state at any time, due being killed by\n+A thread may transition to the *panicked* state at any time, due being killed by\n some external event or internally, from the evaluation of a `panic!()` macro.\n-Once *panicking*, a task unwinds its stack and transitions to the *dead* state.\n-Unwinding the stack of a task is done by the task itself, on its own control\n+Once *panicking*, a thread unwinds its stack and transitions to the *dead* state.\n+Unwinding the stack of a thread is done by the thread itself, on its own control\n stack. If a value with a destructor is freed during unwinding, the code for the\n-destructor is run, also on the task's control stack. Running the destructor\n+destructor is run, also on the thread's control stack. Running the destructor\n code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions. The original task\n+destructor code to cause any subsequent state transitions. The original thread \n of unwinding and panicking thereby may suspend temporarily, and may involve\n (recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n outermost unwinding activity will continue until the stack is unwound and the\n-task transitions to the *dead* state. There is no way to \"recover\" from task\n-panics. Once a task has temporarily suspended its unwinding in the *panicking*\n+thread transitions to the *dead* state. There is no way to \"recover\" from thread \n+panics. Once a thread has temporarily suspended its unwinding in the *panicking*\n state, a panic occurring from within this destructor results in *hard* panic.\n A hard panic currently results in the process aborting.\n \n-A task in the *dead* state cannot transition to other states; it exists only to\n-have its termination status inspected by other tasks, and/or to await\n+A thread in the *dead* state cannot transition to other states; it exists only to\n+have its termination status inspected by other threads, and/or to await\n reclamation when the last reference to it drops.\n \n # Runtime services, linkage and debugging\n \n The Rust _runtime_ is a relatively compact collection of Rust code that\n-provides fundamental services and datatypes to all Rust tasks at run-time. It\n+provides fundamental services and datatypes to all Rust threads at run-time. It\n is smaller and simpler than many modern language runtimes. It is tightly\n-integrated into the language's execution model of memory, tasks, communication\n+integrated into the language's execution model of memory, threads, communication\n and logging.\n \n ### Memory allocation\n@@ -4181,23 +4178,23 @@ environment and releases them back to its environment when they are no longer\n needed. The default implementation of the service-provider interface consists\n of the C runtime functions `malloc` and `free`.\n \n-The runtime memory-management system, in turn, supplies Rust tasks with\n+The runtime memory-management system, in turn, supplies Rust threads with\n facilities for allocating releasing stacks, as well as allocating and freeing\n heap data.\n \n ### Built in types\n \n The runtime provides C and Rust code to assist with various built-in types,\n such as arrays, strings, and the low level communication system (ports,\n-channels, tasks).\n+channels, threads).\n \n Support for other built-in types such as simple types, tuples and enums is\n open-coded by the Rust compiler.\n \n-### Task scheduling and communication\n+### Thread scheduling and communication\n \n-The runtime provides code to manage inter-task communication. This includes\n-the system of task-lifecycle state transitions depending on the contents of\n+The runtime provides code to manage inter-thread communication. This includes\n+the system of thread-lifecycle state transitions depending on the contents of\n queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n communication facilities."}, {"sha": "214fae02ce27210e3010f41ec6cdda38c2c65fea", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task-local reference-counted boxes (the `Rc<T>` type).\n+//! Thread-local reference-counted boxes (the `Rc<T>` type).\n //!\n //! The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic,\n //! and will occur as soon as the last owner is gone. It is marked as non-sendable because it"}, {"sha": "e20404bf63891431031c6306c5f5eaf4fcaad563", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -540,7 +540,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     match cfg.spawn(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n-            // Task panicked without emitting a fatal diagnostic\n+            // Thread panicked without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n                 let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n "}, {"sha": "292f3e056dd5017408f5d3d448fcb254e8373254", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -18,7 +18,7 @@\n //! See the `distributions` submodule for sampling random numbers from\n //! distributions like normal and exponential.\n //!\n-//! # Task-local RNG\n+//! # Thread-local RNG\n //!\n //! There is built-in support for a RNG associated with each task stored\n //! in task-local storage. This RNG can be accessed via `task_rng`, or"}, {"sha": "e877dd5c6aab813ba5689070940299b667d5df1a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -53,7 +53,7 @@ pub mod args;\n mod at_exit_imp;\n mod libunwind;\n \n-/// The default error code of the rust runtime if the main task panics instead\n+/// The default error code of the rust runtime if the main thread panics instead\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: int = 101;\n \n@@ -137,9 +137,9 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n ///\n /// The procedure passed to this function will be executed as part of the\n /// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other tasks have exited.\n+/// after all other threads have exited.\n ///\n-/// The procedure is *not* executed with a local `Task` available to it, so\n+/// The procedure is *not* executed with a local `Thread` available to it, so\n /// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n /// This is meant for \"bare bones\" usage to clean up runtime details, this is\n /// not meant as a general-purpose \"let's clean everything up\" function."}, {"sha": "773322e4f57f18d5850f3cede5896a037bb5d85b", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -36,7 +36,7 @@ use sys_common::stack;\n use rt::unwind;\n use rt::unwind::Unwinder;\n \n-/// State associated with Rust tasks.\n+/// State associated with Rust threads\n ///\n /// This structure is currently undergoing major changes, and is\n /// likely to be move/be merged with a `Thread` structure.\n@@ -50,14 +50,14 @@ pub struct Task {\n     awoken: bool,            // used to prevent spurious wakeups\n \n     // This field holds the known bounds of the stack in (lo, hi) form. Not all\n-    // native tasks necessarily know their precise bounds, hence this is\n+    // native threads necessarily know their precise bounds, hence this is\n     // optional.\n     stack_bounds: (uint, uint),\n \n     stack_guard: uint\n }\n \n-// Once a task has entered the `Armed` state it must be destroyed via `drop`,\n+// Once a thread has entered the `Armed` state it must be destroyed via `drop`,\n // and no other method. This state is used to track this transition.\n #[deriving(PartialEq)]\n enum TaskState {\n@@ -67,31 +67,31 @@ enum TaskState {\n }\n \n pub struct TaskOpts {\n-    /// Invoke this procedure with the result of the task when it finishes.\n+    /// Invoke this procedure with the result of the thread when it finishes.\n     pub on_exit: Option<Thunk<Result>>,\n-    /// A name for the task-to-be, for identification in panic messages\n+    /// A name for the thread-to-be, for identification in panic messages\n     pub name: Option<SendStr>,\n-    /// The size of the stack for the spawned task\n+    /// The size of the stack for the spawned thread\n     pub stack_size: Option<uint>,\n }\n \n-/// Indicates the manner in which a task exited.\n+/// Indicates the manner in which a thread exited.\n ///\n-/// A task that completes without panicking is considered to exit successfully.\n+/// A thread that completes without panicking is considered to exit successfully.\n ///\n /// If you wish for this result's delivery to block until all\n-/// children tasks complete, recommend using a result future.\n+/// children threads complete, recommend using a result future.\n pub type Result = ::core::result::Result<(), Box<Any + Send>>;\n \n-/// A handle to a blocked task. Usually this means having the Box<Task>\n-/// pointer by ownership, but if the task is killable, a killer can steal it\n+/// A handle to a blocked thread. Usually this means having the Box<Task>\n+/// pointer by ownership, but if the thread is killable, a killer can steal it\n /// at any time.\n pub enum BlockedTask {\n     Owned(Box<Task>),\n     Shared(Arc<AtomicUint>),\n }\n \n-/// Per-task state related to task death, killing, panic, etc.\n+/// Per-thread state related to thread death, killing, panic, etc.\n pub struct Death {\n     pub on_exit: Option<Thunk<Result>>,\n }\n@@ -101,7 +101,7 @@ pub struct BlockedTasks {\n }\n \n impl Task {\n-    /// Creates a new uninitialized task.\n+    /// Creates a new uninitialized thread.\n     pub fn new(stack_bounds: Option<(uint, uint)>, stack_guard: Option<uint>) -> Task {\n         Task {\n             unwinder: Unwinder::new(),\n@@ -153,17 +153,17 @@ impl Task {\n         })\n     }\n \n-    /// Consumes ownership of a task, runs some code, and returns the task back.\n+    /// Consumes ownership of a thread, runs some code, and returns the thread back.\n     ///\n     /// This function can be used as an emulated \"try/catch\" to interoperate\n     /// with the rust runtime at the outermost boundary. It is not possible to\n     /// use this function in a nested fashion (a try/catch inside of another\n     /// try/catch). Invoking this function is quite cheap.\n     ///\n-    /// If the closure `f` succeeds, then the returned task can be used again\n+    /// If the closure `f` succeeds, then the returned thread can be used again\n     /// for another invocation of `run`. If the closure `f` panics then `self`\n     /// will be internally destroyed along with all of the other associated\n-    /// resources of this task. The `on_exit` callback is invoked with the\n+    /// resources of this thread. The `on_exit` callback is invoked with the\n     /// cause of panic (not returned here). This can be discovered by querying\n     /// `is_destroyed()`.\n     ///\n@@ -172,44 +172,44 @@ impl Task {\n     /// guaranteed to return if it panicks. Care should be taken to ensure that\n     /// stack references made by `f` are handled appropriately.\n     ///\n-    /// It is invalid to call this function with a task that has been previously\n+    /// It is invalid to call this function with a thread that has been previously\n     /// destroyed via a failed call to `run`.\n     pub fn run(mut self: Box<Task>, f: ||) -> Box<Task> {\n-        assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n+        assert!(!self.is_destroyed(), \"cannot re-use a destroyed thread\");\n \n         // First, make sure that no one else is in TLS. This does not allow\n         // recursive invocations of run(). If there's no one else, then\n         // relinquish ownership of ourselves back into TLS.\n         if Local::exists(None::<Task>) {\n-            panic!(\"cannot run a task recursively inside another\");\n+            panic!(\"cannot run a thread recursively inside another\");\n         }\n         self.state = Armed;\n         Local::put(self);\n \n         // There are two primary reasons that general try/catch is unsafe. The\n         // first is that we do not support nested try/catch. The above check for\n-        // an existing task in TLS is sufficient for this invariant to be\n+        // an existing thread in TLS is sufficient for this invariant to be\n         // upheld. The second is that unwinding while unwinding is not defined.\n-        // We take care of that by having an 'unwinding' flag in the task\n+        // We take care of that by having an 'unwinding' flag in the thread\n         // itself. For these reasons, this unsafety should be ok.\n         let result = unsafe { unwind::try(f) };\n \n-        // After running the closure given return the task back out if it ran\n-        // successfully, or clean up the task if it panicked.\n+        // After running the closure given return the thread back out if it ran\n+        // successfully, or clean up the thread if it panicked.\n         let task: Box<Task> = Local::take();\n         match result {\n             Ok(()) => task,\n             Err(cause) => { task.cleanup(Err(cause)) }\n         }\n     }\n \n-    /// Destroy all associated resources of this task.\n+    /// Destroy all associated resources of this thread.\n     ///\n-    /// This function will perform any necessary clean up to prepare the task\n+    /// This function will perform any necessary clean up to prepare the thread\n     /// for destruction. It is required that this is called before a `Task`\n     /// falls out of scope.\n     ///\n-    /// The returned task cannot be used for running any more code, but it may\n+    /// The returned thread cannot be used for running any more code, but it may\n     /// be used to extract the runtime as necessary.\n     pub fn destroy(self: Box<Task>) -> Box<Task> {\n         if self.is_destroyed() {\n@@ -219,14 +219,14 @@ impl Task {\n         }\n     }\n \n-    /// Cleans up a task, processing the result of the task as appropriate.\n+    /// Cleans up a thread, processing the result of the thread as appropriate.\n     ///\n-    /// This function consumes ownership of the task, deallocating it once it's\n+    /// This function consumes ownership of the thread, deallocating it once it's\n     /// done being processed. It is assumed that TLD and the local heap have\n     /// already been destroyed and/or annihilated.\n     fn cleanup(mut self: Box<Task>, result: Result) -> Box<Task> {\n         // After taking care of the data above, we need to transmit the result\n-        // of this task.\n+        // of this thread.\n         let what_to_do = self.death.on_exit.take();\n         Local::put(self);\n \n@@ -235,15 +235,15 @@ impl Task {\n         //        if this panics, this will also likely abort the runtime.\n         //\n         //        This closure is currently limited to a channel send via the\n-        //        standard library's task interface, but this needs\n+        //        standard library's thread interface, but this needs\n         //        reconsideration to whether it's a reasonable thing to let a\n-        //        task to do or not.\n+        //        thread to do or not.\n         match what_to_do {\n             Some(f) => { f.invoke(result) }\n             None => { drop(result) }\n         }\n \n-        // Now that we're done, we remove the task from TLS and flag it for\n+        // Now that we're done, we remove the thread from TLS and flag it for\n         // destruction.\n         let mut task: Box<Task> = Local::take();\n         task.state = Destroyed;\n@@ -253,7 +253,7 @@ impl Task {\n     /// Queries whether this can be destroyed or not.\n     pub fn is_destroyed(&self) -> bool { self.state == Destroyed }\n \n-    /// Deschedules the current task, invoking `f` `amt` times. It is not\n+    /// Deschedules the current thread, invoking `f` `amt` times. It is not\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n     //\n@@ -262,31 +262,31 @@ impl Task {\n     // shared state. Additionally, all of the violations are protected with a\n     // mutex, so in theory there are no races.\n     //\n-    // The first thing we need to do is to get a pointer to the task's internal\n-    // mutex. This address will not be changing (because the task is allocated\n-    // on the heap). We must have this handle separately because the task will\n+    // The first thing we need to do is to get a pointer to the thread's internal\n+    // mutex. This address will not be changing (because the thread is allocated\n+    // on the heap). We must have this handle separately because the thread will\n     // have its ownership transferred to the given closure. We're guaranteed,\n     // however, that this memory will remain valid because *this* is the current\n-    // task's execution thread.\n+    // thread's execution thread.\n     //\n-    // The next weird part is where ownership of the task actually goes. We\n+    // The next weird part is where ownership of the thread actually goes. We\n     // relinquish it to the `f` blocking function, but upon returning this\n-    // function needs to replace the task back in TLS. There is no communication\n-    // from the wakeup thread back to this thread about the task pointer, and\n-    // there's really no need to. In order to get around this, we cast the task\n+    // function needs to replace the thread back in TLS. There is no communication\n+    // from the wakeup thread back to this thread about the thread pointer, and\n+    // there's really no need to. In order to get around this, we cast the thread\n     // to a `uint` which is then used at the end of this function to cast back\n     // to a `Box<Task>` object. Naturally, this looks like it violates\n     // ownership semantics in that there may be two `Box<Task>` objects.\n     //\n     // The fun part is that the wakeup half of this implementation knows to\n-    // \"forget\" the task on the other end. This means that the awakening half of\n+    // \"forget\" the thread on the other end. This means that the awakening half of\n     // things silently relinquishes ownership back to this thread, but not in a\n-    // way that the compiler can understand. The task's memory is always valid\n-    // for both tasks because these operations are all done inside of a mutex.\n+    // way that the compiler can understand. The thread's memory is always valid\n+    // for both threads because these operations are all done inside of a mutex.\n     //\n     // You'll also find that if blocking fails (the `f` function hands the\n     // BlockedTask back to us), we will `mem::forget` the handles. The\n-    // reasoning for this is the same logic as above in that the task silently\n+    // reasoning for this is the same logic as above in that the thread silently\n     // transfers ownership via the `uint`, not through normal compiler\n     // semantics.\n     //\n@@ -319,11 +319,11 @@ impl Task {\n                 let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n \n-                // Apply the given closure to all of the \"selectable tasks\",\n+                // Apply the given closure to all of the \"selectable threads\",\n                 // bailing on the first one that produces an error. Note that\n                 // care must be taken such that when an error is occurred, we\n-                // may not own the task, so we may still have to wait for the\n-                // task to become available. In other words, if task.wake()\n+                // may not own the thread, so we may still have to wait for the\n+                // thread to become available. In other words, if thread.wake()\n                 // returns `None`, then someone else has ownership and we must\n                 // wait for their signal.\n                 match iter.map(f).filter_map(|a| a.err()).next() {\n@@ -342,15 +342,15 @@ impl Task {\n                     guard.wait();\n                 }\n             }\n-            // put the task back in TLS, and everything is as it once was.\n+            // put the thread back in TLS, and everything is as it once was.\n             Local::put(mem::transmute(me));\n         }\n     }\n \n-    /// Wakes up a previously blocked task. This function can only be\n-    /// called on tasks that were previously blocked in `deschedule`.\n+    /// Wakes up a previously blocked thread. This function can only be\n+    /// called on threads that were previously blocked in `deschedule`.\n     //\n-    // See the comments on `deschedule` for why the task is forgotten here, and\n+    // See the comments on `deschedule` for why the thread is forgotten here, and\n     // why it's valid to do so.\n     pub fn reawaken(mut self: Box<Task>) {\n         unsafe {\n@@ -362,21 +362,21 @@ impl Task {\n         }\n     }\n \n-    /// Yields control of this task to another task. This function will\n+    /// Yields control of this thread to another thread. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n-    /// opportunity to allow other tasks a chance to run.\n+    /// opportunity to allow other threads a chance to run.\n     pub fn yield_now() {\n         Thread::yield_now();\n     }\n \n-    /// Returns the stack bounds for this task in (lo, hi) format. The stack\n-    /// bounds may not be known for all tasks, so the return value may be\n+    /// Returns the stack bounds for this thread in (lo, hi) format. The stack\n+    /// bounds may not be known for all threads, so the return value may be\n     /// `None`.\n     pub fn stack_bounds(&self) -> (uint, uint) {\n         self.stack_bounds\n     }\n \n-    /// Returns the stack guard for this task, if known.\n+    /// Returns the stack guard for this thread, if known.\n     pub fn stack_guard(&self) -> Option<uint> {\n         if self.stack_guard != 0 {\n             Some(self.stack_guard)\n@@ -385,9 +385,9 @@ impl Task {\n         }\n     }\n \n-    /// Consume this task, flagging it as a candidate for destruction.\n+    /// Consume this thread, flagging it as a candidate for destruction.\n     ///\n-    /// This function is required to be invoked to destroy a task. A task\n+    /// This function is required to be invoked to destroy a thread. A thread\n     /// destroyed through a normal drop will abort.\n     pub fn drop(mut self) {\n         self.state = Destroyed;\n@@ -396,7 +396,7 @@ impl Task {\n \n impl Drop for Task {\n     fn drop(&mut self) {\n-        rtdebug!(\"called drop for a task: {}\", self as *mut Task as uint);\n+        rtdebug!(\"called drop for a thread: {}\", self as *mut Task as uint);\n         rtassert!(self.state != Armed);\n     }\n }\n@@ -414,7 +414,7 @@ impl Iterator<BlockedTask> for BlockedTasks {\n }\n \n impl BlockedTask {\n-    /// Returns Some if the task was successfully woken; None if already killed.\n+    /// Returns Some if the thread was successfully woken; None if already killed.\n     pub fn wake(self) -> Option<Box<Task>> {\n         match self {\n             Owned(task) => Some(task),\n@@ -427,7 +427,7 @@ impl BlockedTask {\n         }\n     }\n \n-    /// Reawakens this task if ownership is acquired. If finer-grained control\n+    /// Reawakens this thread if ownership is acquired. If finer-grained control\n     /// is desired, use `wake` instead.\n     pub fn reawaken(self) {\n         self.wake().map(|t| t.reawaken());\n@@ -438,12 +438,12 @@ impl BlockedTask {\n     #[cfg(not(test))] pub fn trash(self) { }\n     #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n \n-    /// Create a blocked task, unless the task was already killed.\n+    /// Create a blocked thread, unless the thread was already killed.\n     pub fn block(task: Box<Task>) -> BlockedTask {\n         Owned(task)\n     }\n \n-    /// Converts one blocked task handle to a list of many handles to the same.\n+    /// Converts one blocked thread handle to a list of many handles to the same.\n     pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> {\n         let arc = match self {\n             Owned(task) => {\n@@ -543,7 +543,7 @@ mod test {\n         drop(Task::new(None, None));\n     }\n \n-    // Task blocking tests\n+    // Thread blocking tests\n \n     #[test]\n     fn block_and_wake() {"}, {"sha": "9b57dcc9e18bfc941cb4657cf198738ff620097d", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -79,7 +79,7 @@ struct Exception {\n \n pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n \n-// Variables used for invoking callbacks when a task starts to unwind.\n+// Variables used for invoking callbacks when a thread starts to unwind.\n //\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n@@ -106,14 +106,14 @@ thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n ///\n /// * This is not safe to call in a nested fashion. The unwinding\n ///   interface for Rust is designed to have at most one try/catch block per\n-///   task, not multiple. No runtime checking is currently performed to uphold\n+///   thread, not multiple. No runtime checking is currently performed to uphold\n ///   this invariant, so this function is not safe. A nested try/catch block\n ///   may result in corruption of the outer try/catch block's state, especially\n-///   if this is used within a task itself.\n+///   if this is used within a thread itself.\n ///\n-/// * It is not sound to trigger unwinding while already unwinding. Rust tasks\n+/// * It is not sound to trigger unwinding while already unwinding. Rust threads\n ///   have runtime checks in place to ensure this invariant, but it is not\n-///   guaranteed that a rust task is in place when invoking this function.\n+///   guaranteed that a rust thread is in place when invoking this function.\n ///   Unwinding twice can lead to resource leaks where some destructors are not\n ///   run.\n pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n@@ -203,7 +203,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n // _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n //\n // This is pretty close to Rust's exception handling approach, except that Rust\n-// does have a single \"catch-all\" handler at the bottom of each task's stack.\n+// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n // So we have two versions of the personality routine:\n // - rust_eh_personality, used by all cleanup landing pads, which never catches,\n //   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n@@ -570,7 +570,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n     // Currently this means that panic!() on OOM will invoke this code path,\n     // but then again we're not really ready for panic on OOM anyway. If\n     // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this task instead of the task that's\n+    // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n     // see below for why we do the `Any` coercion here.\n@@ -593,7 +593,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     static INIT: Once = ONCE_INIT;\n     INIT.doit(|| unsafe { register(failure::on_fail); });\n \n-    // First, invoke call the user-defined callbacks triggered on task panic.\n+    // First, invoke call the user-defined callbacks triggered on thread panic.\n     //\n     // By the time that we see a callback has been registered (by reading\n     // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n@@ -621,18 +621,18 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n-        // unwinding or otherwise exiting the task cleanly.\n+        // unwinding or otherwise exiting the thread cleanly.\n         rterrln!(\"thread panicked while panicking. aborting.\");\n         unsafe { intrinsics::abort() }\n     }\n     PANICKING.with(|s| s.set(true));\n     rust_panic(msg);\n }\n \n-/// Register a callback to be invoked when a task unwinds.\n+/// Register a callback to be invoked when a thread unwinds.\n ///\n /// This is an unsafe and experimental API which allows for an arbitrary\n-/// callback to be invoked when a task panics. This callback is invoked on both\n+/// callback to be invoked when a thread panics. This callback is invoked on both\n /// the initial unwinding and a double unwinding if one occurs. Additionally,\n /// the local `Task` will be in place for the duration of the callback, and\n /// the callback must ensure that it remains in place once the callback returns."}, {"sha": "ee534f6cdde3ecf135ad0e2590d597448cd88f1d", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4717f07989fe4a5d8e473961b86a613d4bb07f35/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=4717f07989fe4a5d8e473961b86a613d4bb07f35", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Abstraction of a task pool for basic parallelism.\n+//! Abstraction of a thread pool for basic parallelism.\n \n use core::prelude::*;\n \n@@ -45,9 +45,9 @@ impl<'a> Drop for Sentinel<'a> {\n     }\n }\n \n-/// A task pool used to execute functions in parallel.\n+/// A thread pool used to execute functions in parallel.\n ///\n-/// Spawns `n` worker tasks and replenishes the pool if any worker tasks\n+/// Spawns `n` worker threads and replenishes the pool if any worker threads\n /// panic.\n ///\n /// # Example\n@@ -69,34 +69,34 @@ impl<'a> Drop for Sentinel<'a> {\n /// assert_eq!(rx.iter().take(8u).sum(), 8u);\n /// ```\n pub struct TaskPool {\n-    // How the taskpool communicates with subtasks.\n+    // How the threadpool communicates with subthreads.\n     //\n-    // This is the only such Sender, so when it is dropped all subtasks will\n+    // This is the only such Sender, so when it is dropped all subthreads will\n     // quit.\n     jobs: Sender<Thunk>\n }\n \n impl TaskPool {\n-    /// Spawns a new task pool with `tasks` tasks.\n+    /// Spawns a new thread pool with `threads` threads.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `tasks` is 0.\n-    pub fn new(tasks: uint) -> TaskPool {\n-        assert!(tasks >= 1);\n+    /// This function will panic if `threads` is 0.\n+    pub fn new(threads: uint) -> TaskPool {\n+        assert!(threads >= 1);\n \n         let (tx, rx) = channel::<Thunk>();\n         let rx = Arc::new(Mutex::new(rx));\n \n-        // Taskpool tasks.\n-        for _ in range(0, tasks) {\n+        // Threadpool threads\n+        for _ in range(0, threads) {\n             spawn_in_pool(rx.clone());\n         }\n \n         TaskPool { jobs: tx }\n     }\n \n-    /// Executes the function `job` on a task in the pool.\n+    /// Executes the function `job` on a thread in the pool.\n     pub fn execute<F>(&self, job: F)\n         where F : FnOnce(), F : Send\n     {\n@@ -106,7 +106,7 @@ impl TaskPool {\n \n fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n     Thread::spawn(move |:| {\n-        // Will spawn a new task on panic unless it is cancelled.\n+        // Will spawn a new thread on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n \n         loop {\n@@ -165,12 +165,12 @@ mod test {\n \n         let pool = TaskPool::new(TEST_TASKS);\n \n-        // Panic all the existing tasks.\n+        // Panic all the existing threads.\n         for _ in range(0, TEST_TASKS) {\n             pool.execute(move|| -> () { panic!() });\n         }\n \n-        // Ensure new tasks were spawned to compensate.\n+        // Ensure new threads were spawned to compensate.\n         let (tx, rx) = channel();\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n@@ -189,7 +189,7 @@ mod test {\n         let pool = TaskPool::new(TEST_TASKS);\n         let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n \n-        // Panic all the existing tasks in a bit.\n+        // Panic all the existing threads in a bit.\n         for _ in range(0, TEST_TASKS) {\n             let waiter = waiter.clone();\n             pool.execute(move|| {"}]}