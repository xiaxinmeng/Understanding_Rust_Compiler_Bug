{"sha": "141fca60061d85494fcb719a4c8237eaf6c7c134", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MWZjYTYwMDYxZDg1NDk0ZmNiNzE5YTRjODIzN2VhZjZjN2MxMzQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-26T18:07:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-26T18:07:21Z"}, "message": "Merge #2419\n\n2419: Remove ns-polymorphic type_for_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6a7abab05196f1cd3bc2185ab7f02ac89e413c69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a7abab05196f1cd3bc2185ab7f02ac89e413c69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/141fca60061d85494fcb719a4c8237eaf6c7c134", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3WnZCRBK7hj4Ov3rIwAAdHIIAD6tkU/d6w9Ja6M22fonq6+a\nIpq9iM90JVsHNdsbCadhshRfxeMU8BtK3c7WVINZ5nEjGkZ3aTDFvhaQllGo1VJz\nEL+oENhN2aWdBSheVeFjLDH1oC1aclTnnyMroqFzCAjItJwKTwlBNWOJpQltd5hx\nZRzsLIMw6AcWYB+3z7BdbUT+G6S6xLrRR/nh9SpjRdLKRRyL3OekNCGXP1LKlDZ4\n+0/2e2WjkNjvXFPLEL76Lljuc9kEPlxooATKgmCmDK8wnzMUu9zg89jTD3nKOOKh\nnQNLp/BRR8S53BNQc7KzqO1ivmejDeMgYof3iUBOnFJcUNOJVcNzT7H0nKlY8+k=\n=AlfD\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a7abab05196f1cd3bc2185ab7f02ac89e413c69\nparent 3b0fc8ac6224e8ab8848de791011add6a149b9d4\nparent 4e415a269e2d821f31963c05843517c6fde0132d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574791641 +0000\ncommitter GitHub <noreply@github.com> 1574791641 +0000\n\nMerge #2419\n\n2419: Remove ns-polymorphic type_for_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/141fca60061d85494fcb719a4c8237eaf6c7c134", "html_url": "https://github.com/rust-lang/rust/commit/141fca60061d85494fcb719a4c8237eaf6c7c134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/141fca60061d85494fcb719a4c8237eaf6c7c134/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b0fc8ac6224e8ab8848de791011add6a149b9d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0fc8ac6224e8ab8848de791011add6a149b9d4", "html_url": "https://github.com/rust-lang/rust/commit/3b0fc8ac6224e8ab8848de791011add6a149b9d4"}, {"sha": "4e415a269e2d821f31963c05843517c6fde0132d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e415a269e2d821f31963c05843517c6fde0132d", "html_url": "https://github.com/rust-lang/rust/commit/4e415a269e2d821f31963c05843517c6fde0132d"}], "stats": {"total": 448, "additions": 207, "deletions": 241}, "files": [{"sha": "c5cf39ee1a3896e8d7a7e6396bd33c7fc3974217", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -28,8 +28,7 @@ use crate::{\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     ty::display::HirFormatter,\n     ty::{\n-        self, InEnvironment, InferenceResult, Namespace, TraitEnvironment, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n+        self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n     CallableDef, Either, HirDisplay, Name, Source,\n };\n@@ -354,11 +353,11 @@ impl Struct {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n \n     pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Values)\n+        db.value_ty(self.id.into())\n     }\n \n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n@@ -381,7 +380,7 @@ impl Union {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n \n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n@@ -442,7 +441,7 @@ impl Enum {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n }\n \n@@ -617,7 +616,7 @@ impl Function {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Values)\n+        db.value_ty(self.id.into())\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n@@ -741,7 +740,7 @@ impl Trait {\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n-        TraitRef::for_trait(db, self)\n+        TraitRef::for_trait(db, self.id)\n     }\n \n     pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n@@ -797,7 +796,7 @@ impl TypeAlias {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {"}, {"sha": "3b5aa75161cc775a2087771a598f1d60b22c5669", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -9,8 +9,8 @@ use crate::{\n     ty::{\n         method_resolution::CrateImplBlocks,\n         traits::{AssocTyValue, Impl},\n-        CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n-        TypeCtor,\n+        CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n+        ValueTyDefId,\n     },\n     Crate, DefWithBody, ImplBlock, Trait,\n };\n@@ -37,8 +37,11 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::infer_query)]\n     fn infer(&self, def: DefWithBody) -> Arc<InferenceResult>;\n \n-    #[salsa::invoke(crate::ty::type_for_def)]\n-    fn type_for_def(&self, def: TypableDef, ns: Namespace) -> Ty;\n+    #[salsa::invoke(crate::ty::ty_query)]\n+    fn ty(&self, def: TyDefId) -> Ty;\n+\n+    #[salsa::invoke(crate::ty::value_ty_query)]\n+    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n \n     #[salsa::invoke(crate::ty::field_types_query)]\n     fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;"}, {"sha": "680ddc2f9c5986ad259b5e2aded7b88b2eb7dfab", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -19,14 +19,16 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    generics::GenericParams, AdtId, ContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup,\n-    TraitId, TypeAliasId,\n+    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n+    GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n };\n use ra_db::{impl_intern_key, salsa};\n \n use crate::{\n-    db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, FloatTy, IntTy, Mutability,\n-    Name, Trait, Uncertain,\n+    db::HirDatabase,\n+    ty::primitive::{FloatTy, IntTy, Uncertain},\n+    util::make_mut_slice,\n+    Adt, Crate, Name,\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -35,8 +37,8 @@ pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub(crate) use lower::{\n     callable_item_sig, field_types_query, generic_defaults_query,\n-    generic_predicates_for_param_query, generic_predicates_query, type_for_def, Namespace,\n-    TypableDef,\n+    generic_predicates_for_param_query, generic_predicates_query, ty_query, value_ty_query,\n+    TyDefId, TypableDef, ValueTyDefId,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n@@ -445,7 +447,7 @@ impl Deref for Substs {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TraitRef {\n     /// FIXME name?\n-    pub trait_: Trait,\n+    pub trait_: TraitId,\n     pub substs: Substs,\n }\n \n@@ -676,7 +678,7 @@ impl Ty {\n     }\n \n     /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<Trait> {\n+    pub fn inherent_trait(&self) -> Option<TraitId> {\n         match self {\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 predicates.iter().find_map(|pred| match pred {\n@@ -988,7 +990,10 @@ impl HirDisplay for Ty {\n                             write!(\n                                 f,\n                                 \"{}\",\n-                                trait_ref.trait_.name(f.db).unwrap_or_else(Name::missing)\n+                                f.db.trait_data(trait_ref.trait_)\n+                                    .name\n+                                    .clone()\n+                                    .unwrap_or_else(Name::missing)\n                             )?;\n                             if trait_ref.substs.len() > 1 {\n                                 write!(f, \"<\")?;\n@@ -1049,7 +1054,7 @@ impl TraitRef {\n         } else {\n             write!(f, \": \")?;\n         }\n-        write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n+        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone().unwrap_or_else(Name::missing))?;\n         if self.substs.len() > 1 {\n             write!(f, \"<\")?;\n             f.write_joined(&self.substs[1..], \", \")?;"}, {"sha": "beb2efb7aa316b8d3c352f2f0627bc4179f6a3c6", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 15, "deletions": 38, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -35,15 +35,15 @@ use test_utils::tested_by;\n \n use super::{\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypableDef,\n-    TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    TypeWalk, Uncertain,\n };\n use crate::{\n     code_model::TypeAlias,\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n+    AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -520,45 +520,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n-        let def: TypableDef =\n-            // FIXME: this should resolve assoc items as well, see this example:\n-            // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-            match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n-                Some(TypeNs::AdtId(AdtId::StructId(it))) => it.into(),\n-                Some(TypeNs::AdtId(AdtId::UnionId(it))) => it.into(),\n-                Some(TypeNs::AdtSelfType(adt)) => adt.into(),\n-                Some(TypeNs::EnumVariantId(it)) => it.into(),\n-                Some(TypeNs::TypeAliasId(it)) => it.into(),\n-\n-                Some(TypeNs::SelfType(_)) |\n-                Some(TypeNs::GenericParam(_)) |\n-                Some(TypeNs::BuiltinType(_)) |\n-                Some(TypeNs::TraitId(_)) |\n-                Some(TypeNs::AdtId(AdtId::EnumId(_))) |\n-                None => {\n-                    return (Ty::Unknown, None)\n-                }\n-            };\n-        // FIXME remove the duplication between here and `Ty::from_path`?\n-        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n-        match def {\n-            TypableDef::Adt(Adt::Struct(s)) => {\n-                let ty = s.ty(self.db);\n+        // FIXME: this should resolve assoc items as well, see this example:\n+        // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n+        match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n+            Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n+                let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n+                let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(s.into()))\n+                (ty, Some(VariantDef::Struct(strukt.into())))\n             }\n-            TypableDef::EnumVariant(var) => {\n-                let ty = var.parent_enum(self.db).ty(self.db);\n+            Some(TypeNs::EnumVariantId(var)) => {\n+                let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n+                let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(var.into()))\n+                (ty, Some(VariantDef::EnumVariant(var.into())))\n             }\n-            TypableDef::Adt(Adt::Enum(_))\n-            | TypableDef::Adt(Adt::Union(_))\n-            | TypableDef::TypeAlias(_)\n-            | TypableDef::Function(_)\n-            | TypableDef::Const(_)\n-            | TypableDef::Static(_)\n-            | TypableDef::BuiltinType(_) => (Ty::Unknown, None),\n+            Some(_) | None => (Ty::Unknown, None),\n         }\n     }\n "}, {"sha": "eb221d6bc8961bd0c466c98f76f971850fbed3eb", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -17,8 +17,8 @@ use crate::{\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     ty::{\n         autoderef, method_resolution, op, traits::InEnvironment, CallableDef, InferTy, IntTy,\n-        Mutability, Namespace, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n-        TypeCtor, TypeWalk, Uncertain,\n+        Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+        TypeWalk, Uncertain,\n     },\n     Name,\n };\n@@ -558,11 +558,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (\n-                    ty,\n-                    self.db.type_for_def(func.into(), Namespace::Values),\n-                    Some(self.db.generic_params(func.id.into())),\n-                )\n+                (ty, self.db.value_ty(func.id.into()), Some(self.db.generic_params(func.id.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };"}, {"sha": "be2067dd4d373b4964c511b1113091fb76776155", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -7,7 +7,7 @@ use hir_def::{\n \n use crate::{\n     db::HirDatabase,\n-    ty::{method_resolution, Namespace, Substs, Ty, TypableDef, TypeWalk},\n+    ty::{method_resolution, Substs, Ty, TypeWalk, ValueTyDefId},\n     AssocItem, Container, Function, Name, Path,\n };\n \n@@ -56,7 +56,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n         };\n \n-        let typable: TypableDef = match value {\n+        let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n@@ -69,11 +69,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ValueNs::EnumVariantId(it) => it.into(),\n         };\n \n-        let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+        let mut ty = self.db.value_ty(typable);\n         if let Some(self_subst) = self_subst {\n             ty = ty.subst(&self_subst);\n         }\n-\n         let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n         let ty = ty.subst(&substs);\n         Some(ty)\n@@ -143,24 +142,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         let trait_ = trait_ref.trait_;\n-        let item = trait_.items(self.db).iter().copied().find_map(|item| match item {\n-            AssocItem::Function(func) => {\n-                if segment.name == func.name(self.db) {\n-                    Some(AssocItem::Function(func))\n-                } else {\n-                    None\n-                }\n-            }\n+        let item =\n+            self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id).into()).find_map(\n+                |item| match item {\n+                    AssocItem::Function(func) => {\n+                        if segment.name == func.name(self.db) {\n+                            Some(AssocItem::Function(func))\n+                        } else {\n+                            None\n+                        }\n+                    }\n \n-            AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n-                    Some(AssocItem::Const(konst))\n-                } else {\n-                    None\n-                }\n-            }\n-            AssocItem::TypeAlias(_) => None,\n-        })?;\n+                    AssocItem::Const(konst) => {\n+                        if konst.name(self.db).map_or(false, |n| n == segment.name) {\n+                            Some(AssocItem::Const(konst))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    AssocItem::TypeAlias(_) => None,\n+                },\n+            )?;\n         let def = match item {\n             AssocItem::Function(f) => ValueNs::FunctionId(f.id),\n             AssocItem::Const(c) => ValueNs::ConstId(c.id),\n@@ -212,7 +214,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             .fill_with_params()\n                             .build();\n                         self.obligations.push(super::Obligation::Trait(TraitRef {\n-                            trait_: t,\n+                            trait_: t.id,\n                             substs: trait_substs,\n                         }));\n                         Some(substs)"}, {"sha": "709492d21761f959612edd78b739128eb2d7aa70", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 96, "deletions": 108, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -14,8 +14,8 @@ use hir_def::{\n     path::{GenericArg, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, EnumVariantId, FunctionId, GenericDefId, HasModule, LocalStructFieldId,\n-    Lookup, StructId, VariantId,\n+    AdtId, AstItemDef, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n+    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -29,24 +29,12 @@ use crate::{\n     ty::{\n         primitive::{FloatTy, IntTy},\n         utils::{all_super_traits, associated_type_by_name_including_super_traits},\n-        Adt,\n     },\n     util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, ImplBlock, ModuleDef, Path, Static, Struct, Trait,\n+    Adt, Const, Enum, EnumVariant, Function, ImplBlock, ModuleDef, Path, Static, Struct, Trait,\n     TypeAlias, Union,\n };\n \n-// FIXME: this is only really used in `type_for_def`, which contains a bunch of\n-// impossible cases. Perhaps we should recombine `TypeableDef` and `Namespace`\n-// into a `AsTypeDef`, `AsValueDef` enums?\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Namespace {\n-    Types,\n-    Values,\n-    // Note that only type inference uses this enum, and it doesn't care about macros.\n-    // Macro,\n-}\n-\n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n@@ -172,7 +160,7 @@ impl Ty {\n                     let segment = &remaining_segments[0];\n                     let associated_ty = associated_type_by_name_including_super_traits(\n                         db,\n-                        trait_ref.trait_.id,\n+                        trait_ref.trait_,\n                         &segment.name,\n                     );\n                     match associated_ty {\n@@ -263,7 +251,7 @@ impl Ty {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t.id)).map(Trait::from);\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t)).map(Trait::from);\n         for t in traits {\n             if let Some(associated_ty) = db.trait_data(t.id).associated_type_by_name(&segment.name)\n             {\n@@ -282,27 +270,15 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         segment: &PathSegment,\n-        typable: TypableDef,\n+        typable: TyDefId,\n     ) -> Ty {\n-        let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path_segment(db, resolver, segment, typable);\n-        ty.subst(&substs)\n-    }\n-\n-    pub(super) fn substs_from_path_segment(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        segment: &PathSegment,\n-        resolved: TypableDef,\n-    ) -> Substs {\n-        let def_generic: Option<GenericDefId> = match resolved {\n-            TypableDef::Function(func) => Some(func.id.into()),\n-            TypableDef::Adt(adt) => Some(adt.into()),\n-            TypableDef::EnumVariant(var) => Some(var.parent_enum(db).id.into()),\n-            TypableDef::TypeAlias(t) => Some(t.id.into()),\n-            TypableDef::Const(_) | TypableDef::Static(_) | TypableDef::BuiltinType(_) => None,\n+        let generic_def = match typable {\n+            TyDefId::BuiltinType(_) => None,\n+            TyDefId::AdtId(it) => Some(it.into()),\n+            TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        substs_from_path_segment(db, resolver, segment, def_generic, false)\n+        let substs = substs_from_path_segment(db, resolver, segment, generic_def, false);\n+        db.ty(typable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n@@ -311,17 +287,18 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         path: &Path,\n-        resolved: TypableDef,\n+        // Note that we don't call `db.value_type(resolved)` here,\n+        // `ValueTyDefId` is just a convenient way to pass generics and\n+        // special-case enum variants\n+        resolved: ValueTyDefId,\n     ) -> Substs {\n         let last = path.segments.last().expect(\"path should have at least one segment\");\n-        let segment = match resolved {\n-            TypableDef::Function(_)\n-            | TypableDef::Adt(_)\n-            | TypableDef::Const(_)\n-            | TypableDef::Static(_)\n-            | TypableDef::TypeAlias(_)\n-            | TypableDef::BuiltinType(_) => last,\n-            TypableDef::EnumVariant(_) => {\n+        let (segment, generic_def) = match resolved {\n+            ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n+            ValueTyDefId::StructId(it) => (last, Some(it.into())),\n+            ValueTyDefId::ConstId(it) => (last, Some(it.into())),\n+            ValueTyDefId::StaticId(_) => (last, None),\n+            ValueTyDefId::EnumVariantId(var) => {\n                 // the generic args for an enum variant may be either specified\n                 // on the segment referring to the enum, or on the segment\n                 // referring to the variant. So `Option::<T>::None` and\n@@ -335,10 +312,10 @@ impl Ty {\n                     // Option::None::<T>\n                     last\n                 };\n-                segment\n+                (segment, Some(var.parent.into()))\n             }\n         };\n-        Ty::substs_from_path_segment(db, resolver, segment, resolved)\n+        substs_from_path_segment(db, resolver, segment, generic_def, false)\n     }\n }\n \n@@ -423,7 +400,7 @@ impl TraitRef {\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n-        TraitRef { trait_: resolved, substs }\n+        TraitRef { trait_: resolved.id, substs }\n     }\n \n     pub(crate) fn from_hir(\n@@ -450,8 +427,8 @@ impl TraitRef {\n         substs_from_path_segment(db, resolver, segment, Some(resolved.id.into()), !has_self_param)\n     }\n \n-    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {\n-        let substs = Substs::identity(&db.generic_params(trait_.id.into()));\n+    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: TraitId) -> TraitRef {\n+        let substs = Substs::identity(&db.generic_params(trait_.into()));\n         TraitRef { trait_, substs }\n     }\n \n@@ -510,7 +487,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                associated_type_by_name_including_super_traits(db, trait_ref.trait_.id, &name);\n+                associated_type_by_name_including_super_traits(db, trait_ref.trait_, &name);\n             let associated_ty = match associated_ty {\n                 None => return GenericPredicate::Error,\n                 Some(t) => t,\n@@ -523,33 +500,6 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         })\n }\n \n-/// Build the declared type of an item. This depends on the namespace; e.g. for\n-/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n-/// the constructor function `(usize) -> Foo` which lives in the values\n-/// namespace.\n-pub(crate) fn type_for_def(db: &impl HirDatabase, def: TypableDef, ns: Namespace) -> Ty {\n-    match (def, ns) {\n-        (TypableDef::Function(f), Namespace::Values) => type_for_fn(db, f),\n-        (TypableDef::Adt(Adt::Struct(s)), Namespace::Values) => type_for_struct_constructor(db, s),\n-        (TypableDef::Adt(adt), Namespace::Types) => type_for_adt(db, adt),\n-        (TypableDef::EnumVariant(v), Namespace::Values) => type_for_enum_variant_constructor(db, v),\n-        (TypableDef::TypeAlias(t), Namespace::Types) => type_for_type_alias(db, t),\n-        (TypableDef::Const(c), Namespace::Values) => type_for_const(db, c),\n-        (TypableDef::Static(c), Namespace::Values) => type_for_static(db, c),\n-        (TypableDef::BuiltinType(t), Namespace::Types) => type_for_builtin(t),\n-\n-        // 'error' cases:\n-        (TypableDef::Function(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Adt(Adt::Union(_)), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::Adt(Adt::Enum(_)), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::EnumVariant(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::TypeAlias(_), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::Const(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Static(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::BuiltinType(_), Namespace::Values) => Ty::Unknown,\n-    }\n-}\n-\n /// Build the signature of a callable item (function, struct or enum variant).\n pub(crate) fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n     match def {\n@@ -648,24 +598,24 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n-    let generics = db.generic_params(def.id.into());\n+fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n+    let generics = db.generic_params(def.into());\n     let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.id.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n /// Build the declared type of a const.\n-fn type_for_const(db: &impl HirDatabase, def: Const) -> Ty {\n-    let data = db.const_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Ty {\n+    let data = db.const_data(def);\n+    let resolver = def.resolver(db);\n \n     Ty::from_hir(db, &resolver, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n-fn type_for_static(db: &impl HirDatabase, def: Static) -> Ty {\n-    let data = db.static_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Ty {\n+    let data = db.static_data(def);\n+    let resolver = def.resolver(db);\n \n     Ty::from_hir(db, &resolver, &data.type_ref)\n }\n@@ -689,19 +639,19 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let ret = type_for_adt(db, Struct::from(def));\n+    let ret = type_for_adt(db, def.into());\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n-    let struct_data = db.struct_data(def.id.into());\n+fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n+    let struct_data = db.struct_data(def.into());\n     if struct_data.variant_data.is_unit() {\n-        return type_for_adt(db, def); // Unit struct\n+        return type_for_adt(db, def.into()); // Unit struct\n     }\n-    let generics = db.generic_params(def.id.into());\n+    let generics = db.generic_params(def.into());\n     let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.id.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> FnSig {\n@@ -715,34 +665,33 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n         .collect::<Vec<_>>();\n     let generics = db.generic_params(def.parent.into());\n     let substs = Substs::identity(&generics);\n-    let ret = type_for_adt(db, Enum::from(def.parent)).subst(&substs);\n+    let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> Ty {\n-    let var_data = def.variant_data(db);\n+fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Ty {\n+    let enum_data = db.enum_data(def.parent);\n+    let var_data = &enum_data.variants[def.local_id].variant_data;\n     if var_data.is_unit() {\n-        return type_for_adt(db, def.parent_enum(db)); // Unit variant\n+        return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n-    let generics = db.generic_params(def.parent_enum(db).id.into());\n+    let generics = db.generic_params(def.parent.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n }\n \n-fn type_for_adt(db: &impl HirDatabase, adt: impl Into<Adt>) -> Ty {\n-    let adt = adt.into();\n-    let adt_id: AdtId = adt.into();\n-    let generics = db.generic_params(adt_id.into());\n-    Ty::apply(TypeCtor::Adt(adt_id), Substs::identity(&generics))\n+fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n+    let generics = db.generic_params(adt.into());\n+    Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n }\n \n-fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n-    let generics = db.generic_params(t.id.into());\n-    let resolver = t.id.resolver(db);\n-    let type_ref = t.type_ref(db);\n+fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n+    let generics = db.generic_params(t.into());\n+    let resolver = t.resolver(db);\n+    let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, &type_ref.unwrap_or(TypeRef::Error));\n+    let inner = Ty::from_hir(db, &resolver, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n     inner.subst(&substs)\n }\n \n@@ -809,3 +758,42 @@ impl From<CallableDef> for GenericDefId {\n         }\n     }\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TyDefId {\n+    BuiltinType(BuiltinType),\n+    AdtId(AdtId),\n+    TypeAliasId(TypeAliasId),\n+}\n+impl_froms!(TyDefId: BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ValueTyDefId {\n+    FunctionId(FunctionId),\n+    StructId(StructId),\n+    EnumVariantId(EnumVariantId),\n+    ConstId(ConstId),\n+    StaticId(StaticId),\n+}\n+impl_froms!(ValueTyDefId: FunctionId, StructId, EnumVariantId, ConstId, StaticId);\n+\n+/// Build the declared type of an item. This depends on the namespace; e.g. for\n+/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n+/// the constructor function `(usize) -> Foo` which lives in the values\n+/// namespace.\n+pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Ty {\n+    match def {\n+        TyDefId::BuiltinType(it) => type_for_builtin(it),\n+        TyDefId::AdtId(it) => type_for_adt(db, it),\n+        TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n+    }\n+}\n+pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n+    match def {\n+        ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n+        ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n+        ValueTyDefId::EnumVariantId(it) => type_for_enum_variant_constructor(db, it),\n+        ValueTyDefId::ConstId(it) => type_for_const(db, it),\n+        ValueTyDefId::StaticId(it) => type_for_static(db, it),\n+    }\n+}"}, {"sha": "f1bc638eec4fd5847140fb1d2e0cb771885d7306", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -68,7 +68,7 @@ impl CrateImplBlocks {\n                         if let Some(tr) =\n                             TraitRef::from_hir(db, &resolver, &trait_ref, Some(target_ty))\n                         {\n-                            res.impls_by_trait.entry(tr.trait_.id).or_default().push(impl_id);\n+                            res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n                         }\n                     }\n                     None => {\n@@ -249,13 +249,11 @@ fn iterate_trait_method_candidates<T>(\n     let traits_from_env = env\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n-        .flat_map(|t| all_super_traits(db, t.id))\n-        .map(Trait::from);\n-    let traits = inherent_trait\n-        .chain(traits_from_env)\n-        .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n+        .flat_map(|t| all_super_traits(db, t));\n+    let traits =\n+        inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db).into_iter());\n     'traits: for t in traits {\n-        let data = db.trait_data(t.id);\n+        let data = db.trait_data(t);\n \n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n@@ -330,7 +328,7 @@ pub(crate) fn implements_trait(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     krate: Crate,\n-    trait_: Trait,\n+    trait_: TraitId,\n ) -> bool {\n     if ty.value.inherent_trait() == Some(trait_) {\n         // FIXME this is a bit of a hack, since Chalk should say the same thing\n@@ -373,11 +371,11 @@ impl Ty {\n fn generic_implements_goal(\n     db: &impl HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: Trait,\n+    trait_: TraitId,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::Obligation>> {\n     let num_vars = self_ty.num_vars;\n-    let substs = super::Substs::build_for_def(db, trait_.id)\n+    let substs = super::Substs::build_for_def(db, trait_)\n         .push(self_ty.value)\n         .fill_with_bound_vars(num_vars as u32)\n         .build();"}, {"sha": "a91c2476be33926b49a28ce195f4b02eb01d1380", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -2,14 +2,15 @@\n use std::sync::{Arc, Mutex};\n \n use chalk_ir::{cast::Cast, family::ChalkIr};\n-use hir_def::DefWithBodyId;\n+use hir_def::{expr::ExprId, DefWithBodyId};\n use log::debug;\n use ra_db::{impl_intern_key, salsa};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n+use crate::{db::HirDatabase, Crate, ImplBlock, Trait, TypeAlias};\n+\n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, expr::ExprId, Crate, ImplBlock, Trait, TypeAlias};\n \n use self::chalk::{from_chalk, ToChalk};\n "}, {"sha": "4b0f4f56c2d26cc8a4b54f5ccf87ed6def330243", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -9,7 +9,9 @@ use chalk_ir::{\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n-use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId};\n+use hir_def::{\n+    lang_item::LangItemTarget, AstItemDef, ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId,\n+};\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n@@ -19,7 +21,7 @@ use crate::{\n     db::HirDatabase,\n     ty::display::HirDisplay,\n     ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n-    Crate, ImplBlock, Trait, TypeAlias,\n+    Crate, ImplBlock, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -167,15 +169,15 @@ impl ToChalk for TraitRef {\n     }\n }\n \n-impl ToChalk for Trait {\n+impl ToChalk for TraitId {\n     type Chalk = chalk_ir::TraitId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n-        chalk_ir::TraitId(id_to_chalk(self.id))\n+        chalk_ir::TraitId(id_to_chalk(self))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n-        Trait { id: id_from_chalk(trait_id.0) }\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> TraitId {\n+        id_from_chalk(trait_id.0)\n     }\n }\n \n@@ -443,10 +445,10 @@ where\n         if trait_id == UNKNOWN_TRAIT {\n             return Vec::new();\n         }\n-        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let trait_: TraitId = from_chalk(self.db, trait_id);\n         let mut result: Vec<_> = self\n             .db\n-            .impls_for_trait(self.krate, trait_)\n+            .impls_for_trait(self.krate, trait_.into())\n             .iter()\n             .copied()\n             .map(Impl::ImplBlock)\n@@ -459,7 +461,7 @@ where\n                 [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n             {\n                 if let Some(actual_trait) = get_fn_trait(self.db, self.krate, fn_trait) {\n-                    if trait_.id == actual_trait {\n+                    if trait_ == actual_trait {\n                         let impl_ = super::ClosureFnTraitImplData { def, expr, fn_trait };\n                         result.push(Impl::ClosureFnTraitImpl(impl_).to_chalk(self.db));\n                     }\n@@ -516,7 +518,7 @@ pub(crate) fn associated_ty_data_query(\n         where_clauses: vec![],\n     };\n     let datum = AssociatedTyDatum {\n-        trait_id: Trait::from(trait_).to_chalk(db),\n+        trait_id: trait_.to_chalk(db),\n         id,\n         name: lalrpop_intern::intern(&db.type_alias_data(type_alias).name.to_string()),\n         binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n@@ -548,29 +550,23 @@ pub(crate) fn trait_datum_query(\n             associated_ty_ids: vec![],\n         });\n     }\n-    let trait_: Trait = from_chalk(db, trait_id);\n-    debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n-    let generic_params = db.generic_params(trait_.id.into());\n+    let trait_: TraitId = from_chalk(db, trait_id);\n+    let trait_data = db.trait_data(trait_);\n+    debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n+    let generic_params = db.generic_params(trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let flags = chalk_rust_ir::TraitFlags {\n-        auto: trait_.is_auto(db),\n-        upstream: trait_.module(db).krate() != krate,\n+        auto: trait_data.auto,\n+        upstream: trait_.module(db).krate != krate.crate_id,\n         non_enumerable: true,\n         coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n         marker: false,\n         fundamental: false,\n     };\n-    let where_clauses = convert_where_clauses(db, trait_.id.into(), &bound_vars);\n-    let associated_ty_ids = trait_\n-        .items(db)\n-        .into_iter()\n-        .filter_map(|trait_item| match trait_item {\n-            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias.id),\n-            _ => None,\n-        })\n-        .map(|type_alias| type_alias.to_chalk(db))\n-        .collect();\n+    let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n+    let associated_ty_ids =\n+        trait_data.associated_types().map(|type_alias| type_alias.to_chalk(db)).collect();\n     let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n     let trait_datum = TraitDatum {\n         id: trait_id,\n@@ -661,7 +657,7 @@ fn impl_block_datum(\n     };\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n-    let trait_data = db.trait_data(trait_.id);\n+    let trait_data = db.trait_data(trait_);\n     let associated_ty_value_ids = impl_block\n         .items(db)\n         .into_iter()\n@@ -785,12 +781,12 @@ fn type_alias_associated_ty_value(\n         .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n         .trait_;\n     let assoc_ty = db\n-        .trait_data(trait_.id)\n+        .trait_data(trait_)\n         .associated_type_by_name(&type_alias.name(db))\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let generic_params = db.generic_params(impl_block.id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n+    let ty = db.ty(type_alias.id.into()).subst(&bound_vars);\n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n     let value = chalk_rust_ir::AssociatedTyValue {\n         impl_id,"}, {"sha": "80ffceb4bca03dcb9aa81526626f53c2752c3b5f", "filename": "crates/ra_hir/src/ty/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -33,7 +33,7 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n \n /// Returns an iterator over the whole super trait hierarchy (including the\n /// trait itself).\n-pub(crate) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     // we need to take care a bit here to avoid infinite loops in case of cycles\n     // (i.e. if we have `trait A: B; trait B: A;`)\n     let mut result = vec![trait_];\n@@ -52,7 +52,7 @@ pub(crate) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<Tr\n     result\n }\n \n-pub(crate) fn associated_type_by_name_including_super_traits(\n+pub(super) fn associated_type_by_name_including_super_traits(\n     db: &impl DefDatabase,\n     trait_: TraitId,\n     name: &Name,"}, {"sha": "4a76d1dd83ce996d5e00b50752f4e554d6e44ccb", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141fca60061d85494fcb719a4c8237eaf6c7c134/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=141fca60061d85494fcb719a4c8237eaf6c7c134", "patch": "@@ -323,7 +323,8 @@ impl RootDatabase {\n             hir::db::DocumentationQuery\n             hir::db::ExprScopesQuery\n             hir::db::InferQuery\n-            hir::db::TypeForDefQuery\n+            hir::db::TyQuery\n+            hir::db::ValueTyQuery\n             hir::db::FieldTypesQuery\n             hir::db::CallableItemSignatureQuery\n             hir::db::GenericPredicatesQuery"}]}