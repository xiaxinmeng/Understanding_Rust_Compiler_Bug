{"sha": "6bfe2b0b05837ae671d9206b81539f998965b017", "node_id": "C_kwDOAAsO6NoAKDZiZmUyYjBiMDU4MzdhZTY3MWQ5MjA2YjgxNTM5Zjk5ODk2NWIwMTc", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-03T01:50:22Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-03T21:47:46Z"}, "message": "Support more SIMD intrinsics", "tree": {"sha": "f8a8af4338c55ed400982f438525cef8f56949b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8a8af4338c55ed400982f438525cef8f56949b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bfe2b0b05837ae671d9206b81539f998965b017", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfe2b0b05837ae671d9206b81539f998965b017", "html_url": "https://github.com/rust-lang/rust/commit/6bfe2b0b05837ae671d9206b81539f998965b017", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bfe2b0b05837ae671d9206b81539f998965b017/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ace3250da87542526952ce3177f6950410133d1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ace3250da87542526952ce3177f6950410133d1e", "html_url": "https://github.com/rust-lang/rust/commit/ace3250da87542526952ce3177f6950410133d1e"}], "stats": {"total": 146, "additions": 141, "deletions": 5}, "files": [{"sha": "82b0e64e582ab4902dc6f32f24305b26e09595d6", "filename": "src/builder.rs", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=6bfe2b0b05837ae671d9206b81539f998965b017", "patch": "@@ -217,11 +217,27 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             return Cow::Borrowed(args);\n         }\n \n+        let func_name = format!(\"{:?}\", func_ptr);\n+\n         let casted_args: Vec<_> = param_types\n             .into_iter()\n             .zip(args.iter())\n             .enumerate()\n             .map(|(index, (expected_ty, &actual_val))| {\n+                // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+                // last argument type check.\n+                // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n+                match &*func_name {\n+                    \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                    | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n+                    | \"__builtin_ia32_sqrtpd512_mask\" => {\n+                        if index == args.len() - 1 {\n+                            return actual_val;\n+                        }\n+                    },\n+                    _ => (),\n+                }\n+\n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n                     if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n@@ -286,7 +302,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let mut args = self.check_ptr_call(\"call\", func_ptr, args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n@@ -298,6 +314,92 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n+            // arguments here.\n+            if gcc_func.get_param_count() != args.len() {\n+                let func_name = format!(\"{:?}\", func_ptr);\n+                match &*func_name {\n+                    \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n+                    // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+                    | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n+                    | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                    | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n+                    | \"__builtin_ia32_pmaxuq128_mask\"\n+                    | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n+                    | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                    | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                    | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                    => {\n+                        // TODO: refactor by separating those intrinsics outside of this branch.\n+                        let add_before_last_arg =\n+                            match &*func_name {\n+                                \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n+                                _ => false,\n+                            };\n+                        let new_first_arg_is_zero =\n+                            match &*func_name {\n+                                \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n+                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n+                                _ => false\n+                            };\n+                        let arg3_index =\n+                            match &*func_name {\n+                                \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n+                                _ => 2,\n+                            };\n+                        let mut new_args = args.to_vec();\n+                        let arg3_type = gcc_func.get_param_type(arg3_index);\n+                        let first_arg =\n+                            if new_first_arg_is_zero {\n+                                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                                let zero = self.context.new_rvalue_zero(vector_type.get_element_type());\n+                                let num_units = vector_type.get_num_units();\n+                                self.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n+                            }\n+                            else {\n+                                self.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n+                            };\n+                        if add_before_last_arg {\n+                            new_args.insert(new_args.len() - 1, first_arg);\n+                        }\n+                        else {\n+                            new_args.push(first_arg);\n+                        }\n+                        let arg4_index =\n+                            match &*func_name {\n+                                \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n+                                _ => 3,\n+                            };\n+                        let arg4_type = gcc_func.get_param_type(arg4_index);\n+                        let minus_one = self.context.new_rvalue_from_int(arg4_type, -1);\n+                        if add_before_last_arg {\n+                            new_args.insert(new_args.len() - 1, minus_one);\n+                        }\n+                        else {\n+                            new_args.push(minus_one);\n+                        }\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        if args.len() == 3 {\n+                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmaddsub.ps.512 maps to\n+                            // the same GCC intrinsic, but the former has 3 parameters and the\n+                            // latter has 4 so it doesn't require this additional argument.\n+                            let arg4_type = gcc_func.get_param_type(3);\n+                            let minus_one = self.context.new_rvalue_from_int(arg4_type, -1);\n+                            new_args.push(minus_one);\n+                        }\n+\n+                        let arg5_type = gcc_func.get_param_type(4);\n+                        new_args.push(self.context.new_rvalue_from_int(arg5_type, 4));\n+                        args = new_args.into();\n+                    },\n+                    _ => (),\n+                }\n+            }\n             self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }"}, {"sha": "4bc8c5a6760e3e5afe30de20cd8e634ae03b025e", "filename": "src/context.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=6bfe2b0b05837ae671d9206b81539f998965b017", "patch": "@@ -35,6 +35,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n+    pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n \n     pub tls_model: gccjit::TlsModel,\n \n@@ -184,6 +185,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),\n+            intrinsics: RefCell::new(FxHashMap::default()),\n \n             tls_model,\n \n@@ -315,8 +317,16 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n-        let func = get_fn(self, instance);\n-        let func = self.rvalue_as_function(func);\n+        let func_name = self.tcx.symbol_name(instance).name;\n+\n+        let func =\n+            if self.intrinsics.borrow().contains_key(func_name) {\n+                self.intrinsics.borrow()[func_name].clone()\n+            }\n+            else {\n+                let func = get_fn(self, instance);\n+                self.rvalue_as_function(func)\n+            };\n         let ptr = func.get_address(None);\n \n         // TODO(antoyo): don't do this twice: i.e. in declare_fn and here."}, {"sha": "8b2146c5aa84315e37c5d74cbaed1f3f4427da42", "filename": "src/declare.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=6bfe2b0b05837ae671d9206b81539f998965b017", "patch": "@@ -11,6 +11,7 @@ use crate::intrinsic::llvm;\n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         if self.globals.borrow().contains_key(name) {\n+            // TODO: use [] instead of .get().expect()?\n             let typ = self.globals.borrow().get(name).expect(\"global\").get_type();\n             let global = self.context.new_global(None, GlobalKind::Imported, typ, name);\n             if is_tls {\n@@ -103,7 +104,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n /// update the declaration and return existing Value instead.\n fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*llvm::CallConv*/, return_type: Type<'gcc>, param_types: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n     if name.starts_with(\"llvm.\") {\n-        return llvm::intrinsic(name, cx);\n+        let intrinsic = llvm::intrinsic(name, cx);\n+        cx.intrinsics.borrow_mut().insert(name.to_string(), intrinsic);\n+        return intrinsic;\n     }\n     let func =\n         if cx.functions.borrow().contains_key(name) {"}, {"sha": "fbcfc8be859116dd0167b14e57513d571cae817f", "filename": "src/intrinsic/archs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Farchs.rs?ref=6bfe2b0b05837ae671d9206b81539f998965b017", "patch": "@@ -4275,5 +4275,8 @@ match name {\n     \"llvm.xcore.getid\" => \"__builtin_getid\",\n     \"llvm.xcore.getps\" => \"__builtin_getps\",\n     \"llvm.xcore.setps\" => \"__builtin_setps\",\n-    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\n+    _ => {\n+        println!(\"***** unsupported LLVM intrinsic {}\", name);\n+        \"\"\n+    },\n }"}, {"sha": "16f0df8a20750775bb6568994be8292586053cb9", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe2b0b05837ae671d9206b81539f998965b017/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=6bfe2b0b05837ae671d9206b81539f998965b017", "patch": "@@ -21,6 +21,24 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n         // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n+        \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n+        \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n+        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n+        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n+        \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n+        \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n+        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n+        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n+        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n+        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n+        \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n+        \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n+        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n+        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n+        \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n+        \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\","}]}