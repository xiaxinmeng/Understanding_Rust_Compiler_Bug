{"sha": "5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "node_id": "C_kwDOAAsO6NoAKDVkNTRjNTUwZTdmNWM1YzQyM2IxYTNjNWI2ZjNjMjRjMWE5M2FmNDk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-12-30T22:56:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-12-30T22:56:08Z"}, "message": "Fallback to invisible associated functions and constants if no visible resolutions are found", "tree": {"sha": "c3bbc1af3ea4790146cb448af66b4738a93e96bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3bbc1af3ea4790146cb448af66b4738a93e96bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "html_url": "https://github.com/rust-lang/rust/commit/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d76b94c90a20c20d3e57ea1ab03d9afa00dee72", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d76b94c90a20c20d3e57ea1ab03d9afa00dee72", "html_url": "https://github.com/rust-lang/rust/commit/0d76b94c90a20c20d3e57ea1ab03d9afa00dee72"}], "stats": {"total": 148, "additions": 94, "deletions": 54}, "files": [{"sha": "dc645f840eea4f387c446375dd32dd76aea0ea29", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "patch": "@@ -234,15 +234,16 @@ impl<'a> InferenceContext<'a> {\n         let canonical_ty = self.canonicalize(ty.clone());\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n-        method_resolution::iterate_method_candidates(\n+        let mut not_visible = None;\n+        let res = method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n             self.table.trait_env.clone(),\n             &traits_in_scope,\n             VisibleFromModule::Filter(self.resolver.module()),\n             Some(name),\n             method_resolution::LookupMode::Path,\n-            move |_ty, item| {\n+            |_ty, item, visible| {\n                 let (def, container) = match item {\n                     AssocItemId::FunctionId(f) => {\n                         (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n@@ -277,10 +278,21 @@ impl<'a> InferenceContext<'a> {\n                     }\n                 };\n \n-                self.write_assoc_resolution(id, item, substs.clone());\n-                Some((def, Some(substs)))\n+                if visible {\n+                    Some((def, item, Some(substs)))\n+                } else {\n+                    if not_visible.is_none() {\n+                        not_visible = Some((def, item, Some(substs)));\n+                    }\n+                    None\n+                }\n             },\n-        )\n+        );\n+        let res = res.or(not_visible);\n+        if let Some((_, item, Some(ref substs))) = res {\n+            self.write_assoc_resolution(id, item, substs.clone());\n+        }\n+        res.map(|(def, _, substs)| (def, substs))\n     }\n \n     fn resolve_enum_variant_on_ty("}, {"sha": "2d162bc38e45f0f9c0f31445ba4e05ce963038d9", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 76, "deletions": 48, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "patch": "@@ -495,19 +495,25 @@ pub(crate) fn lookup_method(\n     visible_from_module: VisibleFromModule,\n     name: &Name,\n ) -> Option<(ReceiverAdjustments, FunctionId)> {\n-    iterate_method_candidates(\n+    let mut not_visible = None;\n+    let res = iterate_method_candidates(\n         ty,\n         db,\n         env,\n         traits_in_scope,\n         visible_from_module,\n         Some(name),\n         LookupMode::MethodCall,\n-        |adjustments, f| match f {\n-            AssocItemId::FunctionId(f) => Some((adjustments, f)),\n+        |adjustments, f, visible| match f {\n+            AssocItemId::FunctionId(f) if visible => Some((adjustments, f)),\n+            AssocItemId::FunctionId(f) if not_visible.is_none() => {\n+                not_visible = Some((adjustments, f));\n+                None\n+            }\n             _ => None,\n         },\n-    )\n+    );\n+    res.or(not_visible)\n }\n \n /// Whether we're looking up a dotted method call (like `v.len()`) or a path\n@@ -619,7 +625,7 @@ pub(crate) fn iterate_method_candidates<T>(\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    mut callback: impl FnMut(ReceiverAdjustments, AssocItemId) -> Option<T>,\n+    mut callback: impl FnMut(ReceiverAdjustments, AssocItemId, bool) -> Option<T>,\n ) -> Option<T> {\n     let mut slot = None;\n     iterate_method_candidates_dyn(\n@@ -630,9 +636,9 @@ pub(crate) fn iterate_method_candidates<T>(\n         visible_from_module,\n         name,\n         mode,\n-        &mut |adj, item| {\n+        &mut |adj, item, visible| {\n             assert!(slot.is_none());\n-            if let Some(it) = callback(adj, item) {\n+            if let Some(it) = callback(adj, item, visible) {\n                 slot = Some(it);\n                 return ControlFlow::Break(());\n             }\n@@ -771,7 +777,7 @@ pub fn iterate_path_candidates(\n         name,\n         LookupMode::Path,\n         // the adjustments are not relevant for path lookup\n-        &mut |_, id| callback(id),\n+        &mut |_, id, _| callback(id),\n     )\n }\n \n@@ -783,7 +789,7 @@ pub fn iterate_method_candidates_dyn(\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     match mode {\n         LookupMode::MethodCall => {\n@@ -847,7 +853,7 @@ fn iterate_method_candidates_with_autoref(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     if receiver_ty.value.is_general_var(Interner, &receiver_ty.binders) {\n         // don't try to resolve methods on unknown types\n@@ -908,7 +914,7 @@ fn iterate_method_candidates_by_receiver(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let mut table = InferenceTable::new(db, env);\n     let receiver_ty = table.instantiate_canonical(receiver_ty.clone());\n@@ -954,7 +960,7 @@ fn iterate_method_candidates_for_self_ty(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let mut table = InferenceTable::new(db, env);\n     let self_ty = table.instantiate_canonical(self_ty.clone());\n@@ -985,7 +991,7 @@ fn iterate_trait_method_candidates(\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n@@ -1016,17 +1022,19 @@ fn iterate_trait_method_candidates(\n         for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n-                continue;\n-            }\n+            let visible = match is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                IsValidCandidate::Yes => true,\n+                IsValidCandidate::NotVisible => false,\n+                IsValidCandidate::No => continue,\n+            };\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, &canonical_self_ty);\n                 if db.trait_solve(env.krate, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n             known_implemented = true;\n-            callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+            callback(receiver_adjustments.clone().unwrap_or_default(), item, visible)?;\n         }\n     }\n     ControlFlow::Continue(())\n@@ -1039,7 +1047,7 @@ fn iterate_inherent_methods(\n     receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n     visible_from_module: VisibleFromModule,\n-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n@@ -1128,17 +1136,21 @@ fn iterate_inherent_methods(\n         name: Option<&Name>,\n         receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n-        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n         traits: impl Iterator<Item = TraitId>,\n     ) -> ControlFlow<()> {\n         let db = table.db;\n         for t in traits {\n             let data = db.trait_data(t);\n             for &(_, item) in data.items.iter() {\n                 // We don't pass `visible_from_module` as all trait items should be visible.\n-                if is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n-                    callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n-                }\n+                let visible =\n+                    match is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                        IsValidCandidate::Yes => true,\n+                        IsValidCandidate::NotVisible => false,\n+                        IsValidCandidate::No => continue,\n+                    };\n+                callback(receiver_adjustments.clone().unwrap_or_default(), item, visible)?;\n             }\n         }\n         ControlFlow::Continue(())\n@@ -1152,17 +1164,25 @@ fn iterate_inherent_methods(\n         receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n         visible_from_module: Option<ModuleId>,\n-        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n     ) -> ControlFlow<()> {\n         let db = table.db;\n         let impls_for_self_ty = impls.for_self_ty(self_ty);\n         for &impl_def in impls_for_self_ty {\n             for &item in &db.impl_data(impl_def).items {\n-                if !is_valid_candidate(table, name, receiver_ty, item, self_ty, visible_from_module)\n-                {\n-                    continue;\n-                }\n-                callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+                let visible = match is_valid_candidate(\n+                    table,\n+                    name,\n+                    receiver_ty,\n+                    item,\n+                    self_ty,\n+                    visible_from_module,\n+                ) {\n+                    IsValidCandidate::Yes => true,\n+                    IsValidCandidate::NotVisible => false,\n+                    IsValidCandidate::No => continue,\n+                };\n+                callback(receiver_adjustments.clone().unwrap_or_default(), item, visible)?;\n             }\n         }\n         ControlFlow::Continue(())\n@@ -1191,7 +1211,7 @@ pub fn resolve_indexing_op(\n macro_rules! check_that {\n     ($cond:expr) => {\n         if !$cond {\n-            return false;\n+            return IsValidCandidate::No;\n         }\n     };\n }\n@@ -1203,7 +1223,7 @@ fn is_valid_candidate(\n     item: AssocItemId,\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n-) -> bool {\n+) -> IsValidCandidate {\n     let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n@@ -1214,13 +1234,13 @@ fn is_valid_candidate(\n             check_that!(receiver_ty.is_none());\n \n             check_that!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n-            check_that!(visible_from_module.map_or(true, |from_module| {\n-                let v = db.const_visibility(c).is_visible_from(db.upcast(), from_module);\n-                if !v {\n+\n+            if let Some(from_module) = visible_from_module {\n+                if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n                     cov_mark::hit!(const_candidate_not_visible);\n+                    return IsValidCandidate::NotVisible;\n                 }\n-                v\n-            }));\n+            }\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n                     let expected_self_ty = TyBuilder::impl_self_ty(db, impl_id)\n@@ -1230,35 +1250,39 @@ fn is_valid_candidate(\n                 });\n                 if !self_ty_matches {\n                     cov_mark::hit!(const_candidate_self_type_mismatch);\n-                    return false;\n+                    return IsValidCandidate::No;\n                 }\n             }\n-            true\n+            IsValidCandidate::Yes\n         }\n-        _ => false,\n+        _ => IsValidCandidate::No,\n     }\n }\n \n+enum IsValidCandidate {\n+    Yes,\n+    No,\n+    NotVisible,\n+}\n+\n fn is_valid_fn_candidate(\n     table: &mut InferenceTable<'_>,\n     fn_id: FunctionId,\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n-) -> bool {\n+) -> IsValidCandidate {\n     let db = table.db;\n     let data = db.function_data(fn_id);\n \n     check_that!(name.map_or(true, |n| n == &data.name));\n-    check_that!(visible_from_module.map_or(true, |from_module| {\n-        let v = db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module);\n-        if !v {\n+    if let Some(from_module) = visible_from_module {\n+        if !db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module) {\n             cov_mark::hit!(autoderef_candidate_not_visible);\n+            return IsValidCandidate::NotVisible;\n         }\n-        v\n-    }));\n-\n+    }\n     table.run_in_snapshot(|table| {\n         let container = fn_id.lookup(db.upcast()).container;\n         let (impl_subst, expect_self_ty) = match container {\n@@ -1297,7 +1321,7 @@ fn is_valid_fn_candidate(\n             // We need to consider the bounds on the impl to distinguish functions of the same name\n             // for a type.\n             let predicates = db.generic_predicates(impl_id.into());\n-            predicates\n+            let valid = predicates\n                 .iter()\n                 .map(|predicate| {\n                     let (p, b) = predicate\n@@ -1312,12 +1336,16 @@ fn is_valid_fn_candidate(\n                 // It's ok to get ambiguity here, as we may not have enough information to prove\n                 // obligations. We'll check if the user is calling the selected method properly\n                 // later anyway.\n-                .all(|p| table.try_obligation(p.cast(Interner)).is_some())\n+                .all(|p| table.try_obligation(p.cast(Interner)).is_some());\n+            match valid {\n+                true => IsValidCandidate::Yes,\n+                false => IsValidCandidate::No,\n+            }\n         } else {\n             // For `ItemContainerId::TraitId`, we check if `self_ty` implements the trait in\n             // `iterate_trait_method_candidates()`.\n             // For others, this function shouldn't be called.\n-            true\n+            IsValidCandidate::Yes\n         }\n     })\n }"}, {"sha": "ede0c0c9886824256e7ac7502493e3b365b88c3c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=5d54c550e7f5c5c423b1a3c5b6f3c24c1a93af49", "patch": "@@ -3274,7 +3274,7 @@ impl Type {\n             with_local_impls.and_then(|b| b.id.containing_block()).into(),\n             name,\n             method_resolution::LookupMode::MethodCall,\n-            &mut |_adj, id| callback(id),\n+            &mut |_adj, id, _| callback(id),\n         );\n     }\n "}]}