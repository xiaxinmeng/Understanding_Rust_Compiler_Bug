{"sha": "33b06362fa9207ec1beae209a39d974f6c471206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYjA2MzYyZmE5MjA3ZWMxYmVhZTIwOWEzOWQ5NzRmNmM0NzEyMDY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-10T17:01:06Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-10T20:02:18Z"}, "message": "Use the appropriate number of type arguments in suggestion", "tree": {"sha": "f7fa5380001b71d4df000ed5d0030b90d7befd26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7fa5380001b71d4df000ed5d0030b90d7befd26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33b06362fa9207ec1beae209a39d974f6c471206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33b06362fa9207ec1beae209a39d974f6c471206", "html_url": "https://github.com/rust-lang/rust/commit/33b06362fa9207ec1beae209a39d974f6c471206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33b06362fa9207ec1beae209a39d974f6c471206/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca4b6d42ad984a28b9eb2dc3f62590cfc7ef421", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca4b6d42ad984a28b9eb2dc3f62590cfc7ef421", "html_url": "https://github.com/rust-lang/rust/commit/cca4b6d42ad984a28b9eb2dc3f62590cfc7ef421"}], "stats": {"total": 114, "additions": 93, "deletions": 21}, "files": [{"sha": "c5133e8843225396983438e5c69b8f5a700380fa", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/33b06362fa9207ec1beae209a39d974f6c471206/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b06362fa9207ec1beae209a39d974f6c471206/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=33b06362fa9207ec1beae209a39d974f6c471206", "patch": "@@ -20,7 +20,7 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n     found_closure: Option<&'tcx ExprKind>,\n-    found_method_call: Option<&'tcx ExprKind>,\n+    found_method_call: Option<&'tcx Expr>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n@@ -99,7 +99,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         if self.node_matches_type(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n-                ExprKind::MethodCall(..) => self.found_method_call = Some(&expr.kind),\n+                ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n                 _ => {}\n             }\n         }\n@@ -211,8 +211,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n             let ty_vars = self.type_variables.borrow();\n             let getter = move |ty_vid| {\n-                if let TypeVariableOriginKind::TypeParameterDefinition(name) =\n-                    ty_vars.var_origin(ty_vid).kind {\n+                let var_origin = ty_vars.var_origin(ty_vid);\n+                if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n                     return Some(name.to_string());\n                 }\n                 None\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             span\n         } else if let Some(\n             ExprKind::MethodCall(_, call_span, _),\n-        ) = local_visitor.found_method_call {\n+        ) = local_visitor.found_method_call.map(|e| &e.kind) {\n             // Point at the call instead of the whole expression:\n             // error[E0284]: type annotations needed\n             //  --> file.rs:2:5\n@@ -375,16 +375,48 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\"consider giving this pattern {}\", suffix)\n             };\n             err.span_label(pattern.span, msg);\n-        } else if let Some(ExprKind::MethodCall(segment, ..)) = local_visitor.found_method_call {\n-            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(segment.ident.span) {\n-                if segment.args.is_none() {\n-                    err.span_suggestion(\n-                        segment.ident.span,\n-                        \"consider specifying the type argument in the method call\",\n-                        // FIXME: we don't know how many type arguments should be set here.\n-                        format!(\"{}::<_>\", snippet),\n-                        Applicability::HasPlaceholders,\n-                    );\n+        } else if let Some(e) = local_visitor.found_method_call {\n+            if let ExprKind::MethodCall(segment, _call_sp, _args) = &e.kind {\n+                if let (Ok(snippet), Some(tables), None) = (\n+                    self.tcx.sess.source_map().span_to_snippet(segment.ident.span),\n+                    self.in_progress_tables,\n+                    &segment.args,\n+                 ) {\n+                    let borrow = tables.borrow();\n+                    let sigs = borrow.node_method_sig();\n+                    if let Some(sig) = sigs.get(e.hir_id) {\n+                        let mut params = vec![];\n+                        for arg in sig.inputs_and_output().skip_binder().iter() {\n+                            if let ty::Param(param) = arg.kind {\n+                                if param.name != kw::SelfUpper {\n+                                    let name = param.name.to_string();\n+                                    if !params.contains(&name) {\n+                                        params.push(name);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        if !params.is_empty() {\n+                            err.span_suggestion(\n+                                segment.ident.span,\n+                                &format!(\n+                                    \"consider specifying the type argument{} in the method call\",\n+                                    if params.len() > 1 {\n+                                        \"s\"\n+                                    } else {\n+                                        \"\"\n+                                    },\n+                                ),\n+                                format!(\"{}::<{}>\", snippet, params.join(\", \")),\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        } else {\n+                            err.span_label(e.span, &format!(\n+                                \"this method call resolves to `{:?}`\",\n+                                sig.output().skip_binder(),\n+                            ));\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "2da43bdcc1e261ba964c6da85602eb2c7dcecec7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33b06362fa9207ec1beae209a39d974f6c471206/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b06362fa9207ec1beae209a39d974f6c471206/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=33b06362fa9207ec1beae209a39d974f6c471206", "patch": "@@ -338,6 +338,8 @@ pub struct TypeckTables<'tcx> {\n     /// typeck::check::fn_ctxt for details.\n     node_types: ItemLocalMap<Ty<'tcx>>,\n \n+    node_method_sig: ItemLocalMap<ty::PolyFnSig<'tcx>>,\n+\n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node. This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n@@ -442,6 +444,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             user_provided_types: Default::default(),\n             user_provided_sigs: Default::default(),\n             node_types: Default::default(),\n+            node_method_sig: Default::default(),\n             node_substs: Default::default(),\n             adjustments: Default::default(),\n             pat_binding_modes: Default::default(),\n@@ -542,6 +545,20 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn node_method_sig(&self) -> LocalTableInContext<'_, ty::PolyFnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.node_method_sig\n+        }\n+    }\n+\n+    pub fn node_method_sig_mut(&mut self) -> LocalTableInContextMut<'_, ty::PolyFnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_method_sig\n+        }\n+    }\n+\n     pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         self.node_type_opt(id).unwrap_or_else(||\n             bug!(\"node_type: no type for node `{}`\",\n@@ -748,6 +765,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref user_provided_types,\n             ref user_provided_sigs,\n             ref node_types,\n+            ref node_method_sig,\n             ref node_substs,\n             ref adjustments,\n             ref pat_binding_modes,\n@@ -774,6 +792,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             user_provided_types.hash_stable(hcx, hasher);\n             user_provided_sigs.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n+            node_method_sig.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);"}, {"sha": "5f971a1ad505b3b7048676432106e921c3cc78af", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/33b06362fa9207ec1beae209a39d974f6c471206/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b06362fa9207ec1beae209a39d974f6c471206/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=33b06362fa9207ec1beae209a39d974f6c471206", "patch": "@@ -871,6 +871,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n             Ok(method) => {\n+                let sig = self.tcx.fn_sig(method.def_id);\n+                // We could add a \"consider `foo::<params>`\" suggestion here, but I wasn't able to\n+                // trigger this codepath causing `structuraly_resolved_type` to emit an error.\n+\n+                // We could do this only when type params are present in the method to reducte\n+                // memory usage, but doing it unconditionally lets us also point at the method\n+                // expression and state the resolved return value:\n+                // ```\n+                // error[E0282]: type annotations needed\n+                //    --> $DIR/issue-65611.rs:59:20\n+                //    |\n+                // LL |     let x = buffer.last().unwrap().0.clone();\n+                //    |             -------^^^^--\n+                //    |             |      |\n+                //    |             |      cannot infer type for `T`\n+                //    |             this method call resolves to `std::option::Option<&T>`\n+                //    |\n+                //    = note: type must be known at this point\n+                // ```\n+                self.tables.borrow_mut().node_method_sig_mut().insert(expr.hir_id, sig);\n+\n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }"}, {"sha": "3be08b233e470acafffbd1dfbcab06ada41b4e6a", "filename": "src/test/ui/issues/issue-65611.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b06362fa9207ec1beae209a39d974f6c471206/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33b06362fa9207ec1beae209a39d974f6c471206/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr?ref=33b06362fa9207ec1beae209a39d974f6c471206", "patch": "@@ -2,10 +2,10 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-65611.rs:59:20\n    |\n LL |     let x = buffer.last().unwrap().0.clone();\n-   |                    ^^^^\n-   |                    |\n-   |                    cannot infer type for `T`\n-   |                    help: consider specifying the type argument in the method call: `last::<_>`\n+   |             -------^^^^--\n+   |             |      |\n+   |             |      cannot infer type for `T`\n+   |             this method call resolves to `std::option::Option<&T>`\n    |\n    = note: type must be known at this point\n "}, {"sha": "7911701946cd3db3723e6372177ca6732a3181c4", "filename": "src/test/ui/question-mark-type-infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b06362fa9207ec1beae209a39d974f6c471206/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33b06362fa9207ec1beae209a39d974f6c471206/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr?ref=33b06362fa9207ec1beae209a39d974f6c471206", "patch": "@@ -5,7 +5,7 @@ LL |     l.iter().map(f).collect()?\n    |                     ^^^^^^^\n    |                     |\n    |                     cannot infer type\n-   |                     help: consider specifying the type argument in the method call: `collect::<_>`\n+   |                     help: consider specifying the type argument in the method call: `collect::<B>`\n    |\n    = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n "}, {"sha": "bc1c2f6164b61001079edcb66b9ef476b5dcc218", "filename": "src/test/ui/span/type-annotations-needed-expr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b06362fa9207ec1beae209a39d974f6c471206/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33b06362fa9207ec1beae209a39d974f6c471206/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr?ref=33b06362fa9207ec1beae209a39d974f6c471206", "patch": "@@ -5,7 +5,7 @@ LL |     let _ = (vec![1,2,3]).into_iter().sum() as f64;\n    |                                       ^^^\n    |                                       |\n    |                                       cannot infer type for `S`\n-   |                                       help: consider specifying the type argument in the method call: `sum::<_>`\n+   |                                       help: consider specifying the type argument in the method call: `sum::<S>`\n    |\n    = note: type must be known at this point\n "}]}