{"sha": "56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "node_id": "C_kwDOAAsO6NoAKDU2Y2NkMzBhMjdlNjEyNWVlNmI2NmEzOTFhMjdiYTUwNmY3ZGQxZWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T12:01:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T12:01:21Z"}, "message": "Auto merge of #8127 - dswij:8090, r=xFrednet\n\nFix `enum_variants` FP on prefixes that are not camel-case\n\ncloses #8090\n\nFix FP on `enum_variants` when prefixes are only a substring of a camel-case word. Also adds some util helpers on `str_utils` to help parsing camel-case strings.\n\nThis changes how the lint behaves:\n\n1. previously if the Prefix is only a length of 1, it's going to get ignored, i.e. these were previously ignored and now is warned\n```rust\nenum Foo {\n    cFoo,\n    cBar,\n    cBaz,\n}\n\nenum Something {\n    CCall,\n    CCreate,\n    CCryogenize,\n}\n```\n\n2. non-ascii characters that doesn't have casing will not be split,\n```rust\nenum NonCaps {\n    PrefixXXX,\n    PrefixTea,\n    PrefixCake,\n}\n```\nwill be considered as `PrefixXXX`, `Prefix`, `Prefix`, so this won't lint as opposed to fired previously.\n\nchangelog: [`enum_variant_names`] Fix FP when first prefix are only a substring of a camel-case word.\n\n---\n\n (Edited by `@xFrednet` removed some non ascii characters)", "tree": {"sha": "ee15bbb8fe9eac302434d539fa7688694aad6094", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee15bbb8fe9eac302434d539fa7688694aad6094"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "html_url": "https://github.com/rust-lang/rust/commit/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "526fb6b7eaf374f9f1bc62afbe0250791f1a5253", "url": "https://api.github.com/repos/rust-lang/rust/commits/526fb6b7eaf374f9f1bc62afbe0250791f1a5253", "html_url": "https://github.com/rust-lang/rust/commit/526fb6b7eaf374f9f1bc62afbe0250791f1a5253"}, {"sha": "b82c9ce3af0bd338ef3e532eae8a9f87d6981bf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b82c9ce3af0bd338ef3e532eae8a9f87d6981bf0", "html_url": "https://github.com/rust-lang/rust/commit/b82c9ce3af0bd338ef3e532eae8a9f87d6981bf0"}], "stats": {"total": 259, "additions": 187, "deletions": 72}, "files": [{"sha": "6e1fa836b8f89079c8a1e5779cd909477571903d", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "patch": "@@ -2,8 +2,8 @@\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::source::is_present_in_source;\n-use clippy_utils::str_utils::{self, count_match_end, count_match_start};\n-use rustc_hir::{EnumDef, Item, ItemKind};\n+use clippy_utils::str_utils::{camel_case_split, count_match_end, count_match_start};\n+use rustc_hir::{EnumDef, Item, ItemKind, Variant};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -18,6 +18,12 @@ declare_clippy_lint! {\n     /// Enumeration variant names should specify their variant,\n     /// not repeat the enumeration name.\n     ///\n+    /// ### Limitations\n+    /// Characters with no casing will be considered when comparing prefixes/suffixes\n+    /// This applies to numbers and non-ascii characters without casing\n+    /// e.g. `Foo1` and `Foo2` is considered to have different prefixes\n+    /// (the prefixes are `Foo1` and `Foo2` respectively), as also `Bar\u8783`, `Bar\u87f9`\n+    ///\n     /// ### Example\n     /// ```rust\n     /// enum Cake {\n@@ -120,72 +126,73 @@ impl_lint_pass!(EnumVariantNames => [\n     MODULE_INCEPTION\n ]);\n \n-fn check_variant(\n-    cx: &LateContext<'_>,\n-    threshold: u64,\n-    def: &EnumDef<'_>,\n-    item_name: &str,\n-    item_name_chars: usize,\n-    span: Span,\n-) {\n+fn check_enum_start(cx: &LateContext<'_>, item_name: &str, variant: &Variant<'_>) {\n+    let name = variant.ident.name.as_str();\n+    let item_name_chars = item_name.chars().count();\n+\n+    if count_match_start(item_name, &name).char_count == item_name_chars\n+        && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n+        && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n+    {\n+        span_lint(\n+            cx,\n+            ENUM_VARIANT_NAMES,\n+            variant.span,\n+            \"variant name starts with the enum's name\",\n+        );\n+    }\n+}\n+\n+fn check_enum_end(cx: &LateContext<'_>, item_name: &str, variant: &Variant<'_>) {\n+    let name = variant.ident.name.as_str();\n+    let item_name_chars = item_name.chars().count();\n+\n+    if count_match_end(item_name, &name).char_count == item_name_chars {\n+        span_lint(\n+            cx,\n+            ENUM_VARIANT_NAMES,\n+            variant.span,\n+            \"variant name ends with the enum's name\",\n+        );\n+    }\n+}\n+\n+fn check_variant(cx: &LateContext<'_>, threshold: u64, def: &EnumDef<'_>, item_name: &str, span: Span) {\n     if (def.variants.len() as u64) < threshold {\n         return;\n     }\n-    for var in def.variants {\n-        let name = var.ident.name.as_str();\n-        if count_match_start(item_name, &name).char_count == item_name_chars\n-            && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n-            && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n-        {\n-            span_lint(\n-                cx,\n-                ENUM_VARIANT_NAMES,\n-                var.span,\n-                \"variant name starts with the enum's name\",\n-            );\n-        }\n-        if count_match_end(item_name, &name).char_count == item_name_chars {\n-            span_lint(\n-                cx,\n-                ENUM_VARIANT_NAMES,\n-                var.span,\n-                \"variant name ends with the enum's name\",\n-            );\n-        }\n-    }\n+\n     let first = &def.variants[0].ident.name.as_str();\n-    let mut pre = &first[..str_utils::camel_case_until(&*first).byte_index];\n-    let mut post = &first[str_utils::camel_case_start(&*first).byte_index..];\n+    let mut pre = camel_case_split(first);\n+    let mut post = pre.clone();\n+    post.reverse();\n     for var in def.variants {\n+        check_enum_start(cx, item_name, var);\n+        check_enum_end(cx, item_name, var);\n         let name = var.ident.name.as_str();\n \n-        let pre_match = count_match_start(pre, &name).byte_count;\n-        pre = &pre[..pre_match];\n-        let pre_camel = str_utils::camel_case_until(pre).byte_index;\n-        pre = &pre[..pre_camel];\n-        while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n-            if next.is_numeric() {\n-                return;\n-            }\n-            if next.is_lowercase() {\n-                let last = pre.len() - last.len_utf8();\n-                let last_camel = str_utils::camel_case_until(&pre[..last]);\n-                pre = &pre[..last_camel.byte_index];\n-            } else {\n-                break;\n-            }\n-        }\n+        let variant_split = camel_case_split(&name);\n \n-        let post_match = count_match_end(post, &name);\n-        let post_end = post.len() - post_match.byte_count;\n-        post = &post[post_end..];\n-        let post_camel = str_utils::camel_case_start(post);\n-        post = &post[post_camel.byte_index..];\n+        pre = pre\n+            .iter()\n+            .zip(variant_split.iter())\n+            .take_while(|(a, b)| a == b)\n+            .map(|e| *e.0)\n+            .collect();\n+        post = post\n+            .iter()\n+            .zip(variant_split.iter().rev())\n+            .take_while(|(a, b)| a == b)\n+            .map(|e| *e.0)\n+            .collect();\n     }\n     let (what, value) = match (pre.is_empty(), post.is_empty()) {\n         (true, true) => return,\n-        (false, _) => (\"pre\", pre),\n-        (true, false) => (\"post\", post),\n+        (false, _) => (\"pre\", pre.join(\"\")),\n+        (true, false) => {\n+            post.reverse();\n+            (\"post\", post.join(\"\"))\n+        },\n     };\n     span_lint_and_help(\n         cx,\n@@ -233,7 +240,6 @@ impl LateLintPass<'_> for EnumVariantNames {\n     #[allow(clippy::similar_names)]\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         let item_name = item.ident.name.as_str();\n-        let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);\n         if !item.span.from_expansion() && is_present_in_source(cx, item.span) {\n             if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n@@ -283,7 +289,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.def_id)) {\n-                check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span);\n+                check_variant(cx, self.threshold, def, &item_name, item.span);\n             }\n         }\n         self.modules.push((item.ident.name, item_camel));"}, {"sha": "03a9d3c25fd9862ac9efeaf616deba7fe6d34e2f", "filename": "clippy_utils/src/str_utils.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/clippy_utils%2Fsrc%2Fstr_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/clippy_utils%2Fsrc%2Fstr_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fstr_utils.rs?ref=56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "patch": "@@ -68,6 +68,20 @@ pub fn camel_case_until(s: &str) -> StrIndex {\n /// ```\n #[must_use]\n pub fn camel_case_start(s: &str) -> StrIndex {\n+    camel_case_start_from_idx(s, 0)\n+}\n+\n+/// Returns `StrIndex` of the last camel-case component of `s[idx..]`.\n+///\n+/// ```\n+/// # use clippy_utils::str_utils::{camel_case_start_from_idx, StrIndex};\n+/// assert_eq!(camel_case_start_from_idx(\"AbcDef\", 0), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_start_from_idx(\"AbcDef\", 1), StrIndex::new(3, 3));\n+/// assert_eq!(camel_case_start_from_idx(\"AbcDefGhi\", 0), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_start_from_idx(\"AbcDefGhi\", 1), StrIndex::new(3, 3));\n+/// assert_eq!(camel_case_start_from_idx(\"Abcdefg\", 1), StrIndex::new(7, 7));\n+/// ```\n+pub fn camel_case_start_from_idx(s: &str, start_idx: usize) -> StrIndex {\n     let char_count = s.chars().count();\n     let range = 0..char_count;\n     let mut iter = range.rev().zip(s.char_indices().rev());\n@@ -78,9 +92,13 @@ pub fn camel_case_start(s: &str) -> StrIndex {\n     } else {\n         return StrIndex::new(char_count, s.len());\n     }\n+\n     let mut down = true;\n     let mut last_index = StrIndex::new(char_count, s.len());\n     for (char_index, (byte_index, c)) in iter {\n+        if byte_index < start_idx {\n+            break;\n+        }\n         if down {\n             if c.is_uppercase() {\n                 down = false;\n@@ -98,9 +116,55 @@ pub fn camel_case_start(s: &str) -> StrIndex {\n             return last_index;\n         }\n     }\n+\n     last_index\n }\n \n+/// Get the indexes of camel case components of a string `s`\n+///\n+/// ```\n+/// # use clippy_utils::str_utils::{camel_case_indices, StrIndex};\n+/// assert_eq!(\n+///     camel_case_indices(\"AbcDef\"),\n+///     vec![StrIndex::new(0, 0), StrIndex::new(3, 3), StrIndex::new(6, 6)]\n+/// );\n+/// assert_eq!(\n+///     camel_case_indices(\"abcDef\"),\n+///     vec![StrIndex::new(3, 3), StrIndex::new(6, 6)]\n+/// );\n+/// ```\n+pub fn camel_case_indices(s: &str) -> Vec<StrIndex> {\n+    let mut result = Vec::new();\n+    let mut str_idx = camel_case_start(s);\n+\n+    while str_idx.byte_index < s.len() {\n+        let next_idx = str_idx.byte_index + 1;\n+        result.push(str_idx);\n+        str_idx = camel_case_start_from_idx(s, next_idx);\n+    }\n+    result.push(str_idx);\n+\n+    result\n+}\n+\n+/// Split camel case string into a vector of its components\n+///\n+/// ```\n+/// # use clippy_utils::str_utils::{camel_case_split, StrIndex};\n+/// assert_eq!(camel_case_split(\"AbcDef\"), vec![\"Abc\", \"Def\"]);\n+/// ```\n+pub fn camel_case_split(s: &str) -> Vec<&str> {\n+    let mut offsets = camel_case_indices(s)\n+        .iter()\n+        .map(|e| e.byte_index)\n+        .collect::<Vec<usize>>();\n+    if offsets[0] != 0 {\n+        offsets.insert(0, 0);\n+    }\n+\n+    offsets.windows(2).map(|w| &s[w[0]..w[1]]).collect()\n+}\n+\n /// Dealing with sting comparison can be complicated, this struct ensures that both the\n /// character and byte count are provided for correct indexing.\n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -231,4 +295,31 @@ mod test {\n     fn until_caps() {\n         assert_eq!(camel_case_until(\"ABCD\"), StrIndex::new(0, 0));\n     }\n+\n+    #[test]\n+    fn camel_case_start_from_idx_full() {\n+        assert_eq!(camel_case_start_from_idx(\"AbcDef\", 0), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start_from_idx(\"AbcDef\", 1), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_start_from_idx(\"AbcDef\", 4), StrIndex::new(6, 6));\n+        assert_eq!(camel_case_start_from_idx(\"AbcDefGhi\", 0), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start_from_idx(\"AbcDefGhi\", 1), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_start_from_idx(\"Abcdefg\", 1), StrIndex::new(7, 7));\n+    }\n+\n+    #[test]\n+    fn camel_case_indices_full() {\n+        assert_eq!(camel_case_indices(\"Abc\\u{f6}\\u{f6}DD\"), vec![StrIndex::new(7, 9)]);\n+    }\n+\n+    #[test]\n+    fn camel_case_split_full() {\n+        assert_eq!(camel_case_split(\"A\"), vec![\"A\"]);\n+        assert_eq!(camel_case_split(\"AbcDef\"), vec![\"Abc\", \"Def\"]);\n+        assert_eq!(camel_case_split(\"Abc\"), vec![\"Abc\"]);\n+        assert_eq!(camel_case_split(\"abcDef\"), vec![\"abc\", \"Def\"]);\n+        assert_eq!(\n+            camel_case_split(\"\\u{f6}\\u{f6}AabABcd\"),\n+            vec![\"\\u{f6}\\u{f6}\", \"Aab\", \"A\", \"Bcd\"]\n+        );\n+    }\n }"}, {"sha": "d3662a0a213d2cc4b276a974efd8a111e318b509", "filename": "tests/ui/enum_variants.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/tests%2Fui%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/tests%2Fui%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_variants.rs?ref=56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "patch": "@@ -145,4 +145,10 @@ enum HIDataRequest {\n     DeleteUnpubHIData(String),\n }\n \n+enum North {\n+    Normal,\n+    NoLeft,\n+    NoRight,\n+}\n+\n fn main() {}"}, {"sha": "8a3265086e84fe146cef93d1e3aaad081b97f1c4", "filename": "tests/ui/enum_variants.stderr", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/tests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56ccd30a27e6125ee6b66a391a27ba506f7dd1ec/tests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_variants.stderr?ref=56ccd30a27e6125ee6b66a391a27ba506f7dd1ec", "patch": "@@ -6,6 +6,18 @@ LL |     cFoo,\n    |\n    = note: `-D clippy::enum-variant-names` implied by `-D warnings`\n \n+error: all variants have the same prefix: `c`\n+  --> $DIR/enum_variants.rs:14:1\n+   |\n+LL | / enum Foo {\n+LL | |     cFoo,\n+LL | |     cBar,\n+LL | |     cBaz,\n+LL | | }\n+   | |_^\n+   |\n+   = help: remove the prefixes and use full paths to the variants instead of glob imports\n+\n error: variant name starts with the enum's name\n   --> $DIR/enum_variants.rs:26:5\n    |\n@@ -60,25 +72,25 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: all variants have the same prefix: `WithOut`\n-  --> $DIR/enum_variants.rs:81:1\n+error: all variants have the same prefix: `C`\n+  --> $DIR/enum_variants.rs:59:1\n    |\n-LL | / enum Seallll {\n-LL | |     WithOutCake,\n-LL | |     WithOutTea,\n-LL | |     WithOut,\n+LL | / enum Something {\n+LL | |     CCall,\n+LL | |     CCreate,\n+LL | |     CCryogenize,\n LL | | }\n    | |_^\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: all variants have the same prefix: `Prefix`\n-  --> $DIR/enum_variants.rs:87:1\n+error: all variants have the same prefix: `WithOut`\n+  --> $DIR/enum_variants.rs:81:1\n    |\n-LL | / enum NonCaps {\n-LL | |     Prefix\u7684,\n-LL | |     PrefixTea,\n-LL | |     PrefixCake,\n+LL | / enum Seallll {\n+LL | |     WithOutCake,\n+LL | |     WithOutTea,\n+LL | |     WithOut,\n LL | | }\n    | |_^\n    |\n@@ -108,5 +120,5 @@ LL | | }\n    |\n    = help: remove the postfixes and use full paths to the variants instead of glob imports\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n "}]}