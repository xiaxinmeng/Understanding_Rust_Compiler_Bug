{"sha": "681d747b65e1130096412054f3f222cb19fb3124", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MWQ3NDdiNjVlMTEzMDA5NjQxMjA1NGYzZjIyMmNiMTlmYjMxMjQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-08T12:11:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T12:11:45Z"}, "message": "Rollup merge of #71993 - ecstatic-morse:cleanup-old-liveness, r=jonas-schievink\n\nRemove old `util/liveness.rs` module\n\nThe liveness dataflow analysis now lives in the `dataflow` module, so this one is no longer necessary. I've copied the relevant bits of the module docs for `util::liveness` to `MaybeLiveLocals`. The example in the docs is now a `mir-dataflow` test: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs#L6-L26\n\nThe borrow-checker used the same notion of \"defs\" and \"uses\", so I've moved it into a submodule. I would have moved it to `util/def_use.rs`, since it seems generally useful, but there's already a slightly [different version](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/util/def_use.rs) of the same abstraction needed for copy propagation.", "tree": {"sha": "353227eed09f618ee865035a98e7e1bde9665138", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/353227eed09f618ee865035a98e7e1bde9665138"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/681d747b65e1130096412054f3f222cb19fb3124", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetUyCCRBK7hj4Ov3rIwAAdHIIAA04m5nru62ycyffiEe5Z6hT\n/JRwX/eFfAB4WuJ7KAQwd+8hSDWNjqWkPE5JpO2vikF8iYejpXxBkFafFoBcaPD6\n8XNMfPVubi2JhVkFGPAeby1xYMTrrJcioTuY/jh5jzfzKfhvfZ6d7+7lFt2bbb1x\nE6EbV3Gjcp8Kj+dQWJ3SqQX5mHQ8y2PpR/QrqVcdPevadO0u/3nvBia/MaUTSDpW\nGPCmolKNYAJjiuJr2arCOxutBXrNpVsYnvNyhIhpCrcEWRhec+p9DLwO0/iiPG5M\nFqSpQKZwMNZ+84Kj7ioRfRmtgXOpo1QMmTEspsGI5PjB0AsnjlDfMpR48lQgsYI=\n=jRS3\n-----END PGP SIGNATURE-----\n", "payload": "tree 353227eed09f618ee865035a98e7e1bde9665138\nparent 1e6c1996533d279f87d047be6fc771662a38af72\nparent 046848e23dec4f9327b613617026e93c6c87683b\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588939905 +0200\ncommitter GitHub <noreply@github.com> 1588939905 +0200\n\nRollup merge of #71993 - ecstatic-morse:cleanup-old-liveness, r=jonas-schievink\n\nRemove old `util/liveness.rs` module\n\nThe liveness dataflow analysis now lives in the `dataflow` module, so this one is no longer necessary. I've copied the relevant bits of the module docs for `util::liveness` to `MaybeLiveLocals`. The example in the docs is now a `mir-dataflow` test: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs#L6-L26\n\nThe borrow-checker used the same notion of \"defs\" and \"uses\", so I've moved it into a submodule. I would have moved it to `util/def_use.rs`, since it seems generally useful, but there's already a slightly [different version](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/util/def_use.rs) of the same abstraction needed for copy propagation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/681d747b65e1130096412054f3f222cb19fb3124", "html_url": "https://github.com/rust-lang/rust/commit/681d747b65e1130096412054f3f222cb19fb3124", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/681d747b65e1130096412054f3f222cb19fb3124/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e6c1996533d279f87d047be6fc771662a38af72", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6c1996533d279f87d047be6fc771662a38af72", "html_url": "https://github.com/rust-lang/rust/commit/1e6c1996533d279f87d047be6fc771662a38af72"}, {"sha": "046848e23dec4f9327b613617026e93c6c87683b", "url": "https://api.github.com/repos/rust-lang/rust/commits/046848e23dec4f9327b613617026e93c6c87683b", "html_url": "https://github.com/rust-lang/rust/commit/046848e23dec4f9327b613617026e93c6c87683b"}], "stats": {"total": 426, "additions": 92, "deletions": 334}, "files": [{"sha": "689ec249a2fb4f5c708fc3ffa1e244483a3fe97c", "filename": "src/librustc_mir/borrow_check/def_use.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -0,0 +1,78 @@\n+use rustc_middle::mir::visit::{\n+    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext,\n+};\n+\n+#[derive(Eq, PartialEq, Clone)]\n+pub enum DefUse {\n+    Def,\n+    Use,\n+    Drop,\n+}\n+\n+pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n+    match context {\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DEFS\n+\n+        PlaceContext::MutatingUse(MutatingUseContext::Store) |\n+\n+        // This is potentially both a def and a use...\n+        PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n+\n+        // We let Call define the result in both the success and\n+        // unwind cases. This is not really correct, however it\n+        // does not seem to be observable due to the way that we\n+        // generate MIR. To do things properly, we would apply\n+        // the def in call only to the input from the success\n+        // path and not the unwind path. -nmatsakis\n+        PlaceContext::MutatingUse(MutatingUseContext::Call) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Yield) |\n+\n+        // Storage live and storage dead aren't proper defines, but we can ignore\n+        // values that come before them.\n+        PlaceContext::NonUse(NonUseContext::StorageLive) |\n+        PlaceContext::NonUse(NonUseContext::StorageDead) => Some(DefUse::Def),\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // REGULAR USES\n+        //\n+        // These are uses that occur *outside* of a drop. For the\n+        // purposes of NLL, these are special in that **all** the\n+        // lifetimes appearing in the variable must be live for each regular use.\n+\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n+\n+        // Borrows only consider their local used at the point of the borrow.\n+        // This won't affect the results since we use this analysis for generators\n+        // and we only care about the result at suspension points. Borrows cannot\n+        // cross suspension points so this behavior is unproblematic.\n+        PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n+\n+        PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n+        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n+            Some(DefUse::Use),\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DROP USES\n+        //\n+        // These are uses that occur in a DROP (a MIR drop, not a\n+        // call to `std::mem::drop()`). For the purposes of NLL,\n+        // uses in drop are special because `#[may_dangle]`\n+        // attributes can affect whether lifetimes must be live.\n+\n+        PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n+            Some(DefUse::Drop),\n+\n+        // Debug info is neither def nor use.\n+        PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n+    }\n+}"}, {"sha": "8d8cdfb52934c3502927d63926a6df09d56fade1", "filename": "src/librustc_mir/borrow_check/diagnostics/find_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Ffind_use.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -2,10 +2,10 @@ use std::collections::VecDeque;\n use std::rc::Rc;\n \n use crate::borrow_check::{\n+    def_use::{self, DefUse},\n     nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n-use crate::util::liveness::{self, DefUse};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n@@ -117,7 +117,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'tcx> {\n         });\n \n         if found_it {\n-            self.def_use_result = match liveness::categorize(context) {\n+            self.def_use_result = match def_use::categorize(context) {\n                 Some(DefUse::Def) => Some(DefUseResult::Def),\n                 Some(DefUse::Use) => Some(DefUseResult::UseLive { local }),\n                 Some(DefUse::Drop) => Some(DefUseResult::UseDrop { local }),"}, {"sha": "457f0f8444b8c7af35b6c790fe77dcc792174960", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -51,6 +51,7 @@ use self::path_utils::*;\n mod borrow_set;\n mod constraint_generation;\n mod constraints;\n+mod def_use;\n mod diagnostics;\n mod facts;\n mod invalidation;"}, {"sha": "995e3a60a0c76fa8c6e2083a10a93bfbc93577d6", "filename": "src/librustc_mir/borrow_check/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -3,8 +3,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n \n-use crate::util::liveness::{categorize, DefUse};\n-\n+use crate::borrow_check::def_use::{self, DefUse};\n use crate::borrow_check::region_infer::values::{PointIndex, RegionValueElements};\n \n /// A map that cross references each local with the locations where it\n@@ -160,7 +159,7 @@ impl LocalUseMapBuild<'_> {\n impl Visitor<'tcx> for LocalUseMapBuild<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n         if self.locals_with_use_data[local] {\n-            match categorize(context) {\n+            match def_use::categorize(context) {\n                 Some(DefUse::Def) => self.insert_def(local, location),\n                 Some(DefUse::Use) => self.insert_use(local, location),\n                 Some(DefUse::Drop) => self.insert_drop(local, location),"}, {"sha": "d285098c52ad2097c9aca8d8296b61533b153a6d", "filename": "src/librustc_mir/borrow_check/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -1,7 +1,7 @@\n+use crate::borrow_check::def_use::{self, DefUse};\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::{LookupResult, MoveData};\n-use crate::util::liveness::{categorize, DefUse};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Place};\n use rustc_middle::ty::subst::GenericArg;\n@@ -56,7 +56,7 @@ impl UseFactsExtractor<'_> {\n \n impl Visitor<'tcx> for UseFactsExtractor<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n-        match categorize(context) {\n+        match def_use::categorize(context) {\n             Some(DefUse::Def) => self.insert_def(local, location),\n             Some(DefUse::Use) => self.insert_use(local, location),\n             Some(DefUse::Drop) => self.insert_drop_use(local, location),"}, {"sha": "d24faacd3779e5423ceeb684cb1a5e1c4565e8af", "filename": "src/librustc_mir/dataflow/impls/liveness.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -6,6 +6,13 @@ use crate::dataflow::{AnalysisDomain, Backward, BottomValue, GenKill, GenKillAna\n \n /// A [live-variable dataflow analysis][liveness].\n ///\n+/// This analysis considers references as being used only at the point of the\n+/// borrow. In other words, this analysis does not track uses because of references that already\n+/// exist. See [this `mir-datalow` test][flow-test] for an example. You almost never want to use\n+/// this analysis without also looking at the results of [`MaybeBorrowedLocals`].\n+///\n+/// [`MaybeBorrowedLocals`]: ../struct.MaybeBorrowedLocals.html\n+/// [flow-test]: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs\n /// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n pub struct MaybeLiveLocals;\n "}, {"sha": "c261219cc73cc40ad0681fedc16cb35d69e3f7e5", "filename": "src/librustc_mir/util/liveness.rs", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -1,326 +0,0 @@\n-//! Liveness analysis which computes liveness of MIR local variables at the boundary of basic\n-//! blocks.\n-//!\n-//! This analysis considers references as being used only at the point of the\n-//! borrow. This means that this does not track uses because of references that\n-//! already exist:\n-//!\n-//! ```rust\n-//! fn foo() {\n-//!     x = 0;\n-//!     // `x` is live here ...\n-//!     GLOBAL = &x: *const u32;\n-//!     // ... but not here, even while it can be accessed through `GLOBAL`.\n-//!     foo();\n-//!     x = 1;\n-//!     // `x` is live again here, because it is assigned to `OTHER_GLOBAL`.\n-//!     OTHER_GLOBAL = &x: *const u32;\n-//!     // ...\n-//! }\n-//! ```\n-//!\n-//! This means that users of this analysis still have to check whether\n-//! pre-existing references can be used to access the value (e.g., at movable\n-//! generator yield points, all pre-existing references are invalidated, so this\n-//! doesn't matter).\n-\n-use crate::transform::MirSource;\n-use crate::util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{\n-    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n-};\n-use rustc_middle::mir::Local;\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, TyCtxt};\n-use std::fs;\n-use std::io::{self, BufWriter, Write};\n-use std::path::{Path, PathBuf};\n-\n-pub type LiveVarSet = BitSet<Local>;\n-\n-/// This gives the result of the liveness analysis at the boundary of\n-/// basic blocks.\n-///\n-/// The `V` type defines the set of variables that we computed\n-/// liveness for. This is often `Local`, in which case we computed\n-/// liveness for all variables -- but it can also be some other type,\n-/// which indicates a subset of the variables within the graph.\n-pub struct LivenessResult {\n-    /// Live variables on exit to each basic block. This is equal to\n-    /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LiveVarSet>,\n-}\n-\n-/// Computes which local variables are live within the given function\n-/// `mir`, including drops.\n-pub fn liveness_of_locals(body: &Body<'_>) -> LivenessResult {\n-    let num_live_vars = body.local_decls.len();\n-\n-    let def_use: IndexVec<_, DefsUses> =\n-        body.basic_blocks().iter().map(|b| block(b, num_live_vars)).collect();\n-\n-    let mut outs: IndexVec<_, LiveVarSet> =\n-        body.basic_blocks().indices().map(|_| LiveVarSet::new_empty(num_live_vars)).collect();\n-\n-    let mut bits = LiveVarSet::new_empty(num_live_vars);\n-\n-    // The dirty queue contains the set of basic blocks whose entry sets have changed since they\n-    // were last processed. At the start of the analysis, we initialize the queue in post-order to\n-    // make it more likely that the entry set for a given basic block will have the effects of all\n-    // its successors in the CFG applied before it is processed.\n-    //\n-    // FIXME(ecstaticmorse): Reverse post-order on the reverse CFG may generate a better iteration\n-    // order when cycles are present, but the overhead of computing the reverse CFG may outweigh\n-    // any benefits. Benchmark this and find out.\n-    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body.basic_blocks().len());\n-    for (bb, _) in traversal::postorder(&body) {\n-        dirty_queue.insert(bb);\n-    }\n-\n-    // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n-    // be processed after the ones added above.\n-    for bb in body.basic_blocks().indices() {\n-        dirty_queue.insert(bb);\n-    }\n-\n-    let predecessors = body.predecessors();\n-\n-    while let Some(bb) = dirty_queue.pop() {\n-        // bits = use \u222a (bits - def)\n-        bits.overwrite(&outs[bb]);\n-        def_use[bb].apply(&mut bits);\n-\n-        // `bits` now contains the live variables on entry. Therefore,\n-        // add `bits` to the `out` set for each predecessor; if those\n-        // bits were not already present, then enqueue the predecessor\n-        // as dirty.\n-        //\n-        // (note that `union` returns true if the `self` set changed)\n-        for &pred_bb in &predecessors[bb] {\n-            if outs[pred_bb].union(&bits) {\n-                dirty_queue.insert(pred_bb);\n-            }\n-        }\n-    }\n-\n-    LivenessResult { outs }\n-}\n-\n-#[derive(Eq, PartialEq, Clone)]\n-pub enum DefUse {\n-    Def,\n-    Use,\n-    Drop,\n-}\n-\n-pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n-    match context {\n-        ///////////////////////////////////////////////////////////////////////////\n-        // DEFS\n-\n-        PlaceContext::MutatingUse(MutatingUseContext::Store) |\n-\n-        // This is potentially both a def and a use...\n-        PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n-\n-        // We let Call define the result in both the success and\n-        // unwind cases. This is not really correct, however it\n-        // does not seem to be observable due to the way that we\n-        // generate MIR. To do things properly, we would apply\n-        // the def in call only to the input from the success\n-        // path and not the unwind path. -nmatsakis\n-        PlaceContext::MutatingUse(MutatingUseContext::Call) |\n-        PlaceContext::MutatingUse(MutatingUseContext::Yield) |\n-\n-        // Storage live and storage dead aren't proper defines, but we can ignore\n-        // values that come before them.\n-        PlaceContext::NonUse(NonUseContext::StorageLive) |\n-        PlaceContext::NonUse(NonUseContext::StorageDead) => Some(DefUse::Def),\n-\n-        ///////////////////////////////////////////////////////////////////////////\n-        // REGULAR USES\n-        //\n-        // These are uses that occur *outside* of a drop. For the\n-        // purposes of NLL, these are special in that **all** the\n-        // lifetimes appearing in the variable must be live for each regular use.\n-\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) |\n-        PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n-\n-        // Borrows only consider their local used at the point of the borrow.\n-        // This won't affect the results since we use this analysis for generators\n-        // and we only care about the result at suspension points. Borrows cannot\n-        // cross suspension points so this behavior is unproblematic.\n-        PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n-\n-        PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n-        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n-        PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n-            Some(DefUse::Use),\n-\n-        ///////////////////////////////////////////////////////////////////////////\n-        // DROP USES\n-        //\n-        // These are uses that occur in a DROP (a MIR drop, not a\n-        // call to `std::mem::drop()`). For the purposes of NLL,\n-        // uses in drop are special because `#[may_dangle]`\n-        // attributes can affect whether lifetimes must be live.\n-\n-        PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n-            Some(DefUse::Drop),\n-\n-        // Debug info is neither def nor use.\n-        PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n-    }\n-}\n-\n-struct DefsUsesVisitor {\n-    defs_uses: DefsUses,\n-}\n-\n-#[derive(Eq, PartialEq, Clone)]\n-struct DefsUses {\n-    defs: LiveVarSet,\n-    uses: LiveVarSet,\n-}\n-\n-impl DefsUses {\n-    fn apply(&self, bits: &mut LiveVarSet) -> bool {\n-        bits.subtract(&self.defs) | bits.union(&self.uses)\n-    }\n-\n-    fn add_def(&mut self, index: Local) {\n-        // If it was used already in the block, remove that use\n-        // now that we found a definition.\n-        //\n-        // Example:\n-        //\n-        //     // Defs = {X}, Uses = {}\n-        //     X = 5\n-        //     // Defs = {}, Uses = {X}\n-        //     use(X)\n-        self.uses.remove(index);\n-        self.defs.insert(index);\n-    }\n-\n-    fn add_use(&mut self, index: Local) {\n-        // Inverse of above.\n-        //\n-        // Example:\n-        //\n-        //     // Defs = {}, Uses = {X}\n-        //     use(X)\n-        //     // Defs = {X}, Uses = {}\n-        //     X = 5\n-        //     // Defs = {}, Uses = {X}\n-        //     use(X)\n-        self.defs.remove(index);\n-        self.uses.insert(index);\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n-    fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n-        match categorize(context) {\n-            Some(DefUse::Def) => self.defs_uses.add_def(local),\n-            Some(DefUse::Use | DefUse::Drop) => self.defs_uses.add_use(local),\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn block(b: &BasicBlockData<'_>, locals: usize) -> DefsUses {\n-    let mut visitor = DefsUsesVisitor {\n-        defs_uses: DefsUses {\n-            defs: LiveVarSet::new_empty(locals),\n-            uses: LiveVarSet::new_empty(locals),\n-        },\n-    };\n-\n-    let dummy_location = Location { block: BasicBlock::new(0), statement_index: 0 };\n-\n-    // Visit the various parts of the basic block in reverse. If we go\n-    // forward, the logic in `add_def` and `add_use` would be wrong.\n-    visitor.visit_terminator(b.terminator(), dummy_location);\n-    for statement in b.statements.iter().rev() {\n-        visitor.visit_statement(statement, dummy_location);\n-    }\n-\n-    visitor.defs_uses\n-}\n-\n-pub fn dump_mir<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    pass_name: &str,\n-    source: MirSource<'tcx>,\n-    body: &Body<'tcx>,\n-    result: &LivenessResult,\n-) {\n-    if !dump_enabled(tcx, pass_name, source.def_id()) {\n-        return;\n-    }\n-    let node_path = ty::print::with_forced_impl_filename_line(|| {\n-        // see notes on #41697 below\n-        tcx.def_path_str(source.def_id())\n-    });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, body, result);\n-}\n-\n-fn dump_matched_mir_node<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    pass_name: &str,\n-    node_path: &str,\n-    source: MirSource<'tcx>,\n-    body: &Body<'tcx>,\n-    result: &LivenessResult,\n-) {\n-    let mut file_path = PathBuf::new();\n-    file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n-    let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n-    file_path.push(&file_name);\n-    let _ = fs::File::create(&file_path).and_then(|file| {\n-        let mut file = BufWriter::new(file);\n-        writeln!(file, \"// MIR local liveness analysis for `{}`\", node_path)?;\n-        writeln!(file, \"// source = {:?}\", source)?;\n-        writeln!(file, \"// pass_name = {}\", pass_name)?;\n-        writeln!(file)?;\n-        write_mir_fn(tcx, source, body, &mut file, result)?;\n-        Ok(())\n-    });\n-}\n-\n-pub fn write_mir_fn<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    src: MirSource<'tcx>,\n-    body: &Body<'tcx>,\n-    w: &mut dyn Write,\n-    result: &LivenessResult,\n-) -> io::Result<()> {\n-    write_mir_intro(tcx, src, body, w)?;\n-    for block in body.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet>| {\n-            let live: Vec<String> =\n-                result[block].iter().map(|local| format!(\"{:?}\", local)).collect();\n-            writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n-        };\n-        write_basic_block(tcx, block, body, &mut |_, _| Ok(()), w)?;\n-        print(w, \"   \", &result.outs)?;\n-        if block.index() + 1 != body.basic_blocks().len() {\n-            writeln!(w)?;\n-        }\n-    }\n-\n-    writeln!(w, \"}}\")?;\n-    Ok(())\n-}"}, {"sha": "8bbe207c077ee23e7957c3c1134557111508d453", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681d747b65e1130096412054f3f222cb19fb3124/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=681d747b65e1130096412054f3f222cb19fb3124", "patch": "@@ -8,7 +8,6 @@ pub mod storage;\n mod alignment;\n pub mod collect_writes;\n mod graphviz;\n-pub mod liveness;\n pub(crate) mod pretty;\n \n pub use self::aggregate::expand_aggregate;"}]}