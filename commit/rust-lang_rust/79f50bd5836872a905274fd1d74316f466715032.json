{"sha": "79f50bd5836872a905274fd1d74316f466715032", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZjUwYmQ1ODM2ODcyYTkwNTI3NGZkMWQ3NDMxNmY0NjY3MTUwMzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-20T17:57:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-20T17:57:06Z"}, "message": "Merge #8898\n\n8898: internal: resolve derive helpers r=jonas-schievink a=jonas-schievink\n\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "4cf8f0cfc6dd857911e968c3ef6d25b943a314ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cf8f0cfc6dd857911e968c3ef6d25b943a314ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79f50bd5836872a905274fd1d74316f466715032", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgpqLyCRBK7hj4Ov3rIwAAA1wIAJsSnlk3xipvlcU1KUUl6gEA\n0MX/n5WEX7Yrzf5hyjBemc3H6UfzeHKA/CQ4n7xUwgJJ9Ci76bi8WLHg98CWveDP\niIsM46pJ3/Z1iujUbYvnS/QAfqkoZSqD+jFj4yJqNJij/ch3lPBHnuG+vvWD5DaY\nsAFpSicVB/gfEDPfqDstLXZE5jqy2zCfLmZSsdIPV8V+0XpJDRGOFOLPjzX31eIa\n85Y2T6q6vSmy271J6jf1pnyJXNrTevVOzWqAfviQOPbap5A9vUreBOwMZdQB7VL4\nyFAf6MiCjVXKJb0tbOUysUvCIo5ORhMRGmfqY/Rpao3uVBn94N8z7fDTlPtLmIA=\n=TtJZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 4cf8f0cfc6dd857911e968c3ef6d25b943a314ab\nparent f86a9572f388292e0bf4b9a3df172a097f88b155\nparent 036e5b2806256601408d91b5bbb4907bfb110760\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621533426 +0000\ncommitter GitHub <noreply@github.com> 1621533426 +0000\n\nMerge #8898\n\n8898: internal: resolve derive helpers r=jonas-schievink a=jonas-schievink\n\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79f50bd5836872a905274fd1d74316f466715032", "html_url": "https://github.com/rust-lang/rust/commit/79f50bd5836872a905274fd1d74316f466715032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79f50bd5836872a905274fd1d74316f466715032/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f86a9572f388292e0bf4b9a3df172a097f88b155", "url": "https://api.github.com/repos/rust-lang/rust/commits/f86a9572f388292e0bf4b9a3df172a097f88b155", "html_url": "https://github.com/rust-lang/rust/commit/f86a9572f388292e0bf4b9a3df172a097f88b155"}, {"sha": "036e5b2806256601408d91b5bbb4907bfb110760", "url": "https://api.github.com/repos/rust-lang/rust/commits/036e5b2806256601408d91b5bbb4907bfb110760", "html_url": "https://github.com/rust-lang/rust/commit/036e5b2806256601408d91b5bbb4907bfb110760"}], "stats": {"total": 216, "additions": 141, "deletions": 75}, "files": [{"sha": "2d1cba632d4ff1cff19c604f113073cf784b6c6c", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 119, "deletions": 75, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/79f50bd5836872a905274fd1d74316f466715032/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f50bd5836872a905274fd1d74316f466715032/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=79f50bd5836872a905274fd1d74316f466715032", "patch": "@@ -20,7 +20,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n \n use crate::{\n-    attr::{AttrId, Attrs},\n+    attr::{Attr, AttrId, Attrs},\n     builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n@@ -94,14 +94,14 @@ pub(super) fn collect_defs(\n         unresolved_imports: Vec::new(),\n         resolved_imports: Vec::new(),\n \n-        unexpanded_macros: Vec::new(),\n+        unresolved_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n         proc_macros,\n         exports_proc_macros: false,\n         from_glob_import: Default::default(),\n-        ignore_attrs_on: FxHashSet::default(),\n-        derive_helpers_in_scope: FxHashMap::default(),\n+        ignore_attrs_on: Default::default(),\n+        derive_helpers_in_scope: Default::default(),\n     };\n     match block {\n         Some(block) => {\n@@ -237,7 +237,7 @@ struct DefCollector<'a> {\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n-    unexpanded_macros: Vec<MacroDirective>,\n+    unresolved_macros: Vec<MacroDirective>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n     /// List of procedural macros defined by this crate. This is read from the dynamic library\n@@ -247,7 +247,13 @@ struct DefCollector<'a> {\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n     exports_proc_macros: bool,\n     from_glob_import: PerNsGlobImports,\n-    ignore_attrs_on: FxHashSet<InFile<ModItem>>,\n+    /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.\n+    /// This map is used to skip all attributes up to and including the one that failed to resolve,\n+    /// in order to not expand them twice.\n+    ///\n+    /// This also stores the attributes to skip when we resolve derive helpers and non-macro\n+    /// non-builtin attributes in general.\n+    ignore_attrs_on: FxHashMap<InFile<ModItem>, AttrId>,\n     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n@@ -319,7 +325,7 @@ impl DefCollector<'_> {\n                 }\n             }\n \n-            if self.reseed_with_unresolved_attributes() == ReachedFixedPoint::Yes {\n+            if self.reseed_with_unresolved_attribute() == ReachedFixedPoint::Yes {\n                 break;\n             }\n         }\n@@ -362,25 +368,21 @@ impl DefCollector<'_> {\n     }\n \n     /// When the fixed-point loop reaches a stable state, we might still have some unresolved\n-    /// attributes (or unexpanded attribute proc macros) left over. This takes them, and feeds the\n-    /// item they're applied to back into name resolution.\n+    /// attributes (or unexpanded attribute proc macros) left over. This takes one of them, and\n+    /// feeds the item it's applied to back into name resolution.\n     ///\n     /// This effectively ignores the fact that the macro is there and just treats the items as\n     /// normal code.\n     ///\n     /// This improves UX when proc macros are turned off or don't work, and replicates the behavior\n     /// before we supported proc. attribute macros.\n-    fn reseed_with_unresolved_attributes(&mut self) -> ReachedFixedPoint {\n+    fn reseed_with_unresolved_attribute(&mut self) -> ReachedFixedPoint {\n         cov_mark::hit!(unresolved_attribute_fallback);\n \n-        let mut added_items = false;\n-        let unexpanded_macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n-        for directive in &unexpanded_macros {\n-            if let MacroDirectiveKind::Attr { ast_id, mod_item, .. } = &directive.kind {\n-                // Make sure to only add such items once.\n-                if !self.ignore_attrs_on.insert(ast_id.ast_id.with_value(*mod_item)) {\n-                    continue;\n-                }\n+        let mut unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n+        let pos = unresolved_macros.iter().position(|directive| {\n+            if let MacroDirectiveKind::Attr { ast_id, mod_item, attr } = &directive.kind {\n+                self.ignore_attrs_on.insert(ast_id.ast_id.with_value(*mod_item), *attr);\n \n                 let file_id = self.def_map[directive.module_id].definition_source(self.db).file_id;\n                 let item_tree = self.db.file_item_tree(file_id);\n@@ -394,14 +396,20 @@ impl DefCollector<'_> {\n                     mod_dir,\n                 }\n                 .collect(&[*mod_item]);\n-                added_items = true;\n+                true\n+            } else {\n+                false\n             }\n+        });\n+\n+        if let Some(pos) = pos {\n+            unresolved_macros.remove(pos);\n         }\n \n         // The collection above might add new unresolved macros (eg. derives), so merge the lists.\n-        self.unexpanded_macros.extend(unexpanded_macros);\n+        self.unresolved_macros.extend(unresolved_macros);\n \n-        if added_items {\n+        if pos.is_some() {\n             // Continue name resolution with the new data.\n             ReachedFixedPoint::No\n         } else {\n@@ -873,7 +881,7 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n-        let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        let mut macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n@@ -922,14 +930,45 @@ impl DefCollector<'_> {\n                         Err(UnresolvedMacro { .. }) => (),\n                     }\n                 }\n-                MacroDirectiveKind::Attr { .. } => {\n-                    // not yet :)\n+                MacroDirectiveKind::Attr { ast_id, mod_item, attr } => {\n+                    if let Some(ident) = ast_id.path.as_ident() {\n+                        if let Some(helpers) = self.derive_helpers_in_scope.get(&ast_id.ast_id) {\n+                            if helpers.contains(ident) {\n+                                cov_mark::hit!(resolved_derive_helper);\n+\n+                                // Resolved to derive helper. Collect the item's attributes again,\n+                                // starting after the derive helper.\n+                                let file_id = self.def_map[directive.module_id]\n+                                    .definition_source(self.db)\n+                                    .file_id;\n+                                let item_tree = self.db.file_item_tree(file_id);\n+                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                                self.ignore_attrs_on.insert(InFile::new(file_id, *mod_item), *attr);\n+                                ModCollector {\n+                                    def_collector: &mut *self,\n+                                    macro_depth: directive.depth,\n+                                    module_id: directive.module_id,\n+                                    file_id,\n+                                    item_tree: &item_tree,\n+                                    mod_dir,\n+                                }\n+                                .collect(&[*mod_item]);\n+\n+                                // Remove the original directive since we resolved it.\n+                                return false;\n+                            }\n+                        }\n+                    }\n+\n+                    // Not resolved to a derive helper, so try to resolve as a macro.\n+                    // FIXME: not yet :)\n                 }\n             }\n \n             true\n         });\n-        self.unexpanded_macros = macros;\n+        // Attribute resolution can add unresolved macro invocations, so concatenate the lists.\n+        self.unresolved_macros.extend(macros);\n \n         for (module_id, macro_call_id, depth) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth);\n@@ -1000,7 +1039,7 @@ impl DefCollector<'_> {\n     fn finish(mut self) -> DefMap {\n         // Emit diagnostics for all remaining unexpanded macros.\n \n-        for directive in &self.unexpanded_macros {\n+        for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, fragment } => match macro_call_as_call_id(\n                     ast_id,\n@@ -1102,7 +1141,7 @@ impl ModCollector<'_, '_> {\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != self.def_collector.def_map.krate {\n+            if prelude_module.krate != krate {\n                 cov_mark::hit!(prelude_is_macro_use);\n                 self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n@@ -1203,11 +1242,6 @@ impl ModCollector<'_, '_> {\n                 ModItem::Struct(id) => {\n                     let it = &self.item_tree[id];\n \n-                    // FIXME: check attrs to see if this is an attribute macro invocation;\n-                    // in which case we don't add the invocation, just a single attribute\n-                    // macro invocation\n-                    self.collect_derives(&attrs, it.ast_id.upcast());\n-\n                     def = Some(DefData {\n                         id: StructLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n                             .intern(self.def_collector.db)\n@@ -1220,11 +1254,6 @@ impl ModCollector<'_, '_> {\n                 ModItem::Union(id) => {\n                     let it = &self.item_tree[id];\n \n-                    // FIXME: check attrs to see if this is an attribute macro invocation;\n-                    // in which case we don't add the invocation, just a single attribute\n-                    // macro invocation\n-                    self.collect_derives(&attrs, it.ast_id.upcast());\n-\n                     def = Some(DefData {\n                         id: UnionLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n                             .intern(self.def_collector.db)\n@@ -1237,11 +1266,6 @@ impl ModCollector<'_, '_> {\n                 ModItem::Enum(id) => {\n                     let it = &self.item_tree[id];\n \n-                    // FIXME: check attrs to see if this is an attribute macro invocation;\n-                    // in which case we don't add the invocation, just a single attribute\n-                    // macro invocation\n-                    self.collect_derives(&attrs, it.ast_id.upcast());\n-\n                     def = Some(DefData {\n                         id: EnumLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n                             .intern(self.def_collector.db)\n@@ -1453,6 +1477,9 @@ impl ModCollector<'_, '_> {\n     ///\n     /// Returns `Err` when some attributes could not be resolved to builtins and have been\n     /// registered as unresolved.\n+    ///\n+    /// If `ignore_up_to` is `Some`, attributes precending and including that attribute will be\n+    /// assumed to be resolved already.\n     fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n         fn is_builtin_attr(path: &ModPath) -> bool {\n             if path.kind == PathKind::Plain {\n@@ -1478,51 +1505,68 @@ impl ModCollector<'_, '_> {\n             false\n         }\n \n-        // We failed to resolve an attribute on this item earlier, and are falling back to treating\n-        // the item as-is.\n-        if self.def_collector.ignore_attrs_on.contains(&InFile::new(self.file_id, mod_item)) {\n-            return Ok(());\n-        }\n-\n-        match attrs.iter().find(|attr| !is_builtin_attr(&attr.path)) {\n-            Some(non_builtin_attr) => {\n-                log::debug!(\"non-builtin attribute {}\", non_builtin_attr.path);\n+        let mut ignore_up_to =\n+            self.def_collector.ignore_attrs_on.get(&InFile::new(self.file_id, mod_item)).copied();\n+        for attr in attrs.iter().skip_while(|attr| match ignore_up_to {\n+            Some(id) if attr.id == id => {\n+                ignore_up_to = None;\n+                true\n+            }\n+            Some(_) => true,\n+            None => false,\n+        }) {\n+            if attr.path.as_ident() == Some(&hir_expand::name![derive]) {\n+                self.collect_derive(attr, mod_item);\n+            } else if is_builtin_attr(&attr.path) {\n+                continue;\n+            } else {\n+                log::debug!(\"non-builtin attribute {}\", attr.path);\n \n                 let ast_id = AstIdWithPath::new(\n                     self.file_id,\n                     mod_item.ast_id(self.item_tree),\n-                    non_builtin_attr.path.as_ref().clone(),\n+                    attr.path.as_ref().clone(),\n                 );\n-                self.def_collector.unexpanded_macros.push(MacroDirective {\n+                self.def_collector.unresolved_macros.push(MacroDirective {\n                     module_id: self.module_id,\n                     depth: self.macro_depth + 1,\n-                    kind: MacroDirectiveKind::Attr { ast_id, attr: non_builtin_attr.id, mod_item },\n+                    kind: MacroDirectiveKind::Attr { ast_id, attr: attr.id, mod_item },\n                 });\n \n-                Err(())\n+                return Err(());\n             }\n-            None => Ok(()),\n         }\n+\n+        Ok(())\n     }\n \n-    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::Item>) {\n-        for derive in attrs.by_key(\"derive\").attrs() {\n-            match derive.parse_derive() {\n-                Some(derive_macros) => {\n-                    for path in derive_macros {\n-                        let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n-                        self.def_collector.unexpanded_macros.push(MacroDirective {\n-                            module_id: self.module_id,\n-                            depth: self.macro_depth + 1,\n-                            kind: MacroDirectiveKind::Derive { ast_id, derive_attr: derive.id },\n-                        });\n-                    }\n-                }\n-                None => {\n-                    // FIXME: diagnose\n-                    log::debug!(\"malformed derive: {:?}\", derive);\n+    fn collect_derive(&mut self, attr: &Attr, mod_item: ModItem) {\n+        let ast_id: FileAstId<ast::Item> = match mod_item {\n+            ModItem::Struct(it) => self.item_tree[it].ast_id.upcast(),\n+            ModItem::Union(it) => self.item_tree[it].ast_id.upcast(),\n+            ModItem::Enum(it) => self.item_tree[it].ast_id.upcast(),\n+            _ => {\n+                // Cannot use derive on this item.\n+                // FIXME: diagnose\n+                return;\n+            }\n+        };\n+\n+        match attr.parse_derive() {\n+            Some(derive_macros) => {\n+                for path in derive_macros {\n+                    let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n+                    self.def_collector.unresolved_macros.push(MacroDirective {\n+                        module_id: self.module_id,\n+                        depth: self.macro_depth + 1,\n+                        kind: MacroDirectiveKind::Derive { ast_id, derive_attr: attr.id },\n+                    });\n                 }\n             }\n+            None => {\n+                // FIXME: diagnose\n+                log::debug!(\"malformed derive: {:?}\", attr);\n+            }\n         }\n     }\n \n@@ -1686,7 +1730,7 @@ impl ModCollector<'_, '_> {\n             ast_id.path.kind = PathKind::Super(0);\n         }\n \n-        self.def_collector.unexpanded_macros.push(MacroDirective {\n+        self.def_collector.unresolved_macros.push(MacroDirective {\n             module_id: self.module_id,\n             depth: self.macro_depth + 1,\n             kind: MacroDirectiveKind::FnLike { ast_id, fragment: mac.fragment },\n@@ -1731,13 +1775,13 @@ mod tests {\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n             resolved_imports: Vec::new(),\n-            unexpanded_macros: Vec::new(),\n+            unresolved_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n             proc_macros: Default::default(),\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n-            ignore_attrs_on: FxHashSet::default(),\n+            ignore_attrs_on: Default::default(),\n             derive_helpers_in_scope: FxHashMap::default(),\n         };\n         collector.seed_with_top_level();"}, {"sha": "04de107f5b71c8a2e55a8c2cced58a12e564e376", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/79f50bd5836872a905274fd1d74316f466715032/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f50bd5836872a905274fd1d74316f466715032/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=79f50bd5836872a905274fd1d74316f466715032", "patch": "@@ -735,6 +735,28 @@ fn unresolved_attributes_fall_back_track_per_file_moditems() {\n     );\n }\n \n+#[test]\n+fn resolves_derive_helper() {\n+    cov_mark::check!(resolved_derive_helper);\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:proc\n+#[derive(proc::Derive)]\n+#[helper]\n+#[unresolved]\n+struct S;\n+\n+//- /proc.rs crate:proc\n+#[proc_macro_derive(Derive, attributes(helper))]\n+fn derive() {}\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            S: t v\n+        \"#]],\n+    )\n+}\n+\n #[test]\n fn macro_expansion_overflow() {\n     cov_mark::check!(macro_expansion_overflow);"}]}