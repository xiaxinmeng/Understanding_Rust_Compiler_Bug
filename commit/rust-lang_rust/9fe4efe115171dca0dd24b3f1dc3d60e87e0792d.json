{"sha": "9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "node_id": "C_kwDOAAsO6NoAKDlmZTRlZmUxMTUxNzFkY2EwZGQyNGIzZjFkYzNkNjBlODdlMDc5MmQ", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-30T22:25:19Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-02T19:22:19Z"}, "message": "Abolish `QueryVTable` in favour of more assoc items on `QueryConfig`\n\nThis may introduce additional mono _but_ may help const fold things\nbetter and especially may help not constructing a `QueryVTable` anymore\nwhich is cheap but not free.", "tree": {"sha": "b32f3a322631da2288857a3056af6c634e30a6f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b32f3a322631da2288857a3056af6c634e30a6f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "html_url": "https://github.com/rust-lang/rust/commit/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e5fcb0b758fcf7f149cc9206155dcfa18ec909", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e5fcb0b758fcf7f149cc9206155dcfa18ec909", "html_url": "https://github.com/rust-lang/rust/commit/e5e5fcb0b758fcf7f149cc9206155dcfa18ec909"}], "stats": {"total": 209, "additions": 95, "deletions": 114}, "files": [{"sha": "2d243e13cc21249a6679d1e298be44dce69c7024", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "patch": "@@ -34,7 +34,6 @@ use rustc_query_system::query::*;\n pub use rustc_query_system::query::{deadlock, QueryContext};\n \n pub use rustc_query_system::query::QueryConfig;\n-pub(crate) use rustc_query_system::query::QueryVTable;\n \n mod on_disk_cache;\n pub use on_disk_cache::OnDiskCache;"}, {"sha": "535445e70bc15c519afd3abd47164c09b010af63", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "patch": "@@ -493,28 +493,32 @@ macro_rules! define_queries {\n                 &tcx.query_caches.$name\n             }\n \n+            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Stored {\n+                tcx.$name(key)\n+            }\n+\n             #[inline]\n-            fn make_vtable(tcx: QueryCtxt<'tcx>, key: &Self::Key) ->\n-                QueryVTable<QueryCtxt<'tcx>, Self::Key, Self::Value>\n-            {\n-                let compute = get_provider!([$($modifiers)*][tcx, $name, key]);\n-                let cache_on_disk = Self::cache_on_disk(tcx.tcx, key);\n-                QueryVTable {\n-                    anon: is_anon!([$($modifiers)*]),\n-                    eval_always: is_eval_always!([$($modifiers)*]),\n-                    depth_limit: depth_limit!([$($modifiers)*]),\n-                    feedable: feedable!([$($modifiers)*]),\n-                    dep_kind: dep_graph::DepKind::$name,\n-                    hash_result: hash_result!([$($modifiers)*]),\n-                    handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n-                    compute,\n-                    try_load_from_disk: if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None },\n-                }\n+            // key is only sometimes used\n+            #[allow(unused_variables)]\n+            fn compute(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> fn(TyCtxt<'tcx>, Self::Key) -> Self::Value {\n+                get_provider!([$($modifiers)*][qcx, $name, key])\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, k: Self::Key) -> Self::Stored {\n-                tcx.$name(k)\n+            #[inline]\n+            fn try_load_from_disk(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+                let cache_on_disk = Self::cache_on_disk(qcx.tcx, key);\n+                if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None }\n             }\n+\n+            const ANON: bool = is_anon!([$($modifiers)*]);\n+            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+            const DEPTH_LIMIT: bool = depth_limit!([$($modifiers)*]);\n+            const FEEDABLE: bool = feedable!([$($modifiers)*]);\n+\n+            const DEP_KIND: rustc_middle::dep_graph::DepKind = dep_graph::DepKind::$name;\n+            const HANDLE_CYCLE_ERROR: rustc_query_system::HandleCycleError = handle_cycle_error!([$($modifiers)*]);\n+\n+            const HASH_RESULT: rustc_query_system::query::HashResult<QueryCtxt<'tcx>, Self> = hash_result!([$($modifiers)*]);\n         })*\n \n         #[allow(nonstandard_style)]"}, {"sha": "8c0330e438de4724711816ed47742d1e5537aee1", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "patch": "@@ -1,7 +1,6 @@\n //! Query configuration and description traits.\n \n-use crate::dep_graph::DepNode;\n-use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::dep_graph::{DepNode, DepNodeParams, SerializedDepNodeIndex};\n use crate::error::HandleCycleError;\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n@@ -11,10 +10,16 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n+pub type HashResult<Qcx, Q> =\n+    Option<fn(&mut StableHashingContext<'_>, &<Q as QueryConfig<Qcx>>::Value) -> Fingerprint>;\n+\n+pub type TryLoadFromDisk<Qcx, Q> =\n+    Option<fn(Qcx, SerializedDepNodeIndex) -> Option<<Q as QueryConfig<Qcx>>::Value>>;\n+\n pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n-    type Key: Eq + Hash + Clone + Debug;\n+    type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n     type Value: Debug;\n     type Stored: Debug + Clone + std::borrow::Borrow<Self::Value>;\n \n@@ -30,39 +35,27 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     where\n         Qcx: 'a;\n \n-    // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn make_vtable(tcx: Qcx, key: &Self::Key) -> QueryVTable<Qcx, Self::Key, Self::Value>;\n-\n     fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n-}\n \n-#[derive(Copy, Clone)]\n-pub struct QueryVTable<Qcx: QueryContext, K, V> {\n-    pub anon: bool,\n-    pub dep_kind: Qcx::DepKind,\n-    pub eval_always: bool,\n-    pub depth_limit: bool,\n-    pub feedable: bool,\n-\n-    pub compute: fn(Qcx::DepContext, K) -> V,\n-    pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n-    pub handle_cycle_error: HandleCycleError,\n-    // NOTE: this is also `None` if `cache_on_disk()` returns false, not just if it's unsupported by the query\n-    pub try_load_from_disk: Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>,\n-}\n+    fn compute(tcx: Qcx, key: &Self::Key) -> fn(Qcx::DepContext, Self::Key) -> Self::Value;\n \n-impl<Qcx: QueryContext, K, V> QueryVTable<Qcx, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: Qcx::DepContext, key: &K) -> DepNode<Qcx::DepKind>\n-    where\n-        K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n-    {\n-        DepNode::construct(tcx, self.dep_kind, key)\n-    }\n+    fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n+\n+    const ANON: bool;\n+    const EVAL_ALWAYS: bool;\n+    const DEPTH_LIMIT: bool;\n+    const FEEDABLE: bool;\n+\n+    const DEP_KIND: Qcx::DepKind;\n+    const HANDLE_CYCLE_ERROR: HandleCycleError;\n+\n+    const HASH_RESULT: HashResult<Qcx, Self>;\n \n-    pub(crate) fn compute(&self, tcx: Qcx::DepContext, key: K) -> V {\n-        (self.compute)(tcx, key)\n+    // Just here for convernience and checking that the key matches the kind, don't override this.\n+    fn construct_dep_node(tcx: Qcx::DepContext, key: &Self::Key) -> DepNode<Qcx::DepKind> {\n+        DepNode::construct(tcx, Self::DEP_KIND, key)\n     }\n }"}, {"sha": "d308af192076051ef23b0098f3375e39791a879a", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "patch": "@@ -12,7 +12,7 @@ pub use self::caches::{\n };\n \n mod config;\n-pub use self::config::{QueryConfig, QueryVTable};\n+pub use self::config::{HashResult, QueryConfig, TryLoadFromDisk};\n \n use crate::dep_graph::DepKind;\n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};"}, {"sha": "da1ac6a5fb227dd48daf9c075a238a2ebbf4b773", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 49, "deletions": 64, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe4efe115171dca0dd24b3f1dc3d60e87e0792d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=9fe4efe115171dca0dd24b3f1dc3d60e87e0792d", "patch": "@@ -2,10 +2,9 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n-use crate::query::config::QueryVTable;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use crate::values::Value;\n@@ -361,44 +360,42 @@ where\n     })\n }\n \n-fn try_execute_query<Qcx, C>(\n+fn try_execute_query<Q, Qcx>(\n     qcx: Qcx,\n-    state: &QueryState<C::Key, Qcx::DepKind>,\n-    cache: &C,\n+    state: &QueryState<Q::Key, Qcx::DepKind>,\n+    cache: &Q::Cache,\n     span: Span,\n-    key: C::Key,\n+    key: Q::Key,\n     dep_node: Option<DepNode<Qcx::DepKind>>,\n-    query: &QueryVTable<Qcx, C::Key, C::Value>,\n-) -> (C::Stored, Option<DepNodeIndex>)\n+) -> (Q::Stored, Option<DepNodeIndex>)\n where\n-    C: QueryCache,\n-    C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n-    C::Value: Value<Qcx::DepContext, Qcx::DepKind>,\n-    C::Stored: Debug + std::borrow::Borrow<C::Value>,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    match JobOwner::<'_, C::Key, Qcx::DepKind>::try_start(&qcx, state, span, key.clone()) {\n+    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(qcx, key.clone(), dep_node, query, job.id);\n-            if query.feedable {\n+            let (result, dep_node_index) =\n+                execute_job::<Q, Qcx>(qcx, key.clone(), dep_node, job.id);\n+            if Q::FEEDABLE {\n                 // We may have put a value inside the cache from inside the execution.\n                 // Verify that it has the same hash as what we have now, to ensure consistency.\n                 let _ = cache.lookup(&key, |cached_result, _| {\n-                    let hasher = query.hash_result.expect(\"feedable forbids no_hash\");\n+                    let hasher = Q::HASH_RESULT.expect(\"feedable forbids no_hash\");\n+\n                     let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, cached_result.borrow()));\n                     let new_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n                     debug_assert_eq!(\n                         old_hash, new_hash,\n                         \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n-                        query.dep_kind, key, result, cached_result,\n+                        Q::DEP_KIND, key, result, cached_result,\n                     );\n                 });\n             }\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(qcx, error, query.handle_cycle_error, cache);\n+            let result = mk_cycle(qcx, error, Q::HANDLE_CYCLE_ERROR, cache);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n@@ -417,40 +414,38 @@ where\n     }\n }\n \n-fn execute_job<Qcx, K, V>(\n+fn execute_job<Q, Qcx>(\n     qcx: Qcx,\n-    key: K,\n+    key: Q::Key,\n     mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n-    query: &QueryVTable<Qcx, K, V>,\n     job_id: QueryJobId,\n-) -> (V, DepNodeIndex)\n+) -> (Q::Value, DepNodeIndex)\n where\n-    K: Clone + DepNodeParams<Qcx::DepContext>,\n-    V: Debug,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n     let dep_graph = qcx.dep_context().dep_graph();\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, query.depth_limit, None, || {\n-            query.compute(*qcx.dep_context(), key)\n+        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || {\n+            Q::compute(qcx, &key)(*qcx.dep_context(), key)\n         });\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n     }\n \n-    if !query.anon && !query.eval_always {\n+    if !Q::ANON && !Q::EVAL_ALWAYS {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*qcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = qcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(qcx, &key, &dep_node, query)\n+            try_load_from_disk_and_cache_in_memory::<Q, Qcx>(qcx, &key, &dep_node)\n         }) {\n             return ret;\n         }\n@@ -460,18 +455,19 @@ where\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        qcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n-            if query.anon {\n-                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind, || {\n-                    query.compute(*qcx.dep_context(), key)\n+        qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n+            if Q::ANON {\n+                return dep_graph.with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || {\n+                    Q::compute(qcx, &key)(*qcx.dep_context(), key)\n                 });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*qcx.dep_context(), &key));\n+                dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(dep_node, *qcx.dep_context(), key, query.compute, query.hash_result)\n+            let task = Q::compute(qcx, &key);\n+            dep_graph.with_task(dep_node, *qcx.dep_context(), key, task, Q::HASH_RESULT)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -480,7 +476,7 @@ where\n     let side_effects = QuerySideEffects { diagnostics };\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n-        if query.anon {\n+        if Q::ANON {\n             qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n             qcx.store_side_effects(dep_node_index, side_effects);\n@@ -490,16 +486,14 @@ where\n     (result, dep_node_index)\n }\n \n-fn try_load_from_disk_and_cache_in_memory<Qcx, K, V>(\n+fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n     qcx: Qcx,\n-    key: &K,\n+    key: &Q::Key,\n     dep_node: &DepNode<Qcx::DepKind>,\n-    query: &QueryVTable<Qcx, K, V>,\n-) -> Option<(V, DepNodeIndex)>\n+) -> Option<(Q::Value, DepNodeIndex)>\n where\n-    K: Clone,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n-    V: Debug,\n {\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n@@ -511,7 +505,7 @@ where\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n-    if let Some(try_load_from_disk) = query.try_load_from_disk {\n+    if let Some(try_load_from_disk) = Q::try_load_from_disk(qcx, &key) {\n         let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n@@ -545,7 +539,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n             }\n \n             return Some((result, dep_node_index));\n@@ -565,7 +559,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(*qcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| Q::compute(qcx, key)(*qcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -578,7 +572,7 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n \n     Some((result, dep_node_index))\n }\n@@ -699,23 +693,19 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<Qcx, K, V>(\n-    qcx: Qcx,\n-    key: &K,\n-    query: &QueryVTable<Qcx, K, V>,\n-) -> (bool, Option<DepNode<Qcx::DepKind>>)\n+fn ensure_must_run<Q, Qcx>(qcx: Qcx, key: &Q::Key) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n-    K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    if query.eval_always {\n+    if Q::EVAL_ALWAYS {\n         return (true, None);\n     }\n \n     // Ensuring an anonymous query makes no sense\n-    assert!(!query.anon);\n+    assert!(!Q::ANON);\n \n-    let dep_node = query.to_dep_node(*qcx.dep_context(), key);\n+    let dep_node = Q::construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n     match dep_graph.try_mark_green(qcx, &dep_node) {\n@@ -746,13 +736,11 @@ pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode)\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,\n-    Q::Key: DepNodeParams<Qcx::DepContext>,\n     Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n-    let query = Q::make_vtable(qcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(qcx, &key, &query);\n+        let (must_run, dep_node) = ensure_must_run::<Q, _>(qcx, &key);\n         if !must_run {\n             return None;\n         }\n@@ -761,14 +749,13 @@ where\n         None\n     };\n \n-    let (result, dep_node_index) = try_execute_query(\n+    let (result, dep_node_index) = try_execute_query::<Q, Qcx>(\n         qcx,\n         Q::query_state(qcx),\n         Q::query_cache(qcx),\n         span,\n         key,\n         dep_node,\n-        &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n         qcx.dep_context().dep_graph().read_index(dep_node_index)\n@@ -780,7 +767,6 @@ pub fn force_query<Q, Qcx, D>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepK\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,\n-    Q::Key: DepNodeParams<Qcx::DepContext>,\n     Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n@@ -798,9 +784,8 @@ where\n         Err(()) => {}\n     }\n \n-    let query = Q::make_vtable(qcx, &key);\n     let state = Q::query_state(qcx);\n-    debug_assert!(!query.anon);\n+    debug_assert!(!Q::ANON);\n \n-    try_execute_query(qcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n+    try_execute_query::<Q, _>(qcx, state, cache, DUMMY_SP, key, Some(dep_node));\n }"}]}