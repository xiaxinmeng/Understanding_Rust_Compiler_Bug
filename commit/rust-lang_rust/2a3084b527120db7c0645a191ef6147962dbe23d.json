{"sha": "2a3084b527120db7c0645a191ef6147962dbe23d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMzA4NGI1MjcxMjBkYjdjMDY0NWExOTFlZjYxNDc5NjJkYmUyM2Q=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-01T01:34:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-01T01:34:44Z"}, "message": "Start implementing structured constants.", "tree": {"sha": "8afd66f6e0116586ad9460e77d600224b8377c10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8afd66f6e0116586ad9460e77d600224b8377c10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a3084b527120db7c0645a191ef6147962dbe23d", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3084b527120db7c0645a191ef6147962dbe23d", "html_url": "https://github.com/rust-lang/rust/commit/2a3084b527120db7c0645a191ef6147962dbe23d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a3084b527120db7c0645a191ef6147962dbe23d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285fc53570b31965e6b81dad98a6091d90e67065", "url": "https://api.github.com/repos/rust-lang/rust/commits/285fc53570b31965e6b81dad98a6091d90e67065", "html_url": "https://github.com/rust-lang/rust/commit/285fc53570b31965e6b81dad98a6091d90e67065"}], "stats": {"total": 368, "additions": 196, "deletions": 172}, "files": [{"sha": "3be041f4e9a56423d47491221346182e6c26d755", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=2a3084b527120db7c0645a191ef6147962dbe23d", "patch": "@@ -101,6 +101,8 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n               }\n             }\n           }\n+          expr_tup(*) |\n+          expr_rec(*) { }\n           _ {\n             sess.span_err(e.span,\n                           ~\"constant contains unimplemented expression type\");"}, {"sha": "ef957e1c75ac5f216657aac1657686e551589b5b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=2a3084b527120db7c0645a191ef6147962dbe23d", "patch": "@@ -58,14 +58,14 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n           }\n           _ {\n             ret single_result(\n-                rslt(bcx, trans_const_expr(ccx, l)));\n+                rslt(bcx, consts::const_expr(ccx, l)));\n           }\n         }\n       }\n       var(disr_val, _) { ret single_result(rslt(bcx, C_int(ccx, disr_val))); }\n       range(l1, l2) {\n-        ret range_result(rslt(bcx, trans_const_expr(ccx, l1)),\n-                         rslt(bcx, trans_const_expr(ccx, l2)));\n+        ret range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n+                         rslt(bcx, consts::const_expr(ccx, l2)));\n       }\n     }\n }"}, {"sha": "5960b7657f4613e033245a7d3e486d77fa158967", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 169, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2a3084b527120db7c0645a191ef6147962dbe23d", "patch": "@@ -1420,48 +1420,18 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n     ret move_val(cx, action, dst, src, t);\n }\n \n-fn trans_crate_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n-    -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"trans_crate_lit\");\n-    alt lit.node {\n-      ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n-      ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n-      ast::lit_int_unsuffixed(i) {\n-        let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n-        alt ty::get(lit_int_ty).struct {\n-          ty::ty_int(t) {\n-            C_integral(T_int_ty(cx, t), i as u64, True)\n-          }\n-          ty::ty_uint(t) {\n-            C_integral(T_uint_ty(cx, t), i as u64, False)\n-          }\n-          _ { cx.sess.span_bug(lit.span,\n-                               ~\"integer literal doesn't have a type\");\n-            }\n-        }\n-      }\n-      ast::lit_float(fs, t) { C_floating(*fs, T_float_ty(cx, t)) }\n-      ast::lit_bool(b) { C_bool(b) }\n-      ast::lit_nil { C_nil() }\n-      ast::lit_str(s) {\n-        cx.sess.span_unimpl(lit.span, ~\"unique string in this context\");\n-      }\n-    }\n-}\n-\n fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n     let _icx = cx.insn_ctxt(~\"trans_lit\");\n     if dest == ignore { ret cx; }\n     alt lit.node {\n       ast::lit_str(s) { tvec::trans_estr(cx, s,\n                                          ast::vstore_fixed(none), dest) }\n       _ {\n-        store_in_dest(cx, trans_crate_lit(cx.ccx(), e, lit), dest)\n+        store_in_dest(cx, consts::const_lit(cx.ccx(), e, lit), dest)\n       }\n     }\n }\n \n-\n fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n                     t: ty::t, heap: heap,\n                     dest: dest) -> block {\n@@ -1473,7 +1443,6 @@ fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n     ret store_in_dest(bcx, box, dest);\n }\n \n-\n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_unary\");\n@@ -4716,142 +4685,6 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     finish_fn(fcx, lltop);\n }\n \n-\n-// FIXME (#2530): this should do some structural hash-consing to avoid\n-// duplicate constants. I think. Maybe LLVM has a magical mode that does so\n-// later on?\n-fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"trans_const_expr\");\n-    alt e.node {\n-      ast::expr_lit(lit) { trans_crate_lit(cx, e, *lit) }\n-      // If we have a vstore, just keep going; it has to be a string\n-      ast::expr_vstore(e, _) { trans_const_expr(cx, e) }\n-      ast::expr_binary(b, e1, e2) {\n-        let te1 = trans_const_expr(cx, e1);\n-        let te2 = trans_const_expr(cx, e2);\n-\n-        let te2 = cast_shift_const_rhs(b, te1, te2);\n-\n-        /* Neither type is bottom, and we expect them to be unified already,\n-         * so the following is safe. */\n-        let ty = ty::expr_ty(cx.tcx, e1);\n-        let is_float = ty::type_is_fp(ty);\n-        let signed = ty::type_is_signed(ty);\n-        ret alt b {\n-          ast::add    {\n-            if is_float { llvm::LLVMConstFAdd(te1, te2) }\n-            else        { llvm::LLVMConstAdd(te1, te2) }\n-          }\n-          ast::subtract {\n-            if is_float { llvm::LLVMConstFSub(te1, te2) }\n-            else        { llvm::LLVMConstSub(te1, te2) }\n-          }\n-          ast::mul    {\n-            if is_float { llvm::LLVMConstFMul(te1, te2) }\n-            else        { llvm::LLVMConstMul(te1, te2) }\n-          }\n-          ast::div    {\n-            if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n-            else if signed { llvm::LLVMConstSDiv(te1, te2) }\n-            else           { llvm::LLVMConstUDiv(te1, te2) }\n-          }\n-          ast::rem    {\n-            if is_float    { llvm::LLVMConstFRem(te1, te2) }\n-            else if signed { llvm::LLVMConstSRem(te1, te2) }\n-            else           { llvm::LLVMConstURem(te1, te2) }\n-          }\n-          ast::and    |\n-          ast::or     { cx.sess.span_unimpl(e.span, ~\"binop logic\"); }\n-          ast::bitxor { llvm::LLVMConstXor(te1, te2) }\n-          ast::bitand { llvm::LLVMConstAnd(te1, te2) }\n-          ast::bitor  { llvm::LLVMConstOr(te1, te2) }\n-          ast::shl    { llvm::LLVMConstShl(te1, te2) }\n-          ast::shr    {\n-            if signed { llvm::LLVMConstAShr(te1, te2) }\n-            else      { llvm::LLVMConstLShr(te1, te2) }\n-          }\n-          ast::eq     |\n-          ast::lt     |\n-          ast::le     |\n-          ast::ne     |\n-          ast::ge     |\n-          ast::gt     { cx.sess.span_unimpl(e.span, ~\"binop comparator\"); }\n-        }\n-      }\n-      ast::expr_unary(u, e) {\n-        let te = trans_const_expr(cx, e);\n-        let ty = ty::expr_ty(cx.tcx, e);\n-        let is_float = ty::type_is_fp(ty);\n-        ret alt u {\n-          ast::box(_)  |\n-          ast::uniq(_) |\n-          ast::deref   { cx.sess.span_bug(e.span,\n-                           ~\"bad unop type in trans_const_expr\"); }\n-          ast::not    { llvm::LLVMConstNot(te) }\n-          ast::neg    {\n-            if is_float { llvm::LLVMConstFNeg(te) }\n-            else        { llvm::LLVMConstNeg(te) }\n-          }\n-        }\n-      }\n-      ast::expr_cast(base, tp) {\n-        let ety = ty::expr_ty(cx.tcx, e), llty = type_of(cx, ety);\n-        let basety = ty::expr_ty(cx.tcx, base);\n-        let v = trans_const_expr(cx, base);\n-        alt check (cast_type_kind(basety), cast_type_kind(ety)) {\n-          (cast_integral, cast_integral) {\n-            let s = if ty::type_is_signed(basety) { True } else { False };\n-            llvm::LLVMConstIntCast(v, llty, s)\n-          }\n-          (cast_integral, cast_float) {\n-            if ty::type_is_signed(basety) { llvm::LLVMConstSIToFP(v, llty) }\n-            else { llvm::LLVMConstUIToFP(v, llty) }\n-          }\n-          (cast_float, cast_float) { llvm::LLVMConstFPCast(v, llty) }\n-          (cast_float, cast_integral) {\n-            if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n-            else { llvm::LLVMConstFPToUI(v, llty) }\n-          }\n-        }\n-      }\n-      ast::expr_path(path) {\n-        alt cx.tcx.def_map.find(e.id) {\n-          some(ast::def_const(def_id)) {\n-            // Don't know how to handle external consts\n-            assert ast_util::is_local(def_id);\n-            alt cx.tcx.items.get(def_id.node) {\n-              ast_map::node_item(@{\n-                node: ast::item_const(_, subexpr), _\n-              }, _) {\n-                // FIXME (#2530): Instead of recursing here to regenerate\n-                // the values for other constants, we should just look up\n-                // the already-defined value.\n-                trans_const_expr(cx, subexpr)\n-              }\n-              _ {\n-                cx.sess.span_bug(e.span, ~\"expected item\");\n-              }\n-            }\n-          }\n-          _ { cx.sess.span_bug(e.span, ~\"expected to find a const def\") }\n-        }\n-      }\n-      _ { cx.sess.span_bug(e.span,\n-            ~\"bad constant expression type in trans_const_expr\"); }\n-    }\n-}\n-\n-fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(~\"trans_const\");\n-    let v = trans_const_expr(ccx, e);\n-\n-    // The scalars come back as 1st class LLVM vals\n-    // which we have to stick into global constants.\n-    let g = get_item_val(ccx, id);\n-    llvm::LLVMSetInitializer(g, v);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-}\n-\n fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                     body: ast::blk, llctor_decl: ValueRef,\n                     psubsts: param_substs, ctor_id: ast::node_id,\n@@ -5008,7 +4841,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_const(_, expr) { trans_const(ccx, expr, item.id); }\n+      ast::item_const(_, expr) { consts::trans_const(ccx, expr, item.id); }\n       ast::item_foreign_mod(foreign_mod) {\n         let abi = alt attr::foreign_abi(item.attrs) {\n           either::right(abi_) { abi_ }"}, {"sha": "c9e2582f5b2793c91b18730990201a1bf518779e", "filename": "src/rustc/middle/trans/consts.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2a3084b527120db7c0645a191ef6147962dbe23d", "patch": "@@ -0,0 +1,175 @@\n+import common::*;\n+import syntax::{ast, ast_util, codemap, ast_map};\n+import base::get_insn_ctxt;\n+\n+fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n+    -> ValueRef {\n+    let _icx = cx.insn_ctxt(~\"trans_lit\");\n+    alt lit.node {\n+      ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n+      ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n+      ast::lit_int_unsuffixed(i) {\n+        let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n+        alt ty::get(lit_int_ty).struct {\n+          ty::ty_int(t) {\n+            C_integral(T_int_ty(cx, t), i as u64, True)\n+          }\n+          ty::ty_uint(t) {\n+            C_integral(T_uint_ty(cx, t), i as u64, False)\n+          }\n+          _ { cx.sess.span_bug(lit.span,\n+                               ~\"integer literal doesn't have a type\");\n+            }\n+        }\n+      }\n+      ast::lit_float(fs, t) { C_floating(*fs, T_float_ty(cx, t)) }\n+      ast::lit_bool(b) { C_bool(b) }\n+      ast::lit_nil { C_nil() }\n+      ast::lit_str(s) {\n+        cx.sess.span_unimpl(lit.span, ~\"unique string in this context\");\n+      }\n+    }\n+}\n+\n+// FIXME (#2530): this should do some structural hash-consing to avoid\n+// duplicate constants. I think. Maybe LLVM has a magical mode that does so\n+// later on?\n+fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n+    let _icx = cx.insn_ctxt(~\"const_expr\");\n+    alt e.node {\n+      ast::expr_lit(lit) { consts::const_lit(cx, e, *lit) }\n+      // If we have a vstore, just keep going; it has to be a string\n+      ast::expr_vstore(e, _) { const_expr(cx, e) }\n+      ast::expr_binary(b, e1, e2) {\n+        let te1 = const_expr(cx, e1);\n+        let te2 = const_expr(cx, e2);\n+\n+        let te2 = base::cast_shift_const_rhs(b, te1, te2);\n+\n+        /* Neither type is bottom, and we expect them to be unified already,\n+         * so the following is safe. */\n+        let ty = ty::expr_ty(cx.tcx, e1);\n+        let is_float = ty::type_is_fp(ty);\n+        let signed = ty::type_is_signed(ty);\n+        ret alt b {\n+          ast::add    {\n+            if is_float { llvm::LLVMConstFAdd(te1, te2) }\n+            else        { llvm::LLVMConstAdd(te1, te2) }\n+          }\n+          ast::subtract {\n+            if is_float { llvm::LLVMConstFSub(te1, te2) }\n+            else        { llvm::LLVMConstSub(te1, te2) }\n+          }\n+          ast::mul    {\n+            if is_float { llvm::LLVMConstFMul(te1, te2) }\n+            else        { llvm::LLVMConstMul(te1, te2) }\n+          }\n+          ast::div    {\n+            if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n+            else if signed { llvm::LLVMConstSDiv(te1, te2) }\n+            else           { llvm::LLVMConstUDiv(te1, te2) }\n+          }\n+          ast::rem    {\n+            if is_float    { llvm::LLVMConstFRem(te1, te2) }\n+            else if signed { llvm::LLVMConstSRem(te1, te2) }\n+            else           { llvm::LLVMConstURem(te1, te2) }\n+          }\n+          ast::and    |\n+          ast::or     { cx.sess.span_unimpl(e.span, ~\"binop logic\"); }\n+          ast::bitxor { llvm::LLVMConstXor(te1, te2) }\n+          ast::bitand { llvm::LLVMConstAnd(te1, te2) }\n+          ast::bitor  { llvm::LLVMConstOr(te1, te2) }\n+          ast::shl    { llvm::LLVMConstShl(te1, te2) }\n+          ast::shr    {\n+            if signed { llvm::LLVMConstAShr(te1, te2) }\n+            else      { llvm::LLVMConstLShr(te1, te2) }\n+          }\n+          ast::eq     |\n+          ast::lt     |\n+          ast::le     |\n+          ast::ne     |\n+          ast::ge     |\n+          ast::gt     { cx.sess.span_unimpl(e.span, ~\"binop comparator\"); }\n+        }\n+      }\n+      ast::expr_unary(u, e) {\n+        let te = const_expr(cx, e);\n+        let ty = ty::expr_ty(cx.tcx, e);\n+        let is_float = ty::type_is_fp(ty);\n+        ret alt u {\n+          ast::box(_)  |\n+          ast::uniq(_) |\n+          ast::deref   { cx.sess.span_bug(e.span,\n+                           ~\"bad unop type in const_expr\"); }\n+          ast::not    { llvm::LLVMConstNot(te) }\n+          ast::neg    {\n+            if is_float { llvm::LLVMConstFNeg(te) }\n+            else        { llvm::LLVMConstNeg(te) }\n+          }\n+        }\n+      }\n+      ast::expr_cast(base, tp) {\n+        let ety = ty::expr_ty(cx.tcx, e), llty = type_of::type_of(cx, ety);\n+        let basety = ty::expr_ty(cx.tcx, base);\n+        let v = const_expr(cx, base);\n+        alt check (base::cast_type_kind(basety), base::cast_type_kind(ety)) {\n+          (base::cast_integral, base::cast_integral) {\n+            let s = if ty::type_is_signed(basety) { True } else { False };\n+            llvm::LLVMConstIntCast(v, llty, s)\n+          }\n+          (base::cast_integral, base::cast_float) {\n+            if ty::type_is_signed(basety) { llvm::LLVMConstSIToFP(v, llty) }\n+            else { llvm::LLVMConstUIToFP(v, llty) }\n+          }\n+          (base::cast_float, base::cast_float) {\n+            llvm::LLVMConstFPCast(v, llty)\n+          }\n+          (base::cast_float, base::cast_integral) {\n+            if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n+            else { llvm::LLVMConstFPToUI(v, llty) }\n+          }\n+        }\n+      }\n+      ast::expr_tup(es) {\n+        C_struct(es.map(|e| const_expr(cx, e)))\n+      }\n+      ast::expr_rec(fs, none) {\n+        C_struct(fs.map(|f| const_expr(cx, f.node.expr)))\n+      }\n+      ast::expr_path(path) {\n+        alt cx.tcx.def_map.find(e.id) {\n+          some(ast::def_const(def_id)) {\n+            // Don't know how to handle external consts\n+            assert ast_util::is_local(def_id);\n+            alt cx.tcx.items.get(def_id.node) {\n+              ast_map::node_item(@{\n+                node: ast::item_const(_, subexpr), _\n+              }, _) {\n+                // FIXME (#2530): Instead of recursing here to regenerate\n+                // the values for other constants, we should just look up\n+                // the already-defined value.\n+                const_expr(cx, subexpr)\n+              }\n+              _ {\n+                cx.sess.span_bug(e.span, ~\"expected item\");\n+              }\n+            }\n+          }\n+          _ { cx.sess.span_bug(e.span, ~\"expected to find a const def\") }\n+        }\n+      }\n+      _ { cx.sess.span_bug(e.span,\n+            ~\"bad constant expression type in consts::const_expr\"); }\n+    }\n+}\n+\n+fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n+    let _icx = ccx.insn_ctxt(~\"trans_const\");\n+    let v = const_expr(ccx, e);\n+\n+    // The scalars come back as 1st class LLVM vals\n+    // which we have to stick into global constants.\n+    let g = base::get_item_val(ccx, id);\n+    llvm::LLVMSetInitializer(g, v);\n+    llvm::LLVMSetGlobalConstant(g, True);\n+}"}, {"sha": "0c0b2764f3b960cb9aa999fe305b5ad169f4640e", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=2a3084b527120db7c0645a191ef6147962dbe23d", "patch": "@@ -40,6 +40,7 @@ import back_ = back;\n mod middle {\n     mod trans {\n         mod common;\n+        mod consts;\n         mod type_of;\n         mod build;\n         mod base;"}, {"sha": "9f4b1785b7ceb08e477bb2633113c3edca122631", "filename": "src/test/run-pass/const-rec-and-tup.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3084b527120db7c0645a191ef6147962dbe23d/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs?ref=2a3084b527120db7c0645a191ef6147962dbe23d", "patch": "@@ -0,0 +1,13 @@\n+const x : (int,int) = (0xfeedf00dd,0xca11ab1e);\n+const y : { x: (int, int),\n+            y: { a: float,\n+                 b: float } } = { x: (0xf0f0f0f0_f0f0f0f0,\n+                                      0xabababab_abababab),\n+                                  y: { a: 3.14159265358979323846,\n+                                       b: 2.7182818284590452354 } };\n+\n+fn main() {\n+    let (p, _) = y.x;\n+    assert p == 0xf0f0f0f0_f0f0f0f0;\n+    io::println(fmt!{\"0x%x\", p as uint});\n+}"}]}