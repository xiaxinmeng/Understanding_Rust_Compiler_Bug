{"sha": "166dbc3273ab760004c97d8598b9f30853e6f85a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmRiYzMyNzNhYjc2MDAwNGM5N2Q4NTk4YjlmMzA4NTNlNmY4NWE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-28T00:13:17Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Keep a reference to the interners in TyCtxt.", "tree": {"sha": "b8c1330ff12d1a5fcd707d76dca8825f30338d21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8c1330ff12d1a5fcd707d76dca8825f30338d21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166dbc3273ab760004c97d8598b9f30853e6f85a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166dbc3273ab760004c97d8598b9f30853e6f85a", "html_url": "https://github.com/rust-lang/rust/commit/166dbc3273ab760004c97d8598b9f30853e6f85a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166dbc3273ab760004c97d8598b9f30853e6f85a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fbbaf2f170933de41c5dbec7b1c97496cb963a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbbaf2f170933de41c5dbec7b1c97496cb963a9", "html_url": "https://github.com/rust-lang/rust/commit/2fbbaf2f170933de41c5dbec7b1c97496cb963a9"}], "stats": {"total": 201, "additions": 110, "deletions": 91}, "files": [{"sha": "36e97c8a3f3f90b115799fbe82ed3a30997a0a40", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 110, "deletions": 91, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/166dbc3273ab760004c97d8598b9f30853e6f85a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166dbc3273ab760004c97d8598b9f30853e6f85a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=166dbc3273ab760004c97d8598b9f30853e6f85a", "patch": "@@ -80,6 +80,61 @@ impl<'tcx> CtxtArenas<'tcx> {\n     }\n }\n \n+struct CtxtInterners<'tcx> {\n+    /// The arenas that types etc are allocated from.\n+    arenas: &'tcx CtxtArenas<'tcx>,\n+\n+    /// Specifically use a speedy hash algorithm for these hash sets,\n+    /// they're accessed quite often.\n+    type_: RefCell<FnvHashSet<InternedTy<'tcx>>>,\n+    substs: RefCell<FnvHashSet<InternedSubsts<'tcx>>>,\n+    bare_fn: RefCell<FnvHashSet<&'tcx BareFnTy<'tcx>>>,\n+    region: RefCell<FnvHashSet<&'tcx Region>>,\n+    stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n+    layout: RefCell<FnvHashSet<&'tcx Layout>>,\n+}\n+\n+impl<'tcx> CtxtInterners<'tcx> {\n+    fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n+        CtxtInterners {\n+            arenas: arenas,\n+            type_: RefCell::new(FnvHashSet()),\n+            substs: RefCell::new(FnvHashSet()),\n+            bare_fn: RefCell::new(FnvHashSet()),\n+            region: RefCell::new(FnvHashSet()),\n+            stability: RefCell::new(FnvHashSet()),\n+            layout: RefCell::new(FnvHashSet())\n+        }\n+    }\n+\n+    fn intern_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+        let ty = {\n+            let mut interner = self.type_.borrow_mut();\n+            match interner.get(&st) {\n+                Some(&InternedTy { ty }) => return ty,\n+                None => ()\n+            }\n+\n+            let flags = super::flags::FlagComputation::for_sty(&st);\n+\n+            // Don't be &mut TyS.\n+            let ty: Ty = self.arenas.type_.alloc(TyS {\n+                sty: st,\n+                flags: Cell::new(flags.flags),\n+                region_depth: flags.depth,\n+            });\n+\n+            interner.insert(InternedTy { ty: ty });\n+            ty\n+        };\n+\n+        debug!(\"Interned type: {:?} Pointer: {:?}\",\n+            ty, ty as *const TyS);\n+        ty\n+    }\n+\n+}\n+\n pub struct CommonTypes<'tcx> {\n     pub bool: Ty<'tcx>,\n     pub char: Ty<'tcx>,\n@@ -190,11 +245,8 @@ impl<'a, 'tcx> Tables<'tcx> {\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n-    fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n-           interner: &RefCell<FnvHashSet<InternedTy<'tcx>>>)\n-           -> CommonTypes<'tcx>\n-    {\n-        let mk = |sty| TyCtxt::intern_ty(arena, interner, sty);\n+    fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n+        let mk = |sty| interners.intern_ty(sty);\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n@@ -221,7 +273,7 @@ impl<'tcx> CommonTypes<'tcx> {\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'a, 'tcx: 'a> {\n     gcx: &'a GlobalCtxt<'tcx>,\n-\n+    interners: &'a CtxtInterners<'tcx>\n }\n \n impl<'a, 'tcx> Deref for TyCtxt<'a, 'tcx> {\n@@ -232,17 +284,7 @@ impl<'a, 'tcx> Deref for TyCtxt<'a, 'tcx> {\n }\n \n pub struct GlobalCtxt<'tcx> {\n-    /// The arenas that types etc are allocated from.\n-    arenas: &'tcx CtxtArenas<'tcx>,\n-\n-    /// Specifically use a speedy hash algorithm for this hash map, it's used\n-    /// quite often.\n-    interner: RefCell<FnvHashSet<InternedTy<'tcx>>>,\n-    substs_interner: RefCell<FnvHashSet<InternedSubsts<'tcx>>>,\n-    bare_fn_interner: RefCell<FnvHashSet<&'tcx BareFnTy<'tcx>>>,\n-    region_interner: RefCell<FnvHashSet<&'tcx Region>>,\n-    stability_interner: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n-    layout_interner: RefCell<FnvHashSet<&'tcx Layout>>,\n+    global_interners: CtxtInterners<'tcx>,\n \n     pub dep_graph: DepGraph,\n \n@@ -442,6 +484,16 @@ pub struct GlobalCtxt<'tcx> {\n     pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n }\n \n+impl<'tcx> GlobalCtxt<'tcx> {\n+    /// Get the global TyCtxt.\n+    pub fn global_tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+        TyCtxt {\n+            gcx: self,\n+            interners: &self.global_interners\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n@@ -481,7 +533,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     pub fn intern_trait_def(self, def: ty::TraitDef<'tcx>)\n                             -> &'tcx ty::TraitDef<'tcx> {\n         let did = def.trait_ref.def_id;\n-        let interned = self.arenas.trait_defs.alloc(def);\n+        let interned = self.global_interners.arenas.trait_defs.alloc(def);\n         if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n             bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n         }\n@@ -490,7 +542,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n \n     pub fn alloc_trait_def(self, def: ty::TraitDef<'tcx>)\n                            -> &'tcx ty::TraitDef<'tcx> {\n-        self.arenas.trait_defs.alloc(def)\n+        self.global_interners.arenas.trait_defs.alloc(def)\n     }\n \n     pub fn intern_adt_def(self,\n@@ -499,7 +551,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n                           variants: Vec<ty::VariantDefData<'tcx, 'tcx>>)\n                           -> ty::AdtDefMaster<'tcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.arenas.adt_defs.alloc(def);\n+        let interned = self.global_interners.arenas.adt_defs.alloc(def);\n         // this will need a transmute when reverse-variance is removed\n         if let Some(prev) = self.adt_defs.borrow_mut().insert(did, interned) {\n             bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n@@ -508,12 +560,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n-        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n+        if let Some(st) = self.interners.stability.borrow().get(&stab) {\n             return st;\n         }\n \n-        let interned = self.arenas.stability.alloc(stab);\n-        if let Some(prev) = self.stability_interner\n+        let interned = self.interners.arenas.stability.alloc(stab);\n+        if let Some(prev) = self.interners.stability\n                                 .borrow_mut()\n                                 .replace(interned) {\n             bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n@@ -522,12 +574,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     }\n \n     pub fn intern_layout(self, layout: Layout) -> &'tcx Layout {\n-        if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n+        if let Some(layout) = self.interners.layout.borrow().get(&layout) {\n             return layout;\n         }\n \n-        let interned = self.arenas.layout.alloc(layout);\n-        if let Some(prev) = self.layout_interner\n+        let interned = self.interners.arenas.layout.alloc(layout);\n+        if let Some(prev) = self.interners.layout\n                                 .borrow_mut()\n                                 .replace(interned) {\n             bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n@@ -568,18 +620,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx>) -> R\n     {\n         let data_layout = TargetDataLayout::parse(s);\n-        let interner = RefCell::new(FnvHashSet());\n-        let common_types = CommonTypes::new(&arenas.type_, &interner);\n+        let interners = CtxtInterners::new(arenas);\n+        let common_types = CommonTypes::new(&interners);\n         let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         tls::enter(GlobalCtxt {\n-            arenas: arenas,\n-            interner: interner,\n-            substs_interner: RefCell::new(FnvHashSet()),\n-            bare_fn_interner: RefCell::new(FnvHashSet()),\n-            region_interner: RefCell::new(FnvHashSet()),\n-            stability_interner: RefCell::new(FnvHashSet()),\n-            layout_interner: RefCell::new(FnvHashSet()),\n+            global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n@@ -653,7 +699,7 @@ pub trait Lift<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<Ty<'tcx>> {\n-        if let Some(&InternedTy { ty }) = tcx.interner.borrow().get(&self.sty) {\n+        if let Some(&InternedTy { ty }) = tcx.interners.type_.borrow().get(&self.sty) {\n             if *self as *const _ == ty as *const _ {\n                 return Some(ty);\n             }\n@@ -665,7 +711,7 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n     fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if let Some(&InternedSubsts { substs }) = tcx.substs_interner.borrow().get(*self) {\n+        if let Some(&InternedSubsts { substs }) = tcx.interners.substs.borrow().get(*self) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n             }\n@@ -697,18 +743,17 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter<'tcx, F: for<'a> FnOnce(TyCtxt<'a, 'tcx>) -> R, R>(gcx: GlobalCtxt<'tcx>,\n-                                                                    f: F) -> R {\n+    pub fn enter<'tcx, F, R>(gcx: GlobalCtxt<'tcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'tcx>) -> R\n+    {\n         codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n             let tls_ptr = &gcx as *const _ as *const ThreadLocalGlobalCtxt;\n             let result = TLS_TCX.with(|tls| {\n                 let prev = tls.get();\n                 tls.set(Some(tls_ptr));\n-                let ret = f(TyCtxt {\n-                    gcx: &gcx\n-                });\n+                let ret = f(gcx.global_tcx());\n                 tls.set(prev);\n                 ret\n             });\n@@ -718,16 +763,18 @@ pub mod tls {\n     }\n \n     pub fn with<F: FnOnce(TyCtxt) -> R, R>(f: F) -> R {\n-        TLS_TCX.with(|tcx| {\n-            let tcx = tcx.get().unwrap();\n+        TLS_TCX.with(|gcx| {\n+            let gcx = gcx.get().unwrap();\n+            let gcx = unsafe { &*(gcx as *const GlobalCtxt) };\n             f(TyCtxt {\n-                gcx: unsafe { &*(tcx as *const GlobalCtxt) }\n+                gcx: gcx,\n+                interners: &gcx.global_interners\n             })\n         })\n     }\n \n     pub fn with_opt<F: FnOnce(Option<TyCtxt>) -> R, R>(f: F) -> R {\n-        if TLS_TCX.with(|tcx| tcx.get().is_some()) {\n+        if TLS_TCX.with(|gcx| gcx.get().is_some()) {\n             with(|v| f(Some(v)))\n         } else {\n             f(None)\n@@ -760,7 +807,7 @@ macro_rules! sty_debug_print {\n                 $(let mut $variant = total;)*\n \n \n-                for &InternedTy { ty: t } in tcx.interner.borrow().iter() {\n+                for &InternedTy { ty: t } in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n                             ty::TyFloat(..) | ty::TyStr => continue,\n@@ -806,11 +853,11 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n             TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n             TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n \n-        println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n-        println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n-        println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n-        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n-        println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n+        println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n+        println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n+        println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n+        println!(\"Stability interner: #{}\", self.interners.stability.borrow().len());\n+        println!(\"Layout interner: #{}\", self.interners.layout.borrow().len());\n     }\n }\n \n@@ -862,12 +909,12 @@ fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     // Type constructors\n     pub fn mk_substs(self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n-        if let Some(interned) = self.substs_interner.borrow().get(&substs) {\n+        if let Some(interned) = self.interners.substs.borrow().get(&substs) {\n             return interned.substs;\n         }\n \n-        let substs = self.arenas.substs.alloc(substs);\n-        self.substs_interner.borrow_mut().insert(InternedSubsts {\n+        let substs = self.interners.arenas.substs.alloc(substs);\n+        self.interners.substs.borrow_mut().insert(InternedSubsts {\n             substs: substs\n         });\n         substs\n@@ -884,57 +931,29 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     }\n \n     pub fn mk_bare_fn(self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n-        if let Some(bare_fn) = self.bare_fn_interner.borrow().get(&bare_fn) {\n+        if let Some(bare_fn) = self.interners.bare_fn.borrow().get(&bare_fn) {\n             return *bare_fn;\n         }\n \n-        let bare_fn = self.arenas.bare_fn.alloc(bare_fn);\n-        self.bare_fn_interner.borrow_mut().insert(bare_fn);\n+        let bare_fn = self.interners.arenas.bare_fn.alloc(bare_fn);\n+        self.interners.bare_fn.borrow_mut().insert(bare_fn);\n         bare_fn\n     }\n \n     pub fn mk_region(self, region: Region) -> &'tcx Region {\n-        if let Some(region) = self.region_interner.borrow().get(&region) {\n+        if let Some(region) = self.interners.region.borrow().get(&region) {\n             return *region;\n         }\n \n-        let region = self.arenas.region.alloc(region);\n-        self.region_interner.borrow_mut().insert(region);\n+        let region = self.interners.arenas.region.alloc(region);\n+        self.interners.region.borrow_mut().insert(region);\n         region\n     }\n \n-    fn intern_ty(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n-                 interner: &RefCell<FnvHashSet<InternedTy<'tcx>>>,\n-                 st: TypeVariants<'tcx>)\n-                 -> Ty<'tcx> {\n-        let ty: Ty /* don't be &mut TyS */ = {\n-            let mut interner = interner.borrow_mut();\n-            match interner.get(&st) {\n-                Some(&InternedTy { ty }) => return ty,\n-                None => ()\n-            }\n-\n-            let flags = super::flags::FlagComputation::for_sty(&st);\n-\n-            let ty = match () {\n-                () => type_arena.alloc(TyS { sty: st,\n-                                             flags: Cell::new(flags.flags),\n-                                             region_depth: flags.depth, }),\n-            };\n-\n-            interner.insert(InternedTy { ty: ty });\n-            ty\n-        };\n-\n-        debug!(\"Interned type: {:?} Pointer: {:?}\",\n-            ty, ty as *const TyS);\n-        ty\n-    }\n-\n-    // Interns a type/name combination, stores the resulting box in cx.interner,\n+    // Interns a type/name combination, stores the resulting box in cx.interners,\n     // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n     pub fn mk_ty(self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n-        TyCtxt::intern_ty(&self.arenas.type_, &self.interner, st)\n+        self.interners.intern_ty(st)\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}]}