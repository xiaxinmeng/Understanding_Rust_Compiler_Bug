{"sha": "69766e4f167f4097e1f8975bd866c1f782fa26d5", "node_id": "C_kwDOAAsO6NoAKDY5NzY2ZTRmMTY3ZjQwOTdlMWY4OTc1YmQ4NjZjMWY3ODJmYTI2ZDU", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-09-26T04:52:19Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-07T19:19:27Z"}, "message": "migrate loops.rs to translateable diagnostics", "tree": {"sha": "9f6b52909370385d0c2601b4d1c4b410534678c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f6b52909370385d0c2601b4d1c4b410534678c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69766e4f167f4097e1f8975bd866c1f782fa26d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69766e4f167f4097e1f8975bd866c1f782fa26d5", "html_url": "https://github.com/rust-lang/rust/commit/69766e4f167f4097e1f8975bd866c1f782fa26d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69766e4f167f4097e1f8975bd866c1f782fa26d5/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "572f3414b782311a8ec4143c50bbe3b006594898", "url": "https://api.github.com/repos/rust-lang/rust/commits/572f3414b782311a8ec4143c50bbe3b006594898", "html_url": "https://github.com/rust-lang/rust/commit/572f3414b782311a8ec4143c50bbe3b006594898"}], "stats": {"total": 316, "additions": 198, "deletions": 118}, "files": [{"sha": "3dc4204f986a436fb412cd7ad11f6202ca1817be", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/69766e4f167f4097e1f8975bd866c1f782fa26d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/69766e4f167f4097e1f8975bd866c1f782fa26d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=69766e4f167f4097e1f8975bd866c1f782fa26d5", "patch": "@@ -433,3 +433,37 @@ passes_expr_not_allowed_in_context =\n passes_const_impl_const_trait =\n     const `impl`s must be for traits marked with `#[const_trait]`\n     .note = this trait must be annotated with `#[const_trait]`\n+\n+passes_break_non_loop =\n+    `break` with value from a `{$kind}` loop\n+    .label = can only break with a value inside `loop` or breakable block\n+    .label2 = you can't `break` with a value in a `{$kind}` loop\n+    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n+    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+\n+passes_continue_labeled_block =\n+    `continue` pointing to a labeled block\n+    .label = labeled blocks cannot be `continue`'d\n+    .block_label = labeled block the `continue` points to\n+\n+passes_break_inside_closure =\n+    `{$name}` inside of a closure\n+    .label = cannot `{$name}` inside of a closure\n+    .closure_label = enclosing closure\n+\n+passes_break_inside_async_block =\n+    `{$name}` inside of an `async` block\n+    .label = cannot `{$name}` inside of an `async` block\n+    .async_block_label = enclosing `async` block\n+\n+passes_outside_loop =\n+    `{$name}` outside of a loop\n+    .label = cannot `{$name}` outside of a loop\n+\n+passes_unlabeled_in_labeled_block =\n+    unlabeled `{$cf_type}` inside of a labeled block\n+    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n+\n+passes_unlabeled_cf_in_while_condition =\n+    `break` or `continue` with no label in the condition of a `while` loop\n+    .label = unlabeled `{$cf_type}` in the condition of a `while` loop"}, {"sha": "fcbcc298bd5b7fa05efe8ba3213d5928ded8f66c", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/69766e4f167f4097e1f8975bd866c1f782fa26d5/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69766e4f167f4097e1f8975bd866c1f782fa26d5/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=69766e4f167f4097e1f8975bd866c1f782fa26d5", "patch": "@@ -1,7 +1,8 @@\n use std::{io::Error, path::Path};\n \n-use rustc_errors::{Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n-use rustc_hir::Target;\n+use rustc_ast::Label;\n+use rustc_errors::{error_code, Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n+use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n@@ -870,3 +871,119 @@ pub struct ConstImplConstTrait {\n     #[note]\n     pub def_span: Span,\n }\n+\n+pub struct BreakNonLoop<'a> {\n+    pub span: Span,\n+    pub head: Option<Span>,\n+    pub kind: &'a str,\n+    pub suggestion: String,\n+    pub loop_label: Option<Label>,\n+    pub break_label: Option<Label>,\n+    pub break_expr_kind: &'a ExprKind<'a>,\n+    pub break_expr_span: Span,\n+}\n+\n+impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::passes::break_non_loop,\n+            error_code!(E0571),\n+        );\n+        diag.set_arg(\"kind\", self.kind);\n+        diag.span_label(self.span, rustc_errors::fluent::passes::label);\n+        if let Some(head) = self.head {\n+            diag.span_label(head, rustc_errors::fluent::passes::label2);\n+        }\n+        diag.span_suggestion(\n+            self.span,\n+            rustc_errors::fluent::passes::suggestion,\n+            self.suggestion,\n+            Applicability::MaybeIncorrect,\n+        );\n+        if let (Some(label), None) = (self.loop_label, self.break_label) {\n+            match self.break_expr_kind {\n+                ExprKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { segments: [segment], res: hir::def::Res::Err, .. },\n+                )) if label.ident.to_string() == format!(\"'{}\", segment.ident) => {\n+                    // This error is redundant, we will have already emitted a\n+                    // suggestion to use the label when `segment` wasn't found\n+                    // (hence the `Res::Err` check).\n+                    diag.delay_as_bug();\n+                }\n+                _ => {\n+                    diag.span_suggestion(\n+                        self.break_expr_span,\n+                        rustc_errors::fluent::passes::break_expr_suggestion,\n+                        label.ident,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::continue_labeled_block, code = \"E0696\")]\n+pub struct ContinueLabeledBlock {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::break_inside_closure, code = \"E0267\")]\n+pub struct BreakInsideClosure<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::closure_label)]\n+    pub closure_span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::break_inside_async_block, code = \"E0267\")]\n+pub struct BreakInsideAsyncBlock<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::async_block_label)]\n+    pub closure_span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::outside_loop, code = \"E0268\")]\n+pub struct OutsideLoop<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unlabeled_in_labeled_block, code = \"E0695\")]\n+pub struct UnlabeledInLabeledBlock<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub cf_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unlabeled_cf_in_while_condition, code = \"E0590\")]\n+pub struct UnlabeledCfInWhileCondition<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub cf_type: &'a str,\n+}"}, {"sha": "077194ec687bff4da85cddbba83e80d2357543e6", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 45, "deletions": 116, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/69766e4f167f4097e1f8975bd866c1f782fa26d5/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69766e4f167f4097e1f8975bd866c1f782fa26d5/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=69766e4f167f4097e1f8975bd866c1f782fa26d5", "patch": "@@ -1,6 +1,5 @@\n use Context::*;\n \n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -13,6 +12,11 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n+use crate::errors::{\n+    BreakInsideAsyncBlock, BreakInsideClosure, BreakNonLoop, ContinueLabeledBlock, OutsideLoop,\n+    UnlabeledCfInWhileCondition, UnlabeledInLabeledBlock,\n+};\n+\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n@@ -90,7 +94,10 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Ok(loop_id) => Some(loop_id),\n                     Err(hir::LoopIdError::OutsideLoopScope) => None,\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                        self.sess.emit_err(UnlabeledCfInWhileCondition {\n+                            span: e.span,\n+                            cf_type: \"break\",\n+                        });\n                         None\n                     }\n                     Err(hir::LoopIdError::UnresolvedLabel) => None,\n@@ -116,69 +123,22 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     match loop_kind {\n                         None | Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n-                            let mut err = struct_span_err!(\n-                                self.sess,\n-                                e.span,\n-                                E0571,\n-                                \"`break` with value from a `{}` loop\",\n-                                kind.name()\n-                            );\n-                            err.span_label(\n-                                e.span,\n-                                \"can only break with a value inside `loop` or breakable block\",\n+                            let suggestion = format!(\n+                                \"break{}\",\n+                                break_label\n+                                    .label\n+                                    .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n                             );\n-                            if let Some(head) = head {\n-                                err.span_label(\n-                                    head,\n-                                    &format!(\n-                                        \"you can't `break` with a value in a `{}` loop\",\n-                                        kind.name()\n-                                    ),\n-                                );\n-                            }\n-                            err.span_suggestion(\n-                                e.span,\n-                                &format!(\n-                                    \"use `break` on its own without a value inside this `{}` loop\",\n-                                    kind.name(),\n-                                ),\n-                                format!(\n-                                    \"break{}\",\n-                                    break_label\n-                                        .label\n-                                        .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n-                                ),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            if let (Some(label), None) = (loop_label, break_label.label) {\n-                                match break_expr.kind {\n-                                    hir::ExprKind::Path(hir::QPath::Resolved(\n-                                        None,\n-                                        hir::Path {\n-                                            segments: [segment],\n-                                            res: hir::def::Res::Err,\n-                                            ..\n-                                        },\n-                                    )) if label.ident.to_string()\n-                                        == format!(\"'{}\", segment.ident) =>\n-                                    {\n-                                        // This error is redundant, we will have already emitted a\n-                                        // suggestion to use the label when `segment` wasn't found\n-                                        // (hence the `Res::Err` check).\n-                                        err.delay_as_bug();\n-                                    }\n-                                    _ => {\n-                                        err.span_suggestion(\n-                                            break_expr.span,\n-                                            \"alternatively, you might have meant to use the \\\n-                                             available loop label\",\n-                                            label.ident,\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                    }\n-                                }\n-                            }\n-                            err.emit();\n+                            self.sess.emit_err(BreakNonLoop {\n+                                span: e.span,\n+                                head,\n+                                kind: kind.name(),\n+                                suggestion,\n+                                loop_label,\n+                                break_label: break_label.label,\n+                                break_expr_kind: &break_expr.kind,\n+                                break_expr_span: break_expr.span,\n+                            });\n                         }\n                     }\n                 }\n@@ -191,19 +151,17 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 match destination.target_id {\n                     Ok(loop_id) => {\n                         if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n-                            struct_span_err!(\n-                                self.sess,\n-                                e.span,\n-                                E0696,\n-                                \"`continue` pointing to a labeled block\"\n-                            )\n-                            .span_label(e.span, \"labeled blocks cannot be `continue`'d\")\n-                            .span_label(block.span, \"labeled block the `continue` points to\")\n-                            .emit();\n+                            self.sess.emit_err(ContinueLabeledBlock {\n+                                span: e.span,\n+                                block_span: block.span,\n+                            });\n                         }\n                     }\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                        self.sess.emit_err(UnlabeledCfInWhileCondition {\n+                            span: e.span,\n+                            cf_type: \"continue\",\n+                        });\n                     }\n                     Err(_) => {}\n                 }\n@@ -226,21 +184,16 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n-        let err_inside_of = |article, ty, closure_span| {\n-            struct_span_err!(self.sess, span, E0267, \"`{}` inside of {} {}\", name, article, ty)\n-                .span_label(span, format!(\"cannot `{}` inside of {} {}\", name, article, ty))\n-                .span_label(closure_span, &format!(\"enclosing {}\", ty))\n-                .emit();\n-        };\n-\n         match self.cx {\n             LabeledBlock | Loop(_) => {}\n-            Closure(closure_span) => err_inside_of(\"a\", \"closure\", closure_span),\n-            AsyncClosure(closure_span) => err_inside_of(\"an\", \"`async` block\", closure_span),\n+            Closure(closure_span) => {\n+                self.sess.emit_err(BreakInsideClosure { span, closure_span, name });\n+            }\n+            AsyncClosure(closure_span) => {\n+                self.sess.emit_err(BreakInsideAsyncBlock { span, closure_span, name });\n+            }\n             Normal | AnonConst => {\n-                struct_span_err!(self.sess, span, E0268, \"`{}` outside of a loop\", name)\n-                    .span_label(span, format!(\"cannot `{}` outside of a loop\", name))\n-                    .emit();\n+                self.sess.emit_err(OutsideLoop { span, name });\n             }\n         }\n     }\n@@ -251,37 +204,13 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         label: &Destination,\n         cf_type: &str,\n     ) -> bool {\n-        if !span.is_desugaring(DesugaringKind::QuestionMark) && self.cx == LabeledBlock {\n-            if label.label.is_none() {\n-                struct_span_err!(\n-                    self.sess,\n-                    span,\n-                    E0695,\n-                    \"unlabeled `{}` inside of a labeled block\",\n-                    cf_type\n-                )\n-                .span_label(\n-                    span,\n-                    format!(\n-                        \"`{}` statements that would diverge to or through \\\n-                                a labeled block need to bear a label\",\n-                        cf_type\n-                    ),\n-                )\n-                .emit();\n-                return true;\n-            }\n+        if !span.is_desugaring(DesugaringKind::QuestionMark)\n+            && self.cx == LabeledBlock\n+            && label.label.is_none()\n+        {\n+            self.sess.emit_err(UnlabeledInLabeledBlock { span, cf_type });\n+            return true;\n         }\n         false\n     }\n-    fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n-        struct_span_err!(\n-            self.sess,\n-            span,\n-            E0590,\n-            \"`break` or `continue` with no label in the condition of a `while` loop\"\n-        )\n-        .span_label(span, format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n-        .emit();\n-    }\n }"}]}