{"sha": "75201cdc044205ba27178aaa311d9b7b743c57d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MjAxY2RjMDQ0MjA1YmEyNzE3OGFhYTMxMWQ5YjdiNzQzYzU3ZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-29T13:07:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-29T13:07:17Z"}, "message": "vtable.rs: adjust formatting, correct build error", "tree": {"sha": "38618ce7bb64e8ed879e3cea85006a048d953767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38618ce7bb64e8ed879e3cea85006a048d953767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75201cdc044205ba27178aaa311d9b7b743c57d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75201cdc044205ba27178aaa311d9b7b743c57d0", "html_url": "https://github.com/rust-lang/rust/commit/75201cdc044205ba27178aaa311d9b7b743c57d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75201cdc044205ba27178aaa311d9b7b743c57d0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ac7489b5032b4a922a0df1dd611471260b31ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ac7489b5032b4a922a0df1dd611471260b31ef", "html_url": "https://github.com/rust-lang/rust/commit/e9ac7489b5032b4a922a0df1dd611471260b31ef"}], "stats": {"total": 439, "additions": 224, "deletions": 215}, "files": [{"sha": "f22730cb575fe8876a860934269bcd86f638615a", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 224, "deletions": 215, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/75201cdc044205ba27178aaa311d9b7b743c57d0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75201cdc044205ba27178aaa311d9b7b743c57d0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=75201cdc044205ba27178aaa311d9b7b743c57d0", "patch": "@@ -91,249 +91,258 @@ fn lookup_vtable(fcx: @fn_ctxt,\n \n     let tcx = fcx.ccx.tcx;\n     let (trait_id, trait_substs) = match ty::get(trait_ty).struct {\n-      ty::ty_trait(did, substs, _) => (did, substs),\n-      _ => tcx.sess.impossible_case(expr.span, \"lookup_vtable: \\\n-             don't know how to handle a non-trait ty\")\n+        ty::ty_trait(did, substs, _) => (did, substs),\n+        _ => tcx.sess.impossible_case(expr.span,\n+                                      \"lookup_vtable: \\\n+                                       don't know how to handle a non-trait\")\n     };\n     let ty = match fixup_ty(fcx, expr, ty, is_early) {\n-      Some(ty) => ty,\n-      None => {\n-        // fixup_ty can only fail if this is early resolution\n-        assert is_early;\n-        // The type has unconstrained type variables in it, so we can't\n-        // do early resolution on it. Return some completely bogus vtable\n-        // information: we aren't storing it anyways.\n-        return vtable_param(0, 0);\n-      }\n+        Some(ty) => ty,\n+        None => {\n+            // fixup_ty can only fail if this is early resolution\n+            assert is_early;\n+            // The type has unconstrained type variables in it, so we can't\n+            // do early resolution on it. Return some completely bogus vtable\n+            // information: we aren't storing it anyways.\n+            return vtable_param(0, 0);\n+        }\n     };\n \n     match ty::get(ty).struct {\n-      ty::ty_param({idx: n, def_id: did}) => {\n-        let mut n_bound = 0;\n-        for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n-            match bound {\n-              ty::bound_send | ty::bound_copy | ty::bound_const |\n-              ty::bound_owned => {\n-                /* ignore */\n-              }\n-              ty::bound_trait(ity) => {\n-                match ty::get(ity).struct {\n-                  ty::ty_trait(idid, _, _) => {\n-                    if trait_id == idid {\n-                        debug!(\"(checking vtable) @0 relating ty to trait ty\n-                                with did %?\", idid);\n-                        relate_trait_tys(fcx, expr, trait_ty, ity);\n-                        return vtable_param(n, n_bound);\n+        ty::ty_param({idx: n, def_id: did}) => {\n+            let mut n_bound = 0;\n+            for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n+                match bound {\n+                    ty::bound_send | ty::bound_copy | ty::bound_const |\n+                    ty::bound_owned => {\n+                        /* ignore */\n+                    }\n+                    ty::bound_trait(ity) => {\n+                        match ty::get(ity).struct {\n+                            ty::ty_trait(idid, _, _) => {\n+                                if trait_id == idid {\n+                                    debug!(\"(checking vtable) @0 relating \\\n+                                            ty to trait ty with did %?\",\n+                                           idid);\n+                                    relate_trait_tys(fcx, expr,\n+                                                     trait_ty, ity);\n+                                    return vtable_param(n, n_bound);\n+                                }\n+                            }\n+                            _ => tcx.sess.impossible_case(\n+                                expr.span,\n+                                \"lookup_vtable: in loop, \\\n+                                 don't know how to handle a non-trait ity\")\n+                        }\n+                        n_bound += 1u;\n                     }\n-                  }\n-                  _ => tcx.sess.impossible_case(expr.span,\n-                         \"lookup_vtable: in loop, \\\n-                         don't know how to handle a non-trait ity\")\n                 }\n-                n_bound += 1u;\n-              }\n             }\n         }\n-      }\n \n-      ty::ty_trait(did, substs, _) if trait_id == did => {\n-        debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n-               did);\n-\n-        relate_trait_tys(fcx, expr, trait_ty, ty);\n-        if !allow_unsafe && !is_early {\n-            for vec::each(*ty::trait_methods(tcx, did)) |m| {\n-                if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"a boxed trait with self types may not be \\\n-                          passed as a bounded type\");\n-                } else if (*m.tps).len() > 0u {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"a boxed trait with generic methods may not \\\n-                          be passed as a bounded type\");\n+        ty::ty_trait(did, substs, _) if trait_id == did => {\n+            debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n+                   did);\n+\n+            relate_trait_tys(fcx, expr, trait_ty, ty);\n+            if !allow_unsafe && !is_early {\n+                for vec::each(*ty::trait_methods(tcx, did)) |m| {\n+                    if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n+                        tcx.sess.span_err(\n+                            expr.span,\n+                            ~\"a boxed trait with self types may not be \\\n+                              passed as a bounded type\");\n+                    } else if (*m.tps).len() > 0u {\n+                        tcx.sess.span_err(\n+                            expr.span,\n+                            ~\"a boxed trait with generic methods may not \\\n+                              be passed as a bounded type\");\n \n+                    }\n                 }\n             }\n+            return vtable_trait(did, substs.tps);\n         }\n-        return vtable_trait(did, substs.tps);\n-      }\n-\n-      _ => {\n-        let mut found = ~[];\n-\n-        let mut impls_seen = new_def_hash();\n-\n-        match fcx.ccx.coherence_info.extension_methods.find(trait_id) {\n-            None => {\n-                // Nothing found. Continue.\n-            }\n-            Some(implementations) => {\n-                /*\n-                implementations is the list of all impls in scope for\n-                trait_ty. (Usually, there's just one.)\n-                */\n-                for uint::range(0, implementations.len()) |i| {\n-                    let im = implementations[i];\n-\n-                    // im is one specific impl of trait_ty.\n-\n-                    // First, ensure that we haven't processed this impl yet.\n-                    if impls_seen.contains_key(im.did) {\n-                        again;\n-                    }\n-                    impls_seen.insert(im.did, ());\n-\n-\n-                /*\n-                ty::impl_traits gives us the list of all traits that im\n-                implements. Again, usually there's just one.\n \n-                For example, if im represented the struct in:\n+        _ => {\n+            let mut found = ~[];\n \n-                struct foo : baz<int>, bar, quux { ... }\n+            let mut impls_seen = new_def_hash();\n \n-                then ty::impl_traits would return\n-                    ~[baz<int>, bar, quux]\n+            match fcx.ccx.coherence_info.extension_methods.find(trait_id) {\n+                None => {\n+                    // Nothing found. Continue.\n+                }\n+                Some(implementations) => {\n+                    // implementations is the list of all impls in scope for\n+                    // trait_ty. (Usually, there's just one.)\n+                    for uint::range(0, implementations.len()) |i| {\n+                        let im = implementations[i];\n \n-                For each of the traits foo implements, if it's the\n-                same trait as trait_ty, we need to unify it with\n-                trait_ty in order to get all the ty vars sorted out.\n-                */\n-                    for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n-                        match ty::get(of_ty).struct {\n-                        // This is a trait that is different from the one\n-                        // we're looking for, so we skip to the next one.\n-                          ty::ty_trait(id, _, _) if id != trait_id => again,\n-                          _ => { /* ok */ }\n-                        }\n+                        // im is one specific impl of trait_ty.\n \n-                /* At this point, we know that of_ty is the same trait\n-                as trait_ty, but possibly applied to different substs.\n-\n-                Next, we check whether the \"for\" ty in the impl is\n-                compatible with the type that we're casting to a trait. That\n-                is, if im is:\n-\n-                impl<T> self_ty<T>: some_trait<T> { ... }\n-\n-                we check whether self_ty<T> is the type of the thing that\n-                we're trying to cast to some_trait.\n-                */\n-                        let {substs: substs, ty: for_ty} =\n-                            impl_self_ty(fcx, expr, im.did, false);\n-                        let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n-                        match fcx.mk_subty(false, expr.span, ty, for_ty) {\n-                // for_ty is not compatible with ty, so this impl is\n-                // irrelevant and we skip to the next impl\n-                          result::Err(_) => again,\n-                // The impl is an impl for ty of the desired trait.\n-                          result::Ok(()) => ()\n+                        // First, ensure we haven't processed this impl yet.\n+                        if impls_seen.contains_key(im.did) {\n+                            again;\n                         }\n+                        impls_seen.insert(im.did, ());\n+\n+                        // ty::impl_traits gives us the list of all\n+                        // traits that im implements. Again, usually\n+                        // there's just one.\n+                        //\n+                        // For example, if im represented the struct\n+                        // in:\n+                        //\n+                        //   struct foo : baz<int>, bar, quux { ... }\n+                        //\n+                        // then ty::impl_traits would return\n+                        //\n+                        //   ~[baz<int>, bar, quux]\n+                        //\n+                        // For each of the traits foo implements, if\n+                        // it's the same trait as trait_ty, we need to\n+                        // unify it with trait_ty in order to get all\n+                        // the ty vars sorted out.\n+                        for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n+                            match ty::get(of_ty).struct {\n+                                ty::ty_trait(id, _, _) => {\n+                                    // Not the trait we're looking for\n+                                    if id != trait_id { again; }\n+                                }\n+                                _ => { /* ok */ }\n+                            }\n \n-                /*\n-                Now, in the previous example, for_ty is bound to the\n-                type self_ty, and substs is bound to [T].\n-                */\n-                        debug!(\"The self ty is %s and its substs are %s\",\n-                               fcx.infcx.ty_to_str(for_ty),\n-                               tys_to_str(fcx.ccx.tcx, substs.tps));\n-\n-                /*\n-                Next, we unify trait_ty -- the type that we want to cast\n-                to -- with of_ty -- the trait that im implements. At this\n-                point, we require that they be unifiable with each other --\n-                that's what relate_trait_tys does.\n-\n-                For example, in the above example, of_ty would be\n-                some_trait<T>, so we would be unifying trait_ty<U> (for\n-                some value of U) with some_trait<T>. This would fail if\n-                T and U weren't compatible.\n-                */\n-\n-                        debug!(\"(checking vtable) @2 relating trait ty %s to \\\n-                                of_ty %s\",\n-                               fcx.infcx().ty_to_str(trait_ty),\n-                               fcx.infcx().ty_to_str(of_ty));\n-                        let of_ty = ty::subst(tcx, &substs, of_ty);\n-                        relate_trait_tys(fcx, expr, trait_ty, of_ty);\n-\n-                /*\n-                Recall that trait_ty -- the trait type we're casting to --\n-                is the trait with id trait_id applied to the substs\n-                trait_substs. Now we extract out the types themselves\n-                from trait_substs.\n-                */\n-\n-                        let trait_tps = trait_substs.tps;\n-\n-                        debug!(\"Casting to a trait ty whose substs \\\n-                          (trait_tps) are %s\",\n-                               tys_to_str(fcx.ccx.tcx, trait_tps));\n-\n-                /*\n-                Recall that substs is the impl self type's list of\n-                substitutions. That is, if this is an impl of some trait\n-                for foo<T, U>, then substs is [T, U]. substs might contain\n-                type variables, so we call fixup_substs to resolve them.\n-                */\n-\n-                        let substs_f = match fixup_substs(fcx, expr, trait_id,\n-                                                          substs, is_early) {\n-                            Some(substs) => substs,\n-                            None => {\n-                                assert is_early;\n-                                // Bail out with a bogus answer\n-                                return vtable_param(0, 0);\n+                            // At this point, we know that of_ty is\n+                            // the same trait as trait_ty, but\n+                            // possibly applied to different substs.\n+                            //\n+                            // Next, we check whether the \"for\" ty in\n+                            // the impl is compatible with the type\n+                            // that we're casting to a trait. That is,\n+                            // if im is:\n+                            //\n+                            // impl<T> self_ty<T>: some_trait<T> { ... }\n+                            //\n+                            // we check whether self_ty<T> is the type\n+                            // of the thing that we're trying to cast\n+                            // to some_trait.  If not, then we try the next\n+                            // impl.\n+                            let {substs: substs, ty: for_ty} =\n+                                impl_self_ty(fcx, expr, im.did, false);\n+                            let im_bs = ty::lookup_item_type(tcx,\n+                                                             im.did).bounds;\n+                            match fcx.mk_subty(false, expr.span, ty, for_ty) {\n+                                result::Err(_) => again,\n+                                result::Ok(()) => ()\n                             }\n-                        };\n-\n-                        debug!(\"The fixed-up substs for the self ty are %s - \\\n-                                they will be unified with the bounds for \\\n-                                the target ty, %s\",\n-                               tys_to_str(fcx.ccx.tcx, substs_f.tps),\n-                               tys_to_str(fcx.ccx.tcx, trait_tps));\n-\n-                /*\n-                Next, we unify the fixed-up substitutions for the impl self\n-                ty with the substitutions from the trait type that we're\n-                trying to cast to. connect_trait_tps requires these\n-                lists of types to unify pairwise.\n-                */\n-\n-                        connect_trait_tps(fcx, expr, substs_f.tps,\n-                                          trait_tps, im.did);\n-                        let subres = lookup_vtables(\n-                            fcx, expr, im_bs, &substs_f,\n-                            false, is_early);\n-\n-                /*\n-                Finally, we register that we found a matching impl,\n-                and record the def ID of the impl as well as the resolved\n-                list of type substitutions for the target trait.\n-                */\n-                        vec::push(found,\n-                                  vtable_static(im.did, substs_f.tps,\n-                                                subres));\n+\n+                            // Now, in the previous example, for_ty is\n+                            // bound to the type self_ty, and substs\n+                            // is bound to [T].\n+                            debug!(\"The self ty is %s and its substs are %s\",\n+                                   fcx.infcx().ty_to_str(for_ty),\n+                                   tys_to_str(fcx.ccx.tcx, substs.tps));\n+\n+                            // Next, we unify trait_ty -- the type\n+                            // that we want to cast to -- with of_ty\n+                            // -- the trait that im implements. At\n+                            // this point, we require that they be\n+                            // unifiable with each other -- that's\n+                            // what relate_trait_tys does.\n+                            //\n+                            // For example, in the above example,\n+                            // of_ty would be some_trait<T>, so we\n+                            // would be unifying trait_ty<U> (for some\n+                            // value of U) with some_trait<T>. This\n+                            // would fail if T and U weren't\n+                            // compatible.\n+\n+                            debug!(\"(checking vtable) @2 relating trait \\\n+                                    ty %s to of_ty %s\",\n+                                   fcx.infcx().ty_to_str(trait_ty),\n+                                   fcx.infcx().ty_to_str(of_ty));\n+                            let of_ty = ty::subst(tcx, &substs, of_ty);\n+                            relate_trait_tys(fcx, expr, trait_ty, of_ty);\n+\n+                            // Recall that trait_ty -- the trait type\n+                            // we're casting to -- is the trait with\n+                            // id trait_id applied to the substs\n+                            // trait_substs. Now we extract out the\n+                            // types themselves from trait_substs.\n+\n+                            let trait_tps = trait_substs.tps;\n+\n+                            debug!(\"Casting to a trait ty whose substs \\\n+                                    (trait_tps) are %s\",\n+                                   tys_to_str(fcx.ccx.tcx, trait_tps));\n+\n+                            // Recall that substs is the impl self\n+                            // type's list of substitutions. That is,\n+                            // if this is an impl of some trait for\n+                            // foo<T, U>, then substs is [T,\n+                            // U]. substs might contain type\n+                            // variables, so we call fixup_substs to\n+                            // resolve them.\n+\n+                            let substs_f = match fixup_substs(fcx,\n+                                                              expr,\n+                                                              trait_id,\n+                                                              substs,\n+                                                              is_early) {\n+                                Some(substs) => substs,\n+                                None => {\n+                                    assert is_early;\n+                                    // Bail out with a bogus answer\n+                                    return vtable_param(0, 0);\n+                                }\n+                            };\n+\n+                            debug!(\"The fixed-up substs are %s - \\\n+                                    they will be unified with the bounds for \\\n+                                    the target ty, %s\",\n+                                   tys_to_str(fcx.ccx.tcx, substs_f.tps),\n+                                   tys_to_str(fcx.ccx.tcx, trait_tps));\n+\n+                            // Next, we unify the fixed-up\n+                            // substitutions for the impl self ty with\n+                            // the substitutions from the trait type\n+                            // that we're trying to cast\n+                            // to. connect_trait_tps requires these\n+                            // lists of types to unify pairwise.\n+\n+                            connect_trait_tps(fcx, expr, substs_f.tps,\n+                                              trait_tps, im.did);\n+                            let subres = lookup_vtables(\n+                                fcx, expr, im_bs, &substs_f,\n+                                false, is_early);\n+\n+                            // Finally, we register that we found a\n+                            // matching impl, and record the def ID of\n+                            // the impl as well as the resolved list\n+                            // of type substitutions for the target\n+                            // trait.\n+                            vec::push(found,\n+                                      vtable_static(im.did, substs_f.tps,\n+                                                    subres));\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        match found.len() {\n-          0 => { /* fallthrough */ }\n-          1 => { return found[0]; }\n-          _ => {\n-            if !is_early {\n-                fcx.ccx.tcx.sess.span_err(\n-                    expr.span,\n-                    ~\"multiple applicable methods in scope\");\n+            match found.len() {\n+                0 => { /* fallthrough */ }\n+                1 => { return found[0]; }\n+                _ => {\n+                    if !is_early {\n+                        fcx.ccx.tcx.sess.span_err(\n+                            expr.span,\n+                            ~\"multiple applicable methods in scope\");\n+                    }\n+                    return found[0];\n+                }\n             }\n-            return found[0];\n-          }\n         }\n-      }\n     }\n \n     tcx.sess.span_fatal("}]}