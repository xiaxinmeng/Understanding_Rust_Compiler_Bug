{"sha": "eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMTY5NDJjMWRlNDJjMmYzMGY3ZTBlYjBmZjY5MzcxYTE2N2Y3YmQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-01T22:57:03Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-01T22:57:03Z"}, "message": "Use dynamic GEP and silly offset-encoding on tydescs. Successful call into a derived tydesc.", "tree": {"sha": "9bc536b0f32c5ab183c11805de7154b5c49c7af5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bc536b0f32c5ab183c11805de7154b5c49c7af5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "html_url": "https://github.com/rust-lang/rust/commit/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ef22972dbe50b2e05c8983769a638fd5b6a23b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef22972dbe50b2e05c8983769a638fd5b6a23b5", "html_url": "https://github.com/rust-lang/rust/commit/8ef22972dbe50b2e05c8983769a638fd5b6a23b5"}], "stats": {"total": 110, "additions": 70, "deletions": 40}, "files": [{"sha": "446b4f10f086359329376649c3c2f8bbcc69ef7d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 70, "deletions": 40, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "patch": "@@ -16,6 +16,7 @@ import back.x86;\n import back.abi;\n \n import middle.ty.pat_ty;\n+import middle.ty.plain_ty;\n \n import util.common;\n import util.common.append;\n@@ -341,7 +342,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n                    @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = vec(T_taskptr());\n \n-    auto fn_ty = ty.plain_ty(ty.ty_fn(inputs, output));\n+    auto fn_ty = plain_ty(ty.ty_fn(inputs, output));\n     auto ty_param_count = ty.count_ty_params(fn_ty);\n     auto i = 0u;\n     while (i < ty_param_count) {\n@@ -869,7 +870,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     // flattened the incoming structure.\n \n     auto s = split_type(t, ixs, 0u);\n-    auto prefix_ty = ty.plain_ty(ty.ty_tup(s.prefix));\n+    auto prefix_ty = plain_ty(ty.ty_tup(s.prefix));\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n@@ -985,7 +986,12 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n         auto i = 0;\n         for (ValueRef td in tys._1) {\n             auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n-            cx.build.Store(td, tdp);\n+            if (i == 0) {\n+                cx.build.Store(root, tdp);\n+            } else {\n+                cx.build.Store(td, tdp);\n+            }\n+            i += 1;\n         }\n \n         auto bcx = cx;\n@@ -1023,19 +1029,30 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n     auto glue_fn_ty = T_ptr(T_fn(vec(T_taskptr(),\n                                      T_ptr(T_ptr(T_tydesc())),\n                                      pvoid), T_void()));\n+\n+    // FIXME: this adjustment has to do with the ridiculous encoding of\n+    // glue-pointer-constants in the tydesc records: They are tydesc-relative\n+    // displacements.  This is purely for compatibility with rustboot and\n+    // should go when it is discarded.\n+    fn off(ValueRef tydescp,\n+           ValueRef gluefn) -> ValueRef {\n+        ret i2p(llvm.LLVMConstSub(p2i(gluefn), p2i(tydescp)),\n+                val_ty(gluefn));\n+    }\n+\n+    auto name = sanitize(cx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n+    auto gvar = llvm.LLVMAddGlobal(cx.llmod, T_tydesc(), _str.buf(name));\n     auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc()))),\n                                llsize_of(llty),\n                                llalign_of(llty),\n-                               take_glue,             // take_glue_off\n-                               drop_glue,             // drop_glue_off\n+                               off(gvar, take_glue),  // take_glue_off\n+                               off(gvar, drop_glue),  // drop_glue_off\n                                C_null(glue_fn_ty),    // free_glue_off\n                                C_null(glue_fn_ty),    // sever_glue_off\n                                C_null(glue_fn_ty),    // mark_glue_off\n                                C_null(glue_fn_ty),    // obj_drop_glue_off\n                                C_null(glue_fn_ty)));  // is_stateful\n \n-    auto name = sanitize(cx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n-    auto gvar = llvm.LLVMAddGlobal(cx.llmod, val_ty(tydesc), _str.buf(name));\n     llvm.LLVMSetInitializer(gvar, tydesc);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n     llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMPrivateLinkage\n@@ -1322,8 +1339,8 @@ fn iter_structural_ty(@block_ctxt cx,\n                   ValueRef box_cell,\n                   val_and_ty_fn f) -> result {\n         auto box_ptr = cx.build.Load(box_cell);\n-        auto tnil = ty.plain_ty(ty.ty_nil);\n-        auto tbox = ty.plain_ty(ty.ty_box(tnil));\n+        auto tnil = plain_ty(ty.ty_nil);\n+        auto tbox = plain_ty(ty.ty_box(tnil));\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -1524,7 +1541,7 @@ fn iter_sequence(@block_ctxt cx,\n             ret iter_sequence_body(cx, v, et, f, false);\n         }\n         case (ty.ty_str) {\n-            auto et = ty.plain_ty(ty.ty_machine(common.ty_u8));\n+            auto et = plain_ty(ty.ty_machine(common.ty_u8));\n             ret iter_sequence_body(cx, v, et, f, true);\n         }\n         case (_) { fail; }\n@@ -1542,6 +1559,15 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n     lltydescs = cx.build.Load(lltydescs);\n     auto llfnptr = cx.build.GEP(tydesc, vec(C_int(0), C_int(field)));\n     auto llfn = cx.build.Load(llfnptr);\n+\n+    // FIXME: this adjustment has to do with the ridiculous encoding of\n+    // glue-pointer-constants in the tydesc records: They are tydesc-relative\n+    // displacements.  This is purely for compatibility with rustboot and\n+    // should go when it is discarded.\n+    llfn = cx.build.IntToPtr(cx.build.Add(cx.build.PtrToInt(llfn, T_int()),\n+                                          cx.build.PtrToInt(tydesc, T_int())),\n+                             val_ty(llfn));\n+\n     cx.build.FastCall(llfn, vec(cx.fcx.lltaskptr, lltydescs, llrawptr));\n }\n \n@@ -2259,7 +2285,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                         check (cx.fcx.ccx.items.contains_key(tid));\n                         auto tag_item = cx.fcx.ccx.items.get(tid);\n                         auto params = ty.item_ty(tag_item)._0;\n-                        auto fty = ty.plain_ty(ty.ty_nil);\n+                        auto fty = plain_ty(ty.ty_nil);\n                         alt (tag_item.node) {\n                             case (ast.item_tag(_, ?variants, _, _)) {\n                                 for (ast.variant v in variants) {\n@@ -2635,7 +2661,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             }\n \n             // Synthesize a closure type.\n-            let @ty.t bindings_ty = ty.plain_ty(ty.ty_tup(bound_tys));\n+            let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n             let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, ty.expr_ty(f));\n             let TypeRef llbindings_ty = type_of(bcx.fcx.ccx, bindings_ty);\n             let TypeRef llclosure_ty = T_closure_ptr(lltarget_ty,\n@@ -3593,52 +3619,52 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         }\n \n         // Synthesize an obj body type.\n-        let @ty.t fields_ty = ty.plain_ty(ty.ty_tup(obj_fields));\n-        let TypeRef llfields_ty = type_of(bcx.fcx.ccx, fields_ty);\n-        let TypeRef llobj_body_ty =\n-            T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n-                                     llfields_ty))));\n+        let @ty.t fields_ty = plain_ty(ty.ty_tup(obj_fields));\n+        let @ty.t body_ty = plain_ty(ty.ty_tup(vec(plain_ty(ty.ty_type),\n+                                                   fields_ty)));\n+        let @ty.t boxed_body_ty = plain_ty(ty.ty_box(body_ty));\n+\n+        let TypeRef llboxed_body_ty = type_of(cx, boxed_body_ty);\n \n         // Malloc a box for the body.\n-        auto r = trans_malloc_inner(bcx, llobj_body_ty);\n-        bcx = r.bcx;\n-        auto box = r.val;\n-        auto rc = bcx.build.GEP(box,\n-                                vec(C_int(0),\n-                                    C_int(abi.box_rc_field_refcnt)));\n-        auto body = bcx.build.GEP(box,\n-                                  vec(C_int(0),\n-                                      C_int(abi.box_rc_field_body)));\n-        bcx.build.Store(C_int(1), rc);\n+        auto box = trans_malloc_inner(bcx, llboxed_body_ty);\n+        bcx = box.bcx;\n+        auto rc = GEP_tup_like(bcx, boxed_body_ty, box.val,\n+                               vec(0, abi.box_rc_field_refcnt));\n+        bcx = rc.bcx;\n+        auto body = GEP_tup_like(bcx, boxed_body_ty, box.val,\n+                                 vec(0, abi.box_rc_field_body));\n+        bcx = body.bcx;\n+        bcx.build.Store(C_int(1), rc.val);\n \n         // Store body tydesc.\n         auto body_tydesc =\n-            bcx.build.GEP(body,\n-                          vec(C_int(0),\n-                              C_int(abi.obj_body_elt_tydesc)));\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         vec(0, abi.obj_body_elt_tydesc));\n+        bcx = body_tydesc.bcx;\n \n-        auto fields_tydesc = get_tydesc(r.bcx, fields_ty);\n+        auto fields_tydesc = get_tydesc(bcx, fields_ty);\n         bcx = fields_tydesc.bcx;\n-        bcx.build.Store(fields_tydesc.val, body_tydesc);\n+        bcx.build.Store(fields_tydesc.val, body_tydesc.val);\n \n         // Copy args into body fields.\n         auto body_fields =\n-            bcx.build.GEP(body,\n-                          vec(C_int(0),\n-                              C_int(abi.obj_body_elt_fields)));\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         vec(0, abi.obj_body_elt_fields));\n+        bcx = body_fields.bcx;\n \n         let int i = 0;\n         for (ast.obj_field f in ob.fields) {\n             auto arg = bcx.fcx.llargs.get(f.id);\n             arg = load_scalar_or_boxed(bcx, arg, arg_tys.(i).ty);\n-            auto field = bcx.build.GEP(body_fields,\n-                                         vec(C_int(0),C_int(i)));\n-            bcx = copy_ty(bcx, INIT, field, arg, arg_tys.(i).ty).bcx;\n+            auto field = GEP_tup_like(bcx, fields_ty, body_fields.val,\n+                                      vec(0, i));\n+            bcx = field.bcx;\n+            bcx = copy_ty(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n             i += 1;\n         }\n-\n         // Store box ptr in outer pair.\n-        auto p = bcx.build.PointerCast(box, llbox_ty);\n+        auto p = bcx.build.PointerCast(box.val, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n     bcx.build.Ret(bcx.build.Load(pair));\n@@ -4030,6 +4056,10 @@ fn p2i(ValueRef v) -> ValueRef {\n     ret llvm.LLVMConstPtrToInt(v, T_int());\n }\n \n+fn i2p(ValueRef v, TypeRef t) -> ValueRef {\n+    ret llvm.LLVMConstIntToPtr(v, t);\n+}\n+\n fn trans_exit_task_glue(@crate_ctxt cx) {\n     let vec[TypeRef] T_args = vec();\n     let vec[ValueRef] V_args = vec();"}]}