{"sha": "35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZjI4YzUzOGE5YjlmNDYxYmI0ZGIxYTc4ZDAyZTlmMDJhM2QyOTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-09T00:41:03Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-09T00:41:03Z"}, "message": "Merge #1512\n\n1512: Infer ? operator r=unrealhoang a=unrealhoang\n\nLogical continuation of https://github.com/rust-analyzer/rust-analyzer/pull/1501\r\n\r\ncc https://github.com/rust-analyzer/rust-analyzer/issues/1426\n\nCo-authored-by: Unreal Hoang <unrealhoang@gmail.com>", "tree": {"sha": "a610ad33b7bc3a1e14770cb34036fa1430ebc900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a610ad33b7bc3a1e14770cb34036fa1430ebc900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "html_url": "https://github.com/rust-lang/rust/commit/35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ecdc6cdce997c6ae251dbda2066de929f9d49c49", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdc6cdce997c6ae251dbda2066de929f9d49c49", "html_url": "https://github.com/rust-lang/rust/commit/ecdc6cdce997c6ae251dbda2066de929f9d49c49"}, {"sha": "9a0d4b16b7d14530b77c96e2e18b80b3f5b526c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a0d4b16b7d14530b77c96e2e18b80b3f5b526c8", "html_url": "https://github.com/rust-lang/rust/commit/9a0d4b16b7d14530b77c96e2e18b80b3f5b526c8"}], "stats": {"total": 123, "additions": 106, "deletions": 17}, "files": [{"sha": "40c9d6002245a010de37acbfa5eef509a9bc688a", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "patch": "@@ -115,6 +115,9 @@ pub(crate) const ITER: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"iter\n pub(crate) const INTO_ITERATOR: Name =\n     Name::new(SmolStr::new_inline_from_ascii(12, b\"IntoIterator\"));\n pub(crate) const ITEM: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Item\"));\n+pub(crate) const OPS: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"ops\"));\n+pub(crate) const TRY: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Try\"));\n+pub(crate) const OK: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"Ok\"));\n \n fn resolve_name(text: &SmolStr) -> SmolStr {\n     let raw_start = \"r#\";"}, {"sha": "827addddd2e2f841931ce2847618e43746fe39bc", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "patch": "@@ -40,7 +40,7 @@ use crate::{\n         PatId, Statement, UnaryOp,\n     },\n     generics::{GenericParams, HasGenericParams},\n-    name::{INTO_ITERATOR, ITEM, ITER, SELF_TYPE, STD},\n+    name,\n     nameres::{Namespace, PerNs},\n     path::{GenericArg, GenericArgs, PathKind, PathSegment},\n     resolve::{\n@@ -843,7 +843,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n             for param in &parent_generics.params {\n-                if param.name == SELF_TYPE {\n+                if param.name == name::SELF_TYPE {\n                     substs.push(receiver_ty.clone());\n                 } else {\n                     substs.push(Ty::Unknown);\n@@ -1140,8 +1140,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.insert_type_vars(ty)\n             }\n             Expr::Try { expr } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                Ty::Unknown\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let ty = match self.resolve_ops_try_ok() {\n+                    Some(ops_try_ok_alias) => {\n+                        let ty = self.new_type_var();\n+                        let projection = ProjectionPredicate {\n+                            ty: ty.clone(),\n+                            projection_ty: ProjectionTy {\n+                                associated_ty: ops_try_ok_alias,\n+                                parameters: vec![inner_ty].into(),\n+                            },\n+                        };\n+                        self.obligations.push(Obligation::Projection(projection));\n+                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                    }\n+                    None => Ty::Unknown,\n+                };\n+                ty\n             }\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n@@ -1347,15 +1362,33 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let into_iter_path = Path {\n             kind: PathKind::Abs,\n             segments: vec![\n-                PathSegment { name: STD, args_and_bindings: None },\n-                PathSegment { name: ITER, args_and_bindings: None },\n-                PathSegment { name: INTO_ITERATOR, args_and_bindings: None },\n+                PathSegment { name: name::STD, args_and_bindings: None },\n+                PathSegment { name: name::ITER, args_and_bindings: None },\n+                PathSegment { name: name::INTO_ITERATOR, args_and_bindings: None },\n             ],\n         };\n \n         match self.resolver.resolve_path_segments(self.db, &into_iter_path).into_fully_resolved() {\n             PerNs { types: Some(Def(Trait(trait_))), .. } => {\n-                Some(trait_.associated_type_by_name(self.db, ITEM)?)\n+                Some(trait_.associated_type_by_name(self.db, name::ITEM)?)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n+        let ops_try_path = Path {\n+            kind: PathKind::Abs,\n+            segments: vec![\n+                PathSegment { name: name::STD, args_and_bindings: None },\n+                PathSegment { name: name::OPS, args_and_bindings: None },\n+                PathSegment { name: name::TRY, args_and_bindings: None },\n+            ],\n+        };\n+\n+        match self.resolver.resolve_path_segments(self.db, &ops_try_path).into_fully_resolved() {\n+            PerNs { types: Some(Def(Trait(trait_))), .. } => {\n+                Some(trait_.associated_type_by_name(self.db, name::OK)?)\n             }\n             _ => None,\n         }"}, {"sha": "6aea1fb4a1894d7f8e18f8d5d7e9d00c015212c3", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f28c538a9b9f461bb4db1a78d02e9f02a3d296/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "patch": "@@ -21,19 +21,57 @@ use crate::{\n // update the snapshots.\n \n #[test]\n-fn infer_for_loop() {\n+fn infer_try() {\n     let (mut db, pos) = MockDatabase::with_position(\n         r#\"\n //- /main.rs\n-struct Vec<T> {}\n-impl<T> Vec<T> {\n-    fn new() -> Self { Vec {} }\n-    fn push(&mut self, t: T) { }\n+\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n+    let v = r?;\n+    v<|>;\n }\n \n-impl<T> ::std::iter::IntoIterator for Vec<T> {\n-    type Item=T;\n+//- /std.rs\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    trait Try {\n+        type Ok;\n+        type Error;\n+    }\n+}\n+\n+#[prelude_import] use result::*;\n+mod result {\n+    enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> crate::ops::Try for Result<O, E> {\n+        type Ok = O;\n+        type Error = E;\n+    }\n+}\n+\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"std\"]),\n+        \"std\": (\"/std.rs\", []),\n+    });\n+    assert_eq!(\"i32\", type_at_pos(&db, pos));\n }\n+\n+#[test]\n+fn infer_for_loop() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+\n+use std::collections::Vec;\n+\n fn test() {\n     let v = Vec::new();\n     v.push(\"foo\");\n@@ -42,20 +80,35 @@ fn test() {\n     }\n }\n \n-//- /lib.rs\n+//- /std.rs\n+\n+#[prelude_import] use iter::*;\n mod iter {\n     trait IntoIterator {\n         type Item;\n     }\n }\n+\n+mod collections {\n+    struct Vec<T> {}\n+    impl<T> Vec<T> {\n+        fn new() -> Self { Vec {} }\n+        fn push(&mut self, t: T) { }\n+    }\n+\n+    impl<T> crate::iter::IntoIterator for Vec<T> {\n+        type Item=T;\n+    }\n+}\n \"#,\n     );\n     db.set_crate_graph_from_fixture(crate_graph! {\n         \"main\": (\"/main.rs\", [\"std\"]),\n-        \"std\": (\"/lib.rs\", []),\n+        \"std\": (\"/std.rs\", []),\n     });\n     assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n+\n #[test]\n fn infer_basics() {\n     assert_snapshot_matches!("}]}