{"sha": "c9686cb31ad9dd9428825dbb3b362f5df72ab719", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5Njg2Y2IzMWFkOWRkOTQyODgyNWRiYjNiMzYyZjVkZjcyYWI3MTk=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2020-07-26T12:53:39Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2020-09-14T01:08:08Z"}, "message": "Introduce a PartitioningCx struct", "tree": {"sha": "f936114ef0f00177214fbadeeafc753bad6cd58f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f936114ef0f00177214fbadeeafc753bad6cd58f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9686cb31ad9dd9428825dbb3b362f5df72ab719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9686cb31ad9dd9428825dbb3b362f5df72ab719", "html_url": "https://github.com/rust-lang/rust/commit/c9686cb31ad9dd9428825dbb3b362f5df72ab719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9686cb31ad9dd9428825dbb3b362f5df72ab719/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d0f6b113047b2cf9afbde990cee30fd5b866469", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0f6b113047b2cf9afbde990cee30fd5b866469", "html_url": "https://github.com/rust-lang/rust/commit/0d0f6b113047b2cf9afbde990cee30fd5b866469"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "827d037f3198888888f36188d4470fbb122b2544", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c9686cb31ad9dd9428825dbb3b362f5df72ab719/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9686cb31ad9dd9428825dbb3b362f5df72ab719/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=c9686cb31ad9dd9428825dbb3b362f5df72ab719", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::ty::print::characteristic_def_id_of_type;\n use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n use rustc_span::symbol::Symbol;\n \n+use super::PartitioningCx;\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::partitioning::merging;\n use crate::monomorphize::partitioning::{\n@@ -22,35 +23,36 @@ pub struct DefaultPartitioning;\n impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n     fn place_root_mono_items(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     ) -> PreInliningPartitioning<'tcx> {\n         let mut roots = FxHashSet::default();\n         let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n         let mut internalization_candidates = FxHashSet::default();\n \n         // Determine if monomorphizations instantiated in this crate will be made\n         // available to downstream crates. This depends on whether we are in\n         // share-generics mode and whether the current crate can even have\n         // downstream crates.\n-        let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n+        let export_generics =\n+            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n \n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n         let cgu_name_cache = &mut FxHashMap::default();\n \n         for mono_item in mono_items {\n-            match mono_item.instantiation_mode(tcx) {\n+            match mono_item.instantiation_mode(cx.tcx) {\n                 InstantiationMode::GloballyShared { .. } => {}\n                 InstantiationMode::LocalCopy => continue,\n             }\n \n-            let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n+            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n             let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(\n-                    tcx,\n+                    cx.tcx,\n                     cgu_name_builder,\n                     def_id,\n                     is_volatile,\n@@ -65,7 +67,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n             let mut can_be_internalized = true;\n             let (linkage, visibility) = mono_item_linkage_and_visibility(\n-                tcx,\n+                cx.tcx,\n                 &mono_item,\n                 &mut can_be_internalized,\n                 export_generics,\n@@ -97,17 +99,16 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n     fn merge_codegen_units(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-        target_cgu_count: usize,\n     ) {\n-        merging::merge_codegen_units(tcx, initial_partitioning, target_cgu_count);\n+        merging::merge_codegen_units(cx, initial_partitioning);\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: PreInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) -> PostInliningPartitioning<'tcx> {\n         let mut new_partitioning = Vec::new();\n         let mut mono_item_placements = FxHashMap::default();\n@@ -124,7 +125,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n             // Collect all items that need to be available in this codegen unit.\n             let mut reachable = FxHashSet::default();\n             for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, inlining_map, &mut reachable);\n+                follow_inlining(*root, cx.inlining_map, &mut reachable);\n             }\n \n             let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -198,9 +199,8 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n     fn internalize_symbols(\n         &mut self,\n-        _tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         partitioning: &mut PostInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) {\n         if partitioning.codegen_units.len() == 1 {\n             // Fast path for when there is only one codegen unit. In this case we\n@@ -218,7 +218,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n         // Build a map from every monomorphization to all the monomorphizations that\n         // reference it.\n         let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        inlining_map.iter_accesses(|accessor, accessees| {\n+        cx.inlining_map.iter_accesses(|accessor, accessees| {\n             for accessee in accessees {\n                 accessor_map.entry(*accessee).or_default().push(accessor);\n             }"}, {"sha": "3f3aaa2f63ca32fb1575d2b5ab8d3d531fc06789", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/merging.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9686cb31ad9dd9428825dbb3b362f5df72ab719/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9686cb31ad9dd9428825dbb3b362f5df72ab719/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs?ref=c9686cb31ad9dd9428825dbb3b362f5df72ab719", "patch": "@@ -3,17 +3,16 @@ use std::cmp;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{Symbol, SymbolStr};\n \n+use super::PartitioningCx;\n use crate::monomorphize::partitioning::PreInliningPartitioning;\n \n pub fn merge_codegen_units<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+    cx: &PartitioningCx<'_, 'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    target_cgu_count: usize,\n ) {\n-    assert!(target_cgu_count >= 1);\n+    assert!(cx.target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n     // Note that at this point in time the `codegen_units` here may not be in a\n@@ -32,7 +31,7 @@ pub fn merge_codegen_units<'tcx>(\n         codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n \n     // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > target_cgu_count {\n+    while codegen_units.len() > cx.target_cgu_count {\n         // Sort small cgus to the back\n         codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n         let mut smallest = codegen_units.pop().unwrap();\n@@ -56,9 +55,9 @@ pub fn merge_codegen_units<'tcx>(\n         );\n     }\n \n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n \n-    if tcx.sess.opts.incremental.is_some() {\n+    if cx.tcx.sess.opts.incremental.is_some() {\n         // If we are doing incremental compilation, we want CGU names to\n         // reflect the path of the source level module they correspond to.\n         // For CGUs that contain the code of multiple modules because of the\n@@ -82,7 +81,7 @@ pub fn merge_codegen_units<'tcx>(\n \n         for cgu in codegen_units.iter_mut() {\n             if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+                if cx.tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n                     cgu.set_name(Symbol::intern(&new_cgu_name));\n                 } else {\n                     // If we don't require CGU names to be human-readable, we"}, {"sha": "f66fec37b25de38120dc544d951d0c621c726e8f", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c9686cb31ad9dd9428825dbb3b362f5df72ab719/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9686cb31ad9dd9428825dbb3b362f5df72ab719/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs?ref=c9686cb31ad9dd9428825dbb3b362f5df72ab719", "patch": "@@ -107,31 +107,35 @@ use rustc_span::symbol::Symbol;\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n \n+pub struct PartitioningCx<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    target_cgu_count: usize,\n+    inlining_map: &'a InliningMap<'tcx>,\n+}\n+\n trait Partitioner<'tcx> {\n     fn place_root_mono_items(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     ) -> PreInliningPartitioning<'tcx>;\n \n     fn merge_codegen_units(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-        target_cgu_count: usize,\n     );\n \n     fn place_inlined_mono_items(\n         &mut self,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: PreInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) -> PostInliningPartitioning<'tcx>;\n \n     fn internalize_symbols(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         partitioning: &mut PostInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     );\n }\n \n@@ -156,12 +160,13 @@ pub fn partition<'tcx>(\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n     let mut partitioner = get_partitioner(tcx);\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(tcx, mono_items)\n+        partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -171,7 +176,7 @@ pub fn partition<'tcx>(\n     // Merge until we have at most `max_cgu_count` codegen units.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n+        partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n@@ -181,7 +186,7 @@ pub fn partition<'tcx>(\n     // local functions the definition of which is marked with `#[inline]`.\n     let mut post_inlining = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(initial_partitioning, inlining_map)\n+        partitioner.place_inlined_mono_items(cx, initial_partitioning)\n     };\n \n     post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -192,7 +197,7 @@ pub fn partition<'tcx>(\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(tcx, &mut post_inlining, inlining_map);\n+        partitioner.internalize_symbols(cx, &mut post_inlining);\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results."}]}