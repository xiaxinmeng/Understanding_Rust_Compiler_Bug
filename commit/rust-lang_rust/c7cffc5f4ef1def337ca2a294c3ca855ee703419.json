{"sha": "c7cffc5f4ef1def337ca2a294c3ca855ee703419", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3Y2ZmYzVmNGVmMWRlZjMzN2NhMmEyOTRjM2NhODU1ZWU3MDM0MTk=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-05-04T18:48:58Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-05-05T03:54:54Z"}, "message": "Deprecate heap::EMPTY in favour of Unique::empty or otherwise.", "tree": {"sha": "6d112c6462a626413c82467cd5de05af3ae41d05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d112c6462a626413c82467cd5de05af3ae41d05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7cffc5f4ef1def337ca2a294c3ca855ee703419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7cffc5f4ef1def337ca2a294c3ca855ee703419", "html_url": "https://github.com/rust-lang/rust/commit/c7cffc5f4ef1def337ca2a294c3ca855ee703419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7cffc5f4ef1def337ca2a294c3ca855ee703419/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "html_url": "https://github.com/rust-lang/rust/commit/4ff583b1161c5c2e08c28a0740f34a526b39a8bc"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "fc6929f896ecbaa70870751f9c59007cc1024983", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c7cffc5f4ef1def337ca2a294c3ca855ee703419", "patch": "@@ -156,7 +156,7 @@ fn make_place<T>() -> IntermediateBox<T> {\n     let align = mem::align_of::<T>();\n \n     let p = if size == 0 {\n-        heap::EMPTY as *mut u8\n+        mem::align_of::<T>() as *mut u8\n     } else {\n         let p = unsafe { heap::allocate(size, align) };\n         if p.is_null() {"}, {"sha": "5ff21c86483c80cbbef1ef02fe516cc425b5dab6", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=c7cffc5f4ef1def337ca2a294c3ca855ee703419", "patch": "@@ -138,7 +138,9 @@ pub fn usable_size(size: usize, align: usize) -> usize {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address\n /// may overlap with non-zero-size memory allocations.\n-pub const EMPTY: *mut () = 0x1 as *mut ();\n+#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/Shared::empty() instead\")]\n+#[unstable(feature = \"heap_api\", issue = \"27700\")]\n+pub const EMPTY: *mut () = 1 as *mut ();\n \n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n@@ -147,7 +149,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n-        EMPTY as *mut u8\n+        align as *mut u8\n     } else {\n         let ptr = allocate(size, align);\n         if ptr.is_null() {"}, {"sha": "7edf07944ec50c812aead220f6e66b4c69402b6a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=c7cffc5f4ef1def337ca2a294c3ca855ee703419", "patch": "@@ -22,13 +22,13 @@ use core::cmp;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces heap::EMPTY on zero-sized types\n-/// * Produces heap::EMPTY on zero-length allocations\n+/// * Produces Unique::empty() on zero-sized types\n+/// * Produces Unique::empty() on zero-length allocations\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes\n /// * Guards against overflowing your length\n /// * Aborts on OOM\n-/// * Avoids freeing heap::EMPTY\n+/// * Avoids freeing Unique::empty()\n /// * Contains a ptr::Unique and thus endows the user with all related benefits\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n@@ -55,15 +55,13 @@ impl<T> RawVec<T> {\n     /// it makes a RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+        // !0 is usize::MAX. This branch should be stripped at compile time.\n+        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec {\n-                ptr: Unique::new(heap::EMPTY as *mut T),\n-                cap: cap,\n-            }\n+        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        RawVec {\n+            ptr: Unique::empty(),\n+            cap: cap,\n         }\n     }\n \n@@ -101,7 +99,7 @@ impl<T> RawVec<T> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                heap::EMPTY as *mut u8\n+                mem::align_of::<T>() as *mut u8\n             } else {\n                 let align = mem::align_of::<T>();\n                 let ptr = if zeroed {\n@@ -148,10 +146,10 @@ impl<T> RawVec<T> {\n \n impl<T> RawVec<T> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// heap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n-        self.ptr.ptr()\n+        self.ptr.as_ptr()\n     }\n \n     /// Gets the capacity of the allocation."}, {"sha": "321fa2edd56c7717e9bb2aaa243392d175b5feb1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=c7cffc5f4ef1def337ca2a294c3ca855ee703419", "patch": "@@ -31,7 +31,6 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(heap_api)]\n #![feature(generic_param_attrs)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]\n@@ -48,7 +47,6 @@ use std::mem;\n use std::ptr;\n use std::slice;\n \n-use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n /// An arena that can hold objects of only one type.\n@@ -140,7 +138,7 @@ impl<T> TypedArena<T> {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n-                let ptr = heap::EMPTY as *mut T;\n+                let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "7ec5c29de6b4be49918d8bc5678f51a0ef665d29", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c7cffc5f4ef1def337ca2a294c3ca855ee703419", "patch": "@@ -67,7 +67,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use alloc::heap::EMPTY;\n use alloc::raw_vec::RawVec;\n use borrow::ToOwned;\n use borrow::Cow;\n@@ -2192,7 +2191,8 @@ impl<T> Iterator for IntoIter<T> {\n                     self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.ptr might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -2231,7 +2231,8 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n                     self.end = arith_offset(self.end as *const i8, -1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.end might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n "}, {"sha": "a15269cc87c5da08f9e0acd973f628ba83240bda", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7cffc5f4ef1def337ca2a294c3ca855ee703419/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c7cffc5f4ef1def337ca2a294c3ca855ee703419", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::{EMPTY, allocate, deallocate};\n+use alloc::heap::{allocate, deallocate};\n \n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n@@ -33,6 +33,7 @@ use self::BucketState::*;\n type HashUint = usize;\n \n const EMPTY_BUCKET: HashUint = 0;\n+const EMPTY: usize = 1;\n \n /// Special `Unique<HashUint>` that uses the lower bit of the pointer\n /// to expose a boolean tag."}]}