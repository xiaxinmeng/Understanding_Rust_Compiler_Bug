{"sha": "1ff8994fce4a7ba719bc0b35dceb6442a66888a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZjg5OTRmY2U0YTdiYTcxOWJjMGIzNWRjZWI2NDQyYTY2ODg4YTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-07T16:34:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-08T01:05:58Z"}, "message": "Purge old map impl: more collisions, not clear it is safe on 64bit", "tree": {"sha": "89610382b670923214fe5be162f52e817d5336f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89610382b670923214fe5be162f52e817d5336f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ff8994fce4a7ba719bc0b35dceb6442a66888a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff8994fce4a7ba719bc0b35dceb6442a66888a0", "html_url": "https://github.com/rust-lang/rust/commit/1ff8994fce4a7ba719bc0b35dceb6442a66888a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ff8994fce4a7ba719bc0b35dceb6442a66888a0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b704ac69b17d8d338c25cdb24f8bcdfbd7565a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b704ac69b17d8d338c25cdb24f8bcdfbd7565a4", "html_url": "https://github.com/rust-lang/rust/commit/4b704ac69b17d8d338c25cdb24f8bcdfbd7565a4"}], "stats": {"total": 205, "additions": 0, "deletions": 205}, "files": [{"sha": "18cae4d55b76b864e216d8afb9315a46ee645053", "filename": "src/libstd/map.rs", "status": "modified", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/1ff8994fce4a7ba719bc0b35dceb6442a66888a0/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff8994fce4a7ba719bc0b35dceb6442a66888a0/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=1ff8994fce4a7ba719bc0b35dceb6442a66888a0", "patch": "@@ -353,211 +353,6 @@ mod chained {\n     }\n }\n \n-/*\n-Function: mk_flat_hashmap\n-\n-Construct a \"flat\" hashmap, meaning that there are\n-not chains per buckets, but rather we search a sequence\n-of buckets for each key.\n-\n-Warning: it is unclear to me that this code is correct\n-on 32-bit processors.  Check out the 'hash-tearing' code\n-in hash() and the comment surrounding it. - Niko\n-\n-Parameters:\n-\n-hasher - The hash function for key type K\n-eqer - The equality function for key type K\n-*/\n-fn mk_flat_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n-    -> hashmap<K, V> {\n-    let initial_capacity: uint = 32u; // 2^5\n-\n-    let load_factor: util::rational = {num: 3, den: 4};\n-    tag bucket<copy K, copy V> { nil; deleted; some(K, V); }\n-    fn make_buckets<copy K, copy V>(nbkts: uint) -> [mutable bucket<K, V>] {\n-        ret vec::init_elt_mut::<bucket<K, V>>(nil::<K, V>, nbkts);\n-    }\n-    // Derive two hash functions from the one given by taking the upper\n-    // half and lower half of the uint bits.  Our bucket probing\n-    // sequence is then defined by\n-    //\n-    //   hash(key, i) := hashl(key) * i + hashr(key)   for i = 0, 1, 2, ...\n-    //\n-    // Tearing the hash function apart this way is kosher in practice\n-    // as, assuming 32-bit uints, the table would have to be at 2^32\n-    // buckets before the resulting pair of hash functions no longer\n-    // probes all buckets for a fixed key.  Note that hashl is made to\n-    // output odd numbers (hence coprime to the number of nbkts, which\n-    // is always a power? of 2), so that all buckets are probed for a\n-    // fixed key.\n-\n-    fn hashl(n: uint) -> uint { ret (n >>> 16u) * 2u + 1u; }\n-    fn hashr(n: uint) -> uint { ret 0x0000_ffff_u & n; }\n-    fn hash(h: uint, nbkts: uint, i: uint) -> uint {\n-        ret (hashl(h) * i + hashr(h)) % nbkts;\n-    }\n-\n-    /**\n-     * We attempt to never call this with a full table.  If we do, it\n-     * will fail.\n-     */\n-    fn insert_common<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                                     bkts: [mutable bucket<K, V>],\n-                                     nbkts: uint, key: K, val: V) -> bool {\n-        let i: uint = 0u;\n-        let h = hasher(key);\n-        while i < nbkts {\n-            let j: uint = hash(h, nbkts, i);\n-            alt bkts[j] {\n-              some(k, _) {\n-                // Copy key to please alias analysis.\n-\n-                let k_ = k;\n-                if eqer(key, k_) {\n-                    log(\"map updated\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n-                    bkts[j] = some(k_, val);\n-                    ret false;\n-                }\n-                i += 1u;\n-              }\n-              _ {\n-                log(\"map inserted\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n-                bkts[j] = some(key, val);\n-                ret true;\n-              }\n-            }\n-        }\n-        fail; // full table\n-    }\n-    fn find_common<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                                   bkts: [mutable bucket<K, V>],\n-                                   nbkts: uint, key: K) -> option::t<V> {\n-        let i: uint = 0u;\n-        let h = hasher(key);\n-        while i < nbkts {\n-            let j: uint = hash(h, nbkts, i);\n-            alt bkts[j] {\n-              some(k, v) {\n-                // Copy to please alias analysis.\n-                let k_ = k;\n-                let v_ = v;\n-                if eqer(key, k_) {\n-                    log(\"map present\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n-                    ret option::some(v_);\n-                }\n-              }\n-              nil. {\n-                log(\"map absent\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n-                ret option::none;\n-              }\n-              deleted. { }\n-            }\n-            i += 1u;\n-        }\n-        ret option::none;\n-    }\n-    fn rehash<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                              oldbkts: [mutable bucket<K, V>],\n-                              _noldbkts: uint,\n-                              newbkts: [mutable bucket<K, V>],\n-                              nnewbkts: uint) {\n-        for b: bucket<K, V> in oldbkts {\n-            alt b {\n-              some(k_, v_) {\n-                let k = k_;\n-                let v = v_;\n-                insert_common(hasher, eqer, newbkts, nnewbkts, k, v);\n-              }\n-              _ { }\n-            }\n-        }\n-    }\n-    obj hashmap<copy K, copy V>(hasher: hashfn<K>,\n-                                eqer: eqfn<K>,\n-                                mutable bkts: [mutable bucket<K, V>],\n-                                mutable nbkts: uint,\n-                                mutable nelts: uint,\n-                                lf: util::rational) {\n-        fn size() -> uint { ret nelts; }\n-        fn insert(key: K, val: V) -> bool {\n-            let load: util::rational =\n-                {num: nelts + 1u as int, den: nbkts as int};\n-            if !util::rational_leq(load, lf) {\n-                let nnewbkts: uint = uint::next_power_of_two(nbkts + 1u);\n-                let newbkts = make_buckets(nnewbkts);\n-                rehash(hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n-                bkts = newbkts;\n-                nbkts = nnewbkts;\n-            }\n-            if insert_common(hasher, eqer, bkts, nbkts, key, val) {\n-                nelts += 1u;\n-                ret true;\n-            }\n-            ret false;\n-        }\n-        fn contains_key(key: K) -> bool {\n-            ret alt find_common(hasher, eqer, bkts, nbkts, key) {\n-                  option::some(_) { true }\n-                  _ { false }\n-                };\n-        }\n-        fn get(key: K) -> V {\n-            ret alt find_common(hasher, eqer, bkts, nbkts, key) {\n-                  option::some(val) { val }\n-                  _ { fail }\n-                };\n-        }\n-        fn find(key: K) -> option::t<V> {\n-            be find_common(hasher, eqer, bkts, nbkts, key);\n-        }\n-        fn remove(key: K) -> option::t<V> {\n-            let i: uint = 0u;\n-            let h = hasher(key);\n-            while i < nbkts {\n-                let j: uint = hash(h, nbkts, i);\n-                alt bkts[j] {\n-                  some(k, v) {\n-                    let k_ = k;\n-                    let vo = option::some(v);\n-                    if eqer(key, k_) {\n-                        bkts[j] = deleted;\n-                        nelts -= 1u;\n-                        ret vo;\n-                    }\n-                  }\n-                  deleted. { }\n-                  nil. { ret option::none; }\n-                }\n-                i += 1u;\n-            }\n-            ret option::none;\n-        }\n-        fn rehash() {\n-            let newbkts = make_buckets(nbkts);\n-            rehash(hasher, eqer, bkts, nbkts, newbkts, nbkts);\n-            bkts = newbkts;\n-        }\n-        fn items(it: block(K, V)) {\n-            for b in bkts {\n-                alt b { some(k, v) { it(copy k, copy v); } _ { } }\n-            }\n-        }\n-        fn keys(it: block(K)) {\n-            for b in bkts {\n-                alt b { some(k, _) { it(copy k); } _ { } }\n-            }\n-        }\n-        fn values(it: block(V)) {\n-            for b in bkts {\n-                alt b { some(_, v) { it(copy v); } _ { } }\n-            }\n-        }\n-    }\n-    let bkts = make_buckets(initial_capacity);\n-    ret hashmap(hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n-}\n-\n /*\n Function: mk_hashmap\n "}]}