{"sha": "09885b5b878730f266d3450b95d2f91b46183654", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ODg1YjViODc4NzMwZjI2NmQzNDUwYjk1ZDJmOTFiNDYxODM2NTQ=", "commit": {"author": {"name": "Jeffrey Yasskin", "email": "jyasskin@gmail.com", "date": "2010-07-22T10:18:27Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2010-07-22T16:42:51Z"}, "message": "Implement tuple access for LLVM.\nThis involved adding an Ast.ty return to trans_lval.\n\nI also included the code for record and box access, but their tests don't\ncompletely pass yet.", "tree": {"sha": "638e5499fea580c264ea8c485e0a5824e5dade5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/638e5499fea580c264ea8c485e0a5824e5dade5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09885b5b878730f266d3450b95d2f91b46183654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09885b5b878730f266d3450b95d2f91b46183654", "html_url": "https://github.com/rust-lang/rust/commit/09885b5b878730f266d3450b95d2f91b46183654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09885b5b878730f266d3450b95d2f91b46183654/comments", "author": {"login": "jyasskin", "id": 83420, "node_id": "MDQ6VXNlcjgzNDIw", "avatar_url": "https://avatars.githubusercontent.com/u/83420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyasskin", "html_url": "https://github.com/jyasskin", "followers_url": "https://api.github.com/users/jyasskin/followers", "following_url": "https://api.github.com/users/jyasskin/following{/other_user}", "gists_url": "https://api.github.com/users/jyasskin/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyasskin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyasskin/subscriptions", "organizations_url": "https://api.github.com/users/jyasskin/orgs", "repos_url": "https://api.github.com/users/jyasskin/repos", "events_url": "https://api.github.com/users/jyasskin/events{/privacy}", "received_events_url": "https://api.github.com/users/jyasskin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c070c1124883e400cc9fba1b97c6cfef60189575", "url": "https://api.github.com/repos/rust-lang/rust/commits/c070c1124883e400cc9fba1b97c6cfef60189575", "html_url": "https://github.com/rust-lang/rust/commit/c070c1124883e400cc9fba1b97c6cfef60189575"}], "stats": {"total": 98, "additions": 77, "deletions": 21}, "files": [{"sha": "5832a3f0373236942db88e021ef80e16bd777dea", "filename": "src/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09885b5b878730f266d3450b95d2f91b46183654/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/09885b5b878730f266d3450b95d2f91b46183654/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=09885b5b878730f266d3450b95d2f91b46183654", "patch": "@@ -477,7 +477,6 @@ TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                       task-comm-4.rs \\\n                       task-comm-5.rs \\\n                       threads.rs \\\n-                      tup.rs \\\n                       type-sizes.rs \\\n                       unit.rs \\\n                       use-import-export.rs \\"}, {"sha": "ef1affc08a7a74be897b8139f974a357f5173993", "filename": "src/boot/llvm/lltrans.ml", "status": "modified", "additions": 77, "deletions": 20, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/09885b5b878730f266d3450b95d2f91b46183654/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/09885b5b878730f266d3450b95d2f91b46183654/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=09885b5b878730f266d3450b95d2f91b46183654", "patch": "@@ -3,6 +3,7 @@\n  *)\n \n open Common;;\n+open Semant;;\n open Transutil;;\n \n let log cx = Session.log \"trans\"\n@@ -549,6 +550,37 @@ let trans_crate\n         end\n   in\n \n+  (* Dereferences the box referred to by ptr, whose type is ty.  Looks\n+     straight through all mutable and constrained-type boxes, and loads\n+     pointers per dctrl.  Returns the dereferenced value and its type. *)\n+  let rec deref_ty\n+      (llbuilder:Llvm.llbuilder) (dctrl:deref_ctrl)\n+      (ptr:Llvm.llvalue) (ty:Ast.ty)\n+      : (Llvm.llvalue * Ast.ty) =\n+    match (ty, dctrl) with\n+\n+      | (Ast.TY_mutable ty, _)\n+      | (Ast.TY_constrained (ty, _), _) ->\n+          deref_ty llbuilder dctrl ptr ty\n+\n+      | (Ast.TY_box ty', DEREF_one_box)\n+      | (Ast.TY_box ty', DEREF_all_boxes) ->\n+          let content =\n+            Llvm.build_load\n+              (get_element_ptr llbuilder ptr (Abi.box_rc_field_body))\n+              (anon_llid \"deref\") llbuilder\n+          in\n+          let inner_dctrl =\n+            if dctrl = DEREF_one_box\n+            then DEREF_none\n+            else DEREF_all_boxes\n+          in\n+            (* Possibly deref recursively. *)\n+            deref_ty llbuilder inner_dctrl content ty'\n+\n+      | _ -> (ptr, ty)\n+  in\n+\n   let (llitems:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n     (* Maps a fn's or block's id to an LLVM metadata node (subprogram or\n        lexical block) representing it. *)\n@@ -724,36 +756,61 @@ let trans_crate\n \n       (* Translates an lval by reference into the appropriate pointer\n        * value. *)\n-      let trans_lval (lval:Ast.lval) : Llvm.llvalue =\n+      let rec trans_lval (lval:Ast.lval) : (Llvm.llvalue * Ast.ty) =\n         iflog (fun _ -> log sem_cx \"trans_lval: %a\" Ast.sprintf_lval lval);\n         match lval with\n             Ast.LVAL_base { id = base_id } ->\n               set_debug_loc base_id;\n-              let id =\n-                Hashtbl.find sem_cx.Semant.ctxt_lval_to_referent base_id\n-              in\n-              let referent = Hashtbl.find sem_cx.Semant.ctxt_all_defns id in\n+              let referent = lval_to_referent sem_cx base_id in\n               begin\n-                match referent with\n-                    Semant.DEFN_slot _ -> Hashtbl.find slot_to_llvalue id\n-                  | Semant.DEFN_item _ -> Hashtbl.find llitems id\n+                match resolve_lval_id sem_cx base_id with\n+                    Semant.DEFN_slot slot ->\n+                      (Hashtbl.find slot_to_llvalue referent, slot_ty slot)\n+                  | Semant.DEFN_item _ ->\n+                      (Hashtbl.find llitems referent, lval_ty sem_cx lval)\n                   | _ ->\n-                      Common.unimpl (Some id)\n+                      Common.unimpl (Some referent)\n                         \"LLVM base-referent translation of: %a\"\n                         Ast.sprintf_lval lval\n               end\n-          | Ast.LVAL_ext _ ->\n-              Common.unimpl (Some (Semant.lval_base_id lval))\n-                        \"LLVM lval translation of: %a\"\n-                        Ast.sprintf_lval lval\n+          | Ast.LVAL_ext (base, component) ->\n+              let (llbase, base_ty) = trans_lval base in\n+              let base_ty = strip_mutable_or_constrained_ty base_ty in\n+                (*\n+                 * All lval components aside from explicit-deref just\n+                 * auto-deref through all boxes to find their indexable\n+                 * referent.\n+                 *)\n+              let (llbase, base_ty) =\n+                if component = Ast.COMP_deref\n+                then (llbase, base_ty)\n+                else deref_ty llbuilder DEREF_all_boxes llbase base_ty\n+              in\n+                match (base_ty, component) with\n+                    (Ast.TY_rec entries,\n+                     Ast.COMP_named (Ast.COMP_ident id)) ->\n+                      let i = arr_idx (Array.map fst entries) id in\n+                        (get_element_ptr llbuilder llbase i, snd entries.(i))\n+\n+                  | (Ast.TY_tup entries,\n+                     Ast.COMP_named (Ast.COMP_idx i)) ->\n+                      (get_element_ptr llbuilder llbase i, entries.(i))\n+\n+                  | (Ast.TY_box _, Ast.COMP_deref) ->\n+                      deref_ty llbuilder DEREF_one_box llbase base_ty\n+\n+                  | _ -> (Common.unimpl (Some (Semant.lval_base_id lval))\n+                            \"LLVM lval translation of: %a\"\n+                            Ast.sprintf_lval lval)\n       in\n \n       let trans_atom (atom:Ast.atom) : Llvm.llvalue =\n         iflog (fun _ -> log sem_cx \"trans_atom: %a\" Ast.sprintf_atom atom);\n         match atom with\n             Ast.ATOM_literal { node = lit } -> trans_literal lit\n           | Ast.ATOM_lval lval ->\n-              Llvm.build_load (trans_lval lval) (anon_llid \"tmp\") llbuilder\n+              Llvm.build_load (fst (trans_lval lval)) (anon_llid \"tmp\")\n+                llbuilder\n       in\n \n       let build_binop (op:Ast.binop) (lllhs:Llvm.llvalue) (llrhs:Llvm.llvalue)\n@@ -867,7 +924,7 @@ let trans_crate\n             match head.node with\n                 Ast.STMT_init_tup (dest, elems) ->\n                   let zero = const_i32 0 in\n-                  let lldest = trans_lval dest in\n+                  let (lldest, _) = trans_lval dest in\n                   let trans_tup_elem idx (_, atom) =\n                     let indices = [| zero; const_i32 idx |] in\n                     let gep_id = anon_llid \"init_tup_gep\" in\n@@ -881,12 +938,12 @@ let trans_crate\n \n               | Ast.STMT_copy (dest, src) ->\n                   let llsrc = trans_expr src in\n-                  let lldest = trans_lval dest in\n+                  let (lldest, _) = trans_lval dest in\n                   ignore (Llvm.build_store llsrc lldest llbuilder);\n                   trans_tail ()\n \n               | Ast.STMT_copy_binop (dest, op, src) ->\n-                  let lldest = trans_lval dest in\n+                  let (lldest, _) = trans_lval dest in\n                   let llsrc = trans_atom src in\n                     (* FIXME: Handle vecs and strs. *)\n                   let lldest_deref =\n@@ -898,8 +955,8 @@ let trans_crate\n \n               | Ast.STMT_call (dest, fn, args) ->\n                   let llargs = Array.map trans_atom args in\n-                  let lldest = trans_lval dest in\n-                  let llfn = trans_lval fn in\n+                  let (lldest, _) = trans_lval dest in\n+                  let (llfn, _) = trans_lval fn in\n                   let llallargs = Array.append [| lldest; lltask |] llargs in\n                   let llrv = build_call llfn llallargs \"\" llbuilder in\n                     Llvm.set_instruction_call_conv Llvm.CallConv.c llrv;\n@@ -966,7 +1023,7 @@ let trans_crate\n                   trans_tail_with_builder llokbuilder\n \n               | Ast.STMT_init_str (dst, str) ->\n-                  let d = trans_lval dst in\n+                  let (d, _) = trans_lval dst in\n                   let s = static_str str in\n                   let len =\n                     Llvm.const_int word_ty ((String.length str) + 1)"}]}