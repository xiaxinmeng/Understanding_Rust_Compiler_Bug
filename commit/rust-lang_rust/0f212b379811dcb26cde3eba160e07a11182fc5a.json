{"sha": "0f212b379811dcb26cde3eba160e07a11182fc5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMjEyYjM3OTgxMWRjYjI2Y2RlM2ViYTE2MGUwN2ExMTE4MmZjNWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-20T14:43:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-20T15:52:02Z"}, "message": "Move ModuleScope to a new module", "tree": {"sha": "cdc5814a3a912d5deb701c32386bfa3a44aca3cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdc5814a3a912d5deb701c32386bfa3a44aca3cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f212b379811dcb26cde3eba160e07a11182fc5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f212b379811dcb26cde3eba160e07a11182fc5a", "html_url": "https://github.com/rust-lang/rust/commit/0f212b379811dcb26cde3eba160e07a11182fc5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f212b379811dcb26cde3eba160e07a11182fc5a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49aac9ef63bf11827fca48c16b820ee1c3fe327f", "url": "https://api.github.com/repos/rust-lang/rust/commits/49aac9ef63bf11827fca48c16b820ee1c3fe327f", "html_url": "https://github.com/rust-lang/rust/commit/49aac9ef63bf11827fca48c16b820ee1c3fe327f"}], "stats": {"total": 222, "additions": 114, "deletions": 108}, "files": [{"sha": "d9ce6bcff6df62c72f4d258b2fe51724844c7bbe", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=0f212b379811dcb26cde3eba160e07a11182fc5a", "patch": "@@ -17,7 +17,8 @@ use rustc_hash::FxHashMap;\n use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n-    nameres::{BuiltinShadowMode, CrateDefMap},\n+    item_scope::BuiltinShadowMode,\n+    nameres::CrateDefMap,\n     path::{ModPath, Path},\n     src::HasSource,\n     DefWithBodyId, HasModule, Lookup, ModuleDefId, ModuleId,"}, {"sha": "62e7a02cb4f661cbfc6e24d5eedbc06a5e3a4183", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=0f212b379811dcb26cde3eba160e07a11182fc5a", "patch": "@@ -1 +1,106 @@\n+use hir_expand::name::Name;\n+use once_cell::sync::Lazy;\n+use rustc_hash::FxHashMap;\n \n+use crate::{per_ns::PerNs, BuiltinType, LocalImportId, MacroDefId, ModuleDefId, TraitId};\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ModuleScope {\n+    pub(crate) items: FxHashMap<Name, Resolution>,\n+    /// Macros visable in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n+    pub(crate) legacy_macros: FxHashMap<Name, MacroDefId>,\n+}\n+\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n+    BuiltinType::ALL\n+        .iter()\n+        .map(|(name, ty)| {\n+            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n+        })\n+        .collect()\n+});\n+\n+/// Shadow mode for builtin type which can be shadowed by module.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum BuiltinShadowMode {\n+    // Prefer Module\n+    Module,\n+    // Prefer Other Types\n+    Other,\n+}\n+\n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n+impl ModuleScope {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n+        //FIXME: shadowing\n+        self.items.iter().chain(BUILTIN_SCOPE.iter())\n+    }\n+\n+    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n+        self.entries()\n+            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n+            .flat_map(|per_ns| {\n+                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n+            })\n+    }\n+\n+    /// Iterate over all module scoped macros\n+    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.items\n+            .iter()\n+            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visable at the end of the module\n+    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n+    pub fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n+        match shadow {\n+            BuiltinShadowMode::Module => self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n+            BuiltinShadowMode::Other => {\n+                let item = self.items.get(name);\n+                if let Some(res) = item {\n+                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n+                        return BUILTIN_SCOPE.get(name).or(item);\n+                    }\n+                }\n+\n+                item.or_else(|| BUILTIN_SCOPE.get(name))\n+            }\n+        }\n+    }\n+\n+    pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDefId::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n+\n+    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n+        self.legacy_macros.get(name).copied()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+pub struct Resolution {\n+    /// None for unresolved\n+    pub def: PerNs,\n+    /// ident by which this is imported into local scope.\n+    pub import: Option<LocalImportId>,\n+}"}, {"sha": "0b486ce163156386f53b3dd711629036ef9fd21c", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 3, "deletions": 105, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=0f212b379811dcb26cde3eba160e07a11182fc5a", "patch": "@@ -57,8 +57,7 @@ mod tests;\n \n use std::sync::Arc;\n \n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile, MacroDefId};\n-use once_cell::sync::Lazy;\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n use ra_arena::Arena;\n use ra_db::{CrateId, Edition, FileId, FilePosition};\n use ra_prof::profile;\n@@ -69,12 +68,12 @@ use ra_syntax::{\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    builtin_type::BuiltinType,\n     db::DefDatabase,\n+    item_scope::{BuiltinShadowMode, ModuleScope},\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::ModPath,\n     per_ns::PerNs,\n-    AstId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n+    AstId, ImplId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -174,107 +173,6 @@ pub struct ModuleData {\n     pub impls: Vec<ImplId>,\n }\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n-    /// Macros visable in current module in legacy textual scope\n-    ///\n-    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n-    /// If it yields no result, then it turns to module scoped `macros`.\n-    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n-    /// and only normal scoped `macros` will be searched in.\n-    ///\n-    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n-    ///\n-    /// Module scoped macros will be inserted into `items` instead of here.\n-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n-    // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroDefId>,\n-}\n-\n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n-    BuiltinType::ALL\n-        .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n-        })\n-        .collect()\n-});\n-\n-/// Shadow mode for builtin type which can be shadowed by module.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum BuiltinShadowMode {\n-    // Prefer Module\n-    Module,\n-    // Prefer Other Types\n-    Other,\n-}\n-\n-/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n-/// Other methods will only resolve values, types and module scoped macros only.\n-impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n-        //FIXME: shadowing\n-        self.items.iter().chain(BUILTIN_SCOPE.iter())\n-    }\n-\n-    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n-        self.entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n-    }\n-\n-    /// Iterate over all module scoped macros\n-    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.items\n-            .iter()\n-            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n-    }\n-\n-    /// Iterate over all legacy textual scoped macros visable at the end of the module\n-    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n-    }\n-\n-    /// Get a name from current module scope, legacy macros are not included\n-    pub fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n-        match shadow {\n-            BuiltinShadowMode::Module => self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n-            BuiltinShadowMode::Other => {\n-                let item = self.items.get(name);\n-                if let Some(res) = item {\n-                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n-                        return BUILTIN_SCOPE.get(name).or(item);\n-                    }\n-                }\n-\n-                item.or_else(|| BUILTIN_SCOPE.get(name))\n-            }\n-        }\n-    }\n-\n-    pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.items.values().filter_map(|r| match r.def.take_types() {\n-            Some(ModuleDefId::TraitId(t)) => Some(t),\n-            _ => None,\n-        })\n-    }\n-\n-    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n-        self.legacy_macros.get(name).copied()\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<LocalImportId>,\n-}\n-\n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(\n         // Note that this doesn't have `+ AstDatabase`!"}, {"sha": "ea6ce5f97b8e332d8d0a8d00b0e4fcd6152b175c", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0f212b379811dcb26cde3eba160e07a11182fc5a", "patch": "@@ -18,9 +18,10 @@ use test_utils::tested_by;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n+    item_scope::Resolution,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, Resolution, ResolveMode,\n+        raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ModPath, PathKind},\n     per_ns::PerNs,"}, {"sha": "83013fed3d5b61cf0480bf77ccd0851eeb45222f", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f212b379811dcb26cde3eba160e07a11182fc5a/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=0f212b379811dcb26cde3eba160e07a11182fc5a", "patch": "@@ -14,7 +14,8 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n-    nameres::{BuiltinShadowMode, CrateDefMap},\n+    item_scope::BuiltinShadowMode,\n+    nameres::CrateDefMap,\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,"}]}