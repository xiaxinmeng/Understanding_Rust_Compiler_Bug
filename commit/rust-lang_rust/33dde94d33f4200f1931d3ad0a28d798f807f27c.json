{"sha": "33dde94d33f4200f1931d3ad0a28d798f807f27c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZGRlOTRkMzNmNDIwMGYxOTMxZDNhZDBhMjhkNzk4ZjgwN2YyN2M=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-27T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-27T21:55:53Z"}, "message": "liveness: Inline visitor implementation for IrMaps", "tree": {"sha": "b9425c166efc86a8de03c35f502661363e212c76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9425c166efc86a8de03c35f502661363e212c76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33dde94d33f4200f1931d3ad0a28d798f807f27c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33dde94d33f4200f1931d3ad0a28d798f807f27c", "html_url": "https://github.com/rust-lang/rust/commit/33dde94d33f4200f1931d3ad0a28d798f807f27c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33dde94d33f4200f1931d3ad0a28d798f807f27c/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "536b51aca016b4744596f16a2e502b76e9490664", "url": "https://api.github.com/repos/rust-lang/rust/commits/536b51aca016b4744596f16a2e502b76e9490664", "html_url": "https://github.com/rust-lang/rust/commit/536b51aca016b4744596f16a2e502b76e9490664"}], "stats": {"total": 374, "additions": 175, "deletions": 199}, "files": [{"sha": "eb2f40a82d1f1600c86323636dc3472f32c621c7", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 175, "deletions": 199, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/33dde94d33f4200f1931d3ad0a28d798f807f27c/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33dde94d33f4200f1931d3ad0a28d798f807f27c/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=33dde94d33f4200f1931d3ad0a28d798f807f27c", "patch": "@@ -138,38 +138,6 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.tcx.hir())\n-    }\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: FnKind<'tcx>,\n-        fd: &'tcx hir::FnDecl<'tcx>,\n-        b: hir::BodyId,\n-        s: Span,\n-        id: HirId,\n-    ) {\n-        visit_fn(self, fk, fd, b, s, id);\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        visit_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        visit_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        visit_arm(self, a);\n-    }\n-    fn visit_param(&mut self, p: &'tcx hir::Param<'tcx>) {\n-        visit_param(self, p);\n-    }\n-}\n-\n fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx).as_deep_visitor());\n }\n@@ -300,196 +268,204 @@ impl IrMaps<'tcx> {\n     fn set_captures(&mut self, hir_id: HirId, cs: Vec<CaptureInfo>) {\n         self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n-}\n \n-fn visit_fn<'tcx>(\n-    ir: &mut IrMaps<'tcx>,\n-    fk: FnKind<'tcx>,\n-    decl: &'tcx hir::FnDecl<'tcx>,\n-    body_id: hir::BodyId,\n-    sp: Span,\n-    id: hir::HirId,\n-) {\n-    debug!(\"visit_fn {:?}\", id);\n-\n-    // swap in a new set of IR maps for this function body:\n-    let def_id = ir.tcx.hir().local_def_id(id);\n-    let mut fn_maps = IrMaps::new(ir.tcx);\n-\n-    // Don't run unused pass for #[derive()]\n-    if let FnKind::Method(..) = fk {\n-        let parent = ir.tcx.hir().get_parent_item(id);\n-        if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n-            if i.attrs.iter().any(|a| ir.tcx.sess.check_name(a, sym::automatically_derived)) {\n-                return;\n+    fn add_from_pat(&mut self, pat: &hir::Pat<'tcx>) {\n+        // For struct patterns, take note of which fields used shorthand\n+        // (`x` rather than `x: x`).\n+        let mut shorthand_field_ids = HirIdSet::default();\n+        let mut pats = VecDeque::new();\n+        pats.push_back(pat);\n+        while let Some(pat) = pats.pop_front() {\n+            use rustc_hir::PatKind::*;\n+            match &pat.kind {\n+                Binding(.., inner_pat) => {\n+                    pats.extend(inner_pat.iter());\n+                }\n+                Struct(_, fields, _) => {\n+                    let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n+                    shorthand_field_ids.extend(ids);\n+                }\n+                Ref(inner_pat, _) | Box(inner_pat) => {\n+                    pats.push_back(inner_pat);\n+                }\n+                TupleStruct(_, inner_pats, _) | Tuple(inner_pats, _) | Or(inner_pats) => {\n+                    pats.extend(inner_pats.iter());\n+                }\n+                Slice(pre_pats, inner_pat, post_pats) => {\n+                    pats.extend(pre_pats.iter());\n+                    pats.extend(inner_pat.iter());\n+                    pats.extend(post_pats.iter());\n+                }\n+                _ => {}\n             }\n         }\n-    }\n \n-    debug!(\"creating fn_maps: {:p}\", &fn_maps);\n+        pat.each_binding(|_, hir_id, _, ident| {\n+            self.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n+            self.add_variable(Local(LocalInfo {\n+                id: hir_id,\n+                name: ident.name,\n+                is_shorthand: shorthand_field_ids.contains(&hir_id),\n+            }));\n+        });\n+    }\n+}\n \n-    let body = ir.tcx.hir().body(body_id);\n+impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n+    type Map = Map<'tcx>;\n \n-    if let Some(upvars) = ir.tcx.upvars_mentioned(def_id) {\n-        for (&var_hir_id, _upvar) in upvars {\n-            let var_name = ir.tcx.hir().name(var_hir_id);\n-            fn_maps.add_variable(Upvar(var_hir_id, var_name));\n-        }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.tcx.hir())\n     }\n \n-    // gather up the various local variables, significant expressions,\n-    // and so forth:\n-    intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n+    fn visit_fn(\n+        &mut self,\n+        fk: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        sp: Span,\n+        id: HirId,\n+    ) {\n+        debug!(\"visit_fn {:?}\", id);\n+\n+        // swap in a new set of IR maps for this function body:\n+        let def_id = self.tcx.hir().local_def_id(id);\n+        let mut fn_maps = IrMaps::new(self.tcx);\n+\n+        // Don't run unused pass for #[derive()]\n+        if let FnKind::Method(..) = fk {\n+            let parent = self.tcx.hir().get_parent_item(id);\n+            if let Some(Node::Item(i)) = self.tcx.hir().find(parent) {\n+                if i.attrs.iter().any(|a| self.tcx.sess.check_name(a, sym::automatically_derived)) {\n+                    return;\n+                }\n+            }\n+        }\n \n-    // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n-    let entry_ln = lsets.compute(&body, sp, id);\n-    lsets.log_liveness(entry_ln, id);\n+        debug!(\"creating fn_maps: {:p}\", &fn_maps);\n \n-    // check for various error conditions\n-    lsets.visit_body(body);\n-    lsets.warn_about_unused_upvars(entry_ln);\n-    lsets.warn_about_unused_args(body, entry_ln);\n-}\n+        let body = self.tcx.hir().body(body_id);\n \n-fn add_from_pat(ir: &mut IrMaps<'_>, pat: &hir::Pat<'_>) {\n-    // For struct patterns, take note of which fields used shorthand\n-    // (`x` rather than `x: x`).\n-    let mut shorthand_field_ids = HirIdSet::default();\n-    let mut pats = VecDeque::new();\n-    pats.push_back(pat);\n-    while let Some(pat) = pats.pop_front() {\n-        use rustc_hir::PatKind::*;\n-        match &pat.kind {\n-            Binding(.., inner_pat) => {\n-                pats.extend(inner_pat.iter());\n-            }\n-            Struct(_, fields, _) => {\n-                let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n-                shorthand_field_ids.extend(ids);\n-            }\n-            Ref(inner_pat, _) | Box(inner_pat) => {\n-                pats.push_back(inner_pat);\n+        if let Some(upvars) = self.tcx.upvars_mentioned(def_id) {\n+            for (&var_hir_id, _upvar) in upvars {\n+                let var_name = self.tcx.hir().name(var_hir_id);\n+                fn_maps.add_variable(Upvar(var_hir_id, var_name));\n             }\n-            TupleStruct(_, inner_pats, _) | Tuple(inner_pats, _) | Or(inner_pats) => {\n-                pats.extend(inner_pats.iter());\n-            }\n-            Slice(pre_pats, inner_pat, post_pats) => {\n-                pats.extend(pre_pats.iter());\n-                pats.extend(inner_pat.iter());\n-                pats.extend(post_pats.iter());\n-            }\n-            _ => {}\n         }\n-    }\n \n-    pat.each_binding(|_, hir_id, _, ident| {\n-        ir.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n-        ir.add_variable(Local(LocalInfo {\n-            id: hir_id,\n-            name: ident.name,\n-            is_shorthand: shorthand_field_ids.contains(&hir_id),\n-        }));\n-    });\n-}\n+        // gather up the various local variables, significant expressions,\n+        // and so forth:\n+        intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n-fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local<'tcx>) {\n-    add_from_pat(ir, &local.pat);\n-    intravisit::walk_local(ir, local);\n-}\n+        // compute liveness\n+        let mut lsets = Liveness::new(&mut fn_maps, def_id);\n+        let entry_ln = lsets.compute(&body, sp, id);\n+        lsets.log_liveness(entry_ln, id);\n \n-fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n-    add_from_pat(ir, &arm.pat);\n-    intravisit::walk_arm(ir, arm);\n-}\n+        // check for various error conditions\n+        lsets.visit_body(body);\n+        lsets.warn_about_unused_upvars(entry_ln);\n+        lsets.warn_about_unused_args(body, entry_ln);\n+    }\n \n-fn visit_param<'tcx>(ir: &mut IrMaps<'tcx>, param: &'tcx hir::Param<'tcx>) {\n-    let is_shorthand = match param.pat.kind {\n-        rustc_hir::PatKind::Struct(..) => true,\n-        _ => false,\n-    };\n-    param.pat.each_binding(|_bm, hir_id, _x, ident| {\n-        let var = if is_shorthand {\n-            Local(LocalInfo { id: hir_id, name: ident.name, is_shorthand: true })\n-        } else {\n-            Param(hir_id, ident.name)\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n+        self.add_from_pat(&local.pat);\n+        intravisit::walk_local(self, local);\n+    }\n+\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n+        self.add_from_pat(&arm.pat);\n+        intravisit::walk_arm(self, arm);\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        let is_shorthand = match param.pat.kind {\n+            rustc_hir::PatKind::Struct(..) => true,\n+            _ => false,\n         };\n-        ir.add_variable(var);\n-    });\n-    intravisit::walk_param(ir, param);\n-}\n+        param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+            let var = if is_shorthand {\n+                Local(LocalInfo { id: hir_id, name: ident.name, is_shorthand: true })\n+            } else {\n+                Param(hir_id, ident.name)\n+            };\n+            self.add_variable(var);\n+        });\n+        intravisit::walk_param(self, param);\n+    }\n \n-fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    match expr.kind {\n-        // live nodes required for uses or definitions of variables:\n-        hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-            debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n-            if let Res::Local(_var_hir_id) = path.res {\n-                ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        match expr.kind {\n+            // live nodes required for uses or definitions of variables:\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n+                if let Res::Local(_var_hir_id) = path.res {\n+                    self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                }\n+                intravisit::walk_expr(self, expr);\n             }\n-            intravisit::walk_expr(ir, expr);\n-        }\n-        hir::ExprKind::Closure(..) => {\n-            // Interesting control flow (for loops can contain labeled\n-            // breaks or continues)\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-\n-            // Make a live_node for each captured variable, with the span\n-            // being the location that the variable is used.  This results\n-            // in better error messages than just pointing at the closure\n-            // construction site.\n-            let mut call_caps = Vec::new();\n-            let closure_def_id = ir.tcx.hir().local_def_id(expr.hir_id);\n-            if let Some(upvars) = ir.tcx.upvars_mentioned(closure_def_id) {\n-                call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n-                    let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n-                    CaptureInfo { ln: upvar_ln, var_hid: var_id }\n-                }));\n+            hir::ExprKind::Closure(..) => {\n+                // Interesting control flow (for loops can contain labeled\n+                // breaks or continues)\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+\n+                // Make a live_node for each captured variable, with the span\n+                // being the location that the variable is used.  This results\n+                // in better error messages than just pointing at the closure\n+                // construction site.\n+                let mut call_caps = Vec::new();\n+                let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n+                if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                    call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n+                        let upvar_ln = self.add_live_node(UpvarNode(upvar.span));\n+                        CaptureInfo { ln: upvar_ln, var_hid: var_id }\n+                    }));\n+                }\n+                self.set_captures(expr.hir_id, call_caps);\n+                intravisit::walk_expr(self, expr);\n             }\n-            ir.set_captures(expr.hir_id, call_caps);\n-            intravisit::walk_expr(ir, expr);\n-        }\n \n-        // live nodes required for interesting control flow:\n-        hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-            intravisit::walk_expr(ir, expr);\n-        }\n-        hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-            intravisit::walk_expr(ir, expr);\n-        }\n+            // live nodes required for interesting control flow:\n+            hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                intravisit::walk_expr(self, expr);\n+            }\n+            hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                intravisit::walk_expr(self, expr);\n+            }\n \n-        // otherwise, live nodes are not required:\n-        hir::ExprKind::Index(..)\n-        | hir::ExprKind::Field(..)\n-        | hir::ExprKind::Array(..)\n-        | hir::ExprKind::Call(..)\n-        | hir::ExprKind::MethodCall(..)\n-        | hir::ExprKind::Tup(..)\n-        | hir::ExprKind::Binary(..)\n-        | hir::ExprKind::AddrOf(..)\n-        | hir::ExprKind::Cast(..)\n-        | hir::ExprKind::DropTemps(..)\n-        | hir::ExprKind::Unary(..)\n-        | hir::ExprKind::Break(..)\n-        | hir::ExprKind::Continue(_)\n-        | hir::ExprKind::Lit(_)\n-        | hir::ExprKind::Ret(..)\n-        | hir::ExprKind::Block(..)\n-        | hir::ExprKind::Assign(..)\n-        | hir::ExprKind::AssignOp(..)\n-        | hir::ExprKind::Struct(..)\n-        | hir::ExprKind::Repeat(..)\n-        | hir::ExprKind::InlineAsm(..)\n-        | hir::ExprKind::LlvmInlineAsm(..)\n-        | hir::ExprKind::Box(..)\n-        | hir::ExprKind::Yield(..)\n-        | hir::ExprKind::Type(..)\n-        | hir::ExprKind::Err\n-        | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n-        | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n-            intravisit::walk_expr(ir, expr);\n+            // otherwise, live nodes are not required:\n+            hir::ExprKind::Index(..)\n+            | hir::ExprKind::Field(..)\n+            | hir::ExprKind::Array(..)\n+            | hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            | hir::ExprKind::Tup(..)\n+            | hir::ExprKind::Binary(..)\n+            | hir::ExprKind::AddrOf(..)\n+            | hir::ExprKind::Cast(..)\n+            | hir::ExprKind::DropTemps(..)\n+            | hir::ExprKind::Unary(..)\n+            | hir::ExprKind::Break(..)\n+            | hir::ExprKind::Continue(_)\n+            | hir::ExprKind::Lit(_)\n+            | hir::ExprKind::Ret(..)\n+            | hir::ExprKind::Block(..)\n+            | hir::ExprKind::Assign(..)\n+            | hir::ExprKind::AssignOp(..)\n+            | hir::ExprKind::Struct(..)\n+            | hir::ExprKind::Repeat(..)\n+            | hir::ExprKind::InlineAsm(..)\n+            | hir::ExprKind::LlvmInlineAsm(..)\n+            | hir::ExprKind::Box(..)\n+            | hir::ExprKind::Yield(..)\n+            | hir::ExprKind::Type(..)\n+            | hir::ExprKind::Err\n+            | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n+            | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n+                intravisit::walk_expr(self, expr);\n+            }\n         }\n     }\n }"}]}