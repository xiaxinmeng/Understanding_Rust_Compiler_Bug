{"sha": "d9da43984b5e9d50f711320d2afc3307537dfb44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZGE0Mzk4NGI1ZTlkNTBmNzExMzIwZDJhZmMzMzA3NTM3ZGZiNDQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-06T17:25:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-06T17:25:32Z"}, "message": "Merge branch 'master' of github.com:graydon/rust", "tree": {"sha": "6b9b3eefc8909c7621c01b7e039375deb019e7b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b9b3eefc8909c7621c01b7e039375deb019e7b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9da43984b5e9d50f711320d2afc3307537dfb44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9da43984b5e9d50f711320d2afc3307537dfb44", "html_url": "https://github.com/rust-lang/rust/commit/d9da43984b5e9d50f711320d2afc3307537dfb44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9da43984b5e9d50f711320d2afc3307537dfb44/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f10a5bbad0e169d051ffb05ff58a31438cb8b31b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f10a5bbad0e169d051ffb05ff58a31438cb8b31b", "html_url": "https://github.com/rust-lang/rust/commit/f10a5bbad0e169d051ffb05ff58a31438cb8b31b"}, {"sha": "36d75d6391873b34a1f4e10c34d3d58c54a453c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/36d75d6391873b34a1f4e10c34d3d58c54a453c5", "html_url": "https://github.com/rust-lang/rust/commit/36d75d6391873b34a1f4e10c34d3d58c54a453c5"}], "stats": {"total": 961, "additions": 724, "deletions": 237}, "files": [{"sha": "36e973d69cf7d68c9b14506389cc2895aaa93e11", "filename": "doc/rust.texi", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -120,7 +120,7 @@ table. The task ahead involves combining, trimming, and implementing.\n @end quotation\n @sp 2\n \n-Rust is a curly-brace, block-structured statement language. It visually\n+Rust is a curly-brace, block-structured expression language. It visually\n resembles the C language family, but differs significantly in syntactic and\n semantic details. Its design is oriented toward concerns of ``programming in\n the large'', that is, of creating and maintaining @emph{boundaries} -- both\n@@ -334,7 +334,7 @@ The Rust type system is primarily structural, and contains the standard\n assortment of useful ``algebraic'' type constructors from functional\n languages, such as function types, tuples, record types, vectors, and\n nominally-tagged disjoint unions. Such values may be @emph{pattern-matched} in\n-an @code{alt} statement.\n+an @code{alt} expression.\n \n @sp 1\n @item Generic code\n@@ -394,8 +394,8 @@ the surrounding text by skipping over the bracketed ``extension text''.\n @sp 1\n @item Idempotent failure\n \n-If a task fails due to a signal, or if it executes the special @code{fail}\n-statement, it enters the @emph{failing} state. A failing task unwinds its\n+If a task fails due to a signal, or if it evaluates the special @code{fail}\n+expression, it enters the @emph{failing} state. A failing task unwinds its\n control stack, frees all of its owned resources (executing destructors) and\n enters the @emph{dead} state. Failure is idempotent and non-recoverable.\n \n@@ -1486,8 +1486,8 @@ operating-system processes.\n @cindex Port\n @cindex Channel\n @cindex Message passing\n-@cindex Send statement\n-@cindex Receive statement\n+@cindex Send expression\n+@cindex Receive expression\n \n With the exception of @emph{unsafe} constructs, Rust tasks are isolated from\n interfering with one another's memory directly. Instead of manipulating shared\n@@ -1563,14 +1563,14 @@ A task begins its lifecycle -- once it has been spawned -- in the\n function, and any functions called by the entry function.\n \n A task may transition from the @emph{running} state to the @emph{blocked}\n-state any time it executes a communication statement on a port or channel that\n-cannot be immediately completed.  When the communication statement can be\n+state any time it evaluates a communication expression on a port or channel that\n+cannot be immediately completed.  When the communication expression can be\n completed -- when a message arrives at a sender, or a queue drains\n sufficiently to complete a semi-synchronous send -- then the blocked task will\n unblock and transition back to @emph{running}.\n \n A task may transition to the @emph{failing} state at any time, due to an\n-un-trapped signal or the execution of a @code{fail} statement. Once\n+un-trapped signal or the evaluation of a @code{fail} expression. Once\n @emph{failing}, a task unwinds its stack and transitions to the @emph{dead}\n state. Unwinding the stack of a task is done by the task itself, on its own\n control stack. If a value with a destructor is freed during unwinding, the\n@@ -1804,8 +1804,8 @@ otherwise exactly as a function item (with a minor additional cost of calling\n the function, as such a call is indirect). @xref{Ref.Type.Fn}.\n \n Every control path in a function ends with either a @code{ret} or @code{be}\n-statement. If a control path lacks a @code{ret} statement in source code, an\n-implicit @code{ret} statement is appended to the end of the control path\n+expression. If a control path lacks a @code{ret} expression in source code, an\n+implicit @code{ret} expression is appended to the end of the control path\n during compilation, returning the implicit @code{()} value.\n \n A function may have an @emph{effect}, which may be either @code{impure} or\n@@ -1827,9 +1827,9 @@ fn add(int x, int y) -> int @{\n @c * Ref.Item.Iter::          Items defining iterators.\n \n @cindex Iterators\n-@cindex Put statement\n-@cindex Put each statement\n-@cindex Foreach statement\n+@cindex Put expression\n+@cindex Put each expression\n+@cindex Foreach expression\n \n Iterators are function-like items that can @code{put} multiple values during\n their execution before returning or tail-calling.\n@@ -1841,11 +1841,11 @@ but the iterator frame is only @emph{suspended} during the put, and will be\n the caller's loop.\n \n The output type of an iterator is the type of value that the function will\n-@code{put}, before it eventually executes a @code{ret} or @code{be} statement\n+@code{put}, before it eventually evaluates a @code{ret} or @code{be} expression\n of type @code{()} and completes its execution.\n \n An iterator can only be called in the loop header of a matching @code{for\n-each} loop or as the argument in a @code{put each} statement.\n+each} loop or as the argument in a @code{put each} expression.\n @xref{Ref.Stmt.Foreach}.\n \n An example of an iterator:\n@@ -2052,13 +2052,13 @@ Rust; they cannot be used as user-defined identifiers in any context.\n @cindex Any type\n @cindex Dynamic type, see @i{Any type}\n @cindex Reflection\n-@cindex Alt type statement\n+@cindex Alt type expression\n \n The type @code{any} is the union of all possible Rust types. A value of type\n @code{any} is represented in memory as a pair consisting of a boxed value of\n some non-@code{any} type @var{T} and a reflection of the type @var{T}.\n \n-Values of type @code{any} can be used in an @code{alt type} statement, in\n+Values of type @code{any} can be used in an @code{alt type} expression, in\n which the reflection is used to select a block corresponding to a particular\n type extraction. @xref{Ref.Stmt.Alt}.\n \n@@ -2549,7 +2549,7 @@ right hand side of copy statements, @xref{Ref.Stmt.Copy}.\n @c * Ref.Stmt::               Executable statements.\n @cindex Statements\n \n-A @dfn{statement} is a component of a block, which is in turn a components of\n+A @dfn{statement} is a component of a block, which is in turn a component of\n an outer block, a function or an iterator. When a function is spawned into a\n task, the task @emph{executes} statements in an order determined by the body\n of the enclosing structure. Each statement causes the task to perform certain"}, {"sha": "d41e6d6068684cebf72698fb21e63458f7e19c1d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -188,7 +188,7 @@ fn binop_to_str(binop op) -> str {\n \n \n tag unop {\n-    box;\n+    box(mutability);\n     deref;\n     bitnot;\n     not;\n@@ -197,7 +197,10 @@ tag unop {\n \n fn unop_to_str(unop op) -> str {\n     alt (op) {\n-        case (box) {ret \"@\";}\n+        case (box(?mt)) {\n+            if (mt == mut) { ret \"@mutable\"; }\n+            ret \"@\";\n+        }\n         case (deref) {ret \"*\";}\n         case (bitnot) {ret \"~\";}\n         case (not) {ret \"!\";}\n@@ -255,7 +258,7 @@ tag expr_ {\n     expr_tup(vec[elt], ann);\n     expr_rec(vec[field], option.t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n-    expr_call_self(@expr, vec[@expr], ann);\n+    expr_call_self(ident, vec[@expr], ann);\n     expr_bind(@expr, vec[option.t[@expr]], ann);\n     expr_spawn(spawn_dom, option.t[str], @expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);"}, {"sha": "27fdc7feb2d2f7320deaf1e0c79a1cc10074cb8f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -887,17 +887,19 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         }\n \n         case (token.SELF) {\n+            log \"parsing a self-call...\";\n+\n             p.bump();\n             expect(p, token.DOT);\n             // The rest is a call expression.\n-            auto e = parse_bottom_expr(p);\n+            auto e = parse_ident(p);\n             auto pf = parse_expr;\n             auto es = parse_seq[@ast.expr](token.LPAREN,\n                                            token.RPAREN,\n                                            some(token.COMMA),\n                                            pf, p);\n             hi = es.span;\n-            auto ex = ast.expr_call_self(e, es.node, ast.ann_none);\n+            ex = ast.expr_call_self(e, es.node, ast.ann_none);\n         }\n \n         case (_) {\n@@ -1074,9 +1076,10 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n \n         case (token.AT) {\n             p.bump();\n+            auto m = parse_mutability(p);\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.box, e, ast.ann_none);\n+            ex = ast.expr_unary(ast.box(m), e, ast.ann_none);\n         }\n \n         case (_) {"}, {"sha": "dcfafadf202a57239472748eaab0571695810a30", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -348,6 +348,8 @@ fn to_str(token t) -> str {\n \n         /* Object type */\n         case (OBJ) { ret \"obj\"; }\n+        case (SELF) { ret \"self\"; }\n+\n \n         /* Comm and task types */\n         case (CHAN) { ret \"chan\"; }"}, {"sha": "77c898366afdec172f778119fe04923ffbf396f1", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -88,7 +88,7 @@ type ast_fold[ENV] =\n          ann a) -> @expr)                         fold_expr_call,\n \n      (fn(&ENV e, &span sp,\n-         @expr f, vec[@expr] args,\n+         ident id, vec[@expr] args,\n          ann a) -> @expr)                         fold_expr_call_self,\n \n      (fn(&ENV e, &span sp,\n@@ -566,10 +566,9 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_call(env_, e.span, ff, aargs, t);\n         }\n \n-        case (ast.expr_call_self(?f, ?args, ?t)) {\n-            auto ff = fold_expr(env_, fld, f);\n+        case (ast.expr_call_self(?ident, ?args, ?t)) {\n             auto aargs = fold_exprs(env_, fld, args);\n-            ret fld.fold_expr_call_self(env_, e.span, ff, aargs, t);\n+            ret fld.fold_expr_call_self(env_, e.span, ident, aargs, t);\n         }\n \n         case (ast.expr_bind(?f, ?args_opt, ?t)) {\n@@ -1185,9 +1184,9 @@ fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n     ret @respan(sp, ast.expr_call(f, args, a));\n }\n \n-fn identity_fold_expr_call_self[ENV](&ENV env, &span sp, @expr f,\n+fn identity_fold_expr_call_self[ENV](&ENV env, &span sp, ident id,\n                                 vec[@expr] args, ann a) -> @expr {\n-    ret @respan(sp, ast.expr_call_self(f, args, a));\n+    ret @respan(sp, ast.expr_call_self(id, args, a));\n }\n \n fn identity_fold_expr_bind[ENV](&ENV env, &span sp, @expr f,"}, {"sha": "322796a49072553e4cda729d91f31e1956bf2674", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 129, "deletions": 118, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -12,11 +12,14 @@ import std.option.none;\n \n import front.ast;\n import front.creader;\n+import pretty.pprust;\n import driver.session;\n import middle.ty;\n import back.x86;\n import back.abi;\n \n+import pretty.pprust;\n+\n import middle.ty.pat_ty;\n import middle.ty.plain_ty;\n \n@@ -112,12 +115,14 @@ state type crate_ctxt = rec(session.session sess,\n                             vec[str] path,\n                             std.sha1.sha1 sha);\n \n+type self_vt = rec(ValueRef v, @ty.t t);\n+\n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n                          ValueRef llenv,\n                          ValueRef llretptr,\n                          mutable BasicBlockRef llallocas,\n-                         mutable option.t[ValueRef] llself,\n+                         mutable option.t[self_vt] llself,\n                          mutable option.t[ValueRef] lliterbody,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n@@ -1424,7 +1429,7 @@ fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n     auto boxed_body = ty.plain_tup_ty(vec(plain_ty(ty.ty_int), t));\n-    auto box_ptr = ty.plain_box_ty(t);\n+    auto box_ptr = ty.plain_box_ty(t, ast.imm);\n     auto sz = size_of(cx, boxed_body);\n     auto llty = type_of(cx.fcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n@@ -2005,7 +2010,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n         auto tnil = plain_ty(ty.ty_nil);\n-        auto tbox = ty.plain_box_ty(tnil);\n+        auto tbox = ty.plain_box_ty(tnil, ast.imm);\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2557,7 +2562,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n                 ret res(sub.bcx, sub.bcx.build.Neg(sub.val));\n             }\n         }\n-        case (ast.box) {\n+        case (ast.box(_)) {\n             auto e_ty = ty.expr_ty(e);\n             auto e_val = sub.val;\n             auto box_ty = node_ann_type(sub.bcx.fcx.ccx, a);\n@@ -3600,20 +3605,23 @@ type generic_info = rec(@ty.t item_type,\n type lval_result = rec(result res,\n                        bool is_mem,\n                        option.t[generic_info] generic,\n-                       option.t[ValueRef] llobj);\n+                       option.t[ValueRef] llobj,\n+                       option.t[@ty.t] method_ty);\n \n fn lval_mem(@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n             is_mem=true,\n             generic=none[generic_info],\n-            llobj=none[ValueRef]);\n+            llobj=none[ValueRef],\n+            method_ty=none[@ty.t]);\n }\n \n fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n             is_mem=false,\n             generic=none[generic_info],\n-            llobj=none[ValueRef]);\n+            llobj=none[ValueRef],\n+            method_ty=none[@ty.t]);\n }\n \n fn trans_external_path(@block_ctxt cx, ast.def_id did,\n@@ -3781,12 +3789,12 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n     fail;\n }\n \n-fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n+fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n-    auto r = trans_expr(cx, base);\n-    auto t = ty.expr_ty(base);\n-    r = autoderef(r.bcx, r.val, t);\n-    t = autoderefed_ty(t);\n+\n+    auto r = autoderef(cx, v, t0);\n+    auto t = autoderefed_ty(t0);\n+\n     alt (t.struct) {\n         case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n@@ -3808,7 +3816,10 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                                                 C_int(ix as int)));\n \n             auto lvo = lval_mem(r.bcx, v);\n-            ret rec(llobj = some[ValueRef](r.val) with lvo);\n+            let @ty.t fn_ty = ty.method_ty_to_fn_ty(methods.(ix));\n+            ret rec(llobj = some[ValueRef](r.val),\n+                    method_ty = some[@ty.t](fn_ty)\n+                    with lvo);\n         }\n         case (_) { cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\"); }\n     }\n@@ -3879,11 +3890,30 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n             ret trans_path(cx, p, dopt, ann);\n         }\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n-            ret trans_field(cx, e.span, base, ident, ann);\n+            auto r = trans_expr(cx, base);\n+            auto t = ty.expr_ty(base);\n+            ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n         }\n         case (ast.expr_index(?base, ?idx, ?ann)) {\n             ret trans_index(cx, e.span, base, idx, ann);\n         }\n+\n+        // Kind of bizarre to pass an *entire* self-call here...but let's try\n+        // it\n+        case (ast.expr_call_self(?ident, _, ?ann)) {\n+            alt (cx.fcx.llself) {\n+                case (some[self_vt](?s_vt)) {\n+                    auto r =  s_vt.v;\n+                    auto t =  s_vt.t;\n+                    ret trans_field(cx, e.span, r, t, ident, ann);\n+                }\n+                case (_) {\n+                    // Shouldn't happen.\n+                    fail;\n+                }\n+\n+            }\n+        }\n         case (_) { cx.fcx.ccx.sess.unimpl(\"expr variant in trans_lval\"); }\n     }\n     fail;\n@@ -3943,7 +3973,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto llclosure_ptr_ty = type_of(cx, ty.plain_box_ty(closure_ty));\n+    auto llclosure_ptr_ty = type_of(cx, ty.plain_box_ty(closure_ty, ast.imm));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4379,6 +4409,9 @@ fn trans_args(@block_ctxt cx,\n                 }\n             }\n \n+            val = bcx.build.PointerCast(val, lldestty);\n+        } else if (mode == ast.alias) {\n+            auto lldestty = arg_tys.(i);\n             val = bcx.build.PointerCast(val, lldestty);\n         }\n \n@@ -4402,6 +4435,11 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n               option.t[ValueRef] lliterbody,\n               vec[@ast.expr] args,\n               &ast.ann ann) -> result {\n+\n+    // NB: 'f' isn't necessarily a function; it might be an entire self-call\n+    // expression because of the hack that allows us to process self-calls\n+    // with trans_call.\n+\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n     auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.ccx.tn));\n@@ -4425,71 +4463,21 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n             llenv = bcx.build.Load(llclosure);\n         }\n     }\n-    auto fn_ty = ty.expr_ty(f);\n-    auto ret_ty = ty.ann_to_type(ann);\n-    auto args_res = trans_args(f_res.res.bcx,\n-                               llenv, f_res.llobj,\n-                               f_res.generic,\n-                               lliterbody,\n-                               args, fn_ty);\n-\n-    auto bcx = args_res._0;\n-    auto llargs = args_res._1;\n-    auto llretslot = args_res._2;\n-\n-    /*\n-    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n-\n-    for (ValueRef arg in llargs) {\n-        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n-    }\n-    */\n-\n-    bcx.build.FastCall(faddr, llargs);\n-    auto retval = C_nil();\n-\n-    if (!ty.type_is_nil(ret_ty)) {\n-        retval = load_scalar_or_boxed(bcx, llretslot, ret_ty);\n-        // Retval doesn't correspond to anything really tangible in the frame,\n-        // but it's a ref all the same, so we put a note here to drop it when\n-        // we're done in this scope.\n-        find_scope_cx(cx).cleanups +=\n-            vec(clean(bind drop_ty(_, retval, ret_ty)));\n-    }\n-\n-    ret res(bcx, retval);\n-}\n-\n-fn trans_call_self(@block_ctxt cx, @ast.expr f,\n-                   option.t[ValueRef] lliterbody,\n-                   vec[@ast.expr] args,\n-                   &ast.ann ann) -> result {\n-    log \"translating a self-call\";\n-\n-    auto f_res = trans_lval(cx, f);\n-    auto faddr = f_res.res.val;\n-    auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.ccx.tn));\n \n-    alt (f_res.llobj) {\n-        case (some[ValueRef](_)) {\n-            // It's a vtbl entry.\n-            faddr = f_res.res.bcx.build.Load(faddr);\n+    let @ty.t fn_ty;\n+    alt (f_res.method_ty) {\n+        case (some[@ty.t](?meth)) {\n+            // self-call\n+            fn_ty = meth;\n         }\n-        case (none[ValueRef]) {\n-            // It's a closure.\n-            auto bcx = f_res.res.bcx;\n-            auto pair = faddr;\n-            faddr = bcx.build.GEP(pair, vec(C_int(0),\n-                                            C_int(abi.fn_field_code)));\n-            faddr = bcx.build.Load(faddr);\n+        \n+        case (_) {\n+            fn_ty = ty.expr_ty(f);\n \n-            auto llclosure = bcx.build.GEP(pair,\n-                                           vec(C_int(0),\n-                                               C_int(abi.fn_field_box)));\n-            llenv = bcx.build.Load(llclosure);\n         }\n+\n     }\n-    auto fn_ty = ty.expr_ty(f);\n+\n     auto ret_ty = ty.ann_to_type(ann);\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n@@ -4760,8 +4748,9 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_call(cx, f, none[ValueRef], args, ann);\n         }\n \n-        case (ast.expr_call_self(?f, ?args, ?ann)) {\n-            ret trans_call_self(cx, f, none[ValueRef], args, ann);\n+        case (ast.expr_call_self(?ident, ?args, ?ann)) {\n+            // A weird hack to make self-calls work.\n+            ret trans_call(cx, e, none[ValueRef], args, ann);\n         }\n \n         case (ast.expr_cast(?e, _, ?ann)) {\n@@ -4913,8 +4902,7 @@ fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n-    // FIXME: need pretty-printer.\n-    auto expr_str = \"<expr>\";\n+    auto expr_str = pretty.pprust.expr_to_str(e);\n     auto fail_cx = new_sub_block_ctxt(cx, \"fail\");\n     auto fail_res = trans_fail(fail_cx, e.span, expr_str);\n \n@@ -5472,7 +5460,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              llenv=llenv,\n              llretptr=llretptr,\n              mutable llallocas = llallocas,\n-             mutable llself=none[ValueRef],\n+             mutable llself=none[self_vt],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n              llobjfields=llobjfields,\n@@ -5491,27 +5479,24 @@ fn new_fn_ctxt(@crate_ctxt cx,\n \n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              ast.proto proto,\n-                             option.t[TypeRef] ty_self,\n+                             option.t[tup(TypeRef, @ty.t)] ty_self,\n                              @ty.t ret_ty,\n                              &vec[ast.arg] args,\n                              &vec[ast.ty_param] ty_params) {\n \n-    alt (ty_self) {\n-        case (some[TypeRef](_)) {\n-            cx.llself = some[ValueRef](cx.llenv);\n-        }\n-        case (_) {\n-        }\n-    }\n-\n     auto arg_n = 3u;\n \n-    if (ty_self == none[TypeRef]) {\n-        for (ast.ty_param tp in ty_params) {\n-            auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-            check (llarg as int != 0);\n-            cx.lltydescs.insert(tp.id, llarg);\n-            arg_n += 1u;\n+    alt (ty_self) {\n+        case (some[tup(TypeRef, @ty.t)](?tt)) {\n+            cx.llself = some[self_vt](rec(v = cx.llenv, t = tt._1));\n+        }\n+        case (none[tup(TypeRef, @ty.t)]) {\n+            for (ast.ty_param tp in ty_params) {\n+                auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n+                check (llarg as int != 0);\n+                cx.lltydescs.insert(tp.id, llarg);\n+                arg_n += 1u;\n+            }\n         }\n     }\n \n@@ -5535,17 +5520,17 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n fn copy_any_self_to_alloca(@fn_ctxt fcx,\n-                           option.t[TypeRef] ty_self) {\n+                           option.t[tup(TypeRef, @ty.t)] ty_self) {\n \n     auto bcx = llallocas_block_ctxt(fcx);\n \n     alt (fcx.llself) {\n-        case (some[ValueRef](?self_v)) {\n+        case (some[self_vt](?s_vt)) {\n             alt (ty_self) {\n-                case (some[TypeRef](?self_t)) {\n-                    auto a = alloca(bcx, self_t);\n-                    bcx.build.Store(self_v, a);\n-                    fcx.llself = some[ValueRef](a);\n+                case (some[tup(TypeRef, @ty.t)](?tt)) {\n+                    auto a = alloca(bcx, tt._0);\n+                    bcx.build.Store(s_vt.v, a);\n+                    fcx.llself = some[self_vt](rec(v = a, t = s_vt.t));\n                 }\n             }\n         }\n@@ -5607,7 +5592,7 @@ fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n     ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n }\n \n-fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n+fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     auto bcx = llallocas_block_ctxt(fcx);\n \n     let vec[@ty.t] field_tys = vec();\n@@ -5624,7 +5609,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.ccx.tn, n_typarams);\n \n     auto box_cell =\n-        bcx.build.GEP(llself,\n+        bcx.build.GEP(llself.v,\n                       vec(C_int(0),\n                           C_int(abi.obj_field_box)));\n \n@@ -5677,7 +5662,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n }\n \n fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n-            option.t[TypeRef] ty_self,\n+            option.t[tup(TypeRef, @ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llfndecl = cx.item_ids.get(fid);\n@@ -5690,7 +5675,7 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     copy_any_self_to_alloca(fcx, ty_self);\n \n     alt (fcx.llself) {\n-        case (some[ValueRef](?llself)) {\n+        case (some[self_vt](?llself)) {\n             populate_fn_ctxt_from_llself(fcx, llself);\n         }\n         case (_) {\n@@ -5713,7 +5698,9 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n+fn trans_vtbl(@crate_ctxt cx, \n+              TypeRef llself_ty,\n+              @ty.t self_ty,\n               &ast._obj ob,\n               &vec[ast.ty_param] ty_params) -> ValueRef {\n     let vec[ValueRef] methods = vec();\n@@ -5731,7 +5718,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n         alt (node_ann_type(cx, m.node.ann).struct) {\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx, proto,\n-                                         some[TypeRef](self_ty),\n+                                         some[TypeRef](llself_ty),\n                                          inputs, output,\n                                          _vec.len[ast.ty_param](ty_params));\n             }\n@@ -5743,7 +5730,8 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n         cx.item_ids.insert(m.node.id, llfn);\n         cx.item_symbols.insert(m.node.id, s);\n \n-        trans_fn(mcx, m.node.meth, m.node.id, some[TypeRef](self_ty),\n+        trans_fn(mcx, m.node.meth, m.node.id, \n+                 some[tup(TypeRef, @ty.t)](tup(llself_ty, self_ty)),\n                  ty_params, m.node.ann);\n         methods += vec(llfn);\n     }\n@@ -5774,7 +5762,8 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[TypeRef], ret_ty_of_fn(ann),\n+                              none[tup(TypeRef, @ty.t)], \n+                              ret_ty_of_fn(ann),\n                               fn_args, ty_params);\n \n     let vec[ty.arg] arg_tys = arg_tys_of_fn(ann);\n@@ -5783,9 +5772,10 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto llself_ty = type_of(cx, ret_ty_of_fn(ann));\n+    auto self_ty = ret_ty_of_fn(ann);\n+    auto llself_ty = type_of(cx, self_ty);\n     auto pair = bcx.fcx.llretptr;\n-    auto vtbl = trans_vtbl(cx, llself_ty, ob, ty_params);\n+    auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    vec(C_int(0),\n                                        C_int(abi.obj_field_vtbl)));\n@@ -5819,7 +5809,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         let @ty.t body_ty = ty.plain_tup_ty(vec(tydesc_ty,\n                                                 typarams_ty,\n                                                 fields_ty));\n-        let @ty.t boxed_body_ty = ty.plain_box_ty(body_ty);\n+        let @ty.t boxed_body_ty = ty.plain_box_ty(body_ty, ast.imm);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -5906,7 +5896,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     auto fcx = new_fn_ctxt(cx, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[TypeRef], ret_ty_of_fn(variant.node.ann),\n+                              none[tup(TypeRef, @ty.t)], \n+                              ret_ty_of_fn(variant.node.ann),\n                               fn_args, ty_params);\n \n     let vec[@ty.t] ty_param_substs = vec();\n@@ -5994,7 +5985,7 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = extend_path(cx, name);\n-            trans_fn(sub_cx, f, fid, none[TypeRef], tps, ann);\n+            trans_fn(sub_cx, f, fid, none[tup(TypeRef, @ty.t)], tps, ann);\n         }\n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             auto sub_cx = @rec(obj_typarams=tps,\n@@ -6147,15 +6138,15 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     auto arg_n = 3u;\n     auto pass_task;\n \n-    auto lltaskptr = bcx.build.PtrToInt(fcx.lltaskptr, T_int());\n+    auto lltaskptr = vp2i(bcx, fcx.lltaskptr);\n     alt (abi) {\n         case (ast.native_abi_rust) {\n             pass_task = true;\n             call_args += vec(lltaskptr);\n             for each (uint i in _uint.range(0u, num_ty_param)) {\n                 auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n                 check (llarg as int != 0);\n-                call_args += vec(bcx.build.PointerCast(llarg, T_i32()));\n+                call_args += vec(vp2i(bcx, llarg));\n                 arg_n += 1u;\n             }\n         }\n@@ -6168,6 +6159,26 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n         }\n     }\n \n+    fn push_arg(@block_ctxt cx,\n+                &mutable vec[ValueRef] args,\n+                ValueRef v,\n+                @ty.t t) {\n+        if (ty.type_is_integral(t)) {\n+            auto lldsttype = T_int();\n+            auto llsrctype = type_of(cx.fcx.ccx, t);\n+            if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n+                llvm.LLVMGetIntTypeWidth(llsrctype)) {\n+                args += vec(cx.build.ZExtOrBitCast(v, T_int()));\n+            } else {\n+                args += vec(cx.build.TruncOrBitCast(v, T_int()));\n+            }\n+        } else if (ty.type_is_fp(t)) {\n+            args += vec(cx.build.FPToSI(v, T_int()));\n+        } else {\n+            args += vec(vp2i(cx, v));\n+        }\n+    }\n+\n     auto r;\n     auto rptr;\n     auto args = ty.ty_fn_args(fn_type);\n@@ -6191,7 +6202,7 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n         for (ty.arg arg in args) {\n             auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n             check (llarg as int != 0);\n-            call_args += vec(bcx.build.PointerCast(llarg, T_i32()));\n+            push_arg(bcx, call_args, llarg, arg.ty);\n             arg_n += 1u;\n         }\n \n@@ -6782,7 +6793,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     llenv=C_null(T_ptr(T_nil())),\n                     llretptr=C_null(T_ptr(T_nil())),\n                     mutable llallocas = llallocas,\n-                    mutable llself=none[ValueRef],\n+                    mutable llself=none[self_vt],\n                     mutable lliterbody=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),"}, {"sha": "f83bece7f20abce8deecbd0629971e94c58f1027", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -26,6 +26,12 @@ type method = rec(ast.proto proto,\n \n type mt = rec(@t ty, ast.mutability mut);\n \n+// Convert from method type to function type.  Pretty easy; we just drop\n+// 'ident'.\n+fn method_ty_to_fn_ty(method m) -> @ty.t {\n+    ret plain_ty(ty_fn(m.proto, m.inputs, m.output));\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n type t = rec(sty struct, option.t[str] cname);\n@@ -564,8 +570,8 @@ fn plain_ty(&sty st) -> @t {\n     ret @rec(struct=st, cname=none[str]);\n }\n \n-fn plain_box_ty(@t subty) -> @t {\n-    ret plain_ty(ty_box(rec(ty=subty, mut=ast.imm)));\n+fn plain_box_ty(@t subty, ast.mutability mut) -> @t {\n+    ret plain_ty(ty_box(rec(ty=subty, mut=mut)));\n }\n \n fn plain_tup_ty(vec[@t] elem_tys) -> @t {"}, {"sha": "ab0262f1753363b8c1fd3b599001d5e2d126a547", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -23,6 +23,7 @@ import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n import middle.ty.type_is_scalar;\n import middle.ty.ty_params_opt_and_ty;\n+import middle.ty.ty_nil;\n \n import std._str;\n import std._uint;\n@@ -62,6 +63,12 @@ fn triv_ann(@ty.t t) -> ann {\n     ret ast.ann_type(t, none[vec[@ty.t]], none[@ts_ann]);\n }\n \n+// Used to fill in the annotation for things that have uninteresting\n+// types\n+fn boring_ann() -> ann {\n+    ret triv_ann(plain_ty(ty_nil));\n+}\n+\n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     state obj ty_generalizer(@crate_ctxt cx,\n@@ -959,7 +966,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n fn add_boxes(uint n, @ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n-        t1 = ty.plain_box_ty(t1);\n+        t1 = ty.plain_box_ty(t1, ast.imm);\n         n -= 1u;\n     }\n     ret t1;\n@@ -1361,7 +1368,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                                  ann_to_type(ann), adk);\n             e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n         }\n-        /* FIXME: this should probably check the type annotations */\n+        /* FIXME: should this check the type annotations? */\n         case (ast.expr_fail(_))  { e_1 = e.node; } \n         case (ast.expr_log(_,_)) { e_1 = e.node; } \n         case (ast.expr_break(_)) { e_1 = e.node; }\n@@ -1728,9 +1735,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto oper_1 = check_expr(fcx, oper);\n             auto oper_t = expr_ty(oper_1);\n             alt (unop) {\n-                case (ast.box) {\n-                    // TODO: mutable\n-                    oper_t = ty.plain_box_ty(oper_t);\n+                case (ast.box(?mut)) {\n+                    oper_t = ty.plain_box_ty(oper_t, mut);\n                 }\n                 case (ast.deref) {\n                     alt (oper_t.struct) {\n@@ -1772,16 +1778,19 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                      ann));\n         }\n \n-        case (ast.expr_fail(_)) { // ??? ignoring ann\n-            ret expr;\n+        case (ast.expr_fail(_)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_fail(boring_ann()));\n         }\n \n         case (ast.expr_break(_)) {\n-            ret expr;\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_break(boring_ann()));\n         }\n \n         case (ast.expr_cont(_)) {\n-            ret expr;\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_cont(boring_ann()));\n         }\n \n         case (ast.expr_ret(?expr_opt, _)) {\n@@ -1793,14 +1802,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                          + \"returning non-nil\");\n                     }\n \n-                    ret expr;\n+                    ret @fold.respan[ast.expr_]\n+                        (expr.span,\n+                         ast.expr_ret(none[@ast.expr], boring_ann()));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n                     ret @fold.respan[ast.expr_]\n-                        (expr.span, ast.expr_ret(some(expr_1), ann_none));\n+                        (expr.span, ast.expr_ret(some(expr_1), boring_ann()));\n                 }\n             }\n         }\n@@ -1814,14 +1825,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                          + \"putting non-nil\");\n                     }\n \n-                    ret expr;\n+                    ret @fold.respan[ast.expr_]\n+                        (expr.span, ast.expr_put(none[@ast.expr],\n+                                                 boring_ann()));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n                     ret @fold.respan[ast.expr_]\n-                        (expr.span, ast.expr_put(some(expr_1), ann_none));\n+                        (expr.span, ast.expr_put(some(expr_1), boring_ann()));\n                 }\n             }\n         }\n@@ -1832,20 +1845,21 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_be(expr_1, ann_none));\n+                                        ast.expr_be(expr_1,\n+                                                    boring_ann()));\n         }\n \n         case (ast.expr_log(?e,_)) {\n             auto expr_t = check_expr(fcx, e);\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_log(expr_t, ann_none));\n+                (expr.span, ast.expr_log(expr_t, boring_ann()));\n         }\n \n         case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n             demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_check_expr(expr_t, ann_none));\n+                (expr.span, ast.expr_check_expr(expr_t, boring_ann()));\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n@@ -2111,6 +2125,18 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_call(f_1, args_1, ann));\n         }\n \n+        case (ast.expr_call_self(?ident, ?args, _)) {\n+            // FIXME: What's to check here?\n+\n+            // FIXME: These two lines are ripped off from the expr_call case;\n+            // what should they be really?\n+            auto rt_1 = plain_ty(ty.ty_nil);\n+            auto ann = triv_ann(rt_1);\n+\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_call_self(ident, args, ann));\n+        }\n+\n         case (ast.expr_spawn(?dom, ?name, ?f, ?args, _)) {\n             auto result = check_call(fcx, f, args);\n             auto f_1 = result._0;"}, {"sha": "64a17a7da0ca3db2812c0ab18998892330b45bcc", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 454, "deletions": 63, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -20,6 +20,8 @@ import front.ast.expr;\n import front.ast.expr_call;\n import front.ast.expr_path;\n import front.ast.expr_log;\n+import front.ast.expr_block;\n+import front.ast.expr_lit;\n import front.ast.path;\n import front.ast.crate_directive;\n import front.ast.fn_decl;\n@@ -42,6 +44,11 @@ import front.ast.ann_none;\n import front.ast.ann_type;\n import front.ast._obj;\n import front.ast._mod;\n+import front.ast.crate;\n+import front.ast.mod_index_entry;\n+import front.ast.mie_item;\n+import front.ast.item_fn;\n+import front.ast.def_local;\n \n import middle.fold;\n import middle.fold.respan;\n@@ -50,16 +57,22 @@ import util.common;\n import util.common.span;\n import util.common.spanned;\n import util.common.new_str_hash;\n+import util.common.new_def_hash;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n import util.typestate_ann.true_precond;\n import util.typestate_ann.true_postcond;\n import util.typestate_ann.postcond;\n import util.typestate_ann.precond;\n+import util.typestate_ann.poststate;\n+import util.typestate_ann.prestate;\n import util.typestate_ann.pre_and_post;\n import util.typestate_ann.get_pre;\n import util.typestate_ann.get_post;\n+import util.typestate_ann.implies;\n+import util.typestate_ann.pre_and_post_state;\n+import util.typestate_ann.empty_states;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -91,28 +104,143 @@ import std.list.cons;\n import std.list.nil;\n import std.list.foldl;\n import std.list.find;\n+import std._uint;\n+import std.bitv;\n \n import util.typestate_ann;\n import util.typestate_ann.difference;\n import util.typestate_ann.union;\n import util.typestate_ann.pps_len;\n import util.typestate_ann.require_and_preserve;\n \n-/**********************************************************************/\n-/* mapping from variable name to bit number */\n-type fn_info = std.map.hashmap[ident, uint];\n+/**** debugging junk  ****/\n+fn log_expr(@expr e) -> () {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=option.none[vec[front.lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+\n+  print_expr(out, e);\n+  log(s.get_str());\n+}\n+\n+fn log_cond(vec[uint] v) -> () {\n+  auto res = \"\";\n+  for (uint i in v) {\n+    if (i == 0u) {\n+      res += \"0\";\n+    }\n+    else {\n+      res += \"1\";\n+    }\n+  }\n+  log(res);\n+}\n+fn log_pp(&pre_and_post pp) -> () {\n+  auto p1 = bitv.to_vec(pp.precondition);\n+  auto p2 = bitv.to_vec(pp.postcondition);\n+  log(\"pre:\");\n+  log_cond(p1);\n+  log(\"post:\");\n+  log_cond(p2);\n+}\n \n-fn bit_num(ident v, fn_info m) -> uint {\n+fn print_ident(&ident i) -> () {\n+  log(\" \" + i + \" \");\n+}\n+\n+fn print_idents(vec[ident] idents) -> () {\n+  if(len[ident](idents) == 0u) {\n+    ret;\n+  }\n+  else {\n+    log(\"an ident: \" + pop[ident](idents));\n+    print_idents(idents);\n+  }\n+}\n+/**********************************************************************/\n+/* mapping from variable name (def_id is assumed to be for a local\n+   variable in a given function) to bit number */\n+type fn_info      = std.map.hashmap[def_id, uint];\n+/* mapping from function name to fn_info map */\n+type _fn_info_map = std.map.hashmap[def_id, fn_info];\n+ \n+fn bit_num(def_id v, fn_info m) -> uint {\n+  check (m.contains_key(v));\n   ret m.get(v);\n }\n+\n+fn var_is_local(def_id v, fn_info m) -> bool {\n+  ret (m.contains_key(v));\n+}\n+\n fn num_locals(fn_info m) -> uint {\n   ret m.size();\n }\n \n+fn find_locals(_fn f) -> vec[def_id] {\n+  auto res = _vec.alloc[def_id](0u);\n+\n+  for each (@tup(ident, block_index_entry) p\n+          in f.body.node.index.items()) {\n+    alt (p._1) {\n+      case (ast.bie_local(?loc)) {\n+        res += vec(loc.id);\n+      }\n+      case (_) { }\n+    }\n+  }\n+\n+  ret res;\n+}\n+\n+fn add_var(def_id v, uint next, fn_info tbl) -> uint {\n+  tbl.insert(v, next);\n+  // log(v + \" |-> \" + _uint.to_str(next, 10u));\n+  ret (next + 1u);\n+}\n+\n+/* builds a table mapping each local var defined in f\n+ to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(_fn f) -> fn_info {\n-  ret new_str_hash[uint](); /* FIXME: actually implement this */\n+  auto res = new_def_hash[uint]();\n+  let uint next = 0u;\n+  let vec[ast.arg] f_args = f.decl.inputs;\n+\n+  for (ast.arg v in f_args) {\n+    next = add_var(v.id, next, res);\n+  }\n+\n+  let vec[def_id] locals = find_locals(f);\n+  for (def_id v in locals) {\n+    next = add_var(v, next, res);\n+  }\n+\n+  ret res;\n }\n-/**********************************************************************/\n+\n+/* extends mk_fn_info to an item, side-effecting the map fi from \n+   function IDs to fn_info maps */\n+fn mk_fn_info_item_fn(&_fn_info_map fi, &span sp, ident i, &ast._fn f,\n+                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+  fi.insert(id, mk_fn_info(f));\n+  ret @respan(sp, item_fn(i, f, ty_params, id, a));\n+}\n+\n+/* initializes the global fn_info_map (mapping each function ID, including\n+   nested locally defined functions, onto a mapping from local variable name\n+   to bit number) */\n+fn mk_f_to_fn_info(@ast.crate c) -> _fn_info_map {\n+  auto res = new_def_hash[fn_info]();\n+\n+  auto fld = fold.new_identity_fold[_fn_info_map]();\n+  fld = @rec(fold_item_fn = bind mk_fn_info_item_fn(_,_,_,_,_,_,_) with *fld);\n+  fold.fold_crate[_fn_info_map](res, fld, c);\n+\n+  ret res;\n+}\n+/**** Helpers ****/\n fn expr_ann(&expr e) -> ann {\n   alt(e.node) {\n     case (ast.expr_vec(_,_,?a)) {\n@@ -214,8 +342,53 @@ fn expr_ann(&expr e) -> ann {\n   }\n }\n \n-fn expr_pp(&@expr e) -> pre_and_post {\n-  alt (expr_ann(*e)) {\n+/* returns ann_none if this is the sort\n+ of statement where an ann doesn't make sense */\n+fn stmt_ann(&stmt s) -> ann {\n+  alt (s.node) {\n+    case (stmt_decl(?d)) {\n+      alt (d.node) {\n+        case (decl_local(?l)) {\n+          ret l.ann;\n+        }\n+        case (decl_item(?i)) {\n+          ret ann_none; /* ????? */\n+        }\n+      }\n+    }\n+    case (stmt_expr(?e)) {\n+      ret expr_ann(*e);\n+    }\n+    case (_) {\n+      ret ann_none;\n+    }\n+  }\n+}\n+\n+/* fails if e has no annotation */\n+fn expr_pp(&expr e) -> pre_and_post {\n+  alt (expr_ann(e)) {\n+    case (ann_none) {\n+      log \"expr_pp: the impossible happened (no annotation)\";\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          log \"expr_pp: the impossible happened (no pre/post)\";\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret p.conditions;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* fails if e has no annotation */\n+fn expr_states(&expr e) -> pre_and_post_state {\n+  alt (expr_ann(e)) {\n     case (ann_none) {\n       log \"expr_pp: the impossible happened (no annotation)\";\n       fail;\n@@ -227,29 +400,95 @@ fn expr_pp(&@expr e) -> pre_and_post {\n           fail;\n         }\n         case (some[@ts_ann](?p)) {\n-          ret *p;\n+          ret p.states;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* fails if no annotation */\n+fn stmt_pp(&stmt s) -> pre_and_post {\n+  alt (stmt_ann(s)) {\n+    case (ann_none) {\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret p.conditions;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* fails if no annotation */\n+fn stmt_states(&stmt s) -> pre_and_post_state {\n+  alt (stmt_ann(s)) {\n+    case (ann_none) {\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret p.states;\n         }\n       }\n     }\n   }\n }\n \n fn expr_precond(&expr e) -> precond {\n-  ret (expr_pp(@e)).precondition;\n+  ret (expr_pp(e)).precondition;\n }\n \n-fn expr_postcond(&@expr e) -> postcond {\n+fn expr_postcond(&expr e) -> postcond {\n   ret (expr_pp(e)).postcondition;\n }\n \n-fn with_pp(ann a, @pre_and_post p) -> ann {\n+fn expr_prestate(&expr e) -> prestate {\n+  ret (expr_states(e)).prestate;\n+}\n+\n+fn expr_poststate(&expr e) -> poststate {\n+  ret (expr_states(e)).poststate;\n+}\n+\n+fn stmt_precond(&stmt s) -> precond {\n+  ret (stmt_pp(s)).precondition;\n+}\n+\n+fn stmt_postcond(&stmt s) -> postcond {\n+  ret (stmt_pp(s)).postcondition;\n+}\n+\n+fn stmt_prestate(&stmt s) -> prestate {\n+  ret (stmt_states(s)).prestate;\n+}\n+\n+fn stmt_poststate(&stmt s) -> poststate {\n+  ret (stmt_states(s)).poststate;\n+}\n+\n+/* returns a new annotation where the pre_and_post is p */\n+fn with_pp(ann a, pre_and_post p) -> ann {\n   alt (a) {\n     case (ann_none) {\n       log(\"with_pp: the impossible happened\");\n       fail; /* shouldn't happen b/c code is typechecked */\n     }\n     case (ann_type(?t, ?ps, _)) {\n-      ret (ann_type(t, ps, some[@ts_ann](p)));\n+      ret (ann_type(t, ps,\n+                    some[@ts_ann]\n+                    (@rec(conditions=p,\n+                          states=empty_states(pps_len(p))))));\n     }\n   }\n }\n@@ -276,9 +515,14 @@ fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n }\n \n fn union_postconds_go(postcond first, &vec[postcond] rest) -> postcond {\n-  auto other = rest.(0);\n-  union(first, other);\n-  union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n+  auto sz = _vec.len[postcond](rest);\n+\n+  if (sz > 0u) {\n+    auto other = rest.(0);\n+    union(first, other);\n+    union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n+  }\n+\n   ret first;\n }\n \n@@ -288,19 +532,7 @@ fn union_postconds(&vec[postcond] pcs) -> postcond {\n   be union_postconds_go(pcs.(0), pcs);\n }\n \n-fn print_ident(&ident i) -> () {\n-  log(\" \" + i + \" \");\n-}\n-\n-fn print_idents(vec[ident] idents) -> () {\n-  if(len[ident](idents) == 0u) {\n-    ret;\n-  }\n-  else {\n-    log(\"an ident: \" + pop[ident](idents));\n-    print_idents(idents);\n-  }\n-}\n+/******* AST-traversing code ********/\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n   ret m; /* FIXME */\n@@ -314,26 +546,29 @@ fn find_pre_post_obj(_obj o) -> _obj {\n   ret o; /* FIXME */\n }\n \n-impure fn find_pre_post_item(fn_info enclosing, &item i) -> item {\n+fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> item {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n       auto e_pp = find_pre_post_expr(enclosing, *e);\n+      log(\"1\");\n       ret (respan(i.span,\n-                   ast.item_const(id, t, e_pp, di,\n-                              with_pp(a, @expr_pp(e_pp)))));\n+                  ast.item_const(id, t, e_pp, di, a)));\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      auto f_pp = find_pre_post_fn(f);\n+      check (fm.contains_key(di));\n+      auto f_pp = find_pre_post_fn(fm, fm.get(di), f);\n       ret (respan(i.span, \n                    ast.item_fn(id, f_pp, ps, di, a)));\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n       auto m_pp = find_pre_post_mod(m);\n+      log(\"3\");\n       ret (respan(i.span,\n                    ast.item_mod(id, m_pp, di)));\n     }\n     case (ast.item_native_mod(?id, ?nm, ?di)) {\n       auto n_pp = find_pre_post_native_mod(nm);\n+      log(\"4\");\n       ret (respan(i.span,\n                    ast.item_native_mod(id, n_pp, di)));\n     }\n@@ -345,58 +580,102 @@ impure fn find_pre_post_item(fn_info enclosing, &item i) -> item {\n     }\n     case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n       auto o_pp = find_pre_post_obj(o);\n+      log(\"5\");\n       ret (respan(i.span,\n                    ast.item_obj(id, o_pp, ps, di, a)));\n     }\n   }\n }\n \n-impure fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n+fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n   auto num_local_vars = num_locals(enclosing);\n \n   fn do_rand_(fn_info enclosing, &@expr e) -> @expr {\n-    be find_pre_post_expr(enclosing, *e);\n+    log(\"for rand \" );\n+    log_expr(e);\n+    log(\"pp = \");\n+    auto res = find_pre_post_expr(enclosing, *e);\n+    log_pp(expr_pp(*res));\n+    ret res;\n   }\n \n   auto do_rand = bind do_rand_(enclosing,_);\n \n   alt(e.node) {\n     case(expr_call(?oper, ?rands, ?a)) {\n       auto pp_oper = find_pre_post_expr(enclosing, *oper);\n+      log(\"pp_oper =\");\n+      log_pp(expr_pp(*pp_oper));\n       \n       auto f = do_rand;\n       auto pp_rands = _vec.map[@expr, @expr](f, rands);\n       \n-      auto g = expr_pp;\n-      auto pps = _vec.map[@expr, pre_and_post]      \n-        (g, pp_rands);\n-      _vec.push[pre_and_post](pps, expr_pp(pp_oper));\n+      fn pp_one(&@expr e) -> pre_and_post {\n+        be expr_pp(*e);\n+      }\n+      auto g = pp_one;\n+      auto pps = _vec.map[@expr, pre_and_post](g, pp_rands);\n+      _vec.push[pre_and_post](pps, expr_pp(*pp_oper));\n       auto h = get_post;\n       auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n       auto res_postcond = union_postconds(res_postconds);\n-      let @pre_and_post pp =\n-        @rec(precondition=seq_preconds(num_local_vars, pps),\n+      let pre_and_post pp =\n+        rec(precondition=seq_preconds(num_local_vars, pps),\n              postcondition=res_postcond);\n       let ann a_res = with_pp(a, pp);\n+      log(\"result for call\");\n+      log_expr(@e);\n+      log(\"is:\");\n+      log_pp(pp);\n       ret (@respan(e.span,\n                    expr_call(pp_oper, pp_rands, a_res)));\n                         \n     }\n     case(expr_path(?p, ?maybe_def, ?a)) {\n-      check (len[ident](p.node.idents) > 0u);\n-      auto referent = p.node.idents.(0);\n-      auto i = bit_num(referent, enclosing);\n+      auto df;\n+      alt (maybe_def) {\n+        case (none[def])\n+          { log(\"expr_path should have a def\"); fail; }\n+        case (some[def](?d)) { df = d; }\n+      }\n+\n       auto res = empty_pre_post(num_local_vars);\n-      require_and_preserve(i, *res);\n+\n+      alt (df) {\n+        case (def_local(?d_id)) {\n+          auto i = bit_num(d_id, enclosing);\n+          require_and_preserve(i, res);\n+        }\n+        case (_) { /* nothing to check */ }\n+      }\n+\n+      // Otherwise, variable is global, so it must be initialized\n+      log(\"pre/post for:\\n\");\n+      log_expr(@e);\n+      log(\"is\");\n+      log_pp(res);\n       ret (@respan\n            (e.span,\n             expr_path(p, maybe_def,\n                       with_pp(a, res))));\n     }\n-    case(expr_log(?e, ?a)) {\n-      auto e_pp = find_pre_post_expr(enclosing, *e);\n+    case(expr_log(?arg, ?a)) {\n+      log(\"log\");\n+      auto e_pp = find_pre_post_expr(enclosing, *arg);\n+      log(\"pre/post for: \");\n+      log_expr(arg);\n+      log(\"is\");\n+      log_pp(expr_pp(*e_pp));\n       ret (@respan(e.span,\n-                   expr_log(e_pp, with_pp(a, @expr_pp(e_pp)))));\n+                   expr_log(e_pp, with_pp(a, expr_pp(*e_pp)))));\n+    }\n+    case (expr_block(?b, ?a)) {\n+      log(\"block!\");\n+      fail;\n+    }\n+    case (expr_lit(?l, ?a)) {\n+      ret @respan(e.span,\n+                  expr_lit(l, with_pp(a, empty_pre_post(num_local_vars))));\n     }\n     case(_) {\n       log(\"this sort of expr isn't implemented!\");\n@@ -405,8 +684,8 @@ impure fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n   }\n }\n \n-impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n-  -> ast.stmt {\n+fn find_pre_post_for_each_stmt(_fn_info_map fm, &fn_info enclosing,\n+                               &ast.stmt s) -> ast.stmt {\n   auto num_local_vars = num_locals(enclosing);\n \n   alt(s.node) {\n@@ -418,7 +697,7 @@ impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n               let @expr r = find_pre_post_expr(enclosing, *an_init.expr);\n               let init_op o = an_init.op;\n               let initializer a_i = rec(op=o, expr=r);\n-              let ann res_ann = with_pp(alocal.ann, @expr_pp(r));\n+              let ann res_ann = with_pp(alocal.ann, expr_pp(*r));\n               let @local res_local =\n                 @rec(ty=alocal.ty, infer=alocal.infer,\n                      ident=alocal.ident, init=some[initializer](a_i),\n@@ -443,24 +722,26 @@ impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n           }\n         }\n         case(decl_item(?anitem)) {\n-          auto res_item = find_pre_post_item(enclosing, *anitem);\n+          auto res_item = find_pre_post_item(fm, enclosing, *anitem);\n           ret (respan(s.span, stmt_decl(@respan(adecl.span,\n                                                decl_item(@res_item))))); \n         }\n       }\n     }\n     case(stmt_expr(?e)) {\n+      log_expr(e);\n       let @expr e_pp = find_pre_post_expr(enclosing, *e);\n       ret (respan(s.span, stmt_expr(e_pp)));\n     }    \n   }\n }\n \n-fn find_pre_post_block(fn_info enclosing, block b) -> block {\n-  fn do_one_(fn_info i, &@stmt s) -> @stmt {\n-    ret (@find_pre_post_for_each_stmt(i, *s));\n+fn find_pre_post_block(&_fn_info_map fm, &fn_info enclosing, block b)\n+  -> block {\n+  fn do_one_(_fn_info_map fm, fn_info i, &@stmt s) -> @stmt {\n+    ret (@find_pre_post_for_each_stmt(fm, i, *s));\n   }\n-  auto do_one = bind do_one_(enclosing, _);\n+  auto do_one = bind do_one_(fm, enclosing, _);\n  \n   auto ss = _vec.map[@stmt, @stmt](do_one, b.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> @expr {\n@@ -472,24 +753,134 @@ fn find_pre_post_block(fn_info enclosing, block b) -> block {\n   ret respan(b.span, b_res);\n }\n \n-fn find_pre_post_fn(&_fn f) -> _fn {\n-  let fn_info fi = mk_fn_info(f);\n+fn find_pre_post_fn(&_fn_info_map fm, &fn_info fi, &_fn f) -> _fn {\n   ret rec(decl=f.decl, proto=f.proto,\n-          body=find_pre_post_block(fi, f.body));\n+          body=find_pre_post_block(fm, fi, f.body));\n }\n \n-fn check_item_fn(&@() ignore, &span sp, ident i, &ast._fn f,\n+fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n                  vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n-  auto res_f = find_pre_post_fn(f);  \n+  check (fm.contains_key(id));\n+  auto res_f = find_pre_post_fn(fm, fm.get(id), f);  \n \n   ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n }\n \n+/* Returns a pair of a new function, with possibly a changed pre- or\n+   post-state, and a boolean flag saying whether the function's pre- or \n+   poststate changed */\n+fn find_pre_post_state_fn(fn_info f_info, &ast._fn f) -> tup(bool, ast._fn) {\n+  log (\"Implement find_pre_post_state_fn!\");\n+  fail;\n+}\n+\n+fn fixed_point_states(fn_info f_info,\n+                      fn (fn_info, &ast._fn) -> tup(bool, ast._fn) f,\n+                      &ast._fn start) -> ast._fn {\n+  auto next = f(f_info, start);\n+\n+  if (next._0) {\n+    // something changed\n+    be fixed_point_states(f_info, f, next._1);\n+  }\n+  else {\n+    // we're done!\n+    ret next._1;\n+  }\n+}\n+\n+fn check_states_expr(fn_info enclosing, &expr e) -> () {\n+  let precond prec    = expr_precond(e);\n+  let postcond postc  = expr_postcond(e);\n+  let prestate pres   = expr_prestate(e);\n+  let poststate posts = expr_poststate(e);\n+\n+  if (!implies(pres, prec)) {\n+    log(\"check_states_expr: unsatisfied precondition\");\n+    fail;\n+  }\n+  if (!implies(posts, postc)) {\n+    log(\"check_states_expr: unsatisfied postcondition\");\n+    fail;\n+  }\n+}\n+\n+fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n+  alt (stmt_ann(s)) {\n+    case (ann_none) {\n+      // Statement doesn't require an annotation -- do nothing\n+      ret;\n+    }\n+    case (ann_type(_,_,?m_pp)) {\n+      let precond prec    = stmt_precond(s);\n+      let postcond postc  = stmt_postcond(s);\n+      let prestate pres   = stmt_prestate(s);\n+      let poststate posts = stmt_poststate(s);\n+\n+      if (!implies(pres, prec)) {\n+        log(\"check_states_stmt: unsatisfied precondition\");\n+        fail;\n+      }\n+      if (!implies(posts, postc)) {\n+        log(\"check_states_stmt: unsatisfied postcondition\");\n+        fail;\n+      }\n+    }\n+  }\n+}\n+\n+fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n+  fn do_one_(fn_info i, &@stmt s) -> () {\n+    check_states_stmt(i, *s);\n+  }\n+  auto do_one = bind do_one_(enclosing, _);\n+ \n+  _vec.map[@stmt, ()](do_one, f.body.node.stmts);\n+  fn do_inner_(fn_info i, &@expr e) -> () {\n+    check_states_expr(i, *e);\n+  }\n+  auto do_inner = bind do_inner_(enclosing, _);\n+  option.map[@expr, ()](do_inner, f.body.node.expr);\n+  \n+}\n+\n+fn check_item_fn_state(&_fn_info_map f_info_map, &span sp, ident i,\n+                       &ast._fn f, vec[ast.ty_param] ty_params, def_id id,\n+                       ann a) -> @item {\n+\n+  /* Look up the var-to-bit-num map for this function */\n+  check(f_info_map.contains_key(id));\n+  auto f_info = f_info_map.get(id);\n+\n+  /* Compute the pre- and post-states for this function */\n+  auto g = find_pre_post_state_fn;\n+  auto res_f = fixed_point_states(f_info, g, f);\n+\n+  /* Now compare each expr's pre-state to its precondition\n+     and post-state to its postcondition */\n+  check_states_against_conditions(f_info, res_f);\n+\n+  /* Rebuild the same function */\n+  ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n+}\n+\n fn check_crate(@ast.crate crate) -> @ast.crate {\n-  auto fld = fold.new_identity_fold[@()]();\n \n+  /* Build the global map from function id to var-to-bit-num-map */\n+  auto fn_info_map = mk_f_to_fn_info(crate);\n+\n+  /* Compute the pre and postcondition for every subexpression */\n+  auto fld = fold.new_identity_fold[_fn_info_map]();\n   fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n+  auto with_pre_postconditions = fold.fold_crate[_fn_info_map]\n+    (fn_info_map, fld, crate);\n+\n+  auto fld1 = fold.new_identity_fold[_fn_info_map]();\n+\n+  fld1 = @rec(fold_item_fn = bind check_item_fn_state(_,_,_,_,_,_,_)\n+              with *fld1);\n \n-  ret fold.fold_crate[@()](@(), fld, crate);\n+  ret fold.fold_crate[_fn_info_map](fn_info_map, fld1,\n+                                    with_pre_postconditions);\n }"}, {"sha": "7e0fb6cb7c94d664b4c3be83a536d4f8e83d3308", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -379,6 +379,11 @@ impure fn print_literal(ps s, @ast.lit lit) {\n             wrd(s.s, common.istr(val as int));\n             wrd(s.s, common.ty_mach_to_str(mach));\n         }\n+        case (ast.lit_mach_float(?mach,?val)) {\n+            // val is already a str\n+            wrd(s.s, val);\n+            wrd(s.s, common.ty_mach_to_str(mach));\n+        }\n         case (ast.lit_nil) {wrd(s.s, \"()\");}\n         case (ast.lit_bool(?val)) {\n             if (val) {wrd(s.s, \"true\");} else {wrd(s.s, \"false\");}\n@@ -449,9 +454,9 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             commasep_exprs(s, args);\n             pclose(s);\n         }\n-        case (ast.expr_call_self(?func,?args,_)) {\n+        case (ast.expr_call_self(?ident,?args,_)) {\n             wrd(s.s, \"self.\");\n-            print_expr(s, func);\n+            print_ident(s, ident);\n             popen(s);\n             commasep_exprs(s, args);\n             pclose(s);\n@@ -718,6 +723,10 @@ impure fn print_decl(ps s, @ast.decl decl) {\n     end(s.s);\n }\n \n+impure fn print_ident(ps s, ast.ident ident) {\n+    wrd(s.s, ident);\n+}\n+\n impure fn print_for_decl(ps s, @ast.decl decl) {\n     alt (decl.node) {\n         case (ast.decl_local(?loc)) {"}, {"sha": "47a37f3325ff374c041b305fc8dc19ffcc427d77", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -62,6 +62,8 @@ auth middle.typestate_check.log_expr = impure;\n auth lib.llvm = unsafe;\n auth pretty.pprust = impure;\n auth middle.typestate_check.find_pre_post_block = impure;\n+auth middle.typestate_check.find_pre_post_expr = impure;\n+auth util.typestate_ann.implies = impure;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "071f55135f5a1ac39d7943a1724d1e454e4784b2", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -12,12 +12,21 @@ type precond  = bitv.t; /* 1 means \"this variable must be initialized\"\n type postcond = bitv.t; /* 1 means \"this variable is initialized\"\n                            0 means \"don't know about this variable */\n \n+type prestate = bitv.t; /* 1 means \"this variable is definitely initialized\"\n+                           0 means \"don't know whether this variable is\n+                           initialized\" */\n+type poststate = bitv.t; /* 1 means \"this variable is definitely initialized\"\n+                            0 means \"don't know whether this variable is\n+                            initialized\" */\n+\n /* named thus so as not to confuse with prestate and poststate */\n type pre_and_post = rec(precond precondition, postcond postcondition);\n /* FIXME: once it's implemented: */\n //  : ((*.precondition).nbits == (*.postcondition).nbits);\n \n-type ts_ann = pre_and_post;\n+type pre_and_post_state = rec(prestate prestate, poststate poststate);\n+\n+type ts_ann = rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n   be bitv.create(num_vars, false);\n@@ -27,11 +36,16 @@ fn true_postcond(uint num_vars) -> postcond {\n   be true_precond(num_vars);\n }\n \n-fn empty_pre_post(uint num_vars) -> @pre_and_post {\n-  ret(@rec(precondition=true_precond(num_vars),\n+fn empty_pre_post(uint num_vars) -> pre_and_post {\n+  ret(rec(precondition=true_precond(num_vars),\n            postcondition=true_postcond(num_vars)));\n }\n \n+fn empty_states(uint num_vars) -> pre_and_post_state {\n+  ret(rec(prestate=true_precond(num_vars),\n+           poststate=true_postcond(num_vars)));\n+}\n+\n fn get_pre(&pre_and_post p) -> precond {\n   ret p.precondition;\n }\n@@ -57,5 +71,10 @@ fn pps_len(&pre_and_post p) -> uint {\n impure fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   // sets the ith bit in p's pre and post\n   bitv.set(p.precondition, i, true);\n-  bitv.set(p.postcondition, i, false);\n-}\n\\ No newline at end of file\n+  bitv.set(p.postcondition, i, true);\n+}\n+\n+fn implies(bitv.t a, bitv.t b) -> bool {\n+  bitv.difference(b, a);\n+  ret (bitv.equal(b, bitv.create(b.nbits, false)));\n+}"}, {"sha": "5add8dbd222efd4ec33e04167f08c2d0f7f1dee5", "filename": "src/test/run-pass/lib-option.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Ftest%2Frun-pass%2Flib-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Ftest%2Frun-pass%2Flib-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-option.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -0,0 +1,6 @@\n+// xfail-stage0\n+use std;\n+\n+fn main() {\n+  auto x = std.option.some[int](10);\n+}\n\\ No newline at end of file"}, {"sha": "dbbc212eda6631a8bf5cbd6bfc8892f42c0095f2", "filename": "src/test/run-pass/tag-and-generic-obj.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Ftest%2Frun-pass%2Ftag-and-generic-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9da43984b5e9d50f711320d2afc3307537dfb44/src%2Ftest%2Frun-pass%2Ftag-and-generic-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-and-generic-obj.rs?ref=d9da43984b5e9d50f711320d2afc3307537dfb44", "patch": "@@ -0,0 +1,10 @@\n+tag colour { red; green; }\n+\n+obj foo[T]() {\n+  fn meth(&T x) {\n+  }\n+}\n+\n+fn main() {\n+  foo[colour]().meth(red);\n+}\n\\ No newline at end of file"}]}