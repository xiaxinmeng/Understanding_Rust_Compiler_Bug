{"sha": "8e03f18e37d2782189391955bc56d3aebead81f5", "node_id": "C_kwDOAAsO6NoAKDhlMDNmMThlMzdkMjc4MjE4OTM5MTk1NWJjNTZkM2FlYmVhZDgxZjU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-11-26T14:51:22Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-11-26T15:31:02Z"}, "message": "fix: check if range contains tail expression", "tree": {"sha": "d9e4bed16297ab5040cfd0366b032d8c3d2b4b39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9e4bed16297ab5040cfd0366b032d8c3d2b4b39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e03f18e37d2782189391955bc56d3aebead81f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmOCMTYACgkQ4laYqTBY\nYXFEMQ/9Ef5l8nFVqHBSTUgpN8O6cWYwTGdk/brXpGDR7WLxOFsAGxjq9PqpYlvG\n8BA0PUta4jCd3zmp87lhwT6uRgLaZrHOGo+bKSseENbSTuPopqiHa4twt1yLJADs\nUO2wYhwvmyemZUC957OZDcZjxheKn7WFhC59nY1ODMZ2Bba/ZpmvAz7K/bVIgSl9\n1ml5Mp6VvP6AyRQ5KvLxezsqr+p8VBhTlIAgY9oFd65dpxnm/2X3fn/ByMu/6zsE\nh1HLDTcSfFYzIJb+rKOoChS9SGo5yjmKnoCzESZ+poVXpqLLNaQXDracJEYsvSME\nQLCDgxXSl5kTdVb8iioA9O1NLl1vEJNgv0tLMC22AsK0bEJK536wVVZnxXpYw25y\nj+mE1uwwIBRp/8jQT5G7XA7OtScmLezVtxcdQ6wktxD28CPLGdvMTXIAc0Do5iTt\ndm1Y7Xw6fvX16RnG3+R4ymkTI5gQhoSER8hu6Hy+BJTxrOGLfljuQ19Cdt3+rnud\nrQG5AwTkrLpC9RD+cLizOFBrCdaS9eGDsRiUNa1K1D3HvOvIgkVmT8hwLbERcMoL\npNEZ+RcosodNTUpMk5hUFMyGmcwiQSYpMt+JXQxKt/Bkv0Pb187lH+xIZFMcZt9P\ntvOWAlrFAKrFEZrobLdc3TMMzZ0GwWTc98lhrmEkrYQbbW8NwKs=\n=QqKl\n-----END PGP SIGNATURE-----", "payload": "tree d9e4bed16297ab5040cfd0366b032d8c3d2b4b39\nparent 822c61f559dc522dbd28f2886d20989a55613fc0\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1669474282 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1669476662 +0900\n\nfix: check if range contains tail expression\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e03f18e37d2782189391955bc56d3aebead81f5", "html_url": "https://github.com/rust-lang/rust/commit/8e03f18e37d2782189391955bc56d3aebead81f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e03f18e37d2782189391955bc56d3aebead81f5/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "822c61f559dc522dbd28f2886d20989a55613fc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/822c61f559dc522dbd28f2886d20989a55613fc0", "html_url": "https://github.com/rust-lang/rust/commit/822c61f559dc522dbd28f2886d20989a55613fc0"}], "stats": {"total": 204, "additions": 183, "deletions": 21}, "files": [{"sha": "0483cfdc64667012313eeca7d1afc65ba6a8277e", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 183, "deletions": 21, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/8e03f18e37d2782189391955bc56d3aebead81f5/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e03f18e37d2782189391955bc56d3aebead81f5/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=8e03f18e37d2782189391955bc56d3aebead81f5", "patch": "@@ -11,7 +11,9 @@ use ide_db::{\n     helpers::mod_path_to_ast,\n     imports::insert_use::{insert_use, ImportScope},\n     search::{FileReference, ReferenceCategory, SearchScope},\n-    syntax_helpers::node_ext::{preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr},\n+    syntax_helpers::node_ext::{\n+        for_each_tail_expr, preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr,\n+    },\n     FxIndexSet, RootDatabase,\n };\n use itertools::Itertools;\n@@ -78,7 +80,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n     };\n \n     let body = extraction_target(&node, range)?;\n-    let container_info = body.analyze_container(&ctx.sema)?;\n+    let (container_info, contains_tail_expr) = body.analyze_container(&ctx.sema)?;\n \n     let (locals_used, self_param) = body.analyze(&ctx.sema);\n \n@@ -119,6 +121,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                 ret_ty,\n                 body,\n                 outliving_locals,\n+                contains_tail_expr,\n                 mods: container_info,\n             };\n \n@@ -245,6 +248,8 @@ struct Function {\n     ret_ty: RetType,\n     body: FunctionBody,\n     outliving_locals: Vec<OutlivedLocal>,\n+    /// Whether at least one of the container's tail expr is contained in the range we're extracting.\n+    contains_tail_expr: bool,\n     mods: ContainerInfo,\n }\n \n@@ -294,7 +299,6 @@ struct ControlFlow {\n #[derive(Clone, Debug)]\n struct ContainerInfo {\n     is_const: bool,\n-    is_in_tail: bool,\n     parent_loop: Option<SyntaxNode>,\n     /// The function's return type, const's type etc.\n     ret_type: Option<hir::Type>,\n@@ -743,7 +747,10 @@ impl FunctionBody {\n         (res, self_param)\n     }\n \n-    fn analyze_container(&self, sema: &Semantics<'_, RootDatabase>) -> Option<ContainerInfo> {\n+    fn analyze_container(\n+        &self,\n+        sema: &Semantics<'_, RootDatabase>,\n+    ) -> Option<(ContainerInfo, bool)> {\n         let mut ancestors = self.parent()?.ancestors();\n         let infer_expr_opt = |expr| sema.type_of_expr(&expr?).map(TypeInfo::adjusted);\n         let mut parent_loop = None;\n@@ -815,28 +822,36 @@ impl FunctionBody {\n                 }\n             };\n         };\n-        let container_tail = match expr? {\n-            ast::Expr::BlockExpr(block) => block.tail_expr(),\n-            expr => Some(expr),\n-        };\n-        let is_in_tail =\n-            container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n-                container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n+\n+        let expr = expr?;\n+        let contains_tail_expr = if let Some(body_tail) = self.tail_expr() {\n+            let mut contains_tail_expr = false;\n+            let tail_expr_range = body_tail.syntax().text_range();\n+            for_each_tail_expr(&expr, &mut |e| {\n+                if tail_expr_range.contains_range(e.syntax().text_range()) {\n+                    contains_tail_expr = true;\n+                }\n             });\n+            contains_tail_expr\n+        } else {\n+            false\n+        };\n \n         let parent = self.parent()?;\n         let parents = generic_parents(&parent);\n         let generic_param_lists = parents.iter().filter_map(|it| it.generic_param_list()).collect();\n         let where_clauses = parents.iter().filter_map(|it| it.where_clause()).collect();\n \n-        Some(ContainerInfo {\n-            is_in_tail,\n-            is_const,\n-            parent_loop,\n-            ret_type: ty,\n-            generic_param_lists,\n-            where_clauses,\n-        })\n+        Some((\n+            ContainerInfo {\n+                is_const,\n+                parent_loop,\n+                ret_type: ty,\n+                generic_param_lists,\n+                where_clauses,\n+            },\n+            contains_tail_expr,\n+        ))\n     }\n \n     fn return_ty(&self, ctx: &AssistContext<'_>) -> Option<RetType> {\n@@ -1633,7 +1648,7 @@ impl Function {\n \n     fn make_ret_ty(&self, ctx: &AssistContext<'_>, module: hir::Module) -> Option<ast::RetType> {\n         let fun_ty = self.return_type(ctx);\n-        let handler = if self.mods.is_in_tail {\n+        let handler = if self.contains_tail_expr {\n             FlowHandler::None\n         } else {\n             FlowHandler::from_ret_ty(self, &fun_ty)\n@@ -1707,7 +1722,7 @@ fn make_body(\n     fun: &Function,\n ) -> ast::BlockExpr {\n     let ret_ty = fun.return_type(ctx);\n-    let handler = if fun.mods.is_in_tail {\n+    let handler = if fun.contains_tail_expr {\n         FlowHandler::None\n     } else {\n         FlowHandler::from_ret_ty(fun, &ret_ty)\n@@ -5582,6 +5597,153 @@ impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n     t.into() + v.into()\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_of_tail_expr_loop() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        $0if true {\n+            continue;\n+        }$0\n+\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        if let ControlFlow::Break(_) = fun_name() {\n+            continue;\n+        }\n+\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\n+fn $0fun_name() -> ControlFlow<()> {\n+    if true {\n+        return ControlFlow::Break(());\n+    }\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_of_tail_if_block() {\n+        // FIXME: double semicolon\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: option, try\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        let a = $0if true {\n+            Some(())?\n+        } else {\n+            ()\n+        }$0;\n+        Some(a)\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        let a = fun_name()?;;\n+        Some(a)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    Some(if true {\n+        Some(())?\n+    } else {\n+        ()\n+    })\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tail_expr_of_tail_block_nested() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: option, try\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        $0{\n+            let a = if true {\n+                Some(())?\n+            } else {\n+                ()\n+            };\n+            Some(a)\n+        }$0\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        fun_name()?\n+    } else {\n+        None\n+    }\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    let a = if true {\n+        Some(())?\n+    } else {\n+        ()\n+    };\n+    Some(a)\n+}\n \"#,\n         );\n     }"}]}