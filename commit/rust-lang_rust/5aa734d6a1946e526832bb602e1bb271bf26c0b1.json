{"sha": "5aa734d6a1946e526832bb602e1bb271bf26c0b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYTczNGQ2YTE5NDZlNTI2ODMyYmI2MDJlMWJiMjcxYmYyNmMwYjE=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2013-03-12T07:01:09Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2013-03-12T08:03:34Z"}, "message": "Parse operands properly and add a way to indicate volatile asm.", "tree": {"sha": "f9c2332f54666a31c4bb7ffa5a2cb1e85e2c895a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9c2332f54666a31c4bb7ffa5a2cb1e85e2c895a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aa734d6a1946e526832bb602e1bb271bf26c0b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa734d6a1946e526832bb602e1bb271bf26c0b1", "html_url": "https://github.com/rust-lang/rust/commit/5aa734d6a1946e526832bb602e1bb271bf26c0b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aa734d6a1946e526832bb602e1bb271bf26c0b1/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "885d0d3d3369bef72590a4d5671c0de83e968dda", "url": "https://api.github.com/repos/rust-lang/rust/commits/885d0d3d3369bef72590a4d5671c0de83e968dda", "html_url": "https://github.com/rust-lang/rust/commit/885d0d3d3369bef72590a4d5671c0de83e968dda"}], "stats": {"total": 163, "additions": 145, "deletions": 18}, "files": [{"sha": "2e6b0c5f78216ad6b41774f155f2d975c3263b22", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5aa734d6a1946e526832bb602e1bb271bf26c0b1", "patch": "@@ -873,12 +873,12 @@ pub fn add_comment(bcx: block, text: &str) {\n }\n \n pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n-                     dia: AsmDialect) -> ValueRef {\n+                     volatile: lib::llvm::Bool, dia: AsmDialect) -> ValueRef {\n     unsafe {\n         count_insn(cx, \"inlineasm\");\n \n         let llfty = T_fn(~[], T_void());\n-        let v = llvm::LLVMInlineAsm(llfty, asm, cons, False, False, dia);\n+        let v = llvm::LLVMInlineAsm(llfty, asm, cons, volatile, False, dia);\n \n         Call(cx, v, ~[])\n     }"}, {"sha": "0539dadca8e35d6a61dc06dae450a102a153174f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5aa734d6a1946e526832bb602e1bb271bf26c0b1", "patch": "@@ -691,10 +691,14 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_assign_op(op, dst, src) => {\n             return trans_assign_op(bcx, expr, op, dst, src);\n         }\n-        ast::expr_inline_asm(asm, cons) => {\n+        ast::expr_inline_asm(asm, cons, volatile) => {\n+            // XXX: cons doesn't actual contain ALL the stuff we should\n+            // be passing since the constraints for in/outputs aren't included\n             do str::as_c_str(*asm) |a| {\n                 do str::as_c_str(*cons) |c| {\n-                    InlineAsmCall(bcx, a, c, lib::llvm::AD_ATT);\n+                    let v = if volatile { lib::llvm::True }\n+                            else        { lib::llvm::False };\n+                    InlineAsmCall(bcx, a, c, v, lib::llvm::AD_ATT);\n                 }\n             }\n             return bcx;"}, {"sha": "dab5de47aa648d4753a0434290de2559d0158c3e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5aa734d6a1946e526832bb602e1bb271bf26c0b1", "patch": "@@ -601,7 +601,8 @@ pub enum expr_ {\n     expr_ret(Option<@expr>),\n     expr_log(log_level, @expr, @expr),\n     \n-    expr_inline_asm(@~str /* asm */, @~str /* constraints */),\n+    /* asm, clobbers + constraints, volatile */\n+    expr_inline_asm(@~str, @~str, bool),\n \n     expr_mac(mac),\n "}, {"sha": "229d1d2a95e1f7a0c0bbb97b799d28b7de3eba65", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 129, "deletions": 11, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=5aa734d6a1946e526832bb602e1bb271bf26c0b1", "patch": "@@ -20,29 +20,147 @@ use ast;\n use codemap::span;\n use ext::base;\n use ext::base::*;\n+use parse;\n+use parse::token;\n+\n+enum State {\n+    Asm,\n+    Outputs,\n+    Inputs,\n+    Clobbers,\n+    Options\n+}\n+\n+fn next_state(s: State) -> Option<State> {\n+    match s {\n+        Asm      => Some(Outputs),\n+        Outputs  => Some(Inputs),\n+        Inputs   => Some(Clobbers),\n+        Clobbers => Some(Options),\n+        Options  => None\n+    }\n+}\n \n pub fn expand_asm(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n-    let args = get_exprs_from_tts(cx, tts);\n-    if args.len() == 0 {\n-        cx.span_fatal(sp, \"ast! takes at least 1 argument.\");\n+\n+    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(),\n+                                       vec::from_slice(tts));\n+\n+    let mut asm = ~\"\";\n+    let mut outputs = ~[];\n+    let mut inputs = ~[];\n+    let mut cons = ~\"\";\n+    let mut volatile = false;\n+\n+    let mut state = Asm;\n+    loop outer: {\n+        \n+        match state {\n+            Asm => {\n+                asm = expr_to_str(cx, p.parse_expr(),\n+                                ~\"inline assembly must be a string literal.\");\n+            }\n+            Outputs => {\n+                while *p.token != token::EOF &&\n+                      *p.token != token::COLON &&\n+                      *p.token != token::MOD_SEP {\n+                    \n+                    if outputs.len() != 0 {\n+                        p.eat(&token::COMMA);\n+                    }\n+                    \n+                    let constraint = p.parse_str();\n+                    p.expect(&token::LPAREN);\n+                    let out = p.parse_expr();\n+                    p.expect(&token::RPAREN);\n+\n+                    outputs.push((constraint, out));\n+                }\n+            }\n+            Inputs => {\n+                while *p.token != token::EOF &&\n+                      *p.token != token::COLON &&\n+                      *p.token != token::MOD_SEP {\n+                    \n+                    if inputs.len() != 0 {\n+                        p.eat(&token::COMMA);\n+                    }\n+                    \n+                    let constraint = p.parse_str();\n+                    p.expect(&token::LPAREN);\n+                    let in = p.parse_expr();\n+                    p.expect(&token::RPAREN);\n+\n+                    inputs.push((constraint, in));\n+                }\n+            }\n+            Clobbers => {\n+                let mut clobs = ~[];\n+                while *p.token != token::EOF &&\n+                      *p.token != token::COLON &&\n+                      *p.token != token::MOD_SEP {\n+                    \n+                    if clobs.len() != 0 {\n+                        p.eat(&token::COMMA);\n+                    }\n+                    \n+                    let clob = ~\"~{\" + *p.parse_str() + ~\"}\";\n+                    clobs.push(clob);\n+                }\n+\n+                cons = str::connect(clobs, \",\");\n+            }\n+            Options => {\n+                let option = *p.parse_str();\n+                \n+                if option == ~\"volatile\" {\n+                    volatile = true;\n+                }\n+\n+                if *p.token == token::COMMA {\n+                    p.eat(&token::COMMA);\n+                }\n+            }\n+        }\n+\n+        while *p.token == token::COLON   ||\n+              *p.token == token::MOD_SEP ||\n+              *p.token == token::EOF {\n+            state = if *p.token == token::COLON {\n+                p.bump();\n+                match next_state(state) {\n+                    Some(x) => x,\n+                    None    => break outer\n+                }\n+            } else if *p.token == token::MOD_SEP {\n+                p.bump();\n+                let s = match next_state(state) {\n+                    Some(x) => x,\n+                    None    => break outer\n+                };\n+                match next_state(s) {\n+                    Some(x) => x,\n+                    None    => break outer\n+                }\n+            } else if *p.token == token::EOF {\n+                break outer;\n+            } else {\n+               state \n+            };\n+        }\n     }\n-    let asm =\n-        expr_to_str(cx, args[0],\n-                    ~\"inline assembly must be a string literal.\");\n-    let cons = if args.len() > 1 {\n-        expr_to_str(cx, args[1],\n-                    ~\"constraints must be a string literal.\")\n-    } else { ~\"\" };\n \n     MRExpr(@ast::expr {\n         id: cx.next_id(),\n         callee_id: cx.next_id(),\n-        node: ast::expr_inline_asm(@asm, @cons),\n+        node: ast::expr_inline_asm(@asm, @cons, volatile),\n         span: sp\n     })\n }\n \n+\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "6b1a72b92fff44cd92329078c49fdbd80b07cd82", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa734d6a1946e526832bb602e1bb271bf26c0b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5aa734d6a1946e526832bb602e1bb271bf26c0b1", "patch": "@@ -1398,8 +1398,12 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n           }\n         }\n       }\n-      ast::expr_inline_asm(a, c) => {\n-        word(s.s, ~\"__asm__\");\n+      ast::expr_inline_asm(a, c, v) => {\n+        if v {\n+            word(s.s, ~\"__volatile__ asm!\");\n+        } else {\n+            word(s.s, ~\"asm!\");\n+        }\n         popen(s);\n         print_string(s, *a);\n         word_space(s, ~\",\");"}]}