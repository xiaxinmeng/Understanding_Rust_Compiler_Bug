{"sha": "97076c074d72bb2787bb48093b1607902d8bc894", "node_id": "C_kwDOAAsO6NoAKDk3MDc2YzA3NGQ3MmJiMjc4N2JiNDgwOTNiMTYwNzkwMmQ4YmM4OTQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-06T02:49:54Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-06T02:49:54Z"}, "message": "internal: Simplify and optimize syntax_highlighting", "tree": {"sha": "5e024cc79a1460e1e77ec2d50d7082374dde7acf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e024cc79a1460e1e77ec2d50d7082374dde7acf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97076c074d72bb2787bb48093b1607902d8bc894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97076c074d72bb2787bb48093b1607902d8bc894", "html_url": "https://github.com/rust-lang/rust/commit/97076c074d72bb2787bb48093b1607902d8bc894", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97076c074d72bb2787bb48093b1607902d8bc894/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8edbb5d6fa43db893fc5eb2a3c75b7b23713919", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8edbb5d6fa43db893fc5eb2a3c75b7b23713919", "html_url": "https://github.com/rust-lang/rust/commit/e8edbb5d6fa43db893fc5eb2a3c75b7b23713919"}], "stats": {"total": 351, "additions": 184, "deletions": 167}, "files": [{"sha": "0119ba5cb7794b855375f061340c9d9cda8bcf78", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 72, "deletions": 53, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -241,19 +241,26 @@ fn traverse(\n                     current_macro = Some(mac.into());\n                     continue;\n                 }\n-                Some(item) if sema.is_attr_macro_call(&item) => current_attr_call = Some(item),\n-                Some(item) if current_attr_call.is_none() => {\n-                    let adt = match item {\n-                        ast::Item::Enum(it) => Some(ast::Adt::Enum(it)),\n-                        ast::Item::Struct(it) => Some(ast::Adt::Struct(it)),\n-                        ast::Item::Union(it) => Some(ast::Adt::Union(it)),\n-                        _ => None,\n-                    };\n-                    match adt {\n-                        Some(adt) if sema.is_derive_annotated(&adt) => {\n-                            current_derive_call = Some(ast::Item::from(adt));\n+                Some(item) => {\n+                    if matches!(node.kind(), FN | CONST | STATIC) {\n+                        bindings_shadow_count.clear();\n+                    }\n+\n+                    if sema.is_attr_macro_call(&item) {\n+                        current_attr_call = Some(item);\n+                    } else if current_attr_call.is_none() {\n+                        let adt = match item {\n+                            ast::Item::Enum(it) => Some(ast::Adt::Enum(it)),\n+                            ast::Item::Struct(it) => Some(ast::Adt::Struct(it)),\n+                            ast::Item::Union(it) => Some(ast::Adt::Union(it)),\n+                            _ => None,\n+                        };\n+                        match adt {\n+                            Some(adt) if sema.is_derive_annotated(&adt) => {\n+                                current_derive_call = Some(ast::Item::from(adt));\n+                            }\n+                            _ => (),\n                         }\n-                        _ => (),\n                     }\n                 }\n                 None if ast::Attr::can_cast(node.kind()) => inside_attribute = true,\n@@ -291,6 +298,8 @@ fn traverse(\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(NodeOrToken::Token(_)) => continue,\n             WalkEvent::Leave(NodeOrToken::Node(node)) => {\n+                // Doc comment highlighting injection, we do this when leaving the node\n+                // so that we overwrite the highlighting of the doc comment itself.\n                 inject::doc_comment(hl, sema, InFile::new(file_id.into(), &node));\n                 continue;\n             }\n@@ -302,57 +311,68 @@ fn traverse(\n             }\n         }\n \n-        // only attempt to descend if we are inside a macro call or attribute\n-        // as calling `descend_into_macros_single` gets rather expensive if done for every single token\n-        // additionally, do not descend into comments, descending maps down to doc attributes which get\n-        // tagged as string literals.\n-        let descend_token = (current_macro_call.is_some()\n-            || current_attr_call.is_some()\n-            || current_derive_call.is_some())\n-            && element.kind() != COMMENT;\n-        let element_to_highlight = if descend_token {\n-            let token = match &element {\n-                NodeOrToken::Node(_) => continue,\n-                NodeOrToken::Token(tok) => tok.clone(),\n-            };\n-            let in_mcall_outside_tt = current_attr_call.is_none()\n-                && token.parent().as_ref().map(SyntaxNode::kind) != Some(TOKEN_TREE);\n-            let token = match in_mcall_outside_tt {\n-                // not in the macros/derives token tree, don't attempt to descend\n-                true => token,\n-                false => sema.descend_into_macros_single(token),\n-            };\n-            match token.parent() {\n-                Some(parent) => {\n-                    // Names and NameRefs have special semantics, use them instead of the tokens\n-                    // as otherwise we won't ever visit them\n-                    match (token.kind(), parent.kind()) {\n-                        (T![ident], NAME | NAME_REF) => parent.into(),\n-                        (T![self] | T![super] | T![crate] | T![Self], NAME_REF) => parent.into(),\n-                        (INT_NUMBER, NAME_REF) => parent.into(),\n-                        (LIFETIME_IDENT, LIFETIME) => parent.into(),\n-                        _ => token.into(),\n+        let element = match element.clone() {\n+            NodeOrToken::Node(n) => match ast::NameLike::cast(n) {\n+                Some(n) => NodeOrToken::Node(n),\n+                None => continue,\n+            },\n+            NodeOrToken::Token(t) => NodeOrToken::Token(t),\n+        };\n+        let token = element.as_token().cloned();\n+\n+        // Descending tokens into macros is expensive even if no descending occurs, so make sure\n+        // that we actually are in a position where descending is possible.\n+        let in_macro = current_macro_call.is_some()\n+            || current_derive_call.is_some()\n+            || current_attr_call.is_some();\n+        let descended_element = if in_macro {\n+            // Attempt to descend tokens into macro-calls.\n+            match element {\n+                NodeOrToken::Token(token) if token.kind() != COMMENT => {\n+                    // For function-like macro calls and derive attributes, only attempt to descend if\n+                    // we are inside their token-trees.\n+                    let in_tt = current_attr_call.is_some()\n+                        || token.parent().as_ref().map(SyntaxNode::kind) == Some(TOKEN_TREE);\n+\n+                    if in_tt {\n+                        let token = sema.descend_into_macros_single(token);\n+                        match token.parent().and_then(ast::NameLike::cast) {\n+                            // Remap the token into the wrapping single token nodes\n+                            // FIXME: if the node doesn't resolve, we also won't do token based highlighting!\n+                            Some(parent) => match (token.kind(), parent.syntax().kind()) {\n+                                (T![self] | T![ident], NAME | NAME_REF) => {\n+                                    NodeOrToken::Node(parent)\n+                                }\n+                                (T![self] | T![super] | T![crate] | T![Self], NAME_REF) => {\n+                                    NodeOrToken::Node(parent)\n+                                }\n+                                (INT_NUMBER, NAME_REF) => NodeOrToken::Node(parent),\n+                                (LIFETIME_IDENT, LIFETIME) => NodeOrToken::Node(parent),\n+                                _ => NodeOrToken::Token(token),\n+                            },\n+                            None => NodeOrToken::Token(token),\n+                        }\n+                    } else {\n+                        NodeOrToken::Token(token)\n                     }\n                 }\n-                None => token.into(),\n+                e => e,\n             }\n         } else {\n-            element.clone()\n+            element\n         };\n \n         // FIXME: do proper macro def highlighting https://github.com/rust-analyzer/rust-analyzer/issues/6232\n         // Skip metavariables from being highlighted to prevent keyword highlighting in them\n-        if macro_highlighter.highlight(&element_to_highlight).is_some() {\n+        if descended_element.as_token().and_then(|t| macro_highlighter.highlight(t)).is_some() {\n             continue;\n         }\n \n         // string highlight injections, note this does not use the descended element as proc-macros\n         // can rewrite string literals which invalidates our indices\n-        if let (Some(token), Some(token_to_highlight)) =\n-            (element.into_token(), element_to_highlight.as_token())\n-        {\n+        if let (Some(token), Some(descended_token)) = (token, descended_element.as_token()) {\n             let string = ast::String::cast(token);\n-            let string_to_highlight = ast::String::cast(token_to_highlight.clone());\n+            let string_to_highlight = ast::String::cast(descended_token.clone());\n             if let Some((string, expanded_string)) = string.zip(string_to_highlight) {\n                 if string.is_raw() {\n                     if inject::ra_fixture(hl, sema, &string, &expanded_string).is_some() {\n@@ -377,14 +397,13 @@ fn traverse(\n             }\n         }\n \n-        // do the normal highlighting\n-        let element = match element_to_highlight {\n-            NodeOrToken::Node(node) => highlight::node(\n+        let element = match descended_element {\n+            NodeOrToken::Node(name_like) => highlight::name_like(\n                 sema,\n                 krate,\n                 &mut bindings_shadow_count,\n                 syntactic_name_ref_highlighting,\n-                node,\n+                name_like,\n             ),\n             NodeOrToken::Token(token) => highlight::token(sema, token).zip(Some(None)),\n         };"}, {"sha": "b98fa1ab39246850570738e335250eb3d428ec98", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -2,7 +2,7 @@\n \n use hir::{AsAssocItem, HasVisibility, Semantics};\n use ide_db::{\n-    defs::{Definition, NameClass, NameRefClass},\n+    defs::{Definition, IdentClass, NameClass, NameRefClass},\n     helpers::FamousDefs,\n     RootDatabase, SymbolKind,\n };\n@@ -47,52 +47,36 @@ pub(super) fn token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Optio\n     Some(highlight)\n }\n \n-pub(super) fn node(\n+pub(super) fn name_like(\n     sema: &Semantics<RootDatabase>,\n     krate: Option<hir::Crate>,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     syntactic_name_ref_highlighting: bool,\n-    node: SyntaxNode,\n+    name_like: ast::NameLike,\n ) -> Option<(Highlight, Option<u64>)> {\n     let mut binding_hash = None;\n-    let highlight = match_ast! {\n-        match node {\n-            ast::NameRef(name_ref) => {\n-                highlight_name_ref(\n-                    sema,\n-                    krate,\n-                    bindings_shadow_count,\n-                    &mut binding_hash,\n-                    syntactic_name_ref_highlighting,\n-                    name_ref,\n-                )\n-            },\n-            ast::Name(name) => {\n-                highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n-            },\n-            ast::Lifetime(lifetime) => {\n-                match NameClass::classify_lifetime(sema, &lifetime) {\n-                    Some(NameClass::Definition(def)) => {\n-                        highlight_def(sema, krate, def) | HlMod::Definition\n-                    }\n-                    None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n-                        Some(NameRefClass::Definition(def)) => highlight_def(sema, krate, def),\n-                        _ => SymbolKind::LifetimeParam.into(),\n-                    },\n-                    _ => Highlight::from(SymbolKind::LifetimeParam) | HlMod::Definition,\n-                }\n-            },\n-            ast::Fn(_) => {\n-                bindings_shadow_count.clear();\n-                return None;\n-            },\n-            _ => {\n-                if [FN, CONST, STATIC].contains(&node.kind()) {\n-                    bindings_shadow_count.clear();\n-                }\n-                return None\n-            },\n+    let highlight = match name_like {\n+        ast::NameLike::NameRef(name_ref) => highlight_name_ref(\n+            sema,\n+            krate,\n+            bindings_shadow_count,\n+            &mut binding_hash,\n+            syntactic_name_ref_highlighting,\n+            name_ref,\n+        ),\n+        ast::NameLike::Name(name) => {\n+            highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n         }\n+        ast::NameLike::Lifetime(lifetime) => match IdentClass::classify_lifetime(sema, &lifetime) {\n+            Some(IdentClass::NameClass(NameClass::Definition(def))) => {\n+                highlight_def(sema, krate, def) | HlMod::Definition\n+            }\n+            Some(IdentClass::NameRefClass(NameRefClass::Definition(def))) => {\n+                highlight_def(sema, krate, def)\n+            }\n+            // FIXME: Fallback for 'static and '_, as we do not resolve these yet\n+            _ => SymbolKind::LifetimeParam.into(),\n+        },\n     };\n     Some((highlight, binding_hash))\n }"}, {"sha": "774934a24987521d9ff880036e3432af73f8c507", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -9,7 +9,7 @@ use ide_db::{\n     SymbolKind,\n };\n use syntax::{\n-    ast::{self, AstNode, IsString},\n+    ast::{self, AstNode, IsString, QuoteOffsets},\n     AstToken, NodeOrToken, SyntaxNode, TextRange, TextSize,\n };\n \n@@ -61,7 +61,7 @@ pub(super) fn ra_fixture(\n         }\n     }\n \n-    let (analysis, tmp_file_id) = Analysis::from_single_file(inj.text().to_string());\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());\n \n     for mut hl_range in analysis.highlight(tmp_file_id).unwrap() {\n         for range in inj.map_range_up(hl_range.range) {\n@@ -85,31 +85,19 @@ const RUSTDOC_FENCE: &'static str = \"```\";\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n     sema: &Semantics<RootDatabase>,\n-    node: InFile<&SyntaxNode>,\n+    InFile { file_id: src_file_id, value: node }: InFile<&SyntaxNode>,\n ) {\n-    let (attributes, def) = match doc_attributes(sema, node.value) {\n+    let (attributes, def) = match doc_attributes(sema, node) {\n         Some(it) => it,\n         None => return,\n     };\n \n-    let mut inj = Injector::default();\n-    inj.add_unmapped(\"fn doctest() {\\n\");\n-\n-    let attrs_source_map = attributes.source_map(sema.db);\n-\n-    let mut is_codeblock = false;\n-    let mut is_doctest = false;\n-\n-    // Replace the original, line-spanning comment ranges by new, only comment-prefix\n-    // spanning comment ranges.\n-    let mut new_comments = Vec::new();\n-    let mut string;\n-\n+    // Extract intra-doc links and emit highlights for them.\n     if let Some((docs, doc_mapping)) = attributes.docs_with_rangemap(sema.db) {\n         extract_definitions_from_docs(&docs)\n             .into_iter()\n             .filter_map(|(range, link, ns)| {\n-                doc_mapping.map(range).filter(|mapping| mapping.file_id == node.file_id).and_then(\n+                doc_mapping.map(range).filter(|mapping| mapping.file_id == src_file_id).and_then(\n                     |InFile { value: mapped_range, .. }| {\n                         Some(mapped_range).zip(resolve_doc_path_for_def(sema.db, def, &link, ns))\n                     },\n@@ -127,40 +115,57 @@ pub(super) fn doc_comment(\n             });\n     }\n \n+    // Extract doc-test sources from the docs and calculate highlighting for them.\n+\n+    let mut inj = Injector::default();\n+    inj.add_unmapped(\"fn doctest() {\\n\");\n+\n+    let attrs_source_map = attributes.source_map(sema.db);\n+\n+    let mut is_codeblock = false;\n+    let mut is_doctest = false;\n+\n+    let mut new_comments = Vec::new();\n+    let mut string;\n+\n     for attr in attributes.by_key(\"doc\").attrs() {\n         let InFile { file_id, value: src } = attrs_source_map.source_of(attr);\n-        if file_id != node.file_id {\n+        if file_id != src_file_id {\n             continue;\n         }\n-        let (line, range, prefix) = match &src {\n+        let (line, range) = match &src {\n             Either::Left(it) => {\n                 string = match find_doc_string_in_attr(attr, it) {\n                     Some(it) => it,\n                     None => continue,\n                 };\n-                let text_range = string.syntax().text_range();\n-                let text_range = TextRange::new(\n-                    text_range.start() + TextSize::from(1),\n-                    text_range.end() - TextSize::from(1),\n-                );\n                 let text = string.text();\n-                (&text[1..text.len() - 1], text_range, \"\")\n+                let text_range = string.syntax().text_range();\n+                match string.quote_offsets() {\n+                    Some(QuoteOffsets { contents, .. }) => {\n+                        (&text[contents - text_range.start()], contents)\n+                    }\n+                    None => (text, text_range),\n+                }\n             }\n             Either::Right(comment) => {\n-                (comment.text(), comment.syntax().text_range(), comment.prefix())\n+                let value = comment.prefix().len();\n+                let range = comment.syntax().text_range();\n+                (\n+                    &comment.text()[value..],\n+                    TextRange::new(range.start() + TextSize::try_from(value).unwrap(), range.end()),\n+                )\n             }\n         };\n \n-        let mut pos = TextSize::from(prefix.len() as u32);\n         let mut range_start = range.start();\n         for line in line.split('\\n') {\n             let line_len = TextSize::from(line.len() as u32);\n             let prev_range_start = {\n                 let next_range_start = range_start + line_len + TextSize::from(1);\n                 mem::replace(&mut range_start, next_range_start)\n             };\n-            // only first line has the prefix so take it away for future iterations\n-            let mut pos = mem::take(&mut pos);\n+            let mut pos = TextSize::from(0);\n \n             match line.find(RUSTDOC_FENCE) {\n                 Some(idx) => {\n@@ -196,13 +201,13 @@ pub(super) fn doc_comment(\n \n     inj.add_unmapped(\"\\n}\");\n \n-    let (analysis, tmp_file_id) = Analysis::from_single_file(inj.text().to_string());\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());\n \n-    for HlRange { range, highlight, binding_hash } in\n-        analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)).unwrap()\n-    {\n-        for range in inj.map_range_up(range) {\n-            hl.add(HlRange { range, highlight: highlight | HlMod::Injected, binding_hash });\n+    if let Ok(ranges) = analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)) {\n+        for HlRange { range, highlight, binding_hash } in ranges {\n+            for range in inj.map_range_up(range) {\n+                hl.add(HlRange { range, highlight: highlight | HlMod::Injected, binding_hash });\n+            }\n         }\n     }\n "}, {"sha": "a902fd717f0990cc3071e2d96ea1bc3fd8136992", "filename": "crates/ide/src/syntax_highlighting/injector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -29,8 +29,8 @@ impl Injector {\n         self.buf.push_str(text);\n     }\n \n-    pub(super) fn text(&self) -> &str {\n-        &self.buf\n+    pub(super) fn take_text(&mut self) -> String {\n+        std::mem::take(&mut self.buf)\n     }\n \n     pub(super) fn map_range_up(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {"}, {"sha": "1099d9c23b7212812f205fffd74310bb2952d5d1", "filename": "crates/ide/src/syntax_highlighting/macro_.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_.rs?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -1,5 +1,5 @@\n //! Syntax highlighting for macro_rules!.\n-use syntax::{SyntaxElement, SyntaxKind, SyntaxToken, TextRange, T};\n+use syntax::{SyntaxKind, SyntaxToken, TextRange, T};\n \n use crate::{HlRange, HlTag};\n \n@@ -19,10 +19,10 @@ impl MacroHighlighter {\n         }\n     }\n \n-    pub(super) fn highlight(&self, element: &SyntaxElement) -> Option<HlRange> {\n+    pub(super) fn highlight(&self, token: &SyntaxToken) -> Option<HlRange> {\n         if let Some(state) = self.state.as_ref() {\n             if matches!(state.rule_state, RuleState::Matcher | RuleState::Expander) {\n-                if let Some(range) = is_metavariable(element) {\n+                if let Some(range) = is_metavariable(token) {\n                     return Some(HlRange {\n                         range,\n                         highlight: HlTag::UnresolvedReference.into(),\n@@ -115,12 +115,11 @@ fn update_macro_state(state: &mut MacroMatcherParseState, tok: &SyntaxToken) {\n     }\n }\n \n-fn is_metavariable(element: &SyntaxElement) -> Option<TextRange> {\n-    let tok = element.as_token()?;\n-    match tok.kind() {\n+fn is_metavariable(token: &SyntaxToken) -> Option<TextRange> {\n+    match token.kind() {\n         kind if kind == SyntaxKind::IDENT || kind.is_keyword() => {\n-            if let Some(_dollar) = tok.prev_token().filter(|t| t.kind() == T![$]) {\n-                return Some(tok.text_range());\n+            if let Some(_dollar) = token.prev_token().filter(|t| t.kind() == T![$]) {\n+                return Some(token.text_range());\n             }\n         }\n         _ => (),"}, {"sha": "96044751b81d8ed69164d1f95ab68708eb581b9f", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -43,13 +43,13 @@\n </style>\n <pre><code><span class=\"comment documentation\">//! This is a module to test doc injection.</span>\n <span class=\"comment documentation\">//! ```</span>\n-<span class=\"comment documentation\">//! </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">test</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span>\n+<span class=\"comment documentation\">//!</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">test</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span>\n <span class=\"comment documentation\">//! ```</span>\n \n <span class=\"keyword\">mod</span> <span class=\"module declaration\">outline_module</span><span class=\"semicolon\">;</span>\n \n <span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"early doctests should not go boom\"</span><span class=\"semicolon injected\">;</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"early doctests should not go boom\"</span><span class=\"semicolon injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> <span class=\"brace\">{</span>\n     <span class=\"field declaration\">bar</span><span class=\"colon\">:</span> <span class=\"builtin_type\">bool</span><span class=\"comma\">,</span>\n@@ -58,15 +58,15 @@\n <span class=\"comment documentation\">/// This is an impl with a code block.</span>\n <span class=\"comment documentation\">///</span>\n <span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>\n <span class=\"comment documentation\">///</span>\n-<span class=\"comment documentation\">/// </span><span class=\"brace injected\">}</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"brace injected\">}</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">impl</span> <span class=\"struct\">Foo</span> <span class=\"brace\">{</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"Call me</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"Call me</span>\n     <span class=\"comment\">//    KILLER WHALE</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">    Ishmael.\"</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"string_literal injected\">    Ishmael.\"</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"constant associated declaration public\">bar</span><span class=\"colon\">:</span> <span class=\"builtin_type\">bool</span> <span class=\"operator\">=</span> <span class=\"bool_literal\">true</span><span class=\"semicolon\">;</span>\n \n@@ -75,8 +75,8 @@\n     <span class=\"comment documentation\">/// # Examples</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// #</span><span class=\"none injected\"> </span><span class=\"attribute_bracket attribute injected\">#</span><span class=\"attribute_bracket attribute injected\">!</span><span class=\"attribute_bracket attribute injected\">[</span><span class=\"builtin_attr attribute injected library\">allow</span><span class=\"parenthesis attribute injected\">(</span><span class=\"none attribute injected\">unused_mut</span><span class=\"parenthesis attribute injected\">)</span><span class=\"attribute_bracket attribute injected\">]</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"keyword injected\">mut</span><span class=\"none injected\"> </span><span class=\"variable declaration injected mutable\">foo</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> #</span><span class=\"none injected\"> </span><span class=\"attribute_bracket attribute injected\">#</span><span class=\"attribute_bracket attribute injected\">!</span><span class=\"attribute_bracket attribute injected\">[</span><span class=\"builtin_attr attribute injected library\">allow</span><span class=\"parenthesis attribute injected\">(</span><span class=\"none attribute injected\">unused_mut</span><span class=\"parenthesis attribute injected\">)</span><span class=\"attribute_bracket attribute injected\">]</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"keyword injected\">mut</span><span class=\"none injected\"> </span><span class=\"variable declaration injected mutable\">foo</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public static\">new</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"struct\">Foo</span> <span class=\"brace\">{</span>\n         <span class=\"struct\">Foo</span> <span class=\"brace\">{</span> <span class=\"field\">bar</span><span class=\"colon\">:</span> <span class=\"bool_literal\">true</span> <span class=\"brace\">}</span>\n@@ -87,33 +87,33 @@\n     <span class=\"comment documentation\">/// # Examples</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">use</span><span class=\"none injected\"> </span><span class=\"module injected\">x</span><span class=\"operator injected\">::</span><span class=\"module injected\">y</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">use</span><span class=\"none injected\"> </span><span class=\"module injected\">x</span><span class=\"operator injected\">::</span><span class=\"module injected\">y</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foo</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foo</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">// calls bar on foo</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"macro injected\">assert</span><span class=\"macro_bang injected\">!</span><span class=\"parenthesis injected\">(</span><span class=\"none injected\">foo</span><span class=\"operator injected\">.</span><span class=\"none injected\">bar</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"comment injected\">// calls bar on foo</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"macro injected\">assert</span><span class=\"macro_bang injected\">!</span><span class=\"parenthesis injected\">(</span><span class=\"none injected\">foo</span><span class=\"operator injected\">.</span><span class=\"none injected\">bar</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">bar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"variable injected\">foo</span><span class=\"operator injected\">.</span><span class=\"field injected\">bar</span><span class=\"none injected\"> </span><span class=\"logical injected\">||</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"constant injected\">bar</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">bar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"variable injected\">foo</span><span class=\"operator injected\">.</span><span class=\"field injected\">bar</span><span class=\"none injected\"> </span><span class=\"logical injected\">||</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"constant injected\">bar</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">/* multi-line</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">       comment */</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"comment injected\">/* multi-line</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"comment injected\">       comment */</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected reference\">multi_line_string</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"Foo</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">  bar</span><span class=\"escape_sequence injected\">\\n</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">         \"</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected reference\">multi_line_string</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"Foo</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"string_literal injected\">  bar</span><span class=\"escape_sequence injected\">\\n</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"string_literal injected\">         \"</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```rust,no_run</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">// functions</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"angle injected\">&lt;</span><span class=\"type_param declaration injected\">T</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"keyword injected\">const</span><span class=\"none injected\"> </span><span class=\"const_param declaration injected\">X</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"builtin_type injected\">usize</span><span class=\"angle injected\">&gt;</span><span class=\"parenthesis injected\">(</span><span class=\"value_param declaration injected\">arg</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"builtin_type injected\">i32</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"none injected\">    </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">x</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"type_param injected\">T</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"const_param injected\">X</span><span class=\"semicolon injected\">;</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"brace injected\">}</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"comment injected\">// functions</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"angle injected\">&lt;</span><span class=\"type_param declaration injected\">T</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"keyword injected\">const</span><span class=\"none injected\"> </span><span class=\"const_param declaration injected\">X</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"builtin_type injected\">usize</span><span class=\"angle injected\">&gt;</span><span class=\"parenthesis injected\">(</span><span class=\"value_param declaration injected\">arg</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"builtin_type injected\">i32</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"none injected\">    </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">x</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"type_param injected\">T</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"const_param injected\">X</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"brace injected\">}</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```sh</span>\n@@ -138,8 +138,8 @@\n <span class=\"brace\">}</span>\n \n <span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">macro_rules</span><span class=\"punctuation injected\">!</span><span class=\"none injected\"> </span><span class=\"macro declaration injected\">noop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"none injected\"> </span><span class=\"parenthesis injected\">(</span><span class=\"punctuation injected\">$</span><span class=\"none injected\">expr</span><span class=\"colon injected\">:</span><span class=\"none injected\">expr</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"angle injected\">&gt;</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">$</span><span class=\"none injected\">expr </span><span class=\"brace injected\">}</span><span class=\"brace injected\">}</span>\n-<span class=\"comment documentation\">/// </span><span class=\"macro injected\">noop</span><span class=\"macro_bang injected\">!</span><span class=\"parenthesis injected\">(</span><span class=\"numeric_literal injected\">1</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">macro_rules</span><span class=\"punctuation injected\">!</span><span class=\"none injected\"> </span><span class=\"macro declaration injected\">noop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"none injected\"> </span><span class=\"parenthesis injected\">(</span><span class=\"punctuation injected\">$</span><span class=\"none injected\">expr</span><span class=\"colon injected\">:</span><span class=\"none injected\">expr</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"angle injected\">&gt;</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">$</span><span class=\"none injected\">expr </span><span class=\"brace injected\">}</span><span class=\"brace injected\">}</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"macro injected\">noop</span><span class=\"macro_bang injected\">!</span><span class=\"parenthesis injected\">(</span><span class=\"numeric_literal injected\">1</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">macro_rules</span><span class=\"punctuation\">!</span> <span class=\"macro declaration\">noop</span> <span class=\"brace\">{</span>\n     <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>expr<span class=\"colon\">:</span>expr<span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"brace\">{</span>\n@@ -148,18 +148,18 @@\n <span class=\"brace\">}</span>\n \n <span class=\"comment documentation\">/// ```rust</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"function injected\">example</span><span class=\"parenthesis injected\">(</span><span class=\"operator injected\">&</span><span class=\"bracket injected\">[</span><span class=\"numeric_literal injected\">1</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">2</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">3</span><span class=\"bracket injected\">]</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"function injected\">example</span><span class=\"parenthesis injected\">(</span><span class=\"operator injected\">&</span><span class=\"bracket injected\">[</span><span class=\"numeric_literal injected\">1</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">2</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">3</span><span class=\"bracket injected\">]</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">///</span>\n <span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span>\n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">not</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"false\"</span><span class=\"parenthesis attribute\">)</span><span class=\"comma attribute\">,</span> <span class=\"none attribute\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"</span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span><span class=\"string_literal attribute\">\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"</span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span><span class=\"string_literal attribute\">\"</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">///</span>\n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"alloc\"</span><span class=\"comma attribute\">,</span> <span class=\"none attribute\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"```rust\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">not</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"alloc\"</span><span class=\"parenthesis attribute\">)</span><span class=\"comma attribute\">,</span> <span class=\"none attribute\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"```ignore\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"function injected\">example</span><span class=\"parenthesis injected\">(</span><span class=\"operator injected\">&</span><span class=\"module injected\">alloc</span><span class=\"operator injected\">::</span><span class=\"macro injected\">vec</span><span class=\"macro_bang injected\">!</span><span class=\"bracket injected\">[</span><span class=\"numeric_literal injected\">1</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">2</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">3</span><span class=\"bracket injected\">]</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n+<span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"function injected\">example</span><span class=\"parenthesis injected\">(</span><span class=\"operator injected\">&</span><span class=\"module injected\">alloc</span><span class=\"operator injected\">::</span><span class=\"macro injected\">vec</span><span class=\"macro_bang injected\">!</span><span class=\"bracket injected\">[</span><span class=\"numeric_literal injected\">1</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">2</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">3</span><span class=\"bracket injected\">]</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration public\">mix_and_match</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n "}, {"sha": "9d05db4a77cc1c8381805f4cf35a24e0d1446c13", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97076c074d72bb2787bb48093b1607902d8bc894/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=97076c074d72bb2787bb48093b1607902d8bc894", "patch": "@@ -116,6 +116,7 @@ impl Definition {\n     }\n }\n \n+#[derive(Debug)]\n pub enum IdentClass {\n     NameClass(NameClass),\n     NameRefClass(NameRefClass),\n@@ -145,6 +146,15 @@ impl IdentClass {\n         Self::classify_node(sema, &parent)\n     }\n \n+    pub fn classify_lifetime(\n+        sema: &Semantics<RootDatabase>,\n+        lifetime: &ast::Lifetime,\n+    ) -> Option<IdentClass> {\n+        NameClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameClass).or_else(|| {\n+            NameRefClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameRefClass)\n+        })\n+    }\n+\n     pub fn definitions(self) -> ArrayVec<Definition, 2> {\n         let mut res = ArrayVec::new();\n         match self {"}]}