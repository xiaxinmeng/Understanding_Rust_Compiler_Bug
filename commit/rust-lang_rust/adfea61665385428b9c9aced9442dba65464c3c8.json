{"sha": "adfea61665385428b9c9aced9442dba65464c3c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZmVhNjE2NjUzODU0MjhiOWM5YWNlZDk0NDJkYmE2NTQ2NGMzYzg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-28T14:48:43Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Allow machines to create new memory kinds", "tree": {"sha": "d0b1bf5d67af2175cf65737c60be83c57ef8fdb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0b1bf5d67af2175cf65737c60be83c57ef8fdb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adfea61665385428b9c9aced9442dba65464c3c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19mrWw//cSZe5rnbcWfClo4c0qJisFNNmMqFjzKGcqIs7R8PgEDf7OXa5tJ5uYDg\nOcLghjin/1P/zWjmfsAKKj8VtAk3OhysXVxJnx8f8w6MK8PTwLzdsiXrE/4/JCjf\nFuW6QWu1rbZwPjLdAemPgiwGzduPQZOrTm/0w9izDf6MY41ZK7ygPq1A19krHh5i\nDCIRyjWnJnlCBVCDuCSbo9LHsAUht68THIXf72/o3CQ3CSg2upN7moHQf8XOVwx3\nKKSCdLXYaxxhWvXRSC6WYSv1P4aB3dcCAmVz2aGhmwDspXIpfrQhdfQ0YBdHLSjn\nrEsmDm1yO216pelc/2HV254sLBp1IYP+EL39euxSjLvYo5CIHudrW9RMAYYYwbSL\nlmVU9Jeq5run9teM9/ObPC1UUDHJThT43yUs6l+JJGEAlRRqiBnCmXqEik4OvHX+\nVknXHxoS7dNnxwqImb84dqGfR1RZi5lwmaOmJaxYQk6X8cWdrbfNLay/JZOX/amd\nck4/yEIai20Jg/EJfkGSUPEQ2nKVthzkG4lC4k4xXvTsqeJDOA8JNw3VlTaq2ZTm\nsLFWqYLxNih9h0xtfSxG2+zHfYESbf8DLPh0z3G9DfMeO678xDScvIou+WBcUCbI\nPZYDd6osm7diGhKAFPJv6UqDEIX6GAJoVIkHz/JY1+uaTYAUbbU=\n=YBYj\n-----END PGP SIGNATURE-----", "payload": "tree d0b1bf5d67af2175cf65737c60be83c57ef8fdb3\nparent 7ed706d09c68469a7540f01efbfa5c4f6e3603b9\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501253323 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nAllow machines to create new memory kinds\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adfea61665385428b9c9aced9442dba65464c3c8", "html_url": "https://github.com/rust-lang/rust/commit/adfea61665385428b9c9aced9442dba65464c3c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adfea61665385428b9c9aced9442dba65464c3c8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ed706d09c68469a7540f01efbfa5c4f6e3603b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed706d09c68469a7540f01efbfa5c4f6e3603b9", "html_url": "https://github.com/rust-lang/rust/commit/7ed706d09c68469a7540f01efbfa5c4f6e3603b9"}], "stats": {"total": 193, "additions": 131, "deletions": 62}, "files": [{"sha": "cf3464ce3af3100f1d1c51a9269f07f34959d260", "filename": "miri/fn_call.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -15,6 +15,8 @@ use super::{\n     MemoryExt,\n };\n \n+use super::memory::Kind;\n+\n pub trait EvalContextExt<'tcx> {\n     fn call_c_abi(\n         &mut self,\n@@ -110,15 +112,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n+                    let ptr = self.memory.allocate(size, align, Kind::C.into())?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C.into())?;\n                 }\n             }\n \n@@ -242,7 +244,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n+                        self.memory.deallocate(var, None, Kind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -265,12 +267,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env.into())?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n+                        self.memory.deallocate(var, None, Kind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -491,7 +493,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n@@ -503,7 +505,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n@@ -517,7 +519,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust.into())?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n@@ -534,7 +536,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !new_align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n "}, {"sha": "89985593bc7bf8aaa8fbab0d95ab4c294558ca99", "filename": "miri/lib.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -32,6 +32,7 @@ mod fn_call;\n mod operator;\n mod intrinsic;\n mod helpers;\n+mod memory;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n@@ -278,6 +279,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n impl<'tcx> Machine<'tcx> for Evaluator {\n     type Data = EvaluatorData;\n     type MemoryData = MemoryData<'tcx>;\n+    type MemoryKinds = memory::Kind;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn eval_fn_call<'a>(\n@@ -313,4 +315,28 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n         ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n     }\n+\n+    fn mark_static_initialized(m: memory::Kind) -> EvalResult<'tcx> {\n+        use memory::Kind::*;\n+        match m {\n+            // FIXME: This could be allowed, but not for env vars set during miri execution\n+            Env => Err(EvalError::Unimplemented(\"statics can't refer to env vars\".to_owned())),\n+            _ => Ok(()),\n+        }\n+    }\n+\n+    fn box_alloc<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        let size = ecx.type_size(ty)?.expect(\"box only works with sized types\");\n+        let align = ecx.type_align(ty)?;\n+        if size == 0 {\n+            Ok(PrimVal::Bytes(align.into()))\n+        } else {\n+            ecx.memory\n+                .allocate(size, align, Kind::Machine(memory::Kind::Rust))\n+                .map(PrimVal::Ptr)\n+        }\n+    }\n }"}, {"sha": "55e6026280ca5cd2a3805093203f86103512e63b", "filename": "miri/memory.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/miri%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/miri%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fmemory.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -0,0 +1,16 @@\n+\n+#[derive(Debug, PartialEq, Copy, Clone)]\n+pub enum Kind {\n+    /// Error if deallocated any other way than `rust_deallocate`\n+    Rust,\n+    /// Error if deallocated any other way than `free`\n+    C,\n+    /// Part of env var emulation\n+    Env,\n+}\n+\n+impl Into<::rustc_miri::interpret::Kind<Kind>> for Kind {\n+    fn into(self) -> ::rustc_miri::interpret::Kind<Kind> {\n+        ::rustc_miri::interpret::Kind::Machine(self)\n+    }\n+}"}, {"sha": "8a0b6d5b6922e5218c141a11404360ba24de9650", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -128,6 +128,7 @@ impl Error for ConstEvalError {\n impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     type Data = ();\n     type MemoryData = ();\n+    type MemoryKinds = !;\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n@@ -185,4 +186,15 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n         Err(ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into())\n     }\n+\n+    fn mark_static_initialized(m: !) -> EvalResult<'tcx> {\n+        m\n+    }\n+\n+    fn box_alloc<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        Err(ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into())\n+    }\n }"}, {"sha": "7d62d59fcd79d2d0b038fc55820e27c83a3293ba", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -4,7 +4,7 @@ use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n \n use super::{\n-    MemoryPointer, Kind, LockInfo, AccessKind\n+    MemoryPointer, LockInfo, AccessKind\n };\n \n use rustc_const_math::ConstMathErr;\n@@ -88,8 +88,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedWrongMemoryKind(Kind, Kind),\n-    DeallocatedWrongMemoryKind(Kind, Kind),\n+    ReallocatedWrongMemoryKind(String, String),\n+    DeallocatedWrongMemoryKind(String, String),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation,\n@@ -262,10 +262,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n             ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n-            ReallocatedWrongMemoryKind(old, new) =>\n-                write!(f, \"tried to reallocate memory from {:?} to {:?}\", old, new),\n-            DeallocatedWrongMemoryKind(old, new) =>\n-                write!(f, \"tried to deallocate {:?} memory but gave {:?} as the kind\", old, new),\n+            ReallocatedWrongMemoryKind(ref old, ref new) =>\n+                write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n+            DeallocatedWrongMemoryKind(ref old, ref new) =>\n+                write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n             Math(span, ref err) =>\n                 write!(f, \"{:?} at {:?}\", err, span),\n             Intrinsic(ref err) =>"}, {"sha": "277e6e99e752cf23579ecc81e90f759bbd0a4a69", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -782,17 +782,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n-                // FIXME(CTFE): don't allow heap allocations in const eval\n-                // FIXME: call the `exchange_malloc` lang item if available\n-                let size = self.type_size(ty)?.expect(\"box only works with sized types\");\n-                if size == 0 {\n-                    let align = self.type_align(ty)?;\n-                    self.write_primval(dest, PrimVal::Bytes(align.into()), dest_ty)?;\n-                } else {\n-                    let align = self.type_align(ty)?;\n-                    let ptr = self.memory.allocate(size, align, MemoryKind::Rust)?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-                }\n+                let ptr = M::box_alloc(self, ty)?;\n+                self.write_primval(dest, ptr, dest_ty)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {"}, {"sha": "140bd946c78718aca9d97b2e12bbca8dd6b7e35c", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -21,6 +21,9 @@ pub trait Machine<'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n     type MemoryData;\n \n+    /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n+    type MemoryKinds: ::std::fmt::Debug + PartialEq + Copy + Clone;\n+\n     /// Entry point to all function calls.\n     ///\n     /// Returns Ok(true) when the function was handled completely\n@@ -61,5 +64,16 @@ pub trait Machine<'tcx>: Sized {\n         right: PrimVal,\n         right_ty: ty::Ty<'tcx>,\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+\n+    /// Called when trying to mark machine defined `MemoryKinds` as static\n+    fn mark_static_initialized(m: Self::MemoryKinds) -> EvalResult<'tcx>;\n+\n+    /// Heap allocations via the `box` keyword\n+    ///\n+    /// Returns a pointer to the allocated memory\n+    fn box_alloc<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal>;\n }\n "}, {"sha": "31e47e706ad33cc6e27a050402616809eb1a965e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -116,7 +116,7 @@ impl fmt::Display for AllocId {\n }\n \n #[derive(Debug)]\n-pub struct Allocation {\n+pub struct Allocation<M> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n@@ -132,12 +132,12 @@ pub struct Allocation {\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    pub kind: Kind,\n+    pub kind: Kind<M>,\n     /// Memory regions that are locked by some function\n     locks: BTreeMap<MemoryRange, LockInfo>,\n }\n \n-impl Allocation {\n+impl<M> Allocation<M> {\n     fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a LockInfo)> + 'a {\n         self.locks.range(MemoryRange::range(offset, len))\n             .filter(move |&(range, _)| range.overlaps(offset, len))\n@@ -165,11 +165,7 @@ impl Allocation {\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum Kind {\n-    /// Error if deallocated any other way than `rust_deallocate`\n-    Rust,\n-    /// Error if deallocated any other way than `free`\n-    C,\n+pub enum Kind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n     /// Static in the process of being initialized.\n@@ -179,8 +175,8 @@ pub enum Kind {\n     UninitializedStatic,\n     /// May never be deallocated\n     Static,\n-    /// Part of env var emulation\n-    Env,\n+    /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n+    Machine(T),\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -226,7 +222,7 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<AllocId, Allocation>,\n+    alloc_map: HashMap<AllocId, Allocation<M::MemoryKinds>>,\n \n     /// The AllocId to assign to the next new allocation. Always incremented, never gets smaller.\n     next_id: AllocId,\n@@ -285,7 +281,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation> {\n+    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation<M::MemoryKinds>> {\n         self.alloc_map.iter()\n     }\n \n@@ -313,7 +309,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(ptr)\n     }\n \n-    pub fn allocate(&mut self, size: u64, align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn allocate(\n+        &mut self,\n+        size: u64,\n+        align: u64,\n+        kind: Kind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n \n@@ -341,15 +342,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(MemoryPointer::new(id, 0))\n     }\n \n-    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn reallocate(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        old_size: u64,\n+        old_align: u64,\n+        new_size: u64,\n+        new_align: u64,\n+        kind: Kind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n         if ptr.offset != 0 {\n             return Err(EvalError::ReallocateNonBasePtr);\n         }\n         if let Ok(alloc) = self.get(ptr.alloc_id) {\n             if alloc.kind != kind {\n-                return Err(EvalError::ReallocatedWrongMemoryKind(alloc.kind, kind));\n+                return Err(EvalError::ReallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n             }\n         }\n \n@@ -361,7 +370,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>, kind: Kind) -> EvalResult<'tcx> {\n+    pub fn deallocate(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        size_and_align: Option<(u64, u64)>,\n+        kind: Kind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n             return Err(EvalError::DeallocateNonBasePtr);\n         }\n@@ -380,7 +394,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             .map_err(|lock| EvalError::DeallocatedLockedMemory { ptr, lock })?;\n \n         if alloc.kind != kind {\n-            return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n+            return Err(EvalError::DeallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n         }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n@@ -573,7 +587,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -583,7 +597,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n     \n-    fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n+    fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -593,7 +607,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n+    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         let alloc = self.get_mut_unchecked(id)?;\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)\n@@ -663,13 +677,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             }\n \n             let immutable = match (alloc.kind, alloc.mutable) {\n-                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\",\n-                (Kind::Static, Mutability::Mutable) => \" (static mut)\",\n-                (Kind::Static, Mutability::Immutable) => \" (immutable)\",\n-                (Kind::Env, _) => \" (env var)\",\n-                (Kind::C, _) => \" (malloc)\",\n-                (Kind::Rust, _) => \" (heap)\",\n-                (Kind::Stack, _) => \" (stack)\",\n+                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n+                (Kind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n+                (Kind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n+                (Kind::Machine(m), _) => format!(\" ({:?})\", m),\n+                (Kind::Stack, _) => \" (stack)\".to_owned(),\n             };\n             trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n@@ -793,17 +805,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n                     Kind::Stack |\n                     // The entire point of this function\n-                    Kind::UninitializedStatic |\n-                    // In the future const eval will allow heap allocations so we'll need to protect them\n-                    // from deallocation, too\n-                    Kind::Rust |\n-                    Kind::C => {},\n+                    Kind::UninitializedStatic => {},\n+                    Kind::Machine(m) => M::mark_static_initialized(m)?,\n                     Kind::Static => {\n                         trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n                         return Ok(());\n                     },\n-                    // FIXME: This could be allowed, but not for env vars set during miri execution\n-                    Kind::Env => return Err(EvalError::Unimplemented(\"statics can't refer to env vars\".to_owned())),\n                 }\n                 *kind = Kind::Static;\n                 *mutable = mutability;"}, {"sha": "960b73ee6b243c1fef4d1912fadf9dd8cd640e3a", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -2,6 +2,7 @@\n     i128_type,\n     rustc_private,\n     conservative_impl_trait,\n+    never_type,\n )]\n \n // From rustc."}, {"sha": "96006c884e5806b085aafc46e7fff5691108149b", "filename": "tests/compile-fail/stack_free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adfea61665385428b9c9aced9442dba65464c3c8/tests%2Fcompile-fail%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfea61665385428b9c9aced9442dba65464c3c8/tests%2Fcompile-fail%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_free.rs?ref=adfea61665385428b9c9aced9442dba65464c3c8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: tried to deallocate Stack memory but gave Rust as the kind\n+// error-pattern: tried to deallocate Stack memory but gave Machine(Rust) as the kind\n \n fn main() {\n     let x = 42;"}]}