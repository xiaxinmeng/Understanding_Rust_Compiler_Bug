{"sha": "29ca4350c8d64facb39311660e8ee919766f481a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5Y2E0MzUwYzhkNjRmYWNiMzkzMTE2NjBlOGVlOTE5NzY2ZjQ4MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-10T00:11:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-10T00:11:28Z"}, "message": "auto merge of #10812 : alexcrichton/rust/lto, r=pcwalton\n\nThe first commit was approved from another pull request, but I wanted to rebase LTO on top of it.\r\n\r\nLTO is not turned on by default at all, and it's hidden behind a `-Z` flag. I have added a few small tests for it, however.", "tree": {"sha": "89cc0a532846f00be6159ea2eb5b3c8f3d9cf058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89cc0a532846f00be6159ea2eb5b3c8f3d9cf058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ca4350c8d64facb39311660e8ee919766f481a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ca4350c8d64facb39311660e8ee919766f481a", "html_url": "https://github.com/rust-lang/rust/commit/29ca4350c8d64facb39311660e8ee919766f481a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ca4350c8d64facb39311660e8ee919766f481a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f817ed3e6f39e6e0b1a8ec968ea0ad3c1bc36ba5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f817ed3e6f39e6e0b1a8ec968ea0ad3c1bc36ba5", "html_url": "https://github.com/rust-lang/rust/commit/f817ed3e6f39e6e0b1a8ec968ea0ad3c1bc36ba5"}, {"sha": "fce4a174b9ffff71a66feecd9f4960f17fc9c331", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce4a174b9ffff71a66feecd9f4960f17fc9c331", "html_url": "https://github.com/rust-lang/rust/commit/fce4a174b9ffff71a66feecd9f4960f17fc9c331"}], "stats": {"total": 690, "additions": 538, "deletions": 152}, "files": [{"sha": "eec15f798278d195e048932c1cf0ac5f4fd83016", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -20,6 +20,8 @@ use std::str;\n use extra::tempfile::TempDir;\n use syntax::abi;\n \n+pub static METADATA_FILENAME: &'static str = \"metadata\";\n+\n pub struct Archive {\n     priv sess: Session,\n     priv dst: Path,\n@@ -40,7 +42,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n     }\n     let o = Process::new(ar, args.as_slice(), opts).finish_with_output();\n     if !o.status.success() {\n-        sess.err(format!(\"{} failed with: {}\", ar, o.status));\n+        sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n+                         o.status));\n         sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output)));\n         sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error)));\n         sess.abort_if_errors();\n@@ -81,17 +84,40 @@ impl Archive {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) {\n         let location = self.find_library(name);\n-        self.add_archive(&location, name);\n+        self.add_archive(&location, name, []);\n     }\n \n     /// Adds all of the contents of the rlib at the specified path to this\n     /// archive.\n-    pub fn add_rlib(&mut self, rlib: &Path) {\n-        let name = rlib.filename_str().unwrap().split('-').next().unwrap();\n-        self.add_archive(rlib, name);\n+    ///\n+    /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n+    /// then the object file also isn't added.\n+    pub fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool) {\n+        let object = format!(\"{}.o\", name);\n+        let bytecode = format!(\"{}.bc\", name);\n+        let mut ignore = ~[METADATA_FILENAME, bytecode.as_slice()];\n+        if lto {\n+            ignore.push(object.as_slice());\n+        }\n+        self.add_archive(rlib, name, ignore);\n     }\n \n-    fn add_archive(&mut self, archive: &Path, name: &str) {\n+    /// Adds an arbitrary file to this archive\n+    pub fn add_file(&mut self, file: &Path) {\n+        run_ar(self.sess, \"r\", None, [&self.dst, file]);\n+    }\n+\n+    /// Removes a file from this archive\n+    pub fn remove_file(&mut self, file: &str) {\n+        run_ar(self.sess, \"d\", None, [&self.dst, &Path::new(file)]);\n+    }\n+\n+    pub fn files(&self) -> ~[~str] {\n+        let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n+        str::from_utf8(output.output).lines().map(|s| s.to_owned()).collect()\n+    }\n+\n+    fn add_archive(&mut self, archive: &Path, name: &str, skip: &[&str]) {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n         // First, extract the contents of the archive to a temporary directory\n@@ -102,10 +128,17 @@ impl Archive {\n         // The reason for this is that archives are keyed off the name of the\n         // files, so if two files have the same name they will override one\n         // another in the archive (bad).\n+        //\n+        // We skip any files explicitly desired for skipping, and we also skip\n+        // all SYMDEF files as these are just magical placeholders which get\n+        // re-created when we make a new archive anyway.\n         let files = fs::readdir(loc.path());\n         let mut inputs = ~[];\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n+            if skip.iter().any(|s| *s == filename) { continue }\n+            if filename.contains(\".SYMDEF\") { continue }\n+\n             let filename = format!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n             fs::rename(file, &new_filename);"}, {"sha": "451213ab694f712d32212b0bb53f2d7d19b8c024", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 213, "deletions": 71, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n \n-use back::archive::Archive;\n+use back::archive::{Archive, METADATA_FILENAME};\n use back::rpath;\n+use driver::driver::CrateTranslation;\n use driver::session::Session;\n use driver::session;\n use lib::llvm::llvm;\n@@ -21,6 +22,7 @@ use metadata::{encoder, cstore, filesearch, csearch};\n use middle::trans::context::CrateContext;\n use middle::trans::common::gensym_name;\n use middle::ty;\n+use util::common::time;\n use util::ppaux;\n \n use std::c_str::ToCStr;\n@@ -32,6 +34,7 @@ use std::ptr;\n use std::run;\n use std::str;\n use std::io::fs;\n+use extra::tempfile::TempDir;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n@@ -84,15 +87,18 @@ pub fn WriteOutputFile(\n \n pub mod write {\n \n+    use back::lto;\n     use back::link::{WriteOutputFile, output_type};\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n     use back::link::{output_type_object};\n+    use driver::driver::CrateTranslation;\n     use driver::session::Session;\n     use driver::session;\n     use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, ContextRef};\n+    use lib::llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n     use lib;\n+    use util::common::time;\n \n     use std::c_str::ToCStr;\n     use std::libc::{c_uint, c_int};\n@@ -101,10 +107,11 @@ pub mod write {\n     use std::str;\n \n     pub fn run_passes(sess: Session,\n-                      llcx: ContextRef,\n-                      llmod: ModuleRef,\n+                      trans: &CrateTranslation,\n                       output_type: output_type,\n                       output: &Path) {\n+        let llmod = trans.module;\n+        let llcx = trans.context;\n         unsafe {\n             llvm::LLVMInitializePasses();\n \n@@ -191,49 +198,106 @@ pub mod write {\n             }\n \n             // Finally, run the actual optimization passes\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n-            llvm::LLVMRunPassManager(mpm, llmod);\n+            time(sess.time_passes(), \"llvm function passes\", (), |()|\n+                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+            time(sess.time_passes(), \"llvm module passes\", (), |()|\n+                 llvm::LLVMRunPassManager(mpm, llmod));\n \n             // Deallocate managers that we're now done with\n             llvm::LLVMDisposePassManager(fpm);\n             llvm::LLVMDisposePassManager(mpm);\n \n-            if sess.opts.save_temps {\n+            // Emit the bytecode if we're either saving our temporaries or\n+            // emitting an rlib. Whenever an rlib is create, the bytecode is\n+            // inserted into the archive in order to allow LTO against it.\n+            if sess.opts.save_temps ||\n+               sess.outputs.iter().any(|&o| o == session::OutputRlib) {\n                 output.with_extension(\"bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 })\n             }\n \n-            // Create a codegen-specific pass manager to emit the actual\n-            // assembly or object files. This may not end up getting used,\n-            // but we make it anyway for good measure.\n-            let cpm = llvm::LLVMCreatePassManager();\n-            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-            llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n-\n-            match output_type {\n-                output_type_none => {}\n-                output_type_bitcode => {\n-                    output.with_c_str(|buf| {\n+            if sess.lto() {\n+                time(sess.time_passes(), \"all lto passes\", (), |()|\n+                     lto::run(sess, llmod, tm, trans.reachable));\n+\n+                if sess.opts.save_temps {\n+                    output.with_extension(\"lto.bc\").with_c_str(|buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                     })\n                 }\n-                output_type_llvm_assembly => {\n-                    output.with_c_str(|output| {\n-                        llvm::LLVMRustPrintModule(cpm, llmod, output)\n-                    })\n-                }\n-                output_type_assembly => {\n-                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n-                }\n-                output_type_exe | output_type_object => {\n-                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n+            }\n+\n+            // A codegen-specific pass manager is used to generate object\n+            // files for an LLVM module.\n+            //\n+            // Apparently each of these pass managers is a one-shot kind of\n+            // thing, so we create a new one for each type of output. The\n+            // pass manager passed to the closure should be ensured to not\n+            // escape the closure itself, and the manager should only be\n+            // used once.\n+            fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n+                            f: |PassManagerRef|) {\n+                unsafe {\n+                    let cpm = llvm::LLVMCreatePassManager();\n+                    llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+                    llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+                    f(cpm);\n+                    llvm::LLVMDisposePassManager(cpm);\n                 }\n             }\n \n-            llvm::LLVMDisposePassManager(cpm);\n+            time(sess.time_passes(), \"codegen passes\", (), |()| {\n+                match output_type {\n+                    output_type_none => {}\n+                    output_type_bitcode => {\n+                        output.with_c_str(|buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                        })\n+                    }\n+                    output_type_llvm_assembly => {\n+                        output.with_c_str(|output| {\n+                            with_codegen(tm, llmod, |cpm| {\n+                                llvm::LLVMRustPrintModule(cpm, llmod, output);\n+                            })\n+                        })\n+                    }\n+                    output_type_assembly => {\n+                        with_codegen(tm, llmod, |cpm| {\n+                            WriteOutputFile(sess, tm, cpm, llmod, output,\n+                                            lib::llvm::AssemblyFile);\n+                        });\n+\n+                        // If we're not using the LLVM assembler, this function\n+                        // could be invoked specially with output_type_assembly,\n+                        // so in this case we still want the metadata object\n+                        // file.\n+                        if sess.opts.output_type != output_type_assembly {\n+                            with_codegen(tm, trans.metadata_module, |cpm| {\n+                                let out = output.with_extension(\"metadata.o\");\n+                                WriteOutputFile(sess, tm, cpm,\n+                                                trans.metadata_module, &out,\n+                                                lib::llvm::ObjectFile);\n+                            })\n+                        }\n+                    }\n+                    output_type_exe | output_type_object => {\n+                        with_codegen(tm, llmod, |cpm| {\n+                            WriteOutputFile(sess, tm, cpm, llmod, output,\n+                                            lib::llvm::ObjectFile);\n+                        });\n+                        with_codegen(tm, trans.metadata_module, |cpm| {\n+                            let out = output.with_extension(\"metadata.o\");\n+                            WriteOutputFile(sess, tm, cpm,\n+                                            trans.metadata_module, &out,\n+                                            lib::llvm::ObjectFile);\n+                        })\n+                    }\n+                }\n+            });\n \n             llvm::LLVMRustDisposeTargetMachine(tm);\n+            llvm::LLVMDisposeModule(trans.metadata_module);\n             llvm::LLVMDisposeModule(llmod);\n             llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n@@ -782,43 +846,25 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n pub fn link_binary(sess: Session,\n-                   crate_types: &[~str],\n+                   trans: &CrateTranslation,\n                    obj_filename: &Path,\n-                   out_filename: &Path,\n-                   lm: LinkMeta) {\n+                   out_filename: &Path) {\n+    // If we're generating a test executable, then ignore all other output\n+    // styles at all other locations\n     let outputs = if sess.opts.test {\n-        // If we're generating a test executable, then ignore all other output\n-        // styles at all other locations\n         ~[session::OutputExecutable]\n     } else {\n-        // Always generate whatever was specified on the command line, but also\n-        // look at what was in the crate file itself for generating output\n-        // formats.\n-        let mut outputs = sess.opts.outputs.clone();\n-        for ty in crate_types.iter() {\n-            if \"bin\" == *ty {\n-                outputs.push(session::OutputExecutable);\n-            } else if \"dylib\" == *ty || \"lib\" == *ty {\n-                outputs.push(session::OutputDylib);\n-            } else if \"rlib\" == *ty {\n-                outputs.push(session::OutputRlib);\n-            } else if \"staticlib\" == *ty {\n-                outputs.push(session::OutputStaticlib);\n-            }\n-        }\n-        if outputs.len() == 0 {\n-            outputs.push(session::OutputExecutable);\n-        }\n-        outputs\n+        (*sess.outputs).clone()\n     };\n \n     for output in outputs.move_iter() {\n-        link_binary_output(sess, output, obj_filename, out_filename, lm);\n+        link_binary_output(sess, trans, output, obj_filename, out_filename);\n     }\n \n-    // Remove the temporary object file if we aren't saving temps\n+    // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.save_temps {\n         fs::unlink(obj_filename);\n+        fs::unlink(&obj_filename.with_extension(\"metadata.o\"));\n     }\n }\n \n@@ -832,11 +878,11 @@ fn is_writeable(p: &Path) -> bool {\n }\n \n fn link_binary_output(sess: Session,\n+                      trans: &CrateTranslation,\n                       output: session::OutputStyle,\n                       obj_filename: &Path,\n-                      out_filename: &Path,\n-                      lm: LinkMeta) {\n-    let libname = output_lib_filename(lm);\n+                      out_filename: &Path) {\n+    let libname = output_lib_filename(trans.link);\n     let out_filename = match output {\n         session::OutputRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n@@ -874,7 +920,7 @@ fn link_binary_output(sess: Session,\n \n     match output {\n         session::OutputRlib => {\n-            link_rlib(sess, obj_filename, &out_filename);\n+            link_rlib(sess, Some(trans), obj_filename, &out_filename);\n         }\n         session::OutputStaticlib => {\n             link_staticlib(sess, obj_filename, &out_filename);\n@@ -894,9 +940,12 @@ fn link_binary_output(sess: Session,\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n-fn link_rlib(sess: Session, obj_filename: &Path,\n+fn link_rlib(sess: Session,\n+             trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n+             obj_filename: &Path,\n              out_filename: &Path) -> Archive {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n+\n     for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n         match kind {\n             cstore::NativeStatic => {\n@@ -905,6 +954,48 @@ fn link_rlib(sess: Session, obj_filename: &Path,\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n     }\n+\n+    // Note that it is important that we add all of our non-object \"magical\n+    // files\" *after* all of the object files in the archive. The reason for\n+    // this is as follows:\n+    //\n+    // * When performing LTO, this archive will be modified to remove\n+    //   obj_filename from above. The reason for this is described below.\n+    //\n+    // * When the system linker looks at an archive, it will attempt to\n+    //   determine the architecture of the archive in order to see whether its\n+    //   linkable.\n+    //\n+    //   The algorithm for this detections is: iterate over the files in the\n+    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n+    //   object file. Read architecture from the object file.\n+    //\n+    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n+    //   before all of the objects, then the architecture of this archive would\n+    //   not be correctly inferred once 'foo.o' is removed.\n+    //\n+    // Basically, all this means is that this code should not move above the\n+    // code above.\n+    match trans {\n+        Some(trans) => {\n+            // Instead of putting the metadata in an object file section, rlibs\n+            // contain the metadata in a separate file.\n+            let metadata = obj_filename.with_filename(METADATA_FILENAME);\n+            fs::File::create(&metadata).write(trans.metadata);\n+            a.add_file(&metadata);\n+            fs::unlink(&metadata);\n+\n+            // For LTO purposes, the bytecode of this library is also inserted\n+            // into the archive.\n+            let bc = obj_filename.with_extension(\"bc\");\n+            a.add_file(&bc);\n+            if !sess.opts.save_temps {\n+                fs::unlink(&bc);\n+            }\n+        }\n+\n+        None => {}\n+    }\n     return a;\n }\n \n@@ -916,20 +1007,24 @@ fn link_rlib(sess: Session, obj_filename: &Path,\n //\n // Additionally, there's no way for us to link dynamic libraries, so we warn\n // about all dynamic library dependencies that they're not linked in.\n+//\n+// There's no need to include metadata in a static archive, so ensure to not\n+// link in the metadata object file (and also don't prepare the archive with a\n+// metadata file).\n fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n-    let mut a = link_rlib(sess, obj_filename, out_filename);\n+    let mut a = link_rlib(sess, None, obj_filename, out_filename);\n     a.add_native_library(\"morestack\");\n \n     let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n+        let name = cstore::get_crate_data(sess.cstore, cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n-                sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 cstore::get_crate_data(sess.cstore, cnum).name));\n+                sess.err(format!(\"could not find rlib for: `{}`\", name));\n                 continue\n             }\n         };\n-        a.add_rlib(&p);\n+        a.add_rlib(&p, name, sess.lto());\n         let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n@@ -948,10 +1043,12 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n // links to all upstream files as well.\n fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n                  out_filename: &Path) {\n+    let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n     // The invocations of cc share some flags across platforms\n     let cc_prog = get_cc_prog(sess);\n     let mut cc_args = sess.targ_cfg.target_strs.cc_args.clone();\n-    cc_args.push_all_move(link_args(sess, dylib, obj_filename, out_filename));\n+    cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(),\n+                                    obj_filename, out_filename));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n         println!(\"{} link args: '{}'\", cc_prog, cc_args.connect(\"' '\"));\n     }\n@@ -961,7 +1058,8 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n-    let prog = run::process_output(cc_prog, cc_args);\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()|\n+                    run::process_output(cc_prog, cc_args));\n \n     if !prog.status.success() {\n         sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n@@ -982,6 +1080,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n fn link_args(sess: Session,\n              dylib: bool,\n+             tmpdir: &Path,\n              obj_filename: &Path,\n              out_filename: &Path) -> ~[~str] {\n \n@@ -998,6 +1097,14 @@ fn link_args(sess: Session,\n         ~\"-o\", out_filename.as_str().unwrap().to_owned(),\n         obj_filename.as_str().unwrap().to_owned()]);\n \n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if dylib {\n+        let metadata = obj_filename.with_extension(\"metadata.o\");\n+        args.push(metadata.as_str().unwrap().to_owned());\n+    }\n+\n     if sess.targ_cfg.os == abi::OsLinux {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n@@ -1015,7 +1122,7 @@ fn link_args(sess: Session,\n     }\n \n     add_local_native_libraries(&mut args, sess);\n-    add_upstream_rust_crates(&mut args, sess, dylib);\n+    add_upstream_rust_crates(&mut args, sess, dylib, tmpdir);\n     add_upstream_native_libraries(&mut args, sess);\n \n     // # Telling the linker what we're doing\n@@ -1098,7 +1205,7 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n-                            dylib: bool) {\n+                            dylib: bool, tmpdir: &Path) {\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, stem: &str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n@@ -1123,14 +1230,49 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n         // dynamic libraries.\n         let crates = cstore::get_used_crates(cstore, cstore::RequireStatic);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-            for (_, path) in crates.move_iter() {\n-                let path = path.unwrap();\n-                args.push(path.as_str().unwrap().to_owned());\n+            for (cnum, path) in crates.move_iter() {\n+                let cratepath = path.unwrap();\n+\n+                // When performing LTO on an executable output, all of the\n+                // bytecode from the upstream libraries has already been\n+                // included in our object file output. We need to modify all of\n+                // the upstream archives to remove their corresponding object\n+                // file to make sure we don't pull the same code in twice.\n+                //\n+                // We must continue to link to the upstream archives to be sure\n+                // to pull in native static dependencies. As the final caveat,\n+                // on linux it is apparently illegal to link to a blank archive,\n+                // so if an archive no longer has any object files in it after\n+                // we remove `lib.o`, then don't link against it at all.\n+                //\n+                // If we're not doing LTO, then our job is simply to just link\n+                // against the archive.\n+                if sess.lto() {\n+                    let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+                    time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n+                         (), |()| {\n+                        let dst = tmpdir.join(cratepath.filename().unwrap());\n+                        fs::copy(&cratepath, &dst);\n+                        let dst_str = dst.as_str().unwrap().to_owned();\n+                        let mut archive = Archive::open(sess, dst);\n+                        archive.remove_file(format!(\"{}.o\", name));\n+                        let files = archive.files();\n+                        if files.iter().any(|s| s.ends_with(\".o\")) {\n+                            args.push(dst_str);\n+                        }\n+                    });\n+                } else {\n+                    args.push(cratepath.as_str().unwrap().to_owned());\n+                }\n             }\n             return;\n         }\n     }\n \n+    // If we're performing LTO, then it should have been previously required\n+    // that all upstream rust depenencies were available in an rlib format.\n+    assert!(!sess.lto());\n+\n     // This is a fallback of three different  cases of linking:\n     //\n     // * When creating a dynamic library, all inputs are required to be dynamic"}, {"sha": "7c8c6aabd7eab5cfccee33b9d44df98b2f57d185", "filename": "src/librustc/back/lto.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::archive::Archive;\n+use back::link;\n+use driver::session;\n+use lib::llvm::{ModuleRef, TargetMachineRef, llvm, True, False};\n+use metadata::cstore;\n+use util::common::time;\n+\n+use std::libc;\n+use std::vec;\n+\n+pub fn run(sess: session::Session, llmod: ModuleRef,\n+           tm: TargetMachineRef, reachable: &[~str]) {\n+    // Make sure we actually can run LTO\n+    for output in sess.outputs.iter() {\n+        match *output {\n+            session::OutputExecutable | session::OutputStaticlib => {}\n+            _ => {\n+                sess.fatal(\"lto can only be run for executables and \\\n+                            static library outputs\");\n+            }\n+        }\n+    }\n+\n+    // For each of our upstream dependencies, find the corresponding rlib and\n+    // load the bitcode from the archive. Then merge it into the current LLVM\n+    // module that we've got.\n+    let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n+    for (cnum, path) in crates.move_iter() {\n+        let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+        let path = match path {\n+            Some(p) => p,\n+            None => {\n+                sess.fatal(format!(\"could not find rlib for: `{}`\", name));\n+            }\n+        };\n+\n+        let archive = Archive::open(sess, path);\n+        debug!(\"reading {}\", name);\n+        let bc = time(sess.time_passes(), format!(\"read {}.bc\", name), (), |_|\n+                      archive.read(format!(\"{}.bc\", name)));\n+        let ptr = vec::raw::to_ptr(bc);\n+        debug!(\"linking {}\", name);\n+        time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {\n+            if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n+                                                    ptr as *libc::c_char,\n+                                                    bc.len() as libc::size_t) {\n+                link::llvm_err(sess, format!(\"failed to load bc of `{}`\", name));\n+            }\n+        });\n+    }\n+\n+    // Internalize everything but the reachable symbols of the current module\n+    let cstrs = reachable.map(|s| s.to_c_str());\n+    let arr = cstrs.map(|c| c.with_ref(|p| p));\n+    let ptr = vec::raw::to_ptr(arr);\n+    unsafe {\n+        llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,\n+                                         arr.len() as libc::size_t);\n+    }\n+\n+    // Now we have one massive module inside of llmod. Time to run the\n+    // LTO-specific optimization passes that LLVM provides.\n+    //\n+    // This code is based off the code found in llvm's LTO code generator:\n+    //      tools/lto/LTOCodeGenerator.cpp\n+    debug!(\"running the pass manager\");\n+    unsafe {\n+        let pm = llvm::LLVMCreatePassManager();\n+        llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n+        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+\n+        let builder = llvm::LLVMPassManagerBuilderCreate();\n+        llvm::LLVMPassManagerBuilderPopulateLTOPassManager(builder, pm,\n+            /* Internalize = */ False,\n+            /* RunInliner = */ True);\n+        llvm::LLVMPassManagerBuilderDispose(builder);\n+\n+        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+\n+        time(sess.time_passes(), \"LTO pases\", (), |()|\n+             llvm::LLVMRunPassManager(pm, llmod));\n+\n+        llvm::LLVMDisposePassManager(pm);\n+    }\n+    debug!(\"lto done\");\n+}"}, {"sha": "c0ee53da9705362d294cd1bcff193b120b410f90", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -165,10 +165,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     let time_passes = sess.time_passes();\n \n     *sess.building_library = session::building_library(sess.opts, &crate);\n-    let want_exe = sess.opts.outputs.iter().any(|&o| o == OutputExecutable);\n-    if *sess.building_library && want_exe {\n-        sess.err(\"cannot build both a library and an executable\");\n-    }\n+    *sess.outputs = session::collect_outputs(sess.opts, &crate);\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &crate));\n@@ -335,8 +332,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n pub struct CrateTranslation {\n     context: ContextRef,\n     module: ModuleRef,\n+    metadata_module: ModuleRef,\n     link: LinkMeta,\n-    crate_types: ~[~str],\n+    metadata: ~[u8],\n+    reachable: ~[~str],\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -362,8 +361,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n-                                    trans.context,\n-                                    trans.module,\n+                                    trans,\n                                     output_type,\n                                     &asm_filename));\n \n@@ -376,8 +374,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n-                                    trans.context,\n-                                    trans.module,\n+                                    trans,\n                                     sess.opts.output_type,\n                                     &outputs.obj_filename));\n     }\n@@ -390,10 +387,9 @@ pub fn phase_6_link_output(sess: Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n-                           trans.crate_types,\n+                           trans,\n                            &outputs.obj_filename,\n-                           &outputs.out_filename,\n-                           trans.link));\n+                           &outputs.out_filename));\n }\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n@@ -838,7 +834,8 @@ pub fn build_session_(sopts: @session::options,\n         building_library: @mut false,\n         working_dir: os::getcwd(),\n         lints: @mut HashMap::new(),\n-        node_id: @mut 1\n+        node_id: @mut 1,\n+        outputs: @mut ~[],\n     }\n }\n "}, {"sha": "30d5b7780cf92c3b688893fa827193635489eddb", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -17,6 +17,7 @@ use metadata::filesearch;\n use metadata;\n use middle::lint;\n \n+use syntax::attr::AttrMetaMethods;\n use syntax::ast::NodeId;\n use syntax::ast::{int_ty, uint_ty};\n use syntax::codemap::Span;\n@@ -67,6 +68,7 @@ pub static use_softfp:              uint = 1 << 26;\n pub static gen_crate_map:           uint = 1 << 27;\n pub static prefer_dynamic:          uint = 1 << 28;\n pub static no_integrated_as:        uint = 1 << 29;\n+pub static lto:                     uint = 1 << 30;\n \n pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n     ~[(\"verbose\", \"in general, enable more debug printouts\", verbose),\n@@ -120,6 +122,7 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n      (\"prefer-dynamic\", \"Prefer dynamic linking to static linking\", prefer_dynamic),\n      (\"no-integrated-as\",\n       \"Use external assembler rather than LLVM's integrated one\", no_integrated_as),\n+     (\"lto\", \"Perform LLVM link-time optimizations\", lto),\n     ]\n }\n \n@@ -208,6 +211,7 @@ pub struct Session_ {\n     working_dir: Path,\n     lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::Span, ~str)]>,\n     node_id: @mut ast::NodeId,\n+    outputs: @mut ~[OutputStyle],\n }\n \n pub type Session = @Session_;\n@@ -341,6 +345,9 @@ impl Session_ {\n     pub fn no_integrated_as(&self) -> bool {\n         self.debugging_opt(no_integrated_as)\n     }\n+    pub fn lto(&self) -> bool {\n+        self.debugging_opt(lto)\n+    }\n \n     // pointless function, now...\n     pub fn str_of(&self, id: ast::Ident) -> @str {\n@@ -408,6 +415,29 @@ pub fn building_library(options: &options, crate: &ast::Crate) -> bool {\n     }\n }\n \n+pub fn collect_outputs(options: &options, crate: &ast::Crate) -> ~[OutputStyle] {\n+    let mut base = options.outputs.clone();\n+    let mut iter = crate.attrs.iter().filter_map(|a| {\n+        if \"crate_type\" == a.name() {\n+            match a.value_str() {\n+                Some(n) if \"rlib\" == n => Some(OutputRlib),\n+                Some(n) if \"dylib\" == n => Some(OutputDylib),\n+                Some(n) if \"lib\" == n => Some(OutputDylib),\n+                Some(n) if \"staticlib\" == n => Some(OutputStaticlib),\n+                Some(n) if \"bin\" == n => Some(OutputExecutable),\n+                _ => None\n+            }\n+        } else {\n+            None\n+        }\n+    });\n+    base.extend(&mut iter);\n+    if base.len() == 0 {\n+        base.push(OutputExecutable);\n+    }\n+    return base;\n+}\n+\n pub fn sess_os_to_meta_os(os: abi::Os) -> metadata::loader::Os {\n     use metadata::loader;\n "}, {"sha": "3de33e13ecc197fd0bf3e9242fef954cccd85c40", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -99,6 +99,7 @@ pub mod back {\n     pub mod x86_64;\n     pub mod rpath;\n     pub mod target_strs;\n+    pub mod lto;\n }\n \n pub mod metadata;"}, {"sha": "7039eced9769fbb52411f0c95585a559501ec3fd", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -1403,6 +1403,11 @@ pub mod llvm {\n         pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n             PMB: PassManagerBuilderRef,\n             PM: PassManagerRef);\n+        pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+            PMB: PassManagerBuilderRef,\n+            PM: PassManagerRef,\n+            Internalize: Bool,\n+            RunInliner: Bool);\n \n         /** Destroys a memory buffer. */\n         pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n@@ -1736,6 +1741,12 @@ pub mod llvm {\n         pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *c_char);\n         pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n                                            AddLifetimes: bool);\n+        pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n+                                             bc: *c_char,\n+                                             len: size_t) -> bool;\n+        pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n+                                          syms: **c_char,\n+                                          len: size_t);\n     }\n }\n "}, {"sha": "bf50da3d7892e8b9867dbed90d347a7cf73b0d7b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -21,13 +21,14 @@ use middle::ty;\n use middle::typeck;\n use middle;\n \n+use std::cast;\n use std::hashmap::{HashMap, HashSet};\n-use std::io::{Writer, Seek, Decorator};\n use std::io::mem::MemWriter;\n+use std::io::{Writer, Seek, Decorator};\n use std::str;\n+use std::util;\n use std::vec;\n \n-use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n \n@@ -47,8 +48,6 @@ use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n-use std::cast;\n-\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n@@ -1871,10 +1870,9 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     // remaining % 4 bytes.\n     wr.write(&[0u8, 0u8, 0u8, 0u8]);\n \n-    let writer_bytes: &mut ~[u8] = wr.inner_mut_ref();\n-\n-    metadata_encoding_version.to_owned() +\n-        flate::deflate_bytes(*writer_bytes)\n+    // This is a horrible thing to do to the outer MemWriter, but thankfully we\n+    // don't use it again so... it's ok right?\n+    return util::replace(wr.inner_mut_ref(), ~[]);\n }\n \n // Get the encoded string for a type"}, {"sha": "5b1385c757973304b47cee38d2db5f2e4191006a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -10,7 +10,7 @@\n \n //! Finds crate binaries and loads their metadata\n \n-use back::archive::Archive;\n+use back::archive::{Archive, METADATA_FILENAME};\n use driver::session::Session;\n use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n use metadata::decoder;\n@@ -27,7 +27,6 @@ use syntax::attr::AttrMetaMethods;\n use std::c_str::ToCStr;\n use std::cast;\n use std::io;\n-use std::libc;\n use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n@@ -102,8 +101,7 @@ impl Context {\n                     if candidate && existing {\n                         FileMatches\n                     } else if candidate {\n-                        match get_metadata_section(self.sess, self.os, path,\n-                                                   crate_name) {\n+                        match get_metadata_section(self.sess, self.os, path) {\n                             Some(cvec) =>\n                                 if crate_matches(cvec, self.metas, self.hash) {\n                                     debug!(\"found {} with matching metadata\",\n@@ -271,22 +269,15 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n     local_metas.iter().all(|needed| attr::contains(extern_metas, *needed))\n }\n \n-fn get_metadata_section(sess: Session, os: Os, filename: &Path,\n-                        crate_name: &str) -> Option<@~[u8]> {\n+fn get_metadata_section(sess: Session, os: Os, filename: &Path) -> Option<@~[u8]> {\n+    if filename.filename_str().unwrap().ends_with(\".rlib\") {\n+        let archive = Archive::open(sess, filename.clone());\n+        return Some(@archive.read(METADATA_FILENAME));\n+    }\n     unsafe {\n-        let mb = if filename.filename_str().unwrap().ends_with(\".rlib\") {\n-            let archive = Archive::open(sess, filename.clone());\n-            let contents = archive.read(crate_name + \".o\");\n-            let ptr = vec::raw::to_ptr(contents);\n-            crate_name.with_c_str(|name| {\n-                llvm::LLVMCreateMemoryBufferWithMemoryRangeCopy(\n-                    ptr as *i8, contents.len() as libc::size_t, name)\n-            })\n-        } else {\n-            filename.with_c_str(|buf| {\n-                llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-            })\n-        };\n+        let mb = filename.with_c_str(|buf| {\n+            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+        });\n         if mb as int == 0 { return None }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n@@ -356,12 +347,7 @@ pub fn list_file_metadata(sess: Session,\n                           os: Os,\n                           path: &Path,\n                           out: @mut io::Writer) {\n-    // guess the crate name from the pathname\n-    let crate_name = path.filename_str().unwrap();\n-    let crate_name = if crate_name.starts_with(\"lib\") {\n-        crate_name.slice_from(3) } else { crate_name };\n-    let crate_name = crate_name.split('-').next().unwrap();\n-    match get_metadata_section(sess, os, path, crate_name) {\n+    match get_metadata_section(sess, os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n         write!(out, \"could not find metadata in {}.\\n\", path.display())"}, {"sha": "8a89cd35d0e47e89a27343f821de7719c5e9dd88", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -2929,7 +2929,7 @@ pub fn symname(sess: session::Session, name: &str,\n }\n \n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n-                      llmod: ModuleRef) -> ValueRef {\n+                      llmod: ModuleRef) -> (~str, ValueRef) {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n@@ -2963,7 +2963,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n     }\n \n-    return map;\n+    return (sym_name, map);\n }\n \n pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n@@ -3044,36 +3044,35 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n-    if !*cx.sess.building_library { return; }\n+pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n+    use extra::flate;\n+\n+    if !*cx.sess.building_library { return ~[]; }\n \n     let encode_inlined_item: encoder::encode_inlined_item =\n         |ecx, ebml_w, path, ii|\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n-    let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n+    let metadata = encoder::encode_metadata(encode_parms, crate);\n+    let compressed = encoder::metadata_encoding_version +\n+                        flate::deflate_bytes(metadata);\n+    let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n-    let mut llglobal = \"rust_metadata\".with_c_str(|buf| {\n+    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.name,\n+                       cx.link_meta.vers, cx.link_meta.extras_hash);\n+    let llglobal = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n         }\n     });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n-        lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-\n-        let t_ptr_i8 = Type::i8p();\n-        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n-        let llvm_used = \"llvm.used\".with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n-        });\n-        lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n-        llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n+    return metadata;\n }\n \n pub fn trans_crate(sess: session::Session,\n@@ -3140,7 +3139,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     // Translate the metadata.\n-    write_metadata(ccx, &crate);\n+    let metadata = write_metadata(ccx, &crate);\n     if ccx.sess.trans_stats() {\n         println(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs);\n@@ -3174,18 +3173,27 @@ pub fn trans_crate(sess: session::Session,\n     let llcx = ccx.llcx;\n     let link_meta = ccx.link_meta;\n     let llmod = ccx.llmod;\n-    let crate_types = crate.attrs.iter().filter_map(|a| {\n-        if \"crate_type\" == a.name() {\n-            a.value_str()\n-        } else {\n-            None\n-        }\n-    }).map(|a| a.to_owned()).collect();\n+    let mut reachable = ccx.reachable.iter().filter_map(|id| {\n+        ccx.item_symbols.find(id).map(|s| s.to_owned())\n+    }).to_owned_vec();\n+\n+    // Make sure that some other crucial symbols are not eliminated from the\n+    // module. This includes the main function (main/amain elsewhere), the crate\n+    // map (used for debug log settings and I/O), and finally the curious\n+    // rust_stack_exhausted symbol. This symbol is required for use by the\n+    // libmorestack library that we link in, so we must ensure that this symbol\n+    // is not internalized (if defined in the crate).\n+    reachable.push(ccx.crate_map_name.to_owned());\n+    reachable.push(~\"main\");\n+    reachable.push(~\"amain\");\n+    reachable.push(~\"rust_stack_exhausted\");\n \n     return CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,\n-        crate_types: crate_types,\n+        metadata_module: ccx.metadata_llmod,\n+        metadata: metadata,\n+        reachable: reachable,\n     };\n }"}, {"sha": "c483a0f48f8c9aab0ef20b456232355db4248724", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -42,6 +42,7 @@ pub struct CrateContext {\n      sess: session::Session,\n      llmod: ModuleRef,\n      llcx: ContextRef,\n+     metadata_llmod: ModuleRef,\n      td: TargetData,\n      tn: TypeNames,\n      externs: ExternMap,\n@@ -110,6 +111,7 @@ pub struct CrateContext {\n      opaque_vec_type: Type,\n      builder: BuilderRef_res,\n      crate_map: ValueRef,\n+     crate_map_name: ~str,\n      // Set when at least one function uses GC. Needed so that\n      // decl_gc_metadata knows whether to link to the module metadata, which\n      // is not emitted by LLVM's GC pass when no functions use GC.\n@@ -134,11 +136,18 @@ impl CrateContext {\n             let llmod = name.with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n+            let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n+                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+            });\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            data_layout.with_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n+            data_layout.with_c_str(|buf| {\n+                llvm::LLVMSetDataLayout(llmod, buf);\n+                llvm::LLVMSetDataLayout(metadata_llmod, buf);\n+            });\n             targ_triple.with_c_str(|buf| {\n-                llvm::LLVMRustSetNormalizedTarget(llmod, buf)\n+                llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n+                llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });\n             let targ_cfg = sess.targ_cfg;\n \n@@ -159,7 +168,8 @@ impl CrateContext {\n             tn.associate_type(\"tydesc\", &tydesc_type);\n             tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-            let crate_map = decl_crate_map(sess, link_meta, llmod);\n+            let (crate_map_name, crate_map) = decl_crate_map(sess, link_meta,\n+                                                             llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod, name.to_owned()))\n             } else {\n@@ -174,6 +184,7 @@ impl CrateContext {\n                   sess: sess,\n                   llmod: llmod,\n                   llcx: llcx,\n+                  metadata_llmod: metadata_llmod,\n                   td: td,\n                   tn: tn,\n                   externs: HashMap::new(),\n@@ -229,6 +240,7 @@ impl CrateContext {\n                   opaque_vec_type: opaque_vec_type,\n                   builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                   crate_map: crate_map,\n+                  crate_map_name: crate_map_name,\n                   uses_gc: false,\n                   dbg_cx: dbg_cx,\n                   do_not_commit_warning_issued: false"}, {"sha": "ee068d7e6a149ef5c3ac9f9077c52dc549924248", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -15,14 +15,23 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::hashmap::HashSet;\n+use std::local_data;\n use extra;\n \n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n+    local_data_key!(depth: uint);\n     if !do_it { return f(u); }\n+\n+    let old = local_data::get(depth, |d| d.map(|a| *a).unwrap_or(0));\n+    local_data::set(depth, old + 1);\n+\n     let start = extra::time::precise_time_s();\n     let rv = f(u);\n     let end = extra::time::precise_time_s();\n-    println!(\"time: {:3.3f} s\\t{}\", end - start, what);\n+\n+    println!(\"{}time: {:3.3f} s\\t{}\", \"  \".repeat(old), end - start, what);\n+    local_data::set(depth, old);\n+\n     rv\n }\n "}, {"sha": "76e24faebd93b9bdeac3222f3532a02448df76fa", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -211,3 +211,11 @@ extern \"C\" void\n LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n     unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n }\n+\n+extern \"C\" void\n+LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols, size_t len) {\n+    PassManager passes;\n+    ArrayRef<const char*> ref(symbols, len);\n+    passes.add(llvm::createInternalizePass(ref));\n+    passes.run(*unwrap(M));\n+}"}, {"sha": "fb611dd15c227d4a542834788f59871b62dc5358", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -539,3 +539,22 @@ extern \"C\" char *LLVMTypeToString(LLVMTypeRef Type) {\n     unwrap<llvm::Type>(Type)->print(os);\n     return strdup(os.str().data());\n }\n+\n+extern \"C\" bool\n+LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n+    Module *Dst = unwrap(dst);\n+    MemoryBuffer* buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+    std::string Err;\n+    Module *Src = llvm::getLazyBitcodeModule(buf, Dst->getContext(), &Err);\n+    if (Src == NULL) {\n+        LLVMRustError = Err.c_str();\n+        delete buf;\n+        return false;\n+    }\n+\n+    if (Linker::LinkModules(Dst, Src, Linker::DestroySource, &Err)) {\n+        LLVMRustError = Err.c_str();\n+        return false;\n+    }\n+    return true;\n+}"}, {"sha": "ee82fa80f8743bc6b9b457271d4f6713f28c58f8", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -629,3 +629,6 @@ LLVMTypeToString\n LLVMAddColdAttribute\n LLVMCreateMemoryBufferWithMemoryRange\n LLVMCreateMemoryBufferWithMemoryRangeCopy\n+LLVMPassManagerBuilderPopulateLTOPassManager\n+LLVMRustLinkInExternalBitcode\n+LLVMRustRunRestrictionPass"}, {"sha": "ef7199a6ca8cc18fb9a78f5ee3e6c24e7fd3121d", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -19,6 +19,7 @@\n #include \"llvm/Analysis/Verifier.h\"\n #include \"llvm/Analysis/Passes.h\"\n #include \"llvm/Analysis/Lint.h\"\n+#include \"llvm/ADT/ArrayRef.h\"\n #include \"llvm/ADT/Triple.h\"\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/Assembly/Parser.h\"\n@@ -47,6 +48,7 @@\n #include \"llvm/Transforms/Vectorize.h\"\n #include \"llvm/DebugInfo.h\"\n #include \"llvm/DIBuilder.h\"\n+#include \"llvm/Bitcode/ReaderWriter.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n #include \"llvm-c/ExecutionEngine.h\""}, {"sha": "a491fda7dc232bc17517f1a490a9fd0cc52b50d7", "filename": "src/test/run-make/lto-smoke-c/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+\n+ifneq ($(shell uname),Darwin)\n+\tEXTRAFLAGS := -lm -lrt -ldl -lpthread\n+endif\n+\n+all:\n+\t$(RUSTC) foo.rs -Z gen-crate-map -Z lto\n+\tln -s $(call STATICLIB,foo-*) $(call STATICLIB,foo)\n+\t$(CC) bar.c -lfoo -o $(call RUN,bar) $(EXTRAFLAGS) -lstdc++\n+\t$(call RUN,bar)"}, {"sha": "bb4036b06e13b79a32ec78ae04db97590f54b2cc", "filename": "src/test/run-make/lto-smoke-c/bar.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke-c%2Fbar.c", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke-c%2Fbar.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2Fbar.c?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1,6 @@\n+void foo();\n+\n+int main() {\n+    foo();\n+    return 0;\n+}"}, {"sha": "3da09eb6bb6a87b0eca9600106ec86af9b37cd6c", "filename": "src/test/run-make/lto-smoke-c/foo.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke-c%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke-c%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2Ffoo.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1,4 @@\n+#[crate_type = \"staticlib\"];\n+\n+#[no_mangle]\n+pub extern \"C\" fn foo() {}"}, {"sha": "4652556d34401e0378d40f530b396b0d2dac7177", "filename": "src/test/run-make/lto-smoke/Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke%2FMakefile?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1,6 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) lib.rs\n+\t$(RUSTC) main.rs -Z lto\n+\t$(call RUN,main)"}, {"sha": "3cdacc96ee9e01f2d2e8fa0316e906581bdafd19", "filename": "src/test/run-make/lto-smoke/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke%2Flib.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1 @@\n+#[crate_type = \"rlib\"];"}, {"sha": "a3ed67729262b33cfb6216e561a5176fe11eccab", "filename": "src/test/run-make/lto-smoke/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ca4350c8d64facb39311660e8ee919766f481a/src%2Ftest%2Frun-make%2Flto-smoke%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke%2Fmain.rs?ref=29ca4350c8d64facb39311660e8ee919766f481a", "patch": "@@ -0,0 +1,3 @@\n+extern mod lib;\n+\n+fn main() {}"}]}