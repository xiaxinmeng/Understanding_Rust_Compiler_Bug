{"sha": "31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "node_id": "C_kwDOAAsO6NoAKDMxYTRmMmRhNTc1ZjVlMzM1YmRiYmU3ZjEyYTY5NGY5ZTc0YWQwYTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T17:48:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T17:48:24Z"}, "message": "Auto merge of #110907 - Bryanskiy:privacy_ef, r=petrochenkov\n\nPopulate effective visibilities in 'rustc_privacy'\n\nNext part of RFC https://github.com/rust-lang/rust/issues/48054.\n\nr? `@petrochenkov`", "tree": {"sha": "19c7d721507b9dbcc8b373b0ff6a5f5d902ae9d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19c7d721507b9dbcc8b373b0ff6a5f5d902ae9d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "html_url": "https://github.com/rust-lang/rust/commit/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "905d5a38d69328385ce9963c65c385734c60322d", "url": "https://api.github.com/repos/rust-lang/rust/commits/905d5a38d69328385ce9963c65c385734c60322d", "html_url": "https://github.com/rust-lang/rust/commit/905d5a38d69328385ce9963c65c385734c60322d"}, {"sha": "cff85f22f5030fbe7266d272da74a9e76160523c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff85f22f5030fbe7266d272da74a9e76160523c", "html_url": "https://github.com/rust-lang/rust/commit/cff85f22f5030fbe7266d272da74a9e76160523c"}], "stats": {"total": 326, "additions": 181, "deletions": 145}, "files": [{"sha": "aeb6a1601fc24fe611ee656c5b287c2eeee20ae4", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "patch": "@@ -64,14 +64,26 @@ impl EffectiveVisibility {\n         self.at_level(level).is_public()\n     }\n \n-    pub fn from_vis(vis: Visibility) -> EffectiveVisibility {\n+    pub const fn from_vis(vis: Visibility) -> EffectiveVisibility {\n         EffectiveVisibility {\n             direct: vis,\n             reexported: vis,\n             reachable: vis,\n             reachable_through_impl_trait: vis,\n         }\n     }\n+\n+    #[must_use]\n+    pub fn min(mut self, lhs: EffectiveVisibility, tcx: TyCtxt<'_>) -> Self {\n+        for l in Level::all_levels() {\n+            let rhs_vis = self.at_level_mut(l);\n+            let lhs_vis = *lhs.at_level(l);\n+            if rhs_vis.is_at_least(lhs_vis, tcx) {\n+                *rhs_vis = lhs_vis;\n+            };\n+        }\n+        self\n+    }\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n@@ -137,24 +149,6 @@ impl EffectiveVisibilities {\n         };\n     }\n \n-    pub fn set_public_at_level(\n-        &mut self,\n-        id: LocalDefId,\n-        lazy_private_vis: impl FnOnce() -> Visibility,\n-        level: Level,\n-    ) {\n-        let mut effective_vis = self\n-            .effective_vis(id)\n-            .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n-        for l in Level::all_levels() {\n-            if l <= level {\n-                *effective_vis.at_level_mut(l) = Visibility::Public;\n-            }\n-        }\n-        self.map.insert(id, effective_vis);\n-    }\n-\n     pub fn check_invariants(&self, tcx: TyCtxt<'_>, early: bool) {\n         if !cfg!(debug_assertions) {\n             return;\n@@ -219,7 +213,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn update(\n         &mut self,\n         id: Id,\n-        nominal_vis: Visibility,\n+        nominal_vis: Option<Visibility>,\n         lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n@@ -243,12 +237,11 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n                 if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n                     && level != l)\n                 {\n-                    calculated_effective_vis =\n-                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n-                            inherited_effective_vis_at_level\n-                        } else {\n-                            nominal_vis\n-                        };\n+                    calculated_effective_vis = if let Some(nominal_vis) = nominal_vis && !nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n+                        nominal_vis\n+                    } else {\n+                        inherited_effective_vis_at_level\n+                    }\n                 }\n                 // effective visibility can't be decreased at next update call for the\n                 // same id"}, {"sha": "b738ce35ada8039a58a0b30786b4fd188496d3f4", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 154, "deletions": 117, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -38,7 +38,7 @@ use rustc_span::Span;\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n-use std::{cmp, fmt, mem};\n+use std::{fmt, mem};\n \n use errors::{\n     FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n@@ -375,8 +375,9 @@ impl VisibilityLike for ty::Visibility {\n         min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n-impl VisibilityLike for Option<Level> {\n-    const MAX: Self = Some(Level::Direct);\n+\n+impl VisibilityLike for Option<EffectiveVisibility> {\n+    const MAX: Self = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n     // Type inference is very smart sometimes.\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n@@ -388,7 +389,13 @@ impl VisibilityLike for Option<Level> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n-        cmp::min(find.effective_visibilities.public_at_level(def_id), find.min)\n+        if let Some(min) = find.min {\n+            return find\n+                .effective_visibilities\n+                .effective_vis(def_id)\n+                .map(|eff_vis| min.min(*eff_vis, find.tcx));\n+        }\n+        None\n     }\n }\n \n@@ -414,49 +421,79 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n-    /// Previous visibility level; `None` means unreachable.\n-    prev_level: Option<Level>,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    level: Option<Level>,\n+    effective_vis: Option<EffectiveVisibility>,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n+    level: Level,\n }\n \n impl<'tcx> EmbargoVisitor<'tcx> {\n-    fn get(&self, def_id: LocalDefId) -> Option<Level> {\n-        self.effective_visibilities.public_at_level(def_id)\n-    }\n-\n-    /// Updates node level and returns the updated level.\n-    fn update(&mut self, def_id: LocalDefId, level: Option<Level>) -> Option<Level> {\n-        let old_level = self.get(def_id);\n-        // Visibility levels can only grow.\n-        if level > old_level {\n-            self.effective_visibilities.set_public_at_level(\n-                def_id,\n-                || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n-                level.unwrap(),\n-            );\n-            self.changed = true;\n-            level\n-        } else {\n-            old_level\n+    fn get(&self, def_id: LocalDefId) -> Option<EffectiveVisibility> {\n+        self.effective_visibilities.effective_vis(def_id).copied()\n+    }\n+\n+    // Updates node effective visibility.\n+    fn update(\n+        &mut self,\n+        def_id: LocalDefId,\n+        inherited_effective_vis: Option<EffectiveVisibility>,\n+        level: Level,\n+    ) {\n+        let nominal_vis = self.tcx.local_visibility(def_id);\n+        self.update_eff_vis(def_id, inherited_effective_vis, Some(nominal_vis), level);\n+    }\n+\n+    fn update_eff_vis(\n+        &mut self,\n+        def_id: LocalDefId,\n+        inherited_effective_vis: Option<EffectiveVisibility>,\n+        nominal_vis: Option<ty::Visibility>,\n+        level: Level,\n+    ) {\n+        if let Some(inherited_effective_vis) = inherited_effective_vis {\n+            let private_vis =\n+                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n+            if Some(private_vis) != nominal_vis {\n+                self.changed |= self.effective_visibilities.update(\n+                    def_id,\n+                    nominal_vis,\n+                    || private_vis,\n+                    inherited_effective_vis,\n+                    level,\n+                    self.tcx,\n+                );\n+            }\n         }\n     }\n \n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        level: Option<Level>,\n+        effective_vis: Option<EffectiveVisibility>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            level: cmp::min(level, Some(Level::Reachable)),\n+            effective_vis,\n             item_def_id: def_id,\n             ev: self,\n+            level: Level::Reachable,\n+        }\n+    }\n+\n+    fn reach_through_impl_trait(\n+        &mut self,\n+        def_id: LocalDefId,\n+        effective_vis: Option<EffectiveVisibility>,\n+    ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n+        ReachEverythingInTheInterfaceVisitor {\n+            effective_vis,\n+            item_def_id: def_id,\n+            ev: self,\n+            level: Level::ReachableThroughImplTrait,\n         }\n     }\n \n@@ -477,16 +514,18 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             return;\n         }\n \n-        if self.get(local_def_id).is_none() {\n+        if self.effective_visibilities.public_at_level(local_def_id).is_none() {\n             return;\n         }\n \n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n+        let macro_ev = self.get(local_def_id);\n+        assert!(macro_ev.is_some());\n         loop {\n             let changed_reachability =\n-                self.update_macro_reachable(module_def_id, macro_module_def_id);\n+                self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n             if changed_reachability || module_def_id == CRATE_DEF_ID {\n                 break;\n             }\n@@ -500,21 +539,33 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n+        macro_ev: Option<EffectiveVisibility>,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n-            self.update_macro_reachable_mod(module_def_id, defining_mod);\n+            self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n+    fn update_macro_reachable_mod(\n+        &mut self,\n+        module_def_id: LocalDefId,\n+        defining_mod: LocalDefId,\n+        macro_ev: Option<EffectiveVisibility>,\n+    ) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.owner_id);\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n-            self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n+            self.update_macro_reachable_def(\n+                item_id.owner_id.def_id,\n+                def_kind,\n+                vis,\n+                defining_mod,\n+                macro_ev,\n+            );\n         }\n         for child in self.tcx.module_children_local(module_def_id) {\n             // FIXME: Use module children for the logic above too.\n@@ -523,7 +574,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 && let Res::Def(def_kind, def_id) = child.res\n                 && let Some(def_id) = def_id.as_local() {\n                 let vis = self.tcx.local_visibility(def_id);\n-                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n+                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod, macro_ev);\n             }\n         }\n     }\n@@ -534,16 +585,14 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n+        macro_ev: Option<EffectiveVisibility>,\n     ) {\n-        let level = Some(Level::Reachable);\n-        if vis.is_public() {\n-            self.update(def_id, level);\n-        }\n+        self.update(def_id, macro_ev, Level::Reachable);\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(def_id, level);\n+                    self.update(def_id, macro_ev, Level::Reachable);\n                 }\n             }\n \n@@ -555,7 +604,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module, self.tcx) {\n-                        self.update(def_id, level);\n+                        self.update(def_id, macro_ev, Level::Reachable);\n                     }\n                 }\n             }\n@@ -566,26 +615,24 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             // the module, however may be reachable.\n             DefKind::Mod => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update_macro_reachable(def_id, module);\n+                    self.update_macro_reachable(def_id, module, macro_ev);\n                 }\n             }\n \n             DefKind::Struct | DefKind::Union => {\n                 // While structs and unions have type privacy, their fields do not.\n-                if vis.is_public() {\n-                    let item = self.tcx.hir().expect_item(def_id);\n-                    if let hir::ItemKind::Struct(ref struct_def, _)\n-                    | hir::ItemKind::Union(ref struct_def, _) = item.kind\n-                    {\n-                        for field in struct_def.fields() {\n-                            let field_vis = self.tcx.local_visibility(field.def_id);\n-                            if field_vis.is_accessible_from(module, self.tcx) {\n-                                self.reach(field.def_id, level).ty();\n-                            }\n+                let item = self.tcx.hir().expect_item(def_id);\n+                if let hir::ItemKind::Struct(ref struct_def, _)\n+                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                {\n+                    for field in struct_def.fields() {\n+                        let field_vis = self.tcx.local_visibility(field.def_id);\n+                        if field_vis.is_accessible_from(module, self.tcx) {\n+                            self.reach(field.def_id, macro_ev).ty();\n                         }\n-                    } else {\n-                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                     }\n+                } else {\n+                    bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                 }\n             }\n \n@@ -629,14 +676,16 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_level = match item.kind {\n+        let item_ev = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_level = Option::<Level>::of_impl(\n+                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n                     item.owner_id.def_id,\n                     self.tcx,\n                     &self.effective_visibilities,\n                 );\n-                self.update(item.owner_id.def_id, impl_level)\n+\n+                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n+                impl_ev\n             }\n             _ => self.get(item.owner_id.def_id),\n         };\n@@ -645,48 +694,40 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants {\n-                    let variant_level = self.update(variant.def_id, item_level);\n+                    self.update(variant.def_id, item_ev, Level::Reachable);\n+                    let variant_ev = self.get(variant.def_id);\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, item_level);\n+                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n                     }\n                     for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_level);\n+                        self.update(field.def_id, variant_ev, Level::Reachable);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n-                    if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n-                    {\n-                        self.update(impl_item_ref.id.owner_id.def_id, item_level);\n-                    }\n+                    self.update(impl_item_ref.id.owner_id.def_id, item_ev, Level::Direct);\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_level);\n+                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_level);\n+                    self.update(ctor_def_id, item_ev, Level::Reachable);\n                 }\n                 for field in def.fields() {\n-                    let vis = self.tcx.visibility(field.def_id);\n-                    if vis.is_public() {\n-                        self.update(field.def_id, item_level);\n-                    }\n+                    self.update(field.def_id, item_ev, Level::Reachable);\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    if self.tcx.visibility(foreign_item.id.owner_id).is_public() {\n-                        self.update(foreign_item.id.owner_id.def_id, item_level);\n-                    }\n+                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n                 }\n             }\n \n@@ -721,26 +762,30 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n-                    self.reach(item.owner_id.def_id, exist_level).generics().predicates().ty();\n+                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n+                    self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n+                        .generics()\n+                        .predicates()\n+                        .ty();\n                 }\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates().ty();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n+\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -754,23 +799,24 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level)\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.owner_id.def_id);\n-                        if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_level)\n+                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n+\n+                        if impl_item_ev.is_some() {\n+                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -781,33 +827,33 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_level = self.get(variant.def_id);\n-                    if variant_level.is_some() {\n+                    let variant_ev = self.get(variant.def_id);\n+                    if variant_ev.is_some() {\n                         for field in variant.data.fields() {\n-                            self.reach(field.def_id, variant_level).ty();\n+                            self.reach(field.def_id, variant_ev).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.owner_id.def_id, variant_level).ty();\n+                        self.reach(item.owner_id.def_id, variant_ev).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_level = self.get(ctor_def_id);\n-                        if ctor_level.is_some() {\n-                            self.reach(item.owner_id.def_id, ctor_level).ty();\n+                        let ctor_ev = self.get(ctor_def_id);\n+                        if ctor_ev.is_some() {\n+                            self.reach(item.owner_id.def_id, ctor_ev).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_level)\n+                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n+                    if foreign_item_ev.is_some() {\n+                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -816,36 +862,32 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(field.def_id);\n-                        if field_level.is_some() {\n-                            self.reach(field.def_id, field_level).ty();\n+                        let field_ev = self.get(field.def_id);\n+                        if field_ev.is_some() {\n+                            self.reach(field.def_id, field_ev).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_level = self.get(ctor_def_id);\n-                    if ctor_level.is_some() {\n-                        self.reach(item.owner_id.def_id, ctor_level).ty();\n+                    let ctor_ev = self.get(ctor_def_id);\n+                    if ctor_ev.is_some() {\n+                        self.reach(item.owner_id.def_id, ctor_ev).ty();\n                     }\n                 }\n             }\n         }\n \n-        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n-        self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n-        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n-        self.prev_level = orig_level;\n     }\n }\n \n@@ -899,11 +941,7 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            if let (ty::Visibility::Public, _) | (_, Some(Level::ReachableThroughImplTrait)) =\n-                (self.tcx().visibility(def_id.to_def_id()), self.level)\n-            {\n-                self.ev.update(def_id, self.level);\n-            }\n+            self.ev.update_eff_vis(def_id, self.effective_vis, None, self.level);\n         }\n         ControlFlow::Continue(())\n     }\n@@ -2131,7 +2169,6 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         tcx,\n         effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n-        prev_level: Some(Level::Direct),\n         changed: false,\n     };\n "}, {"sha": "7393bdb388a56e8c57db275de99a4e4b0e2701be", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "patch": "@@ -199,7 +199,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n-            nominal_vis,\n+            Some(nominal_vis),\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n@@ -213,7 +213,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n-            nominal_vis,\n+            Some(nominal_vis),\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),"}, {"sha": "2568aaf34f3fbe1dd098e7d9e5445e9dd01affa0", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=31a4f2da575f5e335bdbbe7f12a694f9e74ad0a1", "patch": "@@ -310,6 +310,7 @@ where\n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n #[derive(Clone, Debug)]\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n struct FlattenCompat<I, U> {\n     iter: Fuse<I>,\n     frontiter: Option<U>,\n@@ -463,6 +464,7 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> Iterator for FlattenCompat<I, U>\n where\n     I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -577,6 +579,7 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n where\n     I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -646,20 +649,23 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <[T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = [T; N]>,\n {\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a [T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = &'a [T; N]>,\n {\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a mut [T; N] as IntoIterator>::IntoIter>\n where"}]}