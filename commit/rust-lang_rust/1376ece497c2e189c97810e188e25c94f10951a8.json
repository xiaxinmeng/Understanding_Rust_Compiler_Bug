{"sha": "1376ece497c2e189c97810e188e25c94f10951a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNzZlY2U0OTdjMmUxODljOTc4MTBlMTg4ZTI1Yzk0ZjEwOTUxYTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-12T10:18:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-12T10:18:02Z"}, "message": "Merge #9863\n\n9863: feat: Generate default trait fn impl when generating `PartialEq` r=yoshuawuyts a=yoshuawuyts\n\nImplements a default trait function body when generating the `PartialEq` trait for a type. Thanks!\r\n\r\nr? `@veykril`\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>", "tree": {"sha": "42c23507e13b968f033d7d29396f5675e7e79beb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42c23507e13b968f033d7d29396f5675e7e79beb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1376ece497c2e189c97810e188e25c94f10951a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhFPVaCRBK7hj4Ov3rIwAAhmUIAC3v5+YLPKJ812UvLQGUZS1H\nNhI2SoaQ7Ul2MX6NVyvKGUyZdpjxpt48pTGnyixUvSmQdPjfSamxwTxXkV2B7zj6\nPkeJSVi/0Wf5gTcV2NGKmA7IrObudwZ/QEeGSIUWVH0I3xZf+Nvlljnbbvj/LRHf\nKSLC0YAX5/9d14YeO9EWBdm/TGhTIXydaZSW+U8GItsmIDqwI0kl3OzQoEFUdQGV\nPrGNsQUI/GAwYUK5fDta6+q3x7YCUEGYfCmmnVrtWmtxg0EchjHAKa72hZM+eiYz\nnFDfO1dtv85cFm4mG+O0HYdCJQE+ujHDfdqh777QDLO1PP6FnhkZSq35xvCdLbM=\n=uqMV\n-----END PGP SIGNATURE-----\n", "payload": "tree 42c23507e13b968f033d7d29396f5675e7e79beb\nparent 2511e1bc35abec0cd56695c2d52ff5e572576943\nparent 97ec6a27ecb9bd643903c343397e69fd2c01d77e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628763482 +0000\ncommitter GitHub <noreply@github.com> 1628763482 +0000\n\nMerge #9863\n\n9863: feat: Generate default trait fn impl when generating `PartialEq` r=yoshuawuyts a=yoshuawuyts\n\nImplements a default trait function body when generating the `PartialEq` trait for a type. Thanks!\r\n\r\nr? `@veykril`\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1376ece497c2e189c97810e188e25c94f10951a8", "html_url": "https://github.com/rust-lang/rust/commit/1376ece497c2e189c97810e188e25c94f10951a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1376ece497c2e189c97810e188e25c94f10951a8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2511e1bc35abec0cd56695c2d52ff5e572576943", "url": "https://api.github.com/repos/rust-lang/rust/commits/2511e1bc35abec0cd56695c2d52ff5e572576943", "html_url": "https://github.com/rust-lang/rust/commit/2511e1bc35abec0cd56695c2d52ff5e572576943"}, {"sha": "97ec6a27ecb9bd643903c343397e69fd2c01d77e", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ec6a27ecb9bd643903c343397e69fd2c01d77e", "html_url": "https://github.com/rust-lang/rust/commit/97ec6a27ecb9bd643903c343397e69fd2c01d77e"}], "stats": {"total": 438, "additions": 418, "deletions": 20}, "files": [{"sha": "d29a312eba59e77f3b503801c46909c17bcfbcb0", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=1376ece497c2e189c97810e188e25c94f10951a8", "patch": "@@ -606,6 +606,177 @@ impl Clone for Foo {\n         }\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_record_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq\n+#[derive(Partial$0Eq)]\n+struct Foo {\n+    bin: usize,\n+    bar: usize,\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bin: usize,\n+    bar: usize,\n+}\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        self.bin == other.bin && self.bar == other.bar\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_tuple_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq\n+#[derive(Partial$0Eq)]\n+struct Foo(usize, usize);\n+\"#,\n+            r#\"\n+struct Foo(usize, usize);\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0 && self.1 == other.1\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_empty_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq\n+#[derive(Partial$0Eq)]\n+struct Foo;\n+\"#,\n+            r#\"\n+struct Foo;\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        true\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq\n+#[derive(Partial$0Eq)]\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        core::mem::discriminant(self) == core::mem::discriminant(other)\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_tuple_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq\n+#[derive(Partial$0Eq)]\n+enum Foo {\n+    Bar(String),\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar(String),\n+    Baz,\n+}\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Bar(l0), Self::Bar(r0)) => l0 == r0,\n+            _ => core::mem::discriminant(self) == core::mem::discriminant(other),\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_record_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq\n+#[derive(Partial$0Eq)]\n+enum Foo {\n+    Bar {\n+        bin: String,\n+    },\n+    Baz {\n+        qux: String,\n+        fez: String,\n+    },\n+    Qux {},\n+    Bin,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar {\n+        bin: String,\n+    },\n+    Baz {\n+        qux: String,\n+        fez: String,\n+    },\n+    Qux {},\n+    Bin,\n+}\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Bar { bin: l_bin }, Self::Bar { bin: r_bin }) => l_bin == r_bin,\n+            (Self::Baz { qux: l_qux, fez: l_fez }, Self::Baz { qux: r_qux, fez: r_fez }) => l_qux == r_qux && l_fez == r_fez,\n+            _ => core::mem::discriminant(self) == core::mem::discriminant(other),\n+        }\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "111fa0b23fcf388b94608aeb32409ae5fb117c32", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 184, "deletions": 20, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=1376ece497c2e189c97810e188e25c94f10951a8", "patch": "@@ -20,6 +20,7 @@ pub(crate) fn gen_trait_fn_body(\n         \"Debug\" => gen_debug_impl(adt, func),\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n+        \"PartialEq\" => gen_partial_eq(adt, func),\n         _ => None,\n     }\n }\n@@ -38,9 +39,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let left = make::ext::ident_path(\"Self\");\n-                let right = make::ext::ident_path(&format!(\"{}\", name));\n-                let variant_name = make::path_concat(left, right);\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n \n                 match variant.field_list() {\n                     // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n@@ -150,9 +149,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let left = make::ext::ident_path(\"Self\");\n-                let right = make::ext::ident_path(&format!(\"{}\", name));\n-                let variant_name = make::path_pat(make::path_concat(left, right));\n+                let variant_name =\n+                    make::path_pat(make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?);\n \n                 let target = make::expr_path(make::ext::ident_path(\"f\").into());\n                 let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n@@ -224,11 +222,9 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n /// Generate a `Debug` impl based on the fields and members of the target type.\n fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n-    fn gen_default_call() -> ast::Expr {\n-        let trait_name = make::ext::ident_path(\"Default\");\n-        let method_name = make::ext::ident_path(\"default\");\n-        let fn_name = make::expr_path(make::path_concat(trait_name, method_name));\n-        make::expr_call(fn_name, make::arg_list(None))\n+    fn gen_default_call() -> Option<ast::Expr> {\n+        let fn_name = make::ext::path_from_idents([\"Default\", \"default\"])?;\n+        Some(make::expr_call(make::expr_path(fn_name), make::arg_list(None)))\n     }\n     match adt {\n         // `Debug` cannot be derived for unions, so no default impl can be provided.\n@@ -240,7 +236,7 @@ fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 Some(ast::FieldList::RecordFieldList(field_list)) => {\n                     let mut fields = vec![];\n                     for field in field_list.fields() {\n-                        let method_call = gen_default_call();\n+                        let method_call = gen_default_call()?;\n                         let name_ref = make::name_ref(&field.name()?.to_string());\n                         let field = make::record_expr_field(name_ref, Some(method_call));\n                         fields.push(field);\n@@ -251,7 +247,10 @@ fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 }\n                 Some(ast::FieldList::TupleFieldList(field_list)) => {\n                     let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n-                    let fields = field_list.fields().map(|_| gen_default_call());\n+                    let fields = field_list\n+                        .fields()\n+                        .map(|_| gen_default_call())\n+                        .collect::<Option<Vec<ast::Expr>>>()?;\n                     make::expr_call(struct_name, make::arg_list(fields))\n                 }\n                 None => {\n@@ -273,8 +272,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         let method = make::name_ref(\"hash\");\n         let arg = make::expr_path(make::ext::ident_path(\"state\"));\n         let expr = make::expr_method_call(target, method, make::arg_list(Some(arg)));\n-        let stmt = make::expr_stmt(expr);\n-        stmt.into()\n+        make::expr_stmt(expr).into()\n     }\n \n     let body = match adt {\n@@ -283,11 +281,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n         // => std::mem::discriminant(self).hash(state);\n         ast::Adt::Enum(_) => {\n-            let root = make::ext::ident_path(\"core\");\n-            let submodule = make::ext::ident_path(\"mem\");\n-            let fn_name = make::ext::ident_path(\"discriminant\");\n-            let fn_name = make::path_concat(submodule, fn_name);\n-            let fn_name = make::expr_path(make::path_concat(root, fn_name));\n+            let fn_name = make_discriminant()?;\n \n             let arg = make::expr_path(make::ext::ident_path(\"self\"));\n             let fn_call = make::expr_call(fn_name, make::arg_list(Some(arg)));\n@@ -326,3 +320,173 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n     Some(())\n }\n+\n+/// Generate a `PartialEq` impl based on the fields and members of the target type.\n+fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n+        match expr {\n+            Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n+            None => Some(cmp),\n+        }\n+    }\n+\n+    fn gen_record_pat_field(field_name: &str, pat_name: &str) -> ast::RecordPatField {\n+        let pat = make::ext::simple_ident_pat(make::name(&pat_name));\n+        let name_ref = make::name_ref(field_name);\n+        make::record_pat_field(name_ref, pat.into())\n+    }\n+\n+    fn gen_record_pat(record_name: ast::Path, fields: Vec<ast::RecordPatField>) -> ast::RecordPat {\n+        let list = make::record_pat_field_list(fields);\n+        make::record_pat_with_fields(record_name, list)\n+    }\n+\n+    fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n+        make::ext::path_from_idents([\"Self\", &variant.name()?.to_string()])\n+    }\n+\n+    fn gen_tuple_field(field_name: &String) -> ast::Pat {\n+        ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n+    }\n+\n+    // FIXME: return `None` if the trait carries a generic type; we can only\n+    // generate this code `Self` for the time being.\n+\n+    let body = match adt {\n+        // `Hash` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => return None,\n+\n+        ast::Adt::Enum(enum_) => {\n+            // => std::mem::discriminant(self) == std::mem::discriminant(other)\n+            let lhs_name = make::expr_path(make::ext::ident_path(\"self\"));\n+            let lhs = make::expr_call(make_discriminant()?, make::arg_list(Some(lhs_name.clone())));\n+            let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n+            let rhs = make::expr_call(make_discriminant()?, make::arg_list(Some(rhs_name.clone())));\n+            let eq_check = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+\n+            let mut case_count = 0;\n+            let mut arms = vec![];\n+            for variant in enum_.variant_list()?.variants() {\n+                case_count += 1;\n+                match variant.field_list() {\n+                    // => (Self::Bar { bin: l_bin }, Self::Bar { bin: r_bin }) => l_bin == r_bin,\n+                    Some(ast::FieldList::RecordFieldList(list)) => {\n+                        let mut expr = None;\n+                        let mut l_fields = vec![];\n+                        let mut r_fields = vec![];\n+\n+                        for field in list.fields() {\n+                            let field_name = field.name()?.to_string();\n+\n+                            let l_name = &format!(\"l_{}\", field_name);\n+                            l_fields.push(gen_record_pat_field(&field_name, &l_name));\n+\n+                            let r_name = &format!(\"r_{}\", field_name);\n+                            r_fields.push(gen_record_pat_field(&field_name, &r_name));\n+\n+                            let lhs = make::expr_path(make::ext::ident_path(l_name));\n+                            let rhs = make::expr_path(make::ext::ident_path(r_name));\n+                            let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                            expr = gen_eq_chain(expr, cmp);\n+                        }\n+\n+                        let left = gen_record_pat(gen_variant_path(&variant)?, l_fields);\n+                        let right = gen_record_pat(gen_variant_path(&variant)?, r_fields);\n+                        let tuple = make::tuple_pat(vec![left.into(), right.into()]);\n+\n+                        if let Some(expr) = expr {\n+                            arms.push(make::match_arm(Some(tuple.into()), None, expr));\n+                        }\n+                    }\n+\n+                    Some(ast::FieldList::TupleFieldList(list)) => {\n+                        let mut expr = None;\n+                        let mut l_fields = vec![];\n+                        let mut r_fields = vec![];\n+\n+                        for (i, _) in list.fields().enumerate() {\n+                            let field_name = format!(\"{}\", i);\n+\n+                            let l_name = format!(\"l{}\", field_name);\n+                            l_fields.push(gen_tuple_field(&l_name));\n+\n+                            let r_name = format!(\"r{}\", field_name);\n+                            r_fields.push(gen_tuple_field(&r_name));\n+\n+                            let lhs = make::expr_path(make::ext::ident_path(&l_name));\n+                            let rhs = make::expr_path(make::ext::ident_path(&r_name));\n+                            let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                            expr = gen_eq_chain(expr, cmp);\n+                        }\n+\n+                        let left = make::tuple_struct_pat(gen_variant_path(&variant)?, l_fields);\n+                        let right = make::tuple_struct_pat(gen_variant_path(&variant)?, r_fields);\n+                        let tuple = make::tuple_pat(vec![left.into(), right.into()]);\n+\n+                        if let Some(expr) = expr {\n+                            arms.push(make::match_arm(Some(tuple.into()), None, expr));\n+                        }\n+                    }\n+                    None => continue,\n+                }\n+            }\n+\n+            let expr = match arms.len() {\n+                0 => eq_check,\n+                _ => {\n+                    if case_count > arms.len() {\n+                        let lhs = make::wildcard_pat().into();\n+                        arms.push(make::match_arm(Some(lhs), None, eq_check));\n+                    }\n+\n+                    let match_target = make::expr_tuple(vec![lhs_name, rhs_name]);\n+                    let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+                    make::expr_match(match_target, list)\n+                }\n+            };\n+\n+            make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n+        }\n+        ast::Adt::Struct(strukt) => match strukt.field_list() {\n+            Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                let mut expr = None;\n+                for field in field_list.fields() {\n+                    let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n+                    let lhs = make::expr_field(lhs, &field.name()?.to_string());\n+                    let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n+                    let rhs = make::expr_field(rhs, &field.name()?.to_string());\n+                    let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                    expr = gen_eq_chain(expr, cmp);\n+                }\n+                make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n+            }\n+\n+            Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                let mut expr = None;\n+                for (i, _) in field_list.fields().enumerate() {\n+                    let idx = format!(\"{}\", i);\n+                    let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n+                    let lhs = make::expr_field(lhs, &idx);\n+                    let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n+                    let rhs = make::expr_field(rhs, &idx);\n+                    let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                    expr = gen_eq_chain(expr, cmp);\n+                }\n+                make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n+            }\n+\n+            // No fields in the body means there's nothing to hash.\n+            None => {\n+                let expr = make::expr_literal(\"true\").into();\n+                make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n+            }\n+        },\n+    };\n+\n+    ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+    Some(())\n+}\n+\n+fn make_discriminant() -> Option<ast::Expr> {\n+    Some(make::expr_path(make::ext::path_from_idents([\"core\", \"mem\", \"discriminant\"])?))\n+}"}, {"sha": "2dfb0d1ad31cfeb516e521e7041c88e6d2a00661", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=1376ece497c2e189c97810e188e25c94f10951a8", "patch": "@@ -160,6 +160,18 @@ pub enum ElseBranch {\n     IfExpr(ast::IfExpr),\n }\n \n+impl From<ast::BlockExpr> for ElseBranch {\n+    fn from(block_expr: ast::BlockExpr) -> Self {\n+        Self::Block(block_expr)\n+    }\n+}\n+\n+impl From<ast::IfExpr> for ElseBranch {\n+    fn from(if_expr: ast::IfExpr) -> Self {\n+        Self::IfExpr(if_expr)\n+    }\n+}\n+\n impl ast::IfExpr {\n     pub fn then_branch(&self) -> Option<ast::BlockExpr> {\n         self.blocks().next()\n@@ -350,6 +362,42 @@ impl ast::BinExpr {\n     }\n }\n \n+impl std::fmt::Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            BinOp::BooleanOr => write!(f, \"||\"),\n+            BinOp::BooleanAnd => write!(f, \"&&\"),\n+            BinOp::EqualityTest => write!(f, \"==\"),\n+            BinOp::NegatedEqualityTest => write!(f, \"!=\"),\n+            BinOp::LesserEqualTest => write!(f, \"<=\"),\n+            BinOp::GreaterEqualTest => write!(f, \">=\"),\n+            BinOp::LesserTest => write!(f, \"<\"),\n+            BinOp::GreaterTest => write!(f, \">\"),\n+            BinOp::Addition => write!(f, \"+\"),\n+            BinOp::Multiplication => write!(f, \"*\"),\n+            BinOp::Subtraction => write!(f, \"-\"),\n+            BinOp::Division => write!(f, \"/\"),\n+            BinOp::Remainder => write!(f, \"%\"),\n+            BinOp::LeftShift => write!(f, \"<<\"),\n+            BinOp::RightShift => write!(f, \">>\"),\n+            BinOp::BitwiseXor => write!(f, \"^\"),\n+            BinOp::BitwiseOr => write!(f, \"|\"),\n+            BinOp::BitwiseAnd => write!(f, \"&\"),\n+            BinOp::Assignment => write!(f, \"=\"),\n+            BinOp::AddAssign => write!(f, \"+=\"),\n+            BinOp::DivAssign => write!(f, \"/=\"),\n+            BinOp::MulAssign => write!(f, \"*=\"),\n+            BinOp::RemAssign => write!(f, \"%=\"),\n+            BinOp::ShrAssign => write!(f, \">>=\"),\n+            BinOp::ShlAssign => write!(f, \"<<=\"),\n+            BinOp::SubAssign => write!(f, \"-\"),\n+            BinOp::BitOrAssign => write!(f, \"|=\"),\n+            BinOp::BitAndAssign => write!(f, \"&=\"),\n+            BinOp::BitXorAssign => write!(f, \"^=\"),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum RangeOp {\n     /// `..`"}, {"sha": "e6fab72ac0526d984d5aaf3ec55e73e57077cad7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1376ece497c2e189c97810e188e25c94f10951a8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=1376ece497c2e189c97810e188e25c94f10951a8", "patch": "@@ -32,6 +32,18 @@ pub mod ext {\n         path_unqualified(path_segment(name_ref(ident)))\n     }\n \n+    pub fn path_from_idents<'a>(\n+        parts: impl std::iter::IntoIterator<Item = &'a str>,\n+    ) -> Option<ast::Path> {\n+        let mut iter = parts.into_iter();\n+        let base = ext::ident_path(iter.next()?);\n+        let path = iter.fold(base, |base, s| {\n+            let path = ext::ident_path(s);\n+            path_concat(base, path)\n+        });\n+        Some(path)\n+    }\n+\n     pub fn expr_unreachable() -> ast::Expr {\n         expr_from_text(\"unreachable!()\")\n     }\n@@ -264,6 +276,9 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n pub fn expr_continue() -> ast::Expr {\n     expr_from_text(\"continue\")\n }\n+pub fn expr_op(op: ast::BinOp, lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n+    expr_from_text(&format!(\"{} {} {}\", lhs, op, rhs))\n+}\n pub fn expr_break(expr: Option<ast::Expr>) -> ast::Expr {\n     match expr {\n         Some(expr) => expr_from_text(&format!(\"break {}\", expr)),"}]}