{"sha": "c511955a9ff89089bff313cd8a87a6e62e2783f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MTE5NTVhOWZmODkwODliZmYzMTNjZDhhODdhNmU2MmUyNzgzZjU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-25T22:51:50Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Factor out the two specialization steps", "tree": {"sha": "ccf736918abcb6547af4b5dcbcd875dd1afc01a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccf736918abcb6547af4b5dcbcd875dd1afc01a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c511955a9ff89089bff313cd8a87a6e62e2783f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c511955a9ff89089bff313cd8a87a6e62e2783f5", "html_url": "https://github.com/rust-lang/rust/commit/c511955a9ff89089bff313cd8a87a6e62e2783f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c511955a9ff89089bff313cd8a87a6e62e2783f5/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "html_url": "https://github.com/rust-lang/rust/commit/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7"}], "stats": {"total": 187, "additions": 107, "deletions": 80}, "files": [{"sha": "7dbde71b2a60efa11c0b5e67a351414ade7d2ea0", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 107, "deletions": 80, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/c511955a9ff89089bff313cd8a87a6e62e2783f5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c511955a9ff89089bff313cd8a87a6e62e2783f5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=c511955a9ff89089bff313cd8a87a6e62e2783f5", "patch": "@@ -1132,6 +1132,66 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    /// Returns whether `self` is covered by `other`, ie whether `self` is a subset of `other`. For\n+    /// the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n+    /// this checks for inclusion.\n+    fn is_covered_by<'p>(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        other: &Constructor<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        match (self, other) {\n+            (Single, Single) => true,\n+            (Variant(self_id), Variant(other_id)) => self_id == other_id,\n+\n+            (IntRange(self_range), IntRange(other_range)) => {\n+                if self_range.intersection(cx.tcx, other_range).is_some() {\n+                    // Constructor splitting should ensure that all intersections we encounter\n+                    // are actually inclusions.\n+                    assert!(self_range.is_subrange(other_range));\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            (\n+                FloatRange(self_from, self_to, self_end),\n+                FloatRange(other_from, other_to, other_end),\n+            ) => {\n+                match (\n+                    compare_const_vals(cx.tcx, self_to, other_to, cx.param_env, ty),\n+                    compare_const_vals(cx.tcx, self_from, other_from, cx.param_env, ty),\n+                ) {\n+                    (Some(to), Some(from)) => {\n+                        (from == Ordering::Greater || from == Ordering::Equal)\n+                            && (to == Ordering::Less\n+                                || (other_end == self_end && to == Ordering::Equal))\n+                    }\n+                    _ => false,\n+                }\n+            }\n+            (Str(self_val), Str(other_val)) => {\n+                // FIXME: there's probably a more direct way of comparing for equality\n+                match compare_const_vals(cx.tcx, self_val, other_val, cx.param_env, ty) {\n+                    Some(comparison) => comparison == Ordering::Equal,\n+                    None => false,\n+                }\n+            }\n+\n+            (Slice(self_slice), Slice(other_slice)) => {\n+                other_slice.pattern_kind().covers_length(self_slice.arity())\n+            }\n+\n+            // We are trying to inspect an opaque constant. Thus we skip the row.\n+            (Opaque, _) | (_, Opaque) => false,\n+            // Only a wildcard pattern can match the special extra constructor.\n+            (NonExhaustive, _) => false,\n+\n+            _ => bug!(\"trying to compare incompatible constructors {:?} and {:?}\", self, other),\n+        }\n+    }\n+\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n@@ -1461,6 +1521,41 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         }\n     }\n \n+    /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n+    /// that is compatible with the constructor used to build `self`.\n+    /// This is meant to be used on the result of `Fields::wildcards()`. The idea is that\n+    /// `wildcards` constructs a list of fields where all entries are wildcards, and the pattern\n+    /// provided to this function fills some of the fields with non-wildcards.\n+    /// In the following example `Fields::wildcards` would return `[_, _, _, _]`. If we call\n+    /// `replace_with_pattern_arguments` on it with the pattern, the result will be `[Some(0), _,\n+    /// _, _]`.\n+    /// ```rust\n+    /// let x: [Option<u8>; 4] = foo();\n+    /// match x {\n+    ///     [Some(0), ..] => {}\n+    /// }\n+    /// ```\n+    fn replace_with_pattern_arguments(&self, pat: &'p Pat<'tcx>) -> Self {\n+        match pat.kind.as_ref() {\n+            PatKind::Deref { subpattern } => Self::from_single_pattern(subpattern),\n+            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+                self.replace_with_fieldpats(subpatterns)\n+            }\n+            PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. } => {\n+                // Number of subpatterns for the constructor\n+                let ctor_arity = self.len();\n+\n+                // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n+                // the middle if there was a subslice pattern `..`.\n+                let prefix = prefix.iter().enumerate();\n+                let suffix =\n+                    suffix.iter().enumerate().map(|(i, p)| (ctor_arity - suffix.len() + i, p));\n+                self.replace_fields_indexed(prefix.chain(suffix))\n+            }\n+            _ => self.clone(),\n+        }\n+    }\n+\n     fn push_on_patstack(self, stack: &[&'p Pat<'tcx>]) -> PatStack<'p, 'tcx> {\n         let pats: SmallVec<_> = match self {\n             Fields::Slice(pats) => pats.iter().chain(stack.iter().copied()).collect(),\n@@ -2535,89 +2630,21 @@ fn specialize_one_pattern<'p, 'tcx>(\n         return Some(ctor_wild_subpatterns.clone());\n     }\n \n-    let ty = pat.ty;\n-    // `unwrap` is safe because `pat` is not a wildcard.\n-    let pat_ctor = pat_constructor(cx.tcx, cx.param_env, pat).unwrap();\n-\n-    let ctor_covered_by_pat = match (ctor, &pat_ctor) {\n-        (Single, Single) => true,\n-        (Variant(ctor_id), Variant(pat_id)) => ctor_id == pat_id,\n-\n-        (IntRange(ctor_range), IntRange(pat_range)) => {\n-            if ctor_range.intersection(cx.tcx, pat_range).is_some() {\n-                // Constructor splitting should ensure that all intersections we encounter\n-                // are actually inclusions.\n-                assert!(ctor_range.is_subrange(pat_range));\n-                true\n-            } else {\n-                false\n-            }\n+    // We return `None` if `ctor` is not covered by `pat`. If `ctor` is known to be derived from\n+    // `pat` then we don't need to check; otherwise, we compute the constructor of `pat` and check\n+    // for constructor inclusion.\n+    // Note that this shortcut is also necessary for correctness: a pattern should always be\n+    // specializable with its own constructor, even in cases where we refuse to inspect values like\n+    // opaque constants.\n+    if !is_its_own_ctor {\n+        // `unwrap` is safe because `pat` is not a wildcard.\n+        let pat_ctor = pat_constructor(cx.tcx, cx.param_env, pat).unwrap();\n+        if !ctor.is_covered_by(cx, &pat_ctor, pat.ty) {\n+            return None;\n         }\n-        (FloatRange(ctor_from, ctor_to, ctor_end), FloatRange(pat_from, pat_to, pat_end)) => {\n-            let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n-            let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n-            (from == Ordering::Greater || from == Ordering::Equal)\n-                && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal))\n-        }\n-        (Str(ctor_val), Str(pat_val)) => {\n-            // FIXME: there's probably a more direct way of comparing for equality\n-            let comparison = compare_const_vals(cx.tcx, ctor_val, pat_val, cx.param_env, ty)?;\n-            comparison == Ordering::Equal\n-        }\n-\n-        (Slice(ctor_slice), Slice(pat_slice)) => {\n-            pat_slice.pattern_kind().covers_length(ctor_slice.arity())\n-        }\n-\n-        // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n-        // value against its own constructor. That happens when we call\n-        // `v.specialize_constructor(ctor)` with `ctor` obtained from `pat_constructor(v.head())`.\n-        // For example, in the following match, when we are dealing with the third branch, we will\n-        // specialize with an `Opaque` ctor. We want to ignore the second branch because opaque\n-        // constants should not be inspected, but we don't want to ignore the current (third)\n-        // branch, as that would cause us to always conclude that such a branch is unreachable.\n-        // ```rust\n-        // #[derive(PartialEq)]\n-        // struct Foo(i32);\n-        // impl Eq for Foo {}\n-        // const FOO: Foo = Foo(42);\n-        //\n-        // match (Foo(0), true) {\n-        //     (_, true) => {}\n-        //     (FOO, true) => {}\n-        //     (FOO, false) => {}\n-        // }\n-        // ```\n-        (Opaque, Opaque) if is_its_own_ctor => true,\n-        // We are trying to inspect an opaque constant. Thus we skip the row.\n-        (Opaque, _) | (_, Opaque) => false,\n-        // Only a wildcard pattern can match the special extra constructor.\n-        (NonExhaustive, _) => false,\n-\n-        _ => bug!(\"trying to specialize pattern {:?} with constructor {:?}\", pat, ctor),\n-    };\n-\n-    if !ctor_covered_by_pat {\n-        return None;\n     }\n \n-    let fields = match pat.kind.as_ref() {\n-        PatKind::Deref { subpattern } => Fields::from_single_pattern(subpattern),\n-        PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n-            ctor_wild_subpatterns.replace_with_fieldpats(subpatterns)\n-        }\n-        PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. } => {\n-            // Number of subpatterns for the constructor\n-            let ctor_arity = ctor_wild_subpatterns.len();\n-\n-            // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n-            // the middle if there was a subslice pattern `..`.\n-            let prefix = prefix.iter().enumerate();\n-            let suffix = suffix.iter().enumerate().map(|(i, p)| (ctor_arity - suffix.len() + i, p));\n-            ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix))\n-        }\n-        _ => ctor_wild_subpatterns.clone(),\n-    };\n+    let fields = ctor_wild_subpatterns.replace_with_pattern_arguments(pat);\n \n     debug!(\"specialize({:#?}, {:#?}, {:#?}) = {:#?}\", pat, ctor, ctor_wild_subpatterns, fields);\n "}]}