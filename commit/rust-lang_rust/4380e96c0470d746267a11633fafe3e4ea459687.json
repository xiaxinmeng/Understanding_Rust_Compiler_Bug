{"sha": "4380e96c0470d746267a11633fafe3e4ea459687", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzODBlOTZjMDQ3MGQ3NDYyNjdhMTE2MzNmYWZlM2U0ZWE0NTk2ODc=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-21T01:40:10Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-24T17:43:47Z"}, "message": "Overhaul typechecking of patterns\n\nInstead of checking patterns in a top-down fashion with a known\nexpected type on entry, this changes makes typeck establish\nappropriate constraints between a pattern and the expression\nit destructures, and lets inference compute the final types\nor produce good error messages if it's impossible.", "tree": {"sha": "3a1eab5f1213e9baf959ea545e4380b4a92cd12c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1eab5f1213e9baf959ea545e4380b4a92cd12c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4380e96c0470d746267a11633fafe3e4ea459687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4380e96c0470d746267a11633fafe3e4ea459687", "html_url": "https://github.com/rust-lang/rust/commit/4380e96c0470d746267a11633fafe3e4ea459687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4380e96c0470d746267a11633fafe3e4ea459687/comments", "author": null, "committer": null, "parents": [{"sha": "3e9ce5afb776bf5a187cafa8cfe5ad677bfd3acc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e9ce5afb776bf5a187cafa8cfe5ad677bfd3acc", "html_url": "https://github.com/rust-lang/rust/commit/3e9ce5afb776bf5a187cafa8cfe5ad677bfd3acc"}], "stats": {"total": 1132, "additions": 415, "deletions": 717}, "files": [{"sha": "601a9a73c3d3aa67035021e54e92d579b8931dcd", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -44,11 +44,9 @@ register_diagnostics!(\n     E0025,\n     E0026,\n     E0027,\n-    E0028,\n     E0029,\n     E0030,\n     E0031,\n-    E0032,\n     E0033,\n     E0034,\n     E0035,"}, {"sha": "fd71e4f7b1fbacfa430e10cf241e8ca46c64c495", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -673,9 +673,14 @@ pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n         let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n-        let arg_tys = match ty::get(ctor_ty).sty {\n-            ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n-            _ => Vec::new(), // Nullary enum variant.\n+        let (ctor_ty, arg_tys) = match ty::get(ctor_ty).sty {\n+            ty::ty_bare_fn(ref f) =>\n+                (Some(ctor_ty), f.sig.inputs.clone()),\n+            _ => // Nullary or struct enum variant.\n+                (None, get_struct_fields(intr.clone(), cdata, did.node)\n+                    .iter()\n+                    .map(|field_ty| get_type(cdata, field_ty.id.node, tcx).ty)\n+                    .collect())\n         };\n         match variant_disr_val(item) {\n             Some(val) => { disr_val = val; }"}, {"sha": "2256bd71e652ce2a07726cfc89d559c9ef95e574", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -667,21 +667,12 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n         let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n         let struct_desc = match ty::get(struct_type).sty {\n-            ty::ty_struct(_, _) => format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n-            ty::ty_bare_fn(ty::BareFnTy { sig: ty::FnSig { output, .. }, .. }) => {\n-                // Struct `id` is really a struct variant of an enum,\n-                // and we're really looking at the variant's constructor\n-                // function. So get the return type for a detailed error\n-                // message.\n-                let enum_id = match ty::get(output).sty {\n-                    ty::ty_enum(id, _) => id,\n-                    _ => self.tcx.sess.span_bug(span, \"enum variant doesn't \\\n-                                                       belong to an enum\")\n-                };\n+            ty::ty_struct(_, _) =>\n+                format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n+            ty::ty_enum(enum_id, _) =>\n                 format!(\"variant `{}` of enum `{}`\",\n                         ty::with_path(self.tcx, id, |mut p| p.last().unwrap()),\n-                        ty::item_path_str(self.tcx, enum_id))\n-            }\n+                        ty::item_path_str(self.tcx, enum_id)),\n             _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n         };\n         let msg = match name {"}, {"sha": "8c602548f33f6ceaccde3763e148368d75a20803", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -50,7 +50,7 @@ use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n use syntax::ast::{Visibility};\n-use syntax::ast_util::{mod, PostExpansionMethod, is_local, lit_is_str};\n+use syntax::ast_util::{mod, is_local, lit_is_str, local_def, PostExpansionMethod};\n use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::{mod, InternedString};\n@@ -4221,7 +4221,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n pub struct VariantInfo {\n     pub args: Vec<t>,\n     pub arg_names: Option<Vec<ast::Ident> >,\n-    pub ctor_ty: t,\n+    pub ctor_ty: Option<t>,\n     pub name: ast::Name,\n     pub id: ast::DefId,\n     pub disr_val: Disr,\n@@ -4249,7 +4249,7 @@ impl VariantInfo {\n                 return VariantInfo {\n                     args: arg_tys,\n                     arg_names: None,\n-                    ctor_ty: ctor_ty,\n+                    ctor_ty: Some(ctor_ty),\n                     name: ast_variant.node.name.name,\n                     id: ast_util::local_def(ast_variant.node.id),\n                     disr_val: discriminant,\n@@ -4262,7 +4262,8 @@ impl VariantInfo {\n \n                 assert!(fields.len() > 0);\n \n-                let arg_tys = ty_fn_args(ctor_ty).iter().map(|a| *a).collect();\n+                let arg_tys = struct_def.fields.iter()\n+                    .map(|field| node_id_to_type(cx, field.node.id)).collect();\n                 let arg_names = fields.iter().map(|field| {\n                     match field.node.kind {\n                         NamedField(ident, _) => ident,\n@@ -4274,7 +4275,7 @@ impl VariantInfo {\n                 return VariantInfo {\n                     args: arg_tys,\n                     arg_names: Some(arg_names),\n-                    ctor_ty: ctor_ty,\n+                    ctor_ty: None,\n                     name: ast_variant.node.name.name,\n                     id: ast_util::local_def(ast_variant.node.id),\n                     disr_val: discriminant,"}, {"sha": "14725c581c8a8165328a4d15d92b30014427be35", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 361, "deletions": 689, "changes": 1050, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -8,29 +8,229 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n use middle::def;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n-use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty;\n-use middle::typeck::check::demand;\n-use middle::typeck::check::{check_expr, check_expr_has_type, FnCtxt};\n-use middle::typeck::check::{instantiate_path, lookup_def};\n-use middle::typeck::check::{structure_of, valid_range_bounds};\n-use middle::typeck::infer;\n+use middle::typeck::check::{check_expr, check_expr_has_type, demand, FnCtxt};\n+use middle::typeck::check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n+use middle::typeck::infer::{mod, resolve};\n use middle::typeck::require_same_types;\n-use util::ppaux;\n \n-use std::collections::{HashMap, HashSet};\n+use std::cmp;\n+use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::parse::token;\n use syntax::codemap::{Span, Spanned};\n+use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n+pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+\n+    match pat.node {\n+        ast::PatWild(_) => {\n+            fcx.write_ty(pat.id, expected);\n+        }\n+        ast::PatLit(ref lt) => {\n+            check_expr(fcx, &**lt);\n+            let expr_ty = fcx.expr_ty(&**lt);\n+            fcx.write_ty(pat.id, expr_ty);\n+            demand::suptype(fcx, pat.span, expected, expr_ty);\n+        }\n+        ast::PatRange(ref begin, ref end) => {\n+            check_expr(fcx, &**begin);\n+            check_expr(fcx, &**end);\n+\n+            let lhs_ty = fcx.expr_ty(&**begin);\n+            let rhs_ty = fcx.expr_ty(&**end);\n+            if require_same_types(\n+                tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n+                || \"mismatched types in range\".to_string())\n+                && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(rhs_ty)) {\n+                match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n+                    Some(false) => {\n+                        span_err!(tcx.sess, begin.span, E0030,\n+                            \"lower range bound must be less than upper\");\n+                    },\n+                    None => {\n+                        span_err!(tcx.sess, begin.span, E0031,\n+                            \"mismatched types in range\");\n+                    },\n+                    Some(true) => {}\n+                }\n+            } else {\n+                span_err!(tcx.sess, begin.span, E0029,\n+                    \"only char and numeric types are allowed in range\");\n+            }\n+\n+            fcx.write_ty(pat.id, lhs_ty);\n+            demand::eqtype(fcx, pat.span, expected, lhs_ty);\n+        }\n+        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n+            let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n+            let const_pty = ty::lookup_item_type(tcx, const_did);\n+            fcx.write_ty(pat.id, const_pty.ty);\n+            demand::eqtype(fcx, pat.span, expected, const_pty.ty);\n+        }\n+        ast::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n+            let typ = fcx.local_ty(pat.span, pat.id);\n+            match bm {\n+                ast::BindByRef(mutbl) => {\n+                    // if the binding is like\n+                    //    ref x | ref const x | ref mut x\n+                    // then the type of x is &M T where M is the mutability\n+                    // and T is the expected type\n+                    let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                    let mt = ty::mt { ty: expected, mutbl: mutbl };\n+                    let region_ty = ty::mk_rptr(tcx, region_var, mt);\n+                    demand::eqtype(fcx, pat.span, region_ty, typ);\n+                }\n+                // otherwise the type of x is the expected type T\n+                ast::BindByValue(_) => {\n+                    demand::eqtype(fcx, pat.span, expected, typ);\n+                }\n+            }\n+            fcx.write_ty(pat.id, typ);\n+\n+            let canon_id = pcx.map[path.node];\n+            if canon_id != pat.id {\n+                let ct = fcx.local_ty(pat.span, canon_id);\n+                demand::eqtype(fcx, pat.span, ct, typ);\n+            }\n+\n+            if let Some(ref p) = *sub {\n+                check_pat(pcx, &**p, expected);\n+            }\n+        }\n+        ast::PatIdent(_, ref path, _) => {\n+            let path = ast_util::ident_to_path(path.span, path.node);\n+            check_pat_enum(pcx, pat, &path, &Some(vec![]), expected);\n+        }\n+        ast::PatEnum(ref path, ref subpats) => {\n+            check_pat_enum(pcx, pat, path, subpats, expected);\n+        }\n+        ast::PatStruct(ref path, ref fields, etc) => {\n+            check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n+        }\n+        ast::PatTup(ref elements) => {\n+            let element_tys = Vec::from_fn(elements.len(), |_| fcx.infcx().next_ty_var());\n+            let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n+            fcx.write_ty(pat.id, pat_ty);\n+            demand::eqtype(fcx, pat.span, expected, pat_ty);\n+            for (element_pat, element_ty) in elements.iter().zip(element_tys.into_iter()) {\n+                check_pat(pcx, &**element_pat, element_ty);\n+            }\n+        }\n+        ast::PatBox(ref inner) => {\n+            let inner_ty = fcx.infcx().next_ty_var();\n+            let uniq_ty = ty::mk_uniq(tcx, inner_ty);\n+\n+            if check_dereferencable(pcx, pat.span, expected, &**inner) {\n+                demand::suptype(fcx, pat.span, expected, uniq_ty);\n+                fcx.write_ty(pat.id, uniq_ty);\n+                check_pat(pcx, &**inner, inner_ty);\n+            } else {\n+                fcx.write_error(pat.id);\n+                check_pat(pcx, &**inner, ty::mk_err());\n+            }\n+        }\n+        ast::PatRegion(ref inner) => {\n+            let inner_ty = fcx.infcx().next_ty_var();\n+\n+            let mutbl = infer::resolve_type(\n+                fcx.infcx(), Some(pat.span),\n+                expected, resolve::try_resolve_tvar_shallow)\n+                .ok()\n+                .and_then(|t| ty::deref(t, true))\n+                .map_or(ast::MutImmutable, |mt| mt.mutbl);\n+\n+            let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n+            let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+            let rptr_ty = ty::mk_rptr(tcx, region, mt);\n+\n+            if check_dereferencable(pcx, pat.span, expected, &**inner) {\n+                demand::suptype(fcx, pat.span, expected, rptr_ty);\n+                fcx.write_ty(pat.id, rptr_ty);\n+                check_pat(pcx, &**inner, inner_ty);\n+            } else {\n+                fcx.write_error(pat.id);\n+                check_pat(pcx, &**inner, ty::mk_err());\n+            }\n+        }\n+        ast::PatVec(ref before, ref slice, ref after) => {\n+            let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n+            let inner_ty = fcx.infcx().next_ty_var();\n+            let pat_ty = match ty::get(expected_ty).sty {\n+                ty::ty_vec(_, Some(size)) => ty::mk_vec(tcx, inner_ty, Some({\n+                    let min_len = before.len() + after.len();\n+                    match *slice {\n+                        Some(_) => cmp::max(min_len, size),\n+                        None => min_len\n+                    }\n+                })),\n+                _ => {\n+                    let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                    ty::mk_slice(tcx, region, ty::mt {\n+                        ty: inner_ty,\n+                        mutbl: ty::deref(expected_ty, true)\n+                            .map_or(ast::MutImmutable, |mt| mt.mutbl)\n+                    })\n+                }\n+            };\n+\n+            fcx.write_ty(pat.id, pat_ty);\n+            demand::suptype(fcx, pat.span, expected, pat_ty);\n+\n+            for elt in before.iter() {\n+                check_pat(pcx, &**elt, inner_ty);\n+            }\n+            if let Some(ref slice) = *slice {\n+                let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                let mutbl = ty::deref(expected_ty, true)\n+                    .map_or(ast::MutImmutable, |mt| mt.mutbl);\n+\n+                let slice_ty = ty::mk_slice(tcx, region, ty::mt {\n+                    ty: inner_ty,\n+                    mutbl: mutbl\n+                });\n+                check_pat(pcx, &**slice, slice_ty);\n+            }\n+            for elt in after.iter() {\n+                check_pat(pcx, &**elt, inner_ty);\n+            }\n+        }\n+        ast::PatMac(_) => tcx.sess.bug(\"unexpanded macro\")\n+    }\n+}\n+\n+pub fn check_dereferencable(pcx: &pat_ctxt, span: Span, expected: ty::t,\n+                            inner: &ast::Pat) -> bool {\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+    match infer::resolve_type(\n+        fcx.infcx(), Some(span),\n+        expected, resolve::try_resolve_tvar_shallow) {\n+        Ok(t) if pat_is_binding(&tcx.def_map, inner) => {\n+            ty::deref(t, true).map_or(true, |mt| match ty::get(mt.ty).sty {\n+                ty::ty_trait(_) => {\n+                    // This is \"x = SomeTrait\" being reduced from\n+                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                    span_err!(tcx.sess, span, E0033,\n+                        \"type `{}` cannot be dereferenced\",\n+                        fcx.infcx().ty_to_string(t));\n+                    false\n+                }\n+                _ => true\n+            })\n+        }\n+        _ => true\n+    }\n+}\n+\n pub fn check_match(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    discrim: &ast::Expr,\n@@ -47,62 +247,40 @@ pub fn check_match(fcx: &FnCtxt,\n             fcx: fcx,\n             map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n         };\n-\n-        for p in arm.pats.iter() { check_pat(&mut pcx, &**p, discrim_ty);}\n+        for p in arm.pats.iter() {\n+            check_pat(&mut pcx, &**p, discrim_ty);\n+        }\n     }\n \n+    // Now typecheck the blocks.\n+    //\n     // The result of the match is the common supertype of all the\n     // arms. Start out the value as bottom, since it's the, well,\n     // bottom the type lattice, and we'll be moving up the lattice as\n     // we process each arm. (Note that any match with 0 arms is matching\n     // on any empty type and is therefore unreachable; should the flow\n     // of execution reach it, we will fail, so bottom is an appropriate\n     // type in that case)\n-    let mut result_ty = ty::mk_bot();\n-\n-    // Now typecheck the blocks.\n-    let mut saw_err = ty::type_is_error(discrim_ty);\n-    for arm in arms.iter() {\n-        let mut guard_err = false;\n-        let mut guard_bot = false;\n-        match arm.guard {\n-            Some(ref e) => {\n-                check_expr_has_type(fcx, &**e, ty::mk_bool());\n-                let e_ty = fcx.expr_ty(&**e);\n-                if ty::type_is_error(e_ty) {\n-                    guard_err = true;\n-                }\n-                else if ty::type_is_bot(e_ty) {\n-                    guard_bot = true;\n-                }\n-            },\n-            None => ()\n-        }\n+    let result_ty = arms.iter().fold(ty::mk_bot(), |result_ty, arm| {\n         check_expr(fcx, &*arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n-        saw_err = saw_err || ty::type_is_error(bty);\n-        if guard_err {\n-            fcx.write_error(arm.body.id);\n-            saw_err = true;\n-        }\n-        else if guard_bot {\n-            fcx.write_bot(arm.body.id);\n+\n+        if let Some(ref e) = arm.guard {\n+            check_expr_has_type(fcx, &**e, ty::mk_bool());\n         }\n \n-        result_ty =\n+        if ty::type_is_error(result_ty) || ty::type_is_error(bty) {\n+            ty::mk_err()\n+        } else {\n             infer::common_supertype(\n                 fcx.infcx(),\n                 infer::MatchExpressionArm(expr.span, arm.body.span),\n                 true, // result_ty is \"expected\" here\n                 result_ty,\n-                bty);\n-    }\n-\n-    if saw_err {\n-        result_ty = ty::mk_err();\n-    } else if ty::type_is_bot(discrim_ty) {\n-        result_ty = ty::mk_bot();\n-    }\n+                bty\n+            )\n+        }\n+    });\n \n     fcx.write_ty(expr.id, result_ty);\n }\n@@ -112,173 +290,120 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n     pub map: PatIdMap,\n }\n \n-pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<Vec<P<ast::Pat>>>, expected: ty::t) {\n-\n-    // Typecheck the path.\n+pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n+                        path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n+                        etc: bool, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let arg_types: Vec<ty::t> ;\n-    let kind_name;\n-\n-    // structure_of requires type variables to be resolved.\n-    // So when we pass in <expected>, it's an error if it\n-    // contains type variables.\n-\n-    // Check to see whether this is an enum or a struct.\n-    match *structure_of(pcx.fcx, pat.span, expected) {\n-        ty::ty_enum(expected_def_id, ref expected_substs) => {\n-            // Lookup the enum and variant def ids:\n-            let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            match v_def.variant_def_ids() {\n-                Some((enm, var)) => {\n-                    // Assign the pattern the type of the *enum*, not the variant.\n-                    let enum_pty = ty::lookup_item_type(tcx, enm);\n-                    instantiate_path(pcx.fcx,\n-                                     path,\n-                                     enum_pty,\n-                                     v_def,\n-                                     pat.span,\n-                                     pat.id);\n-\n-                    // check that the type of the value being matched is a subtype\n-                    // of the type of the pattern:\n-                    let pat_ty = fcx.node_ty(pat.id);\n-                    demand::subtype(fcx, pat.span, expected, pat_ty);\n-\n-                    // Get the expected types of the arguments.\n-                    arg_types = {\n-                        let vinfo =\n-                            ty::enum_variant_with_id(tcx, enm, var);\n-                        if enm == expected_def_id {\n-                            vinfo.args.iter()\n-                                .map(|t| t.subst(tcx, expected_substs))\n-                                .collect()\n-                        } else {\n-                            vinfo.args.iter()\n-                                .map(|_| ty::mk_err())\n-                                .collect()\n-                        }\n-                    };\n-\n-                    kind_name = \"variant\";\n-                }\n-                None => {\n-                    // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-                    fcx.infcx().type_error_message_str_with_expected(pat.span,\n-                                                       |expected, actual| {\n-                       expected.map_or(\"\".to_string(), |e| {\n-                        format!(\"mismatched types: expected `{}`, found {}\",\n-                                e, actual)\n-                        })},\n-                        Some(expected),\n-                        \"a structure pattern\".to_string(),\n-                        None);\n-                    fcx.write_error(pat.id);\n-                    kind_name = \"[error]\";\n-                    arg_types = subpats.clone()\n-                                       .unwrap_or_default()\n-                                       .into_iter()\n-                                       .map(|_| ty::mk_err())\n-                                       .collect();\n-                }\n-            }\n-        }\n-        ty::ty_struct(struct_def_id, ref expected_substs) => {\n-            // Lookup the struct ctor def id\n-            let s_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            let s_def_id = s_def.def_id();\n-\n-            // Assign the pattern the type of the struct.\n-            let ctor_pty = ty::lookup_item_type(tcx, s_def_id);\n-            let struct_pty = if ty::is_fn_ty(ctor_pty.ty) {\n-                ty::Polytype {ty: ty::ty_fn_ret(ctor_pty.ty),\n-                              ..ctor_pty}\n-            } else {\n-                ctor_pty\n-            };\n-            instantiate_path(pcx.fcx,\n-                             path,\n-                             struct_pty,\n-                             s_def,\n-                             pat.span,\n-                             pat.id);\n-\n-            // Check that the type of the value being matched is a subtype of\n-            // the type of the pattern.\n-            let pat_ty = fcx.node_ty(pat.id);\n-            demand::subtype(fcx, pat.span, expected, pat_ty);\n-\n-            // Get the expected types of the arguments.\n-            let class_fields = ty::struct_fields(\n-                tcx, struct_def_id, expected_substs);\n-            arg_types = class_fields.iter().map(|field| field.mt.ty).collect();\n-\n-            kind_name = \"structure\";\n-        }\n+    let def = tcx.def_map.borrow().get_copy(&pat.id);\n+    let def_type = ty::lookup_item_type(tcx, def.def_id());\n+    let (enum_def_id, variant_def_id) = match ty::get(def_type.ty).sty {\n+        ty::ty_struct(struct_def_id, _) =>\n+            (struct_def_id, struct_def_id),\n+        ty::ty_enum(enum_def_id, _) if def == def::DefVariant(enum_def_id, def.def_id(), true) =>\n+            (enum_def_id, def.def_id()),\n         _ => {\n-            // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-            fcx.infcx().type_error_message_str_with_expected(pat.span,\n-                                               |expected, actual| {\n-                                               expected.map_or(\"\".to_string(),\n-                                                              |e| {\n-                        format!(\"mismatched types: expected `{}`, found {}\",\n-                                e, actual)\n-                    })\n-                },\n-                Some(expected),\n-                \"an enum or structure pattern\".to_string(),\n-                None);\n+            let name = pprust::path_to_string(path);\n+            span_err!(tcx.sess, pat.span, E0163,\n+                \"`{}` does not name a struct or a struct variant\", name);\n             fcx.write_error(pat.id);\n-            kind_name = \"[error]\";\n-            arg_types = subpats.clone()\n-                               .unwrap_or_default()\n-                               .iter()\n-                               .map(|_| ty::mk_err())\n-                               .collect();\n+\n+            for field in fields.iter() {\n+                check_pat(pcx, &*field.node.pat, ty::mk_err());\n+            }\n+            return;\n         }\n-    }\n+    };\n \n-    let arg_len = arg_types.len();\n+    instantiate_path(pcx.fcx, path, ty::lookup_item_type(tcx, enum_def_id),\n+                     def, pat.span, pat.id);\n \n-    // Count the number of subpatterns.\n-    let subpats_len;\n-    match *subpats {\n-        None => subpats_len = arg_len,\n-        Some(ref subpats) => subpats_len = subpats.len()\n-    }\n+    let pat_ty = fcx.node_ty(pat.id);\n+    demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n-    let mut error_happened = false;\n+    let item_substs = fcx\n+        .item_substs()\n+        .find(&pat.id)\n+        .map(|substs| substs.substs.clone())\n+        .unwrap_or_else(|| Substs::empty());\n \n-    if arg_len > 0 {\n-        // N-ary variant.\n-        if arg_len != subpats_len {\n-            span_err!(tcx.sess, pat.span, E0023,\n-                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                      subpats_len, if subpats_len == 1 {\"\"} else {\"s\"},\n-                      kind_name, arg_len, if arg_len == 1 {\"\"} else {\"s\"});\n-            error_happened = true;\n+    let struct_fields = ty::struct_fields(tcx, variant_def_id, &item_substs);\n+    check_struct_pat_fields(pcx, pat.span, fields, struct_fields.as_slice(),\n+                            variant_def_id, etc);\n+}\n+\n+pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n+                      path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n+                      expected: ty::t) {\n+\n+    // Typecheck the path.\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+\n+    let def = tcx.def_map.borrow().get_copy(&pat.id);\n+    let enum_def = def.variant_def_ids()\n+        .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n+\n+    let ctor_pty = ty::lookup_item_type(tcx, enum_def);\n+    let path_ty = if ty::is_fn_ty(ctor_pty.ty) {\n+        ty::Polytype { ty: ty::ty_fn_ret(ctor_pty.ty), ..ctor_pty }\n+    } else {\n+        ctor_pty\n+    };\n+    instantiate_path(pcx.fcx, path, path_ty, def, pat.span, pat.id);\n+\n+    let pat_ty = fcx.node_ty(pat.id);\n+    demand::eqtype(fcx, pat.span, expected, pat_ty);\n+\n+    let real_path_ty = fcx.node_ty(pat.id);\n+    let (arg_tys, kind_name) = match ty::get(real_path_ty).sty {\n+        ty::ty_enum(enum_def_id, ref expected_substs) => {\n+            let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n+            (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),\n+                \"variant\")\n+        }\n+        ty::ty_struct(struct_def_id, ref expected_substs) => {\n+            let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n+            (struct_fields.iter().map(|field| field.mt.ty).collect::<Vec<_>>(),\n+                \"struct\")\n         }\n+        _ => {\n+            let name = pprust::path_to_string(path);\n+            span_err!(tcx.sess, pat.span, E0164,\n+                \"`{}` does not name a variant or a tuple struct\", name);\n+            fcx.write_error(pat.id);\n \n-        if !error_happened {\n-            for pats in subpats.iter() {\n-                for (subpat, arg_ty) in pats.iter().zip(arg_types.iter()) {\n-                    check_pat(pcx, &**subpat, *arg_ty);\n+            if let Some(ref subpats) = *subpats {\n+                for pat in subpats.iter() {\n+                    check_pat(pcx, &**pat, ty::mk_err());\n                 }\n             }\n+            return;\n         }\n-    } else if subpats_len > 0 {\n-        span_err!(tcx.sess, pat.span, E0024,\n-                  \"this pattern has {} field{}, but the corresponding {} has no fields\",\n-                  subpats_len, if subpats_len == 1 {\"\"} else {\"s\"},\n-                  kind_name);\n-        error_happened = true;\n-    }\n+    };\n+\n+    if let Some(ref subpats) = *subpats {\n+        if subpats.len() == arg_tys.len() {\n+            for (subpat, arg_ty) in subpats.iter().zip(arg_tys.iter()) {\n+                check_pat(pcx, &**subpat, *arg_ty);\n+            }\n+        } else if arg_tys.len() == 0 {\n+            span_err!(tcx.sess, pat.span, E0024,\n+                      \"this pattern has {} field{}, but the corresponding {} has no fields\",\n+                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n-    if error_happened {\n-        for pats in subpats.iter() {\n-            for pat in pats.iter() {\n+            for pat in subpats.iter() {\n+                check_pat(pcx, &**pat, ty::mk_err());\n+            }\n+        } else {\n+            span_err!(tcx.sess, pat.span, E0023,\n+                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n+                      kind_name,\n+                      arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n+\n+            for pat in subpats.iter() {\n                 check_pat(pcx, &**pat, ty::mk_err());\n             }\n         }\n@@ -287,515 +412,62 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n \n /// `path` is the AST path item naming the type of this struct.\n /// `fields` is the field patterns of the struct pattern.\n-/// `class_fields` describes the type of each field of the struct.\n-/// `class_id` is the ID of the struct.\n-/// `substitutions` are the type substitutions applied to this struct type\n-/// (e.g. K,V in HashMap<K,V>).\n+/// `struct_fields` describes the type of each field of the struct.\n+/// `struct_id` is the ID of the struct.\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: Span,\n                                fields: &[Spanned<ast::FieldPat>],\n-                               class_fields: Vec<ty::field_ty>,\n-                               class_id: ast::DefId,\n-                               substitutions: &subst::Substs,\n+                               struct_fields: &[ty::field],\n+                               struct_id: ast::DefId,\n                                etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    // Index the class fields. The second argument in the tuple is whether the\n-    // field has been bound yet or not.\n-    let mut field_map = HashMap::new();\n-    for (i, class_field) in class_fields.iter().enumerate() {\n-        field_map.insert(class_field.name, (i, false));\n-    }\n+    // Index the struct fields' types.\n+    let field_type_map = struct_fields\n+        .iter()\n+        .map(|field| (field.name, field.mt.ty))\n+        .collect::<HashMap<_, _>>();\n+\n+    // Keep track of which fields have already appeared in the pattern.\n+    let mut used_fields = HashMap::new();\n \n     // Typecheck each field.\n-    let mut found_fields = HashSet::new();\n     for &Spanned { node: ref field, span } in fields.iter() {\n-        match field_map.find_mut(&field.ident.name) {\n-            Some(&(_, true)) => {\n-                // Check the pattern anyway, so that attempts to look\n-                // up its type won't fail\n-                check_pat(pcx, &*field.pat, ty::mk_err());\n+        let field_type = match used_fields.entry(field.ident.name) {\n+            Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n-                    \"field `{}` bound twice in pattern\",\n+                    \"field `{}` bound multiple times in the pattern\",\n                     token::get_ident(field.ident));\n-            }\n-            Some(&(index, ref mut used)) => {\n-                *used = true;\n-                let class_field = class_fields[index].clone();\n-                let field_type = ty::lookup_field_type(tcx,\n-                                                       class_id,\n-                                                       class_field.id,\n-                                                       substitutions);\n-                check_pat(pcx, &*field.pat, field_type);\n-                found_fields.insert(index);\n-            }\n-            None => {\n-                // Check the pattern anyway, so that attempts to look\n-                // up its type won't fail\n-                check_pat(pcx, &*field.pat, ty::mk_err());\n-                span_err!(tcx.sess, span, E0026,\n-                    \"struct `{}` does not have a field named `{}`\",\n-                    ty::item_path_str(tcx, class_id),\n+                span_note!(tcx.sess, *occupied.get(),\n+                    \"field `{}` previously bound here\",\n                     token::get_ident(field.ident));\n+                ty::mk_err()\n             }\n-        }\n+            Vacant(vacant) => {\n+                vacant.set(span);\n+                field_type_map.find_copy(&field.ident.name)\n+                    .unwrap_or_else(|| {\n+                        span_err!(tcx.sess, span, E0026,\n+                            \"struct `{}` does not have a field named `{}`\",\n+                            ty::item_path_str(tcx, struct_id),\n+                            token::get_ident(field.ident));\n+                        ty::mk_err()\n+                    })\n+            }\n+        };\n+\n+        check_pat(pcx, &*field.pat, field_type);\n     }\n \n     // Report an error if not all the fields were specified.\n     if !etc {\n-        for (i, field) in class_fields.iter().enumerate() {\n-            if found_fields.contains(&i) {\n-                continue;\n-            }\n+        for field in struct_fields\n+            .iter()\n+            .filter(|field| !used_fields.contains_key(&field.name)) {\n             span_err!(tcx.sess, span, E0027,\n                 \"pattern does not mention field `{}`\",\n                 token::get_name(field.name));\n         }\n     }\n }\n-\n-pub fn check_struct_pat(pcx: &pat_ctxt, span: Span,\n-                        fields: &[Spanned<ast::FieldPat>], etc: bool,\n-                        struct_id: ast::DefId,\n-                        substitutions: &subst::Substs) {\n-    let _fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n-\n-    let class_fields = ty::lookup_struct_fields(tcx, struct_id);\n-\n-    check_struct_pat_fields(pcx, span, fields, class_fields, struct_id,\n-                            substitutions, etc);\n-}\n-\n-pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n-                                          pat_id: ast::NodeId,\n-                                          span: Span,\n-                                          expected: ty::t,\n-                                          path: &ast::Path,\n-                                          fields: &[Spanned<ast::FieldPat>],\n-                                          etc: bool,\n-                                          enum_id: ast::DefId,\n-                                          substitutions: &subst::Substs) {\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n-\n-    // Find the variant that was specified.\n-    match tcx.def_map.borrow().find(&pat_id) {\n-        Some(&def::DefVariant(found_enum_id, variant_id, true))\n-                if found_enum_id == enum_id => {\n-            // Get the struct fields from this struct-like enum variant.\n-            let struct_fields = ty::lookup_struct_fields(tcx, variant_id);\n-            check_struct_pat_fields(pcx, span, fields, struct_fields,\n-                                    variant_id, substitutions, etc);\n-            fcx.write_ty(pat_id, expected);\n-        }\n-        Some(&def::DefVariant(_, _, false)) => {\n-            let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, span, E0163,\n-                \"`{}` does not name a struct variant\", name);\n-            fcx.write_error(pat_id);\n-        }\n-        Some(&def::DefVariant(_, _, true)) => {\n-            let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, span, E0164,\n-                \"`{}` does not name a variant of the type being matched against\", name);\n-            fcx.write_error(pat_id);\n-        }\n-        Some(&def::DefStruct(..)) |\n-        Some(&def::DefTy(..)) => {\n-            let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, span, E0028,\n-                \"`{}` does not name a variant\", name);\n-            fcx.write_error(pat_id);\n-        }\n-        _ => {\n-            tcx.sess.span_bug(span, \"resolve didn't write in variant\");\n-        }\n-    }\n-\n-    if ty::type_is_error(fcx.node_ty(pat_id)) {\n-        for field in fields.iter() {\n-            check_pat(pcx, &*field.node.pat, ty::mk_err());\n-        }\n-    }\n-}\n-\n-// Pattern checking is top-down rather than bottom-up so that bindings get\n-// their types immediately.\n-pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n-\n-    match pat.node {\n-      ast::PatWild(_) => {\n-        fcx.write_ty(pat.id, expected);\n-      }\n-      ast::PatLit(ref lt) => {\n-        check_expr_has_type(fcx, &**lt, expected);\n-        fcx.write_ty(pat.id, fcx.expr_ty(&**lt));\n-      }\n-      ast::PatRange(ref begin, ref end) => {\n-        check_expr_has_type(fcx, &**begin, expected);\n-        check_expr_has_type(fcx, &**end, expected);\n-        let b_ty =\n-            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**begin));\n-        let e_ty =\n-            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**end));\n-        debug!(\"pat_range beginning type: {}\", b_ty);\n-        debug!(\"pat_range ending type: {}\", e_ty);\n-        if !require_same_types(\n-            tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n-            || \"mismatched types in range\".to_string())\n-        {\n-            // no-op\n-        } else if !ty::type_is_numeric(b_ty) && !ty::type_is_char(b_ty) {\n-            span_err!(tcx.sess, begin.span, E0029,\n-                \"only char and numeric types are allowed in range\");\n-        } else {\n-            match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n-                Some(false) => {\n-                    span_err!(tcx.sess, begin.span, E0030,\n-                        \"lower range bound must be less than upper\");\n-                },\n-                None => {\n-                    span_err!(tcx.sess, begin.span, E0031,\n-                        \"mismatched types in range\");\n-                },\n-                _ => { },\n-            }\n-        }\n-        fcx.write_ty(pat.id, b_ty);\n-      }\n-      ast::PatEnum(..) |\n-      ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-        let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n-        let const_pty = ty::lookup_item_type(tcx, const_did);\n-        demand::suptype(fcx, pat.span, expected, const_pty.ty);\n-        fcx.write_ty(pat.id, const_pty.ty);\n-      }\n-      ast::PatIdent(bm, ref path1, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n-        let typ = fcx.local_ty(pat.span, pat.id);\n-\n-        match bm {\n-          ast::BindByRef(mutbl) => {\n-            // if the binding is like\n-            //    ref x | ref const x | ref mut x\n-            // then the type of x is &M T where M is the mutability\n-            // and T is the expected type\n-            let region_var =\n-                fcx.infcx().next_region_var(\n-                    infer::PatternRegion(pat.span));\n-            let mt = ty::mt {ty: expected, mutbl: mutbl};\n-            let region_ty = ty::mk_rptr(tcx, region_var, mt);\n-            demand::eqtype(fcx, pat.span, region_ty, typ);\n-          }\n-          // otherwise the type of x is the expected type T\n-          ast::BindByValue(_) => {\n-            demand::eqtype(fcx, pat.span, expected, typ);\n-          }\n-        }\n-\n-        let canon_id = pcx.map[path1.node];\n-        if canon_id != pat.id {\n-            let ct = fcx.local_ty(pat.span, canon_id);\n-            demand::eqtype(fcx, pat.span, ct, typ);\n-        }\n-        fcx.write_ty(pat.id, typ);\n-\n-        debug!(\"(checking match) writing type {} (expected {}) for pat id {}\",\n-               ppaux::ty_to_string(tcx, typ),\n-               ppaux::ty_to_string(tcx, expected),\n-               pat.id);\n-\n-        match *sub {\n-            Some(ref p) => check_pat(pcx, &**p, expected),\n-            _ => ()\n-        }\n-      }\n-      // it's not a binding, it's an enum in disguise:\n-      ast::PatIdent(_, ref path1, _) => {\n-        let path = ast_util::ident_to_path(path1.span,path1.node);\n-        check_pat_variant(pcx, pat, &path, &Some(Vec::new()), expected);\n-      }\n-      ast::PatEnum(ref path, ref subpats) => {\n-        check_pat_variant(pcx, pat, path, subpats, expected);\n-      }\n-      ast::PatStruct(ref path, ref fields, etc) => {\n-        // Grab the class data that we care about.\n-        let structure = structure_of(fcx, pat.span, expected);\n-        let mut error_happened = false;\n-        match *structure {\n-            ty::ty_struct(cid, ref substs) => {\n-                // Verify that the pattern named the right structure.\n-                let item_did = (*tcx.def_map.borrow())[pat.id].def_id();\n-                match ty::ty_to_def_id(ty::lookup_item_type(tcx, item_did).ty) {\n-                    Some(struct_did) if struct_did != cid => {\n-                        span_err!(tcx.sess, path.span, E0032,\n-                                  \"`{}` does not name the structure `{}`\",\n-                                  pprust::path_to_string(path),\n-                                  fcx.infcx().ty_to_string(expected));\n-                    },\n-                    Some(_) => {},\n-                    None => {\n-                        tcx.sess.span_bug(\n-                            path.span,\n-                            format!(\"This shouldn't happen: failed to lookup structure. \\\n-                                item_did = {}\", item_did).as_slice())\n-                    },\n-                }\n-\n-                check_struct_pat(pcx, pat.span, fields.as_slice(), etc, cid, substs);\n-            }\n-            ty::ty_enum(eid, ref substs) => {\n-                check_struct_like_enum_variant_pat(pcx,\n-                                                   pat.id,\n-                                                   pat.span,\n-                                                   expected,\n-                                                   path,\n-                                                   fields.as_slice(),\n-                                                   etc,\n-                                                   eid,\n-                                                   substs);\n-            }\n-            _ => {\n-               // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-                fcx.infcx().type_error_message_str_with_expected(pat.span,\n-                                                                |expected, actual| {\n-                            expected.map_or(\"\".to_string(),\n-                                            |e| {\n-                                format!(\"mismatched types: expected \\\n-                                        `{}`, found {}\", e, actual)\n-                            })},\n-                            Some(expected),\n-                            \"a structure pattern\".to_string(),\n-                            None);\n-                match tcx.def_map.borrow().find(&pat.id) {\n-                    Some(def) => {\n-                        let struct_ty = fcx.instantiate_item_type(pat.span, def.def_id());\n-                        check_struct_pat(pcx, pat.span, fields.as_slice(),\n-                                         etc, def.def_id(), &struct_ty.substs);\n-                    }\n-                    None => {\n-                        tcx.sess.span_bug(pat.span,\n-                                          \"whoops, looks like resolve didn't \\\n-                                           write a def in here\")\n-                    }\n-                }\n-                error_happened = true;\n-            }\n-        }\n-\n-        // Finally, write in the type.\n-        if error_happened {\n-            fcx.write_error(pat.id);\n-        } else {\n-            fcx.write_ty(pat.id, expected);\n-        }\n-      }\n-      ast::PatTup(ref elts) => {\n-        let s = structure_of(fcx, pat.span, expected);\n-        let e_count = elts.len();\n-        match *s {\n-            ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n-                for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, &**elt, ex_elts[i]);\n-                }\n-                fcx.write_ty(pat.id, expected);\n-            }\n-            _ => {\n-                for elt in elts.iter() {\n-                    check_pat(pcx, &**elt, ty::mk_err());\n-                }\n-                // use terr_tuple_size if both types are tuples\n-                let type_error = match *s {\n-                    ty::ty_tup(ref ex_elts) => {\n-                        ty::terr_tuple_size(ty::expected_found {\n-                            expected: ex_elts.len(),\n-                            found: e_count\n-                        })\n-                    }\n-                    _ => ty::terr_mismatch\n-                };\n-                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-                fcx.infcx().type_error_message_str_with_expected(pat.span,\n-                                                                 |expected,\n-                                                                  actual| {\n-                        expected.map_or(\"\".to_string(), |e| {\n-                            format!(\"mismatched types: expected `{}`, \\\n-                                     found {}\", e, actual)\n-                        }\n-                    )},\n-                    Some(expected),\n-                    \"tuple\".to_string(),\n-                    Some(&type_error));\n-                fcx.write_error(pat.id);\n-            }\n-        }\n-      }\n-      ast::PatBox(ref inner) => {\n-          check_pointer_pat(pcx, Send, &**inner, pat.id, pat.span, expected);\n-      }\n-      ast::PatRegion(ref inner) => {\n-          check_pointer_pat(pcx, Borrowed, &**inner, pat.id, pat.span, expected);\n-      }\n-      ast::PatVec(ref before, ref slice, ref after) => {\n-        let default_region_var =\n-            fcx.infcx().next_region_var(\n-                infer::PatternRegion(pat.span));\n-\n-        let check_err = |found: String| {\n-            for elt in before.iter() {\n-                check_pat(pcx, &**elt, ty::mk_err());\n-            }\n-            for elt in slice.iter() {\n-                check_pat(pcx, &**elt, ty::mk_err());\n-            }\n-            for elt in after.iter() {\n-                check_pat(pcx, &**elt, ty::mk_err());\n-            }\n-            // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-            fcx.infcx().type_error_message_str_with_expected(\n-                pat.span,\n-                |expected, actual| {\n-                    expected.map_or(\"\".to_string(),\n-                                    |e| {\n-                        format!(\"mismatched types: expected `{}`, found {}\",\n-                                e, actual)\n-                    })\n-                },\n-                Some(expected),\n-                found,\n-                None);\n-            fcx.write_error(pat.id);\n-        };\n-\n-        let (elt_type, region_var, mutbl, fixed) = match *structure_of(fcx,\n-                                                                pat.span,\n-                                                                expected) {\n-          ty::ty_vec(ty, Some(fixed)) =>\n-            (ty, default_region_var, ast::MutImmutable, Some(fixed)),\n-          ty::ty_uniq(t) => match ty::get(t).sty {\n-              ty::ty_vec(ty, None) => {\n-                  fcx.type_error_message(pat.span,\n-                                         |_| {\n-                                            \"unique vector patterns are no \\\n-                                             longer supported\".to_string()\n-                                         },\n-                                         expected,\n-                                         None);\n-                  (ty, default_region_var, ast::MutImmutable, None)\n-              }\n-              _ => {\n-                  check_err(\"an array  pattern\".to_string());\n-                  return;\n-              }\n-          },\n-          ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n-              ty::ty_vec(ty, None) => (ty, r, mt.mutbl, None),\n-              _ => {\n-                  check_err(\"an array pattern\".to_string());\n-                  return;\n-              }\n-          },\n-          _ => {\n-              check_err(\"an array pattern\".to_string());\n-              return;\n-          }\n-        };\n-\n-        let min_len = before.len() + after.len();\n-        fixed.and_then(|count| match *slice {\n-            Some(_) if count < min_len =>\n-                Some(format!(\"a fixed array pattern of size at least {}\", min_len)),\n-\n-            None if count != min_len =>\n-                Some(format!(\"a fixed array pattern of size {}\", min_len)),\n-\n-            _ => None\n-        }).map(check_err);\n-\n-        for elt in before.iter() {\n-            check_pat(pcx, &**elt, elt_type);\n-        }\n-        match *slice {\n-            Some(ref slice_pat) => {\n-                let slice_ty = ty::mk_slice(tcx,\n-                                            region_var,\n-                                            ty::mt {ty: elt_type, mutbl: mutbl});\n-                check_pat(pcx, &**slice_pat, slice_ty);\n-            }\n-            None => ()\n-        }\n-        for elt in after.iter() {\n-            check_pat(pcx, &**elt, elt_type);\n-        }\n-        fcx.write_ty(pat.id, expected);\n-      }\n-\n-      ast::PatMac(_) => tcx.sess.bug(\"unexpanded macro\"),\n-    }\n-}\n-\n-// Helper function to check gc, box and & patterns\n-fn check_pointer_pat(pcx: &pat_ctxt,\n-                     pointer_kind: PointerKind,\n-                     inner: &ast::Pat,\n-                     pat_id: ast::NodeId,\n-                     span: Span,\n-                     expected: ty::t) {\n-    let fcx = pcx.fcx;\n-    let tcx = fcx.ccx.tcx;\n-    let check_inner: |ty::t| = |e_inner| {\n-        match ty::get(e_inner).sty {\n-            ty::ty_trait(_) if pat_is_binding(&tcx.def_map, inner) => {\n-                // This is \"x = SomeTrait\" being reduced from\n-                // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                check_pat(pcx, inner, ty::mk_err());\n-                span_err!(tcx.sess, span, E0033,\n-                    \"type `{}` cannot be dereferenced\",\n-                    fcx.infcx().ty_to_string(expected));\n-                fcx.write_error(pat_id);\n-            }\n-            _ => {\n-                check_pat(pcx, inner, e_inner);\n-                fcx.write_ty(pat_id, expected);\n-            }\n-        }\n-    };\n-\n-    match *structure_of(fcx, span, expected) {\n-        ty::ty_uniq(e_inner) if pointer_kind == Send => {\n-            check_inner(e_inner);\n-        }\n-        ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n-            check_inner(e_inner.ty);\n-        }\n-        _ => {\n-            check_pat(pcx, inner, ty::mk_err());\n-            // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-            fcx.infcx().type_error_message_str_with_expected(\n-                span,\n-                |expected, actual| {\n-                    expected.map_or(\"\".to_string(), |e| {\n-                        format!(\"mismatched types: expected `{}`, found {}\",\n-                                e, actual)\n-                    })\n-                },\n-                Some(expected),\n-                format!(\"{} pattern\", match pointer_kind {\n-                    Send => \"a box\",\n-                    Borrowed => \"an `&`-pointer\",\n-                }),\n-                None);\n-            fcx.write_error(pat_id);\n-          }\n-    }\n-}\n-\n-#[deriving(PartialEq)]\n-pub enum PointerKind {\n-    Send,\n-    Borrowed,\n-}\n-"}, {"sha": "feab2bacbb842e5aba0e79c18ad7b4e07a19d476", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -117,7 +117,7 @@ use util::ppaux;\n use util::ppaux::{UserString, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, Ref, RefCell};\n use std::collections::HashMap;\n use std::collections::hashmap::{Occupied, Vacant};\n use std::mem::replace;\n@@ -1815,6 +1815,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts>> {\n+        self.inh.item_substs.borrow()\n+    }\n+\n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n                               f: |&ty::ItemSubsts|) {"}, {"sha": "1f4b80b360bd266a2f6fa4634d1807e37172d764", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -236,10 +236,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                 };\n \n                 convert_struct(ccx, &**struct_def, pty, variant.node.id);\n-\n-                let input_tys: Vec<_> = struct_def.fields.iter().map(\n-                    |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n-                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n+                enum_ty\n             }\n         };\n "}, {"sha": "d59c0ad52e98686ff5d25070c73a72adebb2ac38", "filename": "src/test/run-pass/issue-8783.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4380e96c0470d746267a11633fafe3e4ea459687/src%2Ftest%2Frun-pass%2Fissue-8783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4380e96c0470d746267a11633fafe3e4ea459687/src%2Ftest%2Frun-pass%2Fissue-8783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8783.rs?ref=4380e96c0470d746267a11633fafe3e4ea459687", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::default::Default;\n+\n+struct X { pub x: uint }\n+impl Default for X {\n+    fn default() -> X {\n+        X { x: 42u }\n+    }\n+}\n+\n+struct Y<T> { pub y: T }\n+impl<T: Default> Default for Y<T> {\n+    fn default() -> Y<T> {\n+        Y { y: Default::default() }\n+    }\n+}\n+\n+fn main() {\n+    let X { x: _ } = Default::default();\n+    let Y { y: X { x } } = Default::default();\n+}"}]}