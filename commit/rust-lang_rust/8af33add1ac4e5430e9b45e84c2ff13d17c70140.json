{"sha": "8af33add1ac4e5430e9b45e84c2ff13d17c70140", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZjMzYWRkMWFjNGU1NDMwZTliNDVlODRjMmZmMTNkMTdjNzAxNDA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-22T00:14:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-22T00:14:36Z"}, "message": "Rollup merge of #75705 - denisvasilik:intra-doc-links-intrinsics, r=jyn514\n\nMove to intra-doc links for /library/core/src/intrinsics.rs\n\nHelps with #75080.\n\n@rustbot modify labels: T-doc, A-intra-doc-links, T-rustdoc\n\nKnown issues:\n\n* The following f32 and f64 primitive methods cannot be resolved:\n\n    f32/f64::powi\n    f32/f64::sqrt\n    f32/f64::sin\n    f32/f64::cos\n    f32/f64::powf\n    f32/f64::exp\n    f32/f64::exp2\n    f32/f64::ln\n    f32/f64::log2\n    f32/f64::log10\n    f32/f64::mul_add\n    f32/f64::abs\n    f32/f64::copysign\n    f32/f64::floor\n    f32/f64::ceil\n    f32/f64::trunc\n    f32/f64::round\n\n* Links from core to std:\n\n    [`std::pointer::*`]\n    [`std::process::abort`]\n    [`from_raw_parts`]\n    [`Vec::append`]\n\n* Links with anchors?\n\n\tI provided a separate commit that replaced links with anchors by intra-doc links.\n\tHere the anchor location information gets lost, so its questionable whether to\n\tactually replace those links.", "tree": {"sha": "978a24215f9a5147677e5520f834f0b9eafc6cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/978a24215f9a5147677e5520f834f0b9eafc6cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8af33add1ac4e5430e9b45e84c2ff13d17c70140", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfQGNsCRBK7hj4Ov3rIwAAdHIIAKm9STA3kn9dUa0D87qtU/gq\nZnDTt7rC2L/nyT1K3o1F1S9w7J3LBNqeJiADFFcaIIO61gWJbgJ6GdH2luUH82YJ\njiBKP05f2m5dgH8GTsE6eCVwc7SsW/s1znRcDo+gYEJ7BEyRfB2zapqkBHpHYzzA\nbgeR0D0vtv9RcBiO0KS7jwLwWsaAcYz3s91lz5dSXLl4QNs3ZRq5L557Wz/ly0kJ\nFdM/HxQajtkoJAAOTirRThK7XBaN6AVll3x9bl06OraX3Zdj6mviBKsMcjQvIP2U\nKqg/9oyGHSLMY5Ffyj/5KOU4es51EH/VQCrRifjvPNr0c87W4yS9uiECKScH3Tc=\n=ffph\n-----END PGP SIGNATURE-----\n", "payload": "tree 978a24215f9a5147677e5520f834f0b9eafc6cb6\nparent de521cbb303c08febd9fa3755caccd4f3e491ea3\nparent 37b6c249ede0f141a2fcf0332ef11d7cbf68e350\nauthor Dylan DPC <dylan.dpc@gmail.com> 1598055276 +0200\ncommitter GitHub <noreply@github.com> 1598055276 +0200\n\nRollup merge of #75705 - denisvasilik:intra-doc-links-intrinsics, r=jyn514\n\nMove to intra-doc links for /library/core/src/intrinsics.rs\n\nHelps with #75080.\n\n@rustbot modify labels: T-doc, A-intra-doc-links, T-rustdoc\n\nKnown issues:\n\n* The following f32 and f64 primitive methods cannot be resolved:\n\n    f32/f64::powi\n    f32/f64::sqrt\n    f32/f64::sin\n    f32/f64::cos\n    f32/f64::powf\n    f32/f64::exp\n    f32/f64::exp2\n    f32/f64::ln\n    f32/f64::log2\n    f32/f64::log10\n    f32/f64::mul_add\n    f32/f64::abs\n    f32/f64::copysign\n    f32/f64::floor\n    f32/f64::ceil\n    f32/f64::trunc\n    f32/f64::round\n\n* Links from core to std:\n\n    [`std::pointer::*`]\n    [`std::process::abort`]\n    [`from_raw_parts`]\n    [`Vec::append`]\n\n* Links with anchors?\n\n\tI provided a separate commit that replaced links with anchors by intra-doc links.\n\tHere the anchor location information gets lost, so its questionable whether to\n\tactually replace those links.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8af33add1ac4e5430e9b45e84c2ff13d17c70140", "html_url": "https://github.com/rust-lang/rust/commit/8af33add1ac4e5430e9b45e84c2ff13d17c70140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8af33add1ac4e5430e9b45e84c2ff13d17c70140/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de521cbb303c08febd9fa3755caccd4f3e491ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/de521cbb303c08febd9fa3755caccd4f3e491ea3", "html_url": "https://github.com/rust-lang/rust/commit/de521cbb303c08febd9fa3755caccd4f3e491ea3"}, {"sha": "37b6c249ede0f141a2fcf0332ef11d7cbf68e350", "url": "https://api.github.com/repos/rust-lang/rust/commits/37b6c249ede0f141a2fcf0332ef11d7cbf68e350", "html_url": "https://github.com/rust-lang/rust/commit/37b6c249ede0f141a2fcf0332ef11d7cbf68e350"}], "stats": {"total": 701, "additions": 235, "deletions": 466}, "files": [{"sha": "9acf43931c6bacfb59616385108d702bf59e1568", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 235, "deletions": 466, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/8af33add1ac4e5430e9b45e84c2ff13d17c70140/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af33add1ac4e5430e9b45e84c2ff13d17c70140/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=8af33add1ac4e5430e9b45e84c2ff13d17c70140", "patch": "@@ -57,6 +57,10 @@\n use crate::marker::DiscriminantKind;\n use crate::mem;\n \n+// These imports are used for simplifying intra-doc links\n+#[cfg(doc)]\n+use crate::sync::atomic::{self, AtomicBool, AtomicI32, AtomicIsize, AtomicU32, Ordering};\n+\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[rustc_deprecated(\n     reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n@@ -71,710 +75,510 @@ extern \"rust-intrinsic\" {\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `load` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n+    /// [`atomic`] types via the `load` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n     pub fn atomic_load<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `load` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n+    /// [`atomic`] types via the `load` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n     pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `load` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n+    /// [`atomic`] types via the `load` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n     pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `store` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n+    /// [`atomic`] types via the `store` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n     pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `store` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n+    /// [`atomic`] types via the `store` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n     pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `store` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n+    /// [`atomic`] types via the `store` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -823,33 +627,25 @@ extern \"rust-intrinsic\" {\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n     pub fn atomic_fence();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n     pub fn atomic_fence_acq();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n     pub fn atomic_fence_rel();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n     pub fn atomic_fence_acqrel();\n \n@@ -861,9 +657,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence();\n     /// A compiler-only memory barrier.\n@@ -874,9 +668,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_acq();\n     /// A compiler-only memory barrier.\n@@ -887,9 +679,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_rel();\n     /// A compiler-only memory barrier.\n@@ -900,9 +690,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_acqrel();\n \n@@ -930,8 +718,7 @@ extern \"rust-intrinsic\" {\n     /// macro, which panics when it is executed, it is *undefined behavior* to\n     /// reach code marked with this function.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::hint::unreachable_unchecked`](../../std/hint/fn.unreachable_unchecked.html).\n+    /// The stabilized version of this intrinsic is [`crate::hint::unreachable_unchecked`].\n     #[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n     pub fn unreachable() -> !;\n \n@@ -975,23 +762,20 @@ extern \"rust-intrinsic\" {\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::size_of`](../../std/mem/fn.size_of.html).\n+    /// The stabilized version of this intrinsic is [`size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     pub fn size_of<T>() -> usize;\n \n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::ptr::write`](../../std/ptr/fn.write.html).\n+    /// The stabilized version of this intrinsic is [`crate::ptr::write`].\n     pub fn move_val_init<T>(dst: *mut T, src: T);\n \n     /// The minimum alignment of a type.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n+    /// The stabilized version of this intrinsic is [`crate::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n@@ -1002,30 +786,26 @@ extern \"rust-intrinsic\" {\n \n     /// The size of the referenced value in bytes.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n+    /// The stabilized version of this intrinsic is [`size_of_val`].\n     #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::align_of_val`](../../std/mem/fn.align_of_val.html).\n+    /// The stabilized version of this intrinsic is [`crate::mem::align_of_val`].\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::any::type_name`](../../std/any/fn.type_name.html)\n+    /// The stabilized version of this intrinsic is [`crate::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::any::TypeId::of`](../../std/any/struct.TypeId.html#method.of)\n+    /// The stabilized version of this intrinsic is [`crate::any::TypeId::of`].\n     #[rustc_const_stable(feature = \"const_type_id\", since = \"1.46.0\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n@@ -1049,15 +829,14 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n     ///\n-    /// Consider using [`std::panic::Location::caller`](../../std/panic/struct.Location.html#method.caller)\n-    /// instead.\n+    /// Consider using [`crate::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n     ///\n-    /// This exists solely for [`mem::forget_unsized`](../../std/mem/fn.forget_unsized.html);\n-    /// normal `forget` uses `ManuallyDrop` instead.\n+    /// This exists solely for [`mem::forget_unsized`]; normal `forget` uses\n+    /// `ManuallyDrop` instead.\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1300,8 +1079,7 @@ extern \"rust-intrinsic\" {\n     /// If the actual type neither requires drop glue nor implements\n     /// `Copy`, then the return value of this function is unspecified.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::needs_drop`](../../std/mem/fn.needs_drop.html).\n+    /// The stabilized version of this intrinsic is [`needs_drop`].\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     pub fn needs_drop<T>() -> bool;\n \n@@ -1371,13 +1149,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n+    /// The stabilized version of this intrinsic is [`crate::ptr::read_volatile`].\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n+    /// The stabilized version of this intrinsic is [`crate::ptr::write_volatile`].\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n@@ -1526,22 +1302,22 @@ extern \"rust-intrinsic\" {\n     /// Returns the minimum of two `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f32::min`](../../std/primitive.f32.html#method.min)\n+    /// [`f32::min`]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f64::min`](../../std/primitive.f64.html#method.min)\n+    /// [`f64::min`]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f32::max`](../../std/primitive.f32.html#method.max)\n+    /// [`f32::max`]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f64::max`](../../std/primitive.f64.html#method.max)\n+    /// [`f64::max`]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n@@ -1648,23 +1424,22 @@ extern \"rust-intrinsic\" {\n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n-    /// Stabilized as [`f32::to_int_unchecked`](../../std/primitive.f32.html#method.to_int_unchecked)\n-    /// and [`f64::to_int_unchecked`](../../std/primitive.f64.html#method.to_int_unchecked).\n+    /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `count_ones` method. For example,\n-    /// [`std::u32::count_ones`](../../std/primitive.u32.html#method.count_ones)\n+    /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `leading_zeros` method. For example,\n-    /// [`std::u32::leading_zeros`](../../std/primitive.u32.html#method.leading_zeros)\n+    /// [`u32::leading_zeros`]\n     ///\n     /// # Examples\n     ///\n@@ -1715,7 +1490,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `trailing_zeros` method. For example,\n-    /// [`std::u32::trailing_zeros`](../../std/primitive.u32.html#method.trailing_zeros)\n+    /// [`u32::trailing_zeros`]\n     ///\n     /// # Examples\n     ///\n@@ -1766,39 +1541,39 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `swap_bytes` method. For example,\n-    /// [`std::u32::swap_bytes`](../../std/primitive.u32.html#method.swap_bytes)\n+    /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `reverse_bits` method. For example,\n-    /// [`std::u32::reverse_bits`](../../std/primitive.u32.html#method.reverse_bits)\n+    /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n-    /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n+    /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n-    /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n+    /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n-    /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n+    /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n@@ -1813,15 +1588,15 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n-    /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n+    /// [`u32::checked_div`]\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::MIN` and y = -1\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n-    /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n+    /// [`u32::checked_rem`]\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n@@ -1830,15 +1605,15 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shl` method. For example,\n-    /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n+    /// [`u32::checked_shl`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shr` method. For example,\n-    /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n+    /// [`u32::checked_shr`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n@@ -1867,68 +1642,66 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n-    /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n+    /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n-    /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n+    /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_add` method. For example,\n-    /// [`std::u32::checked_add`](../../std/primitive.u32.html#method.checked_add)\n+    /// [`u32::checked_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_sub` method. For example,\n-    /// [`std::u32::checked_sub`](../../std/primitive.u32.html#method.checked_sub)\n+    /// [`u32::checked_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_mul` method. For example,\n-    /// [`std::u32::checked_mul`](../../std/primitive.u32.html#method.checked_mul)\n+    /// [`u32::checked_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n-    /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n+    /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n-    /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n+    /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::discriminant`](../../std/mem/fn.discriminant.html)\n+    /// The stabilized version of this intrinsic is [`crate::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n     /// if `T` has no variants, returns 0. Uninhabited variants will be counted.\n     ///\n-    /// The to-be-stabilized version of this intrinsic is\n-    /// [`std::mem::variant_count`](../../std/mem/fn.variant_count.html)\n+    /// The to-be-stabilized version of this intrinsic is [`variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     pub fn variant_count<T>() -> usize;\n \n@@ -1989,7 +1762,6 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n /// with the argument order swapped.\n ///\n-/// [`copy`]: ./fn.copy.html\n /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n ///\n /// # Safety\n@@ -2014,10 +1786,9 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ../ptr/fn.read.html\n-/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [`read`]: crate::ptr::read\n+/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+/// [valid]: crate::ptr#safety\n ///\n /// # Examples\n ///\n@@ -2096,7 +1867,6 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n /// order swapped. Copying takes place as if the bytes were copied from `src`\n /// to a temporary array and then copied from the array to `dst`.\n ///\n-/// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n ///\n /// # Safety\n@@ -2117,10 +1887,9 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ../ptr/fn.read.html\n-/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [`read`]: crate::ptr::read\n+/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+/// [valid]: crate::ptr#safety\n ///\n /// # Examples\n ///\n@@ -2178,7 +1947,7 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: crate::ptr#safety\n ///\n /// # Examples\n ///"}]}