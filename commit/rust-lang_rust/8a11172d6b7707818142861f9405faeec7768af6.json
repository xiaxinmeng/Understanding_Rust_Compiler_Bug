{"sha": "8a11172d6b7707818142861f9405faeec7768af6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMTExNzJkNmI3NzA3ODE4MTQyODYxZjk0MDVmYWVlYzc3NjhhZjY=", "commit": {"author": {"name": "Michal Budzynski", "email": "budziq@gmail.com", "date": "2017-09-15T12:51:44Z"}, "committer": {"name": "Michal Budzynski", "email": "budziq@gmail.com", "date": "2017-09-16T20:18:46Z"}, "message": "stabilized compiler_fences (fixes #41091)", "tree": {"sha": "83b3f70895570aa17c4b0b612a13f980c3f8a2d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b3f70895570aa17c4b0b612a13f980c3f8a2d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a11172d6b7707818142861f9405faeec7768af6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a11172d6b7707818142861f9405faeec7768af6", "html_url": "https://github.com/rust-lang/rust/commit/8a11172d6b7707818142861f9405faeec7768af6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a11172d6b7707818142861f9405faeec7768af6/comments", "author": {"login": "budziq", "id": 221000, "node_id": "MDQ6VXNlcjIyMTAwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/221000?v=4", "gravatar_id": "", "url": "https://api.github.com/users/budziq", "html_url": "https://github.com/budziq", "followers_url": "https://api.github.com/users/budziq/followers", "following_url": "https://api.github.com/users/budziq/following{/other_user}", "gists_url": "https://api.github.com/users/budziq/gists{/gist_id}", "starred_url": "https://api.github.com/users/budziq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/budziq/subscriptions", "organizations_url": "https://api.github.com/users/budziq/orgs", "repos_url": "https://api.github.com/users/budziq/repos", "events_url": "https://api.github.com/users/budziq/events{/privacy}", "received_events_url": "https://api.github.com/users/budziq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "budziq", "id": 221000, "node_id": "MDQ6VXNlcjIyMTAwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/221000?v=4", "gravatar_id": "", "url": "https://api.github.com/users/budziq", "html_url": "https://github.com/budziq", "followers_url": "https://api.github.com/users/budziq/followers", "following_url": "https://api.github.com/users/budziq/following{/other_user}", "gists_url": "https://api.github.com/users/budziq/gists{/gist_id}", "starred_url": "https://api.github.com/users/budziq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/budziq/subscriptions", "organizations_url": "https://api.github.com/users/budziq/orgs", "repos_url": "https://api.github.com/users/budziq/repos", "events_url": "https://api.github.com/users/budziq/events{/privacy}", "received_events_url": "https://api.github.com/users/budziq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae8efdc87d5f4e22e05e1b60a72272cee87fa74c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8efdc87d5f4e22e05e1b60a72272cee87fa74c", "html_url": "https://github.com/rust-lang/rust/commit/ae8efdc87d5f4e22e05e1b60a72272cee87fa74c"}], "stats": {"total": 108, "additions": 1, "deletions": 107}, "files": [{"sha": "b1e36ab13d5aee82fe881e4833bd2e779a564a27", "filename": "src/doc/unstable-book/src/library-features/compiler-fences.md", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ae8efdc87d5f4e22e05e1b60a72272cee87fa74c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-fences.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae8efdc87d5f4e22e05e1b60a72272cee87fa74c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-fences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-fences.md?ref=ae8efdc87d5f4e22e05e1b60a72272cee87fa74c", "patch": "@@ -1,106 +0,0 @@\n-# `compiler_fences`\n-\n-The tracking issue for this feature is: [#41091]\n-\n-[#41091]: https://github.com/rust-lang/rust/issues/41091\n-\n-------------------------\n-\n-The `compiler_fences` feature exposes the `compiler_fence` function\n-in `std::sync::atomic`. This function is conceptually similar to C++'s\n-`atomic_signal_fence`, which can currently only be accessed in nightly\n-Rust using the `atomic_singlethreadfence_*` instrinsic functions in\n-`core`, or through the mostly equivalent literal assembly:\n-\n-```rust\n-#![feature(asm)]\n-unsafe { asm!(\"\" ::: \"memory\" : \"volatile\") };\n-```\n-\n-A `compiler_fence` restricts the kinds of memory re-ordering the\n-compiler is allowed to do. Specifically, depending on the given ordering\n-semantics, the compiler may be disallowed from moving reads or writes\n-from before or after the call to the other side of the call to\n-`compiler_fence`. Note that it does **not** prevent the *hardware*\n-from doing such re-ordering. This is not a problem in a single-threaded,\n-execution context, but when other threads may modify memory at the same\n-time, stronger synchronization primitives are required.\n-\n-## Examples\n-\n-`compiler_fence` is generally only useful for preventing a thread from\n-racing *with itself*. That is, if a given thread is executing one piece\n-of code, and is then interrupted, and starts executing code elsewhere\n-(while still in the same thread, and conceptually still on the same\n-core). In traditional programs, this can only occur when a signal\n-handler is registered. In more low-level code, such situations can also\n-arise when handling interrupts, when implementing green threads with\n-pre-emption, etc.\n-\n-To give a straightforward example of when a `compiler_fence` is\n-necessary, consider the following example:\n-\n-```rust\n-# use std::sync::atomic::{AtomicBool, AtomicUsize};\n-# use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n-# use std::sync::atomic::Ordering;\n-static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n-static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n-\n-fn main() {\n-    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n-    IS_READY.store(true, Ordering::Relaxed);\n-}\n-\n-fn signal_handler() {\n-    if IS_READY.load(Ordering::Relaxed) {\n-        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n-    }\n-}\n-```\n-\n-The way it is currently written, the `assert_eq!` is *not* guaranteed to\n-succeed, despite everything happening in a single thread. To see why,\n-remember that the compiler is free to swap the stores to\n-`IMPORTANT_VARIABLE` and `IS_READ` since they are both\n-`Ordering::Relaxed`. If it does, and the signal handler is invoked right\n-after `IS_READY` is updated, then the signal handler will see\n-`IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n-\n-Using a `compiler_fence`, we can remedy this situation:\n-\n-```rust\n-#![feature(compiler_fences)]\n-# use std::sync::atomic::{AtomicBool, AtomicUsize};\n-# use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n-# use std::sync::atomic::Ordering;\n-use std::sync::atomic::compiler_fence;\n-\n-static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n-static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n-\n-fn main() {\n-    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n-    // prevent earlier writes from being moved beyond this point\n-    compiler_fence(Ordering::Release);\n-    IS_READY.store(true, Ordering::Relaxed);\n-}\n-\n-fn signal_handler() {\n-    if IS_READY.load(Ordering::Relaxed) {\n-        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n-    }\n-}\n-```\n-\n-A deeper discussion of compiler barriers with various re-ordering\n-semantics (such as `Ordering::SeqCst`) is beyond the scope of this text.\n-Curious readers are encouraged to read the Linux kernel's discussion of\n-[memory barriers][1], the C++ references on [`std::memory_order`][2] and\n-[`atomic_signal_fence`][3], and [this StackOverflow answer][4] for\n-further details.\n-\n-[1]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n-[2]: http://en.cppreference.com/w/cpp/atomic/memory_order\n-[3]: http://www.cplusplus.com/reference/atomic/atomic_signal_fence/\n-[4]: http://stackoverflow.com/a/18454971/472927"}, {"sha": "c6291630a35f3c2a6ff2da330152d2b7317f85f4", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a11172d6b7707818142861f9405faeec7768af6/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a11172d6b7707818142861f9405faeec7768af6/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=8a11172d6b7707818142861f9405faeec7768af6", "patch": "@@ -1703,7 +1703,7 @@ pub fn fence(order: Ordering) {\n /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n-#[unstable(feature = \"compiler_fences\", issue = \"41091\")]\n+#[stable(feature = \"compiler_fences\", since = \"1.22.0\")]\n pub fn compiler_fence(order: Ordering) {\n     unsafe {\n         match order {"}]}