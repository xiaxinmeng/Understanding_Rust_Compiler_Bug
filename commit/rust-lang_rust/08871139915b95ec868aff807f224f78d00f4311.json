{"sha": "08871139915b95ec868aff807f224f78d00f4311", "node_id": "C_kwDOAAsO6NoAKDA4ODcxMTM5OTE1Yjk1ZWM4NjhhZmY4MDdmMjI0Zjc4ZDAwZjQzMTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T22:34:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T22:34:50Z"}, "message": "Auto merge of #98307 - matthiaskrgr:rollup-rb3huha, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #98235 (Drop magic value 3 from code)\n - #98267 (Don't omit comma when suggesting wildcard arm after macro expr)\n - #98276 (Mention formatting macros when encountering `ArgumentV1` method in const)\n - #98296 (Add a link to the unstable book page on Generator doc comment)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d0a3a324262916625b81467e90b87b7d139e843e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0a3a324262916625b81467e90b87b7d139e843e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08871139915b95ec868aff807f224f78d00f4311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08871139915b95ec868aff807f224f78d00f4311", "html_url": "https://github.com/rust-lang/rust/commit/08871139915b95ec868aff807f224f78d00f4311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08871139915b95ec868aff807f224f78d00f4311/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5750a6aa2777382bf421b726f234da23f990a953", "url": "https://api.github.com/repos/rust-lang/rust/commits/5750a6aa2777382bf421b726f234da23f990a953", "html_url": "https://github.com/rust-lang/rust/commit/5750a6aa2777382bf421b726f234da23f990a953"}, {"sha": "dfa933d420ac6ba5af66b0be60455c9bd1882bf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa933d420ac6ba5af66b0be60455c9bd1882bf2", "html_url": "https://github.com/rust-lang/rust/commit/dfa933d420ac6ba5af66b0be60455c9bd1882bf2"}], "stats": {"total": 642, "additions": 361, "deletions": 281}, "files": [{"sha": "0c587220cb77292bb2201584676a64a858bd1949", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -10,7 +10,8 @@ use rustc_middle::mir;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    suggest_constraining_type_param, Adt, Closure, FnDef, FnPtr, Param, TraitPredicate, Ty,\n+    suggest_constraining_type_param, Adt, Closure, DefIdTree, FnDef, FnPtr, Param, TraitPredicate,\n+    Ty,\n };\n use rustc_middle::ty::{Binder, BoundConstness, ImplPolarity, TraitRef};\n use rustc_session::parse::feature_err;\n@@ -300,6 +301,15 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 diag_trait(&mut err, self_ty, tcx.lang_items().deref_trait().unwrap());\n                 err\n             }\n+            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n+                struct_span_err!(\n+                    ccx.tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot call non-const formatting macro in {}s\",\n+                    ccx.const_kind(),\n+                )\n+            }\n             _ => struct_span_err!(\n                 ccx.tcx.sess,\n                 span,"}, {"sha": "4418b848e512a638d1b913e6e21a01c973a4c3a5", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -667,7 +667,7 @@ fn trim_span_hi(span: Span, to_pos: BytePos) -> Span {\n fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n     let fn_decl_span = tcx.def_span(def_id);\n     if let Some(body_span) = hir_body(tcx, def_id).map(|hir_body| hir_body.value.span) {\n-        if fn_decl_span.ctxt() == body_span.ctxt() { fn_decl_span.to(body_span) } else { body_span }\n+        if fn_decl_span.eq_ctxt(body_span) { fn_decl_span.to(body_span) } else { body_span }\n     } else {\n         fn_decl_span\n     }"}, {"sha": "76333b755b747d540a1ad3d526070ac92b368613", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -803,7 +803,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     let mut suggestion = None;\n     let sm = cx.tcx.sess.source_map();\n     match arms {\n-        [] if sp.ctxt() == expr_span.ctxt() => {\n+        [] if sp.eq_ctxt(expr_span) => {\n             // Get the span for the empty match body `{}`.\n             let (indentation, more) = if let Some(snippet) = sm.indentation_before(sp) {\n                 (format!(\"\\n{}\", snippet), \"    \")\n@@ -821,24 +821,36 @@ fn non_exhaustive_match<'p, 'tcx>(\n             ));\n         }\n         [only] => {\n-            let pre_indentation = if let (Some(snippet), true) = (\n-                sm.indentation_before(only.span),\n-                sm.is_multiline(sp.shrink_to_hi().with_hi(only.span.lo())),\n-            ) {\n-                format!(\"\\n{}\", snippet)\n+            let (pre_indentation, is_multiline) = if let Some(snippet) = sm.indentation_before(only.span)\n+                && let Ok(with_trailing) = sm.span_extend_while(only.span, |c| c.is_whitespace() || c == ',')\n+                && sm.is_multiline(with_trailing)\n+            {\n+                (format!(\"\\n{}\", snippet), true)\n+            } else {\n+                (\" \".to_string(), false)\n+            };\n+            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..))\n+                && only.span.eq_ctxt(only.body.span)\n+                && is_multiline\n+            {\n+                \"\"\n             } else {\n-                \" \".to_string()\n+                \",\"\n             };\n-            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..)) { \"\" } else { \",\" };\n             suggestion = Some((\n                 only.span.shrink_to_hi(),\n                 format!(\"{}{}{} => todo!()\", comma, pre_indentation, pattern),\n             ));\n         }\n-        [.., prev, last] if prev.span.ctxt() == last.span.ctxt() => {\n+        [.., prev, last] if prev.span.eq_ctxt(last.span) => {\n             if let Ok(snippet) = sm.span_to_snippet(prev.span.between(last.span)) {\n-                let comma =\n-                    if matches!(last.body.kind, hir::ExprKind::Block(..)) { \"\" } else { \",\" };\n+                let comma = if matches!(last.body.kind, hir::ExprKind::Block(..))\n+                    && last.span.eq_ctxt(last.body.span)\n+                {\n+                    \"\"\n+                } else {\n+                    \",\"\n+                };\n                 suggestion = Some((\n                     last.span.shrink_to_hi(),\n                     format!("}, {"sha": "782b620e28fe048c775c3cd82581414d59285424", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n-            fn_sig.span.ctxt() == body_span.ctxt()\n+            fn_sig.span.eq_ctxt(body_span)\n                 && Lrc::ptr_eq(&source_file, &source_map.lookup_source_file(fn_sig.span.lo()))\n         }) {\n             Some(fn_sig) => fn_sig.span.with_hi(body_span.lo()),"}, {"sha": "82070b903256c05ad182fcfb559062049e379035", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -195,7 +195,7 @@ impl CoverageSpan {\n             .expn_span\n             .parent_callsite()\n             .unwrap_or_else(|| bug!(\"macro must have a parent\"))\n-            .ctxt() == body_span.ctxt()\n+            .eq_ctxt(body_span)\n         {\n             return Some(current_macro);\n         }"}, {"sha": "d777d13d7a51425d0b4ac0cfea3a504134ff94d5", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -195,6 +195,11 @@ const RETURNED: usize = GeneratorSubsts::RETURNED;\n /// Generator has panicked and is poisoned.\n const POISONED: usize = GeneratorSubsts::POISONED;\n \n+/// Number of variants to reserve in generator state. Corresponds to\n+/// `UNRESUMED` (beginning of a generator) and `RETURNED`/`POISONED`\n+/// (end of a generator) states.\n+const RESERVED_VARIANTS: usize = 3;\n+\n /// A `yield` point in the generator.\n struct SuspensionPoint<'tcx> {\n     /// State discriminant used when suspending or resuming at this point.\n@@ -345,7 +350,7 @@ impl<'tcx> MutVisitor<'tcx> for TransformVisitor<'tcx> {\n             data.statements.extend(self.make_state(state_idx, v, source_info));\n             let state = if let Some((resume, mut resume_arg)) = resume {\n                 // Yield\n-                let state = 3 + self.suspension_points.len();\n+                let state = RESERVED_VARIANTS + self.suspension_points.len();\n \n                 // The resume arg target location might itself be remapped if its base local is\n                 // live across a yield.\n@@ -792,7 +797,6 @@ fn compute_layout<'tcx>(\n     // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states.\n     // In debuginfo, these will correspond to the beginning (UNRESUMED) or end\n     // (RETURNED, POISONED) of the function.\n-    const RESERVED_VARIANTS: usize = 3;\n     let body_span = body.source_scopes[OUTERMOST_SOURCE_SCOPE].span;\n     let mut variant_source_info: IndexVec<VariantIdx, SourceInfo> = [\n         SourceInfo::outermost(body_span.shrink_to_lo()),"}, {"sha": "7d2b7de17bf9c9c9047cc3055a44f1afa546b93d", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -1894,7 +1894,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let names = rib\n             .bindings\n             .iter()\n-            .filter(|(id, _)| id.span.ctxt() == label.span.ctxt())\n+            .filter(|(id, _)| id.span.eq_ctxt(label.span))\n             .map(|(id, _)| id.name)\n             .collect::<Vec<Symbol>>();\n "}, {"sha": "a329fa153207bbf7e208b5313c86133b70629254", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -537,6 +537,9 @@ impl Span {\n     pub fn ctxt(self) -> SyntaxContext {\n         self.data_untracked().ctxt\n     }\n+    pub fn eq_ctxt(self, other: Span) -> bool {\n+        self.data_untracked().ctxt == other.data_untracked().ctxt\n+    }\n     #[inline]\n     pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {\n         self.data_untracked().with_ctxt(ctxt)"}, {"sha": "8a6941a451621930fb52c787037b74fec521dadb", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -131,6 +131,7 @@ symbols! {\n         Arc,\n         Argument,\n         ArgumentV1,\n+        ArgumentV1Methods,\n         Arguments,\n         AsMut,\n         AsRef,\n@@ -1641,7 +1642,7 @@ impl Ident {\n \n impl PartialEq for Ident {\n     fn eq(&self, rhs: &Self) -> bool {\n-        self.name == rhs.name && self.span.ctxt() == rhs.span.ctxt()\n+        self.name == rhs.name && self.span.eq_ctxt(rhs.span)\n     }\n }\n "}, {"sha": "9e4a574818a14d704792e7323aed622519356216", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -320,6 +320,7 @@ macro_rules! arg_new {\n     };\n }\n \n+#[rustc_diagnostic_item = \"ArgumentV1Methods\"]\n impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]"}, {"sha": "b651b7b233edeabc4e9afed2ce676a4f21d9f4cc", "filename": "library/core/src/ops/generator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/library%2Fcore%2Fsrc%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/library%2Fcore%2Fsrc%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fgenerator.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -61,9 +61,10 @@ pub enum GeneratorState<Y, R> {\n /// }\n /// ```\n ///\n-/// More documentation of generators can be found in the unstable book.\n+/// More documentation of generators can be found in the [unstable book].\n ///\n /// [RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n+/// [unstable book]: ../../unstable-book/language-features/generators.html\n #[lang = \"generator\"]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n #[fundamental]"}, {"sha": "e43633da3ccb91dc592ddbee0140af3d878c42fe", "filename": "src/test/ui/consts/const-eval/format.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -0,0 +1,21 @@\n+const fn failure() {\n+    panic!(\"{:?}\", 0);\n+    //~^ ERROR cannot call non-const formatting macro in constant functions\n+    //~| ERROR erroneous constant used\n+    //~| ERROR erroneous constant used\n+    //~| WARN this was previously accepted by the compiler\n+    //~| WARN this was previously accepted by the compiler\n+}\n+\n+const fn print() {\n+    println!(\"{:?}\", 0);\n+    //~^ ERROR cannot call non-const formatting macro in constant functions\n+    //~| ERROR `Arguments::<'a>::new_v1` is not yet stable as a const fn\n+    //~| ERROR cannot call non-const fn `_print` in constant functions\n+    //~| ERROR erroneous constant used\n+    //~| ERROR erroneous constant used\n+    //~| WARN this was previously accepted by the compiler\n+    //~| WARN this was previously accepted by the compiler\n+}\n+\n+fn main() {}"}, {"sha": "44f436ae4e3a9ac0c474c6bc208ccef4e943c14d", "filename": "src/test/ui/consts/const-eval/format.stderr", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -0,0 +1,78 @@\n+error[E0015]: cannot call non-const formatting macro in constant functions\n+  --> $DIR/format.rs:2:20\n+   |\n+LL |     panic!(\"{:?}\", 0);\n+   |                    ^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the macro `$crate::const_format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0015]: cannot call non-const formatting macro in constant functions\n+  --> $DIR/format.rs:11:22\n+   |\n+LL |     println!(\"{:?}\", 0);\n+   |                      ^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: `Arguments::<'a>::new_v1` is not yet stable as a const fn\n+  --> $DIR/format.rs:11:5\n+   |\n+LL |     println!(\"{:?}\", 0);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_fmt_arguments_new)]` to the crate attributes to enable\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0015]: cannot call non-const fn `_print` in constant functions\n+  --> $DIR/format.rs:11:5\n+   |\n+LL |     println!(\"{:?}\", 0);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: erroneous constant used\n+  --> $DIR/format.rs:2:12\n+   |\n+LL |     panic!(\"{:?}\", 0);\n+   |            ^^^^^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: erroneous constant used\n+  --> $DIR/format.rs:2:20\n+   |\n+LL |     panic!(\"{:?}\", 0);\n+   |                    ^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = note: this error originates in the macro `$crate::const_format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: erroneous constant used\n+  --> $DIR/format.rs:11:14\n+   |\n+LL |     println!(\"{:?}\", 0);\n+   |              ^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: erroneous constant used\n+  --> $DIR/format.rs:11:22\n+   |\n+LL |     println!(\"{:?}\", 0);\n+   |                      ^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "d429b4e8effbff3a5cb80f5b6c553487b3184c42", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "modified", "additions": 136, "deletions": 204, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -7,9 +7,8 @@ LL |     m!(0f32, f32::NEG_INFINITY..);\n    = note: the matched value is of type `f32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:17:8\n@@ -20,9 +19,8 @@ LL |     m!(0f32, ..f32::INFINITY);\n    = note: the matched value is of type `f32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:26:8\n@@ -33,9 +31,8 @@ LL |     m!('a', ..core::char::MAX);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\u{10ffff}' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\u{10ffff}' => todo!() }\n+   |                                +++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:27:8\n@@ -46,9 +43,8 @@ LL |     m!('a', ..ALMOST_MAX);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\u{10fffe}'..='\\u{10ffff}' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\u{10fffe}'..='\\u{10ffff}' => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\0'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:28:8\n@@ -59,9 +55,8 @@ LL |     m!('a', ALMOST_MIN..);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\0' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\0' => todo!() }\n+   |                                +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:29:8\n@@ -72,9 +67,8 @@ LL |     m!('a', ..=ALMOST_MAX);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         '\\u{10ffff}' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, '\\u{10ffff}' => todo!() }\n+   |                                +++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:30:8\n@@ -85,9 +79,8 @@ LL |     m!('a', ..=VAL | VAL_2..);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         'b' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 'b' => todo!() }\n+   |                                ++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:31:8\n@@ -98,9 +91,8 @@ LL |     m!('a', ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `char`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         'b' => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 'b' => todo!() }\n+   |                                ++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n@@ -111,9 +103,8 @@ LL |         m!(0, ..u8::MAX);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `254_u8..=u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n@@ -124,9 +115,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         254_u8..=u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 254_u8..=u8::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:43:12\n@@ -137,9 +127,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u8 => todo!() }\n+   |                                +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n@@ -150,9 +139,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:45:12\n@@ -163,9 +151,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:46:12\n@@ -176,9 +163,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n@@ -189,9 +175,8 @@ LL |         m!(0, ..u16::MAX);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `65534_u16..=u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n@@ -202,9 +187,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         65534_u16..=u16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 65534_u16..=u16::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:56:12\n@@ -215,9 +199,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u16 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n@@ -228,9 +211,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:58:12\n@@ -241,9 +223,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:59:12\n@@ -254,9 +235,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n@@ -267,9 +247,8 @@ LL |         m!(0, ..u32::MAX);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `4294967294_u32..=u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n@@ -280,9 +259,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         4294967294_u32..=u32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 4294967294_u32..=u32::MAX => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:69:12\n@@ -293,9 +271,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u32 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n@@ -306,9 +283,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:71:12\n@@ -319,9 +295,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:72:12\n@@ -332,9 +307,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n@@ -345,9 +319,8 @@ LL |         m!(0, ..u64::MAX);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `18446744073709551614_u64..=u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n@@ -358,9 +331,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         18446744073709551614_u64..=u64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 18446744073709551614_u64..=u64::MAX => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:82:12\n@@ -371,9 +343,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u64 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n@@ -384,9 +355,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:84:12\n@@ -397,9 +367,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:85:12\n@@ -410,9 +379,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n@@ -423,9 +391,8 @@ LL |         m!(0, ..u128::MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454_u128..=u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n@@ -436,9 +403,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         340282366920938463463374607431768211454_u128..=u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 340282366920938463463374607431768211454_u128..=u128::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:95:12\n@@ -449,9 +415,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u128 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n@@ -462,9 +427,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:97:12\n@@ -475,9 +439,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:98:12\n@@ -488,9 +451,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_u128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n@@ -501,9 +463,8 @@ LL |         m!(0, ..i8::MAX);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `126_i8..=i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n@@ -514,9 +475,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         126_i8..=i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 126_i8..=i8::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n@@ -527,9 +487,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MIN => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n@@ -540,9 +499,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:113:12\n@@ -553,9 +511,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:114:12\n@@ -566,9 +523,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n@@ -579,9 +535,8 @@ LL |         m!(0, ..i16::MAX);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `32766_i16..=i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n@@ -592,9 +547,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         32766_i16..=i16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 32766_i16..=i16::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i16::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n@@ -605,9 +559,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i16::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i16::MIN => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n@@ -618,9 +571,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i16::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i16::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:126:12\n@@ -631,9 +583,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:127:12\n@@ -644,9 +595,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i16`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i16 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i16 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n@@ -657,9 +607,8 @@ LL |         m!(0, ..i32::MAX);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `2147483646_i32..=i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n@@ -670,9 +619,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         2147483646_i32..=i32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 2147483646_i32..=i32::MAX => todo!() }\n+   |                                ++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n@@ -683,9 +631,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i32::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i32::MIN => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n@@ -696,9 +643,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i32::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i32::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:139:12\n@@ -709,9 +655,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:140:12\n@@ -722,9 +667,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i32 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i32 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n@@ -735,9 +679,8 @@ LL |         m!(0, ..i64::MAX);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `9223372036854775806_i64..=i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n@@ -748,9 +691,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         9223372036854775806_i64..=i64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 9223372036854775806_i64..=i64::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i64::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n@@ -761,9 +703,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i64::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i64::MIN => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n@@ -774,9 +715,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i64::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i64::MAX => todo!() }\n+   |                                +++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:152:12\n@@ -787,9 +727,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:153:12\n@@ -800,9 +739,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i64 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i64 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n@@ -813,9 +751,8 @@ LL |         m!(0, ..i128::MAX);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726_i128..=i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n@@ -826,9 +763,8 @@ LL |         m!(0, ..ALMOST_MAX);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         170141183460469231731687303715884105726_i128..=i128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 170141183460469231731687303715884105726_i128..=i128::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i128::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n@@ -839,9 +775,8 @@ LL |         m!(0, ALMOST_MIN..);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i128::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i128::MIN => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n@@ -852,9 +787,8 @@ LL |         m!(0, ..=ALMOST_MAX);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:165:12\n@@ -865,9 +799,8 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `43_i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:166:12\n@@ -878,9 +811,8 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = note: the matched value is of type `i128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         43_i128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 43_i128 => todo!() }\n+   |                                ++++++++++++++++++++\n \n error: aborting due to 68 previous errors\n "}, {"sha": "c42034879369232c258265e28c7ceee85c7a8d57", "filename": "src/test/ui/issue-94866.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fissue-94866.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fissue-94866.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-94866.rs?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -0,0 +1,14 @@\n+macro_rules! m {\n+    () => {\n+        {}\n+    };\n+}\n+\n+enum Enum { A, B }\n+\n+fn main() {\n+    match Enum::A {\n+    //~^ ERROR non-exhaustive patterns\n+    Enum::A => m!()\n+    }\n+}"}, {"sha": "5477d83f449209ee59375ff18db17253552a9e98", "filename": "src/test/ui/issue-94866.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fissue-94866.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fissue-94866.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-94866.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -0,0 +1,21 @@\n+error[E0004]: non-exhaustive patterns: `B` not covered\n+  --> $DIR/issue-94866.rs:10:11\n+   |\n+LL |     match Enum::A {\n+   |           ^^^^^^^ pattern `B` not covered\n+   |\n+note: `Enum` defined here\n+  --> $DIR/issue-94866.rs:7:16\n+   |\n+LL | enum Enum { A, B }\n+   |      ----      ^ not covered\n+   = note: the matched value is of type `Enum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~     Enum::A => m!(),\n+LL +     B => todo!()\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "f30ba05dff9e4343f4199e843086d8d5d9fe1e59", "filename": "src/test/ui/pattern/usefulness/integer-ranges/exhaustiveness.stderr", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -7,9 +7,8 @@ LL |     m!(0u8, 0..255);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:48:8\n@@ -20,9 +19,8 @@ LL |     m!(0u8, 0..=254);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u8` not covered\n   --> $DIR/exhaustiveness.rs:49:8\n@@ -33,9 +31,8 @@ LL |     m!(0u8, 1..=255);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u8 => todo!() }\n+   |                                +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `42_u8` not covered\n   --> $DIR/exhaustiveness.rs:50:8\n@@ -46,9 +43,8 @@ LL |     m!(0u8, 0..42 | 43..=255);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         42_u8 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 42_u8 => todo!() }\n+   |                                ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:51:8\n@@ -59,9 +55,8 @@ LL |     m!(0i8, -128..127);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:52:8\n@@ -72,9 +67,8 @@ LL |     m!(0i8, -128..=126);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MAX => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/exhaustiveness.rs:53:8\n@@ -85,9 +79,8 @@ LL |     m!(0i8, -127..=127);\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         i8::MIN => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, i8::MIN => todo!() }\n+   |                                ++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_i8` not covered\n   --> $DIR/exhaustiveness.rs:54:11\n@@ -111,9 +104,8 @@ LL |     m!(0u128, 0..=ALMOST_MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, u128::MAX => todo!() }\n+   |                                ++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `5_u128..=u128::MAX` not covered\n   --> $DIR/exhaustiveness.rs:60:8\n@@ -124,9 +116,8 @@ LL |     m!(0u128, 0..=4);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         5_u128..=u128::MAX => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 5_u128..=u128::MAX => todo!() }\n+   |                                +++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `0_u128` not covered\n   --> $DIR/exhaustiveness.rs:61:8\n@@ -137,9 +128,8 @@ LL |     m!(0u128, 1..=u128::MAX);\n    = note: the matched value is of type `u128`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         0_u128 => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, 0_u128 => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `(126_u8..=127_u8, false)` not covered\n   --> $DIR/exhaustiveness.rs:69:11"}, {"sha": "e3eb98ccdcda5db09855f90e47b628dcec81edf8", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.deny.stderr", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -39,9 +39,8 @@ LL |     m!(0usize, 0..=usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:24:8\n@@ -54,9 +53,8 @@ LL |     m!(0usize, 0..5 | 5..=usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:26:8\n@@ -69,9 +67,8 @@ LL |     m!(0usize, 0..usize::MAX | usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n   --> $DIR/pointer-sized-int.rs:28:8\n@@ -82,9 +79,8 @@ LL |     m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::\n    = note: the matched value is of type `(usize, bool)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         (_, _) => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, (_, _) => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:31:8\n@@ -97,9 +93,8 @@ LL |     m!(0isize, isize::MIN..=isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:33:8\n@@ -112,9 +107,8 @@ LL |     m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:35:8\n@@ -127,9 +121,8 @@ LL |     m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         _ => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, _ => todo!() }\n+   |                                ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n   --> $DIR/pointer-sized-int.rs:37:8\n@@ -140,9 +133,8 @@ LL |     m!((0isize, true), (isize::MIN..5, true)\n    = note: the matched value is of type `(isize, bool)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         match $s { $($t)+ => {}\n-LL ~         (_, _) => todo!() }\n-   |\n+LL |         match $s { $($t)+ => {}, (_, _) => todo!() }\n+   |                                +++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:41:11"}, {"sha": "89b4e06efdacd7c7afb34a730a817aae628ec1f3", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -12,8 +12,8 @@ LL | enum T { A, B }\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     match x { T::B => { } A => todo!() }\n-   |                           ++++++++++++\n+LL |     match x { T::B => { }, A => todo!() }\n+   |                          ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n   --> $DIR/non-exhaustive-match.rs:8:11"}, {"sha": "e2a65ff8524040062aefcaad59b284c07e11921a", "filename": "src/test/ui/pattern/usefulness/tuple-struct-nonexhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08871139915b95ec868aff807f224f78d00f4311/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr?ref=08871139915b95ec868aff807f224f78d00f4311", "patch": "@@ -12,7 +12,7 @@ LL | struct Foo(isize, isize);\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Foo(2, b) => println!(\"{}\", b)\n+LL ~         Foo(2, b) => println!(\"{}\", b),\n LL +         Foo(_, _) => todo!()\n    |\n "}]}