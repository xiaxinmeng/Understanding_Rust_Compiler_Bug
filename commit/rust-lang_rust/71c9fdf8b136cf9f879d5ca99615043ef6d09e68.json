{"sha": "71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYzlmZGY4YjEzNmNmOWY4NzlkNWNhOTk2MTUwNDNlZjZkMDllNjg=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-08T20:38:00Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:13:32Z"}, "message": "Refactor check_for_loop_range into its module", "tree": {"sha": "516016cb77977c54c9251bc7aaec6cdce7a8d8e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/516016cb77977c54c9251bc7aaec6cdce7a8d8e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "html_url": "https://github.com/rust-lang/rust/commit/71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71c9fdf8b136cf9f879d5ca99615043ef6d09e68/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e4663dedf92f871471cc240069d270b65a8160b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4663dedf92f871471cc240069d270b65a8160b", "html_url": "https://github.com/rust-lang/rust/commit/6e4663dedf92f871471cc240069d270b65a8160b"}], "stats": {"total": 777, "additions": 396, "deletions": 381}, "files": [{"sha": "43560abb7f2db0930a4ca798d6a1cb2c632027b0", "filename": "clippy_lints/src/loops/for_loop_range.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/71c9fdf8b136cf9f879d5ca99615043ef6d09e68/clippy_lints%2Fsrc%2Floops%2Ffor_loop_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c9fdf8b136cf9f879d5ca99615043ef6d09e68/clippy_lints%2Fsrc%2Floops%2Ffor_loop_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loop_range.rs?ref=71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "patch": "@@ -0,0 +1,390 @@\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{\n+    contains_name, has_iter_method, higher, is_integer_const, match_trait_method, multispan_sugg, path_to_local_id,\n+    paths, snippet, span_lint_and_then, sugg, SpanlessEq,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::middle::region;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Symbol};\n+use std::iter::Iterator;\n+use std::mem;\n+\n+/// Checks for looping over a range and then indexing a sequence with it.\n+/// The iteratee must be a range literal.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check_for_loop_range<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n+            let mut visitor = VarVisitor {\n+                cx,\n+                var: canonical_id,\n+                indexed_mut: FxHashSet::default(),\n+                indexed_indirectly: FxHashMap::default(),\n+                indexed_directly: FxHashMap::default(),\n+                referenced: FxHashSet::default(),\n+                nonindex: false,\n+                prefer_mutable: false,\n+            };\n+            walk_expr(&mut visitor, body);\n+\n+            // linting condition: we only indexed one variable, and indexed it directly\n+            if visitor.indexed_indirectly.is_empty() && visitor.indexed_directly.len() == 1 {\n+                let (indexed, (indexed_extent, indexed_ty)) = visitor\n+                    .indexed_directly\n+                    .into_iter()\n+                    .next()\n+                    .expect(\"already checked that we have exactly 1 element\");\n+\n+                // ensure that the indexed variable was declared before the loop, see #601\n+                if let Some(indexed_extent) = indexed_extent {\n+                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n+                    let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n+                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n+                    if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n+                        return;\n+                    }\n+                }\n+\n+                // don't lint if the container that is indexed does not have .iter() method\n+                let has_iter = has_iter_method(cx, indexed_ty);\n+                if has_iter.is_none() {\n+                    return;\n+                }\n+\n+                // don't lint if the container that is indexed into is also used without\n+                // indexing\n+                if visitor.referenced.contains(&indexed) {\n+                    return;\n+                }\n+\n+                let starts_at_zero = is_integer_const(cx, start, 0);\n+\n+                let skip = if starts_at_zero {\n+                    String::new()\n+                } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, start) {\n+                    return;\n+                } else {\n+                    format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n+                };\n+\n+                let mut end_is_start_plus_val = false;\n+\n+                let take = if let Some(end) = *end {\n+                    let mut take_expr = end;\n+\n+                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n+                        if let BinOpKind::Add = op.node {\n+                            let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n+                            let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n+\n+                            if start_equal_left {\n+                                take_expr = right;\n+                            } else if start_equal_right {\n+                                take_expr = left;\n+                            }\n+\n+                            end_is_start_plus_val = start_equal_left | start_equal_right;\n+                        }\n+                    }\n+\n+                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n+                        String::new()\n+                    } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, take_expr) {\n+                        return;\n+                    } else {\n+                        match limits {\n+                            ast::RangeLimits::Closed => {\n+                                let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n+                                format!(\".take({})\", take_expr + sugg::ONE)\n+                            },\n+                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n+                        }\n+                    }\n+                } else {\n+                    String::new()\n+                };\n+\n+                let (ref_mut, method) = if visitor.indexed_mut.contains(&indexed) {\n+                    (\"mut \", \"iter_mut\")\n+                } else {\n+                    (\"\", \"iter\")\n+                };\n+\n+                let take_is_empty = take.is_empty();\n+                let mut method_1 = take;\n+                let mut method_2 = skip;\n+\n+                if end_is_start_plus_val {\n+                    mem::swap(&mut method_1, &mut method_2);\n+                }\n+\n+                if visitor.nonindex {\n+                    span_lint_and_then(\n+                        cx,\n+                        super::NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n+                        |diag| {\n+                            multispan_sugg(\n+                                diag,\n+                                \"consider using an iterator\",\n+                                vec![\n+                                    (pat.span, format!(\"({}, <item>)\", ident.name)),\n+                                    (\n+                                        arg.span,\n+                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                    ),\n+                                ],\n+                            );\n+                        },\n+                    );\n+                } else {\n+                    let repl = if starts_at_zero && take_is_empty {\n+                        format!(\"&{}{}\", ref_mut, indexed)\n+                    } else {\n+                        format!(\"{}.{}(){}{}\", indexed, method, method_1, method_2)\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        super::NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n+                        |diag| {\n+                            multispan_sugg(\n+                                diag,\n+                                \"consider using an iterator\",\n+                                vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n+                            );\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n+        if len_args.len() == 1;\n+        if method.ident.name == sym!(len);\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n+        if path.segments.len() == 1;\n+        if path.segments[0].ident.name == var;\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn is_end_eq_array_len<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    indexed_ty: Ty<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = end.kind;\n+        if let ast::LitKind::Int(end_int, _) = lit.node;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n+        if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n+        then {\n+            return match limits {\n+                ast::RangeLimits::Closed => end_int + 1 >= arr_len.into(),\n+                ast::RangeLimits::HalfOpen => end_int >= arr_len.into(),\n+            };\n+        }\n+    }\n+\n+    false\n+}\n+\n+struct VarVisitor<'a, 'tcx> {\n+    /// context reference\n+    cx: &'a LateContext<'tcx>,\n+    /// var name to look for as index\n+    var: HirId,\n+    /// indexed variables that are used mutably\n+    indexed_mut: FxHashSet<Symbol>,\n+    /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n+    indexed_indirectly: FxHashMap<Symbol, Option<region::Scope>>,\n+    /// subset of `indexed` of vars that are indexed directly: `v[i]`\n+    /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n+    indexed_directly: FxHashMap<Symbol, (Option<region::Scope>, Ty<'tcx>)>,\n+    /// Any names that are used outside an index operation.\n+    /// Used to detect things like `&mut vec` used together with `vec[i]`\n+    referenced: FxHashSet<Symbol>,\n+    /// has the loop variable been used in expressions other than the index of\n+    /// an index op?\n+    nonindex: bool,\n+    /// Whether we are inside the `$` in `&mut $` or `$ = foo` or `$.bar`, where bar\n+    /// takes `&mut self`\n+    prefer_mutable: bool,\n+}\n+\n+impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n+    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+        if_chain! {\n+            // the indexed container is referenced by a name\n+            if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n+            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n+            if seqvar.segments.len() == 1;\n+            then {\n+                let index_used_directly = path_to_local_id(idx, self.var);\n+                let indexed_indirectly = {\n+                    let mut used_visitor = LocalUsedVisitor::new(self.var);\n+                    walk_expr(&mut used_visitor, idx);\n+                    used_visitor.used\n+                };\n+\n+                if indexed_indirectly || index_used_directly {\n+                    if self.prefer_mutable {\n+                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                    }\n+                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n+                    match res {\n+                        Res::Local(hir_id) => {\n+                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                            if indexed_indirectly {\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                            }\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                                );\n+                            }\n+                            return false;  // no need to walk further *on the variable*\n+                        }\n+                        Res::Def(DefKind::Static | DefKind::Const, ..) => {\n+                            if indexed_indirectly {\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n+                            }\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                                );\n+                            }\n+                            return false;  // no need to walk further *on the variable*\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+        }\n+        true\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // a range index op\n+            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n+            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if !self.check(&args[1], &args[0], expr);\n+            then { return }\n+        }\n+\n+        if_chain! {\n+            // an index op\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n+            if !self.check(idx, seqexpr, expr);\n+            then { return }\n+        }\n+\n+        if_chain! {\n+            // directly using a variable\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind;\n+            if let Res::Local(local_id) = path.res;\n+            then {\n+                if local_id == self.var {\n+                    self.nonindex = true;\n+                } else {\n+                    // not the correct variable, but still a variable\n+                    self.referenced.insert(path.segments[0].ident.name);\n+                }\n+            }\n+        }\n+\n+        let old = self.prefer_mutable;\n+        match expr.kind {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                self.prefer_mutable = true;\n+                self.visit_expr(lhs);\n+                self.prefer_mutable = false;\n+                self.visit_expr(rhs);\n+            },\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, ref expr) => {\n+                if mutbl == Mutability::Mut {\n+                    self.prefer_mutable = true;\n+                }\n+                self.visit_expr(expr);\n+            },\n+            ExprKind::Call(ref f, args) => {\n+                self.visit_expr(f);\n+                for expr in args {\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n+                    self.prefer_mutable = false;\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n+                        if mutbl == Mutability::Mut {\n+                            self.prefer_mutable = true;\n+                        }\n+                    }\n+                    self.visit_expr(expr);\n+                }\n+            },\n+            ExprKind::MethodCall(_, _, args, _) => {\n+                let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n+                for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n+                    self.prefer_mutable = false;\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n+                        if mutbl == Mutability::Mut {\n+                            self.prefer_mutable = true;\n+                        }\n+                    }\n+                    self.visit_expr(expr);\n+                }\n+            },\n+            ExprKind::Closure(_, _, body_id, ..) => {\n+                let body = self.cx.tcx.hir().body(body_id);\n+                self.visit_expr(&body.value);\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+        self.prefer_mutable = old;\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "204f9f9b2551be706e3439ee3379945ef4453e29", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 6, "deletions": 381, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/71c9fdf8b136cf9f879d5ca99615043ef6d09e68/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c9fdf8b136cf9f879d5ca99615043ef6d09e68/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "patch": "@@ -1,19 +1,18 @@\n mod for_loop_arg;\n mod for_loop_over_map_kv;\n+mod for_loop_range;\n mod for_mut_range_bound;\n mod manual_flatten;\n mod utils;\n \n use crate::consts::constant;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::mutated_variables;\n-use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n-    contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n-    last_path_segment, match_trait_method, match_type, multispan_sugg, path_to_local, path_to_local_id, paths,\n-    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n+    get_enclosing_block, get_parent_expr, get_trait_def_id, higher, implements_trait, indent_of, is_in_panic_handler,\n+    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n+    match_type, path_to_local, path_to_local_id, paths, single_segment_path, snippet, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -28,13 +27,11 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use std::iter::{once, Iterator};\n-use std::mem;\n use utils::make_iterator_snippet;\n \n declare_clippy_lint! {\n@@ -859,7 +856,7 @@ fn check_for_loop<'tcx>(\n ) {\n     let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n     if !is_manual_memcpy_triggered {\n-        check_for_loop_range(cx, pat, arg, body, expr);\n+        for_loop_range::check_for_loop_range(cx, pat, arg, body, expr);\n         check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     }\n     for_loop_arg::check_for_loop_arg(cx, pat, arg, expr);\n@@ -1477,212 +1474,6 @@ fn detect_same_item_push<'tcx>(\n     }\n }\n \n-/// Checks for looping over a range and then indexing a sequence with it.\n-/// The iteratee must be a range literal.\n-#[allow(clippy::too_many_lines)]\n-fn check_for_loop_range<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    arg: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-    expr: &'tcx Expr<'_>,\n-) {\n-    if let Some(higher::Range {\n-        start: Some(start),\n-        ref end,\n-        limits,\n-    }) = higher::range(arg)\n-    {\n-        // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n-            let mut visitor = VarVisitor {\n-                cx,\n-                var: canonical_id,\n-                indexed_mut: FxHashSet::default(),\n-                indexed_indirectly: FxHashMap::default(),\n-                indexed_directly: FxHashMap::default(),\n-                referenced: FxHashSet::default(),\n-                nonindex: false,\n-                prefer_mutable: false,\n-            };\n-            walk_expr(&mut visitor, body);\n-\n-            // linting condition: we only indexed one variable, and indexed it directly\n-            if visitor.indexed_indirectly.is_empty() && visitor.indexed_directly.len() == 1 {\n-                let (indexed, (indexed_extent, indexed_ty)) = visitor\n-                    .indexed_directly\n-                    .into_iter()\n-                    .next()\n-                    .expect(\"already checked that we have exactly 1 element\");\n-\n-                // ensure that the indexed variable was declared before the loop, see #601\n-                if let Some(indexed_extent) = indexed_extent {\n-                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n-                    let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n-                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n-                    if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n-                        return;\n-                    }\n-                }\n-\n-                // don't lint if the container that is indexed does not have .iter() method\n-                let has_iter = has_iter_method(cx, indexed_ty);\n-                if has_iter.is_none() {\n-                    return;\n-                }\n-\n-                // don't lint if the container that is indexed into is also used without\n-                // indexing\n-                if visitor.referenced.contains(&indexed) {\n-                    return;\n-                }\n-\n-                let starts_at_zero = is_integer_const(cx, start, 0);\n-\n-                let skip = if starts_at_zero {\n-                    String::new()\n-                } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, start) {\n-                    return;\n-                } else {\n-                    format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n-                };\n-\n-                let mut end_is_start_plus_val = false;\n-\n-                let take = if let Some(end) = *end {\n-                    let mut take_expr = end;\n-\n-                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n-                        if let BinOpKind::Add = op.node {\n-                            let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n-                            let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n-\n-                            if start_equal_left {\n-                                take_expr = right;\n-                            } else if start_equal_right {\n-                                take_expr = left;\n-                            }\n-\n-                            end_is_start_plus_val = start_equal_left | start_equal_right;\n-                        }\n-                    }\n-\n-                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n-                        String::new()\n-                    } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, take_expr) {\n-                        return;\n-                    } else {\n-                        match limits {\n-                            ast::RangeLimits::Closed => {\n-                                let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n-                                format!(\".take({})\", take_expr + sugg::ONE)\n-                            },\n-                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n-                        }\n-                    }\n-                } else {\n-                    String::new()\n-                };\n-\n-                let (ref_mut, method) = if visitor.indexed_mut.contains(&indexed) {\n-                    (\"mut \", \"iter_mut\")\n-                } else {\n-                    (\"\", \"iter\")\n-                };\n-\n-                let take_is_empty = take.is_empty();\n-                let mut method_1 = take;\n-                let mut method_2 = skip;\n-\n-                if end_is_start_plus_val {\n-                    mem::swap(&mut method_1, &mut method_2);\n-                }\n-\n-                if visitor.nonindex {\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_RANGE_LOOP,\n-                        expr.span,\n-                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n-                        |diag| {\n-                            multispan_sugg(\n-                                diag,\n-                                \"consider using an iterator\",\n-                                vec![\n-                                    (pat.span, format!(\"({}, <item>)\", ident.name)),\n-                                    (\n-                                        arg.span,\n-                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n-                                    ),\n-                                ],\n-                            );\n-                        },\n-                    );\n-                } else {\n-                    let repl = if starts_at_zero && take_is_empty {\n-                        format!(\"&{}{}\", ref_mut, indexed)\n-                    } else {\n-                        format!(\"{}.{}(){}{}\", indexed, method, method_1, method_2)\n-                    };\n-\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_RANGE_LOOP,\n-                        expr.span,\n-                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n-                        |diag| {\n-                            multispan_sugg(\n-                                diag,\n-                                \"consider using an iterator\",\n-                                vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n-                            );\n-                        },\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n-        if len_args.len() == 1;\n-        if method.ident.name == sym!(len);\n-        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n-        if path.segments.len() == 1;\n-        if path.segments[0].ident.name == var;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn is_end_eq_array_len<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    end: &Expr<'_>,\n-    limits: ast::RangeLimits,\n-    indexed_ty: Ty<'tcx>,\n-) -> bool {\n-    if_chain! {\n-        if let ExprKind::Lit(ref lit) = end.kind;\n-        if let ast::LitKind::Int(end_int, _) = lit.node;\n-        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n-        if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n-        then {\n-            return match limits {\n-                ast::RangeLimits::Closed => end_int + 1 >= arr_len.into(),\n-                ast::RangeLimits::HalfOpen => end_int >= arr_len.into(),\n-            };\n-        }\n-    }\n-\n-    false\n-}\n-\n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n // at the start of the loop.\n@@ -1768,172 +1559,6 @@ fn check_for_single_element_loop<'tcx>(\n     }\n }\n \n-struct VarVisitor<'a, 'tcx> {\n-    /// context reference\n-    cx: &'a LateContext<'tcx>,\n-    /// var name to look for as index\n-    var: HirId,\n-    /// indexed variables that are used mutably\n-    indexed_mut: FxHashSet<Symbol>,\n-    /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n-    indexed_indirectly: FxHashMap<Symbol, Option<region::Scope>>,\n-    /// subset of `indexed` of vars that are indexed directly: `v[i]`\n-    /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n-    indexed_directly: FxHashMap<Symbol, (Option<region::Scope>, Ty<'tcx>)>,\n-    /// Any names that are used outside an index operation.\n-    /// Used to detect things like `&mut vec` used together with `vec[i]`\n-    referenced: FxHashSet<Symbol>,\n-    /// has the loop variable been used in expressions other than the index of\n-    /// an index op?\n-    nonindex: bool,\n-    /// Whether we are inside the `$` in `&mut $` or `$ = foo` or `$.bar`, where bar\n-    /// takes `&mut self`\n-    prefer_mutable: bool,\n-}\n-\n-impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n-    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n-        if_chain! {\n-            // the indexed container is referenced by a name\n-            if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n-            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n-            if seqvar.segments.len() == 1;\n-            then {\n-                let index_used_directly = path_to_local_id(idx, self.var);\n-                let indexed_indirectly = {\n-                    let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                    walk_expr(&mut used_visitor, idx);\n-                    used_visitor.used\n-                };\n-\n-                if indexed_indirectly || index_used_directly {\n-                    if self.prefer_mutable {\n-                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n-                    }\n-                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n-                    match res {\n-                        Res::Local(hir_id) => {\n-                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n-                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                            if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                            }\n-                            if index_used_directly {\n-                                self.indexed_directly.insert(\n-                                    seqvar.segments[0].ident.name,\n-                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n-                                );\n-                            }\n-                            return false;  // no need to walk further *on the variable*\n-                        }\n-                        Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                            if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                            }\n-                            if index_used_directly {\n-                                self.indexed_directly.insert(\n-                                    seqvar.segments[0].ident.name,\n-                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n-                                );\n-                            }\n-                            return false;  // no need to walk further *on the variable*\n-                        }\n-                        _ => (),\n-                    }\n-                }\n-            }\n-        }\n-        true\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            // a range index op\n-            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n-            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n-                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n-            if !self.check(&args[1], &args[0], expr);\n-            then { return }\n-        }\n-\n-        if_chain! {\n-            // an index op\n-            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n-            if !self.check(idx, seqexpr, expr);\n-            then { return }\n-        }\n-\n-        if_chain! {\n-            // directly using a variable\n-            if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind;\n-            if let Res::Local(local_id) = path.res;\n-            then {\n-                if local_id == self.var {\n-                    self.nonindex = true;\n-                } else {\n-                    // not the correct variable, but still a variable\n-                    self.referenced.insert(path.segments[0].ident.name);\n-                }\n-            }\n-        }\n-\n-        let old = self.prefer_mutable;\n-        match expr.kind {\n-            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs, _) => {\n-                self.prefer_mutable = true;\n-                self.visit_expr(lhs);\n-                self.prefer_mutable = false;\n-                self.visit_expr(rhs);\n-            },\n-            ExprKind::AddrOf(BorrowKind::Ref, mutbl, ref expr) => {\n-                if mutbl == Mutability::Mut {\n-                    self.prefer_mutable = true;\n-                }\n-                self.visit_expr(expr);\n-            },\n-            ExprKind::Call(ref f, args) => {\n-                self.visit_expr(f);\n-                for expr in args {\n-                    let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n-                    self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n-                        if mutbl == Mutability::Mut {\n-                            self.prefer_mutable = true;\n-                        }\n-                    }\n-                    self.visit_expr(expr);\n-                }\n-            },\n-            ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n-                    self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n-                        if mutbl == Mutability::Mut {\n-                            self.prefer_mutable = true;\n-                        }\n-                    }\n-                    self.visit_expr(expr);\n-                }\n-            },\n-            ExprKind::Closure(_, _, body_id, ..) => {\n-                let body = self.cx.tcx.hir().body(body_id);\n-                self.visit_expr(&body.value);\n-            },\n-            _ => walk_expr(self, expr),\n-        }\n-        self.prefer_mutable = old;\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n     let def_id = match path_to_local(expr) {\n         Some(id) => id,"}]}