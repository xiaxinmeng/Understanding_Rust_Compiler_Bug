{"sha": "c6247f74c72857de3619a080698237d58ff9e960", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MjQ3Zjc0YzcyODU3ZGUzNjE5YTA4MDY5ODIzN2Q1OGZmOWU5NjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-27T15:05:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-27T15:16:13Z"}, "message": "Basic injections", "tree": {"sha": "6c7053d80c08ba65266a86771e965ce572521c1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c7053d80c08ba65266a86771e965ce572521c1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6247f74c72857de3619a080698237d58ff9e960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6247f74c72857de3619a080698237d58ff9e960", "html_url": "https://github.com/rust-lang/rust/commit/c6247f74c72857de3619a080698237d58ff9e960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6247f74c72857de3619a080698237d58ff9e960/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ed7e751b627791722aa10187894ff6ecc7e5a96", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed7e751b627791722aa10187894ff6ecc7e5a96", "html_url": "https://github.com/rust-lang/rust/commit/8ed7e751b627791722aa10187894ff6ecc7e5a96"}], "stats": {"total": 143, "additions": 120, "deletions": 23}, "files": [{"sha": "087edcc922b2875d3e6d64fa65b0cc4207c89ebe", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=c6247f74c72857de3619a080698237d58ff9e960", "patch": "@@ -51,8 +51,8 @@ fn type_at(content: &str) -> String {\n     type_at_pos(&db, file_pos)\n }\n \n-fn infer(content: &str) -> String {\n-    infer_with_mismatches(content, false)\n+fn infer(ra_fixture: &str) -> String {\n+    infer_with_mismatches(ra_fixture, false)\n }\n \n fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {"}, {"sha": "2b35a380300ef59351de1e58249e463b649bc900", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=c6247f74c72857de3619a080698237d58ff9e960", "patch": "@@ -3,7 +3,7 @@ use hir::Semantics;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, ArgListOwner},\n-    match_ast, AstNode, SyntaxNode,\n+    match_ast, AstNode, SyntaxNode, SyntaxToken,\n };\n use test_utils::tested_by;\n \n@@ -16,7 +16,13 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let file = file.syntax();\n     let token = file.token_at_offset(position.offset).next()?;\n     let token = sema.descend_into_macros(token);\n+    call_info_for_token(&sema, token)\n+}\n \n+pub(crate) fn call_info_for_token(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<CallInfo> {\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&token.parent())?;\n \n@@ -27,21 +33,23 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n                     let fn_def = it.into();\n-                    (CallInfo::with_fn(db, fn_def), fn_def.has_self_param(db))\n+                    (CallInfo::with_fn(sema.db, fn_def), fn_def.has_self_param(sema.db))\n+                }\n+                hir::CallableDef::StructId(it) => {\n+                    (CallInfo::with_struct(sema.db, it.into())?, false)\n                 }\n-                hir::CallableDef::StructId(it) => (CallInfo::with_struct(db, it.into())?, false),\n                 hir::CallableDef::EnumVariantId(it) => {\n-                    (CallInfo::with_enum_variant(db, it.into())?, false)\n+                    (CallInfo::with_enum_variant(sema.db, it.into())?, false)\n                 }\n             }\n         }\n         FnCallNode::MethodCallExpr(method_call) => {\n             let function = sema.resolve_method_call(&method_call)?;\n-            (CallInfo::with_fn(db, function), function.has_self_param(db))\n+            (CallInfo::with_fn(sema.db, function), function.has_self_param(sema.db))\n         }\n         FnCallNode::MacroCallExpr(macro_call) => {\n             let macro_def = sema.resolve_macro_call(&macro_call)?;\n-            (CallInfo::with_macro(db, macro_def)?, false)\n+            (CallInfo::with_macro(sema.db, macro_def)?, false)\n         }\n     };\n \n@@ -61,7 +69,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n                 let num_args_at_callsite = arg_list.args().count();\n \n                 let arg_list_range = arg_list.syntax().text_range();\n-                if !arg_list_range.contains_inclusive(position.offset) {\n+                if !arg_list_range.contains_inclusive(token.text_range().start()) {\n                     tested_by!(call_info_bad_offset);\n                     return None;\n                 }\n@@ -70,7 +78,9 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n                     num_args_at_callsite,\n                     arg_list\n                         .args()\n-                        .take_while(|arg| arg.syntax().text_range().end() < position.offset)\n+                        .take_while(|arg| {\n+                            arg.syntax().text_range().end() < token.text_range().start()\n+                        })\n                         .count(),\n                 );\n \n@@ -100,7 +110,13 @@ impl FnCallNode {\n             match_ast! {\n                 match node {\n                     ast::CallExpr(it) => { Some(FnCallNode::CallExpr(it)) },\n-                    ast::MethodCallExpr(it) => { Some(FnCallNode::MethodCallExpr(it)) },\n+                    ast::MethodCallExpr(it) => {\n+                        let arg_list = it.arg_list()?;\n+                        if !syntax.text_range().is_subrange(&arg_list.syntax().text_range()) {\n+                            return None;\n+                        }\n+                        Some(FnCallNode::MethodCallExpr(it))\n+                    },\n                     ast::MacroCall(it) => { Some(FnCallNode::MacroCallExpr(it)) },\n                     _ => { None },\n                 }"}, {"sha": "f4cd6deb7747e2d05328565fa3f287a9b1918004", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=c6247f74c72857de3619a080698237d58ff9e960", "patch": "@@ -124,28 +124,28 @@ impl MockAnalysis {\n }\n \n /// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n-pub fn analysis_and_position(fixture: &str) -> (Analysis, FilePosition) {\n-    let (mock, position) = MockAnalysis::with_files_and_position(fixture);\n+pub fn analysis_and_position(ra_fixture: &str) -> (Analysis, FilePosition) {\n+    let (mock, position) = MockAnalysis::with_files_and_position(ra_fixture);\n     (mock.analysis(), position)\n }\n \n /// Creates analysis for a single file.\n-pub fn single_file(code: &str) -> (Analysis, FileId) {\n+pub fn single_file(ra_fixture: &str) -> (Analysis, FileId) {\n     let mut mock = MockAnalysis::new();\n-    let file_id = mock.add_file(\"/main.rs\", code);\n+    let file_id = mock.add_file(\"/main.rs\", ra_fixture);\n     (mock.analysis(), file_id)\n }\n \n /// Creates analysis for a single file, returns position marked with <|>.\n-pub fn single_file_with_position(code: &str) -> (Analysis, FilePosition) {\n+pub fn single_file_with_position(ra_fixture: &str) -> (Analysis, FilePosition) {\n     let mut mock = MockAnalysis::new();\n-    let pos = mock.add_file_with_position(\"/main.rs\", code);\n+    let pos = mock.add_file_with_position(\"/main.rs\", ra_fixture);\n     (mock.analysis(), pos)\n }\n \n /// Creates analysis for a single file, returns range marked with a pair of <|>.\n-pub fn single_file_with_range(code: &str) -> (Analysis, FileRange) {\n+pub fn single_file_with_range(ra_fixture: &str) -> (Analysis, FileRange) {\n     let mut mock = MockAnalysis::new();\n-    let pos = mock.add_file_with_range(\"/main.rs\", code);\n+    let pos = mock.add_file_with_range(\"/main.rs\", ra_fixture);\n     (mock.analysis(), pos)\n }"}, {"sha": "3a5cbee9b4de2296cae3f2b31554adaf9522cfdf", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=c6247f74c72857de3619a080698237d58ff9e960", "patch": "@@ -12,11 +12,12 @@ use ra_ide_db::{\n };\n use ra_prof::profile;\n use ra_syntax::{\n-    ast, AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxKind::*, TextRange, WalkEvent, T,\n+    ast, AstNode, AstToken, Direction, NodeOrToken, SyntaxElement, SyntaxKind::*, SyntaxToken,\n+    TextRange, WalkEvent, T,\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{references::classify_name_ref, FileId};\n+use crate::{call_info::call_info_for_token, references::classify_name_ref, Analysis, FileId};\n \n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n@@ -94,11 +95,12 @@ pub(crate) fn highlight(\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(_) => continue,\n         };\n+\n         let range = element.text_range();\n \n         let element_to_highlight = if current_macro_call.is_some() {\n             // Inside a macro -- expand it first\n-            let token = match element.into_token() {\n+            let token = match element.clone().into_token() {\n                 Some(it) if it.parent().kind() == TOKEN_TREE => it,\n                 _ => continue,\n             };\n@@ -110,9 +112,17 @@ pub(crate) fn highlight(\n                 _ => token.into(),\n             }\n         } else {\n-            element\n+            element.clone()\n         };\n \n+        if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n+            let expanded = element_to_highlight.as_token().unwrap().clone();\n+            if highlight_injection(&mut res, &sema, token, expanded).is_some() {\n+                eprintln!(\"res = {:?}\", res);\n+                continue;\n+            }\n+        }\n+\n         if let Some((highlight, binding_hash)) =\n             highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n         {\n@@ -281,3 +291,44 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n         _ => default,\n     }\n }\n+\n+fn highlight_injection(\n+    acc: &mut Vec<HighlightedRange>,\n+    sema: &Semantics<RootDatabase>,\n+    literal: ast::RawString,\n+    expanded: SyntaxToken,\n+) -> Option<()> {\n+    let call_info = call_info_for_token(&sema, expanded)?;\n+    let idx = call_info.active_parameter?;\n+    let name = call_info.signature.parameter_names.get(idx)?;\n+    if name != \"ra_fixture\" {\n+        return None;\n+    }\n+    let value = literal.value()?;\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n+\n+    if let Some(range) = literal.open_quote_text_range() {\n+        acc.push(HighlightedRange {\n+            range,\n+            highlight: HighlightTag::LiteralString.into(),\n+            binding_hash: None,\n+        })\n+    }\n+\n+    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n+        if let Some(r) = literal.map_range_up(h.range) {\n+            h.range = r;\n+            acc.push(h)\n+        }\n+    }\n+\n+    if let Some(range) = literal.close_quote_text_range() {\n+        acc.push(HighlightedRange {\n+            range,\n+            highlight: HighlightTag::LiteralString.into(),\n+            binding_hash: None,\n+        })\n+    }\n+\n+    Some(())\n+}"}, {"sha": "693b35feb0dd74c1371adc8483a08ada54d6d6ed", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6247f74c72857de3619a080698237d58ff9e960/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=c6247f74c72857de3619a080698237d58ff9e960", "patch": "@@ -171,6 +171,36 @@ impl RawString {\n         let inside_str = &text[start_of_inside..end_of_inside];\n         Some(inside_str.to_string())\n     }\n+\n+    pub fn open_quote_text_range(&self) -> Option<TextRange> {\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+\n+        let start = self.syntax().text_range().start();\n+        let len = usual_string_range.start() + TextUnit::of_char('\"');\n+        Some(TextRange::offset_len(start, len))\n+    }\n+\n+    pub fn close_quote_text_range(&self) -> Option<TextRange> {\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+\n+        let end = self.syntax().text_range().end();\n+        let len = TextUnit::of_str(text) - usual_string_range.end();\n+        Some(TextRange::from_to(end - len, end))\n+    }\n+\n+    pub fn map_range_up(&self, range: TextRange) -> Option<TextRange> {\n+        // FIXME: handle escapes here properly\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+        Some(\n+            range\n+                + self.syntax().text_range().start()\n+                + TextUnit::of_char('\"')\n+                + usual_string_range.start(),\n+        )\n+    }\n }\n \n fn find_usual_string_range(s: &str) -> Option<TextRange> {"}]}