{"sha": "ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZDUwYjljZGZhMzhiYzgwZjI0NDRkOTE3ZWVmNWEwMmMzOGMzMmY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T12:18:15Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T12:18:15Z"}, "message": "Make the various from_str functions return options\n\nSo that they can be used with user input without causing task\nfailures.\n\nCloses #1335", "tree": {"sha": "383a83ae49b7690a07d9b546e25b3b43a9adddbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/383a83ae49b7690a07d9b546e25b3b43a9adddbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "html_url": "https://github.com/rust-lang/rust/commit/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72373438d28eecfa565ad16bd84f800b8c8067c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/72373438d28eecfa565ad16bd84f800b8c8067c0", "html_url": "https://github.com/rust-lang/rust/commit/72373438d28eecfa565ad16bd84f800b8c8067c0"}], "stats": {"total": 518, "additions": 203, "deletions": 315}, "files": [{"sha": "06b0acdf4a14dad6e41dbdc048ef6e7cdfffb203", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -95,13 +95,8 @@ fn variant_enum_id(d: ebml::doc) -> ast::def_id {\n }\n \n fn variant_disr_val(d: ebml::doc) -> option<int> {\n-    alt ebml::maybe_get_doc(d, tag_disr_val) {\n-      some(val_doc) {\n-        let val_buf = ebml::doc_data(val_doc);\n-        let val = int::parse_buf(val_buf, 10u);\n-        ret some(val);\n-      }\n-      _ { ret none;}\n+    option::chain(ebml::maybe_get_doc(d, tag_disr_val)) {|val_doc|\n+        int::parse_buf(ebml::doc_data(val_doc), 10u)\n     }\n }\n "}, {"sha": "5d97777c0fb6efc25119a893370c35d09319e2da", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -390,8 +390,8 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     for b: u8 in crate_part { crate_part_vec += [b]; }\n     for b: u8 in def_part { def_part_vec += [b]; }\n \n-    let crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n-    let def_num = uint::parse_buf(def_part_vec, 10u) as int;\n+    let crate_num = option::get(uint::parse_buf(crate_part_vec, 10u)) as int;\n+    let def_num = option::get(uint::parse_buf(def_part_vec, 10u)) as int;\n     ret {crate: crate_num, node: def_num};\n }\n "}, {"sha": "b9d48cb5fb089d0ada57a4c90c8dcc8215343a97", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -301,7 +301,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_str(s) { const_str(s) }\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n-      lit_float(n, _) { const_float(float::from_str(n)) }\n+      lit_float(n, _) { const_float(option::get(float::from_str(n))) }\n       lit_nil { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }\n     }"}, {"sha": "113ca056ed40b07be2c8ec38613fddaf407b8340", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -174,8 +174,8 @@ fn scan_digits(rdr: reader, radix: uint) -> str {\n     while true {\n         let c = rdr.curr;\n         if c == '_' { rdr.bump(); cont; }\n-        alt char::maybe_digit(c) {\n-          some(d) if (d as uint) < radix {\n+        alt char::to_digit(c, radix) {\n+          some(d) {\n             str::push_char(rslt, c);\n             rdr.bump();\n           }\n@@ -229,7 +229,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         if str::len_bytes(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n-        let parsed = u64::from_str(num_str, base as u64);\n+        let parsed = option::get(u64::from_str(num_str, base as u64));\n         alt tp {\n           either::left(t) { ret token::LIT_INT(parsed as i64, t); }\n           either::right(t) { ret token::LIT_UINT(parsed, t); }\n@@ -276,7 +276,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         if str::len_bytes(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n-        let parsed = u64::from_str(num_str, base as u64);\n+        let parsed = option::get(u64::from_str(num_str, base as u64));\n         ret token::LIT_INT(parsed as i64, ast::ty_i);\n     }\n }"}, {"sha": "63a38e7846ad2db14e4af76e3599168cfde3a90f", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -59,11 +59,11 @@ pure fn is_false(v: t) -> bool { !v }\n #[doc(\n   brief = \"Parse logic value from `s`\"\n )]\n-pure fn from_str(s: str) -> t {\n+pure fn from_str(s: str) -> option<t> {\n     alt check s {\n-      \"true\" { true }\n-      \"false\" { false }\n-      _ { fail \"'\" + s + \"' is not a valid boolean string\"; }\n+      \"true\" { some(true) }\n+      \"false\" { some(false) }\n+      _ { none }\n     }\n }\n \n@@ -89,7 +89,7 @@ pure fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n #[test]\n fn test_bool_from_str() {\n     all_values { |v|\n-        assert v == from_str(bool::to_str(v))\n+        assert some(v) == from_str(bool::to_str(v))\n     }\n }\n "}, {"sha": "123d739ba2c5cbde0b990e0f323b13531c13b8f3", "filename": "src/libcore/char.rs", "status": "modified", "additions": 25, "deletions": 44, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -38,7 +38,7 @@ export is_alphabetic,\n        is_lowercase, is_uppercase,\n        is_whitespace, is_alphanumeric,\n        is_ascii, is_digit,\n-       to_digit, to_lower, to_upper, maybe_digit, cmp;\n+       to_digit, to_lower, to_upper, cmp;\n \n import is_alphabetic = unicode::derived_property::Alphabetic;\n import is_XID_start = unicode::derived_property::XID_Start;\n@@ -102,26 +102,18 @@ pure fn is_digit(c: char) -> bool {\n            Safety note: This function fails if `c` is not a valid char\",\n   return = \"If `c` is between '0' and '9', the corresponding value \\\n             between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is \\\n-            'b' or 'B', 11, etc.\"\n+            'b' or 'B', 11, etc. Returns none if the char does not \\\n+            refer to a digit in the given radix.\"\n )]\n-pure fn to_digit(c: char) -> u8 unsafe {\n-    alt maybe_digit(c) {\n-      option::some(x) { x }\n-      option::none { fail; }\n-    }\n-}\n-\n-#[doc(\n-  brief = \"Convert a char to the corresponding digit. Returns none when \\\n-           character is not a valid hexadecimal digit.\"\n-)]\n-pure fn maybe_digit(c: char) -> option<u8> {\n-    alt c {\n-      '0' to '9' { option::some(c as u8 - ('0' as u8)) }\n-      'a' to 'z' { option::some(c as u8 + 10u8 - ('a' as u8)) }\n-      'A' to 'Z' { option::some(c as u8 + 10u8 - ('A' as u8)) }\n-      _ { option::none }\n-    }\n+pure fn to_digit(c: char, radix: uint) -> option<uint> {\n+    let val = alt c {\n+      '0' to '9' { c as uint - ('0' as uint) }\n+      'a' to 'z' { c as uint + 10u - ('a' as uint) }\n+      'A' to 'Z' { c as uint + 10u - ('A' as uint) }\n+      _ { ret none; }\n+    };\n+    if val < radix { some(val) }\n+    else { none }\n }\n \n /*\n@@ -192,30 +184,19 @@ fn test_is_whitespace() {\n \n #[test]\n fn test_to_digit() {\n-    assert (to_digit('0') == 0u8);\n-    assert (to_digit('1') == 1u8);\n-    assert (to_digit('2') == 2u8);\n-    assert (to_digit('9') == 9u8);\n-    assert (to_digit('a') == 10u8);\n-    assert (to_digit('A') == 10u8);\n-    assert (to_digit('b') == 11u8);\n-    assert (to_digit('B') == 11u8);\n-    assert (to_digit('z') == 35u8);\n-    assert (to_digit('Z') == 35u8);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_to_digit_fail_1() {\n-    to_digit(' ');\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_to_digit_fail_2() {\n-    to_digit('$');\n+    assert to_digit('0', 10u) == some(0u);\n+    assert to_digit('1', 2u) == some(1u);\n+    assert to_digit('2', 3u) == some(2u);\n+    assert to_digit('9', 10u) == some(9u);\n+    assert to_digit('a', 16u) == some(10u);\n+    assert to_digit('A', 16u) == some(10u);\n+    assert to_digit('b', 16u) == some(11u);\n+    assert to_digit('B', 16u) == some(11u);\n+    assert to_digit('z', 36u) == some(35u);\n+    assert to_digit('Z', 36u) == some(35u);\n+\n+    assert to_digit(' ', 10u) == none;\n+    assert to_digit('$', 36u) == none;\n }\n \n #[test]"}, {"sha": "b21d154097fafc520238f73fa53c187fc838b6e4", "filename": "src/libcore/float.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -122,28 +122,27 @@ Leading and trailing whitespace are ignored.\n \n Parameters:\n \n-num - A string, possibly empty.\n+num - A string\n \n Returns:\n \n-<NaN> If the string did not represent a valid number.\n-Otherwise, the floating-point number represented [num].\n+none if the string did not represent a valid number.\n+Otherwise, some(n) where n is the floating-point\n+number represented by [num].\n */\n-fn from_str(num: str) -> float {\n-   let num = str::trim(num);\n-\n+fn from_str(num: str) -> option<float> {\n    let pos = 0u;                  //Current byte position in the string.\n                                   //Used to walk the string in O(n).\n    let len = str::len_bytes(num);  //Length of the string, in bytes.\n \n-   if len == 0u { ret 0.; }\n+   if len == 0u { ret none; }\n    let total = 0f;                //Accumulated result\n    let c     = 'z';               //Latest char.\n \n    //The string must start with one of the following characters.\n    alt str::char_at(num, 0u) {\n       '-' | '+' | '0' to '9' | '.' {}\n-      _ { ret NaN; }\n+      _ { ret none; }\n    }\n \n    //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n@@ -173,7 +172,7 @@ fn from_str(num: str) -> float {\n            break;\n          }\n          _ {\n-           ret NaN;\n+           ret none;\n          }\n        }\n    }\n@@ -193,7 +192,7 @@ fn from_str(num: str) -> float {\n                  break;\n              }\n              _ {\n-                 ret NaN;\n+                 ret none;\n              }\n          }\n       }\n@@ -238,17 +237,17 @@ fn from_str(num: str) -> float {\n              total = total * multiplier;\n           }\n       } else {\n-         ret NaN;\n+         ret none;\n       }\n    }\n \n    if(pos < len) {\n-     ret NaN;\n+     ret none;\n    } else {\n      if(neg) {\n         total *= -1f;\n      }\n-     ret total;\n+     ret some(total);\n    }\n }\n \n@@ -291,39 +290,36 @@ fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n \n #[test]\n fn test_from_str() {\n-   assert ( from_str(\"3\") == 3. );\n-   assert ( from_str(\"  3  \") == 3. );\n-   assert ( from_str(\"3.14\") == 3.14 );\n-   assert ( from_str(\"+3.14\") == 3.14 );\n-   assert ( from_str(\"-3.14\") == -3.14 );\n-   assert ( from_str(\"2.5E10\") == 25000000000. );\n-   assert ( from_str(\"2.5e10\") == 25000000000. );\n-   assert ( from_str(\"25000000000.E-10\") == 2.5 );\n-   assert ( from_str(\"\") == 0. );\n-   assert ( from_str(\".\") == 0. );\n-   assert ( from_str(\".e1\") == 0. );\n-   assert ( from_str(\".e-1\") == 0. );\n-   assert ( from_str(\"5.\") == 5. );\n-   assert ( from_str(\".5\") == 0.5 );\n-   assert ( from_str(\"0.5\") == 0.5 );\n-   assert ( from_str(\"0.5 \") == 0.5 );\n-   assert ( from_str(\" 0.5 \") == 0.5 );\n-   assert ( from_str(\" -.5 \") == -0.5 );\n-   assert ( from_str(\" -.5 \") == -0.5 );\n-   assert ( from_str(\" -5 \") == -5. );\n-\n-   assert ( is_NaN(from_str(\"x\")) );\n-   assert ( from_str(\" \") == 0. );\n-   assert ( from_str(\"   \") == 0. );\n-   assert ( from_str(\" 0.5\") == 0.5 );\n-   assert ( from_str(\" 0.5 \") == 0.5 );\n-   assert ( from_str(\" .1 \") == 0.1 );\n-   assert ( is_NaN(from_str(\"e\")) );\n-   assert ( is_NaN(from_str(\"E\")) );\n-   assert ( is_NaN(from_str(\"E1\")) );\n-   assert ( is_NaN(from_str(\"1e1e1\")) );\n-   assert ( is_NaN(from_str(\"1e1.1\")) );\n-   assert ( is_NaN(from_str(\"1e1-1\")) );\n+   assert from_str(\"3\") == some(3.);\n+   assert from_str(\"3\") == some(3.);\n+   assert from_str(\"3.14\") == some(3.14);\n+   assert from_str(\"+3.14\") == some(3.14);\n+   assert from_str(\"-3.14\") == some(-3.14);\n+   assert from_str(\"2.5E10\") == some(25000000000.);\n+   assert from_str(\"2.5e10\") == some(25000000000.);\n+   assert from_str(\"25000000000.E-10\") == some(2.5);\n+   assert from_str(\".\") == some(0.);\n+   assert from_str(\".e1\") == some(0.);\n+   assert from_str(\".e-1\") == some(0.);\n+   assert from_str(\"5.\") == some(5.);\n+   assert from_str(\".5\") == some(0.5);\n+   assert from_str(\"0.5\") == some(0.5);\n+   assert from_str(\"0.5\") == some(0.5);\n+   assert from_str(\"0.5\") == some(0.5);\n+   assert from_str(\"-.5\") == some(-0.5);\n+   assert from_str(\"-.5\") == some(-0.5);\n+   assert from_str(\"-5\") == some(-5.);\n+\n+   assert from_str(\"\") == none;\n+   assert from_str(\"x\") == none;\n+   assert from_str(\" \") == none;\n+   assert from_str(\"   \") == none;\n+   assert from_str(\"e\") == none;\n+   assert from_str(\"E\") == none;\n+   assert from_str(\"E1\") == none;\n+   assert from_str(\"1e1e1\") == none;\n+   assert from_str(\"1e1.1\") == none;\n+   assert from_str(\"1e1-1\") == none;\n }\n \n #[test]"}, {"sha": "8567fc7ccc8fff0ec51338f60d5c41215c6ce6ec", "filename": "src/libcore/int.rs", "status": "modified", "additions": 42, "deletions": 76, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -103,17 +103,10 @@ Parameters:\n \n buf - A byte buffer\n radix - The base of the number\n-\n-Failure:\n-\n-buf must not be empty\n */\n-fn parse_buf(buf: [u8], radix: uint) -> int {\n-    if vec::len::<u8>(buf) == 0u {\n-        #error(\"parse_buf(): buf is empty\");\n-        fail;\n-    }\n-    let i = vec::len::<u8>(buf) - 1u;\n+fn parse_buf(buf: [u8], radix: uint) -> option<int> {\n+    if vec::len(buf) == 0u { ret none; }\n+    let i = vec::len(buf) - 1u;\n     let start = 0u;\n     let power = 1;\n \n@@ -123,13 +116,12 @@ fn parse_buf(buf: [u8], radix: uint) -> int {\n     }\n     let n = 0;\n     while true {\n-        let digit = char::to_digit(buf[i] as char);\n-        if (digit as uint) >= radix {\n-            fail;\n+        alt char::to_digit(buf[i] as char, radix) {\n+          some(d) { n += (d as int) * power; }\n+          none { ret none; }\n         }\n-        n += (digit as int) * power;\n         power *= radix as int;\n-        if i <= start { ret n; }\n+        if i <= start { ret some(n); }\n         i -= 1u;\n     }\n     fail;\n@@ -139,12 +131,8 @@ fn parse_buf(buf: [u8], radix: uint) -> int {\n Function: from_str\n \n Parse a string to an int\n-\n-Failure:\n-\n-s must not be empty\n */\n-fn from_str(s: str) -> int { parse_buf(str::bytes(s), 10u) }\n+fn from_str(s: str) -> option<int> { parse_buf(str::bytes(s), 10u) }\n \n /*\n Function: to_str\n@@ -198,67 +186,45 @@ fn abs(i: int) -> int {\n \n #[test]\n fn test_from_str() {\n-    assert(from_str(\"0\") == 0);\n-    assert(from_str(\"3\") == 3);\n-    assert(from_str(\"10\") == 10);\n-    assert(from_str(\"123456789\") == 123456789);\n-    assert(from_str(\"00100\") == 100);\n-\n-    assert(from_str(\"-1\") == -1);\n-    assert(from_str(\"-3\") == -3);\n-    assert(from_str(\"-10\") == -10);\n-    assert(from_str(\"-123456789\") == -123456789);\n-    assert(from_str(\"-00100\") == -100);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_from_str_fail_1() {\n-    from_str(\" \");\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_from_str_fail_2() {\n-    from_str(\"x\");\n+    assert from_str(\"0\") == some(0);\n+    assert from_str(\"3\") == some(3);\n+    assert from_str(\"10\") == some(10);\n+    assert from_str(\"123456789\") == some(123456789);\n+    assert from_str(\"00100\") == some(100);\n+\n+    assert from_str(\"-1\") == some(-1);\n+    assert from_str(\"-3\") == some(-3);\n+    assert from_str(\"-10\") == some(-10);\n+    assert from_str(\"-123456789\") == some(-123456789);\n+    assert from_str(\"-00100\") == some(-100);\n+\n+    assert from_str(\" \") == none;\n+    assert from_str(\"x\") == none;\n }\n \n #[test]\n fn test_parse_buf() {\n     import str::bytes;\n-    assert (parse_buf(bytes(\"123\"), 10u) == 123);\n-    assert (parse_buf(bytes(\"1001\"), 2u) == 9);\n-    assert (parse_buf(bytes(\"123\"), 8u) == 83);\n-    assert (parse_buf(bytes(\"123\"), 16u) == 291);\n-    assert (parse_buf(bytes(\"ffff\"), 16u) == 65535);\n-    assert (parse_buf(bytes(\"FFFF\"), 16u) == 65535);\n-    assert (parse_buf(bytes(\"z\"), 36u) == 35);\n-    assert (parse_buf(bytes(\"Z\"), 36u) == 35);\n-\n-    assert (parse_buf(bytes(\"-123\"), 10u) == -123);\n-    assert (parse_buf(bytes(\"-1001\"), 2u) == -9);\n-    assert (parse_buf(bytes(\"-123\"), 8u) == -83);\n-    assert (parse_buf(bytes(\"-123\"), 16u) == -291);\n-    assert (parse_buf(bytes(\"-ffff\"), 16u) == -65535);\n-    assert (parse_buf(bytes(\"-FFFF\"), 16u) == -65535);\n-    assert (parse_buf(bytes(\"-z\"), 36u) == -35);\n-    assert (parse_buf(bytes(\"-Z\"), 36u) == -35);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_parse_buf_fail_1() {\n-    parse_buf(str::bytes(\"Z\"), 35u);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_parse_buf_fail_2() {\n-    parse_buf(str::bytes(\"-9\"), 2u);\n+    assert parse_buf(bytes(\"123\"), 10u) == some(123);\n+    assert parse_buf(bytes(\"1001\"), 2u) == some(9);\n+    assert parse_buf(bytes(\"123\"), 8u) == some(83);\n+    assert parse_buf(bytes(\"123\"), 16u) == some(291);\n+    assert parse_buf(bytes(\"ffff\"), 16u) == some(65535);\n+    assert parse_buf(bytes(\"FFFF\"), 16u) == some(65535);\n+    assert parse_buf(bytes(\"z\"), 36u) == some(35);\n+    assert parse_buf(bytes(\"Z\"), 36u) == some(35);\n+\n+    assert parse_buf(bytes(\"-123\"), 10u) == some(-123);\n+    assert parse_buf(bytes(\"-1001\"), 2u) == some(-9);\n+    assert parse_buf(bytes(\"-123\"), 8u) == some(-83);\n+    assert parse_buf(bytes(\"-123\"), 16u) == some(-291);\n+    assert parse_buf(bytes(\"-ffff\"), 16u) == some(-65535);\n+    assert parse_buf(bytes(\"-FFFF\"), 16u) == some(-65535);\n+    assert parse_buf(bytes(\"-z\"), 36u) == some(-35);\n+    assert parse_buf(bytes(\"-Z\"), 36u) == some(-35);\n+\n+    assert parse_buf(str::bytes(\"Z\"), 35u) == none;\n+    assert parse_buf(str::bytes(\"-9\"), 2u) == none;\n }\n \n #[test]"}, {"sha": "844219754255855110389c7223b939c88ce5d6f2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -40,6 +40,16 @@ fn map<T, U: copy>(opt: t<T>, f: fn(T) -> U) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none { none } }\n }\n \n+/*\n+Function: chain\n+\n+Update an optional value by optionally running its content through a function\n+that returns an option.\n+*/\n+fn chain<T, U>(opt: t<T>, f: fn(T) -> t<U>) -> t<U> {\n+    alt opt { some(x) { f(x) } none { none } }\n+}\n+\n /*\n Function: is_none\n "}, {"sha": "9edf4dd03c739666bd3e19c2bccd0e08326da016", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -117,19 +117,17 @@ Function: from_str\n \n Parse a string as an unsigned integer.\n */\n-fn from_str(buf: str, radix: u64) -> u64 {\n-    if str::len_bytes(buf) == 0u {\n-        #error(\"parse_buf(): buf is empty\");\n-        fail;\n-    }\n+fn from_str(buf: str, radix: u64) -> option<u64> {\n+    if str::len_bytes(buf) == 0u { ret none; }\n     let i = str::len_bytes(buf) - 1u;\n     let power = 1u64, n = 0u64;\n     while true {\n-        let digit = char::to_digit(buf[i] as char) as u64;\n-        if digit >= radix { fail; }\n-        n += digit * power;\n+        alt char::to_digit(buf[i] as char, radix) {\n+          some(d) { n += d as u64 * power; }\n+          none { ret none; }\n+        }\n         power *= radix;\n-        if i == 0u { ret n; }\n+        if i == 0u { ret some(n); }\n         i -= 1u;\n     }\n     fail;"}, {"sha": "b5e425d2b1de5e6dd00b89f6641573e4b07703aa", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -188,22 +188,18 @@ Failure:\n \n buf must not be empty\n */\n-fn parse_buf(buf: [u8], radix: uint) -> uint {\n-    if vec::len::<u8>(buf) == 0u {\n-        #error(\"parse_buf(): buf is empty\");\n-        fail;\n-    }\n-    let i = vec::len::<u8>(buf) - 1u;\n+fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n+    if vec::len(buf) == 0u { ret none; }\n+    let i = vec::len(buf) - 1u;\n     let power = 1u;\n     let n = 0u;\n     while true {\n-        let digit = char::to_digit(buf[i] as char);\n-        if (digit as uint) >= radix {\n-            fail;\n+        alt char::to_digit(buf[i] as char, radix) {\n+          some(d) { n += d * power; }\n+          none { ret none; }\n         }\n-        n += (digit as uint) * power;\n         power *= radix;\n-        if i == 0u { ret n; }\n+        if i == 0u { ret some(n); }\n         i -= 1u;\n     }\n     fail;\n@@ -213,12 +209,8 @@ fn parse_buf(buf: [u8], radix: uint) -> uint {\n Function: from_str\n \n Parse a string to an int\n-\n-Failure:\n-\n-s must not be empty\n */\n-fn from_str(s: str) -> uint { parse_buf(str::bytes(s), 10u) }\n+fn from_str(s: str) -> option<uint> { parse_buf(str::bytes(s), 10u) }\n \n /*\n Function: to_str\n@@ -282,50 +274,29 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-        assert (uint::from_str(\"0\") == 0u);\n-        assert (uint::from_str(\"3\") == 3u);\n-        assert (uint::from_str(\"10\") == 10u);\n-        assert (uint::from_str(\"123456789\") == 123456789u);\n-        assert (uint::from_str(\"00100\") == 100u);\n+        assert uint::from_str(\"0\") == some(0u);\n+        assert uint::from_str(\"3\") == some(3u);\n+        assert uint::from_str(\"10\") == some(10u);\n+        assert uint::from_str(\"123456789\") == some(123456789u);\n+        assert uint::from_str(\"00100\") == some(100u);\n+\n+        assert uint::from_str(\"\") == none;\n+        assert uint::from_str(\" \") == none;\n+        assert uint::from_str(\"x\") == none;\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_from_str_fail_1() {\n-        uint::from_str(\" \");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_from_str_fail_2() {\n-        uint::from_str(\"x\");\n-    }\n-\n-    #[test]\n+    #[Test]\n     fn test_parse_buf() {\n         import str::bytes;\n-        assert (uint::parse_buf(bytes(\"123\"), 10u) == 123u);\n-        assert (uint::parse_buf(bytes(\"1001\"), 2u) == 9u);\n-        assert (uint::parse_buf(bytes(\"123\"), 8u) == 83u);\n-        assert (uint::parse_buf(bytes(\"123\"), 16u) == 291u);\n-        assert (uint::parse_buf(bytes(\"ffff\"), 16u) == 65535u);\n-        assert (uint::parse_buf(bytes(\"z\"), 36u) == 35u);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_parse_buf_fail_1() {\n-        uint::parse_buf(str::bytes(\"Z\"), 10u);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_parse_buf_fail_2() {\n-        uint::parse_buf(str::bytes(\"_\"), 2u);\n+        assert uint::parse_buf(bytes(\"123\"), 10u) == some(123u);\n+        assert uint::parse_buf(bytes(\"1001\"), 2u) == some(9u);\n+        assert uint::parse_buf(bytes(\"123\"), 8u) == some(83u);\n+        assert uint::parse_buf(bytes(\"123\"), 16u) == some(291u);\n+        assert uint::parse_buf(bytes(\"ffff\"), 16u) == some(65535u);\n+        assert uint::parse_buf(bytes(\"z\"), 36u) == some(35u);\n+\n+        assert uint::parse_buf(str::bytes(\"Z\"), 10u) == none;\n+        assert uint::parse_buf(str::bytes(\"_\"), 2u) == none;\n     }\n \n     #[test]"}, {"sha": "2325598a2d3766aeb0bb338a31ffde298c2d7d56", "filename": "src/libstd/net.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -49,10 +49,13 @@ Failure:\n String must be a valid IPv4 address\n */\n fn parse_addr(ip: str) -> ip_addr {\n-    let parts = vec::map(str::split_byte(ip, \".\"[0]),\n-                         {|s| uint::from_str(s) });\n+    let parts = vec::map(str::split_byte(ip, \".\"[0]), {|s|\n+        alt uint::from_str(s) {\n+          some(n) if n <= 255u { n }\n+          _ { fail \"Invalid IP Address part.\" }\n+        }\n+    });\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n-    for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)\n }\n "}, {"sha": "36a974002a21f5a3d981f76322a0e4b9e07161e0", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -33,8 +33,8 @@ fn run(args: [str]) {\n     let to_child = task::spawn_listener {|po|\n         server(po, to_parent);\n     };\n-    let size = uint::from_str(args[1]);\n-    let workers = uint::from_str(args[2]);\n+    let size = option::get(uint::from_str(args[1]));\n+    let workers = option::get(uint::from_str(args[2]));\n     let start = std::time::precise_time_s();\n     let to_child = to_child;\n     let worker_results = [];"}, {"sha": "92a6a18230811517ad9af45b262042437531267b", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -14,7 +14,7 @@ fn ack(m: int, n: int) -> int {\n \n fn main(args: [str]) {\n     let n = if vec::len(args) == 2u {\n-        int::from_str(args[1])\n+        option::get(int::from_str(args[1]))\n     } else {\n         8\n     };"}, {"sha": "3054e364dd305ab128219d7f877c8e88dba18204", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -1,5 +1,4 @@\n use std;\n-import int;\n \n enum tree { nil, node(~tree, ~tree, int), }\n \n@@ -21,7 +20,7 @@ fn bottom_up_tree(item: int, depth: int) -> ~tree {\n \n fn main(args: [str]) {\n     let n = if vec::len(args) == 2u {\n-        int::from_str(args[1])\n+        option::get(int::from_str(args[1]))\n     } else {\n         8\n     };"}, {"sha": "26ed2fcf0a4acc8d02e63cf2c9b30cfd757047bb", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -60,7 +60,7 @@ fn fannkuch(n: int) -> int {\n \n fn main(args: [str]) {\n     let n = if vec::len(args) == 2u {\n-        int::from_str(args[1])\n+        option::get(int::from_str(args[1]))\n     } else {\n         8\n     };"}, {"sha": "2868cb0f667a0196559f571df973bc971ab40791", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -10,7 +10,7 @@ fn fib(n: int) -> int {\n \n fn main(args: [str]) {\n     let n = if vec::len(args) == 2u {\n-        int::from_str(args[1])\n+        option::get(int::from_str(args[1]))\n     } else {\n         30\n     };"}, {"sha": "984e8d78a18afd2ba2f6de27fd920b83a7e082f4", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -136,36 +136,21 @@ fn writer(path: str, writech: comm::chan<comm::chan<line>>, size: uint)\n     }\n }\n \n-fn main(argv: [str])\n-{\n-    let size = if vec::len(argv) < 2_u {\n-        80u\n-    }\n-    else {\n-        uint::from_str(argv[1])\n-    };\n-    let yieldevery = if vec::len(argv) < 3_u {\n-        10_u\n-    }\n-    else {\n-        uint::from_str(argv[2])\n-    };\n-    let path = if vec::len(argv) < 4_u {\n-        \"\"\n-    }\n-    else {\n-        argv[3]\n-    };\n+fn main(argv: [str]) {\n+    let size = if vec::len(argv) < 2_u { 80u }\n+    else { option::get(uint::from_str(argv[1])) };\n+    let yieldevery = if vec::len(argv) < 3_u { 10_u }\n+    else { option::get(uint::from_str(argv[2])) };\n+    let path = if vec::len(argv) < 4_u { \"\" }\n+    else { argv[3] };\n     let writep = comm::port();\n     let writech = comm::chan(writep);\n-    task::spawn {\n-        || writer(path, writech, size);\n+    task::spawn {||\n+        writer(path, writech, size);\n     };\n     let ch = comm::recv(writep);\n-    uint::range(0_u, size) {\n-        |j| task::spawn {\n-            || chanmb(j, size, ch);\n-        };\n+    uint::range(0_u, size) {|j|\n+        task::spawn {|| chanmb(j, size, ch);};\n         if j % yieldevery == 0_u {\n             #debug(\"Y %u\", j);\n             task::yield();"}, {"sha": "ac0f47f520e2cba97aac8e4029900a4d0641fb69", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -15,7 +15,7 @@ native mod libc {\n \n fn main(args: [str]) {\n     let n = if vec::len(args) == 2u {\n-        int::from_str(args[1])\n+        option::get(int::from_str(args[1]))\n     } else {\n         100000\n     };"}, {"sha": "8105b019de4780ad74cb39c4eade82b0f777e467", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -90,7 +90,8 @@ fn main(argv: [str]) {\n         if opts.stress {\n             stress(2);\n         } else {\n-            let max = uint::parse_buf(str::bytes(argv[1]), 10u) as int;\n+            let max = option::get(uint::parse_buf(str::bytes(argv[1]),\n+                                                  10u)) as int;\n \n             let num_trials = 10;\n "}, {"sha": "6c475985d49b958a8f844aa76171ff12a78806c1", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -43,7 +43,7 @@ fn eval_AtA_times_u(u: [const float], AtAu: [mutable float]) {\n fn main(args: [str]) {\n \n     let N = if vec::len(args) == 2u {\n-        uint::from_str(args[1])\n+        option::get(uint::from_str(args[1]))\n     } else {\n         1000u\n     };"}, {"sha": "539567a28eecb1b7ae5f7349b536b862c00f1a12", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -38,11 +38,8 @@ fn roundtrip(id: int, p: comm::port<int>, ch: comm::chan<int>) {\n }\n \n fn main(args: [str]) {\n-    let token = if vec::len(args) < 2u {\n-        1000\n-    } else {\n-        int::from_str(args[1])\n-    };\n+    let token = if vec::len(args) < 2u { 1000 }\n+                else { option::get(int::from_str(args[1])) };\n \n     start(token);\n }\n\\ No newline at end of file"}, {"sha": "9b02ee0a49fcdc4552429daca5a1b132350880a0", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -35,9 +35,9 @@ fn read_grid(f: io::reader) -> grid_t {\n     while !f.eof() {\n         let comps = str::split_byte(str::trim(f.read_line()), ',' as u8);\n         if vec::len(comps) >= 3u {\n-            let row     = uint::from_str(comps[0]) as u8;\n-            let col     = uint::from_str(comps[1]) as u8;\n-            g[row][col] = uint::from_str(comps[2]) as u8;\n+            let row     = option::get(uint::from_str(comps[0])) as u8;\n+            let col     = option::get(uint::from_str(comps[1])) as u8;\n+            g[row][col] = option::get(uint::from_str(comps[2])) as u8;\n         }\n     }\n     ret grid_ctor(g);"}, {"sha": "bf74f736a83035db55cc5071089ff7de01fddb17", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -47,7 +47,7 @@ fn calc(children: uint, parent_ch: comm::chan<msg>) {\n \n fn main(args: [str]) {\n     let children = if vec::len(args) == 2u {\n-        uint::from_str(args[1])\n+        option::get(uint::from_str(args[1]))\n     } else {\n         100u\n     };"}, {"sha": "de81e0263d5fb02cf827c5b6474ea99eb971bc9a", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -1,9 +1,3 @@\n-use std;\n-import vec;\n-import task;\n-import uint;\n-import str;\n-\n fn f(&&n: uint) {\n     let i = 0u;\n     while i < n {\n@@ -18,7 +12,7 @@ fn main(args: [str]) {\n     let n =\n         if vec::len(args) < 2u {\n             10u\n-        } else { uint::parse_buf(str::bytes(args[1]), 10u) };\n+        } else { option::get(uint::parse_buf(str::bytes(args[1]), 10u)) };\n     let i = 0u;\n     while i < n { task::spawn {|| f(n); }; i += 1u; }\n }"}, {"sha": "0b24596da643b0d6ccb4301a261a43ff0c8d67ac", "filename": "src/test/bench/task-perf-vector-party.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd50b9cdfa38bc80f2444d917eef5a02c38c32f/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs?ref=ffd50b9cdfa38bc80f2444d917eef5a02c38c32f", "patch": "@@ -3,12 +3,6 @@\n // that synchronization by spawning a number of tasks and then\n // allocating and freeing vectors.\n \n-use std;\n-import vec;\n-import uint;\n-import str;\n-import task;\n-\n fn f(&&n: uint) {\n     uint::range(0u, n) {|i|\n         let v: [u8] = [];\n@@ -17,9 +11,7 @@ fn f(&&n: uint) {\n }\n \n fn main(args: [str]) {\n-    let n =\n-        if vec::len(args) < 2u {\n-            100u\n-        } else { uint::parse_buf(str::bytes(args[1]), 10u) };\n+    let n = if vec::len(args) < 2u { 100u }\n+            else { option::get(uint::from_str(args[1])) };\n     uint::range(0u, 100u) {|i| task::spawn {|| f(n); };}\n }"}]}