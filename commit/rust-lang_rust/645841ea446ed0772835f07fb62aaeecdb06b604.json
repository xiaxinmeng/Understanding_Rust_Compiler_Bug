{"sha": "645841ea446ed0772835f07fb62aaeecdb06b604", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NTg0MWVhNDQ2ZWQwNzcyODM1ZjA3ZmI2MmFhZWVjZGIwNmI2MDQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-25T15:26:24Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:09Z"}, "message": "async-llvm(8): Clean up resource management and drop LLVM modules ASAP.", "tree": {"sha": "841959cc76915629bedba9b0d42166b267475c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/841959cc76915629bedba9b0d42166b267475c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/645841ea446ed0772835f07fb62aaeecdb06b604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/645841ea446ed0772835f07fb62aaeecdb06b604", "html_url": "https://github.com/rust-lang/rust/commit/645841ea446ed0772835f07fb62aaeecdb06b604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/645841ea446ed0772835f07fb62aaeecdb06b604/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4282dd87ea79ea7836978e0b45514aea35dc1d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4282dd87ea79ea7836978e0b45514aea35dc1d0d", "html_url": "https://github.com/rust-lang/rust/commit/4282dd87ea79ea7836978e0b45514aea35dc1d0d"}], "stats": {"total": 407, "additions": 256, "deletions": 151}, "files": [{"sha": "ff9f666af75d28b17f9a033c2fbb73844106f0fb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=645841ea446ed0772835f07fb62aaeecdb06b604", "patch": "@@ -237,8 +237,6 @@ pub fn compile_input(sess: &Session,\n                             phase5_result);\n     phase5_result?;\n \n-    write::cleanup_llvm(&trans);\n-\n     phase_6_link_output(sess, &trans, &outputs);\n \n     // Now that we won't touch anything in the incremental compilation directory"}, {"sha": "83f7f574493ebf967e5d3024df712274227cedf7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 180, "deletions": 135, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=645841ea446ed0772835f07fb62aaeecdb06b604", "patch": "@@ -18,7 +18,8 @@ use rustc::session::Session;\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n-use {CrateTranslation, OngoingCrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n+use {CrateTranslation, OngoingCrateTranslation, ModuleSource, ModuleTranslation,\n+     CompiledModule, ModuleKind};\n use rustc::hir::def_id::CrateNum;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr};\n use rustc::util::fs::link_or_copy;\n@@ -192,7 +193,6 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n \n /// Module-specific configuration for `optimize_and_codegen`.\n-#[derive(Clone)]\n pub struct ModuleConfig {\n     /// LLVM TargetMachine to use for codegen.\n     tm: TargetMachineRef,\n@@ -231,9 +231,9 @@ pub struct ModuleConfig {\n unsafe impl Send for ModuleConfig { }\n \n impl ModuleConfig {\n-    fn new(tm: TargetMachineRef, passes: Vec<String>) -> ModuleConfig {\n+    fn new(sess: &Session, passes: Vec<String>) -> ModuleConfig {\n         ModuleConfig {\n-            tm: tm,\n+            tm: create_target_machine(sess),\n             passes: passes,\n             opt_level: None,\n             opt_size: None,\n@@ -281,6 +281,40 @@ impl ModuleConfig {\n         self.merge_functions = sess.opts.optimize == config::OptLevel::Default ||\n                                sess.opts.optimize == config::OptLevel::Aggressive;\n     }\n+\n+    fn clone(&self, sess: &Session) -> ModuleConfig {\n+        ModuleConfig {\n+            tm: create_target_machine(sess),\n+            passes: self.passes.clone(),\n+            opt_level: self.opt_level,\n+            opt_size: self.opt_size,\n+\n+            emit_no_opt_bc: self.emit_no_opt_bc,\n+            emit_bc: self.emit_bc,\n+            emit_lto_bc: self.emit_lto_bc,\n+            emit_ir: self.emit_ir,\n+            emit_asm: self.emit_asm,\n+            emit_obj: self.emit_obj,\n+            obj_is_bitcode: self.obj_is_bitcode,\n+\n+            no_verify: self.no_verify,\n+            no_prepopulate_passes: self.no_prepopulate_passes,\n+            no_builtins: self.no_builtins,\n+            time_passes: self.time_passes,\n+            vectorize_loop: self.vectorize_loop,\n+            vectorize_slp: self.vectorize_slp,\n+            merge_functions: self.merge_functions,\n+            inline_threshold: self.inline_threshold,\n+        }\n+    }\n+}\n+\n+impl Drop for ModuleConfig {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustDisposeTargetMachine(self.tm);\n+        }\n+    }\n }\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n@@ -372,13 +406,17 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                diag_handler: &Handler,\n                                mtrans: ModuleTranslation,\n-                               mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n                                output_names: OutputFilenames)\n-    -> Result<(), FatalError>\n+    -> Result<CompiledModule, FatalError>\n {\n-    let llmod = mllvm.llmod;\n-    let llcx = mllvm.llcx;\n+    let (llmod, llcx) = match mtrans.source {\n+        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx),\n+        ModuleSource::Preexisting(_) => {\n+            bug!(\"optimize_and_codegen: called with ModuleSource::Preexisting\")\n+        }\n+    };\n+\n     let tm = config.tm;\n \n     let fv = HandlerFreeVars {\n@@ -390,7 +428,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n     llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n-    let module_name = Some(&mtrans.name[..]);\n+    let module_name = mtrans.name.clone();\n+    let module_name = Some(&module_name[..]);\n \n     if config.emit_no_opt_bc {\n         let out = output_names.temp_path_ext(\"no-opt.bc\", module_name);\n@@ -606,30 +645,13 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n     }\n \n-    llvm::LLVMRustDisposeTargetMachine(tm);\n-    Ok(())\n-}\n-\n-\n-pub fn cleanup_llvm(trans: &CrateTranslation) {\n-    for module in trans.modules.iter() {\n-        unsafe {\n-            match module.source {\n-                ModuleSource::Translated(llvm) => {\n-                    llvm::LLVMDisposeModule(llvm.llmod);\n-                    llvm::LLVMContextDispose(llvm.llcx);\n-                }\n-                ModuleSource::Preexisting(_) => {\n-                }\n-            }\n-        }\n-    }\n+    Ok(mtrans.into_compiled_module(config.emit_obj, config.emit_bc))\n }\n \n-pub struct RunLLVMPassesResult {\n-    pub modules: Vec<ModuleTranslation>,\n-    pub metadata_module: ModuleTranslation,\n-    pub allocator_module: Option<ModuleTranslation>,\n+pub struct CompiledModules {\n+    pub modules: Vec<CompiledModule>,\n+    pub metadata_module: CompiledModule,\n+    pub allocator_module: Option<CompiledModule>,\n }\n \n pub fn run_passes(sess: &Session,\n@@ -658,13 +680,11 @@ pub fn run_passes(sess: &Session,\n             !sess.opts.output_types.should_trans() ||\n             sess.opts.debugging_opts.no_trans);\n \n-    let tm = create_target_machine(sess);\n-\n     // Figure out what we actually need to build.\n \n-    let mut modules_config = ModuleConfig::new(tm, sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(tm, vec![]);\n-    let mut allocator_config = ModuleConfig::new(tm, vec![]);\n+    let mut modules_config = ModuleConfig::new(sess, sess.opts.cg.passes.clone());\n+    let mut metadata_config = ModuleConfig::new(sess, vec![]);\n+    let mut allocator_config = ModuleConfig::new(sess, vec![]);\n \n     if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n@@ -747,25 +767,22 @@ pub fn run_passes(sess: &Session,\n     let mut work_items = Vec::with_capacity(1 + modules.len());\n \n     {\n-        let work = build_work_item(sess,\n-                                   metadata_module.clone(),\n-                                   metadata_config.clone(),\n+        let work = build_work_item(metadata_module,\n+                                   metadata_config.clone(sess),\n                                    crate_output.clone());\n         work_items.push(work);\n     }\n \n-    if let Some(allocator) = allocator_module.clone() {\n-        let work = build_work_item(sess,\n-                                   allocator,\n-                                   allocator_config.clone(),\n+    if let Some(allocator) = allocator_module {\n+        let work = build_work_item(allocator,\n+                                   allocator_config.clone(sess),\n                                    crate_output.clone());\n         work_items.push(work);\n     }\n \n-    for mtrans in modules.iter() {\n-        let work = build_work_item(sess,\n-                                   mtrans.clone(),\n-                                   modules_config.clone(),\n+    for mtrans in modules {\n+        let work = build_work_item(mtrans,\n+                                   modules_config.clone(sess),\n                                    crate_output.clone());\n         work_items.push(work);\n     }\n@@ -778,6 +795,10 @@ pub fn run_passes(sess: &Session,\n         Client::new(num_workers).expect(\"failed to create jobserver\")\n     });\n \n+    drop(modules_config);\n+    drop(metadata_config);\n+    drop(allocator_config);\n+\n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n     let (trans_worker_send, trans_worker_receive) = channel();\n     let (coordinator_send, coordinator_receive) = channel();\n@@ -813,37 +834,27 @@ pub fn run_passes(sess: &Session,\n         }\n     }\n \n-    match coordinator_thread.join() {\n-        Ok(()) => {},\n-        Err(err) => {\n-            panic!(\"error: {:?}\", err);\n-        }\n-    }\n+    let compiled_modules = coordinator_thread.join().unwrap();\n \n     // Just in case, check this on the way out.\n     shared_emitter_main.check(sess);\n     sess.diagnostic().abort_if_errors();\n \n     // If in incr. comp. mode, preserve the `.o` files for potential re-use\n-    for mtrans in modules.iter() {\n+    for module in compiled_modules.modules.iter() {\n         let mut files = vec![];\n \n-        if modules_config.emit_obj {\n-            let path = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n+        if module.emit_obj {\n+            let path = crate_output.temp_path(OutputType::Object, Some(&module.name));\n             files.push((OutputType::Object, path));\n         }\n \n-        if modules_config.emit_bc {\n-            let path = crate_output.temp_path(OutputType::Bitcode, Some(&mtrans.name));\n+        if module.emit_bc {\n+            let path = crate_output.temp_path(OutputType::Bitcode, Some(&module.name));\n             files.push((OutputType::Bitcode, path));\n         }\n \n-        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &files);\n-    }\n-\n-    // All codegen is finished.\n-    unsafe {\n-        llvm::LLVMRustDisposeTargetMachine(tm);\n+        save_trans_partition(sess, &module.name, module.symbol_name_hash, &files);\n     }\n \n     let mut user_wants_bitcode = false;\n@@ -858,10 +869,10 @@ pub fn run_passes(sess: &Session,\n \n         let copy_if_one_unit = |output_type: OutputType,\n                                 keep_numbered: bool| {\n-            if modules.len() == 1 {\n+            if compiled_modules.modules.len() == 1 {\n                 // 1) Only one codegen unit.  In this case it's no difficulty\n                 //    to copy `foo.0.x` to `foo.x`.\n-                let module_name = Some(&modules[0].name[..]);\n+                let module_name = Some(&compiled_modules.modules[0].name[..]);\n                 let path = crate_output.temp_path(output_type, module_name);\n                 copy_gracefully(&path,\n                                 &crate_output.path(output_type));\n@@ -962,27 +973,30 @@ pub fn run_passes(sess: &Session,\n         let keep_numbered_objects = needs_crate_object ||\n                 (user_wants_objects && sess.opts.cg.codegen_units > 1);\n \n-        for module_name in modules.iter().map(|m| Some(&m.name[..])) {\n-            if modules_config.emit_obj && !keep_numbered_objects {\n+        for module in compiled_modules.modules.iter() {\n+            let module_name = Some(&module.name[..]);\n+\n+            if module.emit_obj && !keep_numbered_objects {\n                 let path = crate_output.temp_path(OutputType::Object, module_name);\n                 remove(sess, &path);\n             }\n \n-            if modules_config.emit_bc && !keep_numbered_bitcode {\n+            if module.emit_bc && !keep_numbered_bitcode {\n                 let path = crate_output.temp_path(OutputType::Bitcode, module_name);\n                 remove(sess, &path);\n             }\n         }\n \n-        if metadata_config.emit_bc && !user_wants_bitcode {\n+        if compiled_modules.metadata_module.emit_bc && !user_wants_bitcode {\n             let path = crate_output.temp_path(OutputType::Bitcode,\n-                                              Some(&metadata_module.name));\n+                                              Some(&compiled_modules.metadata_module.name));\n             remove(sess, &path);\n         }\n-        if allocator_config.emit_bc && !user_wants_bitcode {\n-            if let Some(ref module) = allocator_module {\n+\n+        if let Some(ref allocator_module) = compiled_modules.allocator_module {\n+            if allocator_module.emit_bc && !user_wants_bitcode {\n                 let path = crate_output.temp_path(OutputType::Bitcode,\n-                                                  Some(&module.name));\n+                                                  Some(&allocator_module.name));\n                 remove(sess, &path);\n             }\n         }\n@@ -1000,21 +1014,14 @@ pub fn run_passes(sess: &Session,\n         unsafe { llvm::LLVMRustPrintPassTimings(); }\n     }\n \n-    *trans.result.borrow_mut() = Some(\n-        RunLLVMPassesResult {\n-            modules,\n-            metadata_module,\n-            allocator_module,\n-        }\n-    );\n+    *trans.result.borrow_mut() = Some(compiled_modules);\n }\n \n pub fn dump_incremental_data(trans: &CrateTranslation) {\n     let mut reuse = 0;\n     for mtrans in trans.modules.iter() {\n-        match mtrans.source {\n-            ModuleSource::Preexisting(..) => reuse += 1,\n-            ModuleSource::Translated(..) => (),\n+        if mtrans.pre_existing {\n+            reuse += 1;\n         }\n     }\n     eprintln!(\"incremental: re-using {} out of {} modules\", reuse, trans.modules.len());\n@@ -1032,14 +1039,11 @@ impl fmt::Debug for WorkItem {\n     }\n }\n \n-fn build_work_item(sess: &Session,\n-                   mtrans: ModuleTranslation,\n+fn build_work_item(mtrans: ModuleTranslation,\n                    config: ModuleConfig,\n                    output_names: OutputFilenames)\n                    -> WorkItem\n {\n-    let mut config = config;\n-    config.tm = create_target_machine(sess);\n     WorkItem {\n         mtrans: mtrans,\n         config: config,\n@@ -1048,54 +1052,65 @@ fn build_work_item(sess: &Session,\n }\n \n fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n-    -> Result<(), FatalError>\n+    -> Result<CompiledModule, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    unsafe {\n-        match work_item.mtrans.source {\n-            ModuleSource::Translated(mllvm) => {\n-                debug!(\"llvm-optimizing {:?}\", work_item.mtrans.name);\n-                optimize_and_codegen(cgcx,\n-                                     &diag_handler,\n-                                     work_item.mtrans,\n-                                     mllvm,\n-                                     work_item.config,\n-                                     work_item.output_names)?;\n-            }\n-            ModuleSource::Preexisting(wp) => {\n-                let incr_comp_session_dir = cgcx.incr_comp_session_dir\n-                                                .as_ref()\n-                                                .unwrap();\n-                let name = &work_item.mtrans.name;\n-                for (kind, saved_file) in wp.saved_files {\n-                    let obj_out = work_item.output_names.temp_path(kind, Some(name));\n-                    let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n-                                                       &saved_file);\n-                    debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n-                           work_item.mtrans.name,\n-                           source_file,\n-                           obj_out.display());\n-                    match link_or_copy(&source_file, &obj_out) {\n-                        Ok(_) => { }\n-                        Err(err) => {\n-                            diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n-                                                      source_file.display(),\n-                                                      obj_out.display(),\n-                                                      err));\n-                        }\n-                    }\n+    let module_name = work_item.mtrans.name.clone();\n+\n+    let pre_existing = match work_item.mtrans.source {\n+        ModuleSource::Translated(_) => None,\n+        ModuleSource::Preexisting(ref wp) => Some(wp.clone()),\n+    };\n+\n+    if let Some(wp) = pre_existing {\n+        let incr_comp_session_dir = cgcx.incr_comp_session_dir\n+                                        .as_ref()\n+                                        .unwrap();\n+        let name = &work_item.mtrans.name;\n+        for (kind, saved_file) in wp.saved_files {\n+            let obj_out = work_item.output_names.temp_path(kind, Some(name));\n+            let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n+                                               &saved_file);\n+            debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n+                   work_item.mtrans.name,\n+                   source_file,\n+                   obj_out.display());\n+            match link_or_copy(&source_file, &obj_out) {\n+                Ok(_) => { }\n+                Err(err) => {\n+                    diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                              source_file.display(),\n+                                              obj_out.display(),\n+                                              err));\n                 }\n             }\n         }\n-    }\n \n-    Ok(())\n+        Ok(CompiledModule {\n+            name: module_name,\n+            kind: ModuleKind::Regular,\n+            pre_existing: true,\n+            symbol_name_hash: work_item.mtrans.symbol_name_hash,\n+            emit_bc: work_item.config.emit_bc,\n+            emit_obj: work_item.config.emit_obj,\n+        })\n+    } else {\n+        debug!(\"llvm-optimizing {:?}\", module_name);\n+\n+        unsafe {\n+            optimize_and_codegen(cgcx,\n+                                 &diag_handler,\n+                                 work_item.mtrans,\n+                                 work_item.config,\n+                                 work_item.output_names)\n+        }\n+    }\n }\n \n #[derive(Debug)]\n pub enum Message {\n     Token(io::Result<Acquired>),\n-    Done { success: bool },\n+    Done { result: Result<CompiledModule, ()> },\n     WorkItem(WorkItem),\n     CheckErrorMessages,\n }\n@@ -1115,7 +1130,7 @@ fn start_executing_work(sess: &Session,\n                         coordinator_receive: Receiver<Message>,\n                         jobserver: Client,\n                         exported_symbols: Arc<ExportedSymbols>)\n-                        -> thread::JoinHandle<()> {\n+                        -> thread::JoinHandle<CompiledModules> {\n     // First up, convert our jobserver into a helper thread so we can use normal\n     // mpsc channels to manage our messages and such. Once we've got the helper\n     // thread then request `n-1` tokens because all of our work items are ready\n@@ -1215,6 +1230,10 @@ fn start_executing_work(sess: &Session,\n     // the jobserver.\n \n     thread::spawn(move || {\n+        let mut compiled_modules = vec![];\n+        let mut compiled_metadata_module = None;\n+        let mut compiled_allocator_module = None;\n+\n         let mut work_items_left = total_work_item_count;\n         let mut work_items = Vec::with_capacity(total_work_item_count);\n         let mut tokens = Vec::new();\n@@ -1253,7 +1272,8 @@ fn start_executing_work(sess: &Session,\n                     } else {\n                         shared_emitter.fatal(\"failed to acquire jobserver token\");\n                         drop(trans_worker_send.send(Message::CheckErrorMessages));\n-                        return\n+                        // Exit the coordinator thread\n+                        panic!()\n                     }\n                 }\n \n@@ -1269,21 +1289,42 @@ fn start_executing_work(sess: &Session,\n                 //\n                 // Note that if the thread failed that means it panicked, so we\n                 // abort immediately.\n-                Message::Done { success: true } => {\n+                Message::Done { result: Ok(compiled_module) } => {\n                     drop(tokens.pop());\n                     running -= 1;\n                     drop(trans_worker_send.send(Message::CheckErrorMessages));\n+\n+                    match compiled_module.kind {\n+                        ModuleKind::Regular => {\n+                            compiled_modules.push(compiled_module);\n+                        }\n+                        ModuleKind::Metadata => {\n+                            assert!(compiled_metadata_module.is_none());\n+                            compiled_metadata_module = Some(compiled_module);\n+                        }\n+                        ModuleKind::Allocator => {\n+                            assert!(compiled_allocator_module.is_none());\n+                            compiled_allocator_module = Some(compiled_module);\n+                        }\n+                    }\n                 }\n-                Message::Done { success: false } => {\n+                Message::Done { result: Err(()) } => {\n                     shared_emitter.fatal(\"aborting due to worker thread panic\");\n                     drop(trans_worker_send.send(Message::CheckErrorMessages));\n-                    return\n+                    // Exit the coordinator thread\n+                    panic!()\n                 }\n                 msg @ Message::CheckErrorMessages => {\n                     bug!(\"unexpected message: {:?}\", msg);\n                 }\n             }\n         }\n+\n+        CompiledModules {\n+            modules: compiled_modules,\n+            metadata_module: compiled_metadata_module.unwrap(),\n+            allocator_module: compiled_allocator_module,\n+        }\n     })\n }\n \n@@ -1297,17 +1338,22 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // we exit.\n         struct Bomb {\n             coordinator_send: Sender<Message>,\n-            success: bool,\n+            result: Option<CompiledModule>,\n         }\n         impl Drop for Bomb {\n             fn drop(&mut self) {\n-                drop(self.coordinator_send.send(Message::Done { success: self.success }));\n+                let result = match self.result.take() {\n+                    Some(compiled_module) => Ok(compiled_module),\n+                    None => Err(())\n+                };\n+\n+                drop(self.coordinator_send.send(Message::Done { result }));\n             }\n         }\n \n         let mut bomb = Bomb {\n             coordinator_send: cgcx.coordinator_send.clone(),\n-            success: false,\n+            result: None,\n         };\n \n         // Execute the work itself, and if it finishes successfully then flag\n@@ -1323,8 +1369,7 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // we just ignore the result and then send off our message saying that\n         // we're done, which if `execute_work_item` failed is unlikely to be\n         // seen by the main thread, but hey we might as well try anyway.\n-        drop(execute_work_item(&cgcx, work).is_err());\n-        bomb.success = true;\n+        bomb.result = Some(execute_work_item(&cgcx, work).unwrap());\n     });\n }\n "}, {"sha": "7ece92ef9dd6698e7e3464c4f28359318eac9435", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=645841ea446ed0772835f07fb62aaeecdb06b604", "patch": "@@ -27,6 +27,7 @@ use super::OngoingCrateTranslation;\n use super::ModuleLlvm;\n use super::ModuleSource;\n use super::ModuleTranslation;\n+use super::ModuleKind;\n \n use assert_module_sources;\n use back::link;\n@@ -952,6 +953,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n         }),\n+        kind: ModuleKind::Metadata,\n     };\n \n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n@@ -961,7 +963,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n        !tcx.sess.opts.output_types.should_trans() {\n         let empty_exported_symbols = ExportedSymbols::empty();\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n-        return OngoingCrateTranslation {\n+        let crate_translation = OngoingCrateTranslation {\n             crate_name: tcx.crate_name(LOCAL_CRATE),\n             link: link_meta,\n             metadata: metadata,\n@@ -970,12 +972,18 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             linker_info: linker_info,\n             windows_subsystem: None,\n             no_integrated_as: false,\n-            result: ::std::cell::RefCell::new(Some(::back::write::RunLLVMPassesResult {\n-                modules: vec![],\n-                metadata_module: metadata_module,\n-                allocator_module: None,\n-            })),\n+            result: ::std::cell::RefCell::new(None),\n         };\n+\n+        ::back::write::run_passes(tcx.sess,\n+                                  &crate_translation,\n+                                  vec![],\n+                                  metadata_module,\n+                                  None,\n+                                  &output_filenames.outputs,\n+                                  output_filenames);\n+\n+        return crate_translation;\n     }\n \n     let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n@@ -1047,7 +1055,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let module = ModuleTranslation {\n                 name: cgu_name,\n                 symbol_name_hash,\n-                source: ModuleSource::Preexisting(buf.clone())\n+                source: ModuleSource::Preexisting(buf.clone()),\n+                kind: ModuleKind::Regular,\n             };\n             return (Stats::default(), module);\n         }\n@@ -1108,7 +1117,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 source: ModuleSource::Translated(ModuleLlvm {\n                     llcx: ccx.llcx(),\n                     llmod: ccx.llmod(),\n-                })\n+                }),\n+                kind: ModuleKind::Regular,\n             }\n         };\n \n@@ -1196,6 +1206,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 name: link::ALLOCATOR_MODULE_NAME.to_string(),\n                 symbol_name_hash: 0, // we always rebuild allocator shims\n                 source: ModuleSource::Translated(modules),\n+                kind: ModuleKind::Allocator,\n             })\n         }\n     });"}, {"sha": "1df1bd272fd8387f337bb30b125905789725c2f9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645841ea446ed0772835f07fb62aaeecdb06b604/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=645841ea446ed0772835f07fb62aaeecdb06b604", "patch": "@@ -135,7 +135,6 @@ mod type_;\n mod type_of;\n mod value;\n \n-#[derive(Clone)]\n pub struct ModuleTranslation {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be\n@@ -145,6 +144,58 @@ pub struct ModuleTranslation {\n     pub name: String,\n     pub symbol_name_hash: u64,\n     pub source: ModuleSource,\n+    pub kind: ModuleKind,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ModuleKind {\n+    Regular,\n+    Metadata,\n+    Allocator,\n+}\n+\n+impl ModuleTranslation {\n+    pub fn into_compiled_module(self, emit_obj: bool, emit_bc: bool) -> CompiledModule {\n+        let pre_existing = match self.source {\n+            ModuleSource::Preexisting(_) => true,\n+            ModuleSource::Translated(_) => false,\n+        };\n+\n+        CompiledModule {\n+            name: self.name.clone(),\n+            kind: self.kind,\n+            symbol_name_hash: self.symbol_name_hash,\n+            pre_existing,\n+            emit_obj,\n+            emit_bc,\n+        }\n+    }\n+}\n+\n+impl Drop for ModuleTranslation {\n+    fn drop(&mut self) {\n+        match self.source {\n+            ModuleSource::Preexisting(_) => {\n+                // Nothing to dispose.\n+            },\n+            ModuleSource::Translated(llvm) => {\n+                unsafe {\n+                    llvm::LLVMDisposeModule(llvm.llmod);\n+                    llvm::LLVMContextDispose(llvm.llcx);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct CompiledModule {\n+    pub name: String,\n+    pub kind: ModuleKind,\n+    pub symbol_name_hash: u64,\n+    pub pre_existing: bool,\n+    pub emit_obj: bool,\n+    pub emit_bc: bool,\n }\n \n #[derive(Clone)]\n@@ -156,7 +207,7 @@ pub enum ModuleSource {\n     Translated(ModuleLlvm),\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct ModuleLlvm {\n     pub llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n@@ -167,9 +218,9 @@ unsafe impl Sync for ModuleTranslation { }\n \n pub struct CrateTranslation {\n     pub crate_name: Symbol,\n-    pub modules: Vec<ModuleTranslation>,\n-    pub metadata_module: ModuleTranslation,\n-    pub allocator_module: Option<ModuleTranslation>,\n+    pub modules: Vec<CompiledModule>,\n+    pub metadata_module: CompiledModule,\n+    pub allocator_module: Option<CompiledModule>,\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n     pub exported_symbols: Arc<back::symbol_export::ExportedSymbols>,\n@@ -189,7 +240,7 @@ pub struct OngoingCrateTranslation {\n     pub no_integrated_as: bool,\n \n     // This will be replaced by a Future.\n-    pub result: ::std::cell::RefCell<Option<back::write::RunLLVMPassesResult>>,\n+    pub result: ::std::cell::RefCell<Option<back::write::CompiledModules>>,\n }\n \n impl OngoingCrateTranslation {"}]}