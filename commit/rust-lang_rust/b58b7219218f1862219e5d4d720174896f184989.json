{"sha": "b58b7219218f1862219e5d4d720174896f184989", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OGI3MjE5MjE4ZjE4NjIyMTllNWQ0ZDcyMDE3NDg5NmYxODQ5ODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-02T16:04:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-02T16:04:54Z"}, "message": "Auto merge of #51321 - zackmdavis:hiridification_generations, r=eddyb\n\nHirId-ification, continued\n\nAnother incremental step towards the vision of #50928 (previously: #50929).\n\nr? @michaelwoerister", "tree": {"sha": "b3c97e5963683bc33ee3b9c001a5b911fc157950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3c97e5963683bc33ee3b9c001a5b911fc157950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b58b7219218f1862219e5d4d720174896f184989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b58b7219218f1862219e5d4d720174896f184989", "html_url": "https://github.com/rust-lang/rust/commit/b58b7219218f1862219e5d4d720174896f184989", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b58b7219218f1862219e5d4d720174896f184989/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4faaf7e3359fa78bad2e8c54011e94ce8ac078c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4faaf7e3359fa78bad2e8c54011e94ce8ac078c6", "html_url": "https://github.com/rust-lang/rust/commit/4faaf7e3359fa78bad2e8c54011e94ce8ac078c6"}, {"sha": "f23d90a1475e65915923814d4ad3d8d183b24c7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f23d90a1475e65915923814d4ad3d8d183b24c7e", "html_url": "https://github.com/rust-lang/rust/commit/f23d90a1475e65915923814d4ad3d8d183b24c7e"}], "stats": {"total": 159, "additions": 85, "deletions": 74}, "files": [{"sha": "6ccf09f4dfc4f27797e71641e7fe5113e7408575", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(region::Scope::Node(body.value.hir_id.local_id)));\n             let arg_cmt = Rc::new(self.mc.cat_rvalue(\n-                arg.id,\n+                arg.hir_id,\n                 arg.pat.span,\n                 fn_body_scope_r, // Args live only as long as the fn body.\n                 arg_ty));\n@@ -860,7 +860,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = Def::Local(canonical_id);\n-                if let Ok(ref binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n \n@@ -923,7 +923,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n-                let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.hir_id,\n                                                                    fn_decl_span,\n                                                                    freevar));\n                 match upvar_capture {\n@@ -948,15 +948,15 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn cat_captured_var(&mut self,\n-                        closure_id: ast::NodeId,\n+                        closure_hir_id: hir::HirId,\n                         closure_span: Span,\n                         upvar: &hir::Freevar)\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_hir_id = self.tcx().hir.node_to_hir_id(upvar.var_id());\n         let var_ty = self.mc.node_ty(var_hir_id)?;\n-        self.mc.cat_def(closure_id, closure_span, var_ty, upvar.def)\n+        self.mc.cat_def(closure_hir_id, closure_span, var_ty, upvar.def)\n     }\n }\n "}, {"sha": "c3a2d3ce0c27f6d48df22fed89cb2034f187bb47", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -179,17 +179,21 @@ pub enum Note {\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n //\n-// *WARNING* The field `cmt.ty` is NOT necessarily the same as the\n-// result of `node_id_to_type(cmt.id)`. This is because the `id` is\n-// always the `id` of the node producing the type; in an expression\n-// like `*x`, the type of this deref node is the deref'd type (`T`),\n-// but in a pattern like `@x`, the `@x` pattern is again a\n-// dereference, but its type is the type *before* the dereference\n-// (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n-// fashion. For more details, see the method `cat_pattern`\n+// *WARNING* The field `cmt.type` is NOT necessarily the same as the\n+// result of `node_id_to_type(cmt.id)`.\n+//\n+// (FIXME: rewrite the following comment given that `@x` managed\n+// pointers have been obsolete for quite some time.)\n+//\n+// This is because the `id` is always the `id` of the node producing the\n+// type; in an expression like `*x`, the type of this deref node is the\n+// deref'd type (`T`), but in a pattern like `@x`, the `@x` pattern is\n+// again a dereference, but its type is the type *before* the\n+// dereference (`@T`). So use `cmt.ty` to find the type of the value in\n+// a consistent fashion. For more details, see the method `cat_pattern`\n #[derive(Clone, Debug, PartialEq)]\n pub struct cmt_<'tcx> {\n-    pub id: ast::NodeId,           // id of expr/pat producing this value\n+    pub hir_id: hir::HirId,        // HIR id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n     pub cat: Categorization<'tcx>, // categorization of expr\n     pub mutbl: MutabilityCategory, // mutability of expr as place\n@@ -271,18 +275,18 @@ impl<'tcx> cmt_<'tcx> {\n     }\n }\n \n-pub trait ast_node {\n-    fn id(&self) -> ast::NodeId;\n+pub trait HirNode {\n+    fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;\n }\n \n-impl ast_node for hir::Expr {\n-    fn id(&self) -> ast::NodeId { self.id }\n+impl HirNode for hir::Expr {\n+    fn hir_id(&self) -> hir::HirId { self.hir_id }\n     fn span(&self) -> Span { self.span }\n }\n \n-impl ast_node for hir::Pat {\n-    fn id(&self) -> ast::NodeId { self.id }\n+impl HirNode for hir::Pat {\n+    fn hir_id(&self) -> hir::HirId { self.hir_id }\n     fn span(&self) -> Span { self.span }\n }\n \n@@ -610,7 +614,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n-                    self.cat_rvalue_node(expr.id, expr.span, ref_ty)\n+                    self.cat_rvalue_node(expr.hir_id, expr.span, ref_ty)\n                 } else {\n                     previous()?\n                 });\n@@ -625,7 +629,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             adjustment::Adjust::Borrow(_) |\n             adjustment::Adjust::Unsize => {\n                 // Result is an rvalue.\n-                Ok(self.cat_rvalue_node(expr.id, expr.span, target))\n+                Ok(self.cat_rvalue_node(expr.hir_id, expr.span, target))\n             }\n         }\n     }\n@@ -669,8 +673,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(ref qpath) => {\n-            let def = self.tables.qpath_def(qpath, expr.hir_id);\n-            self.cat_def(expr.id, expr.span, expr_ty, def)\n+              let def = self.tables.qpath_def(qpath, expr.hir_id);\n+              self.cat_def(expr.hir_id, expr.span, expr_ty, def)\n           }\n \n           hir::ExprType(ref e, _) => {\n@@ -688,35 +692,35 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           hir::ExprLit(..) | hir::ExprBreak(..) |\n           hir::ExprContinue(..) | hir::ExprStruct(..) | hir::ExprRepeat(..) |\n           hir::ExprInlineAsm(..) | hir::ExprBox(..) => {\n-            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+            Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n           }\n         }\n     }\n \n     pub fn cat_def(&self,\n-                   id: ast::NodeId,\n+                   hir_id: hir::HirId,\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: Def)\n                    -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_def: id={} expr={:?} def={:?}\",\n-               id, expr_ty, def);\n+        debug!(\"cat_def: id={:?} expr={:?} def={:?}\",\n+               hir_id, expr_ty, def);\n \n         match def {\n           Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) |\n           Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) => {\n-                Ok(self.cat_rvalue_node(id, span, expr_ty))\n+                Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n           }\n \n           Def::Static(def_id, mutbl) => {\n             // `#[thread_local]` statics may not outlive the current function.\n             for attr in &self.tcx.get_attrs(def_id)[..] {\n                 if attr.check_name(\"thread_local\") {\n-                    return Ok(self.cat_rvalue_node(id, span, expr_ty));\n+                    return Ok(self.cat_rvalue_node(hir_id, span, expr_ty));\n                 }\n             }\n               Ok(cmt_ {\n-                  id:id,\n+                  hir_id,\n                   span:span,\n                   cat:Categorization::StaticItem,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n@@ -726,12 +730,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           Def::Upvar(var_id, _, fn_node_id) => {\n-              self.cat_upvar(id, span, var_id, fn_node_id)\n+              self.cat_upvar(hir_id, span, var_id, fn_node_id)\n           }\n \n           Def::Local(vid) => {\n             Ok(cmt_ {\n-                id,\n+                hir_id,\n                 span,\n                 cat: Categorization::Local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n@@ -747,7 +751,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     // Categorize an upvar, complete with invisible derefs of closure\n     // environment and upvar reference as appropriate.\n     fn cat_upvar(&self,\n-                 id: ast::NodeId,\n+                 hir_id: hir::HirId,\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId)\n@@ -814,7 +818,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // from the environment (perhaps we should eventually desugar\n         // this field further, but it will do for now).\n         let cmt_result = cmt_ {\n-            id,\n+            hir_id,\n             span,\n             cat: Categorization::Upvar(Upvar {id: upvar_id, kind: kind}),\n             mutbl: var_mutbl,\n@@ -830,10 +834,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 cmt_result\n             }\n             ty::ClosureKind::FnMut => {\n-                self.env_deref(id, span, upvar_id, var_mutbl, ty::MutBorrow, cmt_result)\n+                self.env_deref(hir_id, span, upvar_id, var_mutbl, ty::MutBorrow, cmt_result)\n             }\n             ty::ClosureKind::Fn => {\n-                self.env_deref(id, span, upvar_id, var_mutbl, ty::ImmBorrow, cmt_result)\n+                self.env_deref(hir_id, span, upvar_id, var_mutbl, ty::ImmBorrow, cmt_result)\n             }\n         };\n \n@@ -848,7 +852,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ty::UpvarCapture::ByRef(upvar_borrow) => {\n                 let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n                 cmt_ {\n-                    id,\n+                    hir_id,\n                     span,\n                     cat: Categorization::Deref(Rc::new(cmt_result), ptr),\n                     mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n@@ -864,7 +868,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn env_deref(&self,\n-                 id: ast::NodeId,\n+                 hir_id: hir::HirId,\n                  span: Span,\n                  upvar_id: ty::UpvarId,\n                  upvar_mutbl: MutabilityCategory,\n@@ -908,7 +912,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         }\n \n         let ret = cmt_ {\n-            id,\n+            hir_id,\n             span,\n             cat: Categorization::Deref(Rc::new(cmt_result), env_ptr),\n             mutbl: deref_mutbl,\n@@ -932,17 +936,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_rvalue_node(&self,\n-                           id: ast::NodeId,\n+                           hir_id: hir::HirId,\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt_<'tcx> {\n         debug!(\n             \"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n-            id,\n+            hir_id,\n             span,\n             expr_ty,\n         );\n-        let hir_id = self.tcx.hir.node_to_hir_id(id);\n         let promotable = self.rvalue_promotable_map.as_ref().map(|m| m.contains(&hir_id.local_id))\n                                                             .unwrap_or(false);\n \n@@ -970,18 +973,18 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         } else {\n             self.temporary_scope(hir_id.local_id)\n         };\n-        let ret = self.cat_rvalue(id, span, re, expr_ty);\n+        let ret = self.cat_rvalue(hir_id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);\n         ret\n     }\n \n     pub fn cat_rvalue(&self,\n-                      cmt_id: ast::NodeId,\n+                      cmt_hir_id: hir::HirId,\n                       span: Span,\n                       temp_scope: ty::Region<'tcx>,\n                       expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n         let ret = cmt_ {\n-            id:cmt_id,\n+            hir_id: cmt_hir_id,\n             span:span,\n             cat:Categorization::Rvalue(temp_scope),\n             mutbl:McDeclared,\n@@ -992,15 +995,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    pub fn cat_field<N:ast_node>(&self,\n+    pub fn cat_field<N: HirNode>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n                                  f_index: usize,\n                                  f_ident: ast::Ident,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt_<'tcx> {\n         let ret = cmt_ {\n-            id: node.id(),\n+            hir_id: node.hir_id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: Categorization::Interior(base_cmt,\n@@ -1042,13 +1045,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             mutbl,\n         });\n \n-        let base_cmt = Rc::new(self.cat_rvalue_node(expr.id, expr.span, ref_ty));\n+        let base_cmt = Rc::new(self.cat_rvalue_node(expr.hir_id, expr.span, ref_ty));\n         self.cat_deref(expr, base_cmt, note)\n     }\n \n     pub fn cat_deref(\n         &self,\n-        node: &impl ast_node,\n+        node: &impl HirNode,\n         base_cmt: cmt<'tcx>,\n         note: Note,\n     ) -> McResult<cmt_<'tcx>> {\n@@ -1074,7 +1077,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n         };\n         let ret = cmt_ {\n-            id: node.id(),\n+            hir_id: node.hir_id(),\n             span: node.span(),\n             // For unique ptrs, we inherit mutability from the owning reference.\n             mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n@@ -1086,7 +1089,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         Ok(ret)\n     }\n \n-    fn cat_index<N:ast_node>(&self,\n+    fn cat_index<N: HirNode>(&self,\n                              elt: &N,\n                              base_cmt: cmt<'tcx>,\n                              element_ty: Ty<'tcx>,\n@@ -1106,7 +1109,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         //! presuming that `base_cmt` is not of fixed-length type.\n         //!\n         //! # Parameters\n-        //! - `elt`: the AST node being indexed\n+        //! - `elt`: the HIR node being indexed\n         //! - `base_cmt`: the cmt of `elt`\n \n         let interior_elem = InteriorElement(context);\n@@ -1115,14 +1118,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         return Ok(ret);\n     }\n \n-    pub fn cat_imm_interior<N:ast_node>(&self,\n+    pub fn cat_imm_interior<N:HirNode>(&self,\n                                         node: &N,\n                                         base_cmt: cmt<'tcx>,\n                                         interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n                                         -> cmt_<'tcx> {\n         let ret = cmt_ {\n-            id: node.id(),\n+            hir_id: node.hir_id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: Categorization::Interior(base_cmt, interior),\n@@ -1133,7 +1136,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    pub fn cat_downcast_if_needed<N:ast_node>(&self,\n+    pub fn cat_downcast_if_needed<N:HirNode>(&self,\n                                               node: &N,\n                                               base_cmt: cmt<'tcx>,\n                                               variant_did: DefId)\n@@ -1143,7 +1146,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         if self.tcx.adt_def(base_did).variants.len() != 1 {\n             let base_ty = base_cmt.ty;\n             let ret = Rc::new(cmt_ {\n-                id: node.id(),\n+                hir_id: node.hir_id(),\n                 span: node.span(),\n                 mutbl: base_cmt.mutbl.inherit(),\n                 cat: Categorization::Downcast(base_cmt, variant_did),\n@@ -1193,6 +1196,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // value, and I consider them to produce the value that was\n         // matched. So if you have something like:\n         //\n+        // (FIXME: `@@3` is not legal code anymore!)\n+        //\n         //     let x = @@3;\n         //     match x {\n         //       @@y { ... }"}, {"sha": "a11c8f5dc044d8514d8e1ee2cc54d880d5f2d055", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -459,7 +459,7 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n }\n \n struct ExprLocatorVisitor {\n-    id: ast::NodeId,\n+    hir_id: hir::HirId,\n     result: Option<usize>,\n     expr_and_pat_count: usize,\n }\n@@ -476,7 +476,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n \n         self.expr_and_pat_count += 1;\n \n-        if pat.id == self.id {\n+        if pat.hir_id == self.hir_id {\n             self.result = Some(self.expr_and_pat_count);\n         }\n     }\n@@ -494,7 +494,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n                self.expr_and_pat_count,\n                expr);\n \n-        if expr.id == self.id {\n+        if expr.hir_id == self.hir_id {\n             self.result = Some(self.expr_and_pat_count);\n         }\n     }\n@@ -778,11 +778,11 @@ impl<'tcx> ScopeTree {\n     /// `scope` must be inside the body.\n     pub fn yield_in_scope_for_expr(&self,\n                                    scope: Scope,\n-                                   expr: ast::NodeId,\n+                                   expr_hir_id: hir::HirId,\n                                    body: &'tcx hir::Body) -> Option<Span> {\n         self.yield_in_scope(scope).and_then(|(span, count)| {\n             let mut visitor = ExprLocatorVisitor {\n-                id: expr,\n+                hir_id: expr_hir_id,\n                 result: None,\n                 expr_and_pat_count: 0,\n             };"}, {"sha": "046318b3619c30133de43540e025cf258b761484", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -168,8 +168,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // have to be *FULLY* initialized, but we still\n                     // must be careful lest it contains derefs of\n                     // pointers.\n-                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n-                    self.check_if_assigned_path_is_moved(hir_id.local_id,\n+                    self.check_if_assigned_path_is_moved(assignee_cmt.hir_id.local_id,\n                                                          assignment_span,\n                                                          MovedInUse,\n                                                          &lp);\n@@ -178,8 +177,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // In a case like `path += 1`, then path must be\n                     // fully initialized, since we will read it before\n                     // we write it.\n-                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n-                    self.check_if_path_is_moved(hir_id.local_id,\n+                    self.check_if_path_is_moved(assignee_cmt.hir_id.local_id,\n                                                 assignment_span,\n                                                 MovedInUse,\n                                                 &lp);\n@@ -448,7 +446,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         if let Some(yield_span) = self.bccx\n                                       .region_scope_tree\n                                       .yield_in_scope_for_expr(scope,\n-                                                               cmt.id,\n+                                                               cmt.hir_id,\n                                                                self.bccx.body) {\n             self.bccx.cannot_borrow_across_generator_yield(borrow_span,\n                                                            yield_span,"}, {"sha": "d08814138719a370e1c97e1faf74751db12d69ae", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                                     .local_id,\n                                                 assignment_span,\n                                                 lp,\n-                                                self.bccx.tcx.hir.node_to_hir_id(cmt.id).local_id,\n+                                                cmt.hir_id.local_id,\n                                                 mode);\n             }\n             None => {"}, {"sha": "f221565c7f39124afc001be0819ed538f86c84f4", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -112,15 +112,15 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n \n     fn append_to_grouped_errors<'tcx>(grouped_errors: &mut Vec<GroupedMoveErrors<'tcx>>,\n                                       error: &MoveError<'tcx>) {\n-        let move_from_id = error.move_from.id;\n-        debug!(\"append_to_grouped_errors(move_from_id={})\", move_from_id);\n+        let move_from_id = error.move_from.hir_id;\n+        debug!(\"append_to_grouped_errors(move_from_id={:?})\", move_from_id);\n         let move_to = if error.move_to.is_some() {\n             vec![error.move_to.clone().unwrap()]\n         } else {\n             Vec::new()\n         };\n         for ge in &mut *grouped_errors {\n-            if move_from_id == ge.move_from.id && error.move_to.is_some() {\n+            if move_from_id == ge.move_from.hir_id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n                 ge.move_to_places.extend(move_to);\n                 return"}, {"sha": "4bd8e6afa76e3da07fb6b9b776205d0bd5d60583", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -899,7 +899,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 self.note_and_explain_mutbl_error(&mut db, &err, &error_span);\n-                self.note_immutability_blame(&mut db, err.cmt.immutability_blame(), err.cmt.id);\n+                self.note_immutability_blame(\n+                    &mut db,\n+                    err.cmt.immutability_blame(),\n+                    self.tcx.hir.hir_to_node_id(err.cmt.hir_id)\n+                );\n                 db.emit();\n             }\n             err_out_of_scope(super_scope, sub_scope, cause) => {\n@@ -1105,7 +1109,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                             Origin::Ast)\n             }\n         };\n-        self.note_immutability_blame(&mut err, blame, cmt.id);\n+        self.note_immutability_blame(\n+            &mut err,\n+            blame,\n+            self.tcx.hir.hir_to_node_id(cmt.hir_id)\n+        );\n \n         if is_closure {\n             err.help(\"closures behind references must be called via `&mut`\");"}, {"sha": "e489c4d4a46be731045fd25f7351e211c427ae8c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58b7219218f1862219e5d4d720174896f184989/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b58b7219218f1862219e5d4d720174896f184989", "patch": "@@ -1018,7 +1018,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_ty = self.node_ty(arg.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = self.with_mc(|mc| {\n-                Rc::new(mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty))\n+                Rc::new(mc.cat_rvalue(arg.hir_id, arg.pat.span, re_scope, arg_ty))\n             });\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,"}]}