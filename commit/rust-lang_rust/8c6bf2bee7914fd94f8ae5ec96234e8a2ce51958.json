{"sha": "8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "node_id": "C_kwDOAAsO6NoAKDhjNmJmMmJlZTc5MTRmZDk0ZjhhZTVlYzk2MjM0ZThhMmNlNTE5NTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T00:18:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T00:18:22Z"}, "message": "Auto merge of #104990 - matthiaskrgr:rollup-oskk8v3, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #104955 (Switch rustdoc-gui test to function call)\n - #104976 (Prefer doc comments over `//`-comments in compiler)\n - #104984 (Remove Crate::primitives field)\n - #104989 (update Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "15afce0a3703d88e98a01d9b8258dc236c07afaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15afce0a3703d88e98a01d9b8258dc236c07afaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "html_url": "https://github.com/rust-lang/rust/commit/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07e664c41ae5679b912ba9d1f7364ebaac8e51b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/07e664c41ae5679b912ba9d1f7364ebaac8e51b6", "html_url": "https://github.com/rust-lang/rust/commit/07e664c41ae5679b912ba9d1f7364ebaac8e51b6"}, {"sha": "2ccb38b92d38961a41ab5095e67dc1e3209182dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ccb38b92d38961a41ab5095e67dc1e3209182dd", "html_url": "https://github.com/rust-lang/rust/commit/2ccb38b92d38961a41ab5095e67dc1e3209182dd"}], "stats": {"total": 2252, "additions": 1343, "deletions": 909}, "files": [{"sha": "8bb4442d1bb278f9460338a8d4f67ea8bc35032d", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -111,8 +111,8 @@ impl<CTX: rustc_span::HashStableContext> HashStable<CTX> for Path {\n }\n \n impl Path {\n-    // Convert a span and an identifier to the corresponding\n-    // one-segment path.\n+    /// Convert a span and an identifier to the corresponding\n+    /// one-segment path.\n     pub fn from_ident(ident: Ident) -> Path {\n         Path { segments: thin_vec![PathSegment::from_ident(ident)], span: ident.span, tokens: None }\n     }\n@@ -1283,7 +1283,7 @@ impl Expr {\n         )\n     }\n \n-    // To a first-order approximation, is this a pattern\n+    /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n         match &self.peel_parens().kind {\n             ExprKind::Box(_)"}, {"sha": "c948faeb358356b263587e00d448c54d2d9d512f", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -26,9 +26,9 @@ use thin_vec::thin_vec;\n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n impl MarkedAttrs {\n-    // We have no idea how many attributes there will be, so just\n-    // initiate the vectors with 0 bits. We'll grow them as necessary.\n     pub fn new() -> Self {\n+        // We have no idea how many attributes there will be, so just\n+        // initiate the vectors with 0 bits. We'll grow them as necessary.\n         MarkedAttrs(GrowableBitSet::new_empty())\n     }\n \n@@ -174,9 +174,11 @@ impl MetaItem {\n         self.ident().unwrap_or_else(Ident::empty).name\n     }\n \n-    // Example:\n-    //     #[attribute(name = \"value\")]\n-    //                 ^^^^^^^^^^^^^^\n+    /// ```text\n+    /// Example:\n+    ///     #[attribute(name = \"value\")]\n+    ///                 ^^^^^^^^^^^^^^\n+    /// ```\n     pub fn name_value_literal(&self) -> Option<&Lit> {\n         match &self.kind {\n             MetaItemKind::NameValue(v) => Some(v),"}, {"sha": "11def67c463658ebf4dd1a55603e009b8d8b17e1", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -725,10 +725,10 @@ pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyAttrTokenStream>,\n     visit_lazy_tts_opt_mut(lazy_tts.as_mut(), vis);\n }\n \n+/// Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n+/// In practice the ident part is not actually used by specific visitors right now,\n+/// but there's a test below checking that it works.\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-// Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n-// In practice the ident part is not actually used by specific visitors right now,\n-// but there's a test below checking that it works.\n pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n     let Token { kind, span } = t;\n     match kind {"}, {"sha": "c0cc4e79a3d53161b3e985c45ba1daae69ee0efc", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -302,9 +302,9 @@ impl TokenKind {\n         Literal(Lit::new(kind, symbol, suffix))\n     }\n \n-    // An approximation to proc-macro-style single-character operators used by rustc parser.\n-    // If the operator token can be broken into two tokens, the first of which is single-character,\n-    // then this function performs that operation, otherwise it returns `None`.\n+    /// An approximation to proc-macro-style single-character operators used by rustc parser.\n+    /// If the operator token can be broken into two tokens, the first of which is single-character,\n+    /// then this function performs that operation, otherwise it returns `None`.\n     pub fn break_two_token_op(&self) -> Option<(TokenKind, TokenKind)> {\n         Some(match *self {\n             Le => (Lt, Eq),\n@@ -538,10 +538,10 @@ impl Token {\n         }\n     }\n \n-    // A convenience function for matching on identifiers during parsing.\n-    // Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n-    // into the regular identifier or lifetime token it refers to,\n-    // otherwise returns the original token.\n+    /// A convenience function for matching on identifiers during parsing.\n+    /// Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n+    /// into the regular identifier or lifetime token it refers to,\n+    /// otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n             Interpolated(nt) => match **nt {\n@@ -621,7 +621,7 @@ impl Token {\n         false\n     }\n \n-    // Is the token an interpolated block (`$b:block`)?\n+    /// Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n         if let Interpolated(nt) = &self.kind && let NtBlock(..) = **nt {\n             return true;\n@@ -665,8 +665,8 @@ impl Token {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }\n \n-    // Returns true for reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n+    /// Returns true for reserved identifiers used internally for elided lifetimes,\n+    /// unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_special)\n     }"}, {"sha": "58c6d397ea2706380e3839f23c4467ee3b47b712", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -86,12 +86,12 @@ impl TokenTree {\n         }\n     }\n \n-    // Create a `TokenTree::Token` with alone spacing.\n+    /// Create a `TokenTree::Token` with alone spacing.\n     pub fn token_alone(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span), Spacing::Alone)\n     }\n \n-    // Create a `TokenTree::Token` with joint spacing.\n+    /// Create a `TokenTree::Token` with joint spacing.\n     pub fn token_joint(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span), Spacing::Joint)\n     }\n@@ -413,17 +413,17 @@ impl TokenStream {\n         TokenStream(Lrc::new(self.0.iter().enumerate().map(|(i, tree)| f(i, tree)).collect()))\n     }\n \n-    // Create a token stream containing a single token with alone spacing.\n+    /// Create a token stream containing a single token with alone spacing.\n     pub fn token_alone(kind: TokenKind, span: Span) -> TokenStream {\n         TokenStream::new(vec![TokenTree::token_alone(kind, span)])\n     }\n \n-    // Create a token stream containing a single token with joint spacing.\n+    /// Create a token stream containing a single token with joint spacing.\n     pub fn token_joint(kind: TokenKind, span: Span) -> TokenStream {\n         TokenStream::new(vec![TokenTree::token_joint(kind, span)])\n     }\n \n-    // Create a token stream containing a single `Delimited`.\n+    /// Create a token stream containing a single `Delimited`.\n     pub fn delimited(span: DelimSpan, delim: Delimiter, tts: TokenStream) -> TokenStream {\n         TokenStream::new(vec![TokenTree::Delimited(span, delim, tts)])\n     }\n@@ -522,8 +522,8 @@ impl TokenStream {\n         }\n     }\n \n-    // Push `tt` onto the end of the stream, possibly gluing it to the last\n-    // token. Uses `make_mut` to maximize efficiency.\n+    /// Push `tt` onto the end of the stream, possibly gluing it to the last\n+    /// token. Uses `make_mut` to maximize efficiency.\n     pub fn push_tree(&mut self, tt: TokenTree) {\n         let vec_mut = Lrc::make_mut(&mut self.0);\n \n@@ -534,9 +534,9 @@ impl TokenStream {\n         }\n     }\n \n-    // Push `stream` onto the end of the stream, possibly gluing the first\n-    // token tree to the last token. (No other token trees will be glued.)\n-    // Uses `make_mut` to maximize efficiency.\n+    /// Push `stream` onto the end of the stream, possibly gluing the first\n+    /// token tree to the last token. (No other token trees will be glued.)\n+    /// Uses `make_mut` to maximize efficiency.\n     pub fn push_stream(&mut self, stream: TokenStream) {\n         let vec_mut = Lrc::make_mut(&mut self.0);\n "}, {"sha": "c3e0eccd3d4046a98fb52bb231f7eb1b018dd2c4", "filename": "compiler/rustc_ast_pretty/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -36,8 +36,8 @@ impl Printer {\n         self.nbsp()\n     }\n \n-    // Synthesizes a comment that was not textually present in the original\n-    // source file.\n+    /// Synthesizes a comment that was not textually present in the original\n+    /// source file.\n     pub fn synth_comment(&mut self, text: impl Into<Cow<'static, str>>) {\n         self.word(\"/*\");\n         self.space();"}, {"sha": "949d98f96ab6a8166802f4b76ba922c1e84ec2c4", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -58,10 +58,10 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n     }\n \n-    // Does `expr` need parentheses when printed in a condition position?\n-    //\n-    // These cases need parens due to the parse error observed in #26461: `if return {}`\n-    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+    /// Does `expr` need parentheses when printed in a condition position?\n+    ///\n+    /// These cases need parens due to the parse error observed in #26461: `if return {}`\n+    /// parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n     pub(super) fn cond_needs_par(expr: &ast::Expr) -> bool {\n         match expr.kind {\n             ast::ExprKind::Break(..)"}, {"sha": "91c6bcb08a079db59feaaa82615000fcef6fc0a9", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -41,7 +41,7 @@ pub(crate) struct IncorrectMetaItem {\n     pub span: Span,\n }\n \n-// Error code: E0541\n+/// Error code: E0541\n pub(crate) struct UnknownMetaItem<'a> {\n     pub span: Span,\n     pub item: String,\n@@ -200,7 +200,7 @@ pub(crate) struct InvalidReprHintNoValue {\n     pub name: String,\n }\n \n-// Error code: E0565\n+/// Error code: E0565\n pub(crate) struct UnsupportedLiteral {\n     pub span: Span,\n     pub reason: UnsupportedLiteralReason,"}, {"sha": "86c5d9cfa8121c6885338bd6e0e8765795c151bf", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -590,7 +590,7 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the arguments of the closure, if it exists.\n+    /// Add a span label to the arguments of the closure, if it exists.\n     pub(super) fn args_span_label(self, err: &mut Diagnostic, message: impl Into<String>) {\n         if let UseSpans::ClosureUse { args_span, .. } = self {\n             err.span_label(args_span, message);\n@@ -628,7 +628,7 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the use of the captured variable, if it exists.\n+    /// Add a span label to the use of the captured variable, if it exists.\n     pub(super) fn var_span_label(\n         self,\n         err: &mut Diagnostic,"}, {"sha": "4d87ecf5e44be224f7a692e233bac2b472d56d51", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -83,7 +83,7 @@ mod type_check;\n mod universal_regions;\n mod used_muts;\n \n-// A public API provided for the Rust compiler consumers.\n+/// A public API provided for the Rust compiler consumers.\n pub mod consumers;\n \n use borrow_set::{BorrowData, BorrowSet};"}, {"sha": "b344ab46adbde37ba6f064beb3dc68bf2e8bfa83", "filename": "compiler/rustc_borrowck/src/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -121,8 +121,8 @@ pub(super) fn populate_access_facts<'a, 'tcx>(\n     }\n }\n \n-// For every potentially drop()-touched region `region` in `local`'s type\n-// (`kind`), emit a Polonius `use_of_var_derefs_origin(local, origin)` fact.\n+/// For every potentially drop()-touched region `region` in `local`'s type\n+/// (`kind`), emit a Polonius `use_of_var_derefs_origin(local, origin)` fact.\n pub(super) fn add_drop_of_var_derefs_origin<'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     local: Local,"}, {"sha": "1467d4eaec06862d0d301c6db5addf09998d5112", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -300,12 +300,12 @@ struct TypeParameter {\n     ty: P<ast::Ty>,\n }\n \n-// The code snippets built up for derived code are sometimes used as blocks\n-// (e.g. in a function body) and sometimes used as expressions (e.g. in a match\n-// arm). This structure avoids committing to either form until necessary,\n-// avoiding the insertion of any unnecessary blocks.\n-//\n-// The statements come before the expression.\n+/// The code snippets built up for derived code are sometimes used as blocks\n+/// (e.g. in a function body) and sometimes used as expressions (e.g. in a match\n+/// arm). This structure avoids committing to either form until necessary,\n+/// avoiding the insertion of any unnecessary blocks.\n+///\n+/// The statements come before the expression.\n pub struct BlockOrExpr(Vec<ast::Stmt>, Option<P<Expr>>);\n \n impl BlockOrExpr {"}, {"sha": "b2a21611db7f9833088b5da57f76bfc4947a6c38", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -6,15 +6,15 @@ use rustc_span::edition::Edition;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-// This expands to either\n-// - `$crate::panic::panic_2015!(...)` or\n-// - `$crate::panic::panic_2021!(...)`\n-// depending on the edition.\n-//\n-// This is used for both std::panic!() and core::panic!().\n-//\n-// `$crate` will refer to either the `std` or `core` crate depending on which\n-// one we're expanding from.\n+/// This expands to either\n+/// - `$crate::panic::panic_2015!(...)` or\n+/// - `$crate::panic::panic_2021!(...)`\n+/// depending on the edition.\n+///\n+/// This is used for both std::panic!() and core::panic!().\n+///\n+/// `$crate` will refer to either the `std` or `core` crate depending on which\n+/// one we're expanding from.\n pub fn expand_panic<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n@@ -24,10 +24,10 @@ pub fn expand_panic<'cx>(\n     expand(mac, cx, sp, tts)\n }\n \n-// This expands to either\n-// - `$crate::panic::unreachable_2015!(...)` or\n-// - `$crate::panic::unreachable_2021!(...)`\n-// depending on the edition.\n+/// This expands to either\n+/// - `$crate::panic::unreachable_2015!(...)` or\n+/// - `$crate::panic::unreachable_2021!(...)`\n+/// depending on the edition.\n pub fn expand_unreachable<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,"}, {"sha": "0b17e92efe936d94a3dfeaa334a09ac0d49a4e7f", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -164,7 +164,7 @@ pub fn expand_include<'cx>(\n     Box::new(ExpandResult { p, node_id: cx.current_expansion.lint_node_id })\n }\n \n-// include_str! : read the given file, insert it as a literal string expr\n+/// `include_str!`: read the given file, insert it as a literal string expr\n pub fn expand_include_str(\n     cx: &mut ExtCtxt<'_>,\n     sp: Span,"}, {"sha": "82baf1da28f2f2474c0e615493aa8f1bd6670945", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -13,13 +13,13 @@ use rustc_span::Span;\n use std::iter;\n use thin_vec::thin_vec;\n \n-// #[test_case] is used by custom test authors to mark tests\n-// When building for test, it needs to make the item public and gensym the name\n-// Otherwise, we'll omit the item. This behavior means that any item annotated\n-// with #[test_case] is never addressable.\n-//\n-// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n-// logic will pick up on.\n+/// #[test_case] is used by custom test authors to mark tests\n+/// When building for test, it needs to make the item public and gensym the name\n+/// Otherwise, we'll omit the item. This behavior means that any item annotated\n+/// with #[test_case] is never addressable.\n+///\n+/// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n+/// logic will pick up on.\n pub fn expand_test_case(\n     ecx: &mut ExtCtxt<'_>,\n     attr_sp: Span,"}, {"sha": "3269f62b105b97dd947ad697016ba3e737c08f1f", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -34,8 +34,8 @@ struct TestCtxt<'a> {\n     test_runner: Option<ast::Path>,\n }\n \n-// Traverse the crate, collecting all the test functions, eliding any\n-// existing main functions, and synthesizing a main test harness\n+/// Traverse the crate, collecting all the test functions, eliding any\n+/// existing main functions, and synthesizing a main test harness\n pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n     let span_diagnostic = sess.diagnostic();\n     let panic_strategy = sess.panic_strategy();"}, {"sha": "34746ff6b6645c11bdda409d0af1f627908e65a0", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -108,8 +108,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    // Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n-    // vtable pointer.\n+    /// Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n+    /// vtable pointer.\n     pub(crate) fn dyn_star_force_data_on_stack(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "837708aeb0ea9a42aa4a36aced6b7a19a40bddd3", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -88,9 +88,9 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n     // TODO(antoyo): improve the SSA API to not require those.\n-    // Mapping from function pointer type to indexes of on stack parameters.\n+    /// Mapping from function pointer type to indexes of on stack parameters.\n     pub on_stack_params: RefCell<FxHashMap<FunctionPtrType<'gcc>, FxHashSet<usize>>>,\n-    // Mapping from function to indexes of on stack parameters.\n+    /// Mapping from function to indexes of on stack parameters.\n     pub on_stack_function_params: RefCell<FxHashMap<Function<'gcc>, FxHashSet<usize>>>,\n \n     /// Cache of emitted const globals (value -> global)"}, {"sha": "ace15cfb024775d285510d9f3a035910bc4b0140", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -37,7 +37,7 @@ const VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'ll, 'tcx> {\n-    // Coverage data for each instrumented function identified by DefId.\n+    /// Coverage data for each instrumented function identified by DefId.\n     pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>>,\n     pub(crate) pgo_func_name_var_map: RefCell<FxHashMap<Instance<'tcx>, &'ll llvm::Value>>,\n }"}, {"sha": "c14e1656291e87710f422f5abee59bb1eb13a072", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -35,7 +35,7 @@ pub enum LLVMRustResult {\n pub struct LLVMRustCOFFShortExport {\n     pub name: *const c_char,\n     pub ordinal_present: bool,\n-    // value of `ordinal` only important when `ordinal_present` is true\n+    /// value of `ordinal` only important when `ordinal_present` is true\n     pub ordinal: u16,\n }\n "}, {"sha": "bc3a94a4027062fcfd1ad09cf46663894e4bc441", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -194,8 +194,8 @@ pub fn to_llvm_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]\n     }\n }\n \n-// Given a map from target_features to whether they are enabled or disabled,\n-// ensure only valid combinations are allowed.\n+/// Given a map from target_features to whether they are enabled or disabled,\n+/// ensure only valid combinations are allowed.\n pub fn check_tied_features(\n     sess: &Session,\n     features: &FxHashMap<&str, bool>,\n@@ -213,8 +213,8 @@ pub fn check_tied_features(\n     return None;\n }\n \n-// Used to generate cfg variables and apply features\n-// Must express features in the way Rust understands them\n+/// Used to generate cfg variables and apply features\n+/// Must express features in the way Rust understands them\n pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n     let target_machine = create_informational_target_machine(sess);\n     let mut features: Vec<Symbol> = supported_target_features(sess)"}, {"sha": "5772b7e1d812afa3c2566ecb3fd31e042e078f80", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -238,7 +238,7 @@ impl Type {\n         unsafe { llvm::LLVMInt8TypeInContext(llcx) }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g., i24\n+    /// Creates an integer type with the given number of bits, e.g., i24\n     pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> &Type {\n         unsafe { llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint) }\n     }"}, {"sha": "39cd4a35f17781c2d0c11940a4683abaadd15688", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1179,7 +1179,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n-// This functions tries to determine the appropriate linker (and corresponding LinkerFlavor) to use\n+/// This functions tries to determine the appropriate linker (and corresponding LinkerFlavor) to use\n pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     fn infer_from(\n         sess: &Session,"}, {"sha": "ff0c1ac4916f23f0e1651bb8a885949ac6297361", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -34,9 +34,9 @@ pub fn disable_localization(linker: &mut Command) {\n     linker.env(\"VSLANG\", \"1033\");\n }\n \n-// The third parameter is for env vars, used on windows to set up the\n-// path for MSVC to find its DLLs, and gcc to find its bundled\n-// toolchain\n+/// The third parameter is for env vars, used on windows to set up the\n+/// path for MSVC to find its DLLs, and gcc to find its bundled\n+/// toolchain\n pub fn get_linker<'a>(\n     sess: &'a Session,\n     linker: &Path,"}, {"sha": "51c5c375d51913fabe116d1a52b6245224ab0006", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -191,38 +191,38 @@ pub enum MetadataPosition {\n     Last,\n }\n \n-// For rlibs we \"pack\" rustc metadata into a dummy object file.\n-//\n-// Historically it was needed because rustc linked rlibs as whole-archive in some cases.\n-// In that case linkers try to include all files located in an archive, so if metadata is stored\n-// in an archive then it needs to be of a form that the linker is able to process.\n-// Now it's not clear whether metadata still needs to be wrapped into an object file or not.\n-//\n-// Note, though, that we don't actually want this metadata to show up in any\n-// final output of the compiler. Instead this is purely for rustc's own\n-// metadata tracking purposes.\n-//\n-// With the above in mind, each \"flavor\" of object format gets special\n-// handling here depending on the target:\n-//\n-// * MachO - macos-like targets will insert the metadata into a section that\n-//   is sort of fake dwarf debug info. Inspecting the source of the macos\n-//   linker this causes these sections to be skipped automatically because\n-//   it's not in an allowlist of otherwise well known dwarf section names to\n-//   go into the final artifact.\n-//\n-// * WebAssembly - we actually don't have any container format for this\n-//   target. WebAssembly doesn't support the `dylib` crate type anyway so\n-//   there's no need for us to support this at this time. Consequently the\n-//   metadata bytes are simply stored as-is into an rlib.\n-//\n-// * COFF - Windows-like targets create an object with a section that has\n-//   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n-//   ever sees the section it doesn't process it and it's removed.\n-//\n-// * ELF - All other targets are similar to Windows in that there's a\n-//   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n-//   automatically removed from the final output.\n+/// For rlibs we \"pack\" rustc metadata into a dummy object file.\n+///\n+/// Historically it was needed because rustc linked rlibs as whole-archive in some cases.\n+/// In that case linkers try to include all files located in an archive, so if metadata is stored\n+/// in an archive then it needs to be of a form that the linker is able to process.\n+/// Now it's not clear whether metadata still needs to be wrapped into an object file or not.\n+///\n+/// Note, though, that we don't actually want this metadata to show up in any\n+/// final output of the compiler. Instead this is purely for rustc's own\n+/// metadata tracking purposes.\n+///\n+/// With the above in mind, each \"flavor\" of object format gets special\n+/// handling here depending on the target:\n+///\n+/// * MachO - macos-like targets will insert the metadata into a section that\n+///   is sort of fake dwarf debug info. Inspecting the source of the macos\n+///   linker this causes these sections to be skipped automatically because\n+///   it's not in an allowlist of otherwise well known dwarf section names to\n+///   go into the final artifact.\n+///\n+/// * WebAssembly - we actually don't have any container format for this\n+///   target. WebAssembly doesn't support the `dylib` crate type anyway so\n+///   there's no need for us to support this at this time. Consequently the\n+///   metadata bytes are simply stored as-is into an rlib.\n+///\n+/// * COFF - Windows-like targets create an object with a section that has\n+///   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n+///   ever sees the section it doesn't process it and it's removed.\n+///\n+/// * ELF - All other targets are similar to Windows in that there's a\n+///   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n+///   automatically removed from the final output.\n pub fn create_wrapper_file(\n     sess: &Session,\n     section_name: Vec<u8>,"}, {"sha": "12fca64968aac2adad6a60ceedcc2d7285b51880", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -340,20 +340,20 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub split_debuginfo: rustc_target::spec::SplitDebuginfo,\n     pub split_dwarf_kind: rustc_session::config::SplitDwarfKind,\n \n-    // Number of cgus excluding the allocator/metadata modules\n+    /// Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n-    // Handler to use for diagnostics produced during codegen.\n+    /// Handler to use for diagnostics produced during codegen.\n     pub diag_emitter: SharedEmitter,\n-    // LLVM optimizations for which we want to print remarks.\n+    /// LLVM optimizations for which we want to print remarks.\n     pub remark: Passes,\n-    // Worker thread number\n+    /// Worker thread number\n     pub worker: usize,\n-    // The incremental compilation session directory, or None if we are not\n-    // compiling incrementally\n+    /// The incremental compilation session directory, or None if we are not\n+    /// compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n-    // Used to update CGU re-use information during the thinlto phase.\n+    /// Used to update CGU re-use information during the thinlto phase.\n     pub cgu_reuse_tracker: CguReuseTracker,\n-    // Channel back to the main control thread to send messages to\n+    /// Channel back to the main control thread to send messages to\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n }\n \n@@ -756,7 +756,7 @@ fn execute_work_item<B: ExtraBackendMethods>(\n     }\n }\n \n-// Actual LTO type we end up choosing based on multiple factors.\n+/// Actual LTO type we end up choosing based on multiple factors.\n pub enum ComputedLtoType {\n     No,\n     Thin,"}, {"sha": "b004fbf85a97f8bcbefa345dd17da85503dd777b", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-// Type Names for Debug Info.\n+//! Type Names for Debug Info.\n \n // Notes on targeting MSVC:\n // In general, MSVC's debugger attempts to parse all arguments as C++ expressions,\n@@ -26,10 +26,10 @@ use std::fmt::Write;\n \n use crate::debuginfo::wants_c_like_enum_debuginfo;\n \n-// Compute the name of the type as it should be stored in debuginfo. Does not do\n-// any caching, i.e., calling the function twice with the same type will also do\n-// the work twice. The `qualified` parameter only affects the first level of the\n-// type name, further levels (i.e., type parameters) are always fully qualified.\n+/// Compute the name of the type as it should be stored in debuginfo. Does not do\n+/// any caching, i.e., calling the function twice with the same type will also do\n+/// the work twice. The `qualified` parameter only affects the first level of the\n+/// type name, further levels (i.e., type parameters) are always fully qualified.\n pub fn compute_debuginfo_type_name<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     t: Ty<'tcx>,"}, {"sha": "34a5b638d7ebaa7cc4e7bbf1b52b03a6a34242a5", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -40,10 +40,10 @@ pub enum OperandValue<V> {\n /// instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx, V> {\n-    // The value.\n+    /// The value.\n     pub val: OperandValue<V>,\n \n-    // The layout of value, based on its Rust type.\n+    /// The layout of value, based on its Rust type.\n     pub layout: TyAndLayout<'tcx>,\n }\n "}, {"sha": "88d25be6bd861d66f8a0788b5a9243ebdf7b105b", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -417,8 +417,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n }\n \n-// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n-// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n+/// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n+/// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type Provenance = AllocId;\n     type ProvenanceExtra = ();"}, {"sha": "2ffd73eef3ef84e41bcd788570d7549cb6d30350", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -206,8 +206,8 @@ where\n         }\n     }\n \n-    // Iterates over all fields of an array. Much more efficient than doing the\n-    // same by repeatedly calling `operand_index`.\n+    /// Iterates over all fields of an array. Much more efficient than doing the\n+    /// same by repeatedly calling `operand_index`.\n     pub fn operand_array_fields<'a>(\n         &self,\n         base: &'a OpTy<'tcx, Prov>,"}, {"sha": "1a10851a9f9013d92923c9347fac038fd14a7e17", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -324,7 +324,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n \n macro_rules! make_value_visitor {\n     ($visitor_trait:ident, $value_trait:ident, $($mutability:ident)?) => {\n-        // How to traverse a value and what to do when we are at the leaves.\n+        /// How to traverse a value and what to do when we are at the leaves.\n         pub trait $visitor_trait<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n             type V: $value_trait<'mir, 'tcx, M>;\n "}, {"sha": "655ec345ed3777197a771a038839b9b01ef6861a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -75,14 +75,14 @@ pub fn rustc_allow_const_fn_unstable(\n     attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n }\n \n-// Returns `true` if the given `const fn` is \"const-stable\".\n-//\n-// Panics if the given `DefId` does not refer to a `const fn`.\n-//\n-// Const-stability is only relevant for `const fn` within a `staged_api` crate. Only \"const-stable\"\n-// functions can be called in a const-context by users of the stable compiler. \"const-stable\"\n-// functions are subject to more stringent restrictions than \"const-unstable\" functions: They\n-// cannot use unstable features and can only call other \"const-stable\" functions.\n+/// Returns `true` if the given `const fn` is \"const-stable\".\n+///\n+/// Panics if the given `DefId` does not refer to a `const fn`.\n+///\n+/// Const-stability is only relevant for `const fn` within a `staged_api` crate. Only \"const-stable\"\n+/// functions can be called in a const-context by users of the stable compiler. \"const-stable\"\n+/// functions are subject to more stringent restrictions than \"const-unstable\" functions: They\n+/// cannot use unstable features and can only call other \"const-stable\" functions.\n pub fn is_const_stable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // A default body in a `#[const_trait]` is not const-stable because const\n     // trait fns currently cannot be const-stable. We shouldn't"}, {"sha": "b19d270e61053391ec1df6325b56b2c8f94ccc0d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -686,7 +686,7 @@ impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n     }\n }\n \n-// Types that cannot appear in the signature or locals of a `const fn`.\n+/// Types that cannot appear in the signature or locals of a `const fn`.\n pub mod ty {\n     use super::*;\n "}, {"sha": "c43de3368c62fd190ec6e242e287803f9a2b1d78", "filename": "compiler/rustc_const_eval/src/util/aggregate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -9,10 +9,11 @@ use std::iter::TrustedLen;\n /// Expand `lhs = Rvalue::Aggregate(kind, operands)` into assignments to the fields.\n ///\n /// Produces something like\n-///\n+/// ```ignore (ilustrative)\n /// (lhs as Variant).field0 = arg0;     // We only have a downcast if this is an enum\n /// (lhs as Variant).field1 = arg1;\n /// discriminant(lhs) = variant_index;  // If lhs is an enum or generator.\n+/// ```\n pub fn expand_aggregate<'tcx>(\n     orig_lhs: Place<'tcx>,\n     operands: impl Iterator<Item = (Operand<'tcx>, Ty<'tcx>)> + TrustedLen,"}, {"sha": "380fbd732d505ef7e784a47213520b9e0f9f9186", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1336,8 +1336,8 @@ mod signal_handler {\n         }\n     }\n \n-    // When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n-    // process, print a stack trace and then exit.\n+    /// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n+    /// process, print a stack trace and then exit.\n     pub(super) fn install() {\n         unsafe {\n             const ALT_STACK_SIZE: usize = libc::MINSIGSTKSZ + 64 * 1024;"}, {"sha": "9fe5d588b1f5da117c54516eeb33c6110577ab89", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -242,8 +242,8 @@ pub enum ExpandResult<T, U> {\n     Retry(U),\n }\n \n-// `meta_item` is the attribute, and `item` is the item being modified.\n pub trait MultiItemModifier {\n+    /// `meta_item` is the attribute, and `item` is the item being modified.\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,"}, {"sha": "234cf1b315a23f4ddd939ec58b8d4c6125cd628d", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -193,7 +193,7 @@ impl<'a> ExtCtxt<'a> {\n         self.stmt_local(local, sp)\n     }\n \n-    // Generates `let _: Type;`, which is usually used for type assertions.\n+    /// Generates `let _: Type;`, which is usually used for type assertions.\n     pub fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n             pat: self.pat_wild(span),"}, {"sha": "2510795c2e3ed5073c6aa07a2331b06c87f02e17", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -200,7 +200,7 @@ fn get_features(\n     features\n }\n \n-// `cfg_attr`-process the crate's attributes and compute the crate's features.\n+/// `cfg_attr`-process the crate's attributes and compute the crate's features.\n pub fn features(\n     sess: &Session,\n     mut krate: ast::Crate,"}, {"sha": "3e98b024c73b9ec746375578f3e0e11ac859d364", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Recursively expand all macro invocations in this AST fragment.\n+    /// Recursively expand all macro invocations in this AST fragment.\n     pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         let orig_force_mode = self.cx.force_mode;\n@@ -1931,9 +1931,12 @@ pub struct ExpansionConfig<'feat> {\n     pub features: Option<&'feat Features>,\n     pub recursion_limit: Limit,\n     pub trace_mac: bool,\n-    pub should_test: bool,          // If false, strip `#[test]` nodes\n-    pub span_debug: bool,           // If true, use verbose debugging for `proc_macro::Span`\n-    pub proc_macro_backtrace: bool, // If true, show backtraces for proc-macro panics\n+    /// If false, strip `#[test]` nodes\n+    pub should_test: bool,\n+    /// If true, use verbose debugging for `proc_macro::Span`\n+    pub span_debug: bool,\n+    /// If true, show backtraces for proc-macro panics\n+    pub proc_macro_backtrace: bool,\n }\n \n impl<'feat> ExpansionConfig<'feat> {"}, {"sha": "81aedcce87728db7fcca82e1661330a22530e8ff", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -981,8 +981,8 @@ pub struct Pat<'hir> {\n     pub hir_id: HirId,\n     pub kind: PatKind<'hir>,\n     pub span: Span,\n-    // Whether to use default binding modes.\n-    // At present, this is false only for destructuring assignment.\n+    /// Whether to use default binding modes.\n+    /// At present, this is false only for destructuring assignment.\n     pub default_binding_modes: bool,\n }\n \n@@ -1090,7 +1090,7 @@ impl fmt::Display for RangeEnd {\n pub struct DotDotPos(u32);\n \n impl DotDotPos {\n-    // Panics if n >= u32::MAX.\n+    /// Panics if n >= u32::MAX.\n     pub fn new(n: Option<usize>) -> Self {\n         match n {\n             Some(n) => {\n@@ -1694,10 +1694,10 @@ impl Expr<'_> {\n         }\n     }\n \n-    // Whether this looks like a place expr, without checking for deref\n-    // adjustments.\n-    // This will return `true` in some potentially surprising cases such as\n-    // `CONSTANT.field`.\n+    /// Whether this looks like a place expr, without checking for deref\n+    /// adjustments.\n+    /// This will return `true` in some potentially surprising cases such as\n+    /// `CONSTANT.field`.\n     pub fn is_syntactic_place_expr(&self) -> bool {\n         self.is_place_expr(|_| true)\n     }\n@@ -1838,7 +1838,7 @@ impl Expr<'_> {\n         }\n     }\n \n-    // To a first-order approximation, is this a pattern\n+    /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n         match &self.kind {\n             ExprKind::Box(_)\n@@ -2160,11 +2160,11 @@ impl fmt::Display for LoopIdError {\n \n #[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct Destination {\n-    // This is `Some(_)` iff there is an explicit user-specified `label\n+    /// This is `Some(_)` iff there is an explicit user-specified 'label\n     pub label: Option<Label>,\n \n-    // These errors are caught and then reported during the diagnostics pass in\n-    // librustc_passes/loops.rs\n+    /// These errors are caught and then reported during the diagnostics pass in\n+    /// `librustc_passes/loops.rs`\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n@@ -2335,7 +2335,7 @@ pub enum ImplItemKind<'hir> {\n     Type(&'hir Ty<'hir>),\n }\n \n-// The name of the associated type for `Fn` return types.\n+/// The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n /// Bind a type to an associated type (i.e., `A = Foo`).\n@@ -3261,7 +3261,7 @@ pub enum ForeignItemKind<'hir> {\n /// A variable captured by a closure.\n #[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Upvar {\n-    // First span where it is accessed (there can be multiple).\n+    /// First span where it is accessed (there can be multiple).\n     pub span: Span,\n }\n "}, {"sha": "5f06db4038ff7071ad384f0ea848768480bf66a0", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -850,7 +850,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .is_some()\n     }\n \n-    // Sets `implicitly_sized` to true on `Bounds` if necessary\n+    /// Sets `implicitly_sized` to true on `Bounds` if necessary\n     pub(crate) fn add_implicitly_sized<'hir>(\n         &self,\n         bounds: &mut Bounds<'hir>,\n@@ -2391,7 +2391,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         path_segs\n     }\n \n-    // Check a type `Path` and convert it to a `Ty`.\n+    /// Check a type `Path` and convert it to a `Ty`.\n     pub fn res_to_ty(\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,"}, {"sha": "d6e3ddb0a613964238574c6fbc46261d8a00f620", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -233,9 +233,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     result\n }\n \n-// This is an implementation of the TypeRelation trait with the\n-// aim of simply comparing for equality (without side-effects).\n-// It is not intended to be used anywhere else other than here.\n+/// This is an implementation of the [`TypeRelation`] trait with the\n+/// aim of simply comparing for equality (without side-effects).\n+///\n+/// It is not intended to be used anywhere else other than here.\n pub(crate) struct SimpleEqRelation<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "3b286bb9c93cfd09bc2e38a9a90d31b8de8b95d9", "filename": "compiler/rustc_hir_analysis/src/variance/terms.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -42,22 +42,22 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n     }\n }\n \n-// The first pass over the crate simply builds up the set of inferreds.\n+/// The first pass over the crate simply builds up the set of inferreds.\n \n pub struct TermsContext<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub arena: &'a DroplessArena,\n \n-    // For marker types, UnsafeCell, and other lang items where\n-    // variance is hardcoded, records the item-id and the hardcoded\n-    // variance.\n+    /// For marker types, `UnsafeCell`, and other lang items where\n+    /// variance is hardcoded, records the item-id and the hardcoded\n+    /// variance.\n     pub lang_items: Vec<(LocalDefId, Vec<ty::Variance>)>,\n \n-    // Maps from the node id of an item to the first inferred index\n-    // used for its type & region parameters.\n+    /// Maps from the node id of an item to the first inferred index\n+    /// used for its type & region parameters.\n     pub inferred_starts: LocalDefIdMap<InferredIndex>,\n \n-    // Maps from an InferredIndex to the term for that variable.\n+    /// Maps from an InferredIndex to the term for that variable.\n     pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n "}, {"sha": "24184bdbf5cdcd74b125f185243919086905910f", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -57,8 +57,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n     }\n \n-    // Requires that the two types unify, and prints an error message if\n-    // they don't.\n+    /// Requires that the two types unify, and prints an error message if\n+    /// they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n         if let Some(mut e) = self.demand_suptype_diag(sp, expected, actual) {\n             e.emit();"}, {"sha": "4f086cf597d8826dd4a4b512f73a6ae9d661f4ab", "filename": "compiler/rustc_hir_typeck/src/expectation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -79,9 +79,9 @@ impl<'a, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    // Resolves `expected` by a single level if it is a variable. If\n-    // there is no expected type or resolution is not possible (e.g.,\n-    // no constraints yet present), just returns `self`.\n+    /// Resolves `expected` by a single level if it is a variable. If\n+    /// there is no expected type or resolution is not possible (e.g.,\n+    /// no constraints yet present), just returns `self`.\n     fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,"}, {"sha": "5166f1fd1c743fe74e0a0637c0c63beeded13243", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -914,8 +914,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Check if an expression `original_expr_id` comes from the condition of a while loop,\n-    // as opposed from the body of a while loop, which we can naively check by iterating\n-    // parents until we find a loop...\n+    /// as opposed from the body of a while loop, which we can naively check by iterating\n+    /// parents until we find a loop...\n     pub(super) fn comes_from_while_condition(\n         &self,\n         original_expr_id: HirId,"}, {"sha": "e5c9f439af3e07fdf3b00ceacac1da1a0dd074f2", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -38,19 +38,19 @@ pub struct Inherited<'tcx> {\n \n     pub(super) fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n-    // Some additional `Sized` obligations badly affect type inference.\n-    // These obligations are added in a later stage of typeck.\n-    // Removing these may also cause additional complications, see #101066.\n+    /// Some additional `Sized` obligations badly affect type inference.\n+    /// These obligations are added in a later stage of typeck.\n+    /// Removing these may also cause additional complications, see #101066.\n     pub(super) deferred_sized_obligations:\n         RefCell<Vec<(Ty<'tcx>, Span, traits::ObligationCauseCode<'tcx>)>>,\n \n-    // When we process a call like `c()` where `c` is a closure type,\n-    // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n-    // `FnOnce` closure. In that case, we defer full resolution of the\n-    // call until upvar inference can kick in and make the\n-    // decision. We keep these deferred resolutions grouped by the\n-    // def-id of the closure, so that once we decide, we can easily go\n-    // back and process them.\n+    /// When we process a call like `c()` where `c` is a closure type,\n+    /// we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n+    /// `FnOnce` closure. In that case, we defer full resolution of the\n+    /// call until upvar inference can kick in and make the\n+    /// decision. We keep these deferred resolutions grouped by the\n+    /// def-id of the closure, so that once we decide, we can easily go\n+    /// back and process them.\n     pub(super) deferred_call_resolutions: RefCell<LocalDefIdMap<Vec<DeferredCallResolution<'tcx>>>>,\n \n     pub(super) deferred_cast_checks: RefCell<Vec<super::cast::CastCheck<'tcx>>>,"}, {"sha": "a8acaf6597aaba3064b261dc005ac964ee241598", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -438,9 +438,9 @@ fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> Symbol {\n     }\n }\n \n-// A visitor that collects all #[rustc_clean] attributes from\n-// the HIR. It is used to verify that we really ran checks for all annotated\n-// nodes.\n+/// A visitor that collects all `#[rustc_clean]` attributes from\n+/// the HIR. It is used to verify that we really ran checks for all annotated\n+/// nodes.\n pub struct FindAllAttrs<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     found_attrs: Vec<&'tcx Attribute>,"}, {"sha": "2402a7ea7c741be7bae0441777b0345129f6f521", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -29,10 +29,10 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct FreeRegionMap<'tcx> {\n-    // Stores the relation `a < b`, where `a` and `b` are regions.\n-    //\n-    // Invariant: only free regions like `'x` or `'static` are stored\n-    // in this relation, not scopes.\n+    /// Stores the relation `a < b`, where `a` and `b` are regions.\n+    ///\n+    /// Invariant: only free regions like `'x` or `'static` are stored\n+    /// in this relation, not scopes.\n     pub(crate) relation: TransitiveRelation<Region<'tcx>>,\n }\n "}, {"sha": "524f7a39ebbfb8f72077340dd534b13d8aafa330", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -410,19 +410,19 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n }\n \n-// Visitor that requires that (almost) all regions in the type visited outlive\n-// `least_region`. We cannot use `push_outlives_components` because regions in\n-// closure signatures are not included in their outlives components. We need to\n-// ensure all regions outlive the given bound so that we don't end up with,\n-// say, `ReVar` appearing in a return type and causing ICEs when other\n-// functions end up with region constraints involving regions from other\n-// functions.\n-//\n-// We also cannot use `for_each_free_region` because for closures it includes\n-// the regions parameters from the enclosing item.\n-//\n-// We ignore any type parameters because impl trait values are assumed to\n-// capture all the in-scope type parameters.\n+/// Visitor that requires that (almost) all regions in the type visited outlive\n+/// `least_region`. We cannot use `push_outlives_components` because regions in\n+/// closure signatures are not included in their outlives components. We need to\n+/// ensure all regions outlive the given bound so that we don't end up with,\n+/// say, `ReVar` appearing in a return type and causing ICEs when other\n+/// functions end up with region constraints involving regions from other\n+/// functions.\n+///\n+/// We also cannot use `for_each_free_region` because for closures it includes\n+/// the regions parameters from the enclosing item.\n+///\n+/// We ignore any type parameters because impl trait values are assumed to\n+/// capture all the in-scope type parameters.\n pub struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP: FnMut(ty::Region<'tcx>)> {\n     pub tcx: TyCtxt<'tcx>,\n     pub op: OP,"}, {"sha": "c146902d594afd3410c42de40e99f6f926045207", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -9,10 +9,10 @@ use super::{OpaqueTypeDecl, OpaqueTypeMap};\n \n #[derive(Default, Debug, Clone)]\n pub struct OpaqueTypeStorage<'tcx> {\n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    /// Opaque types found in explicit return types and their\n+    /// associated fresh inference variable. Writeback resolves these\n+    /// variables to get the concrete type, which can be used to\n+    /// 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n     pub opaque_types: OpaqueTypeMap<'tcx>,\n }\n "}, {"sha": "e6a0d7e60ca772b10cd67b0630dbdc50724a4907", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -206,7 +206,7 @@ impl LintStore {\n         self.late_module_passes.push(Box::new(pass));\n     }\n \n-    // Helper method for register_early/late_pass\n+    /// Helper method for register_early/late_pass\n     pub fn register_lints(&mut self, lints: &[&'static Lint]) {\n         for lint in lints {\n             self.lints.push(lint);"}, {"sha": "af7b0793a957413b38283188befe5def41f1e234", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -67,10 +67,10 @@ impl std::ops::Deref for MetadataBlob {\n     }\n }\n \n-// A map from external crate numbers (as decoded from some crate file) to\n-// local crate numbers (as generated during this session). Each external\n-// crate may refer to types in other external crates, and each has their\n-// own crate numbers.\n+/// A map from external crate numbers (as decoded from some crate file) to\n+/// local crate numbers (as generated during this session). Each external\n+/// crate may refer to types in other external crates, and each has their\n+/// own crate numbers.\n pub(crate) type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub(crate) struct CrateMetadata {"}, {"sha": "a5050d721bbb85159ba6db6a3576c182fce39b12", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -20,8 +20,8 @@ use super::{\n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n pub struct ConstAlloc<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is an `AllocKind::Memory`\n-    // (so you can use `AllocMap::unwrap_memory`).\n+    /// The value lives here, at offset 0, and that allocation definitely is an `AllocKind::Memory`\n+    /// (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,\n }"}, {"sha": "143435cb2a1f47bcbf11929aa4aba4a4b6e9b1da", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -471,7 +471,7 @@ pub struct ImplDerivedObligationCause<'tcx> {\n }\n \n impl<'tcx> ObligationCauseCode<'tcx> {\n-    // Return the base obligation, ignoring derived obligations.\n+    /// Returns the base obligation, ignoring derived obligations.\n     pub fn peel_derives(&self) -> &Self {\n         let mut base_cause = self;\n         while let Some((parent_code, _)) = base_cause.parent() {"}, {"sha": "921ffead521a076d0dd21ef3a830825d035f4152", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -15,8 +15,8 @@ use super::{Ty, TyCtxt};\n \n use self::BorrowKind::*;\n \n-// Captures are represented using fields inside a structure.\n-// This represents accessing self in the closure structure\n+/// Captures are represented using fields inside a structure.\n+/// This represents accessing self in the closure structure\n pub const CAPTURE_STRUCT_LOCAL: mir::Local = mir::Local::from_u32(1);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n@@ -91,7 +91,7 @@ pub enum ClosureKind {\n }\n \n impl<'tcx> ClosureKind {\n-    // This is the initial value used when doing upvar inference.\n+    /// This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n     /// Returns `true` if a type that impls this closure kind"}, {"sha": "bf30a403d9b945e6f0c134dfdfc47b7aeedf8932", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -713,22 +713,24 @@ impl<'tcx> TypeckResults<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n-    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n-    // doesn't provide type parameter substitutions.\n+    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n+    /// doesn't provide type parameter substitutions.\n+    ///\n+    /// [`expr_ty`]: TypeckResults::expr_ty\n     pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    // Returns the type of an expression as a monotype.\n-    //\n-    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `Adjustment` annotations such as auto-deref or\n-    // auto-ref.  The type returned by this function does not consider such\n-    // adjustments.  See `expr_ty_adjusted()` instead.\n-    //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n-    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n-    // instead of \"fn(ty) -> T with T = isize\".\n+    /// Returns the type of an expression as a monotype.\n+    ///\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n+    /// auto-ref.  The type returned by this function does not consider such\n+    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    ///\n+    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n+    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n+    /// instead of `fn(ty) -> T with T = isize`.\n     pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         self.node_type(expr.hir_id)\n     }\n@@ -995,15 +997,15 @@ impl<'tcx> CommonConsts<'tcx> {\n     }\n }\n \n-// This struct contains information regarding the `ReFree(FreeRegion)` corresponding to a lifetime\n-// conflict.\n+/// This struct contains information regarding the `ReFree(FreeRegion)` corresponding to a lifetime\n+/// conflict.\n #[derive(Debug)]\n pub struct FreeRegionInfo {\n-    // `LocalDefId` corresponding to FreeRegion\n+    /// `LocalDefId` corresponding to FreeRegion\n     pub def_id: LocalDefId,\n-    // the bound region corresponding to FreeRegion\n+    /// the bound region corresponding to FreeRegion\n     pub boundregion: ty::BoundRegionKind,\n-    // checks if bound region is in Impl Item\n+    /// checks if bound region is in Impl Item\n     pub is_impl_item: bool,\n }\n \n@@ -1660,7 +1662,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    // Checks if the bound region is in Impl Item.\n+    /// Checks if the bound region is in Impl Item.\n     pub fn is_bound_region_in_impl_item(self, suitable_region_binding_scope: LocalDefId) -> bool {\n         let container_id = self.parent(suitable_region_binding_scope.to_def_id());\n         if self.impl_trait_ref(container_id).is_some() {"}, {"sha": "046a2660a1f6dd51b45d23616ef786ee69767ca8", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -6,7 +6,7 @@ use std::slice;\n pub struct FlagComputation {\n     pub flags: TypeFlags,\n \n-    // see `Ty::outer_exclusive_binder` for details\n+    /// see `Ty::outer_exclusive_binder` for details\n     pub outer_exclusive_binder: ty::DebruijnIndex,\n }\n "}, {"sha": "595b73986a87b0f81e7b35c6e737b4731f7558bb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -414,7 +414,7 @@ impl Visibility<DefId> {\n         self.map_id(|id| id.expect_local())\n     }\n \n-    // Returns `true` if this item is visible anywhere in the local crate.\n+    /// Returns `true` if this item is visible anywhere in the local crate.\n     pub fn is_visible_locally(self) -> bool {\n         match self {\n             Visibility::Public => true,\n@@ -926,9 +926,10 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n+/// `A: B`\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n+pub struct OutlivesPredicate<A, B>(pub A, pub B);\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>;"}, {"sha": "1e1a566de444d94d27c9d370ac11c1acda4b1865", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -2243,7 +2243,7 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n-    // If `self` is a primitive, return its [`Symbol`].\n+    /// If `self` is a primitive, return its [`Symbol`].\n     pub fn primitive_symbol(self) -> Option<Symbol> {\n         match self.kind() {\n             ty::Bool => Some(sym::bool),"}, {"sha": "b38a5fbf20f5b26d17ab4b44b9b678236ec482aa", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-// Query provider for `trait_impls_of`.\n+/// Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> TraitImpls {\n     let mut impls = TraitImpls::default();\n \n@@ -255,7 +255,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n     impls\n }\n \n-// Query provider for `incoherent_impls`.\n+/// Query provider for `incoherent_impls`.\n pub(super) fn incoherent_impls_provider(tcx: TyCtxt<'_>, simp: SimplifiedType) -> &[DefId] {\n     let mut impls = Vec::new();\n "}, {"sha": "47c1ce8075674acd461a2cd8d90da3ca73dd76e4", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1208,11 +1208,11 @@ pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Does the equivalent of\n-// ```\n-// let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-// folder.tcx().intern_*(&v)\n-// ```\n+/// Does the equivalent of\n+/// ```ignore (ilustrative)\n+/// let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+/// folder.tcx().intern_*(&v)\n+/// ```\n pub fn fold_list<'tcx, F, T>(\n     list: &'tcx ty::List<T>,\n     folder: &mut F,"}, {"sha": "d33401f07645e1db6f4a97a0ea570b341d0a04a4", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -2,35 +2,35 @@ use rustc_middle::thir::*;\n \n #[derive(Debug, PartialEq)]\n pub(crate) enum Category {\n-    // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n-    // sort of thing. Something that could appear on the LHS of an `=`\n-    // sign.\n+    /// An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n+    /// sort of thing. Something that could appear on the LHS of an `=`\n+    /// sign.\n     Place,\n \n-    // A literal like `23` or `\"foo\"`. Does not include constant\n-    // expressions like `3 + 5`.\n+    /// A literal like `23` or `\"foo\"`. Does not include constant\n+    /// expressions like `3 + 5`.\n     Constant,\n \n-    // Something that generates a new value at runtime, like `x + y`\n-    // or `foo()`.\n+    /// Something that generates a new value at runtime, like `x + y`\n+    /// or `foo()`.\n     Rvalue(RvalueFunc),\n }\n \n-// Rvalues fall into different \"styles\" that will determine which fn\n-// is best suited to generate them.\n+/// Rvalues fall into different \"styles\" that will determine which fn\n+/// is best suited to generate them.\n #[derive(Debug, PartialEq)]\n pub(crate) enum RvalueFunc {\n-    // Best generated by `into`. This is generally exprs that\n-    // cause branching, like `match`, but also includes calls.\n+    /// Best generated by `into`. This is generally exprs that\n+    /// cause branching, like `match`, but also includes calls.\n     Into,\n \n-    // Best generated by `as_rvalue`. This is usually the case.\n+    /// Best generated by `as_rvalue`. This is usually the case.\n     AsRvalue,\n }\n \n-/// Determines the category for a given expression. Note that scope\n-/// and paren expressions have no category.\n impl Category {\n+    /// Determines the category for a given expression. Note that scope\n+    /// and paren expressions have no category.\n     pub(crate) fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,"}, {"sha": "baeb2718cae46414636eeafabd1bd414b639b5bd", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -34,8 +34,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         Operand::Constant(constant)\n     }\n \n-    // Returns a zero literal operand for the appropriate type, works for\n-    // bool, char and integers.\n+    /// Returns a zero literal operand for the appropriate type, works for\n+    /// bool, char and integers.\n     pub(crate) fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ConstantKind::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n "}, {"sha": "5ddae5f5300f664e5190d5ebfbf1286228274d7f", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -443,8 +443,9 @@ impl<'tcx> Scopes<'tcx> {\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n-    //  Start a breakable scope, which tracks where `continue`, `break` and\n-    //  `return` should branch to.\n+\n+    ///  Start a breakable scope, which tracks where `continue`, `break` and\n+    ///  `return` should branch to.\n     pub(crate) fn in_breakable_scope<F>(\n         &mut self,\n         loop_block: Option<BasicBlock>,\n@@ -799,6 +800,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Finding scopes\n     // ==============\n+\n     /// Returns the scope that we should use as the lifetime of an\n     /// operand. Basically, an operand must live until it is consumed.\n     /// This is similar to, but not quite the same as, the temporary\n@@ -824,6 +826,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Scheduling drops\n     // ================\n+\n     pub(crate) fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n@@ -996,6 +999,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Other\n     // =====\n+\n     /// Returns the [DropIdx] for the innermost drop if the function unwound at\n     /// this point. The `DropIdx` will be created if it doesn't already exist.\n     fn diverge_cleanup(&mut self) -> DropIdx {"}, {"sha": "9b2260f68251abeaafe883d76d192ee94e34d9cc", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -5,37 +5,36 @@ use crate::util;\n use crate::MirPass;\n use rustc_middle::mir::patch::MirPatch;\n \n-// This pass moves values being dropped that are within a packed\n-// struct to a separate local before dropping them, to ensure that\n-// they are dropped from an aligned address.\n-//\n-// For example, if we have something like\n-// ```Rust\n-//     #[repr(packed)]\n-//     struct Foo {\n-//         dealign: u8,\n-//         data: Vec<u8>\n-//     }\n-//\n-//     let foo = ...;\n-// ```\n-//\n-// We want to call `drop_in_place::<Vec<u8>>` on `data` from an aligned\n-// address. This means we can't simply drop `foo.data` directly, because\n-// its address is not aligned.\n-//\n-// Instead, we move `foo.data` to a local and drop that:\n-// ```\n-//     storage.live(drop_temp)\n-//     drop_temp = foo.data;\n-//     drop(drop_temp) -> next\n-// next:\n-//     storage.dead(drop_temp)\n-// ```\n-//\n-// The storage instructions are required to avoid stack space\n-// blowup.\n-\n+/// This pass moves values being dropped that are within a packed\n+/// struct to a separate local before dropping them, to ensure that\n+/// they are dropped from an aligned address.\n+///\n+/// For example, if we have something like\n+/// ```ignore (ilustrative)\n+/// #[repr(packed)]\n+/// struct Foo {\n+///     dealign: u8,\n+///     data: Vec<u8>\n+/// }\n+///\n+/// let foo = ...;\n+/// ```\n+///\n+/// We want to call `drop_in_place::<Vec<u8>>` on `data` from an aligned\n+/// address. This means we can't simply drop `foo.data` directly, because\n+/// its address is not aligned.\n+///\n+/// Instead, we move `foo.data` to a local and drop that:\n+/// ```ignore (ilustrative)\n+///     storage.live(drop_temp)\n+///     drop_temp = foo.data;\n+///     drop(drop_temp) -> next\n+/// next:\n+///     storage.dead(drop_temp)\n+/// ```\n+///\n+/// The storage instructions are required to avoid stack space\n+/// blowup.\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {"}, {"sha": "932134bd6318f44d6ccacbb06ac1b0ff8e4cf188", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -25,7 +25,7 @@ pub fn build_ptr_tys<'tcx>(\n     (unique_ty, nonnull_ty, ptr_ty)\n }\n \n-// Constructs the projection needed to access a Box's pointer\n+/// Constructs the projection needed to access a Box's pointer\n pub fn build_projection<'tcx>(\n     unique_ty: Ty<'tcx>,\n     nonnull_ty: Ty<'tcx>,"}, {"sha": "cf7226a129ce7fb42aee119c6efccbe7104325eb", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -295,8 +295,8 @@ impl<'tcx> InliningMap<'tcx> {\n         assert!(self.index.insert(source, start_index..end_index).is_none());\n     }\n \n-    // Internally iterate over all items referenced by `source` which will be\n-    // made available for inlining.\n+    /// Internally iterate over all items referenced by `source` which will be\n+    /// made available for inlining.\n     pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n@@ -310,7 +310,7 @@ impl<'tcx> InliningMap<'tcx> {\n         }\n     }\n \n-    // Internally iterate over all items and the things each accesses.\n+    /// Internally iterate over all items and the things each accesses.\n     pub fn iter_accesses<F>(&self, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>]),"}, {"sha": "f1b50296e2565a858e0442b88e192e1fdf12e7e2", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// Characters and their corresponding confusables were collected from\n-// https://www.unicode.org/Public/security/10.0.0/confusables.txt\n+//! Characters and their corresponding confusables were collected from\n+//! <https://www.unicode.org/Public/security/10.0.0/confusables.txt>\n \n use super::StringReader;\n use crate::token::{self, Delimiter};"}, {"sha": "a084a7010885927344a3e24e834cd27e03e00fcb", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -50,7 +50,7 @@ impl AttrWrapper {\n         self.attrs\n     }\n \n-    // Prepend `self.attrs` to `attrs`.\n+    /// Prepend `self.attrs` to `attrs`.\n     // FIXME: require passing an NT to prevent misuse of this method\n     pub(crate) fn prepend_to_nt_inner(self, attrs: &mut AttrVec) {\n         let mut self_attrs = self.attrs;"}, {"sha": "c316a4dd6b41ad346527e1ff0b31512d06434a0f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -224,9 +224,9 @@ impl MultiSugg {\n     }\n }\n \n-// SnapshotParser is used to create a snapshot of the parser\n-// without causing duplicate errors being emitted when the `Parser`\n-// is dropped.\n+/// SnapshotParser is used to create a snapshot of the parser\n+/// without causing duplicate errors being emitted when the `Parser`\n+/// is dropped.\n pub struct SnapshotParser<'a> {\n     parser: Parser<'a>,\n     unclosed_delims: Vec<UnmatchedBrace>,"}, {"sha": "d0f35b27c19fce6c88250aad6cdad3d7003288d4", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -779,26 +779,26 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    // Returns true if the given node has been marked as red during the\n-    // current compilation session. Used in various assertions\n+    /// Returns true if the given node has been marked as red during the\n+    /// current compilation session. Used in various assertions\n     pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node) == Some(DepNodeColor::Red)\n     }\n \n-    // Returns true if the given node has been marked as green during the\n-    // current compilation session. Used in various assertions\n+    /// Returns true if the given node has been marked as green during the\n+    /// current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node).map_or(false, |c| c.is_green())\n     }\n \n-    // This method loads all on-disk cacheable query results into memory, so\n-    // they can be written out to the new cache file again. Most query results\n-    // will already be in memory but in the case where we marked something as\n-    // green but then did not need the value, that value will never have been\n-    // loaded from disk.\n-    //\n-    // This method will only load queries that will end up in the disk cache.\n-    // Other queries will not be executed.\n+    /// This method loads all on-disk cacheable query results into memory, so\n+    /// they can be written out to the new cache file again. Most query results\n+    /// will already be in memory but in the case where we marked something as\n+    /// green but then did not need the value, that value will never have been\n+    /// loaded from disk.\n+    ///\n+    /// This method will only load queries that will end up in the disk cache.\n+    /// Other queries will not be executed.\n     pub fn exec_cache_promotions<Tcx: DepContext<DepKind = K>>(&self, tcx: Tcx) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n "}, {"sha": "2366b94732e0e8f38c4553fa632167e63dcc870c", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -196,7 +196,7 @@ pub(crate) struct NameResolution<'a> {\n }\n \n impl<'a> NameResolution<'a> {\n-    // Returns the binding for the name if it is known or None if it not known.\n+    /// Returns the binding for the name if it is known or None if it not known.\n     pub(crate) fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| {\n             if !binding.is_glob_import() || self.single_imports.is_empty() {\n@@ -228,8 +228,8 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n }\n \n impl<'a> Resolver<'a> {\n-    // Given a binding and an import that resolves to it,\n-    // return the corresponding binding defined by the import.\n+    /// Given a binding and an import that resolves to it,\n+    /// return the corresponding binding defined by the import.\n     pub(crate) fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n@@ -261,7 +261,7 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    // Define the name or return the existing binding if there is a collision.\n+    /// Define the name or return the existing binding if there is a collision.\n     pub(crate) fn try_define(\n         &mut self,\n         module: Module<'a>,"}, {"sha": "4fa0c14715e01ece4869c52c9d56dde50faa5e05", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> SaveContext<'tcx> {\n         }\n     }\n \n-    // Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n+    /// Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n     pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n         let sess = &self.tcx.sess;\n         // Save-analysis is emitted per whole session, not per each crate type\n@@ -112,7 +112,7 @@ impl<'tcx> SaveContext<'tcx> {\n         }\n     }\n \n-    // List external crates used by the current crate.\n+    /// List external crates used by the current crate.\n     pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n         let mut result = Vec::with_capacity(self.tcx.crates(()).len());\n "}, {"sha": "a6cdd32f23b8e5048e07c3448461db3f1f895577", "filename": "compiler/rustc_serialize/src/leb128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -7,7 +7,7 @@ macro_rules! max_leb128_len {\n     };\n }\n \n-// Returns the longest LEB128 encoding of all supported integer types.\n+/// Returns the longest LEB128 encoding of all supported integer types.\n pub const fn max_leb128_len() -> usize {\n     max_leb128_len!(u128)\n }"}, {"sha": "7c54df809f1791a985af793eac09b0986f4a39de", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -155,19 +155,19 @@ impl Encoder for MemEncoder {\n \n pub type FileEncodeResult = Result<usize, io::Error>;\n \n-// `FileEncoder` encodes data to file via fixed-size buffer.\n-//\n-// When encoding large amounts of data to a file, using `FileEncoder` may be\n-// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n-// `Vec` to file, as the latter uses as much memory as there is encoded data,\n-// while the former uses the fixed amount of memory allocated to the buffer.\n-// `FileEncoder` also has the advantage of not needing to reallocate as data\n-// is appended to it, but the disadvantage of requiring more error handling,\n-// which has some runtime overhead.\n+/// `FileEncoder` encodes data to file via fixed-size buffer.\n+///\n+/// When encoding large amounts of data to a file, using `FileEncoder` may be\n+/// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n+/// `Vec` to file, as the latter uses as much memory as there is encoded data,\n+/// while the former uses the fixed amount of memory allocated to the buffer.\n+/// `FileEncoder` also has the advantage of not needing to reallocate as data\n+/// is appended to it, but the disadvantage of requiring more error handling,\n+/// which has some runtime overhead.\n pub struct FileEncoder {\n-    // The input buffer. For adequate performance, we need more control over\n-    // buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n-    // buffer access API, we can use it, and remove `buf` and `buffered`.\n+    /// The input buffer. For adequate performance, we need more control over\n+    /// buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n+    /// buffer access API, we can use it, and remove `buf` and `buffered`.\n     buf: Box<[MaybeUninit<u8>]>,\n     buffered: usize,\n     flushed: usize,\n@@ -711,7 +711,7 @@ impl<'a> Decodable<MemDecoder<'a>> for Vec<u8> {\n     }\n }\n \n-// An integer that will always encode to 8 bytes.\n+/// An integer that will always encode to 8 bytes.\n pub struct IntEncodedWithFixedSize(pub u64);\n \n impl IntEncodedWithFixedSize {"}, {"sha": "1065cd384a94d21c5ba241154d870a0482c03fc0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -78,10 +78,10 @@ use sha2::Sha256;\n #[cfg(test)]\n mod tests;\n \n-// Per-session global variables: this struct is stored in thread-local storage\n-// in such a way that it is accessible without any kind of handle to all\n-// threads within the compilation session, but is not accessible outside the\n-// session.\n+/// Per-session global variables: this struct is stored in thread-local storage\n+/// in such a way that it is accessible without any kind of handle to all\n+/// threads within the compilation session, but is not accessible outside the\n+/// session.\n pub struct SessionGlobals {\n     symbol_interner: symbol::Interner,\n     span_interner: Lock<span_encoding::SpanInterner>,\n@@ -359,8 +359,8 @@ impl FileName {\n         FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Remapped }\n     }\n \n-    // This may include transient local filesystem information.\n-    // Must not be embedded in build outputs.\n+    /// This may include transient local filesystem information.\n+    /// Must not be embedded in build outputs.\n     pub fn prefer_local(&self) -> FileNameDisplay<'_> {\n         FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Local }\n     }\n@@ -751,7 +751,7 @@ impl Span {\n \n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint.\n-    //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n+    /// (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(self) -> bool {\n         self.ctxt().outer_expn_data().allow_internal_unsafe\n     }"}, {"sha": "2ae57d9e56d7c5ce3ec0ff45c06bb8986fe231c2", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -130,14 +130,14 @@ impl FileLoader for RealFileLoader {\n /// different has no real downsides.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n pub struct StableSourceFileId {\n-    // A hash of the source file's FileName. This is hash so that it's size\n-    // is more predictable than if we included the actual FileName value.\n+    /// A hash of the source file's [`FileName`]. This is hash so that it's size\n+    /// is more predictable than if we included the actual [`FileName`] value.\n     pub file_name_hash: u64,\n \n-    // The CrateNum of the crate this source file was originally parsed for.\n-    // We cannot include this information in the hash because at the time\n-    // of hashing we don't have the context to map from the CrateNum's numeric\n-    // value to a StableCrateId.\n+    /// The [`CrateNum`] of the crate this source file was originally parsed for.\n+    /// We cannot include this information in the hash because at the time\n+    /// of hashing we don't have the context to map from the [`CrateNum`]'s numeric\n+    /// value to a `StableCrateId`.\n     pub cnum: CrateNum,\n }\n \n@@ -402,7 +402,7 @@ impl SourceMap {\n         source_file\n     }\n \n-    // If there is a doctest offset, applies it to the line.\n+    /// If there is a doctest offset, applies it to the line.\n     pub fn doctest_offset_line(&self, file: &FileName, orig: usize) -> usize {\n         match file {\n             FileName::DocTest(_, offset) => {\n@@ -429,7 +429,7 @@ impl SourceMap {\n         Loc { file: sf, line, col, col_display }\n     }\n \n-    // If the corresponding `SourceFile` is empty, does not return a line number.\n+    /// If the corresponding `SourceFile` is empty, does not return a line number.\n     pub fn lookup_line(&self, pos: BytePos) -> Result<SourceFileAndLine, Lrc<SourceFile>> {\n         let f = self.lookup_source_file(pos);\n \n@@ -1053,9 +1053,9 @@ impl SourceMap {\n         SourceFileAndBytePos { sf, pos: offset }\n     }\n \n-    // Returns the index of the `SourceFile` (in `self.files`) that contains `pos`.\n-    // This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n-    // since `source_files` is a `MonotonicVec`\n+    /// Returns the index of the [`SourceFile`] (in `self.files`) that contains `pos`.\n+    /// This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n+    /// since `source_files` is a `MonotonicVec`\n     pub fn lookup_source_file_idx(&self, pos: BytePos) -> usize {\n         self.files\n             .borrow()"}, {"sha": "739716cfce382daa5e21da8680fd270525a32a48", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -2051,8 +2051,8 @@ impl Symbol {\n }\n \n impl Ident {\n-    // Returns `true` for reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n+    /// Returns `true` for reserved identifiers used internally for elided lifetimes,\n+    /// unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special(self) -> bool {\n         self.name.is_special()\n     }"}, {"sha": "1a583cf78137186d8418e205919259e5e6c85aad", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1650,9 +1650,9 @@ pub struct TargetOptions {\n \n     /// Flag indicating whether #[thread_local] is available for this target.\n     pub has_thread_local: bool,\n-    // This is mainly for easy compatibility with emscripten.\n-    // If we give emcc .o files that are actually .bc files it\n-    // will 'just work'.\n+    /// This is mainly for easy compatibility with emscripten.\n+    /// If we give emcc .o files that are actually .bc files it\n+    /// will 'just work'.\n     pub obj_is_bitcode: bool,\n     /// Whether the target requires that emitted object code includes bitcode.\n     pub forces_embed_bitcode: bool,\n@@ -1792,12 +1792,12 @@ pub struct TargetOptions {\n     /// since this is most common among tier 1 and tier 2 targets.\n     pub supports_stack_protector: bool,\n \n-    // The name of entry function.\n-    // Default value is \"main\"\n+    /// The name of entry function.\n+    /// Default value is \"main\"\n     pub entry_name: StaticCow<str>,\n \n-    // The ABI of entry function.\n-    // Default value is `Conv::C`, i.e. C call convention\n+    /// The ABI of entry function.\n+    /// Default value is `Conv::C`, i.e. C call convention\n     pub entry_abi: Conv,\n }\n "}, {"sha": "bbb35e752e7b6120e2be0b603389789e04a127c1", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -861,7 +861,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     }\n }\n \n-// Replaces all ReVars in a type with ty::Region's, using the provided map\n+/// Replaces all ReVars in a type with ty::Region's, using the provided map\n pub struct RegionReplacer<'a, 'tcx> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "ddc1be70b7f99b931a2758feac64d0be688410f8", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -829,7 +829,7 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n     }\n }\n \n-// The inverse of `BoundVarReplacer`: replaces placeholders with the bound vars from which they came.\n+/// The inverse of [`BoundVarReplacer`]: replaces placeholders with the bound vars from which they came.\n pub struct PlaceholderReplacer<'me, 'tcx> {\n     infcx: &'me InferCtxt<'tcx>,\n     mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,"}, {"sha": "a251a508b48cf1777f4d86e62583066eb8caa0b7", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -230,7 +230,7 @@ fn fulfill_implication<'tcx>(\n     Ok(infcx.resolve_vars_if_possible(target_substs))\n }\n \n-// Query provider for `specialization_graph_of`.\n+/// Query provider for `specialization_graph_of`.\n pub(super) fn specialization_graph_provider(\n     tcx: TyCtxt<'_>,\n     trait_id: DefId,"}, {"sha": "2894b19877cc72283c2d3f08d29b0104025ddf7e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -115,7 +115,6 @@ impl From<DefId> for ItemId {\n #[derive(Clone, Debug)]\n pub(crate) struct Crate {\n     pub(crate) module: Item,\n-    pub(crate) primitives: ThinVec<(DefId, PrimitiveType)>,\n     /// Only here so that they can be filtered through the rustdoc passes.\n     pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n }\n@@ -2572,7 +2571,7 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n-    static_assert_size!(Crate, 72); // frequently moved by-value\n+    static_assert_size!(Crate, 64); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n     static_assert_size!(GenericArg, 32);\n     static_assert_size!(GenericArgs, 32);"}, {"sha": "3c48dd80b6fc5fd611eab89184a948a9bc2751b1", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n         }));\n     }\n \n-    Crate { module, primitives, external_traits: cx.external_traits.clone() }\n+    Crate { module, external_traits: cx.external_traits.clone() }\n }\n \n pub(crate) fn substs_to_args<'tcx>("}, {"sha": "d57f981d51a84fac39729d530f055d8324a8d68c", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -8,7 +8,7 @@ use crate::formats::cache::Cache;\n use crate::visit::DocVisitor;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::{self, DefIdTree};\n use rustc_span::symbol::sym;\n \n@@ -25,7 +25,9 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         synth.impls\n     });\n \n-    let prims: FxHashSet<PrimitiveType> = krate.primitives.iter().map(|p| p.1).collect();\n+    let local_crate = ExternalCrate { crate_num: LOCAL_CRATE };\n+    let prims: FxHashSet<PrimitiveType> =\n+        local_crate.primitives(cx.tcx).iter().map(|p| p.1).collect();\n \n     let crate_items = {\n         let mut coll = ItemCollector::new();"}, {"sha": "38d01f7f612a5a0cbd99dcf05d24c4a8aeff3e83", "filename": "src/test/rustdoc-gui/sidebar-mobile.goml", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -54,23 +54,35 @@ compare-elements-position-near: (\".block.keyword li:nth-child(1)\", \".mobile-topb\n \n // Now checking the background color of the sidebar.\n show-text: true\n-local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"dark\"}\n-reload:\n \n-// Open the sidebar menu.\n-click: \".sidebar-menu-toggle\"\n-assert-css: (\".sidebar\", {\"background-color\": \"rgb(80, 80, 80)\", \"color\": \"rgb(221, 221, 221)\"})\n-\n-local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"ayu\"}\n-reload:\n-\n-// Open the sidebar menu.\n-click: \".sidebar-menu-toggle\"\n-assert-css: (\".sidebar\", {\"background-color\": \"rgb(20, 25, 31)\", \"color\": \"rgb(197, 197, 197)\"})\n+define-function: (\n+    \"check-colors\",\n+    (theme, color, background),\n+    [\n+        (\"local-storage\", {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": |theme|}),\n+        (\"reload\"),\n \n-local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"light\"}\n-reload:\n+        // Open the sidebar menu.\n+        (\"click\", \".sidebar-menu-toggle\"),\n+        (\"assert-css\", (\".sidebar\", {\n+            \"background-color\": |background|,\n+            \"color\": |color|,\n+        })),\n+    ],\n+)\n \n-// Open the sidebar menu.\n-click: \".sidebar-menu-toggle\"\n-assert-css: (\".sidebar\", {\"background-color\": \"rgb(245, 245, 245)\", \"color\": \"rgb(0, 0, 0)\"})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"ayu\",\n+    \"color\": \"rgb(197, 197, 197)\",\n+    \"background\": \"rgb(20, 25, 31)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"dark\",\n+    \"color\": \"rgb(221, 221, 221)\",\n+    \"background\": \"rgb(80, 80, 80)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"light\",\n+    \"color\": \"rgb(0, 0, 0)\",\n+    \"background\": \"rgb(245, 245, 245)\",\n+})"}, {"sha": "527de780d48923c5d2b3ba501ed5e2f8b4b20397", "filename": "src/test/rustdoc/deref-to-primitive.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftest%2Frustdoc%2Fderef-to-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftest%2Frustdoc%2Fderef-to-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-to-primitive.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,15 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Foo.html'\n+// @has - '//*[@id=\"deref-methods-i32\"]' 'Methods from Deref<Target = i32>'\n+// @has - '//*[@id=\"deref-methods-i32-1\"]//*[@id=\"associatedconstant.BITS\"]/h4' \\\n+//        'pub const BITS: u32 = 32u32'\n+pub struct Foo(i32);\n+\n+impl std::ops::Deref for Foo {\n+    type Target = i32;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}"}, {"sha": "c63f356607d0750a1406053fa1a0250d3c3fd424", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -296,6 +296,13 @@ needed.\n \n ### Exporting changes to the rustc repo\n \n+Keep in mind that pushing is the most complicated job that josh has to do --\n+pulling just filters the rustc history, but pushing needs to construct a new\n+rustc history that would filter to the given Miri history! To avoid problems, it\n+is a good idea to always pull immediately before you push. In particular, you\n+should never do two josh pushes without an intermediate pull; that can lead to\n+duplicated commits.\n+\n Josh needs to be running, as described above. We will use the josh proxy to push\n to your fork of rustc. Run the following in the Miri repo, assuming we are on an\n up-to-date master branch:"}, {"sha": "64b3187305e1af975c2c8a823d038f7cb20280d7", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -281,9 +281,10 @@ pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n         }\n         info.store(&filename);\n-        // For Windows, do the same thing again with `.exe` appended to the filename.\n+        // For Windows and WASM, do the same thing again with `.exe`/`.wasm` appended to the filename.\n         // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n         info.store(&out_filename(\"\", \".exe\"));\n+        info.store(&out_filename(\"\", \".wasm\"));\n     };\n \n     let runnable_crate = !info_query && is_runnable_crate();"}, {"sha": "dd2d2abe35b539cff216bfabbd848718d8d3c8b1", "filename": "src/tools/miri/ci.sh", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,6 +1,17 @@\n #!/bin/bash\n set -euo pipefail\n-set -x\n+\n+function begingroup {\n+  echo \"::group::$@\"\n+  set -x\n+}\n+\n+function endgroup {\n+  set +x\n+  echo \"::endgroup\"\n+}\n+\n+begingroup \"Building Miri\"\n \n # Determine configuration for installed build\n echo \"Installing release version of Miri\"\n@@ -14,14 +25,15 @@ export CARGO_EXTRA_FLAGS=\"--locked\"\n ./miri check --no-default-features # make sure this can be built\n ./miri check --all-features # and this, too\n ./miri build --all-targets # the build that all the `./miri test` below will use\n-echo\n+\n+endgroup\n \n # Test\n function run_tests {\n   if [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n-    echo \"Testing foreign architecture $MIRI_TEST_TARGET\"\n+    begingroup \"Testing foreign architecture $MIRI_TEST_TARGET\"\n   else\n-    echo \"Testing host architecture\"\n+    begingroup \"Testing host architecture\"\n   fi\n \n   ## ui test suite\n@@ -52,7 +64,6 @@ function run_tests {\n   echo 'build.rustc-wrapper = \"thisdoesnotexist\"' > .cargo/config.toml\n   # Run the actual test\n   ${PYTHON} test-cargo-miri/run-test.py\n-  echo\n   # Clean up\n   unset RUSTC MIRI\n   rm -rf .cargo\n@@ -63,16 +74,23 @@ function run_tests {\n       cargo miri run --manifest-path bench-cargo-miri/$BENCH/Cargo.toml\n     done\n   fi\n+\n+  endgroup\n }\n \n function run_tests_minimal {\n   if [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n-    echo \"Testing MINIMAL foreign architecture $MIRI_TEST_TARGET: only testing $@\"\n+    begingroup \"Testing MINIMAL foreign architecture $MIRI_TEST_TARGET: only testing $@\"\n   else\n-    echo \"Testing MINIMAL host architecture: only testing $@\"\n+    begingroup \"Testing MINIMAL host architecture: only testing $@\"\n   fi\n \n   ./miri test -- \"$@\"\n+\n+  # Ensure that a small smoke test of cargo-miri works.\n+  cargo miri run --manifest-path test-cargo-miri/no-std-smoke/Cargo.toml --target ${MIRI_TEST_TARGET-$HOST_TARGET}\n+\n+  endgroup\n }\n \n # host\n@@ -85,6 +103,7 @@ case $HOST_TARGET in\n     MIRI_TEST_TARGET=i686-pc-windows-msvc run_tests\n     MIRI_TEST_TARGET=x86_64-unknown-freebsd run_tests_minimal hello integer vec panic/panic concurrency/simple atomic data_race env/var\n     MIRI_TEST_TARGET=aarch64-linux-android run_tests_minimal hello integer vec panic/panic\n+    MIRI_TEST_TARGET=wasm32-wasi MIRI_NO_STD=1 run_tests_minimal no_std # supports std but miri doesn't support it\n     MIRI_TEST_TARGET=thumbv7em-none-eabihf MIRI_NO_STD=1 run_tests_minimal no_std # no_std embedded architecture\n     ;;\n   x86_64-apple-darwin)"}, {"sha": "851ef39274094b6796e2e418de59f7e192fb0c64", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1 +1 @@\n-7477c1f4f7d6bef037d523099b240d22aa1b63a0\n+454784afba5bf35b5ff14ada0e31265ad1d75e73"}, {"sha": "d669cc1362a9a7a06a31536c8899cf5ae5d3dce9", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -838,18 +838,18 @@ impl VClockAlloc {\n         &self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         \"Read\",\n                         false,\n@@ -869,17 +869,17 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         write_type: WriteType,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -901,10 +901,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Write, machine)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -915,10 +914,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, machine)\n     }\n }\n "}, {"sha": "dacb3a9b88f8f660f67bb234c552f7fbf90960f3", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -118,6 +118,13 @@ pub struct Thread<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n \n+    /// The index of the topmost user-relevant frame in `stack`. This field must contain\n+    /// the value produced by `get_top_user_relevant_frame`.\n+    /// The `None` state here represents\n+    /// This field is a cache to reduce how often we call that method. The cache is manually\n+    /// maintained inside `MiriMachine::after_stack_push` and `MiriMachine::after_stack_pop`.\n+    top_user_relevant_frame: Option<usize>,\n+\n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n@@ -147,6 +154,40 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     fn thread_name(&self) -> &[u8] {\n         if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n     }\n+\n+    /// Return the top user-relevant frame, if there is one.\n+    /// Note that the choice to return `None` here when there is no user-relevant frame is part of\n+    /// justifying the optimization that only pushes of user-relevant frames require updating the\n+    /// `top_user_relevant_frame` field.\n+    fn compute_top_user_relevant_frame(&self) -> Option<usize> {\n+        self.stack\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(idx, frame)| if frame.extra.is_user_relevant { Some(idx) } else { None })\n+    }\n+\n+    /// Re-compute the top user-relevant frame from scratch.\n+    pub fn recompute_top_user_relevant_frame(&mut self) {\n+        self.top_user_relevant_frame = self.compute_top_user_relevant_frame();\n+    }\n+\n+    /// Set the top user-relevant frame to the given value. Must be equal to what\n+    /// `get_top_user_relevant_frame` would return!\n+    pub fn set_top_user_relevant_frame(&mut self, frame_idx: usize) {\n+        debug_assert_eq!(Some(frame_idx), self.compute_top_user_relevant_frame());\n+        self.top_user_relevant_frame = Some(frame_idx);\n+    }\n+\n+    /// Returns the topmost frame that is considered user-relevant, or the\n+    /// top of the stack if there is no such frame, or `None` if the stack is empty.\n+    pub fn top_user_relevant_frame(&self) -> Option<usize> {\n+        debug_assert_eq!(self.top_user_relevant_frame, self.compute_top_user_relevant_frame());\n+        // This can be called upon creation of an allocation. We create allocations while setting up\n+        // parts of the Rust runtime when we do not have any stack frames yet, so we need to handle\n+        // empty stacks.\n+        self.top_user_relevant_frame.or_else(|| self.stack.len().checked_sub(1))\n+    }\n }\n \n impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n@@ -167,6 +208,7 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n             state: ThreadState::Enabled,\n             thread_name: None,\n             stack: Vec::new(),\n+            top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n             panic_payload: None,\n             last_error: None,\n@@ -184,8 +226,15 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n \n impl VisitTags for Thread<'_, '_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let Thread { panic_payload, last_error, stack, state: _, thread_name: _, join_status: _ } =\n-            self;\n+        let Thread {\n+            panic_payload,\n+            last_error,\n+            stack,\n+            top_user_relevant_frame: _,\n+            state: _,\n+            thread_name: _,\n+            join_status: _,\n+        } = self;\n \n         panic_payload.visit_tags(visit);\n         last_error.visit_tags(visit);\n@@ -414,7 +463,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a shared borrow of the currently active thread.\n-    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+    pub fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n         &self.threads[self.active_thread]\n     }\n "}, {"sha": "363b647d6c684fd6e95e04a7244f7217c1073d4e", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -9,6 +9,7 @@ use std::thread;\n use log::info;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{\n     self,\n@@ -195,7 +196,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     MiriMachine::late_init(&mut ecx, config)?;\n \n     // Make sure we have MIR. We check MIR for some stable monomorphic function in libcore.\n-    let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"]);\n+    let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"], Namespace::ValueNS);\n     if !matches!(sentinel, Some(s) if tcx.is_mir_available(s.def.def_id())) {\n         tcx.sess.fatal(\n             \"the current sysroot was built without `-Zalways-encode-mir`, or libcore seems missing. \\"}, {"sha": "f0d8b6768810c720fc7c367d90de6e9ef68c852e", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -2,12 +2,12 @@ pub mod convert;\n \n use std::cmp;\n use std::iter;\n-use std::mem;\n use std::num::NonZeroUsize;\n use std::time::Duration;\n \n use log::trace;\n \n+use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_middle::mir;\n use rustc_middle::ty::{\n@@ -74,48 +74,75 @@ const UNIX_IO_ERROR_TABLE: &[(&str, std::io::ErrorKind)] = {\n };\n \n /// Gets an instance for a path.\n-fn try_resolve_did<'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n-    tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == path[0]).and_then(\n-        |krate| {\n-            let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n-            let mut items = tcx.module_children(krate);\n-            let mut path_it = path.iter().skip(1).peekable();\n-\n-            while let Some(segment) = path_it.next() {\n-                for item in mem::take(&mut items).iter() {\n-                    if item.ident.name.as_str() == *segment {\n-                        if path_it.peek().is_none() {\n-                            return Some(item.res.def_id());\n-                        }\n+///\n+/// A `None` namespace indicates we are looking for a module.\n+fn try_resolve_did(tcx: TyCtxt<'_>, path: &[&str], namespace: Option<Namespace>) -> Option<DefId> {\n+    /// Yield all children of the given item, that have the given name.\n+    fn find_children<'tcx: 'a, 'a>(\n+        tcx: TyCtxt<'tcx>,\n+        item: DefId,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = DefId> + 'a {\n+        tcx.module_children(item)\n+            .iter()\n+            .filter(move |item| item.ident.name.as_str() == name)\n+            .map(move |item| item.res.def_id())\n+    }\n \n-                        items = tcx.module_children(item.res.def_id());\n-                        break;\n-                    }\n-                }\n-            }\n-            None\n-        },\n-    )\n+    // Take apart the path: leading crate, a sequence of modules, and potentially a final item.\n+    let (&crate_name, path) = path.split_first().expect(\"paths must have at least one segment\");\n+    let (modules, item) = if let Some(namespace) = namespace {\n+        let (&item_name, modules) =\n+            path.split_last().expect(\"non-module paths must have at least 2 segments\");\n+        (modules, Some((item_name, namespace)))\n+    } else {\n+        (path, None)\n+    };\n+\n+    // First find the crate.\n+    let krate =\n+        tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == crate_name)?;\n+    let mut cur_item = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n+    // Then go over the modules.\n+    for &segment in modules {\n+        cur_item = find_children(tcx, cur_item, segment)\n+            .find(|item| tcx.def_kind(item) == DefKind::Mod)?;\n+    }\n+    // Finally, look up the desired item in this module, if any.\n+    match item {\n+        Some((item_name, namespace)) =>\n+            Some(\n+                find_children(tcx, cur_item, item_name)\n+                    .find(|item| tcx.def_kind(item).ns() == Some(namespace))?,\n+            ),\n+        None => Some(cur_item),\n+    }\n }\n \n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Checks if the given crate/module exists.\n+    fn have_module(&self, path: &[&str]) -> bool {\n+        try_resolve_did(*self.eval_context_ref().tcx, path, None).is_some()\n+    }\n+\n     /// Gets an instance for a path; fails gracefully if the path does not exist.\n-    fn try_resolve_path(&self, path: &[&str]) -> Option<ty::Instance<'tcx>> {\n-        let did = try_resolve_did(self.eval_context_ref().tcx.tcx, path)?;\n-        Some(ty::Instance::mono(self.eval_context_ref().tcx.tcx, did))\n+    fn try_resolve_path(&self, path: &[&str], namespace: Namespace) -> Option<ty::Instance<'tcx>> {\n+        let tcx = self.eval_context_ref().tcx.tcx;\n+        let did = try_resolve_did(tcx, path, Some(namespace))?;\n+        Some(ty::Instance::mono(tcx, did))\n     }\n \n     /// Gets an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> ty::Instance<'tcx> {\n-        self.try_resolve_path(path)\n+    fn resolve_path(&self, path: &[&str], namespace: Namespace) -> ty::Instance<'tcx> {\n+        self.try_resolve_path(path, namespace)\n             .unwrap_or_else(|| panic!(\"failed to find required Rust item: {path:?}\"))\n     }\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n     fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n-        let instance = this.resolve_path(path);\n+        let instance = this.resolve_path(path, Namespace::ValueNS);\n         let cid = GlobalId { instance, promoted: None };\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n         let const_val = this.eval_global(cid, None)?;\n@@ -147,15 +174,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Helper function to get the `TyAndLayout` of a `libc` type\n     fn libc_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n         let this = self.eval_context_ref();\n-        let ty = this.resolve_path(&[\"libc\", name]).ty(*this.tcx, ty::ParamEnv::reveal_all());\n+        let ty = this\n+            .resolve_path(&[\"libc\", name], Namespace::TypeNS)\n+            .ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `windows` type\n     fn windows_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n         let this = self.eval_context_ref();\n         let ty = this\n-            .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name])\n+            .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name], Namespace::TypeNS)\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n@@ -936,78 +965,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n-    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { current_frame_idx: None, machine: self }\n-    }\n-}\n-\n-/// A `CurrentSpan` should be created infrequently (ideally once) per interpreter step. It does\n-/// nothing on creation, but when `CurrentSpan::get` is called, searches the current stack for the\n-/// topmost frame which corresponds to a local crate, and returns the current span in that frame.\n-/// The result of that search is cached so that later calls are approximately free.\n-#[derive(Clone)]\n-pub struct CurrentSpan<'a, 'mir, 'tcx> {\n-    current_frame_idx: Option<usize>,\n-    machine: &'a MiriMachine<'mir, 'tcx>,\n-}\n-\n-impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n-    pub fn machine(&self) -> &'a MiriMachine<'mir, 'tcx> {\n-        self.machine\n-    }\n-\n-    /// Get the current span, skipping non-local frames.\n+    /// Get the current span in the topmost function which is workspace-local and not\n+    /// `#[track_caller]`.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n-    pub fn get(&mut self) -> Span {\n-        let idx = self.current_frame_idx();\n-        self.stack().get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+    /// It will work even when the stack is empty.\n+    pub fn current_span(&self) -> Span {\n+        self.top_user_relevant_frame()\n+            .map(|frame_idx| self.stack()[frame_idx].current_span())\n+            .unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n     /// Returns the span of the *caller* of the current operation, again\n     /// walking down the stack to find the closest frame in a local crate, if the caller of the\n     /// current operation is not in a local crate.\n     /// This is useful when we are processing something which occurs on function-entry and we want\n     /// to point at the call to the function, not the function definition generally.\n-    pub fn get_caller(&mut self) -> Span {\n+    pub fn caller_span(&self) -> Span {\n         // We need to go down at least to the caller (len - 2), or however\n-        // far we have to go to find a frame in a local crate.\n-        let local_frame_idx = self.current_frame_idx();\n-        let stack = self.stack();\n-        let idx = cmp::min(local_frame_idx, stack.len().saturating_sub(2));\n-        stack.get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+        // far we have to go to find a frame in a local crate which is also not #[track_caller].\n+        let frame_idx = self.top_user_relevant_frame().unwrap();\n+        let frame_idx = cmp::min(frame_idx, self.stack().len().checked_sub(2).unwrap());\n+        self.stack()[frame_idx].current_span()\n     }\n \n     fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameData<'tcx>>] {\n-        self.machine.threads.active_thread_stack()\n+        self.threads.active_thread_stack()\n     }\n \n-    fn current_frame_idx(&mut self) -> usize {\n-        *self\n-            .current_frame_idx\n-            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n+    fn top_user_relevant_frame(&self) -> Option<usize> {\n+        self.threads.active_thread_ref().top_user_relevant_frame()\n     }\n \n-    // Find the position of the inner-most frame which is part of the crate being\n-    // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n-    #[inline(never)]\n-    fn compute_current_frame_index(machine: &MiriMachine<'_, '_>) -> usize {\n-        machine\n-            .threads\n-            .active_thread_stack()\n-            .iter()\n-            .enumerate()\n-            .rev()\n-            .find_map(|(idx, frame)| {\n-                let def_id = frame.instance.def_id();\n-                if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n-                    && !frame.instance.def.requires_caller_location(machine.tcx)\n-                {\n-                    Some(idx)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(0)\n+    /// This is the source of truth for the `is_user_relevant` flag in our `FrameExtra`.\n+    pub fn is_user_relevant(&self, frame: &Frame<'mir, 'tcx, Provenance>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        (def_id.is_local() || self.local_crates.contains(&def_id.krate))\n+            && !frame.instance.def.requires_caller_location(self.tcx)\n     }\n }\n "}, {"sha": "8913f8aa10fcdb962e927e93858cb5f6f21ae1b6", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -97,7 +97,7 @@ pub use crate::diagnostics::{\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n+pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,"}, {"sha": "edfef211dc675abcff79b316ed1f6335a18cf3df", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 33, "deletions": 46, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -50,12 +50,18 @@ pub struct FrameData<'tcx> {\n     /// for the start of this frame. When we finish executing this frame,\n     /// we use this to register a completed event with `measureme`.\n     pub timing: Option<measureme::DetachedTiming>,\n+\n+    /// Indicates whether a `Frame` is part of a workspace-local crate and is also not\n+    /// `#[track_caller]`. We compute this once on creation and store the result, as an\n+    /// optimization.\n+    /// This is used by `MiriMachine::current_span` and `MiriMachine::caller_span`\n+    pub is_user_relevant: bool,\n }\n \n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n+        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n             .field(\"stacked_borrows\", stacked_borrows)\n             .field(\"catch_unwind\", catch_unwind)\n@@ -65,7 +71,7 @@ impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n \n impl VisitTags for FrameData<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _ } = self;\n+        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n         stacked_borrows.visit_tags(visit);\n@@ -895,13 +901,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n         let alloc = alloc.into_owned();\n         let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                ecx.machine.current_span(),\n-            )\n+            Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind, &ecx.machine)\n         });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n@@ -1003,22 +1003,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_ref().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.read(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.borrow_mut().before_memory_read(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n-            )?;\n+            stacked_borrows\n+                .borrow_mut()\n+                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1035,22 +1025,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.write(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n-            )?;\n+            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1070,21 +1048,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.deallocate(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().before_memory_deallocation(\n                 alloc_id,\n                 prove_extra,\n                 range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )\n         } else {\n             Ok(())\n@@ -1126,7 +1097,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n+            is_user_relevant: ecx.machine.is_user_relevant(&frame),\n         };\n+\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -1174,6 +1147,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.frame().extra.is_user_relevant {\n+            // We just pushed a local frame, so we know that the topmost local frame is the topmost\n+            // frame. If we push a non-local frame, there's no need to do anything.\n+            let stack_len = ecx.active_thread_stack().len();\n+            ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n+        }\n+\n         if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n@@ -1183,6 +1163,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n+        if frame.extra.is_user_relevant {\n+            // All that we store is whether or not the frame we just removed is local, so now we\n+            // have no idea where the next topmost local frame is. So we recompute it.\n+            // (If this ever becomes a bottleneck, we could have `push` store the previous\n+            // user-relevant frame and restore that here.)\n+            ecx.active_thread_mut().recompute_top_user_relevant_frame();\n+        }\n         let timing = frame.extra.timing.take();\n         if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().end_call(&frame.extra);"}, {"sha": "bc7ca82997bb8e05d663fa4f08b162aa3ea39519", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -18,12 +18,12 @@ pub enum PathConversion {\n }\n \n #[cfg(unix)]\n-pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+pub fn os_str_to_bytes<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, &[u8]> {\n     Ok(os_str.as_bytes())\n }\n \n #[cfg(not(unix))]\n-pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+pub fn os_str_to_bytes<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, &[u8]> {\n     // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n     // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n     // valid.\n@@ -34,11 +34,11 @@ pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u\n }\n \n #[cfg(unix)]\n-pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+pub fn bytes_to_os_str<'tcx>(bytes: &[u8]) -> InterpResult<'tcx, &OsStr> {\n     Ok(OsStr::from_bytes(bytes))\n }\n #[cfg(not(unix))]\n-pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+pub fn bytes_to_os_str<'tcx>(bytes: &[u8]) -> InterpResult<'tcx, &OsStr> {\n     let s = std::str::from_utf8(bytes)\n         .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n     Ok(OsStr::new(s))"}, {"sha": "5fda8bd7b7de9a2c00a891e012914e9cca914f79", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -261,6 +261,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n         // we specifically look up the static in libstd that we know is placed\n         // in that section.\n+        if !this.have_module(&[\"std\"]) {\n+            // Looks like we are running in a `no_std` crate.\n+            // That also means no TLS dtors callback to call.\n+            return Ok(());\n+        }\n         let thread_callback =\n             this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;"}, {"sha": "e048d53a17e0d498630b698711e830ec60b12ac5", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -11,7 +11,6 @@ use std::time::SystemTime;\n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::{self, layout::LayoutOf};\n use rustc_target::abi::{Align, Size};\n \n use crate::shims::os_str::bytes_to_os_str;\n@@ -1006,12 +1005,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n         // `statxbuf_op` by using the `libc::statx` struct type.\n         let statxbuf = {\n-            // FIXME: This long path is required because `libc::statx` is an struct and also a\n-            // function and `resolve_path` is returning the latter.\n-            let statx_ty = this\n-                .resolve_path(&[\"libc\", \"unix\", \"linux_like\", \"linux\", \"gnu\", \"statx\"])\n-                .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-            let statx_layout = this.layout_of(statx_ty)?;\n+            let statx_layout = this.libc_ty_layout(\"statx\")?;\n             MPlaceTy::from_aligned_ptr(statxbuf_ptr, statx_layout)\n         };\n \n@@ -1917,8 +1911,8 @@ struct FileMetadata {\n }\n \n impl FileMetadata {\n-    fn from_path<'tcx, 'mir>(\n-        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+    fn from_path<'tcx>(\n+        ecx: &mut MiriInterpCx<'_, 'tcx>,\n         path: &Path,\n         follow_symlink: bool,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n@@ -1928,8 +1922,8 @@ impl FileMetadata {\n         FileMetadata::from_meta(ecx, metadata)\n     }\n \n-    fn from_fd<'tcx, 'mir>(\n-        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+    fn from_fd<'tcx>(\n+        ecx: &mut MiriInterpCx<'_, 'tcx>,\n         fd: i32,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n@@ -1942,8 +1936,8 @@ impl FileMetadata {\n         FileMetadata::from_meta(ecx, metadata)\n     }\n \n-    fn from_meta<'tcx, 'mir>(\n-        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+    fn from_meta<'tcx>(\n+        ecx: &mut MiriInterpCx<'_, 'tcx>,\n         metadata: Result<std::fs::Metadata, std::io::Error>,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let metadata = match metadata {"}, {"sha": "9970b79f8c7f17838822938cba38c4dbd3a541b2", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 58, "deletions": 68, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -5,8 +5,7 @@ use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use crate::helpers::CurrentSpan;\n-use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission};\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind};\n use crate::*;\n \n use rustc_middle::mir::interpret::InterpError;\n@@ -110,42 +109,29 @@ pub struct TagHistory {\n     pub protected: Option<(String, SpanData)>,\n }\n \n-pub struct DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span cannot be merged with any other lifetime since they appear invariantly, under the\n-    // mutable ref.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n }\n \n-pub struct DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span and 'history cannot be merged, since when we call `unbuild` we need\n-    // to return the exact 'span that was used when calling `build`.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n     history: &'history mut AllocHistory,\n     offset: Size,\n }\n \n-impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+impl<'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     pub fn build<'history>(\n         self,\n         history: &'history mut AllocHistory,\n         offset: Size,\n-    ) -> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCx {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-            history,\n-            offset,\n-        }\n+    ) -> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+        DiagnosticCx { operation: self.operation, machine: self.machine, history, offset }\n     }\n \n     pub fn retag(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         cause: RetagCause,\n         new_tag: SbTag,\n         orig_tag: ProvenanceExtra,\n@@ -154,46 +140,36 @@ impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n         let operation =\n             Operation::Retag(RetagOp { cause, new_tag, orig_tag, range, permission: None });\n \n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn read(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Read, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn write(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Write, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n-    pub fn dealloc(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n-        tag: ProvenanceExtra,\n-    ) -> Self {\n+    pub fn dealloc(machine: &'ecx MiriMachine<'mir, 'tcx>, tag: ProvenanceExtra) -> Self {\n         let operation = Operation::Dealloc(DeallocOp { tag });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-    pub fn unbuild(self) -> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCxBuilder {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-        }\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+    pub fn unbuild(self) -> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+        DiagnosticCxBuilder { machine: self.machine, operation: self.operation }\n     }\n }\n \n@@ -234,18 +210,18 @@ struct DeallocOp {\n }\n \n impl AllocHistory {\n-    pub fn new(id: AllocId, item: Item, current_span: &mut CurrentSpan<'_, '_, '_>) -> Self {\n+    pub fn new(id: AllocId, item: Item, machine: &MiriMachine<'_, '_>) -> Self {\n         Self {\n             id,\n-            base: (item, current_span.get()),\n+            base: (item, machine.current_span()),\n             creations: SmallVec::new(),\n             invalidations: SmallVec::new(),\n             protectors: SmallVec::new(),\n         }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     pub fn start_grant(&mut self, perm: Permission) {\n         let Operation::Retag(op) = &mut self.operation else {\n             unreachable!(\"start_grant must only be called during a retag, this is: {:?}\", self.operation)\n@@ -274,21 +250,27 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"log_creation must only be called during a retag\")\n         };\n-        self.history.creations.push(Creation { retag: op.clone(), span: self.current_span.get() });\n+        self.history\n+            .creations\n+            .push(Creation { retag: op.clone(), span: self.machine.current_span() });\n     }\n \n     pub fn log_invalidation(&mut self, tag: SbTag) {\n-        let mut span = self.current_span.get();\n+        let mut span = self.machine.current_span();\n         let (range, cause) = match &self.operation {\n             Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n                 if *cause == RetagCause::FnEntry {\n-                    span = self.current_span.get_caller();\n+                    span = self.machine.caller_span();\n                 }\n                 (*range, InvalidationCause::Retag(permission.unwrap(), *cause))\n             }\n             Operation::Access(AccessOp { kind, range, .. }) =>\n                 (*range, InvalidationCause::Access(*kind)),\n-            _ => unreachable!(\"Tags can only be invalidated during a retag or access\"),\n+            Operation::Dealloc(_) => {\n+                // This can be reached, but never be relevant later since the entire allocation is\n+                // gone now.\n+                return;\n+            }\n         };\n         self.history.invalidations.push(Invalidation { tag, range, span, cause });\n     }\n@@ -297,7 +279,9 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"Protectors can only be created during a retag\")\n         };\n-        self.history.protectors.push(Protection { tag: op.new_tag, span: self.current_span.get() });\n+        self.history\n+            .protectors\n+            .push(Protection { tag: op.new_tag, span: self.machine.current_span() });\n     }\n \n     pub fn get_logs_relevant_to(\n@@ -369,10 +353,12 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n+    pub(super) fn grant_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"grant_error should only be called during a retag\")\n         };\n+        let perm =\n+            op.permission.expect(\"`start_grant` must be called before calling `grant_error`\");\n         let action = format!(\n             \"trying to retag from {:?} for {:?} permission at {:?}[{:#x}]\",\n             op.orig_tag,\n@@ -389,9 +375,12 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n-        let Operation::Access(op) = &self.operation  else {\n-            unreachable!(\"access_error should only be called during an access\")\n+    pub(super) fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n+        // Deallocation and retagging also do an access as part of their thing, so handle that here, too.\n+        let op = match &self.operation {\n+            Operation::Access(op) => op,\n+            Operation::Retag(_) => return self.grant_error(stack),\n+            Operation::Dealloc(_) => return self.dealloc_error(stack),\n         };\n         let action = format!(\n             \"attempting a {access} using {tag:?} at {alloc_id:?}[{offset:#x}]\",\n@@ -408,8 +397,13 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn protector_error(&self, item: &Item) -> InterpError<'tcx> {\n+    pub(super) fn protector_error(&self, item: &Item, kind: ProtectorKind) -> InterpError<'tcx> {\n+        let protected = match kind {\n+            ProtectorKind::WeakProtector => \"weakly protected\",\n+            ProtectorKind::StrongProtector => \"strongly protected\",\n+        };\n         let call_id = self\n+            .machine\n             .threads\n             .all_stacks()\n             .flatten()\n@@ -422,19 +416,15 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         match self.operation {\n             Operation::Dealloc(_) =>\n                 err_sb_ub(\n-                    format!(\n-                        \"deallocating while item {:?} is protected by call {:?}\",\n-                        item, call_id\n-                    ),\n+                    format!(\"deallocating while item {item:?} is {protected} by call {call_id:?}\",),\n                     None,\n                     None,\n                 ),\n             Operation::Retag(RetagOp { orig_tag: tag, .. })\n             | Operation::Access(AccessOp { tag, .. }) =>\n                 err_sb_ub(\n                     format!(\n-                        \"not granting access to tag {:?} because that would remove {:?} which is protected because it is an argument of call {:?}\",\n-                        tag, item, call_id\n+                        \"not granting access to tag {tag:?} because that would remove {item:?} which is {protected} because it is an argument of call {call_id:?}\",\n                     ),\n                     None,\n                     tag.and_then(|tag| self.get_logs_relevant_to(tag, Some(item.tag()))),\n@@ -443,14 +433,16 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn dealloc_error(&self) -> InterpError<'tcx> {\n+    pub fn dealloc_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Dealloc(op) = &self.operation else {\n             unreachable!(\"dealloc_error should only be called during a deallocation\")\n         };\n         err_sb_ub(\n             format!(\n-                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                op.tag, self.history.id,\n+                \"attempting deallocation using {tag:?} at {alloc_id:?}{cause}\",\n+                tag = op.tag,\n+                alloc_id = self.history.id,\n+                cause = error_cause(stack, op.tag),\n             ),\n             None,\n             op.tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n@@ -478,9 +470,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        self.current_span\n-            .machine()\n-            .emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.machine.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "4e369f4291a3f821c4315e32afe387f0352fb52c", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 173, "deletions": 131, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -65,7 +65,7 @@ pub struct FrameExtra {\n     /// incremental updates of the global list of protected tags stored in the\n     /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n     /// tag, to identify which call is responsible for protecting the tag.\n-    /// See `Stack::item_popped` for more explanation.\n+    /// See `Stack::item_invalidated` for more explanation.\n     ///\n     /// This will contain one tag per reference passed to the function, so\n     /// a size of 2 is enough for the vast majority of functions.\n@@ -91,6 +91,26 @@ pub struct Stacks {\n     modified_since_last_gc: bool,\n }\n \n+/// The flavor of the protector.\n+#[derive(Copy, Clone, Debug)]\n+enum ProtectorKind {\n+    /// Protected against aliasing violations from other pointers.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n+    /// still be used to issue a deallocation.\n+    ///\n+    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n+    WeakProtector,\n+\n+    /// Protected against any kind of invalidation.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n+    /// This is strictly stronger protection than `WeakProtector`.\n+    ///\n+    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n+    StrongProtector,\n+}\n+\n /// Extra global state, available to the memory access hooks.\n #[derive(Debug)]\n pub struct GlobalStateInner {\n@@ -102,12 +122,12 @@ pub struct GlobalStateInner {\n     base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n-    /// All currently protected tags.\n+    /// All currently protected tags, and the status of their protection.\n     /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n     /// We add tags to this when they are created with a protector in `reborrow`, and\n     /// we remove tags from this when the call which is protecting them returns, in\n-    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n-    protected_tags: FxHashSet<SbTag>,\n+    /// `GlobalStateInner::end_call`. See `Stack::item_invalidated` for more details.\n+    protected_tags: FxHashMap<SbTag, ProtectorKind>,\n     /// The pointer ids to trace\n     tracked_pointer_tags: FxHashSet<SbTag>,\n     /// The call ids to trace\n@@ -189,7 +209,7 @@ impl GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n             base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n-            protected_tags: FxHashSet::default(),\n+            protected_tags: FxHashMap::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n             retag_fields,\n@@ -272,6 +292,13 @@ impl Permission {\n     }\n }\n \n+/// Determines whether an item was invalidated by a conflicting access, or by deallocation.\n+#[derive(Copy, Clone, Debug)]\n+enum ItemInvalidationCause {\n+    Conflict,\n+    Dealloc,\n+}\n+\n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n     /// Find the first write-incompatible item above the given one --\n@@ -310,10 +337,11 @@ impl<'tcx> Stack {\n     /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n     /// the `Size` refers to the specific location in the `AllocRange` that we are\n     /// currently checking.\n-    fn item_popped(\n+    fn item_invalidated(\n         item: &Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n+        cause: ItemInvalidationCause,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n             dcx.check_tracked_tag_popped(item, global);\n@@ -336,8 +364,14 @@ impl<'tcx> Stack {\n         // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n         //    which ends up about linear in the number of protected tags in the program into a\n         //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n-        if global.protected_tags.contains(&item.tag()) {\n-            return Err(dcx.protector_error(item).into());\n+        if let Some(&protector_kind) = global.protected_tags.get(&item.tag()) {\n+            // The only way this is okay is if the protector is weak and we are deallocating with\n+            // the right pointer.\n+            let allowed = matches!(cause, ItemInvalidationCause::Dealloc)\n+                && matches!(protector_kind, ProtectorKind::WeakProtector);\n+            if !allowed {\n+                return Err(dcx.protector_error(item, protector_kind).into());\n+            }\n         }\n         Ok(())\n     }\n@@ -350,15 +384,15 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: ProvenanceExtra,\n-        global: &mut GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        global: &GlobalStateInner,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n         let granting_idx =\n-            self.find_granting(access, tag, exposed_tags).map_err(|_| dcx.access_error(self))?;\n+            self.find_granting(access, tag, exposed_tags).map_err(|()| dcx.access_error(self))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -377,7 +411,7 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.pop_items_after(first_incompatible_idx, |item| {\n-                Stack::item_popped(&item, global, dcx)?;\n+                Stack::item_invalidated(&item, global, dcx, ItemInvalidationCause::Conflict)?;\n                 dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n@@ -398,7 +432,7 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.disable_uniques_starting_at(first_incompatible_idx, |item| {\n-                Stack::item_popped(&item, global, dcx)?;\n+                Stack::item_invalidated(&item, global, dcx, ItemInvalidationCause::Conflict)?;\n                 dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n@@ -437,56 +471,59 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n-        // Step 1: Make sure there is a granting item.\n-        self.find_granting(AccessKind::Write, tag, exposed_tags)\n-            .map_err(|_| dcx.dealloc_error())?;\n+        // Step 1: Make a write access.\n+        // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n+        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)?;\n \n-        // Step 2: Consider all items removed. This checks for protectors.\n+        // Step 2: Pretend we remove the remaining items, checking if any are strongly protected.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n-            Stack::item_popped(&item, global, dcx)?;\n+            Stack::item_invalidated(&item, global, dcx, ItemInvalidationCause::Dealloc)?;\n         }\n \n         Ok(())\n     }\n \n     /// Derive a new pointer from one with the given tag.\n-    /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n-    /// an access, and they add the new item directly on top of the one it is derived\n-    /// from instead of all the way at the top of the stack.\n-    /// `range` refers the entire operation, and `offset` refers to the specific location in\n-    /// `range` that we are currently checking.\n+    ///\n+    /// `access` indicates which kind of memory access this retag itself should correspond to.\n     fn grant(\n         &mut self,\n         derived_from: ProvenanceExtra,\n         new: Item,\n-        global: &mut GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        access: Option<AccessKind>,\n+        global: &GlobalStateInner,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n \n-        // Figure out which access `perm` corresponds to.\n-        let access =\n-            if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n-\n-        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n-        // We use that to determine where to put the new item.\n-        let granting_idx = self\n-            .find_granting(access, derived_from, exposed_tags)\n-            .map_err(|_| dcx.grant_error(new.perm(), self))?;\n-\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if new.perm() == Permission::SharedReadWrite {\n-            assert!(\n-                access == AccessKind::Write,\n-                \"this case only makes sense for stack-like accesses\"\n-            );\n+        let new_idx = if let Some(access) = access {\n+            // Simple case: We are just a regular memory access, and then push our thing on top,\n+            // like a regular stack.\n+            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n+            self.access(access, derived_from, global, dcx, exposed_tags)?;\n+\n+            // We insert \"as far up as possible\": We know only compatible items are remaining\n+            // on top of `derived_from`, and we want the new item at the top so that we\n+            // get the strongest possible guarantees.\n+            // This ensures U1 and F1.\n+            self.len()\n+        } else {\n+            // The tricky case: creating a new SRW permission without actually being an access.\n+            assert!(new.perm() == Permission::SharedReadWrite);\n+\n+            // First we figure out which item grants our parent (`derived_from`) this kind of access.\n+            // We use that to determine where to put the new item.\n+            let granting_idx = self\n+                .find_granting(AccessKind::Write, derived_from, exposed_tags)\n+                .map_err(|()| dcx.grant_error(self))?;\n \n             let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n@@ -503,17 +540,6 @@ impl<'tcx> Stack {\n             // be popped to (i.e., we insert it above all the write-compatible items).\n             // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n             self.find_first_write_incompatible(granting_idx)\n-        } else {\n-            // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n-            // Here, creating a reference actually counts as an access.\n-            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, global, dcx, exposed_tags)?;\n-\n-            // We insert \"as far up as possible\": We know only compatible items are remaining\n-            // on top of `derived_from`, and we want the new item at the top so that we\n-            // get the strongest possible guarantees.\n-            // This ensures U1 and F1.\n-            self.len()\n         };\n \n         // Put the new item there.\n@@ -555,14 +581,14 @@ impl<'tcx> Stacks {\n         perm: Permission,\n         tag: SbTag,\n         id: AllocId,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n             stacks: RangeMap::new(size, stack),\n-            history: AllocHistory::new(id, item, current_span),\n+            history: AllocHistory::new(id, item, machine),\n             exposed_tags: FxHashSet::default(),\n             modified_since_last_gc: false,\n         }\n@@ -572,10 +598,10 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &mut self,\n         range: AllocRange,\n-        mut dcx_builder: DiagnosticCxBuilder<'_, '_, '_, 'tcx>,\n+        mut dcx_builder: DiagnosticCxBuilder<'_, '_, 'tcx>,\n         mut f: impl FnMut(\n             &mut Stack,\n-            &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+            &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -596,7 +622,7 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n-        mut current_span: CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -605,12 +631,11 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack =>\n-                (extra.base_ptr_tag(id, current_span.machine()), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_ptr_tag(id, machine), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, current_span.machine()), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n         };\n-        Stacks::new(size, perm, base_tag, id, &mut current_span)\n+        Stacks::new(size, perm, base_tag, id, machine)\n     }\n \n     #[inline(always)]\n@@ -619,9 +644,7 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx>\n     where\n         'tcx: 'ecx,\n@@ -632,49 +655,45 @@ impl Stacks {\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::read(&mut current_span, threads, tag, range);\n-        let mut state = state.borrow_mut();\n+        let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.access(AccessKind::Read, tag, &mut state, dcx, exposed_tags)\n+            stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_write<'tcx, 'mir, 'ecx>(\n+    pub fn before_memory_write<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::write(&mut current_span, threads, tag, range);\n-        let mut state = state.borrow_mut();\n+        let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.access(AccessKind::Write, tag, &mut state, dcx, exposed_tags)\n+            stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_deallocation<'tcx, 'mir, 'ecx>(\n+    pub fn before_memory_deallocation<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let dcx = DiagnosticCxBuilder::dealloc(&mut current_span, threads, tag);\n-        let state = state.borrow();\n+        let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;\n@@ -698,7 +717,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n         new_tag: SbTag,\n-        protect: bool,\n+        protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n \n@@ -738,7 +757,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n-                    let current_span = &mut this.machine.current_span();\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -748,20 +766,18 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         .as_ref()\n                         .expect(\"we should have Stacked Borrows data\")\n                         .borrow_mut();\n-                    let threads = &this.machine.threads;\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        current_span,\n-                        threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n                         alloc_range(base_offset, size),\n                     );\n                     let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n                     dcx.log_creation();\n-                    if protect {\n+                    if protect.is_some() {\n                         dcx.log_protector();\n                     }\n                 }\n@@ -821,70 +837,89 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             size.bytes()\n         );\n \n-        if protect {\n-            // See comment in `Stack::item_popped` for why we store the tag twice.\n+        if let Some(protect) = protect {\n+            // See comment in `Stack::item_invalidated` for why we store the tag twice.\n             this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n-            this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n+            this.machine\n+                .stacked_borrows\n+                .as_mut()\n+                .unwrap()\n+                .get_mut()\n+                .protected_tags\n+                .insert(new_tag, protect);\n         }\n \n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let perm = match kind {\n-            RefKind::Unique { two_phase: false }\n-                if place.layout.ty.is_unpin(*this.tcx, this.param_env()) =>\n-            {\n-                // Only if the type is unpin do we actually enforce uniqueness\n-                Permission::Unique\n+        let (perm, access) = match kind {\n+            RefKind::Unique { two_phase } => {\n+                // Permission is Unique only if the type is `Unpin` and this is not twophase\n+                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    Permission::Unique\n+                } else {\n+                    Permission::SharedReadWrite\n+                };\n+                // We do an access for all full borrows, even if `!Unpin`.\n+                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n+                (perm, access)\n             }\n-            RefKind::Unique { .. } => {\n-                // Two-phase references and !Unpin references are treated as SharedReadWrite\n-                Permission::SharedReadWrite\n+            RefKind::Raw { mutable: true } => {\n+                // Creating a raw ptr does not count as an access\n+                (Permission::SharedReadWrite, None)\n             }\n-            RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n             RefKind::Shared | RefKind::Raw { mutable: false } => {\n                 // Shared references and *const are a whole different kind of game, the\n                 // permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n-                let extra = this.get_alloc_extra(alloc_id)?;\n-                let mut stacked_borrows = extra\n+                let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+                let mut stacked_borrows = alloc_extra\n                     .stacked_borrows\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n-                // FIXME: can't share this with the current_span inside log_creation\n-                let mut current_span = this.machine.current_span();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let perm = if frozen {\n-                        Permission::SharedReadOnly\n+                    let (perm, access) = if frozen {\n+                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n                     } else {\n-                        Permission::SharedReadWrite\n+                        // Inside UnsafeCell, this does *not* count as an access, as there\n+                        // might actually be mutable references further up the stack that\n+                        // we have to keep alive.\n+                        (Permission::SharedReadWrite, None)\n                     };\n                     let protected = if frozen {\n-                        protect\n+                        protect.is_some()\n                     } else {\n                         // We do not protect inside UnsafeCell.\n                         // This fixes https://github.com/rust-lang/rust/issues/55005.\n                         false\n                     };\n                     let item = Item::new(new_tag, perm, protected);\n-                    let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+                    let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        &mut current_span, // FIXME avoid this `clone`\n-                        &this.machine.threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n                         alloc_range(base_offset, size),\n                     );\n                     stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-                        stack.grant(orig_tag, item, &mut global, dcx, exposed_tags)\n-                    })\n+                        stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n+                    })?;\n+                    drop(global);\n+                    if let Some(access) = access {\n+                        assert_eq!(access, AccessKind::Read);\n+                        // Make sure the data race model also knows about this.\n+                        if let Some(data_race) = alloc_extra.data_race.as_ref() {\n+                            data_race.read(alloc_id, range, &this.machine)?;\n+                        }\n+                    }\n+                    Ok(())\n                 })?;\n                 return Ok(Some(alloc_id));\n             }\n@@ -894,27 +929,32 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let mut stacked_borrows = alloc_extra\n+        let stacked_borrows = alloc_extra\n             .stacked_borrows\n             .as_mut()\n             .expect(\"we should have Stacked Borrows data\")\n-            .borrow_mut();\n-        let item = Item::new(new_tag, perm, protect);\n+            .get_mut();\n+        let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n-        let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-        // FIXME: can't share this with the current_span inside log_creation\n-        let current_span = &mut machine.current_span();\n+        let global = machine.stacked_borrows.as_ref().unwrap().borrow();\n         let dcx = DiagnosticCxBuilder::retag(\n-            current_span,\n-            &machine.threads,\n+            machine,\n             retag_cause,\n             new_tag,\n             orig_tag,\n             alloc_range(base_offset, size),\n         );\n         stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, &mut global, dcx, exposed_tags)\n+            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n         })?;\n+        drop(global);\n+        if let Some(access) = access {\n+            assert_eq!(access, AccessKind::Write);\n+            // Make sure the data race model also knows about this.\n+            if let Some(data_race) = alloc_extra.data_race.as_mut() {\n+                data_race.write(alloc_id, range, machine)?;\n+            }\n+        }\n \n         Ok(Some(alloc_id))\n     }\n@@ -926,7 +966,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        protect: bool,\n+        protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -996,7 +1036,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 place: &PlaceTy<'tcx, Provenance>,\n                 ref_kind: RefKind,\n                 retag_cause: RetagCause,\n-                protector: bool,\n+                protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n                 let val = self.ecx.retag_reference(&val, ref_kind, retag_cause, protector)?;\n@@ -1015,13 +1055,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n-                // Boxes do not get a protector: protectors reflect that references outlive the call\n-                // they were passed in to; that's just not the case for boxes.\n+                // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n                     RefKind::Unique { two_phase: false },\n                     self.retag_cause,\n-                    /*protector*/ false,\n+                    /*protector*/\n+                    (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n                 )\n             }\n \n@@ -1046,7 +1086,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             place,\n                             ref_kind,\n                             self.retag_cause,\n-                            /*protector*/ self.kind == RetagKind::FnEntry,\n+                            /*protector*/\n+                            (self.kind == RetagKind::FnEntry)\n+                                .then_some(ProtectorKind::StrongProtector),\n                         )?;\n                     }\n                     ty::RawPtr(tym) => {\n@@ -1059,7 +1101,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                                 place,\n                                 RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n                                 self.retag_cause,\n-                                /*protector*/ false,\n+                                /*protector*/ None,\n                             )?;\n                         }\n                     }\n@@ -1110,12 +1152,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // (The pointer type does not matter, so we use a raw pointer.)\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n-        // Reborrow it.\n+        // Reborrow it. With protection! That is part of the point.\n         let val = this.retag_reference(\n             &val,\n             RefKind::Unique { two_phase: false },\n             RetagCause::FnReturn,\n-            /*protector*/ true,\n+            /*protector*/ Some(ProtectorKind::StrongProtector),\n         )?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;"}, {"sha": "51a6fba6df01144d50b166bddd2f9f5a6b5033d1", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -367,10 +367,10 @@ impl<'tcx> Stack {\n \n     /// Find all `Unique` elements in this borrow stack above `granting_idx`, pass a copy of them\n     /// to the `visitor`, then set their `Permission` to `Disabled`.\n-    pub fn disable_uniques_starting_at<V: FnMut(Item) -> crate::InterpResult<'tcx>>(\n+    pub fn disable_uniques_starting_at(\n         &mut self,\n         disable_start: usize,\n-        mut visitor: V,\n+        mut visitor: impl FnMut(Item) -> crate::InterpResult<'tcx>,\n     ) -> crate::InterpResult<'tcx> {\n         #[cfg(feature = \"stack-cache\")]\n         let unique_range = self.unique_range.clone();"}, {"sha": "37c996de6623c7e24c4e80a848b050586d644635", "filename": "src/tools/miri/test-cargo-miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,6 @@\n [workspace]\n members = [\"subcrate\", \"issue-1567\", \"exported-symbol-dep\"]\n+exclude = [\"no-std-smoke\"] # it wants to be panic=\"abort\"\n \n [package]\n name = \"cargo-miri-test\""}, {"sha": "b92a05fccf80fe32fe04dbf169c617ef9373eaf9", "filename": "src/tools/miri/test-cargo-miri/no-std-smoke/Cargo.lock", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.lock?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,7 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"no-std-smoke\"\n+version = \"0.1.0\""}, {"sha": "3a056bedaa0034d831e5e943a7aa8f7517083bb4", "filename": "src/tools/miri/test-cargo-miri/no-std-smoke/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.toml?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"no-std-smoke\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n+[profile.dev]\n+panic = 'abort'\n+\n+[profile.release]\n+panic = 'abort'"}, {"sha": "3a207b7d50aa2294dcb23fdfcac53a8a15e675fb", "filename": "src/tools/miri/test-cargo-miri/no-std-smoke/src/main.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2Fsrc%2Fmain.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,34 @@\n+// Copied from tests/pass/no-std.rs\n+\n+#![feature(start)]\n+#![no_std]\n+\n+// Plumbing to let us use `writeln!` to host stdout:\n+\n+extern \"Rust\" {\n+    fn miri_write_to_stdout(bytes: &[u8]);\n+}\n+\n+struct Host;\n+\n+use core::fmt::Write;\n+\n+impl Write for Host {\n+    fn write_str(&mut self, s: &str) -> core::fmt::Result {\n+        unsafe {\n+            miri_write_to_stdout(s.as_bytes());\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    writeln!(Host, \"hello, world!\").unwrap();\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "c728e7c0778db8dd70b9ce77acafa85c37dc24aa", "filename": "src/tools/miri/test_dependencies/Cargo.lock", "status": "modified", "additions": 54, "deletions": 40, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -16,9 +16,9 @@ checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"bytes\"\n-version = \"1.2.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec8a7b6a70fde80372154c65702f00a0f56f3e1c36abbc6c440484be248856db\"\n+checksum = \"dfb24e866b15a1af2a1b663f10c6b6b8f397a84aadb828f12e5b289ec23a3a3c\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -39,9 +39,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.7\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n+checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -59,9 +59,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.133\"\n+version = \"0.2.137\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0f80d65747a3e43d1596c7c5492d95d5edddaabd45a7fcdb02b95f644164966\"\n+checksum = \"fc7fcc620a3bff7cdd7a365be3376c97191aeaccc2a603e600951e452615bf89\"\n \n [[package]]\n name = \"lock_api\"\n@@ -90,9 +90,9 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"mio\"\n-version = \"0.8.4\"\n+version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57ee1c23c7c63b0c9250c339ffdc69255f110b298b901b9f6c82547b7b87caaf\"\n+checksum = \"e5d732bc30207a6423068df043e3d02e0735b155ad7ce1a6f76fe2baa5b158de\"\n dependencies = [\n  \"libc\",\n  \"log\",\n@@ -105,7 +105,7 @@ name = \"miri-test-deps\"\n version = \"0.1.0\"\n dependencies = [\n  \"getrandom 0.1.16\",\n- \"getrandom 0.2.7\",\n+ \"getrandom 0.2.8\",\n  \"libc\",\n  \"num_cpus\",\n  \"page_size\",\n@@ -115,19 +115,19 @@ dependencies = [\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.13.1\"\n+version = \"1.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1\"\n+checksum = \"f6058e64324c71e02bc2b150e4f3bc8286db6c83092132ffa3f6b1eab0f9def5\"\n dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n ]\n \n [[package]]\n name = \"page_size\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eebde548fbbf1ea81a99b128872779c437752fb99f217c45245e1a61dcd9edcd\"\n+checksum = \"1b7663cbd190cfd818d08efa8497f6cd383076688c49a391ef7c0d03cd12b561\"\n dependencies = [\n  \"libc\",\n  \"winapi\",\n@@ -145,9 +145,9 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -164,15 +164,15 @@ checksum = \"e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116\"\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.16\"\n+version = \"0.2.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eb9f9e6e233e5c4a35559a617bf40a4ec447db2e84c20b55a6f83167b7e57872\"\n+checksum = \"5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.45\"\n+version = \"1.0.47\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3edcd08cf4fea98d1ae6c9ddd3b8ccb1acac7c3693d62625969a7daa04a2ae36\"\n+checksum = \"5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -213,7 +213,7 @@ version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\n dependencies = [\n- \"getrandom 0.2.7\",\n+ \"getrandom 0.2.8\",\n ]\n \n [[package]]\n@@ -242,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"socket2\"\n@@ -258,9 +258,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.101\"\n+version = \"1.0.103\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e90cde112c4b9690b8cbe810cba9ddd8bc1d7472e2cae317b69e9438c1cba7d2\"\n+checksum = \"a864042229133ada95abf3b54fdc62ef5ccabe9515b64717bcb9a1919e59445d\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -269,9 +269,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio\"\n-version = \"1.21.2\"\n+version = \"1.22.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9e03c497dc955702ba729190dc4aac6f2a0ce97f913e5b1b5912fc5039d9099\"\n+checksum = \"d76ce4a75fb488c605c54bf610f221cea8b0dafb53333c1a67e8ee199dcd2ae3\"\n dependencies = [\n  \"autocfg\",\n  \"bytes\",\n@@ -300,9 +300,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-ident\"\n-version = \"1.0.4\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dcc811dc4066ac62f84f11307873c4850cb653bfa9b1719cee2bd2204a4bc5dd\"\n+checksum = \"6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3\"\n \n [[package]]\n name = \"wasi\"\n@@ -340,43 +340,57 @@ checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n+ \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n  \"windows_i686_gnu\",\n  \"windows_i686_msvc\",\n  \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\""}, {"sha": "3a80e8c96441962ad14ac09ada234f5413765bb5", "filename": "src/tools/miri/test_dependencies/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -11,11 +11,11 @@ edition = \"2021\"\n # all dependencies (and their transitive ones) listed here can be used in `tests/`.\n tokio = { version = \"1.0\", features = [\"full\"] }\n libc = \"0.2\"\n-page_size = \"0.4.1\"\n+page_size = \"0.5\"\n num_cpus = \"1.10.1\"\n \n getrandom_1 = { package = \"getrandom\", version = \"0.1\" }\n-getrandom_2 = { package = \"getrandom\", version = \"0.2\" }\n+getrandom = { version = \"0.2\" }\n rand = { version = \"0.8\", features = [\"small_rng\"] }\n \n [workspace]"}, {"sha": "5a80d1ac5a9b1a11245cd946448be605d02b9cc4", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n error: unsupported operation: can't call foreign function: epoll_create1\n   --> CARGO_REGISTRY/.../epoll.rs:LL:CC\n    |\n-LL |         syscall!(epoll_create1(flag)).map(|ep| Selector {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't call foreign function: epoll_create1\n+LL |         let res = syscall!(epoll_create1(libc::EPOLL_CLOEXEC));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't call foreign function: epoll_create1\n    |\n    = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n    = note: BACKTRACE:"}, {"sha": "6040452a166cbebfe09878abf4236b52938ac0fc", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n #![feature(new_uninit)]\n \n use std::mem::MaybeUninit;"}, {"sha": "51d431b36f3a36af40c9ca6a128aca6bdb7fc9d9", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n #![feature(new_uninit)]\n \n use std::ptr::null_mut;"}, {"sha": "79c6760b7c42af4d71177abb468fceb981d6e9b4", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "e069ac4ad6a83319a50597248cba798ad608fa4e", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "9c025a0153d58276cdc1152e9be746922685c1d8", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "30b3c4863740c0202ed87cc783586d5038ec51c1", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "02b17cc57b61a51e2f45a0e5a5b81124f45c5970", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "b5f4966d8842af1d714480c47da531bcc558d5e2", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "9922468e5f8424c67fecf0ecf362fba5841abb1f", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "8c8a6ac87f3ab550a0f0a75635de4695cfbda1b0", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "8e1216f5bf0a023008afd139efb1f268299347bd", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "38f76af9de1373d5661d5a9aca9df4aec327f355", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "665e5ce4a1706c8c98dae69655da6bc0f41f4480", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "b36c6b5ac0e45ce5a8aeba89369b6b8e6007bacf", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "4af8b904626d203268d6a08a52ba3ee7f9e4a4f9", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "f851ce95785f7e884d8ef4d8d3109409aa5882a4", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "27aa16a122f364207547836f73ad2bdb92b673bf", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "4d436d51f9895ee1c68a35931a98c69cdda8a7e1", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n use std::sync::atomic::{fence, AtomicUsize, Ordering};\n use std::sync::Arc;\n use std::thread;"}, {"sha": "b26ec6c41427aadb1d0ae01d31e5415520ab2eb5", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "2fbac173993e4dae564949efceb43d59e7f24034", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n // from being optimized away and preventing the detection of the data-race."}, {"sha": "24040a9496114a37ac07d01ba48afa8b9a31576f", "filename": "src/tools/miri/tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "2d7246858e108317a6d8b95572769721d4acbace", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::{sleep, spawn};"}, {"sha": "0f974e1c56d3fd0e032c2d53e77f5ee6e123d40c", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "2d13da30b46393a257c2383cf06bd0c5aa4ecd6a", "filename": "src/tools/miri/tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "cf5c2ed81cb1d1d8e7b992c9875dda159c4046ac", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n use std::thread;\n \n #[derive(Copy, Clone)]"}, {"sha": "60e9ac2ac6c383f0006b410e50d0b01f6ca6d543", "filename": "src/tools/miri/tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,5 +1,5 @@\n // We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "0a29dc13cba1746f66f5af7f21b75e275f68ea28", "filename": "src/tools/miri/tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "268d253ad5b06c65b49b5d9ac60914c231ff0608", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "77a542f45a2566a5f61af86f328921e92d07c668", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "e592b154a7326326da9226cf42c2876ba35f4699", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2067149b6c87cac19c52bebd30a18abb6dfff1ab", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,14 @@\n+unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n+    // We will call this in a way that x and y alias.\n+    *x = 5;\n+    std::mem::forget(x);\n+    *y //~ERROR: weakly protected\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut v = 42;\n+        let ptr = &mut v as *mut i32;\n+        test(Box::from_raw(ptr), ptr);\n+    }\n+}"}, {"sha": "3c84cbcfd5182a0b543111003d38052a8e498bb4", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is weakly protected because it is an argument of call ID\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |     *y\n+   |     ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is weakly protected because it is an argument of call ID\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |         let ptr = &mut v as *mut i32;\n+   |                   ^^^^^^\n+help: <TAG> is this argument\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL | unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n+   |                ^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `test` at $DIR/box_noalias_violation.rs:LL:CC\n+note: inside `main` at $DIR/box_noalias_violation.rs:LL:CC\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |         test(Box::from_raw(ptr), ptr);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "4036dce5bebab1a5995da3daead21bd32c365950", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: /deallocating while item \\[Unique for .*\\] is protected/\n+//@error-pattern: /deallocating while item \\[Unique for .*\\] is strongly protected/\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "bb3eaec1e85c0da033b0f68073849a304ae21b71", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: deallocating while item [Unique for <TAG>] is strongly protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is protected by call ID\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is strongly protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "fd67dccd14df6d826b0767b726fd31f827d37f3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is protected/\n+//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is strongly protected/\n use std::marker::PhantomPinned;\n \n pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "25bab1aa564a65a0145bb1506cda9ded5c95e453", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n+error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "670dd4baad8bc675d69194a61842009bb19578c3", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,14 @@\n+//@error-pattern: /deallocation .* tag does not exist in the borrow stack/\n+use std::alloc::{alloc, dealloc, Layout};\n+\n+fn main() {\n+    unsafe {\n+        let x = alloc(Layout::from_size_align_unchecked(1, 1));\n+        let ptr1 = (&mut *x) as *mut u8;\n+        let ptr2 = (&mut *ptr1) as *mut u8;\n+        // Invalidate ptr2 by writing to ptr1.\n+        ptr1.write(0);\n+        // Deallocate through ptr2.\n+        dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+    }\n+}"}, {"sha": "3b7802901a54eb723ddf23ae38b9b557d1772a2c", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         let ptr2 = (&mut *ptr1) as *mut u8;\n+   |                    ^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         ptr1.write(0);\n+   |         ^^^^^^^^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+note: inside `main` at $DIR/illegal_deALLOC.rs:LL:CC\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "7983b30ea18229ee93498d640354629d5d008175", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -7,6 +7,6 @@ fn main() {\n fn foo(a: &mut u32, y: *mut u32) -> u32 {\n     *a = 1;\n     let _b = &*a;\n-    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is protected/\n+    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is strongly protected/\n     return *a;\n }"}, {"sha": "1a627b8a883009f07818308cbe6f48f916bb21ac", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "1ef36b7ac10fc4c5005ded98d127b7968315d580", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "941b936e5d7249443852d9692444911c5cd8c898", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "176a859ee8af7692d4b1673d1ce96b03eff79019", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector3.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "c19bcb99cc1cee4bd5ca83381607ae019577f1b7", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: which is protected\n+//@error-pattern: which is strongly protected\n struct Newtype<'a>(&'a mut i32, i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "70186dd3a53f3305d9b8622fadf83448f1aae9ad", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2bbe7122ec7478873190fc73686b02dbfe11a932", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: which is protected\n+//@error-pattern: which is strongly protected\n struct Newtype<'a>(&'a mut i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "69fa27c9c096fef7f6e6c1a3e6a6dfe9287165d5", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,17 @@\n+//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n+use std::marker::PhantomPinned;\n+\n+struct NotUnpin(i32, PhantomPinned);\n+\n+fn main() {\n+    unsafe {\n+        let mut x = NotUnpin(0, PhantomPinned);\n+        // Mutable borrow of `Unpin` field (with lifetime laundering)\n+        let fieldref = &mut *(&mut x.0 as *mut i32);\n+        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n+        // still count as a read since we would add `dereferenceable`.\n+        let _xref = &mut x;\n+        // That read should have invalidated `fieldref`.\n+        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n+    }\n+}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,28 @@\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         *fieldref = 0;\n+   |         ^^^^^^^^^^^^^\n+   |         |\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let _xref = &mut x;\n+   |                     ^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "309d7a22be64f20b3eebafe3aa9d89f0d9d09235", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,31 @@\n+//! Make sure that a retag acts like a write for the data race model.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+fn thread_1(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        let _r = &*p;\n+    }\n+}\n+\n+fn thread_2(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>`\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || thread_1(p));\n+    let t2 = std::thread::spawn(move || thread_2(p));\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f25d689524d1b3c86a565ea215a7ec5034a5e03a", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `thread_2` at $DIR/retag_data_race_read.rs:LL:CC\n+note: inside closure at $DIR/retag_data_race_read.rs:LL:CC\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || thread_2(p));\n+   |                                         ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "9368a0a919eb3c9a6dc7eadffdea342b5b7efa56", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,31 @@\n+//! Make sure that a retag acts like a write for the data race model.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+fn thread_1(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        let _r = &mut *p;\n+    }\n+}\n+\n+fn thread_2(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || thread_1(p));\n+    let t2 = std::thread::spawn(move || thread_2(p));\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f97e6bb11e9d674a7535cfef0329d4c8397f61aa", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `thread_2` at $DIR/retag_data_race_write.rs:LL:CC\n+note: inside closure at $DIR/retag_data_race_write.rs:LL:CC\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || thread_2(p));\n+   |                                         ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "2c7bd93fbdb38ce7e58d765ee9382864f50c3319", "filename": "src/tools/miri/tests/pass-dep/getrandom_1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fgetrandom_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fgetrandom_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fgetrandom_1.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -0,0 +1,8 @@\n+// mac-os `getrandom_1` does some pointer shenanigans\n+//@compile-flags: -Zmiri-permissive-provenance\n+\n+/// Test old version of `getrandom`.\n+fn main() {\n+    let mut data = vec![0; 16];\n+    getrandom_1::getrandom(&mut data).unwrap();\n+}"}, {"sha": "0cd8b06d63d8aac42eee735909b64b25820228d3", "filename": "src/tools/miri/tests/pass-dep/random.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Frandom.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,12 +1,10 @@\n-// mac-os `getrandom_1` does some pointer shenanigans\n-//@compile-flags: -Zmiri-permissive-provenance\n+//@compile-flags: -Zmiri-strict-provenance\n use rand::{rngs::SmallRng, Rng, SeedableRng};\n \n fn main() {\n-    // Test `getrandom` directly (in multiple different versions).\n+    // Test `getrandom` directly.\n     let mut data = vec![0; 16];\n-    getrandom_1::getrandom(&mut data).unwrap();\n-    getrandom_2::getrandom(&mut data).unwrap();\n+    getrandom::getrandom(&mut data).unwrap();\n \n     // Try seeding with \"real\" entropy.\n     let mut rng = SmallRng::from_entropy();"}, {"sha": "349b447569a4b8a8dab625b80c1a0e648cc933bf", "filename": "src/tools/miri/tests/pass-dep/shims/libc-getrandom-without-isolation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom-without-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom-without-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom-without-isolation.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "previous_filename": "src/tools/miri/tests/pass-dep/shims/linux-getrandom-without-isolation.rs"}, {"sha": "a1436c7319d3395f0a8419d2bbc34298e5156d12", "filename": "src/tools/miri/tests/pass-dep/shims/libc-getrandom.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "previous_filename": "src/tools/miri/tests/pass-dep/shims/linux-getrandom.rs"}, {"sha": "3bece7783f798db012424aa871760904a71a5546", "filename": "src/tools/miri/tests/pass/no_std.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs?ref=8c6bf2bee7914fd94f8ae5ec96234e8a2ce51958", "patch": "@@ -1,9 +1,5 @@\n #![feature(lang_items, start)]\n #![no_std]\n-// windows tls dtors go through libstd right now, thus this test\n-// cannot pass. When windows tls dtors go through the special magic\n-// windows linker section, we can run this test on windows again.\n-//@ignore-target-windows: no-std not supported on Windows\n \n // Plumbing to let us use `writeln!` to host stdout:\n "}]}