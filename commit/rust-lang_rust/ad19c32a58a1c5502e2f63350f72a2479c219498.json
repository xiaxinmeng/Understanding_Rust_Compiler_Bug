{"sha": "ad19c32a58a1c5502e2f63350f72a2479c219498", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMTljMzJhNThhMWM1NTAyZTJmNjMzNTBmNzJhMjQ3OWMyMTk0OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-06T18:42:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-06T18:42:34Z"}, "message": "Auto merge of #37002 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 15 pull requests\n\n- Successful merges: #36726, #36832, #36909, #36930, #36932, #36957, #36959, #36960, #36962, #36965, #36966, #36967, #36972, #36974, #36977\n- Failed merges:", "tree": {"sha": "f223fa1b72d4685258f681b218c09154d7d22155", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f223fa1b72d4685258f681b218c09154d7d22155"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad19c32a58a1c5502e2f63350f72a2479c219498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad19c32a58a1c5502e2f63350f72a2479c219498", "html_url": "https://github.com/rust-lang/rust/commit/ad19c32a58a1c5502e2f63350f72a2479c219498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad19c32a58a1c5502e2f63350f72a2479c219498/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46957f05771a427545c792f69b37f8e05dcbb15d", "url": "https://api.github.com/repos/rust-lang/rust/commits/46957f05771a427545c792f69b37f8e05dcbb15d", "html_url": "https://github.com/rust-lang/rust/commit/46957f05771a427545c792f69b37f8e05dcbb15d"}, {"sha": "89aebdbce8c92617be0cebbd86a14289f2419b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/89aebdbce8c92617be0cebbd86a14289f2419b79", "html_url": "https://github.com/rust-lang/rust/commit/89aebdbce8c92617be0cebbd86a14289f2419b79"}], "stats": {"total": 1192, "additions": 925, "deletions": 267}, "files": [{"sha": "418c3a48ed348bc8281e711bdecbbb42df94efad", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -90,16 +90,16 @@ pub fn std_link(build: &Build,\n     add_to_sysroot(&out_dir, &libdir);\n \n     if target.contains(\"musl\") && !target.contains(\"mips\") {\n-        copy_musl_third_party_objects(build, &libdir);\n+        copy_musl_third_party_objects(build, target, &libdir);\n     }\n }\n \n /// Copies the crt(1,i,n).o startup objects\n ///\n /// Only required for musl targets that statically link to libc\n-fn copy_musl_third_party_objects(build: &Build, into: &Path) {\n+fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.config.musl_root.as_ref().unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n "}, {"sha": "69bd7a769910ccf8ef272a754a9fe7a880328ea6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -158,6 +158,7 @@ struct TomlTarget {\n     cc: Option<String>,\n     cxx: Option<String>,\n     android_ndk: Option<String>,\n+    musl_root: Option<String>,\n }\n \n impl Config {\n@@ -268,6 +269,7 @@ impl Config {\n                 }\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n \n                 config.target_config.insert(triple.clone(), target);\n             }"}, {"sha": "969cd70fd57eb43e027d41580601398bd097afce", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -146,8 +146,8 @@ pub fn check(build: &mut Build) {\n                     }\n                 }\n                 None => {\n-                    panic!(\"when targeting MUSL either the build.musl-root \\\n-                            option or the target.$TARGET.musl-root one must \\\n+                    panic!(\"when targeting MUSL either the rust.musl-root \\\n+                            option or the target.$TARGET.musl-root option must \\\n                             be specified in config.toml\")\n                 }\n             }"}, {"sha": "41d8345b720949a68339ad847b37c7e9ad2b57fa", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -4,7 +4,7 @@ Concurrency and parallelism are incredibly important topics in computer\n science, and are also a hot topic in industry today. Computers are gaining more\n and more cores, yet many programmers aren't prepared to fully utilize them.\n \n-Rust's memory safety features also apply to its concurrency story too. Even\n+Rust's memory safety features also apply to its concurrency story. Even\n concurrent Rust programs must be memory safe, having no data races. Rust's type\n system is up to the task, and gives you powerful ways to reason about\n concurrent code at compile time.\n@@ -281,8 +281,8 @@ And... still gives us an error.\n ```\n \n `Arc<T>` by default has immutable contents. It allows the _sharing_ of data\n-between threads, but shared mutable data is unsafe and when threads are\n-involved can cause data races!\n+between threads, but shared mutable data is unsafe\u2014and when threads are\n+involved\u2014can cause data races!\n \n \n Usually when we wish to make something in an immutable position mutable, we use"}, {"sha": "609eb28348e21a2b571c8f063e4749bd9ed32b39", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -1053,10 +1053,10 @@ impl str {\n     }\n \n     /// An iterator over substrings of the given string slice, separated by a\n-    /// pattern, restricted to returning at most `count` items.\n+    /// pattern, restricted to returning at most `n` items.\n     ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string slice.\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n     ///\n     /// The pattern can be a `&str`, [`char`], or a closure that determines the\n     /// split.\n@@ -1098,16 +1098,16 @@ impl str {\n     /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(self, count, pat)\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(self, n, pat)\n     }\n \n     /// An iterator over substrings of this string slice, separated by a\n     /// pattern, starting from the end of the string, restricted to returning\n-    /// at most `count` items.\n+    /// at most `n` items.\n     ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string slice.\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n     ///\n     /// The pattern can be a `&str`, [`char`], or a closure that\n     /// determines the split.\n@@ -1145,10 +1145,10 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        core_str::StrExt::rsplitn(self, count, pat)\n+        core_str::StrExt::rsplitn(self, n, pat)\n     }\n \n     /// An iterator over the matches of a pattern within the given string"}, {"sha": "fc74669635934b6fae563c8b2241721aeb96d0eb", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -17,6 +17,9 @@ use ptr;\n \n /// An implementation of SipHash 1-3.\n ///\n+/// This is currently the default hashing function used by standard library\n+/// (eg. `collections::HashMap` uses it by default).\n+///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n@@ -39,9 +42,6 @@ pub struct SipHasher24 {\n ///\n /// See: https://131002.net/siphash/\n ///\n-/// This is currently the default hashing function used by standard library\n-/// (eg. `collections::HashMap` uses it by default).\n-///\n /// SipHash is a general-purpose hashing function: it runs at a good\n /// speed (competitive with Spooky and City) and permits strong _keyed_\n /// hashing. This lets you key your hashtables from a strong RNG, such as\n@@ -117,23 +117,18 @@ unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n     data.to_le()\n }\n \n-macro_rules! rotl {\n-    ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64_i32.wrapping_sub($b))))\n-}\n-\n macro_rules! compress {\n     ($state:expr) => ({\n         compress!($state.v0, $state.v1, $state.v2, $state.v3)\n     });\n     ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n     ({\n-        $v0 = $v0.wrapping_add($v1); $v1 = rotl!($v1, 13); $v1 ^= $v0;\n-        $v0 = rotl!($v0, 32);\n-        $v2 = $v2.wrapping_add($v3); $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-        $v0 = $v0.wrapping_add($v3); $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-        $v2 = $v2.wrapping_add($v1); $v1 = rotl!($v1, 17); $v1 ^= $v2;\n-        $v2 = rotl!($v2, 32);\n+        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+        $v0 = $v0.rotate_left(32);\n+        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.rotate_left(32);\n     });\n }\n "}, {"sha": "2bd4a4d302936668a7f9fe070d9b00bbebcfd458", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -25,8 +25,10 @@ use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n+use rustc::session::Session;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_errors::DiagnosticBuilder;\n use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n@@ -163,6 +165,10 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.sess.abort_if_errors();\n }\n \n+fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> DiagnosticBuilder<'a> {\n+    struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n+}\n+\n fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n     intravisit::walk_expr(cx, ex);\n     match ex.node {\n@@ -215,9 +221,10 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n             if inlined_arms.is_empty() {\n                 if !pat_ty.is_uninhabited(cx.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n-                    let mut err = struct_span_err!(cx.tcx.sess, ex.span, E0002,\n-                                                   \"non-exhaustive patterns: type {} is non-empty\",\n-                                                   pat_ty);\n+                    let mut err = create_e0004(cx.tcx.sess, ex.span,\n+                                               format!(\"non-exhaustive patterns: type {} \\\n+                                                        is non-empty\",\n+                                                       pat_ty));\n                     span_help!(&mut err, ex.span,\n                         \"Please ensure that all possible cases are being handled; \\\n                          possibly adding wildcards or more match arms.\");\n@@ -438,10 +445,11 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                         1 => format!(\"pattern {} not covered\", joined_patterns),\n                         _ => format!(\"patterns {} not covered\", joined_patterns)\n                     };\n-                    struct_span_err!(cx.tcx.sess, sp, E0004,\n-                        \"non-exhaustive patterns: {} not covered\",\n-                        joined_patterns\n-                    ).span_label(sp, &label_text).emit();\n+                    create_e0004(cx.tcx.sess, sp,\n+                                 format!(\"non-exhaustive patterns: {} not covered\",\n+                                         joined_patterns))\n+                        .span_label(sp, &label_text)\n+                        .emit();\n                 },\n             }\n         }"}, {"sha": "3df68ac583d46c8792c42d1a32a0ecdf6dae85a4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 146, "deletions": 16, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -15,6 +15,11 @@\n \n use self::SawExprComponent::*;\n use self::SawAbiComponent::*;\n+use self::SawItemComponent::*;\n+use self::SawPatComponent::*;\n+use self::SawTyComponent::*;\n+use self::SawTraitOrImplItemComponent::*;\n+use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::parse::token;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n@@ -155,19 +160,19 @@ enum SawAbiComponent<'a> {\n \n     SawMod,\n     SawForeignItem,\n-    SawItem,\n-    SawTy,\n+    SawItem(SawItemComponent),\n+    SawTy(SawTyComponent),\n     SawGenerics,\n-    SawTraitItem,\n-    SawImplItem,\n+    SawTraitItem(SawTraitOrImplItemComponent),\n+    SawImplItem(SawTraitOrImplItemComponent),\n     SawStructField,\n     SawVariant,\n     SawPath(bool),\n     SawPathSegment,\n     SawPathParameters,\n     SawPathListItem,\n     SawBlock,\n-    SawPat,\n+    SawPat(SawPatComponent),\n     SawLocal,\n     SawArm,\n     SawExpr(SawExprComponent<'a>),\n@@ -198,6 +203,9 @@ enum SawAbiComponent<'a> {\n /// because the SVH is just a developer convenience; there is no\n /// guarantee of collision-freedom, hash collisions are just\n /// (hopefully) unlikely.)\n+///\n+/// The xxxComponent enums and saw_xxx functions for Item, Pat,\n+/// Ty, TraitItem and ImplItem follow the same methodology.\n #[derive(Hash)]\n enum SawExprComponent<'a> {\n \n@@ -267,6 +275,134 @@ fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n     }\n }\n \n+#[derive(Hash)]\n+enum SawItemComponent {\n+    SawItemExternCrate,\n+    SawItemUse,\n+    SawItemStatic(Mutability),\n+    SawItemConst,\n+    SawItemFn(Unsafety, Constness, Abi),\n+    SawItemMod,\n+    SawItemForeignMod,\n+    SawItemTy,\n+    SawItemEnum,\n+    SawItemStruct,\n+    SawItemUnion,\n+    SawItemTrait(Unsafety),\n+    SawItemDefaultImpl(Unsafety),\n+    SawItemImpl(Unsafety, ImplPolarity)\n+}\n+\n+fn saw_item(node: &Item_) -> SawItemComponent {\n+    match *node {\n+        ItemExternCrate(..) => SawItemExternCrate,\n+        ItemUse(..) => SawItemUse,\n+        ItemStatic(_, mutability, _) => SawItemStatic(mutability),\n+        ItemConst(..) =>SawItemConst,\n+        ItemFn(_, unsafety, constness, abi, _, _) => SawItemFn(unsafety, constness, abi),\n+        ItemMod(..) => SawItemMod,\n+        ItemForeignMod(..) => SawItemForeignMod,\n+        ItemTy(..) => SawItemTy,\n+        ItemEnum(..) => SawItemEnum,\n+        ItemStruct(..) => SawItemStruct,\n+        ItemUnion(..) => SawItemUnion,\n+        ItemTrait(unsafety, ..) => SawItemTrait(unsafety),\n+        ItemDefaultImpl(unsafety, _) => SawItemDefaultImpl(unsafety),\n+        ItemImpl(unsafety, implpolarity, ..) => SawItemImpl(unsafety, implpolarity)\n+    }\n+}\n+\n+#[derive(Hash)]\n+enum SawPatComponent {\n+    SawPatWild,\n+    SawPatBinding(BindingMode),\n+    SawPatStruct,\n+    SawPatTupleStruct,\n+    SawPatPath,\n+    SawPatTuple,\n+    SawPatBox,\n+    SawPatRef(Mutability),\n+    SawPatLit,\n+    SawPatRange,\n+    SawPatSlice\n+}\n+\n+fn saw_pat(node: &PatKind) -> SawPatComponent {\n+    match *node {\n+        PatKind::Wild => SawPatWild,\n+        PatKind::Binding(bindingmode, ..) => SawPatBinding(bindingmode),\n+        PatKind::Struct(..) => SawPatStruct,\n+        PatKind::TupleStruct(..) => SawPatTupleStruct,\n+        PatKind::Path(..) => SawPatPath,\n+        PatKind::Tuple(..) => SawPatTuple,\n+        PatKind::Box(..) => SawPatBox,\n+        PatKind::Ref(_, mutability) => SawPatRef(mutability),\n+        PatKind::Lit(..) => SawPatLit,\n+        PatKind::Range(..) => SawPatRange,\n+        PatKind::Slice(..) => SawPatSlice\n+    }\n+}\n+\n+#[derive(Hash)]\n+enum SawTyComponent {\n+    SawTySlice,\n+    SawTyArray,\n+    SawTyPtr(Mutability),\n+    SawTyRptr(Mutability),\n+    SawTyBareFn(Unsafety, Abi),\n+    SawTyNever,\n+    SawTyTup,\n+    SawTyPath,\n+    SawTyObjectSum,\n+    SawTyPolyTraitRef,\n+    SawTyImplTrait,\n+    SawTyTypeof,\n+    SawTyInfer\n+}\n+\n+fn saw_ty(node: &Ty_) -> SawTyComponent {\n+    match *node {\n+      TySlice(..) => SawTySlice,\n+      TyArray(..) => SawTyArray,\n+      TyPtr(ref mty) => SawTyPtr(mty.mutbl),\n+      TyRptr(_, ref mty) => SawTyRptr(mty.mutbl),\n+      TyBareFn(ref barefnty) => SawTyBareFn(barefnty.unsafety, barefnty.abi),\n+      TyNever => SawTyNever,\n+      TyTup(..) => SawTyTup,\n+      TyPath(..) => SawTyPath,\n+      TyObjectSum(..) => SawTyObjectSum,\n+      TyPolyTraitRef(..) => SawTyPolyTraitRef,\n+      TyImplTrait(..) => SawTyImplTrait,\n+      TyTypeof(..) => SawTyTypeof,\n+      TyInfer => SawTyInfer\n+    }\n+}\n+\n+#[derive(Hash)]\n+enum SawTraitOrImplItemComponent {\n+    SawTraitOrImplItemConst,\n+    SawTraitOrImplItemMethod(Unsafety, Constness, Abi),\n+    SawTraitOrImplItemType\n+}\n+\n+fn saw_trait_item(ti: &TraitItem_) -> SawTraitOrImplItemComponent {\n+    match *ti {\n+        ConstTraitItem(..) => SawTraitOrImplItemConst,\n+        MethodTraitItem(ref sig, _) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi),\n+        TypeTraitItem(..) => SawTraitOrImplItemType\n+    }\n+}\n+\n+fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n+    match *ii {\n+        ImplItemKind::Const(..) => SawTraitOrImplItemConst,\n+        ImplItemKind::Method(ref sig, _) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi),\n+        ImplItemKind::Type(..) => SawTraitOrImplItemType\n+    }\n+}\n+\n #[derive(Clone, Copy, Hash, Eq, PartialEq)]\n enum SawSpanExpnKind {\n     NoExpansion,\n@@ -383,10 +519,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n-\n-        SawItem.hash(self.st);\n-        // Hash the value of the discriminant of the Item variant.\n-        self.hash_discriminant(&i.node);\n+        SawItem(saw_item(&i.node)).hash(self.st);\n         hash_span!(self, i.span);\n         hash_attrs!(self, &i.attrs);\n         visit::walk_item(self, i)\n@@ -399,7 +532,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_ty(&mut self, t: &'tcx Ty) {\n         debug!(\"visit_ty: st={:?}\", self.st);\n-        SawTy.hash(self.st);\n+        SawTy(saw_ty(&t.node)).hash(self.st);\n         hash_span!(self, t.span);\n         visit::walk_ty(self, t)\n     }\n@@ -412,17 +545,15 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n-        SawTraitItem.hash(self.st);\n-        self.hash_discriminant(&ti.node);\n+        SawTraitItem(saw_trait_item(&ti.node)).hash(self.st);\n         hash_span!(self, ti.span);\n         hash_attrs!(self, &ti.attrs);\n         visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n-        SawImplItem.hash(self.st);\n-        self.hash_discriminant(&ii.node);\n+        SawImplItem(saw_impl_item(&ii.node)).hash(self.st);\n         hash_span!(self, ii.span);\n         hash_attrs!(self, &ii.attrs);\n         visit::walk_impl_item(self, ii)\n@@ -452,8 +583,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_pat(&mut self, p: &'tcx Pat) {\n         debug!(\"visit_pat: st={:?}\", self.st);\n-        SawPat.hash(self.st);\n-        self.hash_discriminant(&p.node);\n+        SawPat(saw_pat(&p.node)).hash(self.st);\n         hash_span!(self, p.span);\n         visit::walk_pat(self, p)\n     }"}, {"sha": "ca8556496fa074d676711f26f80eb7d8aef27f3a", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -50,6 +50,7 @@ impl<'a> SimplifyCfg<'a> {\n \n impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n     fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n         CfgSimplifier::new(mir).simplify();\n         remove_dead_blocks(mir);\n \n@@ -78,6 +79,8 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n \n         // we can't use mir.predecessors() here because that counts\n         // dead blocks, which we don't want to.\n+        pred_count[START_BLOCK] = 1;\n+\n         for (_, data) in traversal::preorder(mir) {\n             if let Some(ref term) = data.terminator {\n                 for &tgt in term.successors().iter() {\n@@ -157,8 +160,16 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         debug!(\"collapsing goto chain from {:?} to {:?}\", *start, target);\n \n         *changed |= *start != target;\n-        self.pred_count[target] += 1;\n-        self.pred_count[*start] -= 1;\n+\n+        if self.pred_count[*start] == 1 {\n+            // This is the last reference to *start, so the pred-count to\n+            // to target is moved into the current block.\n+            self.pred_count[*start] = 0;\n+        } else {\n+            self.pred_count[target] += 1;\n+            self.pred_count[*start] -= 1;\n+        }\n+\n         *start = target;\n     }\n "}, {"sha": "e0e808f2dcca1848896a3c74c618be69e7215894", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 46, "deletions": 129, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -183,6 +183,14 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     StructGEP(bcx, fat_ptr, abi::FAT_PTR_ADDR)\n }\n \n+pub fn get_meta_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n+}\n+\n+pub fn get_dataptr_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n+}\n+\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n@@ -247,124 +255,6 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    lhs_addr: ValueRef,\n-                                    lhs_extra: ValueRef,\n-                                    rhs_addr: ValueRef,\n-                                    rhs_extra: ValueRef,\n-                                    _t: Ty<'tcx>,\n-                                    op: hir::BinOp_,\n-                                    debug_loc: DebugLoc)\n-                                    -> ValueRef {\n-    match op {\n-        hir::BiEq => {\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n-            And(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiNe => {\n-            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n-            Or(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n-            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n-            let (op, strict_op) = match op {\n-                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n-                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n-                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n-                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => bug!(),\n-            };\n-\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n-            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n-\n-            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n-            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n-        }\n-        _ => {\n-            bug!(\"unexpected fat ptr binop\");\n-        }\n-    }\n-}\n-\n-pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        lhs: ValueRef,\n-                                        rhs: ValueRef,\n-                                        t: Ty<'tcx>,\n-                                        op: hir::BinOp_,\n-                                        debug_loc: DebugLoc)\n-                                        -> ValueRef {\n-    match t.sty {\n-        ty::TyTuple(ref tys) if tys.is_empty() => {\n-            // We don't need to do actual comparisons for nil.\n-            // () == () holds but () < () does not.\n-            match op {\n-                hir::BiEq | hir::BiLe | hir::BiGe => return C_bool(bcx.ccx(), true),\n-                hir::BiNe | hir::BiLt | hir::BiGt => return C_bool(bcx.ccx(), false),\n-                // refinements would be nice\n-                _ => bug!(\"compare_scalar_types: must be a comparison operator\"),\n-            }\n-        }\n-        ty::TyBool => {\n-            // FIXME(#36856) -- using `from_immediate` forces these booleans into `i8`,\n-            // which works around some LLVM bugs\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 from_immediate(bcx, lhs),\n-                 from_immediate(bcx, rhs),\n-                 debug_loc)\n-        }\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyUint(_) | ty::TyChar => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyRawPtr(_) => {\n-            let lhs_addr = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_ADDR]));\n-            let lhs_extra = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_EXTRA]));\n-\n-            let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n-            let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n-            compare_fat_ptrs(bcx,\n-                             lhs_addr,\n-                             lhs_extra,\n-                             rhs_addr,\n-                             rhs_extra,\n-                             t,\n-                             op,\n-                             debug_loc)\n-        }\n-        ty::TyInt(_) => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, true),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyFloat(_) => {\n-            FCmp(bcx,\n-                 bin_op_to_fcmp_predicate(op),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        // Should never get here, because t is scalar.\n-        _ => bug!(\"non-scalar type passed to compare_scalar_types\"),\n-    }\n-}\n-\n pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -632,6 +522,11 @@ pub fn need_invoke(bcx: Block) -> bool {\n     }\n }\n \n+pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n+    let assume_intrinsic = b.ccx.get_intrinsic(\"llvm.assume\");\n+    b.call(assume_intrinsic, &[val], None);\n+}\n+\n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n@@ -685,12 +580,9 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n-        Store(cx,\n-              ExtractValue(cx, v, abi::FAT_PTR_ADDR),\n-              get_dataptr(cx, dst));\n-        Store(cx,\n-              ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n-              get_meta(cx, dst));\n+        let lladdr = ExtractValue(cx, v, abi::FAT_PTR_ADDR);\n+        let llextra = ExtractValue(cx, v, abi::FAT_PTR_EXTRA);\n+        store_fat_ptr(cx, lladdr, llextra, dst, t);\n     } else {\n         Store(cx, from_immediate(cx, v), dst);\n     }\n@@ -708,11 +600,36 @@ pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 src: ValueRef,\n-                                _ty: Ty<'tcx>)\n-                                -> (ValueRef, ValueRef) {\n-    // FIXME: emit metadata\n-    (Load(cx, get_dataptr(cx, src)),\n-     Load(cx, get_meta(cx, src)))\n+                                ty: Ty<'tcx>)\n+                                -> (ValueRef, ValueRef)\n+{\n+    if cx.unreachable.get() {\n+        // FIXME: remove me\n+        return (Load(cx, get_dataptr(cx, src)),\n+                Load(cx, get_meta(cx, src)));\n+    }\n+\n+    load_fat_ptr_builder(&B(cx), src, ty)\n+}\n+\n+pub fn load_fat_ptr_builder<'a, 'tcx>(\n+    b: &Builder<'a, 'tcx>,\n+    src: ValueRef,\n+    t: Ty<'tcx>)\n+    -> (ValueRef, ValueRef)\n+{\n+\n+    let ptr = get_dataptr_builder(b, src);\n+    let ptr = if t.is_region_ptr() || t.is_unique() {\n+        b.load_nonnull(ptr)\n+    } else {\n+        b.load(ptr)\n+    };\n+\n+    // FIXME: emit metadata on `meta`.\n+    let meta = b.load(get_meta_builder(b, src));\n+\n+    (ptr, meta)\n }\n \n pub fn from_immediate(bcx: Block, val: ValueRef) -> ValueRef {"}, {"sha": "c87497384ad6afbdeb8e9aa6c4a4558b5bd29da8", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -217,6 +217,10 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     llreffn: ValueRef)\n     -> ValueRef\n {\n+    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n+        return llfn;\n+    }\n+\n     debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={:?})\",\n            closure_def_id, substs, Value(llreffn));\n \n@@ -257,7 +261,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Create the by-value helper.\n     let function_name = method_instance.symbol_name(ccx.shared());\n-    let lloncefn = declare::declare_fn(ccx, &function_name, llonce_fn_ty);\n+    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -312,5 +316,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     fcx.finish(bcx, DebugLoc::None);\n \n+    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n+\n     lloncefn\n }"}, {"sha": "9edb489decc735f3c361c19b00940d046e528799", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -35,7 +35,7 @@ use syntax::parse::token;\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n-use super::lvalue::{LvalueRef, load_fat_ptr};\n+use super::lvalue::{LvalueRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::*;\n \n@@ -703,7 +703,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let ptr = adt::trans_field_ptr_builder(bcx, tuple.ty, base, Disr(0), n);\n                     let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-                        let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n+                        let (lldata, llextra) = base::load_fat_ptr_builder(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n                     } else {\n                         // trans_argument will load this if it needs to"}, {"sha": "8e65eac2e80894943b86e3cfe836346c6e3008cd", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -13,10 +13,8 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n-use abi;\n use adt;\n use base;\n-use builder::Builder;\n use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n@@ -69,18 +67,6 @@ impl<'tcx> LvalueRef<'tcx> {\n     }\n }\n \n-pub fn get_meta(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n-pub fn load_fat_ptr(b: &Builder, fat_ptr: ValueRef) -> (ValueRef, ValueRef) {\n-    (b.load(get_dataptr(b, fat_ptr)), b.load(get_meta(b, fat_ptr)))\n-}\n-\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n                         bcx: &BlockAndBuilder<'bcx, 'tcx>,"}, {"sha": "d5828f7c56c25ec2b382145ae221e1c2be56bea0", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -34,7 +34,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n pub use self::constant::trans_static_initializer;\n \n-use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n+use self::lvalue::{LvalueRef};\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -384,8 +384,10 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                     // they are the two sub-fields of a single aggregate field.\n                     let meta = &fcx.fn_ty.args[idx];\n                     idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n+                    arg.store_fn_arg(bcx, &mut llarg_idx,\n+                                     base::get_dataptr_builder(bcx, dst));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx,\n+                                      base::get_meta_builder(bcx, dst));\n                 } else {\n                     arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n@@ -466,8 +468,10 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 // so make an alloca to store them in.\n                 let meta = &fcx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, lltemp));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, lltemp));\n+                arg.store_fn_arg(bcx, &mut llarg_idx,\n+                                 base::get_dataptr_builder(bcx, lltemp));\n+                meta.store_fn_arg(bcx, &mut llarg_idx,\n+                                  base::get_meta_builder(bcx, lltemp));\n             } else  {\n                 // otherwise, arg is passed by value, so make a\n                 // temporary and store it there"}, {"sha": "c9d83a3375258df830c0141cb3d38cadb886b40f", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -143,20 +143,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n-        let val = if common::type_is_imm_pair(bcx.ccx(), ty) {\n+        let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+            let (lldata, llextra) = base::load_fat_ptr_builder(bcx, llval, ty);\n+            OperandValue::Pair(lldata, llextra)\n+        } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n+            let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx(), ty).unwrap();\n             let a_ptr = bcx.struct_gep(llval, 0);\n             let b_ptr = bcx.struct_gep(llval, 1);\n \n-            // This is None only for fat pointers, which don't\n-            // need any special load-time behavior anyway.\n-            let pair_fields = common::type_pair_fields(bcx.ccx(), ty);\n-            let (a, b) = if let Some([a_ty, b_ty]) = pair_fields {\n-                (base::load_ty_builder(bcx, a_ptr, a_ty),\n-                 base::load_ty_builder(bcx, b_ptr, b_ty))\n-            } else {\n-                (bcx.load(a_ptr), bcx.load(b_ptr))\n-            };\n-            OperandValue::Pair(a, b)\n+            OperandValue::Pair(\n+                base::load_ty_builder(bcx, a_ptr, a_ty),\n+                base::load_ty_builder(bcx, b_ptr, b_ty)\n+            )\n         } else if common::type_is_immediate(bcx.ccx(), ty) {\n             OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n         } else {"}, {"sha": "97aa475be68a7c3ef0860701080b3340f004b96d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 103, "deletions": 15, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -11,15 +11,18 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n+use rustc::ty::layout::Layout;\n use rustc::mir::repr as mir;\n \n use asm;\n use base;\n use callee::Callee;\n use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder, Result};\n+use common::{C_integral};\n use debuginfo::DebugLoc;\n use adt;\n use machine;\n+use type_::Type;\n use type_of;\n use tvec;\n use value::Value;\n@@ -28,7 +31,7 @@ use Disr;\n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::{LvalueRef, get_dataptr};\n+use super::lvalue::{LvalueRef};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -98,7 +101,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx(), size);\n-                let base = get_dataptr(&bcx, dest.llval);\n+                let base = base::get_dataptr_builder(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n                     tvec::slice_for_each(block, base, tr_elem.ty, size, |block, llslot| {\n                         self.store_operand_direct(block, llslot, tr_elem);\n@@ -281,7 +284,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 }\n                                 OperandValue::Pair(..) => bug!(\"Unexpected Pair operand\")\n                             };\n-                            (discr, adt::is_discr_signed(&l))\n+                            let (signed, min, max) = match l {\n+                                &Layout::CEnum { signed, min, max, .. } => {\n+                                    (signed, min, max)\n+                                }\n+                                _ => bug!(\"CEnum {:?} is not an enum\", operand)\n+                            };\n+\n+                            if max > min {\n+                                // We want `table[e as usize]` to not\n+                                // have bound checks, and this is the most\n+                                // convenient place to put the `assume`.\n+\n+                                base::call_assume(&bcx, bcx.icmp(\n+                                    llvm::IntULE,\n+                                    discr,\n+                                    C_integral(common::val_ty(discr), max, false)\n+                                ))\n+                            }\n+\n+                            (discr, signed)\n                         } else {\n                             (operand.immediate(), operand.ty.is_signed())\n                         };\n@@ -382,13 +404,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::Pair(lhs_addr, lhs_extra),\n                          OperandValue::Pair(rhs_addr, rhs_extra)) => {\n-                            bcx.with_block(|bcx| {\n-                                base::compare_fat_ptrs(bcx,\n-                                                       lhs_addr, lhs_extra,\n-                                                       rhs_addr, rhs_extra,\n-                                                       lhs.ty, op.to_hir_binop(),\n-                                                       debug_loc)\n-                            })\n+                            self.trans_fat_ptr_binop(&bcx, op,\n+                                                     lhs_addr, lhs_extra,\n+                                                     rhs_addr, rhs_extra,\n+                                                     lhs.ty)\n                         }\n                         _ => bug!()\n                     }\n@@ -485,6 +504,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                               input_ty: Ty<'tcx>) -> ValueRef {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n+        let is_nil = input_ty.is_nil();\n+        let is_bool = input_ty.is_bool();\n         match op {\n             mir::BinOp::Add => if is_float {\n                 bcx.fadd(lhs, rhs)\n@@ -535,12 +556,79 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                    DebugLoc::None)\n                 })\n             }\n-            mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n-            mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n-                bcx.with_block(|bcx| {\n-                    base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n-                                               op.to_hir_binop(), DebugLoc::None)\n+            mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n+            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n+                C_bool(bcx.ccx(), match op {\n+                    mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n+                    mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n+                    _ => unreachable!()\n                 })\n+            } else if is_float {\n+                bcx.fcmp(\n+                    base::bin_op_to_fcmp_predicate(op.to_hir_binop()),\n+                    lhs, rhs\n+                )\n+            } else {\n+                let (lhs, rhs) = if is_bool {\n+                    // FIXME(#36856) -- extend the bools into `i8` because\n+                    // LLVM's i1 comparisons are broken.\n+                    (bcx.zext(lhs, Type::i8(bcx.ccx())),\n+                     bcx.zext(rhs, Type::i8(bcx.ccx())))\n+                } else {\n+                    (lhs, rhs)\n+                };\n+\n+                bcx.icmp(\n+                    base::bin_op_to_icmp_predicate(op.to_hir_binop(), is_signed),\n+                    lhs, rhs\n+                )\n+            }\n+        }\n+    }\n+\n+    pub fn trans_fat_ptr_binop(&mut self,\n+                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                               op: mir::BinOp,\n+                               lhs_addr: ValueRef,\n+                               lhs_extra: ValueRef,\n+                               rhs_addr: ValueRef,\n+                               rhs_extra: ValueRef,\n+                               _input_ty: Ty<'tcx>)\n+                               -> ValueRef {\n+        match op {\n+            mir::BinOp::Eq => {\n+                bcx.and(\n+                    bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                    bcx.icmp(llvm::IntEQ, lhs_extra, rhs_extra)\n+                )\n+            }\n+            mir::BinOp::Ne => {\n+                bcx.or(\n+                    bcx.icmp(llvm::IntNE, lhs_addr, rhs_addr),\n+                    bcx.icmp(llvm::IntNE, lhs_extra, rhs_extra)\n+                )\n+            }\n+            mir::BinOp::Le | mir::BinOp::Lt |\n+            mir::BinOp::Ge | mir::BinOp::Gt => {\n+                // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+                let (op, strict_op) = match op {\n+                    mir::BinOp::Lt => (llvm::IntULT, llvm::IntULT),\n+                    mir::BinOp::Le => (llvm::IntULE, llvm::IntULT),\n+                    mir::BinOp::Gt => (llvm::IntUGT, llvm::IntUGT),\n+                    mir::BinOp::Ge => (llvm::IntUGE, llvm::IntUGT),\n+                    _ => bug!(),\n+                };\n+\n+                bcx.or(\n+                    bcx.icmp(strict_op, lhs_addr, rhs_addr),\n+                    bcx.and(\n+                        bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                        bcx.icmp(op, lhs_extra, rhs_extra)\n+                    )\n+                )\n+            }\n+            _ => {\n+                bug!(\"unexpected fat ptr binop\");\n             }\n         }\n     }"}, {"sha": "625b43c7d179255d44aefd33028a58ac1d26be7b", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -267,14 +267,14 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut initial_partitioning = place_root_translation_items(scx,\n                                                                 trans_items);\n \n-    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n+    debug_dump(scx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n \n-        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n+        debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n     // In the next step, we use the inlining map to determine which addtional\n@@ -284,7 +284,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                         inlining_map);\n \n-    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n+    debug_dump(scx, \"POST INLINING:\", post_inlining.0.iter());\n \n     // Finally, sort by codegen unit name, so that we get deterministic results\n     let mut result = post_inlining.0;\n@@ -552,7 +552,7 @@ fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString\n         index)[..])\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                label: &str,\n                                cgus: I)\n     where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n@@ -561,10 +561,21 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n         for cgu in cgus {\n+            let symbol_map = SymbolMap::build(scx, cgu.items\n+                                                      .iter()\n+                                                      .map(|(&trans_item, _)| trans_item));\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n             for (trans_item, linkage) in &cgu.items {\n-                debug!(\" - {} [{:?}]\", trans_item.to_string(tcx), linkage);\n+                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                let symbol_hash_start = symbol_name.rfind('h');\n+                let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n+                                                   .unwrap_or(\"<no hash>\");\n+\n+                debug!(\" - {} [{:?}] [{}]\",\n+                       trans_item.to_string(scx.tcx()),\n+                       linkage,\n+                       symbol_hash);\n             }\n \n             debug!(\"\");"}, {"sha": "ac785e4058bdee48833ab9e27a6ff8c37035047b", "filename": "src/librustc_typeck/variance/README.md", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -1,3 +1,5 @@\n+## Variance of type and lifetime parameters\n+\n This file infers the variance of type and lifetime parameters. The\n algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n@@ -52,11 +54,11 @@ These indicate that (1) the variance of A must be at most covariant;\n variance of C must be at most covariant *and* contravariant. All of these\n results are based on a variance lattice defined as follows:\n \n-      *      Top (bivariant)\n-   -     +\n-      o      Bottom (invariant)\n+       *      Top (bivariant)\n+    -     +\n+       o      Bottom (invariant)\n \n-Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n+Based on this lattice, the solution `V(A)=+`, `V(B)=-`, `V(C)=o` is the\n optimal solution. Note that there is always a naive solution which\n just declares all variables to be invariant.\n \n@@ -68,11 +70,11 @@ take the form:\n     V(X) <= Term\n     Term := + | - | * | o | V(X) | Term x Term\n \n-Here the notation V(X) indicates the variance of a type/region\n+Here the notation `V(X)` indicates the variance of a type/region\n parameter `X` with respect to its defining class. `Term x Term`\n represents the \"variance transform\" as defined in the paper:\n \n-  If the variance of a type variable `X` in type expression `E` is `V2`\n+>  If the variance of a type variable `X` in type expression `E` is `V2`\n   and the definition-site variance of the [corresponding] type parameter\n   of a class `C` is `V1`, then the variance of `X` in the type expression\n   `C<E>` is `V3 = V1.xform(V2)`.\n@@ -267,7 +269,7 @@ expressions -- must be invariant with respect to all of their\n inputs. To see why this makes sense, consider what subtyping for a\n trait reference means:\n \n-   <T as Trait> <: <U as Trait>\n+    <T as Trait> <: <U as Trait>\n \n means that if I know that `T as Trait`, I also know that `U as\n Trait`. Moreover, if you think of it as dictionary passing style,\n@@ -291,9 +293,9 @@ impl<T> Identity for T { type Out = T; ... }\n Now if I have `<&'static () as Identity>::Out`, this can be\n validly derived as `&'a ()` for any `'a`:\n \n-   <&'a () as Identity> <: <&'static () as Identity>\n-   if &'static () < : &'a ()   -- Identity is contravariant in Self\n-   if 'static : 'a             -- Subtyping rules for relations\n+    <&'a () as Identity> <: <&'static () as Identity>\n+    if &'static () < : &'a ()   -- Identity is contravariant in Self\n+    if 'static : 'a             -- Subtyping rules for relations\n \n This change otoh means that `<'static () as Identity>::Out` is\n always `&'static ()` (which might then be upcast to `'a ()`,"}, {"sha": "31497b6bd335256621cb1a418c10c2025fa24891", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -301,8 +301,8 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n         tcx.lang_items.char_impl(),\n         tcx.lang_items.str_impl(),\n         tcx.lang_items.slice_impl(),\n-        tcx.lang_items.slice_impl(),\n-        tcx.lang_items.const_ptr_impl()\n+        tcx.lang_items.const_ptr_impl(),\n+        tcx.lang_items.mut_ptr_impl(),\n     ];\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {"}, {"sha": "93b2d34e27f925d4efa8f232cc7aa415358f5489", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -231,7 +231,7 @@ impl<R: Seek> Seek for BufReader<R> {\n         if let SeekFrom::Current(n) = pos {\n             let remainder = (self.cap - self.pos) as i64;\n             // it should be safe to assume that remainder fits within an i64 as the alternative\n-            // means we managed to allocate 8 ebibytes and that's absurd.\n+            // means we managed to allocate 8 exbibytes and that's absurd.\n             // But it's not out of the realm of possibility for some weird underlying reader to\n             // support seeking by i64::min_value() so we need to handle underflow when subtracting\n             // remainder."}, {"sha": "74a46fce403aa2f7ca6a66d91c2966f44dbc76db", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -29,7 +29,7 @@ use sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\", taget_os = \"haiku\")))]\n+              target_os = \"solaris\", target_os = \"haiku\")))]\n use sys::net::netc::IPV6_ADD_MEMBERSHIP;\n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\","}, {"sha": "4cfb5a752dfdc0cadde5b8cf6ee2f2e5929b5300", "filename": "src/test/codegen/enum-bounds-check.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+pub enum Foo {\n+    A, B\n+}\n+\n+// CHECK-LABEL: @lookup\n+#[no_mangle]\n+pub fn lookup(buf: &[u8; 2], f: Foo) -> u8 {\n+    // CHECK-NOT: panic_bounds_check\n+    buf[f as usize]\n+}"}, {"sha": "824b86cfa83120755de6f06f93e39c93178b27ed", "filename": "src/test/compile-fail/E0004-2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fcompile-fail%2FE0004-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fcompile-fail%2FE0004-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0004-2.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     let x = Some(1);\n \n-    match x { } //~ ERROR E0002\n+    match x { } //~ ERROR E0004\n }", "previous_filename": "src/test/compile-fail/E0002.rs"}, {"sha": "80cc9e71c7ab45840d31be3223cc8d1fb484304a", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Test that changing what a `type` points to does not go unnoticed.\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+\n+#[rustc_if_this_changed]\n+type TypeAlias = u32;\n+\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+struct Struct {\n+    x: TypeAlias,\n+    y: u32\n+}\n+\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+enum Enum {\n+    Variant1(TypeAlias),\n+    Variant2(i32)\n+}\n+\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+trait Trait {\n+    fn method(&self, _: TypeAlias);\n+}\n+\n+struct SomeType;\n+\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+impl SomeType {\n+    fn method(&self, _: TypeAlias) {}\n+}\n+\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+type TypeAlias2 = TypeAlias;\n+\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+fn function(_: TypeAlias) {\n+\n+}"}, {"sha": "93d94cd1a19c4b83e20c16bfef8dc6c9921e4139", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -0,0 +1,400 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for function interfaces.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(conservative_impl_trait)]\n+#![feature(intrinsics)]\n+#![feature(linkage)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Add Parameter ---------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn add_parameter() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_parameter(p: i32) {}\n+\n+\n+// Add Return Type -------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn add_return_type() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_return_type() -> () {}\n+\n+\n+// Change Parameter Type -------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn type_of_parameter(p: i32) {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn type_of_parameter(p: i64) {}\n+\n+\n+// Change Parameter Type Reference ---------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn type_of_parameter_ref(p: &i32) {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn type_of_parameter_ref(p: &mut i32) {}\n+\n+\n+// Change Parameter Order ------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn order_of_parameters(p1: i32, p2: i64) {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn order_of_parameters(p2: i64, p1: i32) {}\n+\n+\n+// Unsafe ----------------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn make_unsafe() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+unsafe fn make_unsafe() {}\n+\n+\n+// Extern ----------------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn make_extern() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+extern fn make_extern() {}\n+\n+\n+// Extern C Extern Rust-Intrinsic ----------------------------------------------\n+\n+#[cfg(cfail1)]\n+extern \"C\" fn make_intrinsic() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+extern \"rust-intrinsic\" fn make_intrinsic() {}\n+\n+\n+// Type Parameter --------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn type_parameter() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn type_parameter<T>() {}\n+\n+\n+// Lifetime Parameter ----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn lifetime_parameter() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn lifetime_parameter<'a>() {}\n+\n+\n+// Trait Bound -----------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn trait_bound<T>() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn trait_bound<T: Eq>() {}\n+\n+\n+// Builtin Bound ---------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn builtin_bound<T>() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn builtin_bound<T: Send>() {}\n+\n+\n+// Lifetime Bound --------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn lifetime_bound<'a, T>() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn lifetime_bound<'a, T: 'a>() {}\n+\n+\n+// Second Trait Bound ----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn second_trait_bound<T: Eq>() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn second_trait_bound<T: Eq + Clone>() {}\n+\n+\n+// Second Builtin Bound --------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn second_builtin_bound<T: Send>() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn second_builtin_bound<T: Send + Sized>() {}\n+\n+\n+// Second Lifetime Bound -------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn second_lifetime_bound<'a, 'b, T: 'a>() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn second_lifetime_bound<'a, 'b, T: 'a + 'b>() {}\n+\n+\n+// Inline ----------------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn inline() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[inline]\n+fn inline() {}\n+\n+\n+// Inline Never ----------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+#[inline(always)]\n+fn inline_never() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[inline(never)]\n+fn inline_never() {}\n+\n+\n+// No Mangle -------------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn no_mangle() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[no_mangle]\n+fn no_mangle() {}\n+\n+\n+// Linkage ---------------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn linkage() {}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[linkage=\"weak_odr\"]\n+fn linkage() {}\n+\n+\n+// Return Impl Trait -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn return_impl_trait() -> i32 {\n+    0\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn return_impl_trait() -> impl Clone {\n+    0\n+}\n+\n+\n+// Change Return Impl Trait ----------------------------------------------------\n+\n+#[cfg(cfail1)]\n+fn change_return_impl_trait() -> impl Clone {\n+    0\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_return_impl_trait() -> impl Copy {\n+    0\n+}\n+\n+\n+// Change Return Type Indirectly -----------------------------------------------\n+\n+struct ReferencedType1;\n+struct ReferencedType2;\n+\n+mod change_return_type_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedType1 as ReturnType;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedType2 as ReturnType;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn indirect_return_type() -> ReturnType {\n+        ReturnType {}\n+    }\n+}\n+\n+\n+// Change Parameter Type Indirectly --------------------------------------------\n+\n+mod change_parameter_type_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedType1 as ParameterType;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedType2 as ParameterType;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn indirect_parameter_type(p: ParameterType) {}\n+}\n+\n+\n+// Change Trait Bound Indirectly -----------------------------------------------\n+\n+trait ReferencedTrait1 {}\n+trait ReferencedTrait2 {}\n+\n+mod change_trait_bound_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedTrait1 as Trait;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedTrait2 as Trait;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn indirect_trait_bound<T: Trait>(p: T) {}\n+}\n+\n+\n+// Change Trait Bound Indirectly In Where Clause -------------------------------\n+\n+mod change_trait_bound_indirectly_in_where_clause {\n+    #[cfg(cfail1)]\n+    use super::ReferencedTrait1 as Trait;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedTrait2 as Trait;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn indirect_trait_bound_where<T>(p: T) where T: Trait {}\n+}"}, {"sha": "f136d74fa517d6fab556b2b848371403625c2eeb", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -26,7 +26,7 @@ fn main() {}\n //     _2 = _1;\n //     _3 = _2;\n //     _0 = Baz { x: _3, y: const F32(0), z: const false };\n-//     goto -> bb1;\n+//     return;\n // }\n // END rustc.node13.Deaggregator.before.mir\n // START rustc.node13.Deaggregator.after.mir\n@@ -36,6 +36,6 @@ fn main() {}\n //     (_0.0: usize) = _3;\n //     (_0.1: f32) = const F32(0);\n //     (_0.2: bool) = const false;\n-//     goto -> bb1;\n+//     return;\n // }\n // END rustc.node13.Deaggregator.after.mir"}, {"sha": "25fa0e90835c601b8d9edd74247d49fae252c098", "filename": "src/test/mir-opt/deaggregator_test_enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -31,7 +31,7 @@ fn main() {\n //     _2 = _1;\n //     _3 = _2;\n //     _0 = Baz::Foo { x: _3 };\n-//     goto -> bb1;\n+//     return;\n // }\n // END rustc.node10.Deaggregator.before.mir\n // START rustc.node10.Deaggregator.after.mir\n@@ -40,6 +40,6 @@ fn main() {\n //     _3 = _2;\n //     ((_0 as Foo).0: usize) = _3;\n //     discriminant(_0) = 1;\n-//     goto -> bb1;\n+//     return;\n // }\n // END rustc.node10.Deaggregator.after.mir"}, {"sha": "933bfa8df2ec2bdac9bb9063fc9d556dc5c9dd67", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -38,10 +38,6 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_6);\n //         StorageDead(_1);\n-//         goto -> bb1;\n-//     }\n-//\n-//     bb1: {\n //         return;\n //     }\n // END rustc.node4.TypeckMir.before.mir"}, {"sha": "c1b14440faab6609bbf5f32c7d45adcc06d16d8b", "filename": "src/test/run-make/stable-symbol-names/Makefile", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -1,12 +1,16 @@\n -include ../tools.mk\n \n-# This test case makes sure that monomorphizations of the same function with the\n-# same set of generic arguments will have the same symbol names when\n-# instantiated in different crates.\n+# The following command will:\n+#  1. dump the symbols of a library using `nm`\n+#  2. extract only those lines that we are interested in via `grep`\n+#  3. from those lines, extract just the symbol name via `sed`\n+#     (symbol names always start with \"_ZN\" and end with \"E\")\n+#  4. sort those symbol names for deterministic comparison\n+#  5. write the result into a file\n \n dump-symbols = nm \"$(TMPDIR)/lib$(1).rlib\" \\\n-             |  grep \"some_test_function\" \\\n-             | sed \"s/^[0-9a-f]\\{8,16\\}/00000000/\" \\\n+             | grep -E \"some_test_function|Bar|bar\" \\\n+             | sed \"s/.*\\(_ZN.*E\\).*/\\1/\" \\\n              | sort \\\n              > \"$(TMPDIR)/$(1).nm\"\n "}, {"sha": "5c73ff0fab6d0ea16c608d0430b2ab20ee6a0c0d", "filename": "src/test/run-make/stable-symbol-names/stable-symbol-names1.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -10,6 +10,20 @@\n \n #![crate_type=\"rlib\"]\n \n+pub trait Foo {\n+  fn foo<T>();\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {\n+  fn foo<T>() {}\n+}\n+\n+pub fn bar() {\n+  Bar::foo::<Bar>();\n+}\n+\n pub fn some_test_function<T>(t: T) -> T {\n   t\n }"}, {"sha": "097dce876affc4428bf7c031b19532d40b513ef4", "filename": "src/test/run-make/stable-symbol-names/stable-symbol-names2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad19c32a58a1c5502e2f63350f72a2479c219498/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs?ref=ad19c32a58a1c5502e2f63350f72a2479c219498", "patch": "@@ -18,3 +18,9 @@ pub fn user() {\n   let x = 2u64;\n   stable_symbol_names1::some_test_function(&x);\n }\n+\n+pub fn trait_impl_test_function() {\n+  use stable_symbol_names1::*;\n+  Bar::foo::<Bar>();\n+  bar();\n+}"}]}