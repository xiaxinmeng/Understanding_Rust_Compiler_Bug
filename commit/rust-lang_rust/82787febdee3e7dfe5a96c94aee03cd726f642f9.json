{"sha": "82787febdee3e7dfe5a96c94aee03cd726f642f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNzg3ZmViZGVlM2U3ZGZlNWE5NmM5NGFlZTAzY2Q3MjZmNjQyZjk=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T17:31:12Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T18:11:12Z"}, "message": "allow local variables to be used after extracted body\n\nwhen variable is defined inside extracted body\nexport this variable to original scope via return value(s)", "tree": {"sha": "1fa901e779885b9ad79a6f691335352388d55691", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fa901e779885b9ad79a6f691335352388d55691"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82787febdee3e7dfe5a96c94aee03cd726f642f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82787febdee3e7dfe5a96c94aee03cd726f642f9", "html_url": "https://github.com/rust-lang/rust/commit/82787febdee3e7dfe5a96c94aee03cd726f642f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82787febdee3e7dfe5a96c94aee03cd726f642f9/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "313aa5f3a2a9237c96c97c5852da39cf83bcb1ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/313aa5f3a2a9237c96c97c5852da39cf83bcb1ae", "html_url": "https://github.com/rust-lang/rust/commit/313aa5f3a2a9237c96c97c5852da39cf83bcb1ae"}], "stats": {"total": 224, "additions": 183, "deletions": 41}, "files": [{"sha": "c5e6ec7331bd95e48c517fa69dab272fa8a8e7c1", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 183, "deletions": 41, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/82787febdee3e7dfe5a96c94aee03cd726f642f9/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82787febdee3e7dfe5a96c94aee03cd726f642f9/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=82787febdee3e7dfe5a96c94aee03cd726f642f9", "patch": "@@ -1,7 +1,10 @@\n use either::Either;\n use hir::{HirDisplay, Local};\n-use ide_db::defs::{Definition, NameRefClass};\n-use rustc_hash::FxHashSet;\n+use ide_db::{\n+    defs::{Definition, NameRefClass},\n+    search::SearchScope,\n+};\n+use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     ast::{\n@@ -81,9 +84,10 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     }\n     let body = body?;\n \n+    let vars_used_in_body = vars_used_in_body(&body, &ctx);\n     let mut self_param = None;\n-    let mut param_pats: Vec<_> = local_variables(&body, &ctx)\n-        .into_iter()\n+    let param_pats: Vec<_> = vars_used_in_body\n+        .iter()\n         .map(|node| node.source(ctx.db()))\n         .filter(|src| {\n             src.file_id.original_file(ctx.db()) == ctx.frange.file_id\n@@ -98,12 +102,27 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n             }\n         })\n         .collect();\n-    deduplicate_params(&mut param_pats);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n     let insert_after = body.scope_for_fn_insertion(anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n+    let vars_defined_in_body = vars_defined_in_body(&body, ctx);\n+\n+    let vars_in_body_used_afterwards: Vec<_> = vars_defined_in_body\n+        .iter()\n+        .copied()\n+        .filter(|node| {\n+            let usages = Definition::Local(*node)\n+                .usages(&ctx.sema)\n+                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+                .all();\n+            let mut usages = usages.iter().flat_map(|(_, rs)| rs.iter());\n+\n+            usages.any(|reference| body.preceedes_range(reference.range))\n+        })\n+        .collect();\n+\n     let params = param_pats\n         .into_iter()\n         .map(|pat| {\n@@ -119,20 +138,18 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         })\n         .collect::<Vec<_>>();\n \n-    let self_param =\n-        if let Some(self_param) = self_param { Some(self_param.to_string()) } else { None };\n-\n     let expr = body.tail_expr();\n     let ret_ty = match expr {\n-        Some(expr) => {\n-            // FIXME: can we do assist when type is unknown?\n-            //        We can insert something like `-> ()`\n-            let ty = ctx.sema.type_of_expr(&expr)?;\n-            Some(ty.display_source_code(ctx.db(), module.into()).ok()?)\n-        }\n+        Some(expr) => Some(ctx.sema.type_of_expr(&expr)?),\n         None => None,\n     };\n \n+    let has_unit_ret = ret_ty.as_ref().map_or(true, |it| it.is_unit());\n+    if stdx::never!(!vars_in_body_used_afterwards.is_empty() && !has_unit_ret) {\n+        // We should not have variables that outlive body if we have expression block\n+        return None;\n+    }\n+\n     let target_range = match &body {\n         FunctionBody::Expr(expr) => expr.syntax().text_range(),\n         FunctionBody::Span { .. } => ctx.frange.range,\n@@ -143,21 +160,46 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n-            let fun = Function { name: \"fun_name\".to_string(), self_param, params, ret_ty, body };\n+            let fun = Function {\n+                name: \"fun_name\".to_string(),\n+                self_param,\n+                params,\n+                ret_ty,\n+                body,\n+                vars_in_body_used_afterwards,\n+            };\n \n-            builder.replace(target_range, format_replacement(&fun));\n+            builder.replace(target_range, format_replacement(ctx, &fun));\n \n             let indent = IndentLevel::from_node(&insert_after);\n \n-            let fn_def = format_function(&fun, indent);\n+            let fn_def = format_function(ctx, module, &fun, indent);\n             let insert_offset = insert_after.text_range().end();\n             builder.insert(insert_offset, fn_def);\n         },\n     )\n }\n \n-fn format_replacement(fun: &Function) -> String {\n+fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n     let mut buf = String::new();\n+\n+    match fun.vars_in_body_used_afterwards.len() {\n+        0 => {}\n+        1 => format_to!(\n+            buf,\n+            \"let {} = \",\n+            fun.vars_in_body_used_afterwards[0].name(ctx.db()).unwrap()\n+        ),\n+        _ => {\n+            buf.push_str(\"let (\");\n+            format_to!(buf, \"{}\", fun.vars_in_body_used_afterwards[0].name(ctx.db()).unwrap());\n+            for local in fun.vars_in_body_used_afterwards.iter().skip(1) {\n+                format_to!(buf, \", {}\", local.name(ctx.db()).unwrap());\n+            }\n+            buf.push_str(\") = \");\n+        }\n+    }\n+\n     if fun.self_param.is_some() {\n         format_to!(buf, \"self.\");\n     }\n@@ -182,16 +224,17 @@ fn format_replacement(fun: &Function) -> String {\n \n struct Function {\n     name: String,\n-    self_param: Option<String>,\n+    self_param: Option<ast::SelfParam>,\n     params: Vec<Param>,\n-    ret_ty: Option<String>,\n+    ret_ty: Option<hir::Type>,\n     body: FunctionBody,\n+    vars_in_body_used_afterwards: Vec<Local>,\n }\n \n impl Function {\n     fn has_unit_ret(&self) -> bool {\n         match &self.ret_ty {\n-            Some(ty) => ty == \"()\",\n+            Some(ty) => ty.is_unit(),\n             None => true,\n         }\n     }\n@@ -203,7 +246,12 @@ struct Param {\n     ty: String,\n }\n \n-fn format_function(fun: &Function, indent: IndentLevel) -> String {\n+fn format_function(\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+    indent: IndentLevel,\n+) -> String {\n     let mut fn_def = String::new();\n     format_to!(fn_def, \"\\n\\n{}fn $0{}(\", indent, fun.name);\n     {\n@@ -221,10 +269,24 @@ fn format_function(fun: &Function, indent: IndentLevel) -> String {\n     format_to!(fn_def, \")\");\n     if !fun.has_unit_ret() {\n         if let Some(ty) = &fun.ret_ty {\n-            format_to!(fn_def, \" -> {}\", ty);\n+            format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n+        }\n+    } else {\n+        match fun.vars_in_body_used_afterwards.as_slice() {\n+            [] => {}\n+            [var] => {\n+                format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+            }\n+            [v0, vs @ ..] => {\n+                format_to!(fn_def, \" -> ({}\", format_type(&v0.ty(ctx.db()), ctx, module));\n+                for var in vs {\n+                    format_to!(fn_def, \", {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+                }\n+                fn_def.push(')');\n+            }\n         }\n     }\n-    format_to!(fn_def, \" {{\");\n+    fn_def.push_str(\" {\");\n \n     match &fun.body {\n         FunctionBody::Expr(expr) => {\n@@ -243,11 +305,28 @@ fn format_function(fun: &Function, indent: IndentLevel) -> String {\n             }\n         }\n     }\n+\n+    match fun.vars_in_body_used_afterwards.as_slice() {\n+        [] => {}\n+        [var] => format_to!(fn_def, \"{}{}\\n\", indent + 1, var.name(ctx.db()).unwrap()),\n+        [v0, vs @ ..] => {\n+            format_to!(fn_def, \"{}({}\", indent + 1, v0.name(ctx.db()).unwrap());\n+            for var in vs {\n+                format_to!(fn_def, \", {}\", var.name(ctx.db()).unwrap());\n+            }\n+            fn_def.push_str(\")\\n\");\n+        }\n+    }\n+\n     format_to!(fn_def, \"{}}}\", indent);\n \n     fn_def\n }\n \n+fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n+    ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n+}\n+\n #[derive(Debug)]\n enum FunctionBody {\n     Expr(ast::Expr),\n@@ -339,18 +418,26 @@ impl FunctionBody {\n         }\n     }\n \n-    fn contains_node(&self, node: &SyntaxNode) -> bool {\n-        fn is_node(body: &FunctionBody, n: &SyntaxNode) -> bool {\n-            match body {\n-                FunctionBody::Expr(expr) => n == expr.syntax(),\n-                FunctionBody::Span { elements, .. } => {\n-                    // FIXME: can it be quadratic?\n-                    elements.iter().filter_map(SyntaxElement::as_node).any(|e| e == n)\n-                }\n-            }\n+    fn text_range(&self) -> TextRange {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().text_range(),\n+            FunctionBody::Span { elements, .. } => TextRange::new(\n+                elements.first().unwrap().text_range().start(),\n+                elements.last().unwrap().text_range().end(),\n+            ),\n         }\n+    }\n+\n+    fn contains_range(&self, range: TextRange) -> bool {\n+        self.text_range().contains_range(range)\n+    }\n \n-        node.ancestors().any(|a| is_node(self, &a))\n+    fn preceedes_range(&self, range: TextRange) -> bool {\n+        self.text_range().end() <= range.start()\n+    }\n+\n+    fn contains_node(&self, node: &SyntaxNode) -> bool {\n+        self.contains_range(node.text_range())\n     }\n }\n \n@@ -383,20 +470,15 @@ fn scope_for_fn_insertion(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n-fn deduplicate_params(params: &mut Vec<ast::IdentPat>) {\n-    let mut seen_params = FxHashSet::default();\n-    params.retain(|p| seen_params.insert(p.clone()));\n-}\n-\n fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     match value {\n         Either::Left(pat) => pat.syntax(),\n         Either::Right(it) => it.syntax(),\n     }\n }\n \n-/// Returns a vector of local variables that are refferenced in `body`\n-fn local_variables(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+/// Returns a vector of local variables that are referenced in `body`\n+fn vars_used_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n     body.descendants()\n         .filter_map(ast::NameRef::cast)\n         .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n@@ -405,6 +487,16 @@ fn local_variables(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n             Definition::Local(local) => Some(local),\n             _ => None,\n         })\n+        .unique()\n+        .collect()\n+}\n+\n+/// Returns a vector of local variables that are defined in `body`\n+fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+    body.descendants()\n+        .filter_map(ast::IdentPat::cast)\n+        .filter_map(|let_stmt| ctx.sema.to_def(&let_stmt))\n+        .unique()\n         .collect()\n }\n \n@@ -970,6 +1062,56 @@ impl S {\n     fn $0fun_name(&self) -> i32 {\n         1+self.f\n     }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn variable_defined_inside_and_used_after_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let k = n * n;$0\n+    let m = k + 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let k = fun_name(n);\n+    let m = k + 1;\n+}\n+\n+fn $0fun_name(n: i32) -> i32 {\n+    let k = n * n;\n+    k\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn two_variables_defined_inside_and_used_after_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let k = n * n;\n+    let m = k + 2;$0\n+    let h = k + m;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let (k, m) = fun_name(n);\n+    let h = k + m;\n+}\n+\n+fn $0fun_name(n: i32) -> (i32, i32) {\n+    let k = n * n;\n+    let m = k + 2;\n+    (k, m)\n }\",\n         );\n     }"}]}