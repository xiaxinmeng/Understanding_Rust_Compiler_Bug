{"sha": "97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MjE2YTZjZTVmNTZhMGJiZmYwZDkxZGQ1YmQ0NDNmOTBiZDc2ZWI=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-04-16T04:21:53Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-05-09T12:31:47Z"}, "message": "Add new atomic integer types", "tree": {"sha": "7d648684fc5c8674210a64de339f7ae62bbe24fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d648684fc5c8674210a64de339f7ae62bbe24fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb", "html_url": "https://github.com/rust-lang/rust/commit/97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04835ea5ec669636fdfbd84d17dbdda4c36bdd9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/04835ea5ec669636fdfbd84d17dbdda4c36bdd9c", "html_url": "https://github.com/rust-lang/rust/commit/04835ea5ec669636fdfbd84d17dbdda4c36bdd9c"}], "stats": {"total": 1020, "additions": 418, "deletions": 602}, "files": [{"sha": "cf3e45cf3de79baf85a79adc15b4121353477a1c", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 418, "deletions": 602, "changes": 1020, "blob_url": "https://github.com/rust-lang/rust/blob/97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=97216a6ce5f56a0bbff0d91dd5bd443f90bd76eb", "patch": "@@ -83,11 +83,13 @@ use default::Default;\n use fmt;\n \n /// A boolean type which can be safely shared between threads.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     fn default() -> Self {\n@@ -96,58 +98,29 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n-/// A signed integer type which can be safely shared between threads.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct AtomicIsize {\n-    v: UnsafeCell<isize>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for AtomicIsize {\n-    fn default() -> Self {\n-        Self::new(Default::default())\n-    }\n-}\n-\n-// Send is implicitly implemented for AtomicIsize.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl Sync for AtomicIsize {}\n-\n-/// An unsigned integer type which can be safely shared between threads.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct AtomicUsize {\n-    v: UnsafeCell<usize>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for AtomicUsize {\n-    fn default() -> Self {\n-        Self::new(Default::default())\n-    }\n-}\n-\n-// Send is implicitly implemented for AtomicUsize.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl Sync for AtomicUsize {}\n-\n /// A raw pointer type which can be safely shared between threads.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     fn default() -> AtomicPtr<T> {\n         AtomicPtr::new(::ptr::null_mut())\n     }\n }\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -189,18 +162,15 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n-/// An `AtomicIsize` initialized to `0`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_ISIZE_INIT: AtomicIsize = AtomicIsize::new(0);\n-/// An `AtomicUsize` initialized to `0`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize::new(0);\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n const UINT_TRUE: usize = !0;\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -543,557 +513,7 @@ impl AtomicBool {\n     }\n }\n \n-impl AtomicIsize {\n-    /// Creates a new `AtomicIsize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::AtomicIsize;\n-    ///\n-    /// let atomic_forty_two  = AtomicIsize::new(42);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn new(v: isize) -> AtomicIsize {\n-        AtomicIsize {v: UnsafeCell::new(v)}\n-    }\n-\n-    /// Loads a value from the isize.\n-    ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn load(&self, order: Ordering) -> isize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    /// Stores a value into the isize.\n-    ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// some_isize.store(10, Ordering::Relaxed);\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn store(&self, val: isize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Stores a value into the isize, returning the old value.\n-    ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n-    ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n-        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n-            Ok(x) => x,\n-            Err(x) => x,\n-        }\n-    }\n-\n-    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is a result indicating whether the new value was written and containing\n-    /// the previous value. On success this value is guaranteed to be equal to `new`.\n-    ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(5, 10,\n-    ///                                        Ordering::Acquire,\n-    ///                                        Ordering::Relaxed),\n-    ///            Ok(5));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(6, 12,\n-    ///                                        Ordering::SeqCst,\n-    ///                                        Ordering::Acquire),\n-    ///            Err(10));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange(&self,\n-                            current: isize,\n-                            new: isize,\n-                            success: Ordering,\n-                            failure: Ordering) -> Result<isize, isize> {\n-        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n-    ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n-    /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// return value is a result indicating whether the new value was written and containing the\n-    /// previous value.\n-    ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let val = AtomicIsize::new(4);\n-    ///\n-    /// let mut old = val.load(Ordering::Relaxed);\n-    /// loop {\n-    ///     let new = old * 2;\n-    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-    ///         Ok(_) => break,\n-    ///         Err(x) => old = x,\n-    ///     }\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange_weak(&self,\n-                                 current: isize,\n-                                 new: isize,\n-                                 success: Ordering,\n-                                 failure: Ordering) -> Result<isize, isize> {\n-        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Add an isize to the current value, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0);\n-    /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract an isize from the current value, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0);\n-    /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current isize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current isize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current isize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-impl AtomicUsize {\n-    /// Creates a new `AtomicUsize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::AtomicUsize;\n-    ///\n-    /// let atomic_forty_two = AtomicUsize::new(42);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn new(v: usize) -> AtomicUsize {\n-        AtomicUsize { v: UnsafeCell::new(v) }\n-    }\n-\n-    /// Loads a value from the usize.\n-    ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn load(&self, order: Ordering) -> usize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    /// Stores a value into the usize.\n-    ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// some_usize.store(10, Ordering::Relaxed);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn store(&self, val: usize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Stores a value into the usize, returning the old value.\n-    ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_usize.swap(10, Ordering::Relaxed), 5);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n-    ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_usize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_usize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n-        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n-            Ok(x) => x,\n-            Err(x) => x,\n-        }\n-    }\n-\n-    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is a result indicating whether the new value was written and containing\n-    /// the previous value. On success this value is guaranteed to be equal to `new`.\n-    ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(5, 10,\n-    ///                                        Ordering::Acquire,\n-    ///                                        Ordering::Relaxed),\n-    ///            Ok(5));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(6, 12,\n-    ///                                        Ordering::SeqCst,\n-    ///                                        Ordering::Acquire),\n-    ///            Err(10));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange(&self,\n-                            current: usize,\n-                            new: usize,\n-                            success: Ordering,\n-                            failure: Ordering) -> Result<usize, usize> {\n-        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n-    ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n-    /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// return value is a result indicating whether the new value was written and containing the\n-    /// previous value.\n-    ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let val = AtomicUsize::new(4);\n-    ///\n-    /// let mut old = val.load(Ordering::Relaxed);\n-    /// loop {\n-    ///     let new = old * 2;\n-    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-    ///         Ok(_) => break,\n-    ///         Err(x) => old = x,\n-    ///     }\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange_weak(&self,\n-                                 current: usize,\n-                                 new: usize,\n-                                 success: Ordering,\n-                                 failure: Ordering) -> Result<usize, usize> {\n-        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Add to the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0);\n-    /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(10);\n-    /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 10);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -1311,6 +731,405 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n+macro_rules! atomic_int {\n+    ($stable:meta,\n+     $stable_cxchg:meta,\n+     $stable_debug:meta,\n+     $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n+        /// An integer type which can be safely shared between threads.\n+        #[$stable]\n+        pub struct $atomic_type {\n+            v: UnsafeCell<$int_type>,\n+        }\n+\n+        /// An atomic integer initialized to `0`.\n+        #[$stable]\n+        pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n+\n+        #[$stable]\n+        impl Default for $atomic_type {\n+            fn default() -> Self {\n+                Self::new(Default::default())\n+            }\n+        }\n+\n+        #[$stable_debug]\n+        impl fmt::Debug for $atomic_type {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                f.debug_tuple(stringify!($atomic_type))\n+                 .field(&self.load(Ordering::SeqCst))\n+                 .finish()\n+            }\n+        }\n+\n+        // Send is implicitly implemented.\n+        #[$stable]\n+        unsafe impl Sync for $atomic_type {}\n+\n+        impl $atomic_type {\n+            /// Creates a new atomic integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::AtomicIsize;\n+            ///\n+            /// let atomic_forty_two  = AtomicIsize::new(42);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub const fn new(v: $int_type) -> Self {\n+                $atomic_type {v: UnsafeCell::new(v)}\n+            }\n+\n+            /// Loads a value from the atomic integer.\n+            ///\n+            /// `load` takes an `Ordering` argument which describes the memory ordering of this\n+            /// operation.\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `order` is `Release` or `AcqRel`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn load(&self, order: Ordering) -> $int_type {\n+                unsafe { atomic_load(self.v.get(), order) }\n+            }\n+\n+            /// Stores a value into the atomic integer.\n+            ///\n+            /// `store` takes an `Ordering` argument which describes the memory ordering of this\n+            /// operation.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// some_isize.store(10, Ordering::Relaxed);\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            /// ```\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `order` is `Acquire` or `AcqRel`.\n+            #[inline]\n+            #[$stable]\n+            pub fn store(&self, val: $int_type, order: Ordering) {\n+                unsafe { atomic_store(self.v.get(), val, order); }\n+            }\n+\n+            /// Stores a value into the atomic integer, returning the old value.\n+            ///\n+            /// `swap` takes an `Ordering` argument which describes the memory ordering of this\n+            /// operation.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_swap(self.v.get(), val, order) }\n+            }\n+\n+            /// Stores a value into the atomic integer if the current value is the same as the\n+            /// `current` value.\n+            ///\n+            /// The return value is always the previous value. If it is equal to `current`, then the\n+            /// value was updated.\n+            ///\n+            /// `compare_and_swap` also takes an `Ordering` argument which describes the memory\n+            /// ordering of this operation.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            ///\n+            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn compare_and_swap(&self,\n+                                    current: $int_type,\n+                                    new: $int_type,\n+                                    order: Ordering) -> $int_type {\n+                match self.compare_exchange(current,\n+                                            new,\n+                                            order,\n+                                            strongest_failure_ordering(order)) {\n+                    Ok(x) => x,\n+                    Err(x) => x,\n+                }\n+            }\n+\n+            /// Stores a value into the atomic integer if the current value is the same as the\n+            /// `current` value.\n+            ///\n+            /// The return value is a result indicating whether the new value was written and\n+            /// containing the previous value. On success this value is guaranteed to be equal to\n+            /// `new`.\n+            ///\n+            /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of\n+            /// this operation. The first describes the required ordering if the operation succeeds\n+            /// while the second describes the required ordering when the operation fails. The\n+            /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker\n+            /// than the success ordering.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(extended_compare_and_swap)]\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.compare_exchange(5, 10,\n+            ///                                        Ordering::Acquire,\n+            ///                                        Ordering::Relaxed),\n+            ///            Ok(5));\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            ///\n+            /// assert_eq!(some_isize.compare_exchange(6, 12,\n+            ///                                        Ordering::SeqCst,\n+            ///                                        Ordering::Acquire),\n+            ///            Err(10));\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable_cxchg]\n+            pub fn compare_exchange(&self,\n+                                    current: $int_type,\n+                                    new: $int_type,\n+                                    success: Ordering,\n+                                    failure: Ordering) -> Result<$int_type, $int_type> {\n+                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+            }\n+\n+            /// Stores a value into the atomic integer if the current value is the same as the\n+            /// `current` value.\n+            ///\n+            /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+            /// comparison succeeds, which can result in more efficient code on some platforms. The\n+            /// return value is a result indicating whether the new value was written and containing\n+            /// the previous value.\n+            ///\n+            /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+            /// ordering of this operation. The first describes the required ordering if the\n+            /// operation succeeds while the second describes the required ordering when the\n+            /// operation fails. The failure ordering can't be `Release` or `AcqRel` and must be\n+            /// equivalent or weaker than the success ordering.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(extended_compare_and_swap)]\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let val = AtomicIsize::new(4);\n+            ///\n+            /// let mut old = val.load(Ordering::Relaxed);\n+            /// loop {\n+            ///     let new = old * 2;\n+            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+            ///         Ok(_) => break,\n+            ///         Err(x) => old = x,\n+            ///     }\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[$stable_cxchg]\n+            pub fn compare_exchange_weak(&self,\n+                                         current: $int_type,\n+                                         new: $int_type,\n+                                         success: Ordering,\n+                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                unsafe {\n+                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+                }\n+            }\n+\n+            /// Add to the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0);\n+            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_add(self.v.get(), val, order) }\n+            }\n+\n+            /// Subtract from the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0);\n+            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_sub(self.v.get(), val, order) }\n+            }\n+\n+            /// Bitwise and with the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0b101101);\n+            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_and(self.v.get(), val, order) }\n+            }\n+\n+            /// Bitwise or with the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0b101101);\n+            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_or(self.v.get(), val, order) }\n+            }\n+\n+            /// Bitwise xor with the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0b101101);\n+            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_xor(self.v.get(), val, order) }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(target_has_atomic = \"8\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i8 AtomicI8 ATOMIC_I8_INIT\n+}\n+#[cfg(target_has_atomic = \"8\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u8 AtomicU8 ATOMIC_U8_INIT\n+}\n+#[cfg(target_has_atomic = \"16\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i16 AtomicI16 ATOMIC_I16_INIT\n+}\n+#[cfg(target_has_atomic = \"16\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u16 AtomicU16 ATOMIC_U16_INIT\n+}\n+#[cfg(target_has_atomic = \"32\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i32 AtomicI32 ATOMIC_I32_INIT\n+}\n+#[cfg(target_has_atomic = \"32\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u32 AtomicU32 ATOMIC_U32_INIT\n+}\n+#[cfg(target_has_atomic = \"64\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i64 AtomicI64 ATOMIC_I64_INIT\n+}\n+#[cfg(target_has_atomic = \"64\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u64 AtomicU64 ATOMIC_U64_INIT\n+}\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n+atomic_int!{\n+    stable(feature = \"rust1\", since = \"1.0.0\"),\n+    unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\"),\n+    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n+    isize AtomicIsize ATOMIC_ISIZE_INIT\n+}\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n+atomic_int!{\n+    stable(feature = \"rust1\", since = \"1.0.0\"),\n+    unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\"),\n+    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n+    usize AtomicUsize ATOMIC_USIZE_INIT\n+}\n+\n #[inline]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n@@ -1514,19 +1333,16 @@ pub fn fence(order: Ordering) {\n     }\n }\n \n-macro_rules! impl_Debug {\n-    ($($t:ident)*) => ($(\n-        #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n-        impl fmt::Debug for $t {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                f.debug_tuple(stringify!($t)).field(&self.load(Ordering::SeqCst)).finish()\n-            }\n-        }\n-    )*);\n-}\n \n-impl_Debug!{ AtomicUsize AtomicIsize AtomicBool }\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n+#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n+impl fmt::Debug for AtomicBool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"AtomicBool\").field(&self.load(Ordering::SeqCst)).finish()\n+    }\n+}\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}]}