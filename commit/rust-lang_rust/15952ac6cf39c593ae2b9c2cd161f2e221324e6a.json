{"sha": "15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OTUyYWM2Y2YzOWM1OTNhZTJiOWMyY2QxNjFmMmUyMjEzMjRlNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-08T19:26:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-08T19:26:30Z"}, "message": "Auto merge of #26894 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #26687, #26784, #26850, #26889, #26891, #26892, #26893\n- Failed merges:", "tree": {"sha": "d98060271ef0c504b8228a8d439e4e3b431f2cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d98060271ef0c504b8228a8d439e4e3b431f2cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "html_url": "https://github.com/rust-lang/rust/commit/15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50df2a09b8b9dd4883eb27d833a8482799175a3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/50df2a09b8b9dd4883eb27d833a8482799175a3b", "html_url": "https://github.com/rust-lang/rust/commit/50df2a09b8b9dd4883eb27d833a8482799175a3b"}, {"sha": "546ce79570c618c0f5ffa72e85535675fab43408", "url": "https://api.github.com/repos/rust-lang/rust/commits/546ce79570c618c0f5ffa72e85535675fab43408", "html_url": "https://github.com/rust-lang/rust/commit/546ce79570c618c0f5ffa72e85535675fab43408"}], "stats": {"total": 89, "additions": 71, "deletions": 18}, "files": [{"sha": "93054f39790858882e47d0cdab6f9851bc51eb2e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -1702,8 +1702,11 @@ fn run_codegen_test(config: &Config, props: &TestProps, testfile: &Path) {\n }\n \n fn charset() -> &'static str {\n-    if cfg!(any(target_os = \"bitrig\", target_os = \"freebsd\")) {\n+    // FreeBSD 10.1 defaults to GDB 6.1.1 which doesn't support \"auto\" charset\n+    if cfg!(target_os = \"bitrig\") {\n         \"auto\"\n+    } else if cfg!(target_os = \"freebsd\") {\n+        \"ISO-8859-1\"\n     } else {\n         \"UTF-8\"\n     }"}, {"sha": "5e99876f5dab8c3f3eb5f2feda6fc5a6b0a298df", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -99,7 +99,7 @@ Second, it makes cost explicit. In general, the only safe way to have a\n non-exhaustive match would be to panic the thread if nothing is matched, though\n it could fall through if the type of the `match` expression is `()`. This sort\n of hidden cost and special casing is against the language's philosophy. It's\n-easy to ignore certain cases by using the `_` wildcard:\n+easy to ignore all unspecified cases by using the `_` wildcard:\n \n ```rust,ignore\n match val.do_something() {"}, {"sha": "1784c253f7f47ae90223ff539f4bf257c4594c96", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -360,10 +360,12 @@ rand=\"0.3.0\"\n The `[dependencies]` section of `Cargo.toml` is like the `[package]` section:\n everything that follows it is part of it, until the next section starts.\n Cargo uses the dependencies section to know what dependencies on external\n-crates you have, and what versions you require. In this case, we\u2019ve used version `0.3.0`.\n+crates you have, and what versions you require. In this case, we\u2019ve specified version `0.3.0`,\n+which Cargo understands to be any release that\u2019s compatible with this specific version.\n Cargo understands [Semantic Versioning][semver], which is a standard for writing version\n-numbers. If we wanted to use the latest version we could use `*` or we could use a range\n-of versions. [Cargo\u2019s documentation][cargodoc] contains more details.\n+numbers. If we wanted to use only `0.3.0` exactly, we could use `=0.3.0`. If we\n+wanted to use the latest version we could use `*`; We could use a range of\n+versions. [Cargo\u2019s documentation][cargodoc] contains more details.\n \n [semver]: http://semver.org\n [cargodoc]: http://doc.crates.io/crates-io.html"}, {"sha": "47030bf0fb31efc989952e8f53fcf9b1122eb44a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -273,6 +273,8 @@ impl<'a> Display for Arguments<'a> {\n ///\n /// Generally speaking, you should just `derive` a `Debug` implementation.\n ///\n+/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n+///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n /// [module]: ../index.html\n@@ -314,13 +316,42 @@ impl<'a> Display for Arguments<'a> {\n /// println!(\"The origin is: {:?}\", origin);\n /// ```\n ///\n+/// This outputs:\n+///\n+/// ```text\n+/// The origin is: Point { x: 0, y: 0 }\n+/// ```\n+///\n /// There are a number of `debug_*` methods on `Formatter` to help you with manual\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n /// on `Formatter` support pretty printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../std/fmt/struct.Formatter.html#method.debug_struct\n+///\n+/// Pretty printing with `#?`:\n+///\n+/// ```\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// let origin = Point { x: 0, y: 0 };\n+///\n+/// println!(\"The origin is: {:#?}\", origin);\n+/// ```\n+///\n+/// This outputs:\n+///\n+/// ```text\n+/// The origin is: Point {\n+///     x: 0,\n+///     y: 0\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is \\\n                             defined in your crate, add `#[derive(Debug)]` or \\\n@@ -379,6 +410,8 @@ pub trait Display {\n ///\n /// The `Octal` trait should format its output as a number in base-8.\n ///\n+/// The alternate flag, `#`, adds a `0o` in front of the output.\n+///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n /// [module]: ../index.html\n@@ -391,6 +424,7 @@ pub trait Display {\n /// let x = 42; // 42 is '52' in octal\n ///\n /// assert_eq!(format!(\"{:o}\", x), \"52\");\n+/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n /// ```\n ///\n /// Implementing `Octal` on a type:\n@@ -423,6 +457,8 @@ pub trait Octal {\n ///\n /// The `Binary` trait should format its output as a number in binary.\n ///\n+/// The alternate flag, `#`, adds a `0b` in front of the output.\n+///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n /// [module]: ../index.html\n@@ -435,6 +471,7 @@ pub trait Octal {\n /// let x = 42; // 42 is '101010' in binary\n ///\n /// assert_eq!(format!(\"{:b}\", x), \"101010\");\n+/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n /// ```\n ///\n /// Implementing `Binary` on a type:\n@@ -468,6 +505,8 @@ pub trait Binary {\n /// The `LowerHex` trait should format its output as a number in hexidecimal, with `a` through `f`\n /// in lower case.\n ///\n+/// The alternate flag, `#`, adds a `0x` in front of the output.\n+///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n /// [module]: ../index.html\n@@ -480,6 +519,7 @@ pub trait Binary {\n /// let x = 42; // 42 is '2a' in hex\n ///\n /// assert_eq!(format!(\"{:x}\", x), \"2a\");\n+/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n /// ```\n ///\n /// Implementing `LowerHex` on a type:\n@@ -513,6 +553,8 @@ pub trait LowerHex {\n /// The `UpperHex` trait should format its output as a number in hexidecimal, with `A` through `F`\n /// in upper case.\n ///\n+/// The alternate flag, `#`, adds a `0x` in front of the output.\n+///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n /// [module]: ../index.html\n@@ -525,6 +567,7 @@ pub trait LowerHex {\n /// let x = 42; // 42 is '2A' in hex\n ///\n /// assert_eq!(format!(\"{:X}\", x), \"2A\");\n+/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n /// ```\n ///\n /// Implementing `UpperHex` on a type:"}, {"sha": "797f9c368720d70d42ebc384f2c9774aa61b45c4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -1368,10 +1368,14 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n+/// # Unsafety\n+///\n /// This function is unsafe as there is no guarantee that the given pointer is\n /// valid for `len` elements, nor whether the lifetime inferred is a suitable\n /// lifetime for the returned slice.\n ///\n+/// `p` must be non-null, even for zero-length slices.\n+///\n /// # Caveat\n ///\n /// The lifetime for the returned slice is inferred from its usage. To"}, {"sha": "0ec3979ccfb30ab6a1d4a2af100aa79ad9b60ac7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -1844,11 +1844,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         visit::walk_ty_param_bounds_helper(this, bounds);\n \n                         for trait_item in trait_items {\n-                            // Create a new rib for the trait_item-specific type\n-                            // parameters.\n-                            //\n-                            // FIXME #4951: Do we need a node ID here?\n-\n                             match trait_item.node {\n                                 ast::ConstTraitItem(_, ref default) => {\n                                     // Only impose the restrictions of"}, {"sha": "d389a0be117bb53143028b744337bfd538e2fd55", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -21,7 +21,7 @@ use io::{self, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom};\n use ptr;\n use iter;\n \n-/// Wraps a `Read` and buffers input from it\n+/// Wraps a `Read` and buffers input from it.\n ///\n /// It can be excessively inefficient to work directly with a `Read` instance.\n /// For example, every call to `read` on `TcpStream` results in a system call.\n@@ -54,13 +54,13 @@ pub struct BufReader<R> {\n }\n \n impl<R: Read> BufReader<R> {\n-    /// Creates a new `BufReader` with a default buffer capacity\n+    /// Creates a new `BufReader` with a default buffer capacity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: R) -> BufReader<R> {\n         BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    /// Creates a new `BufReader` with the specified buffer capacity\n+    /// Creates a new `BufReader` with the specified buffer capacity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n         let mut buf = Vec::with_capacity(cap);\n@@ -183,7 +183,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     }\n }\n \n-/// Wraps a Writer and buffers output to it\n+/// Wraps a Writer and buffers output to it.\n ///\n /// It can be excessively inefficient to work directly with a `Write`. For\n /// example, every call to `write` on `TcpStream` results in a system call. A\n@@ -205,13 +205,13 @@ pub struct BufWriter<W: Write> {\n pub struct IntoInnerError<W>(W, Error);\n \n impl<W: Write> BufWriter<W> {\n-    /// Creates a new `BufWriter` with a default buffer capacity\n+    /// Creates a new `BufWriter` with a default buffer capacity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: W) -> BufWriter<W> {\n         BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    /// Creates a new `BufWriter` with the specified buffer capacity\n+    /// Creates a new `BufWriter` with the specified buffer capacity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n         BufWriter {\n@@ -253,11 +253,11 @@ impl<W: Write> BufWriter<W> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n \n-    /// Gets a mutable reference to the underlying write.\n+    /// Gets a mutable reference to the underlying writer.\n     ///\n     /// # Warning\n     ///\n-    /// It is inadvisable to directly read from the underlying writer.\n+    /// It is inadvisable to directly write to the underlying writer.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n "}, {"sha": "ef646c5bf5d68bb1b3fe9437dda0a58740deff50", "filename": "src/test/run-make/execution-engine/Makefile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/15952ac6cf39c593ae2b9c2cd161f2e221324e6a/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile?ref=15952ac6cf39c593ae2b9c2cd161f2e221324e6a", "patch": "@@ -1,8 +1,14 @@\n -include ../tools.mk\n \n+# FIXME: ignore freebsd\n # This is a basic test of LLVM ExecutionEngine functionality using compiled\n # Rust code built using the `rustc` crate.\n \n+ifneq ($(shell uname),FreeBSD)\n all:\n \t$(RUSTC) test.rs\n \t$(call RUN,test $(RUSTC))\n+else\n+all:\n+\n+endif"}]}