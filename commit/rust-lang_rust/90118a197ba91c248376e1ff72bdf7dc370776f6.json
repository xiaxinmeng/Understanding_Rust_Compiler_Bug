{"sha": "90118a197ba91c248376e1ff72bdf7dc370776f6", "node_id": "C_kwDOAAsO6NoAKDkwMTE4YTE5N2JhOTFjMjQ4Mzc2ZTFmZjcyYmRmN2RjMzcwNzc2ZjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-02T12:50:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-02T12:50:27Z"}, "message": "Auto merge of #2697 - Vanille-N:borrow-tracking, r=RalfJung\n\nReorganizing `stacked_borrows` in anticipation of a different model\n\nThese commits reorganize all the code inside the former `stacked_borrows` module and extract the part that really is specific to Stacked Borrows inside the `borrow_tracker/stacked_borrows` submodule.\nEverything not specific to SB is put in `borrow_tracker/mod.rs`.\nThis is so that the future Tree Borrows model can be later added as a second submodule and reuse all the contents of `borrow_tracker/mod.rs`.\n\nThis reorganization is accompanied by renamings, mostly from \"stacked borrows\" to \"borrow tracking\".", "tree": {"sha": "b6d131edd595f007e7fadc6154bc7297b03c995b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6d131edd595f007e7fadc6154bc7297b03c995b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90118a197ba91c248376e1ff72bdf7dc370776f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90118a197ba91c248376e1ff72bdf7dc370776f6", "html_url": "https://github.com/rust-lang/rust/commit/90118a197ba91c248376e1ff72bdf7dc370776f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90118a197ba91c248376e1ff72bdf7dc370776f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a12a13b588d54b6992bc74131aa4868357dd716", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a12a13b588d54b6992bc74131aa4868357dd716", "html_url": "https://github.com/rust-lang/rust/commit/4a12a13b588d54b6992bc74131aa4868357dd716"}, {"sha": "ab08f2a81301d535dfbaafe2d846ecfad1ed8688", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab08f2a81301d535dfbaafe2d846ecfad1ed8688", "html_url": "https://github.com/rust-lang/rust/commit/ab08f2a81301d535dfbaafe2d846ecfad1ed8688"}], "stats": {"total": 1042, "additions": 608, "deletions": 434}, "files": [{"sha": "9ac04c4930f266038447df0278a7aa50b12fc55c", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -317,7 +317,7 @@ fn main() {\n         } else if arg == \"-Zmiri-disable-validation\" {\n             miri_config.validate = false;\n         } else if arg == \"-Zmiri-disable-stacked-borrows\" {\n-            miri_config.stacked_borrows = false;\n+            miri_config.borrow_tracker = None;\n         } else if arg == \"-Zmiri-disable-data-race-detector\" {\n             miri_config.data_race_detector = false;\n             miri_config.weak_memory_emulation = false;\n@@ -413,7 +413,7 @@ fn main() {\n                         err\n                     ),\n             };\n-            for id in ids.into_iter().map(miri::SbTag::new) {\n+            for id in ids.into_iter().map(miri::BorTag::new) {\n                 if let Some(id) = id {\n                     miri_config.tracked_pointer_tags.insert(id);\n                 } else {"}, {"sha": "69f9bd09f26de42610c5329530940ceba48d9e9f", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -0,0 +1,365 @@\n+use std::cell::RefCell;\n+use std::fmt;\n+use std::num::NonZeroU64;\n+\n+use log::trace;\n+use smallvec::SmallVec;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_middle::mir::RetagKind;\n+use rustc_target::abi::Size;\n+\n+use crate::*;\n+pub mod stacked_borrows;\n+use stacked_borrows::diagnostics::RetagCause;\n+\n+pub type CallId = NonZeroU64;\n+\n+/// Tracking pointer provenance\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct BorTag(NonZeroU64);\n+\n+impl BorTag {\n+    pub fn new(i: u64) -> Option<Self> {\n+        NonZeroU64::new(i).map(BorTag)\n+    }\n+\n+    pub fn get(&self) -> u64 {\n+        self.0.get()\n+    }\n+\n+    pub fn inner(&self) -> NonZeroU64 {\n+        self.0\n+    }\n+\n+    pub fn succ(self) -> Option<Self> {\n+        self.0.checked_add(1).map(Self)\n+    }\n+\n+    /// The minimum representable tag\n+    pub fn one() -> Self {\n+        Self::new(1).unwrap()\n+    }\n+}\n+\n+impl std::default::Default for BorTag {\n+    /// The default to be used when borrow tracking is disabled\n+    fn default() -> Self {\n+        Self::one()\n+    }\n+}\n+\n+impl fmt::Debug for BorTag {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"<{}>\", self.0)\n+    }\n+}\n+\n+/// Per-frame data for borrow tracking\n+#[derive(Debug)]\n+pub struct FrameExtra {\n+    /// The ID of the call this frame corresponds to.\n+    pub call_id: CallId,\n+\n+    /// If this frame is protecting any tags, they are listed here. We use this list to do\n+    /// incremental updates of the global list of protected tags stored in the\n+    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n+    /// tag, to identify which call is responsible for protecting the tag.\n+    /// See `Stack::item_popped` for more explanation.\n+    ///\n+    /// This will contain one tag per reference passed to the function, so\n+    /// a size of 2 is enough for the vast majority of functions.\n+    pub protected_tags: SmallVec<[BorTag; 2]>,\n+}\n+\n+impl VisitTags for FrameExtra {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n+        // `protected_tags` are fine to GC.\n+    }\n+}\n+\n+/// Extra global state, available to the memory access hooks.\n+#[derive(Debug)]\n+pub struct GlobalStateInner {\n+    /// Borrow tracker method currently in use.\n+    pub borrow_tracker_method: BorrowTrackerMethod,\n+    /// Next unused pointer ID (tag).\n+    pub next_ptr_tag: BorTag,\n+    /// Table storing the \"base\" tag for each allocation.\n+    /// The base tag is the one used for the initial pointer.\n+    /// We need this in a separate table to handle cyclic statics.\n+    pub base_ptr_tags: FxHashMap<AllocId, BorTag>,\n+    /// Next unused call ID (for protectors).\n+    pub next_call_id: CallId,\n+    /// All currently protected tags.\n+    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n+    /// We add tags to this when they are created with a protector in `reborrow`, and\n+    /// we remove tags from this when the call which is protecting them returns, in\n+    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n+    pub protected_tags: FxHashMap<BorTag, ProtectorKind>,\n+    /// The pointer ids to trace\n+    pub tracked_pointer_tags: FxHashSet<BorTag>,\n+    /// The call ids to trace\n+    pub tracked_call_ids: FxHashSet<CallId>,\n+    /// Whether to recurse into datatypes when searching for pointers to retag.\n+    pub retag_fields: RetagFields,\n+}\n+\n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n+        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n+        // GC the bottommost tag.\n+    }\n+}\n+\n+/// We need interior mutable access to the global state.\n+pub type GlobalState = RefCell<GlobalStateInner>;\n+\n+/// Indicates which kind of access is being performed.\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+}\n+\n+impl fmt::Display for AccessKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AccessKind::Read => write!(f, \"read access\"),\n+            AccessKind::Write => write!(f, \"write access\"),\n+        }\n+    }\n+}\n+\n+/// Policy on whether to recurse into fields to retag\n+#[derive(Copy, Clone, Debug)]\n+pub enum RetagFields {\n+    /// Don't retag any fields.\n+    No,\n+    /// Retag all fields.\n+    Yes,\n+    /// Only retag fields of types with Scalar and ScalarPair layout,\n+    /// to match the LLVM `noalias` we generate.\n+    OnlyScalar,\n+}\n+\n+/// The flavor of the protector.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ProtectorKind {\n+    /// Protected against aliasing violations from other pointers.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n+    /// still be used to issue a deallocation.\n+    ///\n+    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n+    WeakProtector,\n+\n+    /// Protected against any kind of invalidation.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n+    /// This is strictly stronger protection than `WeakProtector`.\n+    ///\n+    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n+    StrongProtector,\n+}\n+\n+/// Utilities for initialization and ID generation\n+impl GlobalStateInner {\n+    pub fn new(\n+        borrow_tracker_method: BorrowTrackerMethod,\n+        tracked_pointer_tags: FxHashSet<BorTag>,\n+        tracked_call_ids: FxHashSet<CallId>,\n+        retag_fields: RetagFields,\n+    ) -> Self {\n+        GlobalStateInner {\n+            borrow_tracker_method,\n+            next_ptr_tag: BorTag::one(),\n+            base_ptr_tags: FxHashMap::default(),\n+            next_call_id: NonZeroU64::new(1).unwrap(),\n+            protected_tags: FxHashMap::default(),\n+            tracked_pointer_tags,\n+            tracked_call_ids,\n+            retag_fields,\n+        }\n+    }\n+\n+    /// Generates a new pointer tag. Remember to also check track_pointer_tags and log its creation!\n+    pub fn new_ptr(&mut self) -> BorTag {\n+        let id = self.next_ptr_tag;\n+        self.next_ptr_tag = id.succ().unwrap();\n+        id\n+    }\n+\n+    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameExtra {\n+        let call_id = self.next_call_id;\n+        trace!(\"new_frame: Assigning call ID {}\", call_id);\n+        if self.tracked_call_ids.contains(&call_id) {\n+            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n+        }\n+        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n+        FrameExtra { call_id, protected_tags: SmallVec::new() }\n+    }\n+\n+    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n+        for tag in &frame\n+            .borrow_tracker\n+            .as_ref()\n+            .expect(\"we should have borrow tracking data\")\n+            .protected_tags\n+        {\n+            self.protected_tags.remove(tag);\n+        }\n+    }\n+\n+    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &MiriMachine<'_, '_>) -> BorTag {\n+        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n+            let tag = self.new_ptr();\n+            if self.tracked_pointer_tags.contains(&tag) {\n+                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                    tag.inner(),\n+                    None,\n+                    None,\n+                ));\n+            }\n+            trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n+            self.base_ptr_tags.try_insert(id, tag).unwrap();\n+            tag\n+        })\n+    }\n+}\n+\n+/// Which borrow tracking method to use\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum BorrowTrackerMethod {\n+    /// Stacked Borrows, as implemented in borrow_tracker/stacked\n+    StackedBorrows,\n+}\n+\n+impl BorrowTrackerMethod {\n+    pub fn instanciate_global_state(self, config: &MiriConfig) -> GlobalState {\n+        RefCell::new(GlobalStateInner::new(\n+            self,\n+            config.tracked_pointer_tags.clone(),\n+            config.tracked_call_ids.clone(),\n+            config.retag_fields,\n+        ))\n+    }\n+}\n+\n+impl GlobalStateInner {\n+    pub fn new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        alloc_size: Size,\n+        kind: MemoryKind<machine::MiriMemoryKind>,\n+        machine: &MiriMachine<'_, '_>,\n+    ) -> AllocExtra {\n+        match self.borrow_tracker_method {\n+            BorrowTrackerMethod::StackedBorrows =>\n+                AllocExtra::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n+                    id, alloc_size, self, kind, machine,\n+                )))),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag(kind, place),\n+        }\n+    }\n+\n+    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_return_place(),\n+        }\n+    }\n+\n+    fn expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_expose_tag(alloc_id, tag),\n+        }\n+    }\n+}\n+\n+/// Extra per-allocation data for borrow tracking\n+#[derive(Debug, Clone)]\n+pub enum AllocExtra {\n+    /// Data corresponding to Stacked Borrows\n+    StackedBorrows(Box<RefCell<stacked_borrows::AllocExtra>>),\n+}\n+\n+impl AllocExtra {\n+    pub fn assert_sb(&self) -> &RefCell<stacked_borrows::AllocExtra> {\n+        match self {\n+            AllocExtra::StackedBorrows(ref sb) => sb,\n+        }\n+    }\n+\n+    pub fn assert_sb_mut(&mut self) -> &mut RefCell<stacked_borrows::AllocExtra> {\n+        match self {\n+            AllocExtra::StackedBorrows(ref mut sb) => sb,\n+        }\n+    }\n+\n+    pub fn before_memory_read<'tcx>(\n+        &self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) =>\n+                sb.borrow_mut().before_memory_read(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn before_memory_write<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) =>\n+                sb.get_mut().before_memory_write(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn before_memory_deallocation<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) =>\n+                sb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn remove_unreachable_tags(&self, tags: &FxHashSet<BorTag>) {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n+        }\n+    }\n+}\n+\n+impl VisitTags for AllocExtra {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) => sb.visit_tags(visit),\n+        }\n+    }\n+}"}, {"sha": "c5eb2113f9f8eb9c28ee8851edd692abedd81a12", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "renamed", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -1,17 +1,16 @@\n use smallvec::SmallVec;\n use std::fmt;\n \n-use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n+use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange, InterpError};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use crate::stacked_borrows::{\n-    err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind, Stack,\n+use crate::borrow_tracker::{\n+    stacked_borrows::{err_sb_ub, Permission},\n+    AccessKind, GlobalStateInner, ProtectorKind,\n };\n use crate::*;\n \n-use rustc_middle::mir::interpret::InterpError;\n-\n #[derive(Clone, Debug)]\n pub struct AllocHistory {\n     id: AllocId,\n@@ -53,7 +52,7 @@ impl Creation {\n \n #[derive(Clone, Debug)]\n struct Invalidation {\n-    tag: SbTag,\n+    tag: BorTag,\n     range: AllocRange,\n     span: Span,\n     cause: InvalidationCause,\n@@ -100,7 +99,7 @@ impl fmt::Display for InvalidationCause {\n \n #[derive(Clone, Debug)]\n struct Protection {\n-    tag: SbTag,\n+    tag: BorTag,\n     span: Span,\n }\n \n@@ -135,7 +134,7 @@ impl<'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     pub fn retag(\n         machine: &'ecx MiriMachine<'mir, 'tcx>,\n         cause: RetagCause,\n-        new_tag: SbTag,\n+        new_tag: BorTag,\n         orig_tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n@@ -185,7 +184,7 @@ enum Operation {\n #[derive(Debug, Clone)]\n struct RetagOp {\n     cause: RetagCause,\n-    new_tag: SbTag,\n+    new_tag: BorTag,\n     orig_tag: ProvenanceExtra,\n     range: AllocRange,\n     permission: Option<Permission>,\n@@ -257,7 +256,7 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             .push(Creation { retag: op.clone(), span: self.machine.current_span() });\n     }\n \n-    pub fn log_invalidation(&mut self, tag: SbTag) {\n+    pub fn log_invalidation(&mut self, tag: BorTag) {\n         let mut span = self.machine.current_span();\n         let (range, cause) = match &self.operation {\n             Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n@@ -288,8 +287,8 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n \n     pub fn get_logs_relevant_to(\n         &self,\n-        tag: SbTag,\n-        protector_tag: Option<SbTag>,\n+        tag: BorTag,\n+        protector_tag: Option<BorTag>,\n     ) -> Option<TagHistory> {\n         let Some(created) = self.history\n             .creations\n@@ -410,7 +409,7 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             .all_stacks()\n             .flatten()\n             .map(|frame| {\n-                frame.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\")\n+                frame.extra.borrow_tracker.as_ref().expect(\"we should have borrow tracking data\")\n             })\n             .find(|frame| frame.protected_tags.contains(&item.tag()))\n             .map(|frame| frame.call_id)", "previous_filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs"}, {"sha": "b9a52e4966cd7230914e084d568b77e782a2195f", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/item.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fitem.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -1,13 +1,13 @@\n-use crate::stacked_borrows::SbTag;\n use std::fmt;\n-use std::num::NonZeroU64;\n+\n+use crate::borrow_tracker::BorTag;\n \n /// An item in the per-location borrow stack.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Item(u64);\n \n // An Item contains 3 bitfields:\n-// * Bits 0-61 store an SbTag\n+// * Bits 0-61 store a BorTag\n // * Bits 61-63 store a Permission\n // * Bit 64 stores a flag which indicates if we have a protector\n const TAG_MASK: u64 = u64::MAX >> 3;\n@@ -18,9 +18,9 @@ const PERM_SHIFT: u64 = 61;\n const PROTECTED_SHIFT: u64 = 63;\n \n impl Item {\n-    pub fn new(tag: SbTag, perm: Permission, protected: bool) -> Self {\n-        assert!(tag.0.get() <= TAG_MASK);\n-        let packed_tag = tag.0.get();\n+    pub fn new(tag: BorTag, perm: Permission, protected: bool) -> Self {\n+        assert!(tag.get() <= TAG_MASK);\n+        let packed_tag = tag.get();\n         let packed_perm = perm.to_bits() << PERM_SHIFT;\n         let packed_protected = u64::from(protected) << PROTECTED_SHIFT;\n \n@@ -34,8 +34,8 @@ impl Item {\n     }\n \n     /// The pointers the permission is granted to.\n-    pub fn tag(self) -> SbTag {\n-        SbTag(NonZeroU64::new(self.0 & TAG_MASK).unwrap())\n+    pub fn tag(self) -> BorTag {\n+        BorTag::new(self.0 & TAG_MASK).unwrap()\n     }\n \n     /// The permission this item grants.", "previous_filename": "src/tools/miri/src/stacked_borrows/item.rs"}, {"sha": "ec3be398a2c29d896ac1a92ac49ee236c025fd2c", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "renamed", "additions": 83, "deletions": 260, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -2,81 +2,30 @@\n //! for further information.\n \n use log::trace;\n-use std::cell::RefCell;\n use std::cmp;\n-use std::fmt;\n-use std::fmt::Write;\n-use std::num::NonZeroU64;\n+use std::fmt::{self, Write};\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::Mutability;\n-use rustc_middle::mir::RetagKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::mir::{Mutability, RetagKind};\n use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n };\n-use rustc_target::abi::Abi;\n-use rustc_target::abi::Size;\n-use smallvec::SmallVec;\n+use rustc_target::abi::{Abi, Size};\n \n+use crate::borrow_tracker::{\n+    stacked_borrows::diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, TagHistory},\n+    AccessKind, GlobalStateInner, ProtectorKind, RetagCause, RetagFields,\n+};\n use crate::*;\n \n-pub mod diagnostics;\n-use diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, RetagCause, TagHistory};\n-\n mod item;\n pub use item::{Item, Permission};\n mod stack;\n pub use stack::Stack;\n+pub mod diagnostics;\n \n-pub type CallId = NonZeroU64;\n-\n-// Even reading memory can have effects on the stack, so we need a `RefCell` here.\n-pub type AllocExtra = RefCell<Stacks>;\n-\n-/// Tracking pointer provenance\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct SbTag(NonZeroU64);\n-\n-impl SbTag {\n-    pub fn new(i: u64) -> Option<Self> {\n-        NonZeroU64::new(i).map(SbTag)\n-    }\n-\n-    // The default to be used when SB is disabled\n-    #[allow(clippy::should_implement_trait)]\n-    pub fn default() -> Self {\n-        Self::new(1).unwrap()\n-    }\n-}\n-\n-impl fmt::Debug for SbTag {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<{}>\", self.0)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct FrameExtra {\n-    /// The ID of the call this frame corresponds to.\n-    call_id: CallId,\n-\n-    /// If this frame is protecting any tags, they are listed here. We use this list to do\n-    /// incremental updates of the global list of protected tags stored in the\n-    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n-    /// tag, to identify which call is responsible for protecting the tag.\n-    /// See `Stack::item_invalidated` for more explanation.\n-    ///\n-    /// This will contain one tag per reference passed to the function, so\n-    /// a size of 2 is enough for the vast majority of functions.\n-    protected_tags: SmallVec<[SbTag; 2]>,\n-}\n-\n-impl VisitTags for FrameExtra {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n-        // `protected_tags` are fine to GC.\n-    }\n-}\n+pub type AllocExtra = Stacks;\n \n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n@@ -86,98 +35,16 @@ pub struct Stacks {\n     /// Stores past operations on this allocation\n     history: AllocHistory,\n     /// The set of tags that have been exposed inside this allocation.\n-    exposed_tags: FxHashSet<SbTag>,\n+    exposed_tags: FxHashSet<BorTag>,\n     /// Whether this memory has been modified since the last time the tag GC ran\n     modified_since_last_gc: bool,\n }\n \n-/// The flavor of the protector.\n-#[derive(Copy, Clone, Debug)]\n-enum ProtectorKind {\n-    /// Protected against aliasing violations from other pointers.\n-    ///\n-    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n-    /// still be used to issue a deallocation.\n-    ///\n-    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n-    WeakProtector,\n-\n-    /// Protected against any kind of invalidation.\n-    ///\n-    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n-    /// This is strictly stronger protection than `WeakProtector`.\n-    ///\n-    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n-    StrongProtector,\n-}\n-\n-/// Extra global state, available to the memory access hooks.\n-#[derive(Debug)]\n-pub struct GlobalStateInner {\n-    /// Next unused pointer ID (tag).\n-    next_ptr_tag: SbTag,\n-    /// Table storing the \"base\" tag for each allocation.\n-    /// The base tag is the one used for the initial pointer.\n-    /// We need this in a separate table to handle cyclic statics.\n-    base_ptr_tags: FxHashMap<AllocId, SbTag>,\n-    /// Next unused call ID (for protectors).\n-    next_call_id: CallId,\n-    /// All currently protected tags, and the status of their protection.\n-    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n-    /// We add tags to this when they are created with a protector in `reborrow`, and\n-    /// we remove tags from this when the call which is protecting them returns, in\n-    /// `GlobalStateInner::end_call`. See `Stack::item_invalidated` for more details.\n-    protected_tags: FxHashMap<SbTag, ProtectorKind>,\n-    /// The pointer ids to trace\n-    tracked_pointer_tags: FxHashSet<SbTag>,\n-    /// The call ids to trace\n-    tracked_call_ids: FxHashSet<CallId>,\n-    /// Whether to recurse into datatypes when searching for pointers to retag.\n-    retag_fields: RetagFields,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum RetagFields {\n-    /// Don't retag any fields.\n-    No,\n-    /// Retag all fields.\n-    Yes,\n-    /// Only retag fields of types with Scalar and ScalarPair layout,\n-    /// to match the LLVM `noalias` we generate.\n-    OnlyScalar,\n-}\n-\n-impl VisitTags for GlobalStateInner {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n-        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n-        // GC the bottommost tag.\n-    }\n-}\n-\n-/// We need interior mutable access to the global state.\n-pub type GlobalState = RefCell<GlobalStateInner>;\n-\n-/// Indicates which kind of access is being performed.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n-pub enum AccessKind {\n-    Read,\n-    Write,\n-}\n-\n-impl fmt::Display for AccessKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            AccessKind::Read => write!(f, \"read access\"),\n-            AccessKind::Write => write!(f, \"write access\"),\n-        }\n-    }\n-}\n-\n /// Indicates which kind of reference is being created.\n /// Used by high-level `reborrow` to compute which permissions to grant to the\n /// new pointer.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub enum RefKind {\n+enum RefKind {\n     /// `&mut` and `Box`.\n     Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n@@ -198,65 +65,6 @@ impl fmt::Display for RefKind {\n     }\n }\n \n-/// Utilities for initialization and ID generation\n-impl GlobalStateInner {\n-    pub fn new(\n-        tracked_pointer_tags: FxHashSet<SbTag>,\n-        tracked_call_ids: FxHashSet<CallId>,\n-        retag_fields: RetagFields,\n-    ) -> Self {\n-        GlobalStateInner {\n-            next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n-            base_ptr_tags: FxHashMap::default(),\n-            next_call_id: NonZeroU64::new(1).unwrap(),\n-            protected_tags: FxHashMap::default(),\n-            tracked_pointer_tags,\n-            tracked_call_ids,\n-            retag_fields,\n-        }\n-    }\n-\n-    /// Generates a new pointer tag. Remember to also check track_pointer_tags and log its creation!\n-    fn new_ptr(&mut self) -> SbTag {\n-        let id = self.next_ptr_tag;\n-        self.next_ptr_tag = SbTag(NonZeroU64::new(id.0.get() + 1).unwrap());\n-        id\n-    }\n-\n-    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameExtra {\n-        let call_id = self.next_call_id;\n-        trace!(\"new_frame: Assigning call ID {}\", call_id);\n-        if self.tracked_call_ids.contains(&call_id) {\n-            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n-        }\n-        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n-        FrameExtra { call_id, protected_tags: SmallVec::new() }\n-    }\n-\n-    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n-        for tag in &frame\n-            .stacked_borrows\n-            .as_ref()\n-            .expect(\"we should have Stacked Borrows data\")\n-            .protected_tags\n-        {\n-            self.protected_tags.remove(tag);\n-        }\n-    }\n-\n-    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &MiriMachine<'_, '_>) -> SbTag {\n-        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n-            let tag = self.new_ptr();\n-            if self.tracked_pointer_tags.contains(&tag) {\n-                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None, None));\n-            }\n-            trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n-            self.base_ptr_tags.try_insert(id, tag).unwrap();\n-            tag\n-        })\n-    }\n-}\n-\n /// Error reporting\n pub fn err_sb_ub<'tcx>(\n     msg: String,\n@@ -329,14 +137,7 @@ impl<'tcx> Stack {\n         }\n     }\n \n-    /// Check if the given item is protected.\n-    ///\n-    /// The `provoking_access` argument is only used to produce diagnostics.\n-    /// It is `Some` when we are granting the contained access for said tag, and it is\n-    /// `None` during a deallocation.\n-    /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n-    /// the `Size` refers to the specific location in the `AllocRange` that we are\n-    /// currently checking.\n+    /// The given item was invalidated -- check its protectors for whether that will cause UB.\n     fn item_invalidated(\n         item: &Item,\n         global: &GlobalStateInner,\n@@ -386,7 +187,7 @@ impl<'tcx> Stack {\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n@@ -442,23 +243,24 @@ impl<'tcx> Stack {\n         if granting_idx.is_none() || matches!(tag, ProvenanceExtra::Wildcard) {\n             // Compute the upper bound of the items that remain.\n             // (This is why we did all the work above: to reduce the items we have to consider here.)\n-            let mut max = NonZeroU64::new(1).unwrap();\n+            let mut max = BorTag::one();\n             for i in 0..self.len() {\n                 let item = self.get(i).unwrap();\n                 // Skip disabled items, they cannot be matched anyway.\n                 if !matches!(item.perm(), Permission::Disabled) {\n                     // We are looking for a strict upper bound, so add 1 to this tag.\n-                    max = cmp::max(item.tag().0.checked_add(1).unwrap(), max);\n+                    max = cmp::max(item.tag().succ().unwrap(), max);\n                 }\n             }\n             if let Some(unk) = self.unknown_bottom() {\n-                max = cmp::max(unk.0, max);\n+                max = cmp::max(unk, max);\n             }\n             // Use `max` as new strict upper bound for everything.\n             trace!(\n-                \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\"\n+                \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\",\n+                max = max.get(),\n             );\n-            self.set_unknown_bottom(SbTag(max));\n+            self.set_unknown_bottom(max);\n         }\n \n         // Done.\n@@ -472,7 +274,7 @@ impl<'tcx> Stack {\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make a write access.\n         // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n@@ -497,7 +299,7 @@ impl<'tcx> Stack {\n         access: Option<AccessKind>,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n \n@@ -550,9 +352,9 @@ impl<'tcx> Stack {\n }\n // # Stacked Borrows Core End\n \n-/// Integration with the SbTag garbage collector\n+/// Integration with the BorTag garbage collector\n impl Stacks {\n-    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<SbTag>) {\n+    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<BorTag>) {\n         if self.modified_since_last_gc {\n             for stack in self.stacks.iter_mut_all() {\n                 if stack.len() > 64 {\n@@ -565,7 +367,7 @@ impl Stacks {\n }\n \n impl VisitTags for Stacks {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for tag in self.exposed_tags.iter().copied() {\n             visit(tag);\n         }\n@@ -579,7 +381,7 @@ impl<'tcx> Stacks {\n     fn new(\n         size: Size,\n         perm: Permission,\n-        tag: SbTag,\n+        tag: BorTag,\n         id: AllocId,\n         machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n@@ -602,7 +404,7 @@ impl<'tcx> Stacks {\n         mut f: impl FnMut(\n             &mut Stack,\n             &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-            &mut FxHashSet<SbTag>,\n+            &mut FxHashSet<BorTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         self.modified_since_last_gc = true;\n@@ -620,20 +422,19 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        state: &GlobalState,\n+        state: &mut GlobalStateInner,\n         kind: MemoryKind<MiriMemoryKind>,\n         machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n-        let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n             // New unique borrow. This tag is not accessible by the program,\n             // so it will only ever be used when using the local directly (i.e.,\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_ptr_tag(id, machine), Permission::Unique),\n+            MemoryKind::Stack => (state.base_ptr_tag(id, machine), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n+            _ => (state.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n         };\n         Stacks::new(size, perm, base_tag, id, machine)\n     }\n@@ -656,7 +457,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n-        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let state = machine.borrow_tracker.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n         })\n@@ -677,7 +478,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n-        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let state = machine.borrow_tracker.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n         })\n@@ -693,12 +494,16 @@ impl Stacks {\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n-        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let state = machine.borrow_tracker.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;\n         Ok(())\n     }\n+\n+    fn expose_tag(&mut self, tag: BorTag) {\n+        self.exposed_tags.insert(tag);\n+    }\n }\n \n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n@@ -710,13 +515,13 @@ impl<'mir: 'ecx, 'tcx: 'mir, 'ecx> EvalContextPrivExt<'mir, 'tcx, 'ecx>\n trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Returns the `AllocId` the reborrow was done in, if some actual borrow stack manipulation\n     /// happened.\n-    fn reborrow(\n+    fn sb_reborrow(\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        new_tag: SbTag,\n+        new_tag: BorTag,\n         protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n@@ -725,7 +530,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let log_creation = |this: &MiriInterpCx<'mir, 'tcx>,\n                             loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n          -> InterpResult<'tcx> {\n-            let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n+            let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n             let ty = place.layout.ty;\n             if global.tracked_pointer_tags.contains(&new_tag) {\n                 let mut kind_str = format!(\"{kind}\");\n@@ -743,7 +548,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     _ => write!(kind_str, \" (pointee type {ty})\").unwrap(),\n                 };\n                 this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n-                    new_tag.0,\n+                    new_tag.inner(),\n                     Some(kind_str),\n                     loc.map(|(alloc_id, base_offset, orig_tag)| (alloc_id, alloc_range(base_offset, size), orig_tag)),\n                 ));\n@@ -762,9 +567,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // uncovers a non-supported `extern static`.\n                     let extra = this.get_alloc_extra(alloc_id)?;\n                     let mut stacked_borrows = extra\n-                        .stacked_borrows\n+                        .borrow_tracker\n                         .as_ref()\n-                        .expect(\"we should have Stacked Borrows data\")\n+                        .expect(\"We should have borrow tracking data\")\n+                        .assert_sb()\n                         .borrow_mut();\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n@@ -780,7 +586,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     if protect.is_some() {\n                         dcx.log_protector();\n                     }\n-                }\n+                },\n                 AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n                     // No stacked borrows on these allocations.\n                 }\n@@ -839,9 +645,9 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n         if let Some(protect) = protect {\n             // See comment in `Stack::item_invalidated` for why we store the tag twice.\n-            this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n+            this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine\n-                .stacked_borrows\n+                .borrow_tracker\n                 .as_mut()\n                 .unwrap()\n                 .get_mut()\n@@ -876,9 +682,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 // `visit_freeze_sensitive` needs to access the global state.\n                 let alloc_extra = this.get_alloc_extra(alloc_id)?;\n                 let mut stacked_borrows = alloc_extra\n-                    .stacked_borrows\n+                    .borrow_tracker\n                     .as_ref()\n-                    .expect(\"we should have Stacked Borrows data\")\n+                    .expect(\"We should have borrow tracking data\")\n+                    .assert_sb()\n                     .borrow_mut();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n@@ -900,7 +707,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         false\n                     };\n                     let item = Item::new(new_tag, perm, protected);\n-                    let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n+                    let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n                         &this.machine,\n                         retag_cause,\n@@ -930,13 +737,14 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n         let stacked_borrows = alloc_extra\n-            .stacked_borrows\n+            .borrow_tracker\n             .as_mut()\n-            .expect(\"we should have Stacked Borrows data\")\n+            .expect(\"We should have borrow tracking data\")\n+            .assert_sb_mut()\n             .get_mut();\n         let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n-        let global = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n         let dcx = DiagnosticCxBuilder::retag(\n             machine,\n             retag_cause,\n@@ -960,8 +768,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n-    /// `mutbl` can be `None` to make this a raw pointer.\n-    fn retag_reference(\n+    /// `kind` indicates what kind of reference is being created.\n+    fn sb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n@@ -981,10 +789,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         };\n \n         // Compute new borrow.\n-        let new_tag = this.machine.stacked_borrows.as_mut().unwrap().get_mut().new_ptr();\n+        let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n-        let alloc_id = this.reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n+        let alloc_id = this.sb_reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n@@ -993,7 +801,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     Some(alloc_id) => {\n                         // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n                         // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n-                        Provenance::Concrete { alloc_id, sb: new_tag }\n+                        Provenance::Concrete { alloc_id, tag: new_tag }\n                     }\n                     None => {\n                         // Looks like this has to stay a wildcard pointer.\n@@ -1011,9 +819,13 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+    fn sb_retag(\n+        &mut self,\n+        kind: RetagKind,\n+        place: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n+        let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n         let retag_cause = match kind {\n             RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n             RetagKind::FnEntry => RetagCause::FnEntry,\n@@ -1039,7 +851,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.retag_reference(&val, ref_kind, retag_cause, protector)?;\n+                let val = self.ecx.sb_retag_reference(&val, ref_kind, retag_cause, protector)?;\n                 self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n@@ -1138,7 +950,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ///\n     /// This is a HACK because there is nothing in MIR that would make the retag\n     /// explicit. Also see <https://github.com/rust-lang/rust/issues/71117>.\n-    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+    fn sb_retag_return_place(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let return_place = &this.frame().return_place;\n         if return_place.layout.is_zst() {\n@@ -1153,7 +965,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n         // Reborrow it. With protection! That is part of the point.\n-        let val = this.retag_reference(\n+        let val = this.sb_retag_reference(\n             &val,\n             RefKind::Unique { two_phase: false },\n             RetagCause::FnReturn,\n@@ -1167,7 +979,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark the given tag as exposed. It was found on a pointer with the given AllocId.\n-    fn expose_tag(&mut self, alloc_id: AllocId, tag: SbTag) -> InterpResult<'tcx> {\n+    fn sb_expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n@@ -1181,7 +993,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // uncovers a non-supported `extern static`.\n                 let alloc_extra = this.get_alloc_extra(alloc_id)?;\n                 trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id:?}\");\n-                alloc_extra.stacked_borrows.as_ref().unwrap().borrow_mut().exposed_tags.insert(tag);\n+                alloc_extra\n+                    .borrow_tracker\n+                    .as_ref()\n+                    .expect(\"We should have borrow tracking data\")\n+                    .assert_sb()\n+                    .borrow_mut()\n+                    .expose_tag(tag);\n             }\n             AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n                 // No stacked borrows on these allocations.\n@@ -1193,7 +1011,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn print_stacks(&mut self, alloc_id: AllocId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let alloc_extra = this.get_alloc_extra(alloc_id)?;\n-        let stacks = alloc_extra.stacked_borrows.as_ref().unwrap().borrow();\n+        let stacks = alloc_extra\n+            .borrow_tracker\n+            .as_ref()\n+            .expect(\"We should have borrow tracking data\")\n+            .assert_sb()\n+            .borrow();\n         for (range, stack) in stacks.stacks.iter_all() {\n             print!(\"{range:?}: [\");\n             if let Some(bottom) = stack.unknown_bottom() {", "previous_filename": "src/tools/miri/src/stacked_borrows/mod.rs"}, {"sha": "1d5cfec3500aeeef7d05339592a8f37c0745e4df", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/stack.rs", "status": "renamed", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -3,11 +3,14 @@ use std::ops::Range;\n \n use rustc_data_structures::fx::FxHashSet;\n \n-use crate::stacked_borrows::{AccessKind, Item, Permission, SbTag};\n+use crate::borrow_tracker::{\n+    stacked_borrows::{Item, Permission},\n+    AccessKind, BorTag,\n+};\n use crate::ProvenanceExtra;\n \n /// Exactly what cache size we should use is a difficult tradeoff. There will always be some\n-/// workload which has a `SbTag` working set which exceeds the size of the cache, and ends up\n+/// workload which has a `BorTag` working set which exceeds the size of the cache, and ends up\n /// falling back to linear searches of the borrow stack very often.\n /// The cost of making this value too large is that the loop in `Stack::insert` which ensures the\n /// entries in the cache stay correct after an insert becomes expensive.\n@@ -28,7 +31,7 @@ pub struct Stack {\n     /// than `id`.\n     /// When the bottom is unknown, `borrows` always has a `SharedReadOnly` or `Unique` at the bottom;\n     /// we never have the unknown-to-known boundary in an SRW group.\n-    unknown_bottom: Option<SbTag>,\n+    unknown_bottom: Option<BorTag>,\n \n     /// A small LRU cache of searches of the borrow stack.\n     #[cfg(feature = \"stack-cache\")]\n@@ -40,7 +43,7 @@ pub struct Stack {\n }\n \n impl Stack {\n-    pub fn retain(&mut self, tags: &FxHashSet<SbTag>) {\n+    pub fn retain(&mut self, tags: &FxHashSet<BorTag>) {\n         let mut first_removed = None;\n \n         // We never consider removing the bottom-most tag. For stacks without an unknown\n@@ -185,7 +188,7 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: ProvenanceExtra,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> Result<Option<usize>, ()> {\n         #[cfg(all(feature = \"stack-cache\", debug_assertions))]\n         self.verify_cache_consistency();\n@@ -219,12 +222,12 @@ impl<'tcx> Stack {\n \n         // Couldn't find it in the stack; but if there is an unknown bottom it might be there.\n         let found = self.unknown_bottom.is_some_and(|unknown_limit| {\n-            tag.0 < unknown_limit.0 // unknown_limit is an upper bound for what can be in the unknown bottom.\n+            tag < unknown_limit // unknown_limit is an upper bound for what can be in the unknown bottom.\n         });\n         if found { Ok(None) } else { Err(()) }\n     }\n \n-    fn find_granting_tagged(&mut self, access: AccessKind, tag: SbTag) -> Option<usize> {\n+    fn find_granting_tagged(&mut self, access: AccessKind, tag: BorTag) -> Option<usize> {\n         #[cfg(feature = \"stack-cache\")]\n         if let Some(idx) = self.find_granting_cache(access, tag) {\n             return Some(idx);\n@@ -243,7 +246,7 @@ impl<'tcx> Stack {\n     }\n \n     #[cfg(feature = \"stack-cache\")]\n-    fn find_granting_cache(&mut self, access: AccessKind, tag: SbTag) -> Option<usize> {\n+    fn find_granting_cache(&mut self, access: AccessKind, tag: BorTag) -> Option<usize> {\n         // This looks like a common-sense optimization; we're going to do a linear search of the\n         // cache or the borrow stack to scan the shorter of the two. This optimization is miniscule\n         // and this check actually ensures we do not access an invalid cache.\n@@ -349,11 +352,11 @@ impl<'tcx> Stack {\n         self.borrows.len()\n     }\n \n-    pub fn unknown_bottom(&self) -> Option<SbTag> {\n+    pub fn unknown_bottom(&self) -> Option<BorTag> {\n         self.unknown_bottom\n     }\n \n-    pub fn set_unknown_bottom(&mut self, tag: SbTag) {\n+    pub fn set_unknown_bottom(&mut self, tag: BorTag) {\n         // We clear the borrow stack but the lookup cache doesn't support clearing per se. Instead,\n         // there is a check explained in `find_granting_cache` which protects against accessing the\n         // cache when it has been cleared and not yet refilled.", "previous_filename": "src/tools/miri/src/stacked_borrows/stack.rs"}, {"sha": "99288480386e1ede3268f16042c7c9b8ebff640d", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -670,7 +670,7 @@ pub struct VClockAlloc {\n }\n \n impl VisitTags for VClockAlloc {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // No tags here.\n     }\n }\n@@ -1220,7 +1220,7 @@ pub struct GlobalState {\n }\n \n impl VisitTags for GlobalState {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // We don't have any tags.\n     }\n }"}, {"sha": "9c9d505297c2dd88bb4bff1f4893ca31e79eba68", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -45,7 +45,7 @@ pub(super) struct InitOnce<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for waiter in self.waiters.iter() {\n             waiter.callback.visit_tags(visit);\n         }"}, {"sha": "402c9ce6fc9af927e9331eafd3ea9056f7f34c18", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -181,7 +181,7 @@ pub(crate) struct SynchronizationState<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for init_once in self.init_onces.iter() {\n             init_once.visit_tags(visit);\n         }"}, {"sha": "6ba93a13aaf2311a9f317ba23a53a4fcfb1bd170", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -212,7 +212,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n }\n \n impl VisitTags for Thread<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Thread {\n             panic_payload,\n             last_error,\n@@ -233,7 +233,7 @@ impl VisitTags for Thread<'_, '_> {\n }\n \n impl VisitTags for Frame<'_, '_, Provenance, FrameData<'_>> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Frame {\n             return_place,\n             locals,\n@@ -316,7 +316,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n }\n \n impl VisitTags for ThreadManager<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let ThreadManager {\n             threads,\n             thread_local_alloc_ids,"}, {"sha": "4c32efcfa3515139785e92e024a2dce8e79b85c7", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -109,7 +109,7 @@ pub struct StoreBufferAlloc {\n }\n \n impl VisitTags for StoreBufferAlloc {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Self { store_buffers } = self;\n         for val in store_buffers\n             .borrow()"}, {"sha": "bc771ca057f098c6a9ff350a8335649148dd9df2", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -6,7 +6,7 @@ use log::trace;\n use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n-use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n+use crate::borrow_tracker::{stacked_borrows::diagnostics::TagHistory, AccessKind};\n use crate::*;\n \n /// Details of premature program termination."}, {"sha": "7b4973f3b9daf2bdf3bce7e7f19bfd25db85c17c", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -9,6 +9,7 @@ use std::thread;\n \n use log::info;\n \n+use crate::borrow_tracker::RetagFields;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n@@ -87,7 +88,7 @@ pub struct MiriConfig {\n     /// Determine if validity checking is enabled.\n     pub validate: bool,\n     /// Determines if Stacked Borrows is enabled.\n-    pub stacked_borrows: bool,\n+    pub borrow_tracker: Option<BorrowTrackerMethod>,\n     /// Controls alignment checking.\n     pub check_alignment: AlignmentCheck,\n     /// Controls function [ABI](Abi) checking.\n@@ -103,7 +104,7 @@ pub struct MiriConfig {\n     /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n     pub seed: Option<u64>,\n     /// The stacked borrows pointer ids to report about\n-    pub tracked_pointer_tags: FxHashSet<SbTag>,\n+    pub tracked_pointer_tags: FxHashSet<BorTag>,\n     /// The stacked borrows call IDs to report about\n     pub tracked_call_ids: FxHashSet<CallId>,\n     /// The allocation ids to report about.\n@@ -138,7 +139,7 @@ pub struct MiriConfig {\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n     pub external_so_file: Option<PathBuf>,\n-    /// Run a garbage collector for SbTags every N basic blocks.\n+    /// Run a garbage collector for BorTags every N basic blocks.\n     pub gc_interval: u32,\n     /// The number of CPUs to be reported by miri.\n     pub num_cpus: u32,\n@@ -149,7 +150,7 @@ impl Default for MiriConfig {\n         MiriConfig {\n             env: vec![],\n             validate: true,\n-            stacked_borrows: true,\n+            borrow_tracker: Some(BorrowTrackerMethod::StackedBorrows),\n             check_alignment: AlignmentCheck::Int,\n             check_abi: true,\n             isolated_op: IsolatedOp::Reject(RejectOpWith::Abort),"}, {"sha": "c26828b11e0e1322e29fdb0d5069966f1237590f", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -45,7 +45,7 @@ pub struct GlobalStateInner {\n }\n \n impl VisitTags for GlobalStateInner {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // Nothing to visit here.\n     }\n }\n@@ -105,15 +105,15 @@ impl<'mir, 'tcx> GlobalStateInner {\n     pub fn expose_ptr(\n         ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         alloc_id: AllocId,\n-        sb: SbTag,\n+        tag: BorTag,\n     ) -> InterpResult<'tcx> {\n         let global_state = ecx.machine.intptrcast.get_mut();\n         // In strict mode, we don't need this, so we can save some cycles by not tracking it.\n         if global_state.provenance_mode != ProvenanceMode::Strict {\n             trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n-            if ecx.machine.stacked_borrows.is_some() {\n-                ecx.expose_tag(alloc_id, sb)?;\n+            if ecx.machine.borrow_tracker.is_some() {\n+                ecx.expose_tag(alloc_id, tag)?;\n             }\n         }\n         Ok(())"}, {"sha": "2c427c166c16d00fd7bdb2862327e2dff3d27afa", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -53,6 +53,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n \n+mod borrow_tracker;\n mod clock;\n mod concurrency;\n mod diagnostics;\n@@ -64,7 +65,6 @@ mod mono_hash_map;\n mod operator;\n mod range_map;\n mod shims;\n-mod stacked_borrows;\n mod tag_gc;\n \n // Establish a \"crate-wide prelude\": we often import `crate::*`.\n@@ -84,6 +84,12 @@ pub use crate::shims::time::EvalContextExt as _;\n pub use crate::shims::tls::TlsData;\n pub use crate::shims::EvalContextExt as _;\n \n+pub use crate::borrow_tracker::stacked_borrows::{\n+    EvalContextExt as _, Item, Permission, Stack, Stacks,\n+};\n+pub use crate::borrow_tracker::{\n+    BorTag, BorrowTrackerMethod, CallId, EvalContextExt as _, RetagFields,\n+};\n pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n     data_race::{AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, EvalContextExt as _},\n@@ -106,9 +112,6 @@ pub use crate::machine::{\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;\n pub use crate::range_map::RangeMap;\n-pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as _, Item, Permission, RetagFields, SbTag,\n-};\n pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be"}, {"sha": "920ee3e1ef1f492f8e39e7d8d802acd3b0fb06f2", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 64, "deletions": 80, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -39,7 +39,7 @@ pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n /// Extra data stored with each stack frame\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n-    pub stacked_borrows: Option<stacked_borrows::FrameExtra>,\n+    pub borrow_tracker: Option<borrow_tracker::FrameExtra>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n     /// called by `try`). When this frame is popped during unwinding a panic,\n@@ -61,20 +61,20 @@ pub struct FrameData<'tcx> {\n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n+        let FrameData { borrow_tracker, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n-            .field(\"stacked_borrows\", stacked_borrows)\n+            .field(\"borrow_tracker\", borrow_tracker)\n             .field(\"catch_unwind\", catch_unwind)\n             .finish()\n     }\n }\n \n impl VisitTags for FrameData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let FrameData { catch_unwind, borrow_tracker, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n     }\n }\n \n@@ -147,7 +147,7 @@ pub enum Provenance {\n     Concrete {\n         alloc_id: AllocId,\n         /// Stacked Borrows tag.\n-        sb: SbTag,\n+        tag: BorTag,\n     },\n     Wildcard,\n }\n@@ -173,7 +173,7 @@ impl std::hash::Hash for Provenance {\n /// The \"extra\" information a pointer has over a regular AllocId.\n #[derive(Copy, Clone, PartialEq)]\n pub enum ProvenanceExtra {\n-    Concrete(SbTag),\n+    Concrete(BorTag),\n     Wildcard,\n }\n \n@@ -188,15 +188,15 @@ static_assert_size!(Scalar<Provenance>, 32);\n impl fmt::Debug for Provenance {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n-            Provenance::Concrete { alloc_id, sb } => {\n+            Provenance::Concrete { alloc_id, tag } => {\n                 // Forward `alternate` flag to `alloc_id` printing.\n                 if f.alternate() {\n                     write!(f, \"[{alloc_id:#?}]\")?;\n                 } else {\n                     write!(f, \"[{alloc_id:?}]\")?;\n                 }\n                 // Print Stacked Borrows tag.\n-                write!(f, \"{sb:?}\")?;\n+                write!(f, \"{tag:?}\")?;\n             }\n             Provenance::Wildcard => {\n                 write!(f, \"[wildcard]\")?;\n@@ -221,9 +221,9 @@ impl interpret::Provenance for Provenance {\n         match (left, right) {\n             // If both are the *same* concrete tag, that is the result.\n             (\n-                Some(Provenance::Concrete { alloc_id: left_alloc, sb: left_sb }),\n-                Some(Provenance::Concrete { alloc_id: right_alloc, sb: right_sb }),\n-            ) if left_alloc == right_alloc && left_sb == right_sb => left,\n+                Some(Provenance::Concrete { alloc_id: left_alloc, tag: left_tag }),\n+                Some(Provenance::Concrete { alloc_id: right_alloc, tag: right_tag }),\n+            ) if left_alloc == right_alloc && left_tag == right_tag => left,\n             // If one side is a wildcard, the best possible outcome is that it is equal to the other\n             // one, and we use that.\n             (Some(Provenance::Wildcard), o) | (o, Some(Provenance::Wildcard)) => o,\n@@ -243,7 +243,7 @@ impl fmt::Debug for ProvenanceExtra {\n }\n \n impl ProvenanceExtra {\n-    pub fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n+    pub fn and_then<T>(self, f: impl FnOnce(BorTag) -> Option<T>) -> Option<T> {\n         match self {\n             ProvenanceExtra::Concrete(pid) => f(pid),\n             ProvenanceExtra::Wildcard => None,\n@@ -254,8 +254,8 @@ impl ProvenanceExtra {\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    /// Stacked Borrows state is only added if it is enabled.\n-    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n+    /// Global state of the borrow tracker, if enabled.\n+    pub borrow_tracker: Option<borrow_tracker::AllocExtra>,\n     /// Data race detection via the use of a vector-clock,\n     ///  this is only added if it is enabled.\n     pub data_race: Option<data_race::AllocExtra>,\n@@ -265,10 +265,10 @@ pub struct AllocExtra {\n }\n \n impl VisitTags for AllocExtra {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let AllocExtra { stacked_borrows, data_race, weak_memory } = self;\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let AllocExtra { borrow_tracker, data_race, weak_memory } = self;\n \n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n         data_race.visit_tags(visit);\n         weak_memory.visit_tags(visit);\n     }\n@@ -350,8 +350,8 @@ pub struct MiriMachine<'mir, 'tcx> {\n     // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// Stacked Borrows global data.\n-    pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+    /// Global data for borrow tracking.\n+    pub borrow_tracker: Option<borrow_tracker::GlobalState>,\n \n     /// Data race detector global data.\n     pub data_race: Option<data_race::GlobalState>,\n@@ -463,9 +463,9 @@ pub struct MiriMachine<'mir, 'tcx> {\n     #[cfg(not(target_os = \"linux\"))]\n     pub external_so_lib: Option<!>,\n \n-    /// Run a garbage collector for SbTags every N basic blocks.\n+    /// Run a garbage collector for BorTags every N basic blocks.\n     pub(crate) gc_interval: u32,\n-    /// The number of blocks that passed since the last SbTag GC pass.\n+    /// The number of blocks that passed since the last BorTag GC pass.\n     pub(crate) since_gc: u32,\n     /// The number of CPUs to be reported by miri.\n     pub(crate) num_cpus: u32,\n@@ -480,17 +480,11 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n         });\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n-        let stacked_borrows = config.stacked_borrows.then(|| {\n-            RefCell::new(stacked_borrows::GlobalStateInner::new(\n-                config.tracked_pointer_tags.clone(),\n-                config.tracked_call_ids.clone(),\n-                config.retag_fields,\n-            ))\n-        });\n+        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instanciate_global_state(config));\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n         MiriMachine {\n             tcx: layout_cx.tcx,\n-            stacked_borrows,\n+            borrow_tracker,\n             data_race,\n             intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n             // `env_vars` depends on a full interpreter so we cannot properly initialize it yet.\n@@ -656,7 +650,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n }\n \n impl VisitTags for MiriMachine<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         #[rustfmt::skip]\n         let MiriMachine {\n             threads,\n@@ -668,7 +662,7 @@ impl VisitTags for MiriMachine<'_, '_> {\n             cmd_line,\n             extern_statics,\n             dir_handler,\n-            stacked_borrows,\n+            borrow_tracker,\n             data_race,\n             intptrcast,\n             file_handler,\n@@ -706,7 +700,7 @@ impl VisitTags for MiriMachine<'_, '_> {\n         dir_handler.visit_tags(visit);\n         file_handler.visit_tags(visit);\n         data_race.visit_tags(visit);\n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n         intptrcast.visit_tags(visit);\n         main_fn_ret_place.visit_tags(visit);\n         argc.visit_tags(visit);\n@@ -907,15 +901,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         }\n \n         let alloc = alloc.into_owned();\n-        let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            stacked_borrows::Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                &ecx.machine,\n-            )\n-        });\n+        let borrow_tracker = ecx\n+            .machine\n+            .borrow_tracker\n+            .as_ref()\n+            .map(|bt| bt.borrow_mut().new_allocation(id, alloc.size(), kind, &ecx.machine));\n+\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n                 data_race,\n@@ -927,11 +918,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocExtra::new_allocation);\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n-            AllocExtra {\n-                stacked_borrows: stacks.map(RefCell::new),\n-                data_race: race_alloc,\n-                weak_memory: buffer_alloc,\n-            },\n+            AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n             |ptr| ecx.global_base_pointer(ptr),\n         )?;\n         Ok(Cow::Owned(alloc))\n@@ -955,14 +942,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             }\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n-        let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n+        let tag = if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n+            borrow_tracker.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n-            SbTag::default()\n+            BorTag::default()\n         };\n         Pointer::new(\n-            Provenance::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n+            Provenance::Concrete { alloc_id: ptr.provenance, tag },\n             Size::from_bytes(absolute_addr),\n         )\n     }\n@@ -980,8 +967,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Provenance::Concrete { alloc_id, sb } =>\n-                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, sb),\n+            Provenance::Concrete { alloc_id, tag } =>\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag),\n             Provenance::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n@@ -999,11 +986,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n \n         rel.map(|(alloc_id, size)| {\n-            let sb = match ptr.provenance {\n-                Provenance::Concrete { sb, .. } => ProvenanceExtra::Concrete(sb),\n+            let tag = match ptr.provenance {\n+                Provenance::Concrete { tag, .. } => ProvenanceExtra::Concrete(tag),\n                 Provenance::Wildcard => ProvenanceExtra::Wildcard,\n             };\n-            (alloc_id, size, sb)\n+            (alloc_id, size, tag)\n         })\n     }\n \n@@ -1018,10 +1005,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n             data_race.read(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows\n-                .borrow_mut()\n-                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n+        if let Some(borrow_tracker) = &alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1040,8 +1025,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.write(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n+        if let Some(borrow_tracker) = &mut alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1063,16 +1048,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.deallocate(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_deallocation(\n-                alloc_id,\n-                prove_extra,\n-                range,\n-                machine,\n-            )\n-        } else {\n-            Ok(())\n+        if let Some(borrow_tracker) = &mut alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_deallocation(alloc_id, prove_extra, range, machine)?;\n         }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1081,7 +1060,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag(kind, place)?;\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1104,10 +1086,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             None\n         };\n \n-        let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n+        let borrow_tracker = ecx.machine.borrow_tracker.as_ref();\n \n         let extra = FrameData {\n-            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n+            borrow_tracker: borrow_tracker.map(|bt| bt.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n             is_user_relevant: ecx.machine.is_user_relevant(&frame),\n@@ -1140,7 +1122,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             }\n         }\n \n-        // Search for SbTags to find all live pointers, then remove all other tags from borrow\n+        // Search for BorTags to find all live pointers, then remove all other tags from borrow\n         // stacks.\n         // When debug assertions are enabled, run the GC as often as possible so that any cases\n         // where it mistakenly removes an important tag become visible.\n@@ -1166,8 +1148,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             let stack_len = ecx.active_thread_stack().len();\n             ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n         }\n-\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag_return_place()?;\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1184,8 +1168,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             ecx.active_thread_mut().recompute_top_user_relevant_frame();\n         }\n         let timing = frame.extra.timing.take();\n-        if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().end_call(&frame.extra);\n+        if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n+            borrow_tracker.borrow_mut().end_call(&frame.extra);\n         }\n         let res = ecx.handle_stack_pop_unwind(frame.extra, unwinding);\n         if let Some(profiler) = ecx.machine.profiler.as_ref() {"}, {"sha": "80fb4ff2fe9802e051d61389f3f90c67978bddce", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -37,7 +37,7 @@ pub struct EnvVars<'tcx> {\n }\n \n impl VisitTags for EnvVars<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let EnvVars { map, environ } = self;\n \n         environ.visit_tags(visit);"}, {"sha": "7c30845dc675677eec626100c5c9a74c39db4e9c", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -36,7 +36,7 @@ pub struct CatchUnwindData<'tcx> {\n }\n \n impl VisitTags for CatchUnwindData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let CatchUnwindData { catch_fn, data, dest, ret: _ } = self;\n         catch_fn.visit_tags(visit);\n         data.visit_tags(visit);"}, {"sha": "d263aab351b12e07591210cc85ede4bc60c461c0", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -278,7 +278,7 @@ struct UnblockCallback {\n }\n \n impl VisitTags for UnblockCallback {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {}\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {}\n }\n \n impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for UnblockCallback {"}, {"sha": "54fdf2872ab4d3967c594fba3d30def27840b96f", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -208,7 +208,7 @@ impl<'tcx> TlsData<'tcx> {\n }\n \n impl VisitTags for TlsData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let TlsData { keys, macos_thread_dtors, next_key: _ } = self;\n \n         for scalar in keys.values().flat_map(|v| v.data.values()) {"}, {"sha": "988627db5611c283c0ee35c8b5e77fe6a97f18e7", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -278,7 +278,7 @@ pub struct FileHandler {\n }\n \n impl VisitTags for FileHandler {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // All our FileDescriptor do not have any tags.\n     }\n }\n@@ -490,7 +490,7 @@ impl Default for DirHandler {\n }\n \n impl VisitTags for DirHandler {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let DirHandler { streams, next_id: _ } = self;\n \n         for dir in streams.values() {"}, {"sha": "343232c4bbb2913a247d6c13c622806660ecbb84", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -183,7 +183,7 @@ pub fn futex<'tcx>(\n                     }\n \n                     impl<'tcx> VisitTags for Callback<'tcx> {\n-                        fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                             let Callback { thread: _, addr_usize: _, dest } = self;\n                             dest.visit_tags(visit);\n                         }"}, {"sha": "f9b5774f0090e05ece1d5e2703386a2452091fae", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -747,7 +747,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         impl<'tcx> VisitTags for Callback<'tcx> {\n-            fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+            fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                 let Callback { active_thread: _, mutex_id: _, id: _, dest } = self;\n                 dest.visit_tags(visit);\n             }"}, {"sha": "6b043c6d2c9e1c723d2d242d1ff12e896f3a61c7", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -182,7 +182,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n \n                 impl<'tcx> VisitTags for Callback<'tcx> {\n-                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                         let Callback { init_once_id: _, pending_place } = self;\n                         pending_place.visit_tags(visit);\n                     }\n@@ -315,7 +315,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n \n                 impl<'tcx> VisitTags for Callback<'tcx> {\n-                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                         let Callback { thread: _, addr: _, dest } = self;\n                         dest.visit_tags(visit);\n                     }\n@@ -419,7 +419,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             impl<'tcx> VisitTags for Callback<'tcx> {\n-                fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                     let Callback { thread: _, condvar_id: _, lock_id: _, mode: _, dest } = self;\n                     dest.visit_tags(visit);\n                 }"}, {"sha": "c1194fe22163a65cbe8977e849e73161dcc0c48c", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90118a197ba91c248376e1ff72bdf7dc370776f6/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=90118a197ba91c248376e1ff72bdf7dc370776f6", "patch": "@@ -3,53 +3,53 @@ use rustc_data_structures::fx::FxHashSet;\n use crate::*;\n \n pub trait VisitTags {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag));\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag));\n }\n \n impl<T: VisitTags> VisitTags for Option<T> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         if let Some(x) = self {\n             x.visit_tags(visit);\n         }\n     }\n }\n \n impl<T: VisitTags> VisitTags for std::cell::RefCell<T> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         self.borrow().visit_tags(visit)\n     }\n }\n \n-impl VisitTags for SbTag {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+impl VisitTags for BorTag {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         visit(*self)\n     }\n }\n \n impl VisitTags for Provenance {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        if let Provenance::Concrete { sb, .. } = self {\n-            visit(*sb);\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        if let Provenance::Concrete { tag, .. } = self {\n+            visit(*tag);\n         }\n     }\n }\n \n impl VisitTags for Pointer<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let (prov, _offset) = self.into_parts();\n         prov.visit_tags(visit);\n     }\n }\n \n impl VisitTags for Pointer<Option<Provenance>> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let (prov, _offset) = self.into_parts();\n         prov.visit_tags(visit);\n     }\n }\n \n impl VisitTags for Scalar<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Scalar::Ptr(ptr, _) => ptr.visit_tags(visit),\n             Scalar::Int(_) => (),\n@@ -58,7 +58,7 @@ impl VisitTags for Scalar<Provenance> {\n }\n \n impl VisitTags for Immediate<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Immediate::Scalar(s) => {\n                 s.visit_tags(visit);\n@@ -73,7 +73,7 @@ impl VisitTags for Immediate<Provenance> {\n }\n \n impl VisitTags for MemPlaceMeta<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             MemPlaceMeta::Meta(m) => m.visit_tags(visit),\n             MemPlaceMeta::None => {}\n@@ -82,21 +82,21 @@ impl VisitTags for MemPlaceMeta<Provenance> {\n }\n \n impl VisitTags for MemPlace<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let MemPlace { ptr, meta } = self;\n         ptr.visit_tags(visit);\n         meta.visit_tags(visit);\n     }\n }\n \n impl VisitTags for MPlaceTy<'_, Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         (**self).visit_tags(visit)\n     }\n }\n \n impl VisitTags for Place<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Place::Ptr(p) => p.visit_tags(visit),\n             Place::Local { .. } => {\n@@ -107,13 +107,13 @@ impl VisitTags for Place<Provenance> {\n }\n \n impl VisitTags for PlaceTy<'_, Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         (**self).visit_tags(visit)\n     }\n }\n \n impl VisitTags for Operand<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Operand::Immediate(imm) => {\n                 imm.visit_tags(visit);\n@@ -126,7 +126,7 @@ impl VisitTags for Operand<Provenance> {\n }\n \n impl VisitTags for Allocation<Provenance, AllocExtra> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for prov in self.provenance().provenances() {\n             prov.visit_tags(visit);\n         }\n@@ -136,7 +136,7 @@ impl VisitTags for Allocation<Provenance, AllocExtra> {\n }\n \n impl VisitTags for crate::MiriInterpCx<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         // Memory.\n         self.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n@@ -154,7 +154,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off.\n-        if this.machine.stacked_borrows.is_none() {\n+        if this.machine.borrow_tracker.is_none() {\n             return Ok(());\n         }\n \n@@ -167,17 +167,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn remove_unreachable_tags(&mut self, tags: FxHashSet<SbTag>) {\n+    fn remove_unreachable_tags(&mut self, tags: FxHashSet<BorTag>) {\n         let this = self.eval_context_mut();\n         this.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n-                alloc\n-                    .extra\n-                    .stacked_borrows\n-                    .as_ref()\n-                    .unwrap()\n-                    .borrow_mut()\n-                    .remove_unreachable_tags(&tags);\n+                if let Some(bt) = &alloc.extra.borrow_tracker {\n+                    bt.remove_unreachable_tags(&tags);\n+                }\n             }\n         });\n     }"}]}