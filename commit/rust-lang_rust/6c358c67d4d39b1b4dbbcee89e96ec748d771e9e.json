{"sha": "6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "node_id": "C_kwDOAAsO6NoAKDZjMzU4YzY3ZDRkMzliMWI0ZGJiY2VlODllOTZlYzc0OGQ3NzFlOWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T03:16:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T03:16:29Z"}, "message": "Auto merge of #101241 - camsteffen:refactor-binding-annotations, r=cjgillot\n\n`BindingAnnotation` refactor\n\n* `ast::BindingMode` is deleted and replaced with `hir::BindingAnnotation` (which is moved to `ast`)\n* `BindingAnnotation` is changed from an enum to a tuple struct e.g. `BindingAnnotation(ByRef::No, Mutability::Mut)`\n* Associated constants added for convenience `BindingAnnotation::{NONE, REF, MUT, REF_MUT}`\n\nOne goal is to make it more clear that `BindingAnnotation` merely represents syntax `ref mut` and not the actual binding mode. This was especially confusing since we had `ast::BindingMode`->`hir::BindingAnnotation`->`thir::BindingMode`.\n\nI wish there were more symmetry between `ByRef` and `Mutability` (variant) naming (maybe `Mutable::Yes`?), and I also don't love how long the name `BindingAnnotation` is, but this seems like the best compromise. Ideas welcome.", "tree": {"sha": "0b408a0a95a82676690a365e92530600e2a78874", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b408a0a95a82676690a365e92530600e2a78874"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "html_url": "https://github.com/rust-lang/rust/commit/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56b27110e7f72ea01312d99f1b1e0577431cbbd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/56b27110e7f72ea01312d99f1b1e0577431cbbd0", "html_url": "https://github.com/rust-lang/rust/commit/56b27110e7f72ea01312d99f1b1e0577431cbbd0"}, {"sha": "9ea82d57e296efd6dfc0cb0a6c4c09f4111c123d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea82d57e296efd6dfc0cb0a6c4c09f4111c123d", "html_url": "https://github.com/rust-lang/rust/commit/9ea82d57e296efd6dfc0cb0a6c4c09f4111c123d"}], "stats": {"total": 607, "additions": 276, "deletions": 331}, "files": [{"sha": "f25fdc942b0850db6590061f0956ba536b21302b", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -594,7 +594,7 @@ impl Pat {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+            PatKind::Ident(BindingAnnotation::NONE, ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n@@ -681,10 +681,43 @@ pub struct PatField {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-pub enum BindingMode {\n-    ByRef(Mutability),\n-    ByValue(Mutability),\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum ByRef {\n+    Yes,\n+    No,\n+}\n+\n+impl From<bool> for ByRef {\n+    fn from(b: bool) -> ByRef {\n+        match b {\n+            false => ByRef::No,\n+            true => ByRef::Yes,\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub struct BindingAnnotation(pub ByRef, pub Mutability);\n+\n+impl BindingAnnotation {\n+    pub const NONE: Self = Self(ByRef::No, Mutability::Not);\n+    pub const REF: Self = Self(ByRef::Yes, Mutability::Not);\n+    pub const MUT: Self = Self(ByRef::No, Mutability::Mut);\n+    pub const REF_MUT: Self = Self(ByRef::Yes, Mutability::Mut);\n+\n+    pub fn prefix_str(self) -> &'static str {\n+        match self {\n+            Self::NONE => \"\",\n+            Self::REF => \"ref \",\n+            Self::MUT => \"mut \",\n+            Self::REF_MUT => \"ref mut \",\n+        }\n+    }\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -713,7 +746,7 @@ pub enum PatKind {\n     /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n     /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n     /// during name resolution.\n-    Ident(BindingMode, Ident, Option<P<Pat>>),\n+    Ident(BindingAnnotation, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -2228,7 +2261,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Param {\n     /// Attempts to cast parameter to `ExplicitSelf`.\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n+        if let PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n                 return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -2258,31 +2291,31 @@ impl Param {\n     pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty { id: DUMMY_NODE_ID, kind: TyKind::ImplicitSelf, span, tokens: None });\n-        let param = |mutbl, ty| Param {\n+        let (mutbl, ty) = match eself.node {\n+            SelfKind::Explicit(ty, mutbl) => (mutbl, ty),\n+            SelfKind::Value(mutbl) => (mutbl, infer_ty),\n+            SelfKind::Region(lt, mutbl) => (\n+                Mutability::Not,\n+                P(Ty {\n+                    id: DUMMY_NODE_ID,\n+                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n+                    span,\n+                    tokens: None,\n+                }),\n+            ),\n+        };\n+        Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                kind: PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), eself_ident, None),\n                 span,\n                 tokens: None,\n             }),\n             span,\n             ty,\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n-        };\n-        match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n-            SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => param(\n-                Mutability::Not,\n-                P(Ty {\n-                    id: DUMMY_NODE_ID,\n-                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n-                    span,\n-                    tokens: None,\n-                }),\n-            ),\n         }\n     }\n }"}, {"sha": "77babeb5d39d186099b6b9f2505b6522c0d9a928", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -577,7 +577,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (pat, task_context_hid) = self.pat_ident_binding_mode(\n             span,\n             Ident::with_dummy_span(sym::_task_context),\n-            hir::BindingAnnotation::Mutable,\n+            hir::BindingAnnotation::MUT,\n         );\n         let param = hir::Param {\n             hir_id: self.next_id(),\n@@ -671,7 +671,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // this name to identify what is being awaited by a suspended async functions.\n         let awaitee_ident = Ident::with_dummy_span(sym::__awaitee);\n         let (awaitee_pat, awaitee_pat_hid) =\n-            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::MUT);\n \n         let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n \n@@ -1433,7 +1433,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter`\n         let iter = Ident::with_dummy_span(sym::iter);\n         let (iter_pat, iter_pat_nid) =\n-            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::MUT);\n \n         // `match Iterator::next(&mut iter) { ... }`\n         let match_expr = {"}, {"sha": "76f63d1d78a90c284aa3df5ff290ee356f0df509", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1083,12 +1083,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n                 let (ident, is_simple_parameter) = match parameter.pat.kind {\n-                    hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                        _,\n-                        ident,\n-                        _,\n-                    ) => (ident, true),\n+                    hir::PatKind::Binding(hir::BindingAnnotation(ByRef::No, _), _, ident, _) => {\n+                        (ident, true)\n+                    }\n                     // For `ref mut` or wildcard arguments, we can't reuse the binding, but\n                     // we can keep the same name for the parameter.\n                     // This lets rustdoc render it correctly in documentation.\n@@ -1153,7 +1150,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span,\n                         ident,\n-                        hir::BindingAnnotation::Mutable,\n+                        hir::BindingAnnotation::MUT,\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat("}, {"sha": "3a94c7a91b23f7adf1c60e43ffd678decd950be6", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1692,10 +1692,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             output,\n             c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(hir::ImplicitSelfKind::None, |arg| {\n-                use BindingMode::{ByRef, ByValue};\n                 let is_mutable_pat = matches!(\n                     arg.pat.kind,\n-                    PatKind::Ident(ByValue(Mutability::Mut) | ByRef(Mutability::Mut), ..)\n+                    PatKind::Ident(hir::BindingAnnotation(_, Mutability::Mut), ..)\n                 );\n \n                 match arg.ty.kind {\n@@ -2360,11 +2359,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n-        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n+        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::NONE)\n     }\n \n     fn pat_ident_mut(&mut self, span: Span, ident: Ident) -> (hir::Pat<'hir>, hir::HirId) {\n-        self.pat_ident_binding_mode_mut(span, ident, hir::BindingAnnotation::Unannotated)\n+        self.pat_ident_binding_mode_mut(span, ident, hir::BindingAnnotation::NONE)\n     }\n \n     fn pat_ident_binding_mode("}, {"sha": "a1eee1be7984f63dfd174cc414d26c42820f50a5", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let node = loop {\n                 match pattern.kind {\n                     PatKind::Wild => break hir::PatKind::Wild,\n-                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                    PatKind::Ident(binding_mode, ident, ref sub) => {\n                         let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n                         break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n                     }\n@@ -176,9 +176,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut prev_rest_span = None;\n \n         // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n-        let lower_rest_sub = |this: &mut Self, pat, bm, ident, sub| {\n+        let lower_rest_sub = |this: &mut Self, pat, ann, ident, sub| {\n             let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-            let node = this.lower_pat_ident(pat, bm, ident, lower_sub);\n+            let node = this.lower_pat_ident(pat, ann, ident, lower_sub);\n             this.pat_with_node_id_of(pat, node)\n         };\n \n@@ -194,9 +194,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n-                    slice = Some(self.arena.alloc(lower_rest_sub(self, pat, bm, ident, sub)));\n+                    slice = Some(self.arena.alloc(lower_rest_sub(self, pat, ann, ident, sub)));\n                     break;\n                 }\n                 // It was not a subslice pattern so lower it normally.\n@@ -209,9 +209,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // There was a previous subslice pattern; make sure we don't allow more.\n             let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n                     // #69103: Lower into `binding @ _` as above to avoid ICEs.\n-                    after.push(lower_rest_sub(self, pat, bm, ident, sub));\n+                    after.push(lower_rest_sub(self, pat, ann, ident, sub));\n                     Some(sub.span)\n                 }\n                 _ => None,\n@@ -235,7 +235,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_pat_ident(\n         &mut self,\n         p: &Pat,\n-        binding_mode: &BindingMode,\n+        annotation: BindingAnnotation,\n         ident: Ident,\n         lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n     ) -> hir::PatKind<'hir> {\n@@ -248,7 +248,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 };\n \n                 hir::PatKind::Binding(\n-                    self.lower_binding_mode(binding_mode),\n+                    annotation,\n                     self.lower_node_id(canonical_id),\n                     self.lower_ident(ident),\n                     lower_sub(self),\n@@ -269,15 +269,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n-        match *b {\n-            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n-        }\n-    }\n-\n     fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n         self.arena.alloc(self.pat_with_node_id_of(p, hir::PatKind::Wild))\n     }"}, {"sha": "d6d8881a53a146e0c4c62d8fb93123122fb735fe", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -281,8 +281,8 @@ impl<'a> AstValidator<'a> {\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None) | PatKind::Wild => {}\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ident, None) => {\n+                PatKind::Ident(BindingAnnotation::NONE, _, None) | PatKind::Wild => {}\n+                PatKind::Ident(BindingAnnotation::MUT, ident, None) => {\n                     report_err(pat.span, Some(ident), true)\n                 }\n                 _ => report_err(pat.span, None, false),"}, {"sha": "ed5e7dace4bc4ba1ea971d7c1d61e9e7e244672e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -11,8 +11,8 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{attr, Term};\n+use rustc_ast::{self as ast, BlockCheckMode, Mutability, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::{attr, BindingAnnotation, ByRef, Term};\n use rustc_ast::{GenericArg, MacArgs, MacArgsEq};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n@@ -1399,16 +1399,12 @@ impl<'a> State<'a> {\n         is that it doesn't matter */\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Ident(binding_mode, ident, ref sub) => {\n-                match binding_mode {\n-                    ast::BindingMode::ByRef(mutbl) => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(mutbl, false);\n-                    }\n-                    ast::BindingMode::ByValue(ast::Mutability::Not) => {}\n-                    ast::BindingMode::ByValue(ast::Mutability::Mut) => {\n-                        self.word_nbsp(\"mut\");\n-                    }\n+            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, ref sub) => {\n+                if by_ref == ByRef::Yes {\n+                    self.word_nbsp(\"ref\");\n+                }\n+                if mutbl == Mutability::Mut {\n+                    self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n@@ -1487,12 +1483,10 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 self.word(\"&\");\n-                if mutbl == ast::Mutability::Mut {\n+                if mutbl == Mutability::Mut {\n                     self.word(\"mut \");\n                 }\n-                if let PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Mut), ..) =\n-                    inner.kind\n-                {\n+                if let PatKind::Ident(ast::BindingAnnotation::MUT, ..) = inner.kind {\n                     self.popen();\n                     self.print_pat(inner);\n                     self.pclose();"}, {"sha": "2c6c461267a916a689aca507388dd11c37195f13", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some(Node::Pat(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n                     && let hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated,\n+                        hir::BindingAnnotation::NONE,\n                         _,\n                         upvar_ident,\n                         _,"}, {"sha": "3cc160adb5397aa73ed3041e23e8f0d081db2fc5", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -164,7 +164,9 @@ pub use SubstructureFields::*;\n \n use crate::deriving;\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, EnumDef, Expr, Generics, PatKind};\n+use rustc_ast::{\n+    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, Generics, Mutability, PatKind,\n+};\n use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n@@ -1063,9 +1065,9 @@ impl<'a> MethodDef<'a> {\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let use_ref_pat = is_packed && !always_copy;\n+            let by_ref = ByRef::from(is_packed && !always_copy);\n             let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, use_ref_pat);\n+                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, by_ref);\n \n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n@@ -1247,13 +1249,13 @@ impl<'a> MethodDef<'a> {\n \n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n-                let use_ref_pat = false; // because enums can't be repr(packed)\n+                let by_ref = ByRef::No; // because enums can't be repr(packed)\n                 let mut subpats: Vec<_> = trait_.create_struct_patterns(\n                     cx,\n                     variant_path,\n                     &variant.data,\n                     &prefixes,\n-                    use_ref_pat,\n+                    by_ref,\n                 );\n \n                 // `(VariantK, VariantK, ...)` or just `VariantK`.\n@@ -1414,25 +1416,27 @@ impl<'a> TraitDef<'a> {\n         struct_path: ast::Path,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        use_ref_pat: bool,\n+        by_ref: ByRef,\n     ) -> Vec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {\n                 let pieces_iter =\n                     struct_def.fields().iter().enumerate().map(|(i, struct_field)| {\n                         let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-                        let binding_mode = if use_ref_pat {\n-                            ast::BindingMode::ByRef(ast::Mutability::Not)\n-                        } else {\n-                            ast::BindingMode::ByValue(ast::Mutability::Not)\n-                        };\n                         let ident = self.mk_pattern_ident(prefix, i);\n                         let path = ident.with_span_pos(sp);\n                         (\n                             sp,\n                             struct_field.ident,\n-                            cx.pat(path.span, PatKind::Ident(binding_mode, path, None)),\n+                            cx.pat(\n+                                path.span,\n+                                PatKind::Ident(\n+                                    BindingAnnotation(by_ref, Mutability::Not),\n+                                    path,\n+                                    None,\n+                                ),\n+                            ),\n                         )\n                     });\n "}, {"sha": "cf2c023c2f89f3de35ffb9c5c2d43bd1a2be728f", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -178,8 +178,7 @@ impl<'a> ExtCtxt<'a> {\n         ex: P<ast::Expr>,\n     ) -> ast::Stmt {\n         let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n-            self.pat_ident_binding_mode(sp, ident, binding_mode)\n+            self.pat_ident_binding_mode(sp, ident, ast::BindingAnnotation::MUT)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -445,17 +444,16 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n     pub fn pat_ident(&self, span: Span, ident: Ident) -> P<ast::Pat> {\n-        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Not);\n-        self.pat_ident_binding_mode(span, ident, binding_mode)\n+        self.pat_ident_binding_mode(span, ident, ast::BindingAnnotation::NONE)\n     }\n \n     pub fn pat_ident_binding_mode(\n         &self,\n         span: Span,\n         ident: Ident,\n-        bm: ast::BindingMode,\n+        ann: ast::BindingAnnotation,\n     ) -> P<ast::Pat> {\n-        let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n+        let pat = PatKind::Ident(ann, ident.with_span_pos(span), None);\n         self.pat(span, pat)\n     }\n     pub fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {"}, {"sha": "50e7c5d2d04c8ba269584ac8d48001a3c2947ef6", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -7,7 +7,7 @@ use crate::LangItem;\n use rustc_ast as ast;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, TraitObjectSyntax, UintTy};\n-pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n+pub use rustc_ast::{BindingAnnotation, BorrowKind, ByRef, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -1044,30 +1044,6 @@ pub struct PatField<'hir> {\n     pub span: Span,\n }\n \n-/// Explicit binding annotations given in the HIR for a binding. Note\n-/// that this is not the final binding *mode* that we infer after type\n-/// inference.\n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n-pub enum BindingAnnotation {\n-    /// No binding annotation given: this means that the final binding mode\n-    /// will depend on whether we have skipped through a `&` reference\n-    /// when matching. For example, the `x` in `Some(x)` will have binding\n-    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n-    /// ultimately be inferred to be by-reference.\n-    ///\n-    /// Note that implicit reference skipping is not implemented yet (#42640).\n-    Unannotated,\n-\n-    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n-    Mutable,\n-\n-    /// Annotated as `ref`, like `ref x`\n-    Ref,\n-\n-    /// Annotated as `ref mut x`.\n-    RefMut,\n-}\n-\n #[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,"}, {"sha": "9baaf9390f2c5aa181bfde02841de865236339af", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n-use crate::hir::{self, HirId, PatKind};\n+use crate::hir::{self, BindingAnnotation, ByRef, HirId, PatKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n@@ -93,12 +93,7 @@ impl hir::Pat<'_> {\n \n     pub fn simple_ident(&self) -> Option<Ident> {\n         match self.kind {\n-            PatKind::Binding(\n-                hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                _,\n-                ident,\n-                None,\n-            ) => Some(ident),\n+            PatKind::Binding(BindingAnnotation(ByRef::No, _), _, ident, None) => Some(ident),\n             _ => None,\n         }\n     }\n@@ -135,11 +130,11 @@ impl hir::Pat<'_> {\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| match annotation {\n-            hir::BindingAnnotation::Ref => match result {\n+            hir::BindingAnnotation::REF => match result {\n                 None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n                 _ => {}\n             },\n-            hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mut),\n+            hir::BindingAnnotation::REF_MUT => result = Some(hir::Mutability::Mut),\n             _ => {}\n         });\n         result"}, {"sha": "1220755f44b30866aa3394a31fc4588e55d1fd02", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -9,7 +9,9 @@ use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::LifetimeParamKind;\n-use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node, Term};\n+use rustc_hir::{\n+    BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Mutability, Node, Term,\n+};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n@@ -1743,20 +1745,12 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Binding(binding_mode, _, ident, sub) => {\n-                match binding_mode {\n-                    hir::BindingAnnotation::Ref => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Not, false);\n-                    }\n-                    hir::BindingAnnotation::RefMut => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mut, false);\n-                    }\n-                    hir::BindingAnnotation::Unannotated => {}\n-                    hir::BindingAnnotation::Mutable => {\n-                        self.word_nbsp(\"mut\");\n-                    }\n+            PatKind::Binding(BindingAnnotation(by_ref, mutbl), _, ident, sub) => {\n+                if by_ref == ByRef::Yes {\n+                    self.word_nbsp(\"ref\");\n+                }\n+                if mutbl == Mutability::Mut {\n+                    self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);\n                 if let Some(p) = sub {"}, {"sha": "f06bfa912ca5314480708ec9ff2f4f2762c32423", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -259,17 +259,8 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n                     {\n                         cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n-                            let binding = match binding_annot {\n-                                hir::BindingAnnotation::Unannotated => None,\n-                                hir::BindingAnnotation::Mutable => Some(\"mut\"),\n-                                hir::BindingAnnotation::Ref => Some(\"ref\"),\n-                                hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n-                            };\n-                            let suggested_ident = if let Some(binding) = binding {\n-                                format!(\"{} {}\", binding, ident)\n-                            } else {\n-                                ident.to_string()\n-                            };\n+                            let suggested_ident =\n+                                format!(\"{}{}\", binding_annot.prefix_str(), ident);\n                             lint.build(fluent::lint::builtin_non_shorthand_field_patterns)\n                                 .set_arg(\"ident\", ident.clone())\n                                 .span_suggestion("}, {"sha": "9a7d722c05a90be163d3b8a83bc506889f0b095f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -751,7 +751,7 @@ impl UnusedParens {\n         avoid_or: bool,\n         avoid_mut: bool,\n     ) {\n-        use ast::{BindingMode, Mutability, PatKind};\n+        use ast::{BindingAnnotation, PatKind};\n \n         if let PatKind::Paren(inner) = &value.kind {\n             match inner.kind {\n@@ -763,7 +763,9 @@ impl UnusedParens {\n                 // Avoid `p0 | .. | pn` if we should.\n                 PatKind::Or(..) if avoid_or => return,\n                 // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n+                PatKind::Ident(BindingAnnotation::MUT, ..) if avoid_mut => {\n+                    return;\n+                }\n                 // Otherwise proceed with linting.\n                 _ => {}\n             }"}, {"sha": "a5b05a4f9b526a01fbeb9c67e5106e3e5635006f", "filename": "compiler/rustc_middle/src/ty/binding.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fbinding.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1,6 +1,4 @@\n-use rustc_hir::BindingAnnotation;\n-use rustc_hir::BindingAnnotation::*;\n-use rustc_hir::Mutability;\n+use rustc_hir::{BindingAnnotation, ByRef, Mutability};\n \n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, Debug, Copy, HashStable)]\n pub enum BindingMode {\n@@ -11,12 +9,10 @@ pub enum BindingMode {\n TrivialTypeTraversalAndLiftImpls! { BindingMode, }\n \n impl BindingMode {\n-    pub fn convert(ba: BindingAnnotation) -> BindingMode {\n-        match ba {\n-            Unannotated => BindingMode::BindByValue(Mutability::Not),\n-            Mutable => BindingMode::BindByValue(Mutability::Mut),\n-            Ref => BindingMode::BindByReference(Mutability::Not),\n-            RefMut => BindingMode::BindByReference(Mutability::Mut),\n+    pub fn convert(BindingAnnotation(by_ref, mutbl): BindingAnnotation) -> BindingMode {\n+        match by_ref {\n+            ByRef::No => BindingMode::BindByValue(mutbl),\n+            ByRef::Yes => BindingMode::BindByReference(mutbl),\n         }\n     }\n }"}, {"sha": "9b5dd09372cc8cd18a2746948e2f43a01f5ff54d", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -10,9 +10,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{\n-    AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingMode, Block,\n-    BlockCheckMode, Expr, ExprKind, GenericArg, Generics, Item, ItemKind, Mutability, Param, Pat,\n-    PatKind, Path, PathSegment, QSelf, Ty, TyKind,\n+    AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingAnnotation, Block,\n+    BlockCheckMode, Expr, ExprKind, GenericArg, Generics, Item, ItemKind, Param, Pat, PatKind,\n+    Path, PathSegment, QSelf, Ty, TyKind,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -37,7 +37,7 @@ const TURBOFISH_SUGGESTION_STR: &str =\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None),\n+        kind: PatKind::Ident(BindingAnnotation::NONE, ident, None),\n         span: ident.span,\n         tokens: None,\n     });\n@@ -2961,7 +2961,7 @@ impl<'a> Parser<'a> {\n                                 }\n                                 _ => {}\n                             },\n-                            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+                            PatKind::Ident(BindingAnnotation::NONE, ident, None) => {\n                                 match &first_pat.kind {\n                                     PatKind::Ident(_, old_ident, _) => {\n                                         let path = PatKind::Path("}, {"sha": "dbdd85ea8e87d5feb428d5e5807b3d5962c0e669", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::{self as ast, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n-use rustc_ast::{BindingMode, Block, FnDecl, FnSig, Param, SelfKind};\n+use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, VariantData};\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n@@ -2322,7 +2322,7 @@ impl<'a> Parser<'a> {\n                 match ty {\n                     Ok(ty) => {\n                         let ident = Ident::new(kw::Empty, this.prev_token.span);\n-                        let bm = BindingMode::ByValue(Mutability::Not);\n+                        let bm = BindingAnnotation::NONE;\n                         let pat = this.mk_pat_ident(ty.span, bm, ident);\n                         (pat, ty)\n                     }"}, {"sha": "88bd57d37cb657cd1548b66ea24157b6482784ac", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -4,8 +4,8 @@ use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::{\n-    self as ast, AttrVec, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat, PatField, PatKind,\n-    Path, QSelf, RangeEnd, RangeSyntax,\n+    self as ast, AttrVec, BindingAnnotation, ByRef, Expr, ExprKind, MacCall, Mutability, Pat,\n+    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -353,7 +353,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Ref) {\n             // Parse ref ident @ pat / ref mut ident @ pat\n             let mutbl = self.parse_mutability();\n-            self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n+            self.parse_pat_ident(BindingAnnotation(ByRef::Yes, mutbl))?\n         } else if self.eat_keyword(kw::Box) {\n             self.parse_pat_box()?\n         } else if self.check_inline_const(0) {\n@@ -369,7 +369,7 @@ impl<'a> Parser<'a> {\n             // Parse `ident @ pat`\n             // This can give false positives and parse nullary enums,\n             // they are dealt with later in resolve.\n-            self.parse_pat_ident(BindingMode::ByValue(Mutability::Not))?\n+            self.parse_pat_ident(BindingAnnotation::NONE)?\n         } else if self.is_start_of_pat_with_path() {\n             // Parse pattern starting with a path\n             let (qself, path) = if self.eat_lt() {\n@@ -578,7 +578,8 @@ impl<'a> Parser<'a> {\n         let mut pat = self.parse_pat_no_top_alt(Some(\"identifier\"))?;\n \n         // If we don't have `mut $ident (@ pat)?`, error.\n-        if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind {\n+        if let PatKind::Ident(BindingAnnotation(ByRef::No, m @ Mutability::Not), ..) = &mut pat.kind\n+        {\n             // Don't recurse into the subpattern.\n             // `mut` on the outer binding doesn't affect the inner bindings.\n             *m = Mutability::Mut;\n@@ -604,7 +605,7 @@ impl<'a> Parser<'a> {\n             )\n             .emit();\n \n-        self.parse_pat_ident(BindingMode::ByRef(Mutability::Mut))\n+        self.parse_pat_ident(BindingAnnotation::REF_MUT)\n     }\n \n     /// Turn all by-value immutable bindings in a pattern into mutable bindings.\n@@ -613,7 +614,8 @@ impl<'a> Parser<'a> {\n         struct AddMut(bool);\n         impl MutVisitor for AddMut {\n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-                if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind\n+                if let PatKind::Ident(BindingAnnotation(ByRef::No, m @ Mutability::Not), ..) =\n+                    &mut pat.kind\n                 {\n                     self.0 = true;\n                     *m = Mutability::Mut;\n@@ -838,7 +840,7 @@ impl<'a> Parser<'a> {\n     /// Parses `ident` or `ident @ pat`.\n     /// Used by the copy foo and ref foo patterns to give a good\n     /// error message when parsing mistakes like `ref foo(a, b)`.\n-    fn parse_pat_ident(&mut self, binding_mode: BindingMode) -> PResult<'a, PatKind> {\n+    fn parse_pat_ident(&mut self, binding_annotation: BindingAnnotation) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n@@ -856,7 +858,7 @@ impl<'a> Parser<'a> {\n                 .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n         }\n \n-        Ok(PatKind::Ident(binding_mode, ident, sub))\n+        Ok(PatKind::Ident(binding_annotation, ident, sub))\n     }\n \n     /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n@@ -936,11 +938,7 @@ impl<'a> Parser<'a> {\n                 None\n             };\n \n-            Ok(PatKind::Ident(\n-                BindingMode::ByValue(Mutability::Not),\n-                Ident::new(kw::Box, box_span),\n-                sub,\n-            ))\n+            Ok(PatKind::Ident(BindingAnnotation::NONE, Ident::new(kw::Box, box_span), sub))\n         } else {\n             let pat = self.parse_pat_with_range_pat(false, None)?;\n             self.sess.gated_spans.gate(sym::box_patterns, box_span.to(self.prev_token.span));\n@@ -1117,14 +1115,12 @@ impl<'a> Parser<'a> {\n             let fieldname = self.parse_field_name()?;\n             hi = self.prev_token.span;\n \n-            let bind_type = match (is_ref, is_mut) {\n-                (true, true) => BindingMode::ByRef(Mutability::Mut),\n-                (true, false) => BindingMode::ByRef(Mutability::Not),\n-                (false, true) => BindingMode::ByValue(Mutability::Mut),\n-                (false, false) => BindingMode::ByValue(Mutability::Not),\n+            let mutability = match is_mut {\n+                false => Mutability::Not,\n+                true => Mutability::Mut,\n             };\n-\n-            let fieldpat = self.mk_pat_ident(boxed_span.to(hi), bind_type, fieldname);\n+            let ann = BindingAnnotation(ByRef::from(is_ref), mutability);\n+            let fieldpat = self.mk_pat_ident(boxed_span.to(hi), ann, fieldname);\n             let subpat =\n                 if is_box { self.mk_pat(lo.to(hi), PatKind::Box(fieldpat)) } else { fieldpat };\n             (subpat, fieldname, true)\n@@ -1141,8 +1137,8 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub(super) fn mk_pat_ident(&self, span: Span, bm: BindingMode, ident: Ident) -> P<Pat> {\n-        self.mk_pat(span, PatKind::Ident(bm, ident, None))\n+    pub(super) fn mk_pat_ident(&self, span: Span, ann: BindingAnnotation, ident: Ident) -> P<Pat> {\n+        self.mk_pat(span, PatKind::Ident(ann, ident, None))\n     }\n \n     pub(super) fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {"}, {"sha": "607973446fc1e32c3818f682c746013b5e0e250a", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -76,7 +76,7 @@ fn check_no_patterns(tcx: TyCtxt<'_>, params: &[hir::Param<'_>]) {\n     for param in params {\n         match param.pat.kind {\n             hir::PatKind::Wild\n-            | hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, _, None) => {}\n+            | hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, _, None) => {}\n             _ => {\n                 tcx.sess\n                     .struct_span_err("}, {"sha": "b37feb15890ba22ff080b55f34c231a67318536f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -20,7 +20,7 @@ use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::{PrimTy, TraitCandidate};\n+use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n use rustc_middle::middle::resolve_lifetime::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n@@ -50,7 +50,7 @@ use diagnostics::{\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n-    binding_mode: BindingMode,\n+    annotation: BindingAnnotation,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -2865,10 +2865,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         pat.walk(&mut |pat| {\n             match pat.kind {\n-                PatKind::Ident(binding_mode, ident, ref sub_pat)\n+                PatKind::Ident(annotation, ident, ref sub_pat)\n                     if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n                 {\n-                    binding_map.insert(ident, BindingInfo { span: ident.span, binding_mode });\n+                    binding_map.insert(ident, BindingInfo { span: ident.span, annotation });\n                 }\n                 PatKind::Or(ref ps) => {\n                     // Check the consistency of this or-pattern and\n@@ -2925,7 +2925,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         binding_error.target.insert(pat_outer.span);\n                     }\n                     Some(binding_outer) => {\n-                        if binding_outer.binding_mode != binding_inner.binding_mode {\n+                        if binding_outer.annotation != binding_inner.annotation {\n                             // The binding modes in the outer and inner bindings differ.\n                             inconsistent_vars\n                                 .entry(name)\n@@ -3146,14 +3146,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn try_resolve_as_non_binding(\n         &mut self,\n         pat_src: PatternSource,\n-        bm: BindingMode,\n+        ann: BindingAnnotation,\n         ident: Ident,\n         has_sub: bool,\n     ) -> Option<Res> {\n         // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n         // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n-        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n+        let is_syntactic_ambiguity = !has_sub && ann == BindingAnnotation::NONE;\n \n         let ls_binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS)?;\n         let (res, binding) = match ls_binding {"}, {"sha": "89bca39512f52554250cab4ad0894128cae84752", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -866,23 +866,12 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n             hir::PatKind::TupleStruct(ref path, ..) | hir::PatKind::Path(ref path) => {\n                 self.collected_paths.push((p.hir_id, path));\n             }\n-            hir::PatKind::Binding(bm, _, ident, _) => {\n+            hir::PatKind::Binding(hir::BindingAnnotation(_, mutbl), _, ident, _) => {\n                 debug!(\n                     \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n                     ident, p.span, ident.span\n                 );\n-                let immut = match bm {\n-                    // Even if the ref is mut, you can't change the ref, only\n-                    // the data pointed at, so showing the initialising expression\n-                    // is still worthwhile.\n-                    hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Ref => {\n-                        hir::Mutability::Not\n-                    }\n-                    hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut => {\n-                        hir::Mutability::Mut\n-                    }\n-                };\n-                self.collected_idents.push((p.hir_id, ident, immut));\n+                self.collected_idents.push((p.hir_id, ident, mutbl));\n             }\n             _ => {}\n         }"}, {"sha": "b012073f7719d2d4270ea7363483b9c393b75fcb", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -774,7 +774,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Get the local name of this closure. This can be inaccurate because\n             // of the possibility of reassignment, but this should be good enough.\n             match &kind {\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) => {\n+                hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, ident, None) => {\n                     Some(ident.name)\n                 }\n                 _ => {"}, {"sha": "9096fc442d49398e882f60ed458b4a99e644f65d", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         // Determine the binding mode...\n         let bm = match ba {\n-            hir::BindingAnnotation::Unannotated => def_bm,\n+            hir::BindingAnnotation::NONE => def_bm,\n             _ => BindingMode::convert(ba),\n         };\n         // ...and store it in a side table:\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ba: hir::BindingAnnotation,\n     ) {\n         match (expected.kind(), actual.kind(), ba) {\n-            (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::Unannotated)\n+            (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::NONE)\n                 if self.can_eq(self.param_env, *inner_ty, actual).is_ok() =>\n             {\n                 err.span_suggestion_verbose(\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::Ref)\n+            (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::REF)\n                 if self.can_eq(self.param_env, expected, *inner_ty).is_ok() =>\n             {\n                 err.span_suggestion_verbose("}, {"sha": "b779713482e14872e63107276552672c5e06b269", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -587,8 +587,7 @@ fn resolve_local<'tcx>(\n         // & expression, and its lifetime would be extended to the end of the block (due\n         // to a different rule, not the below code).\n         match pat.kind {\n-            PatKind::Binding(hir::BindingAnnotation::Ref, ..)\n-            | PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n+            PatKind::Binding(hir::BindingAnnotation(hir::ByRef::Yes, _), ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n@@ -607,10 +606,7 @@ fn resolve_local<'tcx>(\n             PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n \n             PatKind::Ref(_, _)\n-            | PatKind::Binding(\n-                hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                ..,\n-            )\n+            | PatKind::Binding(hir::BindingAnnotation(hir::ByRef::No, _), ..)\n             | PatKind::Wild\n             | PatKind::Path(_)\n             | PatKind::Lit(_)"}, {"sha": "ae509aab1525f68d2598e5d903ec3f085789166f", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -503,7 +503,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n+        if let PatKind::Binding(BindingAnnotation::REF, id, name, _) = pat.kind {\n             if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n                 // This binding id has been seen before. Add this pattern to the list of changes.\n                 if let Some(prev_pat) = opt_prev_pat {"}, {"sha": "b9ed4af02190b07c4eb7c5a409ab890be52e907b", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -128,7 +128,7 @@ fn look_in_block<'tcx, 'hir>(cx: &LateContext<'tcx>, kind: &'tcx ExprKind<'hir>)\n         if let Some(Node::Pat(res_pat)) = cx.tcx.hir().find(expr_res);\n \n         // Find id of the local we found in the block\n-        if let PatKind::Binding(BindingAnnotation::Unannotated, local_hir_id, _ident, None) = local.pat.kind;\n+        if let PatKind::Binding(BindingAnnotation::NONE, local_hir_id, _ident, None) = local.pat.kind;\n \n         // If those two are the same hir id\n         if res_pat.hir_id == local_hir_id;"}, {"sha": "0dd7f5bf000d20d69192bf6dfb5251380366251d", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -95,12 +95,14 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n     let mut removed_pat: FxHashSet<hir::HirId> = FxHashSet::default();\n     let mut slices: FxIndexMap<hir::HirId, SliceLintInformation> = FxIndexMap::default();\n     pat.walk_always(|pat| {\n-        if let hir::PatKind::Binding(binding, value_hir_id, ident, sub_pat) = pat.kind {\n-            // We'll just ignore mut and ref mut for simplicity sake right now\n-            if let hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut = binding {\n-                return;\n-            }\n-\n+        // We'll just ignore mut and ref mut for simplicity sake right now\n+        if let hir::PatKind::Binding(\n+            hir::BindingAnnotation(by_ref, hir::Mutability::Not),\n+            value_hir_id,\n+            ident,\n+            sub_pat,\n+        ) = pat.kind\n+        {\n             // This block catches bindings with sub patterns. It would be hard to build a correct suggestion\n             // for them and it's likely that the user knows what they are doing in such a case.\n             if removed_pat.contains(&value_hir_id) {\n@@ -116,7 +118,7 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n             if let ty::Slice(inner_ty) | ty::Array(inner_ty, _) = bound_ty.peel_refs().kind() {\n                 // The values need to use the `ref` keyword if they can't be copied.\n                 // This will need to be adjusted if the lint want to support mutable access in the future\n-                let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n+                let src_is_ref = bound_ty.is_ref() && by_ref != hir::ByRef::Yes;\n                 let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n \n                 let slice_info = slices"}, {"sha": "10fc0f4018efdd31c990809aa7a0fca44925fa40", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::{path_to_local_id, visitors::is_local_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::BindingAnnotation;\n+use rustc_hir::{BindingAnnotation, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -98,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     };\n \n                     let mutability = match mode {\n-                        BindingAnnotation::RefMut | BindingAnnotation::Mutable => \"<mut> \",\n+                        BindingAnnotation(_, Mutability::Mut) => \"<mut> \",\n                         _ => \"\",\n                     };\n "}, {"sha": "09b2376d5c04a6d68ad26d1d3abaaa8002f7d4db", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_find.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -106,7 +106,7 @@ fn get_binding(pat: &Pat<'_>) -> Option<HirId> {\n             hir_id = None;\n             return;\n         }\n-        if let BindingAnnotation::Unannotated = annotation {\n+        if let BindingAnnotation::NONE = annotation {\n             hir_id = Some(id);\n         }\n     });"}, {"sha": "fce2d54639cbf22af7ae546a0153ec48793b7978", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -44,7 +44,7 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n     if_chain! {\n         if let Some(hir_id) = path_to_local(bound);\n         if let Node::Pat(pat) = cx.tcx.hir().get(hir_id);\n-        if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n+        if let PatKind::Binding(BindingAnnotation::MUT, ..) = pat.kind;\n         then {\n             return Some(hir_id);\n         }"}, {"sha": "aeefe6e33fbe9a9405175f3dd1ba6a3af7ea3f53", "filename": "src/tools/clippy/clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -7,7 +7,7 @@ use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Node, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n use std::iter::Iterator;\n@@ -65,7 +65,7 @@ pub(super) fn check<'tcx>(\n                             if_chain! {\n                                 if let Node::Pat(pat) = node;\n                                 if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                                if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                if !matches!(bind_ann, BindingAnnotation(_, Mutability::Mut));\n                                 let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n                                 if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n                                 if let Some(init) = parent_let_expr.init;"}, {"sha": "b0198e856d5b6ad3b4e107fc792821cb6eb76ef4", "filename": "src/tools/clippy/clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -165,7 +165,7 @@ fn check<'tcx>(\n                 }\n \n                 // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n                     \"mut \"\n                 } else {\n                     \"\""}, {"sha": "91d17f481e2df1cd7e369e1eb3dee2e9659dea0f", "filename": "src/tools/clippy/clippy_lints/src/matches/match_as_ref.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -2,26 +2,25 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_lang_ctor, peel_blocks};\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, LangItem, PatKind, QPath};\n+use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, LangItem, Mutability, PatKind, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n \n use super::MATCH_AS_REF;\n \n pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+        let arm_ref_mut = if is_none_arm(cx, &arms[0]) {\n             is_ref_some_arm(cx, &arms[1])\n         } else if is_none_arm(cx, &arms[1]) {\n             is_ref_some_arm(cx, &arms[0])\n         } else {\n             None\n         };\n-        if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref {\n-                \"as_ref\"\n-            } else {\n-                \"as_mut\"\n+        if let Some(rb) = arm_ref_mut {\n+            let suggestion = match rb {\n+                Mutability::Not => \"as_ref\",\n+                Mutability::Mut => \"as_mut\",\n             };\n \n             let output_ty = cx.typeck_results().expr_ty(expr);\n@@ -66,19 +65,18 @@ fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<Mutability> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n         if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n-        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., ident, _) = first_pat.kind;\n         if let ExprKind::Call(e, [arg]) = peel_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if is_lang_ctor(cx, some_path, LangItem::OptionSome);\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = arg.kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n-            return Some(rb)\n+            return Some(mutabl)\n         }\n     }\n     None"}, {"sha": "634eef82e532ae50304b9f1dd76316ee0acc6748", "filename": "src/tools/clippy/clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -8,7 +8,7 @@ use clippy_utils::{\n };\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Guard, Node, Pat, PatKind, Path, QPath};\n+use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, FnRetTy, Guard, Node, Pat, PatKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_span::sym;\n use rustc_typeck::hir_ty_to_ty;\n@@ -189,8 +189,7 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n                 },\n             )),\n         ) => {\n-            return !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n-                && pat_ident.name == first_seg.ident.name;\n+            return !matches!(annot, BindingAnnotation(ByRef::Yes, _)) && pat_ident.name == first_seg.ident.name;\n         },\n         // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n         (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {"}, {"sha": "95478af45b4bf3fa687149fa8f76d5e5587306b4", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -175,7 +175,7 @@ fn collect_pat_paths<'a>(acc: &mut Vec<Ty<'a>>, cx: &LateContext<'a>, pat: &Pat<\n             let p_ty = cx.typeck_results().pat_ty(p);\n             collect_pat_paths(acc, cx, p, p_ty);\n         }),\n-        PatKind::TupleStruct(..) | PatKind::Binding(BindingAnnotation::Unannotated, .., None) | PatKind::Path(_) => {\n+        PatKind::TupleStruct(..) | PatKind::Binding(BindingAnnotation::NONE, .., None) | PatKind::Path(_) => {\n             acc.push(ty);\n         },\n         _ => {},"}, {"sha": "f5bead387d7bd170b17aec80361b8bb04ffc8560", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_copy;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Expr, ExprKind, MatchSource, Node, PatKind, QPath};\n+use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, MatchSource, Node, PatKind, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, adjustment::Adjust};\n use rustc_span::symbol::{sym, Symbol};\n@@ -101,12 +101,7 @@ pub(super) fn check(\n                 _ => false,\n             },\n             // local binding capturing a reference\n-            Some(Node::Local(l))\n-                if matches!(\n-                    l.pat.kind,\n-                    PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..)\n-                ) =>\n-            {\n+            Some(Node::Local(l)) if matches!(l.pat.kind, PatKind::Binding(BindingAnnotation(ByRef::Yes, _), ..)) => {\n                 return;\n             },\n             _ => false,"}, {"sha": "beb772100affcb1e5f1351c413c0a656b0baeae7", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_skip_next.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -24,7 +24,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n                     if let Some(id) = path_to_local(recv);\n                     if let Node::Pat(pat) = cx.tcx.hir().get(id);\n                     if let PatKind::Binding(ann, _, _, _)  = pat.kind;\n-                    if ann != BindingAnnotation::Mutable;\n+                    if ann != BindingAnnotation::MUT;\n                     then {\n                         application = Applicability::Unspecified;\n                         diag.span_help("}, {"sha": "e8442091fd3067fd3717c397856770c6055d17de", "filename": "src/tools/clippy/clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -33,13 +33,13 @@ pub(super) fn check<'tcx>(\n             let closure_expr = peel_blocks(&closure_body.value);\n             match closure_body.params[0].pat.kind {\n                 hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n-                    hir::BindingAnnotation::Unannotated, .., name, None\n+                    hir::BindingAnnotation::NONE, .., name, None\n                 ) = inner.kind {\n                     if ident_eq(name, closure_expr) {\n                         lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n                     }\n                 },\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n+                hir::PatKind::Binding(hir::BindingAnnotation::NONE, .., name, None) => {\n                     match closure_expr.kind {\n                         hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n                             if ident_eq(name, inner) {"}, {"sha": "9ca4d65550d3e1d594726005ecf99fd3c84d9a26", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -130,7 +130,7 @@ fn check_manual_split_once_indirect(\n     let ctxt = expr.span.ctxt();\n     let mut parents = cx.tcx.hir().parent_iter(expr.hir_id);\n     if let (_, Node::Local(local)) = parents.next()?\n-        && let PatKind::Binding(BindingAnnotation::Mutable, iter_binding_id, iter_ident, None) = local.pat.kind\n+        && let PatKind::Binding(BindingAnnotation::MUT, iter_binding_id, iter_ident, None) = local.pat.kind\n         && let (iter_stmt_id, Node::Stmt(_)) = parents.next()?\n         && let (_, Node::Block(enclosing_block)) = parents.next()?\n \n@@ -212,11 +212,10 @@ fn indirect_usage<'tcx>(\n     ctxt: SyntaxContext,\n ) -> Option<IndirectUsage<'tcx>> {\n     if let StmtKind::Local(Local {\n-        pat:\n-            Pat {\n-                kind: PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None),\n-                ..\n-            },\n+        pat: Pat {\n+            kind: PatKind::Binding(BindingAnnotation::NONE, _, ident, None),\n+            ..\n+        },\n         init: Some(init_expr),\n         hir_id: local_hir_id,\n         .."}, {"sha": "ea245edd77040688400d3810e3e10b668fcac282", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -5,8 +5,8 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n-    StmtKind, TyKind,\n+    self as hir, def, BinOpKind, BindingAnnotation, Body, ByRef, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind,\n+    Stmt, StmtKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -146,7 +146,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             return;\n         }\n         for arg in iter_input_pats(decl, body) {\n-            if let PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..) = arg.pat.kind {\n+            if let PatKind::Binding(BindingAnnotation(ByRef::Yes, _), ..) = arg.pat.kind {\n                 span_lint(\n                     cx,\n                     TOPLEVEL_REF_ARG,\n@@ -162,9 +162,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, stmt.span);\n             if let StmtKind::Local(local) = stmt.kind;\n-            if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n                 // use the macro callsite when the init span (but not the whole local span)\n                 // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n@@ -173,7 +172,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 } else {\n                     Sugg::hir(cx, init, \"..\")\n                 };\n-                let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n+                let (mutopt, initref) = if mutabl == Mutability::Mut {\n                     (\"mut \", sugg_init.mut_addr())\n                 } else {\n                     (\"\", sugg_init.addr())"}, {"sha": "d7bb0616acb0ba4aba14a2af50eb13263eeb70a1", "filename": "src/tools/clippy/clippy_lints/src/misc_early/redundant_pattern.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1,18 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_ast::ast::{BindingMode, Mutability, Pat, PatKind};\n+use rustc_ast::ast::{Pat, PatKind};\n use rustc_errors::Applicability;\n use rustc_lint::EarlyContext;\n \n use super::REDUNDANT_PATTERN;\n \n pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::Ident(left, ident, Some(ref right)) = pat.kind {\n-        let left_binding = match left {\n-            BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n-            BindingMode::ByRef(Mutability::Not) => \"ref \",\n-            BindingMode::ByValue(..) => \"\",\n-        };\n-\n+    if let PatKind::Ident(ann, ident, Some(ref right)) = pat.kind {\n         if let PatKind::Wild = right.kind {\n             span_lint_and_sugg(\n                 cx,\n@@ -23,7 +17,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n                     ident.name, ident.name,\n                 ),\n                 \"try\",\n-                format!(\"{}{}\", left_binding, ident.name),\n+                format!(\"{}{}\", ann.prefix_str(), ident.name),\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "f2ffac85bf4023cc25368595e239b84c7383f7e9", "filename": "src/tools/clippy/clippy_lints/src/needless_arbitrary_self_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use if_chain::if_chain;\n-use rustc_ast::ast::{BindingMode, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n+use rustc_ast::ast::{BindingAnnotation, ByRef, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -120,14 +120,14 @@ impl EarlyLintPass for NeedlessArbitrarySelfType {\n \n         match &p.ty.kind {\n             TyKind::Path(None, path) => {\n-                if let PatKind::Ident(BindingMode::ByValue(mutbl), _, _) = p.pat.kind {\n+                if let PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), _, _) = p.pat.kind {\n                     check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Value, mutbl);\n                 }\n             },\n             TyKind::Rptr(lifetime, mut_ty) => {\n                 if_chain! {\n                 if let TyKind::Path(None, path) = &mut_ty.ty.kind;\n-                if let PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, _) = p.pat.kind;\n+                if let PatKind::Ident(BindingAnnotation::NONE, _, _) = p.pat.kind;\n                     then {\n                         check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Ref(*lifetime), mut_ty.mutbl);\n                     }"}, {"sha": "b8855e5adbff4c11c6b17a7176c0857372e4dfda", "filename": "src/tools/clippy/clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n             if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n \n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            if let PatKind::Binding(BindingAnnotation::Ref, .., spanned_name, _) = sub_pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::REF, .., spanned_name, _) = sub_pat.kind;\n             let parent_id = cx.tcx.hir().get_parent_node(pat.hir_id);\n             if let Some(parent_node) = cx.tcx.hir().find(parent_id);\n             then {"}, {"sha": "de99f1d7078e97eb40fd1030376f9c179c26bf75", "filename": "src/tools/clippy/clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -373,7 +373,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessLateInit {\n             if let Local {\n                 init: None,\n                 pat: &Pat {\n-                    kind: PatKind::Binding(BindingAnnotation::Unannotated, binding_id, _, None),\n+                    kind: PatKind::Binding(BindingAnnotation::NONE, binding_id, _, None),\n                     ..\n                 },\n                 source: LocalSource::Normal,"}, {"sha": "6d17c7a7346f3994fc99e74cd8d6d002dc3f16bf", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -8,7 +8,9 @@ use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n+use rustc_hir::{\n+    BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Mutability, Node, PatKind, QPath, TyKind,\n+};\n use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -188,13 +190,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n \n-                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.kind;\n+                if let PatKind::Binding(BindingAnnotation(_, Mutability::Not), canonical_id, ..) = arg.pat.kind;\n                 if !moved_vars.contains(&canonical_id);\n                 then {\n-                    if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n-                        continue;\n-                    }\n-\n                     // Dereference suggestion\n                     let sugg = |diag: &mut Diagnostic| {\n                         if let ty::Adt(def, ..) = ty.kind() {"}, {"sha": "0315678bf97a96c1ef6fcd58e59df3c7b4b5342d", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -130,15 +130,15 @@ fn try_get_option_occurence<'tcx>(\n             .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n             .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n         then {\n-            let capture_mut = if bind_annotation == BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let capture_mut = if bind_annotation == BindingAnnotation::MUT { \"mut \" } else { \"\" };\n             let some_body = peel_blocks(if_then);\n             let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n-                _ => (bind_annotation == BindingAnnotation::Ref, bind_annotation == BindingAnnotation::RefMut),\n+                _ => (bind_annotation == BindingAnnotation::REF, bind_annotation == BindingAnnotation::REF_MUT),\n             };\n \n             // Check if captures the closure will need conflict with borrows made in the scrutinee."}, {"sha": "0960b050c240e37553be6b96824f26b2d09983fd", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -221,7 +221,7 @@ impl<'tcx> PassByRefOrValue {\n                     // if function has a body and parameter is annotated with mut, ignore\n                     if let Some(param) = fn_body.and_then(|body| body.params.get(index)) {\n                         match param.pat.kind {\n-                            PatKind::Binding(BindingAnnotation::Unannotated, _, _, _) => {},\n+                            PatKind::Binding(BindingAnnotation::NONE, _, _, _) => {},\n                             _ => continue,\n                         }\n                     }"}, {"sha": "0028e0bc6c517e79e13f3b57452972f013da44c0", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -571,7 +571,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                 Some((Node::Stmt(_), _)) => (),\n                 Some((Node::Local(l), _)) => {\n                     // Only trace simple bindings. e.g `let x = y;`\n-                    if let PatKind::Binding(BindingAnnotation::Unannotated, id, _, None) = l.pat.kind {\n+                    if let PatKind::Binding(BindingAnnotation::NONE, id, _, None) = l.pat.kind {\n                         self.bindings.insert(id, args_idx);\n                     } else {\n                         set_skip_flag();\n@@ -647,7 +647,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n             .filter_map(|(i, arg)| {\n                 let param = &body.params[arg.idx];\n                 match param.pat.kind {\n-                    PatKind::Binding(BindingAnnotation::Unannotated, id, _, None)\n+                    PatKind::Binding(BindingAnnotation::NONE, id, _, None)\n                         if !is_lint_allowed(cx, PTR_ARG, param.hir_id) =>\n                     {\n                         Some((id, i))"}, {"sha": "f4f1fd336df7cc81c4a60786da7e95ccb5ed85bb", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -9,7 +9,7 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n-use rustc_hir::{BindingAnnotation, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n+use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -123,7 +123,7 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else }) = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n         if let PatKind::TupleStruct(ref path1, [field], None) = let_pat.kind;\n-        if let PatKind::Binding(annot, bind_id, ident, None) = field.kind;\n+        if let PatKind::Binding(BindingAnnotation(by_ref, _), bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n         let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n@@ -132,12 +132,11 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n-            let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n             let requires_semi = matches!(get_parent_node(cx.tcx, expr.hir_id), Some(Node::Stmt(_)));\n             let sugg = format!(\n                 \"{}{}?{}\",\n                 receiver_str,\n-                if by_ref { \".as_ref()\" } else { \"\" },\n+                if by_ref == ByRef::Yes { \".as_ref()\" } else { \"\" },\n                 if requires_semi { \";\" } else { \"\" }\n             );\n             span_lint_and_sugg("}, {"sha": "c07aa00a12789af66d57b26093c4839347c80d80", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n             if let StmtKind::Local(local) = stmt.kind;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, local_id, _, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::MUT, local_id, _, None) = local.pat.kind;\n             if let Some(init) = local.init;\n             if let Some(len_arg) = Self::is_vec_with_capacity(cx, init);\n "}, {"sha": "fb73c386640b49babd971298c21445d4286f9225", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -137,12 +137,12 @@ fn insert_necessary_parens(pat: &mut P<Pat>) {\n     struct Visitor;\n     impl MutVisitor for Visitor {\n         fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-            use ast::{BindingMode::*, Mutability::*};\n+            use ast::BindingAnnotation;\n             noop_visit_pat(pat, self);\n             let target = match &mut pat.kind {\n                 // `i @ a | b`, `box a | b`, and `& mut? a | b`.\n                 Ident(.., Some(p)) | Box(p) | Ref(p, _) if matches!(&p.kind, Or(ps) if ps.len() > 1) => p,\n-                Ref(p, Not) if matches!(p.kind, Ident(ByValue(Mut), ..)) => p, // `&(mut x)`\n+                Ref(p, Mutability::Not) if matches!(p.kind, Ident(BindingAnnotation::MUT, ..)) => p, // `&(mut x)`\n                 _ => return,\n             };\n             target.kind = Paren(P(take_pat(target)));"}, {"sha": "1489c96d9e9b03bcb61a8bb8cd84fb7a0977be97", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -6,7 +6,9 @@ use rustc_ast::ast::{LitFloatType, LitKind};\n use rustc_ast::LitIntType;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::{ArrayLen, Closure, ExprKind, FnRetTy, HirId, Lit, PatKind, QPath, StmtKind, TyKind};\n+use rustc_hir::{\n+    ArrayLen, BindingAnnotation, Closure, ExprKind, FnRetTy, HirId, Lit, PatKind, QPath, StmtKind, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::{Ident, Symbol};\n@@ -610,10 +612,16 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n         match pat.value.kind {\n             PatKind::Wild => kind!(\"Wild\"),\n-            PatKind::Binding(anno, .., name, sub) => {\n+            PatKind::Binding(ann, _, name, sub) => {\n                 bind!(self, name);\n                 opt_bind!(self, sub);\n-                kind!(\"Binding(BindingAnnotation::{anno:?}, _, {name}, {sub})\");\n+                let ann = match ann {\n+                    BindingAnnotation::NONE => \"NONE\",\n+                    BindingAnnotation::REF => \"REF\",\n+                    BindingAnnotation::MUT => \"MUT\",\n+                    BindingAnnotation::REF_MUT => \"REF_MUT\",\n+                };\n+                kind!(\"Binding(BindingAnnotation::{ann}, _, {name}, {sub})\");\n                 self.ident(name);\n                 sub.if_some(|p| self.pat(p));\n             },"}, {"sha": "8425837fd73366277219447d83e196b11c71ffa3", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -157,7 +157,7 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         if let Some(init_expr) = local.init\n-            && let PatKind::Binding(BindingAnnotation::Mutable, id, name, None) = local.pat.kind\n+            && let PatKind::Binding(BindingAnnotation::MUT, id, name, None) = local.pat.kind\n             && !in_external_macro(cx.sess(), local.span)\n             && let Some(init) = get_vec_init_kind(cx, init_expr)\n             && !matches!(init, VecInitKind::WithExprCapacity(_))"}, {"sha": "57448f716d4941e023d2a7112c7e6f919ebcac34", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -6,9 +6,9 @@ use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n-    ArrayLen, BinOpKind, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard,\n-    HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath,\n-    Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    ArrayLen, BinOpKind, BindingAnnotation, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n+    GenericArgs, Guard, HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n+    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n@@ -822,8 +822,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn hash_pat(&mut self, pat: &Pat<'_>) {\n         std::mem::discriminant(&pat.kind).hash(&mut self.s);\n         match pat.kind {\n-            PatKind::Binding(ann, _, _, pat) => {\n-                std::mem::discriminant(&ann).hash(&mut self.s);\n+            PatKind::Binding(BindingAnnotation(by_ref, mutability), _, _, pat) => {\n+                std::mem::discriminant(&by_ref).hash(&mut self.s);\n+                std::mem::discriminant(&mutability).hash(&mut self.s);\n                 if let Some(pat) = pat {\n                     self.hash_pat(pat);\n                 }"}, {"sha": "b27439cbec278bec5bafb3fd46e47b7d0deb0422", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -192,7 +192,7 @@ pub fn find_binding_init<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<\n     let hir = cx.tcx.hir();\n     if_chain! {\n         if let Some(Node::Pat(pat)) = hir.find(hir_id);\n-        if matches!(pat.kind, PatKind::Binding(BindingAnnotation::Unannotated, ..));\n+        if matches!(pat.kind, PatKind::Binding(BindingAnnotation::NONE, ..));\n         let parent = hir.get_parent_node(hir_id);\n         if let Some(Node::Local(local)) = hir.find(parent);\n         then {"}, {"sha": "597318a556b850fc5b356214849b6c23ca734b13", "filename": "src/tools/clippy/tests/ui/author.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor.stdout?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -6,7 +6,7 @@ if_chain! {\n     if match_qpath(qpath, &[\"char\"]);\n     if let ExprKind::Lit(ref lit) = expr.kind;\n     if let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n     if name.as_str() == \"x\";\n     then {\n         // report your lint here"}, {"sha": "a529981e2e68372c0cd034cdbc187cc0c2da900a", "filename": "src/tools/clippy/tests/ui/author/blocks.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fblocks.stdout?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -5,13 +5,13 @@ if_chain! {\n     if let Some(init) = local.init;\n     if let ExprKind::Lit(ref lit) = init.kind;\n     if let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n     if name.as_str() == \"x\";\n     if let StmtKind::Local(local1) = block.stmts[1].kind;\n     if let Some(init1) = local1.init;\n     if let ExprKind::Lit(ref lit1) = init1.kind;\n     if let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local1.pat.kind;\n     if name1.as_str() == \"_t\";\n     if let StmtKind::Semi(e) = block.stmts[2].kind;\n     if let ExprKind::Unary(UnOp::Neg, inner) = e.kind;\n@@ -31,7 +31,7 @@ if_chain! {\n     if let ExprKind::Path(ref qpath) = func.kind;\n     if match_qpath(qpath, &[\"String\", \"new\"]);\n     if args.is_empty();\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n     if name.as_str() == \"expr\";\n     if let Some(trailing_expr) = block.expr;\n     if let ExprKind::Call(func1, args1) = trailing_expr.kind;"}, {"sha": "ceb53fcd496369c11e90ea971cc02091e8c33780", "filename": "src/tools/clippy/tests/ui/author/loop.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Floop.stdout?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1,6 +1,6 @@\n if_chain! {\n     if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = pat.kind;\n     if name.as_str() == \"y\";\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n@@ -17,7 +17,7 @@ if_chain! {\n     if let Some(init) = local.init;\n     if let ExprKind::Path(ref qpath1) = init.kind;\n     if match_qpath(qpath1, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n     if name1.as_str() == \"z\";\n     if block.expr.is_none();\n     then {"}, {"sha": "2cf69a035b4c7364ff6ee3991c78f50101f067bf", "filename": "src/tools/clippy/tests/ui/author/matches.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fmatches.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fmatches.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fmatches.stdout?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -21,7 +21,7 @@ if_chain! {\n     if let Some(init1) = local1.init;\n     if let ExprKind::Lit(ref lit4) = init1.kind;\n     if let LitKind::Int(3, LitIntType::Unsuffixed) = lit4.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local1.pat.kind;\n     if name.as_str() == \"x\";\n     if let Some(trailing_expr) = block.expr;\n     if let ExprKind::Path(ref qpath) = trailing_expr.kind;\n@@ -30,7 +30,7 @@ if_chain! {\n     if arms[2].guard.is_none();\n     if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n     if name1.as_str() == \"a\";\n     then {\n         // report your lint here"}, {"sha": "e2fe92b28f23e9fc53a256fe1538b188849bccf6", "filename": "src/tools/rustfmt/src/patterns.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c358c67d4d39b1b4dbbcee89e96ec748d771e9e/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs?ref=6c358c67d4d39b1b4dbbcee89e96ec748d771e9e", "patch": "@@ -1,4 +1,6 @@\n-use rustc_ast::ast::{self, BindingMode, Pat, PatField, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::ast::{\n+    self, BindingAnnotation, ByRef, Pat, PatField, PatKind, RangeEnd, RangeSyntax,\n+};\n use rustc_ast::ptr;\n use rustc_span::{BytePos, Span};\n \n@@ -99,10 +101,10 @@ impl Rewrite for Pat {\n                 write_list(&items, &fmt)\n             }\n             PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, shape),\n-            PatKind::Ident(binding_mode, ident, ref sub_pat) => {\n-                let (prefix, mutability) = match binding_mode {\n-                    BindingMode::ByRef(mutability) => (\"ref\", mutability),\n-                    BindingMode::ByValue(mutability) => (\"\", mutability),\n+            PatKind::Ident(BindingAnnotation(by_ref, mutability), ident, ref sub_pat) => {\n+                let prefix = match by_ref {\n+                    ByRef::Yes => \"ref\",\n+                    ByRef::No => \"\",\n                 };\n                 let mut_infix = format_mutability(mutability).trim();\n                 let id_str = rewrite_ident(context, ident);"}]}