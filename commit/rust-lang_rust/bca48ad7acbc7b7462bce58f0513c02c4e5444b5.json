{"sha": "bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTQ4YWQ3YWNiYzdiNzQ2MmJjZTU4ZjA1MTNjMDJjNGU1NDQ0YjU=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-16T00:50:20Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-17T16:01:04Z"}, "message": "Reduce indentation by replacing match arm w/ early return.", "tree": {"sha": "e4367c6e3048ebc2ede8e0a3c2b09046112ee9a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4367c6e3048ebc2ede8e0a3c2b09046112ee9a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "html_url": "https://github.com/rust-lang/rust/commit/bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca48ad7acbc7b7462bce58f0513c02c4e5444b5/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80c2c80d52e2384ee6ce33a7b41c0c47c4f0ffd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c2c80d52e2384ee6ce33a7b41c0c47c4f0ffd1", "html_url": "https://github.com/rust-lang/rust/commit/80c2c80d52e2384ee6ce33a7b41c0c47c4f0ffd1"}], "stats": {"total": 243, "additions": 118, "deletions": 125}, "files": [{"sha": "c23b443645de6c5d758f001a38ce567a89800986", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 118, "deletions": 125, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/bca48ad7acbc7b7462bce58f0513c02c4e5444b5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca48ad7acbc7b7462bce58f0513c02c4e5444b5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "patch": "@@ -2198,45 +2198,46 @@ impl ClashingExternDeclarations {\n             debug!(\"structurally_same_type_impl(cx, a = {:?}, b = {:?})\", a, b);\n             match seen_types.get(a, b) {\n                 // If we've already computed the result, just return the memoized result.\n-                SeenSetResult::Computed(result) => result,\n+                SeenSetResult::Computed(result) => return result,\n                 // We are already in the process of computing structural sameness for this type,\n                 // meaning we've found a cycle. The types are structurally same, then.\n-                SeenSetResult::Computing => true,\n-                // We haven't seen this combination of types at all -- compute their sameness.\n-                SeenSetResult::Unseen => {\n-                    seen_types.mark_computing(a, b);\n-                    let tcx = cx.tcx;\n-                    let result = if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n-                        // All nominally-same types are structurally same, too.\n-                        true\n-                    } else {\n-                        // Do a full, depth-first comparison between the two.\n-                        use rustc_middle::ty::TyKind::*;\n-                        let a_kind = &a.kind;\n-                        let b_kind = &b.kind;\n-\n-                        let compare_layouts = |a, b| -> bool {\n-                            let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n-                            let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n-                            debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n-                            a_layout == b_layout\n-                        };\n+                SeenSetResult::Computing => return true,\n+                // We haven't seen this combination of types at all -- continue on to computing\n+                // their sameness.\n+                SeenSetResult::Unseen => (),\n+            }\n+            seen_types.mark_computing(a, b);\n+            let tcx = cx.tcx;\n+            let result = if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n+                // All nominally-same types are structurally same, too.\n+                true\n+            } else {\n+                // Do a full, depth-first comparison between the two.\n+                use rustc_middle::ty::TyKind::*;\n+                let a_kind = &a.kind;\n+                let b_kind = &b.kind;\n+\n+                let compare_layouts = |a, b| -> bool {\n+                    let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n+                    let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n+                    debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n+                    a_layout == b_layout\n+                };\n \n-                        #[allow(rustc::usage_of_ty_tykind)]\n-                        let is_primitive_or_pointer = |kind: &ty::TyKind<'_>| {\n-                            kind.is_primitive() || matches!(kind, RawPtr(..))\n-                        };\n+                #[allow(rustc::usage_of_ty_tykind)]\n+                let is_primitive_or_pointer =\n+                    |kind: &ty::TyKind<'_>| kind.is_primitive() || matches!(kind, RawPtr(..));\n \n-                        match (a_kind, b_kind) {\n-                            (Adt(a_def, a_substs), Adt(b_def, b_substs)) => {\n-                                let a = a.subst(cx.tcx, a_substs);\n-                                let b = b.subst(cx.tcx, b_substs);\n-                                debug!(\"Comparing {:?} and {:?}\", a, b);\n+                match (a_kind, b_kind) {\n+                    (Adt(a_def, a_substs), Adt(b_def, b_substs)) => {\n+                        let a = a.subst(cx.tcx, a_substs);\n+                        let b = b.subst(cx.tcx, b_substs);\n+                        debug!(\"Comparing {:?} and {:?}\", a, b);\n \n-                                // Grab a flattened representation of all fields.\n-                                let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n-                                let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n-                                compare_layouts(a, b)\n+                        // Grab a flattened representation of all fields.\n+                        let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n+                        let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                        compare_layouts(a, b)\n                             && a_fields.eq_by(\n                                 b_fields,\n                                 |&ty::FieldDef { did: a_did, .. },\n@@ -2250,99 +2251,91 @@ impl ClashingExternDeclarations {\n                                     )\n                                 },\n                             )\n-                            }\n-                            (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n-                                // For arrays, we also check the constness of the type.\n-                                a_const.val == b_const.val\n-                                    && structurally_same_type_impl(\n-                                        seen_types, cx, a_ty, b_ty, ckind,\n-                                    )\n-                            }\n-                            (Slice(a_ty), Slice(b_ty)) => {\n-                                structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n-                            }\n-                            (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n-                                a_tymut.mutbl == b_tymut.mutbl\n-                                    && structurally_same_type_impl(\n-                                        seen_types,\n-                                        cx,\n-                                        &a_tymut.ty,\n-                                        &b_tymut.ty,\n-                                        ckind,\n-                                    )\n-                            }\n-                            (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n-                                // For structural sameness, we don't need the region to be same.\n-                                a_mut == b_mut\n-                                    && structurally_same_type_impl(\n-                                        seen_types, cx, a_ty, b_ty, ckind,\n-                                    )\n-                            }\n-                            (FnDef(..), FnDef(..)) => {\n-                                let a_poly_sig = a.fn_sig(tcx);\n-                                let b_poly_sig = b.fn_sig(tcx);\n-\n-                                // As we don't compare regions, skip_binder is fine.\n-                                let a_sig = a_poly_sig.skip_binder();\n-                                let b_sig = b_poly_sig.skip_binder();\n-\n-                                (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n-                                    == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n-                                    && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                                        structurally_same_type_impl(seen_types, cx, a, b, ckind)\n-                                    })\n-                                    && structurally_same_type_impl(\n-                                        seen_types,\n-                                        cx,\n-                                        a_sig.output(),\n-                                        b_sig.output(),\n-                                        ckind,\n-                                    )\n-                            }\n-                            (Tuple(a_substs), Tuple(b_substs)) => {\n-                                a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n-                                    structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n-                                })\n-                            }\n-                            // For these, it's not quite as easy to define structural-sameness quite so easily.\n-                            // For the purposes of this lint, take the conservative approach and mark them as\n-                            // not structurally same.\n-                            (Dynamic(..), Dynamic(..))\n-                            | (Error(..), Error(..))\n-                            | (Closure(..), Closure(..))\n-                            | (Generator(..), Generator(..))\n-                            | (GeneratorWitness(..), GeneratorWitness(..))\n-                            | (Projection(..), Projection(..))\n-                            | (Opaque(..), Opaque(..)) => false,\n-\n-                            // These definitely should have been caught above.\n-                            (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => {\n-                                unreachable!()\n-                            }\n-\n-                            // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n-                            // non-null field.\n-                            (Adt(..), other_kind) | (other_kind, Adt(..))\n-                                if is_primitive_or_pointer(other_kind) =>\n-                            {\n-                                let (primitive, adt) =\n-                                    if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n-                                if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n-                                    ty == primitive\n-                                } else {\n-                                    compare_layouts(a, b)\n-                                }\n-                            }\n-                            // Otherwise, just compare the layouts. This may fail to lint for some\n-                            // incompatible types, but at the very least, will stop reads into\n-                            // uninitialised memory.\n-                            _ => compare_layouts(a, b),\n+                    }\n+                    (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n+                        // For arrays, we also check the constness of the type.\n+                        a_const.val == b_const.val\n+                            && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                    }\n+                    (Slice(a_ty), Slice(b_ty)) => {\n+                        structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                    }\n+                    (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n+                        a_tymut.mutbl == b_tymut.mutbl\n+                            && structurally_same_type_impl(\n+                                seen_types,\n+                                cx,\n+                                &a_tymut.ty,\n+                                &b_tymut.ty,\n+                                ckind,\n+                            )\n+                    }\n+                    (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n+                        // For structural sameness, we don't need the region to be same.\n+                        a_mut == b_mut\n+                            && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                    }\n+                    (FnDef(..), FnDef(..)) => {\n+                        let a_poly_sig = a.fn_sig(tcx);\n+                        let b_poly_sig = b.fn_sig(tcx);\n+\n+                        // As we don't compare regions, skip_binder is fine.\n+                        let a_sig = a_poly_sig.skip_binder();\n+                        let b_sig = b_poly_sig.skip_binder();\n+\n+                        (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n+                            == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n+                            && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n+                                structurally_same_type_impl(seen_types, cx, a, b, ckind)\n+                            })\n+                            && structurally_same_type_impl(\n+                                seen_types,\n+                                cx,\n+                                a_sig.output(),\n+                                b_sig.output(),\n+                                ckind,\n+                            )\n+                    }\n+                    (Tuple(a_substs), Tuple(b_substs)) => {\n+                        a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                            structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                        })\n+                    }\n+                    // For these, it's not quite as easy to define structural-sameness quite so easily.\n+                    // For the purposes of this lint, take the conservative approach and mark them as\n+                    // not structurally same.\n+                    (Dynamic(..), Dynamic(..))\n+                    | (Error(..), Error(..))\n+                    | (Closure(..), Closure(..))\n+                    | (Generator(..), Generator(..))\n+                    | (GeneratorWitness(..), GeneratorWitness(..))\n+                    | (Projection(..), Projection(..))\n+                    | (Opaque(..), Opaque(..)) => false,\n+\n+                    // These definitely should have been caught above.\n+                    (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n+\n+                    // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n+                    // non-null field.\n+                    (Adt(..), other_kind) | (other_kind, Adt(..))\n+                        if is_primitive_or_pointer(other_kind) =>\n+                    {\n+                        let (primitive, adt) =\n+                            if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                        if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                            ty == primitive\n+                        } else {\n+                            compare_layouts(a, b)\n                         }\n-                    };\n-                    seen_types.mark_computed(a, b, result);\n-                    result\n+                    }\n+                    // Otherwise, just compare the layouts. This may fail to lint for some\n+                    // incompatible types, but at the very least, will stop reads into\n+                    // uninitialised memory.\n+                    _ => compare_layouts(a, b),\n                 }\n-            }\n+            };\n+            seen_types.mark_computed(a, b, result);\n+            result\n         }\n         let mut seen_types = SeenSet::new();\n         structurally_same_type_impl(&mut seen_types, cx, a, b, ckind)"}]}