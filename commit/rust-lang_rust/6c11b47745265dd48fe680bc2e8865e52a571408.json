{"sha": "6c11b47745265dd48fe680bc2e8865e52a571408", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMTFiNDc3NDUyNjVkZDQ4ZmU2ODBiYzJlODg2NWU1MmE1NzE0MDg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-15T20:30:13Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-29T16:45:32Z"}, "message": "remove the data from ClosureCandidate\n\nthe data serves no purpose - it can be recovered from the obligation -\nand I think may leak stale inference variables into global caches.", "tree": {"sha": "b44b0282fba306467995c8ad36970f8e8932d292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b44b0282fba306467995c8ad36970f8e8932d292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c11b47745265dd48fe680bc2e8865e52a571408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c11b47745265dd48fe680bc2e8865e52a571408", "html_url": "https://github.com/rust-lang/rust/commit/6c11b47745265dd48fe680bc2e8865e52a571408", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c11b47745265dd48fe680bc2e8865e52a571408/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be155d88e44c1e4cdacfc640448fc9305151ab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be155d88e44c1e4cdacfc640448fc9305151ab2", "html_url": "https://github.com/rust-lang/rust/commit/9be155d88e44c1e4cdacfc640448fc9305151ab2"}], "stats": {"total": 186, "additions": 80, "deletions": 106}, "files": [{"sha": "68b080ccb95da10c3440bfd69fcd2bf0789df228", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 80, "deletions": 106, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6c11b47745265dd48fe680bc2e8865e52a571408/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c11b47745265dd48fe680bc2e8865e52a571408/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6c11b47745265dd48fe680bc2e8865e52a571408", "patch": "@@ -194,13 +194,12 @@ enum SelectionCandidate<'tcx> {\n     ProjectionCandidate,\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression. The ty::ClosureKind informs the\n-    /// confirmation step what ClosureKind obligation to emit.\n-    ClosureCandidate(/* closure */ DefId, ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n+    /// generated for a `||` expression.\n+    ClosureCandidate,\n \n     /// Implementation of a `Generator` trait by one of the anonymous types\n     /// generated for a generator.\n-    GeneratorCandidate(/* function / closure */ DefId, ty::ClosureSubsts<'tcx>),\n+    GeneratorCandidate,\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -229,20 +228,12 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n             ObjectCandidate => ObjectCandidate,\n             BuiltinObjectCandidate => BuiltinObjectCandidate,\n             BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n+            ClosureCandidate => ClosureCandidate,\n+            GeneratorCandidate => GeneratorCandidate,\n \n             ParamCandidate(ref trait_ref) => {\n                 return tcx.lift(trait_ref).map(ParamCandidate);\n             }\n-            GeneratorCandidate(def_id, ref substs) => {\n-                return tcx.lift(substs).map(|substs| {\n-                    GeneratorCandidate(def_id, substs)\n-                });\n-            }\n-            ClosureCandidate(def_id, ref substs, kind) => {\n-                return tcx.lift(substs).map(|substs| {\n-                    ClosureCandidate(def_id, substs, kind)\n-                });\n-            }\n         })\n     }\n }\n@@ -1518,23 +1509,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n-        let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyGenerator(id, substs, _) => (id, substs),\n+        match self_ty.sty {\n+            ty::TyGenerator(..) => {\n+                debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n+                       self_ty,\n+                       obligation);\n+\n+                candidates.vec.push(GeneratorCandidate);\n+                Ok(())\n+            }\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_generator_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n             }\n             _ => { return Ok(()); }\n-        };\n-\n-        debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n-               self_ty,\n-               obligation);\n-\n-        candidates.vec.push(GeneratorCandidate(closure_def_id, substs));\n-\n-        Ok(())\n+        }\n     }\n \n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n@@ -1556,36 +1546,31 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // ok to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, substs) => (id, substs),\n+        match obligation.self_ty().skip_binder().sty {\n+            ty::TyClosure(closure_def_id, _) => {\n+                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n+                       kind, obligation);\n+                match self.infcx.closure_kind(closure_def_id) {\n+                    Some(closure_kind) => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n+                        if closure_kind.extends(kind) {\n+                            candidates.vec.push(ClosureCandidate);\n+                        }\n+                    }\n+                    None => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n+                        candidates.vec.push(ClosureCandidate);\n+                    }\n+                };\n+                Ok(())\n+            }\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n             }\n             _ => { return Ok(()); }\n-        };\n-\n-        debug!(\"assemble_unboxed_candidates: self_ty={:?} kind={:?} obligation={:?}\",\n-               self_ty,\n-               kind,\n-               obligation);\n-\n-        match self.infcx.closure_kind(closure_def_id) {\n-            Some(closure_kind) => {\n-                debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                if closure_kind.extends(kind) {\n-                    candidates.vec.push(ClosureCandidate(closure_def_id, substs, kind));\n-                }\n-            }\n-            None => {\n-                debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n-                candidates.vec.push(ClosureCandidate(closure_def_id, substs, kind));\n-            }\n         }\n-\n-        Ok(())\n     }\n \n     /// Implement one of the `Fn()` family for a fn pointer.\n@@ -1902,8 +1887,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                          when there are other valid candidates\");\n                 }\n                 ImplCandidate(..) |\n-                ClosureCandidate(..) |\n-                GeneratorCandidate(..) |\n+                ClosureCandidate |\n+                GeneratorCandidate |\n                 FnPointerCandidate |\n                 BuiltinObjectCandidate |\n                 BuiltinUnsizeCandidate |\n@@ -2245,15 +2230,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n             }\n \n-            ClosureCandidate(closure_def_id, substs, kind) => {\n-                let vtable_closure =\n-                    self.confirm_closure_candidate(obligation, closure_def_id, substs, kind)?;\n+            ClosureCandidate => {\n+                let vtable_closure = self.confirm_closure_candidate(obligation)?;\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n-            GeneratorCandidate(closure_def_id, substs) => {\n-                let vtable_generator =\n-                    self.confirm_generator_candidate(obligation, closure_def_id, substs)?;\n+            GeneratorCandidate => {\n+                let vtable_generator = self.confirm_generator_candidate(obligation)?;\n                 Ok(VtableGenerator(vtable_generator))\n             }\n \n@@ -2590,21 +2573,34 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_generator_candidate(&mut self,\n-                                 obligation: &TraitObligation<'tcx>,\n-                                 closure_def_id: DefId,\n-                                 substs: ty::ClosureSubsts<'tcx>)\n-                                 -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+                                   obligation: &TraitObligation<'tcx>)\n+                                   -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n+        // ok to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyGenerator(id, substs, _) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n+        };\n+\n         debug!(\"confirm_generator_candidate({:?},{:?},{:?})\",\n                obligation,\n                closure_def_id,\n                substs);\n \n+        let trait_ref =\n+            self.generator_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n             obligations\n-        } = self.generator_trait_ref(obligation, closure_def_id, substs);\n+        } = normalize_with_depth(self,\n+                                 obligation.param_env,\n+                                 obligation.cause.clone(),\n+                                 obligation.recursion_depth+1,\n+                                 &trait_ref);\n \n         debug!(\"confirm_generator_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n                closure_def_id,\n@@ -2624,22 +2620,36 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_closure_candidate(&mut self,\n-                                 obligation: &TraitObligation<'tcx>,\n-                                 closure_def_id: DefId,\n-                                 substs: ty::ClosureSubsts<'tcx>,\n-                                 kind: ty::ClosureKind)\n+                                 obligation: &TraitObligation<'tcx>)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_closure_candidate({:?},{:?},{:?})\",\n-               obligation,\n-               closure_def_id,\n-               substs);\n+        debug!(\"confirm_closure_candidate({:?})\", obligation);\n+\n+        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+            Some(k) => k,\n+            None => bug!(\"closure candidate for non-fn trait {:?}\", obligation)\n+        };\n+\n+        // ok to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyClosure(id, substs) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n+        };\n \n+        let trait_ref =\n+            self.closure_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n             mut obligations\n-        } = self.closure_trait_ref(obligation, closure_def_id, substs);\n+        } = normalize_with_depth(self,\n+                                 obligation.param_env,\n+                                 obligation.cause.clone(),\n+                                 obligation.recursion_depth+1,\n+                                 &trait_ref);\n \n         debug!(\"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n                closure_def_id,\n@@ -3106,24 +3116,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         ty::Binder(trait_ref)\n     }\n \n-    fn closure_trait_ref(&mut self,\n-                         obligation: &TraitObligation<'tcx>,\n-                         closure_def_id: DefId,\n-                         substs: ty::ClosureSubsts<'tcx>)\n-                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n-    {\n-        let trait_ref = self.closure_trait_ref_unnormalized(\n-            obligation, closure_def_id, substs);\n-\n-        // A closure signature can contain associated types which\n-        // must be normalized.\n-        normalize_with_depth(self,\n-                             obligation.param_env,\n-                             obligation.cause.clone(),\n-                             obligation.recursion_depth+1,\n-                             &trait_ref)\n-    }\n-\n     fn generator_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: DefId,\n@@ -3145,24 +3137,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         ty::Binder(trait_ref)\n     }\n \n-    fn generator_trait_ref(&mut self,\n-                         obligation: &TraitObligation<'tcx>,\n-                         closure_def_id: DefId,\n-                         substs: ty::ClosureSubsts<'tcx>)\n-                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n-    {\n-        let trait_ref = self.generator_trait_ref_unnormalized(\n-            obligation, closure_def_id, substs);\n-\n-        // A generator signature can contain associated types which\n-        // must be normalized.\n-        normalize_with_depth(self,\n-                             obligation.param_env,\n-                             obligation.cause.clone(),\n-                             obligation.recursion_depth+1,\n-                             &trait_ref)\n-    }\n-\n     /// Returns the obligations that are implied by instantiating an\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default"}]}