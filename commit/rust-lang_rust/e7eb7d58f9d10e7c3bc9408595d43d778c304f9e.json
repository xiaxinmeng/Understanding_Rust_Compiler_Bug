{"sha": "e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZWI3ZDU4ZjlkMTBlN2MzYmM5NDA4NTk1ZDQzZDc3OGMzMDRmOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-20T11:55:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-20T11:55:17Z"}, "message": "Auto merge of #27723 - mystor:vecdeque_drain_range, r=bluss\n\nThis is a WIP PR for my implementation of drain over the VecDeque data structure supporting ranges. It brings the VecDeque drain implementation in line with Vec's.\r\n\r\nTests haven't been written for the new function yet.", "tree": {"sha": "7ccbe3cffc68c810828ecd66c612f80d364557c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ccbe3cffc68c810828ecd66c612f80d364557c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "html_url": "https://github.com/rust-lang/rust/commit/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9d528534477281bab5cdd5b95e9c667f25ac21e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d528534477281bab5cdd5b95e9c667f25ac21e", "html_url": "https://github.com/rust-lang/rust/commit/a9d528534477281bab5cdd5b95e9c667f25ac21e"}, {"sha": "dec0ea08f786b5b07a2d9ca3e02e81efc87f442c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec0ea08f786b5b07a2d9ca3e02e81efc87f442c", "html_url": "https://github.com/rust-lang/rust/commit/dec0ea08f786b5b07a2d9ca3e02e81efc87f442c"}], "stats": {"total": 299, "additions": 280, "deletions": 19}, "files": [{"sha": "4cba1083fd99d1315e54ee334974224a207804d6", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 274, "deletions": 14, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "patch": "@@ -32,6 +32,8 @@ use core::cmp;\n \n use alloc::raw_vec::RawVec;\n \n+use super::range::RangeArgument;\n+\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n@@ -168,6 +170,117 @@ impl<T> VecDeque<T> {\n             len);\n     }\n \n+    /// Copies a potentially wrapping block of memory len long from src to dest.\n+    /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n+    /// most one continuous overlapping region between src and dest).\n+    unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n+        debug_assert!(\n+            (if src <= dst { dst - src } else { src - dst }) + len <= self.cap(),\n+            \"dst={} src={} len={} cap={}\", dst, src, len, self.cap());\n+\n+        if src == dst || len == 0 { return }\n+\n+        let dst_after_src = self.wrap_sub(dst, src) < len;\n+\n+        let src_pre_wrap_len = self.cap() - src;\n+        let dst_pre_wrap_len = self.cap() - dst;\n+        let src_wraps = src_pre_wrap_len < len;\n+        let dst_wraps = dst_pre_wrap_len < len;\n+\n+        match (dst_after_src, src_wraps, dst_wraps) {\n+            (_, false, false) => {\n+                // src doesn't wrap, dst doesn't wrap\n+                //\n+                //        S . . .\n+                // 1 [_ _ A A B B C C _]\n+                // 2 [_ _ A A A A B B _]\n+                //            D . . .\n+                //\n+                self.copy(dst, src, len);\n+            }\n+            (false, false, true) => {\n+                // dst before src, src doesn't wrap, dst wraps\n+                //\n+                //    S . . .\n+                // 1 [A A B B _ _ _ C C]\n+                // 2 [A A B B _ _ _ A A]\n+                // 3 [B B B B _ _ _ A A]\n+                //    . .           D .\n+                //\n+                self.copy(dst, src, dst_pre_wrap_len);\n+                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+            }\n+            (true, false, true) => {\n+                // src before dst, src doesn't wrap, dst wraps\n+                //\n+                //              S . . .\n+                // 1 [C C _ _ _ A A B B]\n+                // 2 [B B _ _ _ A A B B]\n+                // 3 [B B _ _ _ A A A A]\n+                //    . .           D .\n+                //\n+                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                self.copy(dst, src, dst_pre_wrap_len);\n+            }\n+            (false, true, false) => {\n+                // dst before src, src wraps, dst doesn't wrap\n+                //\n+                //    . .           S .\n+                // 1 [C C _ _ _ A A B B]\n+                // 2 [C C _ _ _ B B B B]\n+                // 3 [C C _ _ _ B B C C]\n+                //              D . . .\n+                //\n+                self.copy(dst, src, src_pre_wrap_len);\n+                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+            }\n+            (true, true, false) => {\n+                // src before dst, src wraps, dst doesn't wrap\n+                //\n+                //    . .           S .\n+                // 1 [A A B B _ _ _ C C]\n+                // 2 [A A A A _ _ _ C C]\n+                // 3 [C C A A _ _ _ C C]\n+                //    D . . .\n+                //\n+                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                self.copy(dst, src, src_pre_wrap_len);\n+            }\n+            (false, true, true) => {\n+                // dst before src, src wraps, dst wraps\n+                //\n+                //    . . .         S .\n+                // 1 [A B C D _ E F G H]\n+                // 2 [A B C D _ E G H H]\n+                // 3 [A B C D _ E G H A]\n+                // 4 [B C C D _ E G H A]\n+                //    . .         D . .\n+                //\n+                debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n+                let delta = dst_pre_wrap_len - src_pre_wrap_len;\n+                self.copy(dst, src, src_pre_wrap_len);\n+                self.copy(dst + src_pre_wrap_len, 0, delta);\n+                self.copy(0, delta, len - dst_pre_wrap_len);\n+            }\n+            (true, true, true) => {\n+                // src before dst, src wraps, dst wraps\n+                //\n+                //    . .         S . .\n+                // 1 [A B C D _ E F G H]\n+                // 2 [A A B D _ E F G H]\n+                // 3 [H A B D _ E F G H]\n+                // 4 [H A B D _ E F F G]\n+                //    . . .         D .\n+                //\n+                debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n+                let delta = src_pre_wrap_len - dst_pre_wrap_len;\n+                self.copy(delta, 0, len - src_pre_wrap_len);\n+                self.copy(0, self.cap() - delta, delta);\n+                self.copy(dst, src, dst_pre_wrap_len);\n+            }\n+        }\n+    }\n+\n     /// Frobs the head and tail sections around to handle the fact that we\n     /// just reallocated. Unsafe because it trusts old_cap.\n     #[inline]\n@@ -613,8 +726,18 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Creates a draining iterator that clears the `VecDeque` and iterates over\n-    /// the removed items from start to end.\n+    /// Create a draining iterator that removes the specified range in the\n+    /// `VecDeque` and yields the removed items from start to end. The element\n+    /// range is removed even if the iterator is not consumed until the end.\n+    ///\n+    /// Note: It is unspecified how many elements are removed from the deque,\n+    /// if the `Drain` value is not dropped, but the borrow it holds expires\n+    /// (eg. due to mem::forget).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n     ///\n     /// # Examples\n     ///\n@@ -623,18 +746,66 @@ impl<T> VecDeque<T> {\n     ///\n     /// use std::collections::VecDeque;\n     ///\n+    /// // draining using `..` clears the whole deque.\n     /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n-    /// assert_eq!(v.drain().next(), Some(1));\n+    /// assert_eq!(v.drain(..).next(), Some(1));\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27711\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+        // Memory safety\n+        //\n+        // When the Drain is first created, the source deque is shortened to\n+        // make sure no uninitialized or moved-from elements are accessible at\n+        // all if the Drain's destructor never gets to run.\n+        //\n+        // Drain will ptr::read out the values to remove.\n+        // When finished, the remaining data will be copied back to cover the hole,\n+        // and the head/tail values will be restored correctly.\n+        //\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+        assert!(start <= end, \"drain lower bound was too large\");\n+        assert!(end <= len, \"drain upper bound was too large\");\n+\n+        // The deque's elements are parted into three segments:\n+        // * self.tail  -> drain_tail\n+        // * drain_tail -> drain_head\n+        // * drain_head -> self.head\n+        //\n+        // T = self.tail; H = self.head; t = drain_tail; h = drain_head\n+        //\n+        // We store drain_tail as self.head, and drain_head and self.head as\n+        // after_tail and after_head respectively on the Drain. This also\n+        // truncates the effective array such that if the Drain is leaked, we\n+        // have forgotten about the potentially moved values after the start of\n+        // the drain.\n+        //\n+        //        T   t   h   H\n+        // [. . . o o x x o o . . .]\n+        //\n+        let drain_tail = self.wrap_add(self.tail, start);\n+        let drain_head = self.wrap_add(self.tail, end);\n+        let head = self.head;\n+\n+        // \"forget\" about the values after the start of the drain until after\n+        // the drain is complete and the Drain destructor is run.\n+        self.head = drain_tail;\n+\n         Drain {\n-            inner: self,\n+            deque: self as *mut _,\n+            after_tail: drain_head,\n+            after_head: head,\n+            iter: Iter {\n+                tail: drain_tail,\n+                head: drain_head,\n+                ring: unsafe { self.buffer_as_mut_slice() },\n+            },\n         }\n     }\n \n@@ -653,7 +824,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n-        self.drain();\n+        self.drain(..);\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n@@ -1393,7 +1564,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // naive impl\n-        self.extend(other.drain());\n+        self.extend(other.drain(..));\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1627,15 +1798,59 @@ impl<T> ExactSizeIterator for IntoIter<T> {}\n            reason = \"matches collection reform specification, waiting for dust to settle\",\n            issue = \"27711\")]\n pub struct Drain<'a, T: 'a> {\n-    inner: &'a mut VecDeque<T>,\n+    after_tail: usize,\n+    after_head: usize,\n+    iter: Iter<'a, T>,\n+    deque: *mut VecDeque<T>,\n }\n \n+unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n+unsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n-        self.inner.head = 0;\n-        self.inner.tail = 0;\n+\n+        let source_deque = unsafe { &mut *self.deque };\n+\n+        // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n+        //\n+        //        T   t   h   H\n+        // [. . . o o x x o o . . .]\n+        //\n+        let orig_tail = source_deque.tail;\n+        let drain_tail = source_deque.head;\n+        let drain_head = self.after_tail;\n+        let orig_head = self.after_head;\n+\n+        let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n+        let head_len = count(drain_head, orig_head, source_deque.cap());\n+\n+        // Restore the original head value\n+        source_deque.head = orig_head;\n+\n+        match (tail_len, head_len) {\n+            (0, 0) => {\n+                source_deque.head = 0;\n+                source_deque.tail = 0;\n+            }\n+            (0, _) => {\n+                source_deque.tail = drain_head;\n+            }\n+            (_, 0) => {\n+                source_deque.head = drain_tail;\n+            }\n+            _ => unsafe {\n+                if tail_len <= head_len {\n+                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                } else {\n+                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -1645,21 +1860,28 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.inner.pop_front()\n+        self.iter.next().map(|elt|\n+            unsafe {\n+                ptr::read(elt)\n+            }\n+        )\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len();\n-        (len, Some(len))\n+        self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.inner.pop_back()\n+        self.iter.next_back().map(|elt|\n+            unsafe {\n+                ptr::read(elt)\n+            }\n+        )\n     }\n }\n \n@@ -1962,6 +2184,44 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_drain() {\n+        let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+        let cap = tester.capacity();\n+        for len in 0..cap + 1 {\n+            for tail in 0..cap + 1 {\n+                for drain_start in 0..len + 1 {\n+                    for drain_end in drain_start..len + 1 {\n+                        tester.tail = tail;\n+                        tester.head = tail;\n+                        for i in 0..len {\n+                            tester.push_back(i);\n+                        }\n+\n+                        // Check that we drain the correct values\n+                        let drained: VecDeque<_> =\n+                            tester.drain(drain_start..drain_end).collect();\n+                        let drained_expected: VecDeque<_> =\n+                            (drain_start..drain_end).collect();\n+                        assert_eq!(drained, drained_expected);\n+\n+                        // We shouldn't have changed the capacity or made the\n+                        // head or tail out of bounds\n+                        assert_eq!(tester.capacity(), cap);\n+                        assert!(tester.tail < tester.cap());\n+                        assert!(tester.head < tester.cap());\n+\n+                        // We should see the correct values in the VecDeque\n+                        let expected: VecDeque<_> =\n+                            (0..drain_start).chain(drain_end..len).collect();\n+                        assert_eq!(expected, tester);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_shrink_to_fit() {\n         // This test checks that every single combination of head and tail position,"}, {"sha": "5f587789bd865ae86d1abdc3b15b80c6ce95fef7", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "patch": "@@ -475,7 +475,7 @@ fn test_drain() {\n         let mut d: VecDeque<i32> = VecDeque::new();\n \n         {\n-            let mut iter = d.drain();\n+            let mut iter = d.drain(..);\n \n             assert_eq!(iter.size_hint(), (0, Some(0)));\n             assert_eq!(iter.next(), None);\n@@ -492,7 +492,7 @@ fn test_drain() {\n             d.push_back(i);\n         }\n \n-        assert_eq!(d.drain().collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n+        assert_eq!(d.drain(..).collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n         assert!(d.is_empty());\n     }\n \n@@ -506,7 +506,7 @@ fn test_drain() {\n             d.push_front(i);\n         }\n \n-        assert_eq!(d.drain().collect::<Vec<_>>(), [8,7,6,0,1,2,3,4]);\n+        assert_eq!(d.drain(..).collect::<Vec<_>>(), [8,7,6,0,1,2,3,4]);\n         assert!(d.is_empty());\n     }\n \n@@ -521,7 +521,7 @@ fn test_drain() {\n         }\n \n         {\n-            let mut it = d.drain();\n+            let mut it = d.drain(..);\n             assert_eq!(it.size_hint(), (8, Some(8)));\n             assert_eq!(it.next(), Some(8));\n             assert_eq!(it.size_hint(), (7, Some(7)));"}, {"sha": "7fa592105c09d4900d14236fe028016c86cf9329", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7eb7d58f9d10e7c3bc9408595d43d778c304f9e/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=e7eb7d58f9d10e7c3bc9408595d43d778c304f9e", "patch": "@@ -93,7 +93,8 @@ fn main() {\n     }\n     all_sync_send!(EnumSet::<Foo>::new(), iter);\n \n-    all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, drain, into_iter);\n+    all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, into_iter);\n+    is_sync_send!(VecDeque::<usize>::new(), drain(..));\n \n     all_sync_send!(Vec::<usize>::new(), into_iter);\n     is_sync_send!(Vec::<usize>::new(), drain(..));"}]}