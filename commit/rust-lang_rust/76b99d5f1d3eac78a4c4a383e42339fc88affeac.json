{"sha": "76b99d5f1d3eac78a4c4a383e42339fc88affeac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Yjk5ZDVmMWQzZWFjNzhhNGM0YTM4M2U0MjMzOWZjODhhZmZlYWM=", "commit": {"author": {"name": "DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-13T01:07:54Z"}, "committer": {"name": "DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-13T01:07:54Z"}, "message": "Add Arc::new_cyclic", "tree": {"sha": "ef9c4055a0e14f6d03815e931e17148cf10bd3be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef9c4055a0e14f6d03815e931e17148cf10bd3be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76b99d5f1d3eac78a4c4a383e42339fc88affeac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76b99d5f1d3eac78a4c4a383e42339fc88affeac", "html_url": "https://github.com/rust-lang/rust/commit/76b99d5f1d3eac78a4c4a383e42339fc88affeac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76b99d5f1d3eac78a4c4a383e42339fc88affeac/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f3be7704a4ec7976fcd1272c728974243d29bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f3be7704a4ec7976fcd1272c728974243d29bd", "html_url": "https://github.com/rust-lang/rust/commit/18f3be7704a4ec7976fcd1272c728974243d29bd"}], "stats": {"total": 152, "additions": 148, "deletions": 4}, "files": [{"sha": "4a2c59d976bad830854016067e97e1b2b6f40ea5", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b99d5f1d3eac78a4c4a383e42339fc88affeac/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b99d5f1d3eac78a4c4a383e42339fc88affeac/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=76b99d5f1d3eac78a4c4a383e42339fc88affeac", "patch": "@@ -132,7 +132,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(associated_type_bounds)]\n-\n+#![feature(raw_ref_op)]\n // Allow testing this library\n \n #[cfg(test)]"}, {"sha": "45852aa41f9f2783058c1e1abc1a2cc52abfafc0", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/76b99d5f1d3eac78a4c4a383e42339fc88affeac/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b99d5f1d3eac78a4c4a383e42339fc88affeac/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=76b99d5f1d3eac78a4c4a383e42339fc88affeac", "patch": "@@ -328,6 +328,79 @@ impl<T> Arc<T> {\n         Self::from_inner(Box::leak(x).into())\n     }\n \n+    /// Constructs a new `Arc<T>` using a weak reference to itself. Attempting\n+  /// to upgrade the weak reference before this function returns will result\n+  /// in a `None` value. However, the weak reference may be cloned freely and\n+  /// stored for use at a later time.\n+  ///\n+  /// # Examples\n+  /// ```\n+  /// #![feature(arc_new_cyclic)]\n+  /// #![allow(dead_code)]\n+  ///\n+  /// use std::sync::{Arc, Weak};\n+  ///\n+  /// struct Foo {\n+  ///     me: Weak<Foo>,\n+  /// }\n+  ///\n+  /// let foo = Arc::new_cyclic(|me| Foo {\n+  ///     me: me.clone(),\n+  /// });\n+  /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_new_cyclic\", issue = \"none\")]\n+    pub fn new_cyclic(data_fn: impl FnOnce(&Weak<T>) -> T) -> Arc<T> {\n+        // Construct the inner in the \"uninitialized\" state with a single\n+        // weak reference.\n+        let uninit_ptr: NonNull<_> = Box::leak(box ArcInner {\n+            strong: atomic::AtomicUsize::new(0),\n+            weak: atomic::AtomicUsize::new(1),\n+            data: mem::MaybeUninit::<T>::uninit(),\n+        })\n+            .into();\n+        let init_ptr: NonNull<ArcInner<T>> = uninit_ptr.cast();\n+\n+        let weak = Weak { ptr: init_ptr };\n+\n+        // It's important we don't give up ownership of the weak pointer, or\n+        // else the memory might be freed by the time `data_fn` returns. If\n+        // we really wanted to pass ownership, we could create an additional\n+        // weak pointer for ourselves, but this would result in additional\n+        // updates to the weak reference count which might not be necessary\n+        // otherwise.\n+        let data = data_fn(&weak);\n+\n+        // Now we can properly initialize the inner value and turn our weak\n+        // reference into a strong reference.\n+        unsafe {\n+            let inner = init_ptr.as_ptr();\n+            ptr::write(&raw mut (*inner).data, data);\n+\n+            // The above write to the data field must be visible to any threads which\n+            // observe a non-zero strong count. Therefore we need at least \"Release\" ordering\n+            // in order to synchronize with the `compare_exchange_weak` in `Weak::upgrade`.\n+            //\n+            // \"Acquire\" ordering is not required. When considering the possible behaviours\n+            // of `data_fn` we only need to look at what it could do with a reference to a\n+            // non-upgradeable `Weak`:\n+            // - It can *clone* the `Weak`, increasing the weak reference count.\n+            // - It can drop those clones, decreasing the weak reference count (but never to zero).\n+            //\n+            // These side effects do not impact us in any way, and no other side effects are\n+            // possible with safe code alone.\n+            let prev_value = (*inner).strong.fetch_add(1, Release);\n+            debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n+        }\n+\n+        let strong = Arc::from_inner(init_ptr);\n+\n+        // Strong references should collectively own a shared weak reference,\n+        // so don't run the destructor for our old weak reference.\n+        mem::forget(weak);\n+        strong\n+    }\n+\n     /// Constructs a new `Arc` with uninitialized contents.\n     ///\n     /// # Examples\n@@ -1589,7 +1662,8 @@ impl<T: ?Sized> Weak<T> {\n     #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n-        // fetch_add because once the count hits 0 it must never be above 0.\n+        // fetch_add as this function should never take the reference count\n+        // from zero to one.\n         let inner = self.inner()?;\n \n         // Relaxed load because any write of 0 that we can observe\n@@ -1608,8 +1682,11 @@ impl<T: ?Sized> Weak<T> {\n                 abort();\n             }\n \n-            // Relaxed is valid for the same reason it is on Arc's Clone impl\n-            match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n+            // Relaxed is fine for the failure case because we don't have any expectations about the new state.\n+                // Acquire is necessary for the success case to synchronise with `Arc::new_cyclic`, when the inner\n+                // value can be initialized after `Weak` references have already been created. In that case, we\n+                // expect to observe the fully initialized value.\n+            match inner.strong.compare_exchange_weak(n, n + 1, Acquire, Relaxed) {\n                 Ok(_) => return Some(Arc::from_inner(self.ptr)), // null checked above\n                 Err(old) => n = old,\n             }"}, {"sha": "15fd1923581a3cf67eae5d13c4bcd725ec9fcd5b", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/76b99d5f1d3eac78a4c4a383e42339fc88affeac/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b99d5f1d3eac78a4c4a383e42339fc88affeac/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=76b99d5f1d3eac78a4c4a383e42339fc88affeac", "patch": "@@ -492,3 +492,70 @@ fn test_array_from_slice() {\n     let a: Result<Arc<[u32; 2]>, _> = r.clone().try_into();\n     assert!(a.is_err());\n }\n+\n+#[test]\n+fn test_arc_cyclic_with_zero_refs() {\n+    struct ZeroRefs {\n+        inner: Weak<ZeroRefs>,\n+    }\n+    let zero_refs = Arc::new_cyclic(|inner| {\n+        assert_eq!(inner.strong_count(), 0);\n+        assert!(inner.upgrade().is_none());\n+        ZeroRefs { inner: Weak::new() }\n+    });\n+\n+    assert_eq!(Arc::strong_count(&zero_refs), 1);\n+    assert_eq!(Arc::weak_count(&zero_refs), 0);\n+    assert_eq!(zero_refs.inner.strong_count(), 0);\n+    assert_eq!(zero_refs.inner.weak_count(), 0);\n+}\n+\n+#[test]\n+fn test_arc_new_cyclic_one_ref() {\n+    struct OneRef {\n+        inner: Weak<OneRef>,\n+    }\n+    let one_ref = Arc::new_cyclic(|inner| {\n+        assert_eq!(inner.strong_count(), 0);\n+        assert!(inner.upgrade().is_none());\n+        OneRef { inner: inner.clone() }\n+    });\n+\n+    assert_eq!(Arc::strong_count(&one_ref), 1);\n+    assert_eq!(Arc::weak_count(&one_ref), 1);\n+\n+    let one_ref2 = Weak::upgrade(&one_ref.inner).unwrap();\n+    assert!(Arc::ptr_eq(&one_ref, &one_ref2));\n+\n+    assert_eq!(Arc::strong_count(&one_ref), 2);\n+    assert_eq!(Arc::weak_count(&one_ref), 1);\n+}\n+\n+#[test]\n+fn test_arc_cyclic_two_refs() {\n+    struct TwoRefs {\n+        inner1: Weak<TwoRefs>,\n+        inner2: Weak<TwoRefs>,\n+    }\n+    let two_refs = Arc::new_cyclic(|inner| {\n+        assert_eq!(inner.strong_count(), 0);\n+        assert!(inner.upgrade().is_none());\n+\n+        let inner1 = inner.clone();\n+        let inner2 = inner1.clone();\n+\n+        TwoRefs { inner1, inner2 }\n+    });\n+\n+    assert_eq!(Arc::strong_count(&two_refs), 1);\n+    assert_eq!(Arc::weak_count(&two_refs), 2);\n+\n+    let two_refs1 = Weak::upgrade(&two_refs.inner1).unwrap();\n+    assert!(Arc::ptr_eq(&two_refs, &two_refs1));\n+\n+    let two_refs2 = Weak::upgrade(&two_refs.inner2).unwrap();\n+    assert!(Arc::ptr_eq(&two_refs, &two_refs2));\n+\n+    assert_eq!(Arc::strong_count(&two_refs), 3);\n+    assert_eq!(Arc::weak_count(&two_refs), 2);\n+}\n\\ No newline at end of file"}]}